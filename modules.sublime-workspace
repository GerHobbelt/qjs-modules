{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"JS_VALUE",
				"JS_VALUE_GET_PTR"
			],
			[
				"JS_NewObj",
				"JS_NewObjectProtoClass"
			],
			[
				"JS_Throw",
				"JS_ThrowOutOfMemory"
			],
			[
				"JS_Set",
				"JS_SetPropertyStr"
			],
			[
				"module_",
				"module_func"
			],
			[
				"initiali",
				"initialization"
			],
			[
				"qjsm_sock",
				"qjsm_socklen_t_size"
			],
			[
				"getCas",
				"getClassConstructor"
			],
			[
				"JS_Get",
				"JS_GetPropertyUint32"
			],
			[
				"JS_GetP",
				"JS_GetPropertyUint32"
			],
			[
				"js_syscall",
				"js_syscallerror_proto_funcs"
			],
			[
				"syscal",
				"syscallerror_proto"
			],
			[
				"JS_SetProper",
				"JS_SetPropertyStr"
			],
			[
				"JS_SetP",
				"JS_SetPropertyUint32"
			],
			[
				"JS_CGET",
				"JS_CGETSET_ENUMERABLE_DEF"
			],
			[
				"sys",
				"syscallerror_ctor"
			],
			[
				"js_sys",
				"js_syscallerror_get"
			],
			[
				"JS_Th",
				"JS_ThrowOutOfMemory"
			],
			[
				"Sys",
				"SyscallError"
			],
			[
				"JS_CGETSET",
				"JS_CGETSET_MAGIC_DEF"
			],
			[
				"JS_T",
				"JS_ThrowTypeError"
			],
			[
				"JS_Thro",
				"JS_ThrowOutOfMemory"
			],
			[
				"js_",
				"js_sockaddr_class_id"
			],
			[
				"STRING",
				"STRINGDECODER_ENCODING"
			],
			[
				"STRINGDECODER_EN",
				"STRINGDECODER_ENCODING"
			],
			[
				"STRINGDE",
				"STRINGDECODER_END"
			],
			[
				"JS_Free",
				"JS_FreeCString"
			],
			[
				"JS_New",
				"JS_NewStringLen"
			],
			[
				"JS_",
				"JS_GetPropertyUint32"
			],
			[
				"ringbuffer_",
				"ringbuffer_continuous_length"
			],
			[
				"string",
				"stringdecoder_proto"
			],
			[
				"get",
				"getOwnPropertyNames"
			],
			[
				"JS_Thr",
				"JS_ThrowInternalError"
			],
			[
				"ringbuffer_res",
				"ringbuffer_resize"
			],
			[
				"ringb",
				"ringbuffer_normalize"
			],
			[
				"ringbuffer",
				"ringbuffer_length"
			],
			[
				"ring",
				"ringbuffer_full"
			],
			[
				"STRINGDEC",
				"STRINGDECODER_END"
			],
			[
				"Ar",
				"ArchiveEntryRef"
			],
			[
				"js_archive",
				"js_archiveentry_data"
			],
			[
				"ARC",
				"ARCHIVE_METHOD_READ"
			],
			[
				"CMAKE_CURREN",
				"CMAKE_CURRENT_BINARY_DIR"
			],
			[
				"getCommand",
				"getCommandExecutable"
			],
			[
				"SYS",
				"SYSCALLERROR_ERRNO"
			],
			[
				"SYSCALL",
				"SYSCALLERROR_SYSCALL"
			],
			[
				"FUNC_",
				"FUNC_GETUID"
			],
			[
				"predi",
				"predicates"
			],
			[
				"int64_t",
				"uint64_t"
			],
			[
				"PRECEDENCE_LOG",
				"PRECEDENCE_LOGICAL_NOT"
			],
			[
				"js_is",
				"js_is_null_or_undefined"
			],
			[
				"js_set_to",
				"js_set_tostringtag_value"
			],
			[
				"Predicate",
				"PredicateOperatorSet"
			],
			[
				"Predi",
				"PredicateOperatorSet"
			],
			[
				"JS_P",
				"JS_PROP_CONFIGURABLE"
			],
			[
				"operat",
				"operators_set"
			],
			[
				"JS_SetProp",
				"JS_SetPropertyUint32"
			],
			[
				"break",
				"stringBreakNewline"
			],
			[
				"define",
				"defineProperty"
			],
			[
				"Event",
				"EventEmitter"
			],
			[
				"sy",
				"syntaxerror_ctor"
			],
			[
				"child_pr",
				"child_process_proto"
			],
			[
				"targtet_",
				"target_compile_definitions"
			],
			[
				"jsm_module",
				"jsm_module_loader_so"
			],
			[
				"base",
				"base_name"
			],
			[
				"ATOM",
				"ATOM_TO_VALUE"
			],
			[
				"prop",
				"propenum_tab"
			],
			[
				"js_loca",
				"js_location_data"
			],
			[
				"loca",
				"location_proto"
			],
			[
				"HAVE_QUI",
				"HAVE_QUICKJS_LIBRARY"
			],
			[
				"jsm_load",
				"jsm_load_packages_json"
			],
			[
				"js_sy",
				"js_syntaxerror_class_id"
			],
			[
				"synta",
				"syntaxerror_proto"
			],
			[
				"property_",
				"property_enumeration_key"
			],
			[
				"jsm_mo",
				"jsm_module_loader_path"
			],
			[
				"inspe",
				"inspect_custom_node"
			],
			[
				"inspect",
				"inspect_custom_node"
			],
			[
				"property",
				"property_enumeration_circular"
			],
			[
				"Reg",
				"RegExpCompare"
			],
			[
				"property_enum",
				"property_enumeration_length"
			],
			[
				"Opera",
				"OperatorsObjects"
			],
			[
				"else",
				"elseif"
			],
			[
				"ABC",
				"ABCDEF"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "—Ⓒ– pcg_state_setseq_64 { … } ; — type\n  Ⓣ  pcg32_random_t ; — typedef\n—Ⓕ– pcg32_random_r ( ) { … } — function\n—Ⓕ– pcg32_random ( ) { … } — function\n—Ⓕ– pcg32_init_state ( ) { … } — function\n—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function\n—Ⓕ– js_bytecode_free_func ( ) { … } — function\n—Ⓕ– js_string_free_func ( ) { … } — function\n—Ⓕ– js_arraybuffer_free_func ( ) { … } — function\n—Ⓕ– js_misc_tostring ( ) { … } — function\n—Ⓕ– js_misc_topointer ( ) { … } — function\n—Ⓕ– js_misc_toarraybuffer ( ) { … } — function\n—Ⓕ– js_misc_duparraybuffer ( ) { … } — function\n—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function\n—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function\n—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function\n—Ⓕ– js_misc_getperformancecounter ( ) { … } — function\n—Ⓕ– js_misc_proclink ( ) { … } — function\n—Ⓕ– js_misc_procread ( ) { … } — function\n—Ⓕ– js_misc_getprototypechain ( ) { … } — function\n—Ⓕ– js_misc_hrtime ( ) { … } — function\n—Ⓕ– js_misc_fnmatch ( ) { … } — function\n—Ⓕ– js_misc_uname ( ) { … } — function\n—Ⓕ– js_misc_btoa ( ) { … } — function\n—Ⓕ– js_misc_atob ( ) { … } — function\n—Ⓕ– js_misc_compile ( ) { … } — function\n—Ⓕ– js_misc_write_object ( ) { … } — function\n—Ⓕ– js_misc_read_object ( ) { … } — function\n—Ⓕ– js_misc_getx ( ) { … } — function\n—Ⓕ– js_misc_valuetype ( ) { … } — function\n—Ⓕ– js_misc_evalbinary ( ) { … } — function\n—Ⓕ– js_misc_opcode_array ( ) { … } — function\n—Ⓕ– js_misc_opcode_object ( ) { … } — function\n—Ⓕ– js_misc_opcodes ( ) { … } — function\n—Ⓕ– js_misc_get_bytecode ( ) { … } — function\n—Ⓕ– js_misc_atom ( ) { … } — function\n—Ⓕ– js_misc_classid ( ) { … } — function\n—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function\n—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function\n—Ⓕ– js_misc_random ( ) { … } — function\n—Ⓕ– js_misc_escape ( ) { … } — function\n—Ⓕ– js_misc_quote ( ) { … } — function\n—Ⓕ– js_misc_error ( ) { … } — function\n—Ⓕ– js_misc_is ( ) { … } — function\n—Ⓕ– js_misc_init ( ) { … } — function\n  Ⓜ  JS_INIT_MODULE … — macro object\n  Ⓜ  JS_INIT_MODULE … — macro object",
			"settings":
			{
				"buffer_size": 2034,
				"line_ending": "Unix",
				"name": "𝌆 Outline",
				"scratch": true
			},
			"undo_stack":
			[
				[
					42,
					2,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
						"symkeys":
						[
							[
								644,
								663
							],
							[
								691,
								705
							],
							[
								817,
								831
							],
							[
								1140,
								1152
							],
							[
								1216,
								1232
							],
							[
								1329,
								1362
							],
							[
								1841,
								1862
							],
							[
								1943,
								1962
							],
							[
								2094,
								2118
							],
							[
								2257,
								2273
							],
							[
								2925,
								2942
							],
							[
								3474,
								3495
							],
							[
								4363,
								4385
							],
							[
								5061,
								5086
							],
							[
								5856,
								5881
							],
							[
								6555,
								6580
							],
							[
								7803,
								7832
							],
							[
								8071,
								8087
							],
							[
								8968,
								8984
							],
							[
								10087,
								10112
							],
							[
								10556,
								10570
							],
							[
								11704,
								11719
							],
							[
								12190,
								12203
							],
							[
								12797,
								12809
							],
							[
								13215,
								13227
							],
							[
								13642,
								13657
							],
							[
								14738,
								14758
							],
							[
								15097,
								15116
							],
							[
								15335,
								15347
							],
							[
								17600,
								17617
							],
							[
								18215,
								18233
							],
							[
								19445,
								19465
							],
							[
								19926,
								19947
							],
							[
								20421,
								20436
							],
							[
								20929,
								20949
							],
							[
								21408,
								21420
							],
							[
								22139,
								22154
							],
							[
								23653,
								23678
							],
							[
								24217,
								24242
							],
							[
								25494,
								25508
							],
							[
								26421,
								26435
							],
							[
								26727,
								26740
							],
							[
								29119,
								29132
							],
							[
								30039,
								30049
							],
							[
								38454,
								38466
							],
							[
								38996,
								39010
							],
							[
								39040,
								39054
							]
						],
						"symlist":
						[
							"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
							" Ⓣ  pcg32_random_t ; — typedef",
							"—Ⓕ– pcg32_random_r ( ) { … } — function",
							"—Ⓕ– pcg32_random ( ) { … } — function",
							"—Ⓕ– pcg32_init_state ( ) { … } — function",
							"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
							"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
							"—Ⓕ– js_string_free_func ( ) { … } — function",
							"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
							"—Ⓕ– js_misc_tostring ( ) { … } — function",
							"—Ⓕ– js_misc_topointer ( ) { … } — function",
							"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
							"—Ⓕ– js_misc_proclink ( ) { … } — function",
							"—Ⓕ– js_misc_procread ( ) { … } — function",
							"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
							"—Ⓕ– js_misc_hrtime ( ) { … } — function",
							"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
							"—Ⓕ– js_misc_uname ( ) { … } — function",
							"—Ⓕ– js_misc_btoa ( ) { … } — function",
							"—Ⓕ– js_misc_atob ( ) { … } — function",
							"—Ⓕ– js_misc_compile ( ) { … } — function",
							"—Ⓕ– js_misc_write_object ( ) { … } — function",
							"—Ⓕ– js_misc_read_object ( ) { … } — function",
							"—Ⓕ– js_misc_getx ( ) { … } — function",
							"—Ⓕ– js_misc_valuetype ( ) { … } — function",
							"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
							"—Ⓕ– js_misc_opcodes ( ) { … } — function",
							"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
							"—Ⓕ– js_misc_atom ( ) { … } — function",
							"—Ⓕ– js_misc_classid ( ) { … } — function",
							"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
							"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
							"—Ⓕ– js_misc_random ( ) { … } — function",
							"—Ⓕ– js_misc_escape ( ) { … } — function",
							"—Ⓕ– js_misc_quote ( ) { … } — function",
							"—Ⓕ– js_misc_error ( ) { … } — function",
							"—Ⓕ– js_misc_is ( ) { … } — function",
							"—Ⓕ– js_misc_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"BAAAAAAAAAAAAAAAAAAAAAAAAAC6CQAA4oCU4pK44oCTIHBjZ19zdGF0ZV9zZXRzZXFfNjQgeyDigKYgfSA7IOKAlCB0eXBlCiAg4pOJICBwY2czMl9yYW5kb21fdCA7IOKAlCB0eXBlZGVmCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX2luaXRfc3RhdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fYm91bmRlZF9kaXZpc2lvbmxlc3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ieXRlY29kZV9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdHJpbmdfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b3N0cmluZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9wb2ludGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b2FycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19kdXBhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVzaXplYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NvbmNhdGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19zZWFyY2hhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY3JlYWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHByb3RvdHlwZWNoYWluICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ocnRpbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2ZubWF0Y2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3VuYW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19idG9hICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9iICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb21waWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY193cml0ZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JlYWRfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXR4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY192YWx1ZXR5cGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2V2YWxiaW5hcnkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0X2J5dGVjb2RlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jbGFzc2lkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19iaXRmaWVsZF90b19hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXJyYXlfdG9fYml0ZmllbGQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXNjYXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19xdW90ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2lzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pbml0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0AAAAAAAAAADyBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugkAAOKAlOKSuOKAkyBwY2dfc3RhdGVfc2V0c2VxXzY0IHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcGNnMzJfcmFuZG9tX3QgOyDigJQgdHlwZWRlZgrigJTikrvigJMgcGNnMzJfcmFuZG9tX3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9pbml0X3N0YXRlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcGNnMzJfcmFuZG9tX2JvdW5kZWRfZGl2aXNpb25sZXNzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYnl0ZWNvZGVfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RyaW5nX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX2FycmF5YnVmZmVyX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9zdHJpbmcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3RvcG9pbnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9hcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZHVwYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Jlc2l6ZWFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb25jYXRhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfc2VhcmNoYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHBlcmZvcm1hbmNlY291bnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY2xpbmsgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Byb2NyZWFkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXRwcm90b3R5cGVjaGFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaHJ0aW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19mbm1hdGNoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY191bmFtZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYnRvYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvYiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY29tcGlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfd3JpdGVfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yZWFkX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0eCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdmFsdWV0eXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ldmFsYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19vcGNvZGVfYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldF9ieXRlY29kZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY2xhc3NpZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYml0ZmllbGRfdG9fYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2FycmF5X3RvX2JpdGZpZWxkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2VzY2FwZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcXVvdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBKU19JTklUX01PRFVMRSDigKYg4oCUIG1hY3JvIG9iamVjdAAAAAAAAAAA8gcAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					43,
					2,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
						"symkeys":
						[
							[
								644,
								663
							],
							[
								691,
								705
							],
							[
								817,
								831
							],
							[
								1140,
								1152
							],
							[
								1216,
								1232
							],
							[
								1329,
								1362
							],
							[
								1841,
								1862
							],
							[
								1943,
								1962
							],
							[
								2094,
								2118
							],
							[
								2257,
								2273
							],
							[
								2925,
								2942
							],
							[
								3474,
								3495
							],
							[
								4363,
								4385
							],
							[
								5061,
								5086
							],
							[
								5856,
								5881
							],
							[
								6555,
								6580
							],
							[
								7803,
								7832
							],
							[
								8071,
								8087
							],
							[
								8968,
								8984
							],
							[
								10087,
								10112
							],
							[
								10556,
								10570
							],
							[
								11704,
								11719
							],
							[
								12190,
								12203
							],
							[
								12797,
								12809
							],
							[
								13215,
								13227
							],
							[
								13642,
								13657
							],
							[
								14738,
								14758
							],
							[
								15097,
								15116
							],
							[
								15335,
								15347
							],
							[
								17600,
								17617
							],
							[
								18215,
								18233
							],
							[
								19445,
								19465
							],
							[
								19926,
								19947
							],
							[
								20421,
								20436
							],
							[
								20929,
								20949
							],
							[
								21408,
								21420
							],
							[
								22139,
								22154
							],
							[
								23653,
								23678
							],
							[
								24217,
								24242
							],
							[
								25494,
								25508
							],
							[
								26421,
								26435
							],
							[
								26727,
								26740
							],
							[
								29119,
								29132
							],
							[
								30039,
								30049
							],
							[
								38454,
								38466
							],
							[
								38996,
								39010
							],
							[
								39040,
								39054
							]
						],
						"symlist":
						[
							"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
							" Ⓣ  pcg32_random_t ; — typedef",
							"—Ⓕ– pcg32_random_r ( ) { … } — function",
							"—Ⓕ– pcg32_random ( ) { … } — function",
							"—Ⓕ– pcg32_init_state ( ) { … } — function",
							"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
							"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
							"—Ⓕ– js_string_free_func ( ) { … } — function",
							"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
							"—Ⓕ– js_misc_tostring ( ) { … } — function",
							"—Ⓕ– js_misc_topointer ( ) { … } — function",
							"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
							"—Ⓕ– js_misc_proclink ( ) { … } — function",
							"—Ⓕ– js_misc_procread ( ) { … } — function",
							"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
							"—Ⓕ– js_misc_hrtime ( ) { … } — function",
							"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
							"—Ⓕ– js_misc_uname ( ) { … } — function",
							"—Ⓕ– js_misc_btoa ( ) { … } — function",
							"—Ⓕ– js_misc_atob ( ) { … } — function",
							"—Ⓕ– js_misc_compile ( ) { … } — function",
							"—Ⓕ– js_misc_write_object ( ) { … } — function",
							"—Ⓕ– js_misc_read_object ( ) { … } — function",
							"—Ⓕ– js_misc_getx ( ) { … } — function",
							"—Ⓕ– js_misc_valuetype ( ) { … } — function",
							"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
							"—Ⓕ– js_misc_opcodes ( ) { … } — function",
							"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
							"—Ⓕ– js_misc_atom ( ) { … } — function",
							"—Ⓕ– js_misc_classid ( ) { … } — function",
							"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
							"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
							"—Ⓕ– js_misc_random ( ) { … } — function",
							"—Ⓕ– js_misc_escape ( ) { … } — function",
							"—Ⓕ– js_misc_quote ( ) { … } — function",
							"—Ⓕ– js_misc_error ( ) { … } — function",
							"—Ⓕ– js_misc_is ( ) { … } — function",
							"—Ⓕ– js_misc_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"BAAAAAAAAAAAAAAAAAAAAAAAAAC6CQAA4oCU4pK44oCTIHBjZ19zdGF0ZV9zZXRzZXFfNjQgeyDigKYgfSA7IOKAlCB0eXBlCiAg4pOJICBwY2czMl9yYW5kb21fdCA7IOKAlCB0eXBlZGVmCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX2luaXRfc3RhdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fYm91bmRlZF9kaXZpc2lvbmxlc3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ieXRlY29kZV9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdHJpbmdfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b3N0cmluZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9wb2ludGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b2FycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19kdXBhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVzaXplYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NvbmNhdGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19zZWFyY2hhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY3JlYWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHByb3RvdHlwZWNoYWluICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ocnRpbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2ZubWF0Y2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3VuYW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19idG9hICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9iICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb21waWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY193cml0ZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JlYWRfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXR4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY192YWx1ZXR5cGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2V2YWxiaW5hcnkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0X2J5dGVjb2RlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jbGFzc2lkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19iaXRmaWVsZF90b19hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXJyYXlfdG9fYml0ZmllbGQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXNjYXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19xdW90ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2lzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pbml0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0AAAAAAAAAADyBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugkAAOKAlOKSuOKAkyBwY2dfc3RhdGVfc2V0c2VxXzY0IHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcGNnMzJfcmFuZG9tX3QgOyDigJQgdHlwZWRlZgrigJTikrvigJMgcGNnMzJfcmFuZG9tX3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9pbml0X3N0YXRlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcGNnMzJfcmFuZG9tX2JvdW5kZWRfZGl2aXNpb25sZXNzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYnl0ZWNvZGVfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RyaW5nX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX2FycmF5YnVmZmVyX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9zdHJpbmcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3RvcG9pbnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9hcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZHVwYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Jlc2l6ZWFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb25jYXRhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfc2VhcmNoYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHBlcmZvcm1hbmNlY291bnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY2xpbmsgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Byb2NyZWFkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXRwcm90b3R5cGVjaGFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaHJ0aW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19mbm1hdGNoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY191bmFtZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYnRvYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvYiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY29tcGlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfd3JpdGVfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yZWFkX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0eCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdmFsdWV0eXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ldmFsYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19vcGNvZGVfYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldF9ieXRlY29kZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY2xhc3NpZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYml0ZmllbGRfdG9fYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2FycmF5X3RvX2JpdGZpZWxkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2VzY2FwZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcXVvdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBKU19JTklUX01PRFVMRSDigKYg4oCUIG1hY3JvIG9iamVjdAAAAAAAAAAA8gcAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					44,
					2,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
						"symkeys":
						[
							[
								644,
								663
							],
							[
								691,
								705
							],
							[
								817,
								831
							],
							[
								1140,
								1152
							],
							[
								1216,
								1232
							],
							[
								1329,
								1362
							],
							[
								1841,
								1862
							],
							[
								1943,
								1962
							],
							[
								2094,
								2118
							],
							[
								2257,
								2273
							],
							[
								2925,
								2942
							],
							[
								3474,
								3495
							],
							[
								4363,
								4385
							],
							[
								5061,
								5086
							],
							[
								5856,
								5881
							],
							[
								6555,
								6580
							],
							[
								7804,
								7833
							],
							[
								8072,
								8088
							],
							[
								8969,
								8985
							],
							[
								10088,
								10113
							],
							[
								10557,
								10571
							],
							[
								11705,
								11720
							],
							[
								12191,
								12204
							],
							[
								12798,
								12810
							],
							[
								13216,
								13228
							],
							[
								13643,
								13658
							],
							[
								14739,
								14759
							],
							[
								15098,
								15117
							],
							[
								15336,
								15348
							],
							[
								17601,
								17618
							],
							[
								18216,
								18234
							],
							[
								19446,
								19466
							],
							[
								19927,
								19948
							],
							[
								20422,
								20437
							],
							[
								20930,
								20950
							],
							[
								21409,
								21421
							],
							[
								22140,
								22155
							],
							[
								23654,
								23679
							],
							[
								24218,
								24243
							],
							[
								25495,
								25509
							],
							[
								26422,
								26436
							],
							[
								26728,
								26741
							],
							[
								29120,
								29133
							],
							[
								30040,
								30050
							],
							[
								38455,
								38467
							],
							[
								38997,
								39011
							],
							[
								39041,
								39055
							]
						],
						"symlist":
						[
							"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
							" Ⓣ  pcg32_random_t ; — typedef",
							"—Ⓕ– pcg32_random_r ( ) { … } — function",
							"—Ⓕ– pcg32_random ( ) { … } — function",
							"—Ⓕ– pcg32_init_state ( ) { … } — function",
							"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
							"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
							"—Ⓕ– js_string_free_func ( ) { … } — function",
							"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
							"—Ⓕ– js_misc_tostring ( ) { … } — function",
							"—Ⓕ– js_misc_topointer ( ) { … } — function",
							"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
							"—Ⓕ– js_misc_proclink ( ) { … } — function",
							"—Ⓕ– js_misc_procread ( ) { … } — function",
							"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
							"—Ⓕ– js_misc_hrtime ( ) { … } — function",
							"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
							"—Ⓕ– js_misc_uname ( ) { … } — function",
							"—Ⓕ– js_misc_btoa ( ) { … } — function",
							"—Ⓕ– js_misc_atob ( ) { … } — function",
							"—Ⓕ– js_misc_compile ( ) { … } — function",
							"—Ⓕ– js_misc_write_object ( ) { … } — function",
							"—Ⓕ– js_misc_read_object ( ) { … } — function",
							"—Ⓕ– js_misc_getx ( ) { … } — function",
							"—Ⓕ– js_misc_valuetype ( ) { … } — function",
							"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
							"—Ⓕ– js_misc_opcodes ( ) { … } — function",
							"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
							"—Ⓕ– js_misc_atom ( ) { … } — function",
							"—Ⓕ– js_misc_classid ( ) { … } — function",
							"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
							"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
							"—Ⓕ– js_misc_random ( ) { … } — function",
							"—Ⓕ– js_misc_escape ( ) { … } — function",
							"—Ⓕ– js_misc_quote ( ) { … } — function",
							"—Ⓕ– js_misc_error ( ) { … } — function",
							"—Ⓕ– js_misc_is ( ) { … } — function",
							"—Ⓕ– js_misc_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"BAAAAAAAAAAAAAAAAAAAAAAAAAC6CQAA4oCU4pK44oCTIHBjZ19zdGF0ZV9zZXRzZXFfNjQgeyDigKYgfSA7IOKAlCB0eXBlCiAg4pOJICBwY2czMl9yYW5kb21fdCA7IOKAlCB0eXBlZGVmCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX2luaXRfc3RhdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fYm91bmRlZF9kaXZpc2lvbmxlc3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ieXRlY29kZV9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdHJpbmdfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b3N0cmluZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9wb2ludGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b2FycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19kdXBhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVzaXplYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NvbmNhdGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19zZWFyY2hhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY3JlYWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHByb3RvdHlwZWNoYWluICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ocnRpbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2ZubWF0Y2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3VuYW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19idG9hICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9iICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb21waWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY193cml0ZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JlYWRfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXR4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY192YWx1ZXR5cGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2V2YWxiaW5hcnkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0X2J5dGVjb2RlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jbGFzc2lkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19iaXRmaWVsZF90b19hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXJyYXlfdG9fYml0ZmllbGQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXNjYXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19xdW90ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2lzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pbml0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0AAAAAAAAAADyBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugkAAOKAlOKSuOKAkyBwY2dfc3RhdGVfc2V0c2VxXzY0IHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcGNnMzJfcmFuZG9tX3QgOyDigJQgdHlwZWRlZgrigJTikrvigJMgcGNnMzJfcmFuZG9tX3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9pbml0X3N0YXRlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcGNnMzJfcmFuZG9tX2JvdW5kZWRfZGl2aXNpb25sZXNzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYnl0ZWNvZGVfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RyaW5nX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX2FycmF5YnVmZmVyX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9zdHJpbmcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3RvcG9pbnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9hcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZHVwYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Jlc2l6ZWFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb25jYXRhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfc2VhcmNoYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHBlcmZvcm1hbmNlY291bnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY2xpbmsgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Byb2NyZWFkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXRwcm90b3R5cGVjaGFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaHJ0aW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19mbm1hdGNoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY191bmFtZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYnRvYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvYiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY29tcGlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfd3JpdGVfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yZWFkX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0eCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdmFsdWV0eXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ldmFsYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19vcGNvZGVfYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldF9ieXRlY29kZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY2xhc3NpZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYml0ZmllbGRfdG9fYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2FycmF5X3RvX2JpdGZpZWxkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2VzY2FwZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcXVvdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBKU19JTklUX01PRFVMRSDigKYg4oCUIG1hY3JvIG9iamVjdAAAAAAAAAAA8gcAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					45,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
						"symkeys":
						[
							[
								644,
								663
							],
							[
								691,
								705
							],
							[
								817,
								831
							],
							[
								1140,
								1152
							],
							[
								1216,
								1232
							],
							[
								1329,
								1362
							],
							[
								1841,
								1862
							],
							[
								1943,
								1962
							],
							[
								2094,
								2118
							],
							[
								2257,
								2273
							],
							[
								2925,
								2942
							],
							[
								3474,
								3495
							],
							[
								4363,
								4385
							],
							[
								5061,
								5086
							],
							[
								5856,
								5881
							],
							[
								6555,
								6580
							],
							[
								7804,
								7833
							],
							[
								8072,
								8088
							],
							[
								8969,
								8985
							],
							[
								10088,
								10113
							],
							[
								10557,
								10571
							],
							[
								11705,
								11720
							],
							[
								12191,
								12204
							],
							[
								12798,
								12810
							],
							[
								13216,
								13228
							],
							[
								13643,
								13658
							],
							[
								14739,
								14759
							],
							[
								15098,
								15117
							],
							[
								15336,
								15348
							],
							[
								17601,
								17618
							],
							[
								18216,
								18234
							],
							[
								19446,
								19466
							],
							[
								19927,
								19948
							],
							[
								20422,
								20437
							],
							[
								20930,
								20950
							],
							[
								21409,
								21421
							],
							[
								22140,
								22155
							],
							[
								23654,
								23679
							],
							[
								24218,
								24243
							],
							[
								25495,
								25509
							],
							[
								26422,
								26436
							],
							[
								26728,
								26741
							],
							[
								29120,
								29133
							],
							[
								30040,
								30050
							],
							[
								38455,
								38467
							],
							[
								38997,
								39011
							],
							[
								39041,
								39055
							]
						],
						"symlist":
						[
							"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
							" Ⓣ  pcg32_random_t ; — typedef",
							"—Ⓕ– pcg32_random_r ( ) { … } — function",
							"—Ⓕ– pcg32_random ( ) { … } — function",
							"—Ⓕ– pcg32_init_state ( ) { … } — function",
							"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
							"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
							"—Ⓕ– js_string_free_func ( ) { … } — function",
							"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
							"—Ⓕ– js_misc_tostring ( ) { … } — function",
							"—Ⓕ– js_misc_topointer ( ) { … } — function",
							"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
							"—Ⓕ– js_misc_proclink ( ) { … } — function",
							"—Ⓕ– js_misc_procread ( ) { … } — function",
							"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
							"—Ⓕ– js_misc_hrtime ( ) { … } — function",
							"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
							"—Ⓕ– js_misc_uname ( ) { … } — function",
							"—Ⓕ– js_misc_btoa ( ) { … } — function",
							"—Ⓕ– js_misc_atob ( ) { … } — function",
							"—Ⓕ– js_misc_compile ( ) { … } — function",
							"—Ⓕ– js_misc_write_object ( ) { … } — function",
							"—Ⓕ– js_misc_read_object ( ) { … } — function",
							"—Ⓕ– js_misc_getx ( ) { … } — function",
							"—Ⓕ– js_misc_valuetype ( ) { … } — function",
							"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
							"—Ⓕ– js_misc_opcodes ( ) { … } — function",
							"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
							"—Ⓕ– js_misc_atom ( ) { … } — function",
							"—Ⓕ– js_misc_classid ( ) { … } — function",
							"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
							"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
							"—Ⓕ– js_misc_random ( ) { … } — function",
							"—Ⓕ– js_misc_escape ( ) { … } — function",
							"—Ⓕ– js_misc_quote ( ) { … } — function",
							"—Ⓕ– js_misc_error ( ) { … } — function",
							"—Ⓕ– js_misc_is ( ) { … } — function",
							"—Ⓕ– js_misc_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAC6CQAA4oCU4pK44oCTIHBjZ19zdGF0ZV9zZXRzZXFfNjQgeyDigKYgfSA7IOKAlCB0eXBlCiAg4pOJICBwY2czMl9yYW5kb21fdCA7IOKAlCB0eXBlZGVmCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX2luaXRfc3RhdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fYm91bmRlZF9kaXZpc2lvbmxlc3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ieXRlY29kZV9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdHJpbmdfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b3N0cmluZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9wb2ludGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b2FycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19kdXBhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVzaXplYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NvbmNhdGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19zZWFyY2hhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY3JlYWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHByb3RvdHlwZWNoYWluICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ocnRpbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2ZubWF0Y2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3VuYW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19idG9hICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9iICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb21waWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY193cml0ZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JlYWRfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXR4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY192YWx1ZXR5cGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2V2YWxiaW5hcnkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0X2J5dGVjb2RlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jbGFzc2lkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19iaXRmaWVsZF90b19hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXJyYXlfdG9fYml0ZmllbGQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXNjYXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19xdW90ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2lzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pbml0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0AAAAAAAAAADyBwAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					46,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
						"symkeys":
						[
							[
								644,
								663
							],
							[
								691,
								705
							],
							[
								817,
								831
							],
							[
								1140,
								1152
							],
							[
								1216,
								1232
							],
							[
								1329,
								1362
							],
							[
								1841,
								1862
							],
							[
								1943,
								1962
							],
							[
								2094,
								2118
							],
							[
								2257,
								2273
							],
							[
								2925,
								2942
							],
							[
								3474,
								3495
							],
							[
								4363,
								4385
							],
							[
								5061,
								5086
							],
							[
								5856,
								5881
							],
							[
								6555,
								6580
							],
							[
								7974,
								8003
							],
							[
								8242,
								8258
							],
							[
								9139,
								9155
							],
							[
								10258,
								10283
							],
							[
								10727,
								10741
							],
							[
								11875,
								11890
							],
							[
								12361,
								12374
							],
							[
								12968,
								12980
							],
							[
								13386,
								13398
							],
							[
								13813,
								13828
							],
							[
								14909,
								14929
							],
							[
								15268,
								15287
							],
							[
								15506,
								15518
							],
							[
								17771,
								17788
							],
							[
								18386,
								18404
							],
							[
								19616,
								19636
							],
							[
								20097,
								20118
							],
							[
								20592,
								20607
							],
							[
								21100,
								21120
							],
							[
								21579,
								21591
							],
							[
								22310,
								22325
							],
							[
								23824,
								23849
							],
							[
								24388,
								24413
							],
							[
								25665,
								25679
							],
							[
								26592,
								26606
							],
							[
								26898,
								26911
							],
							[
								29290,
								29303
							],
							[
								30210,
								30220
							],
							[
								38625,
								38637
							],
							[
								39167,
								39181
							],
							[
								39211,
								39225
							]
						],
						"symlist":
						[
							"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
							" Ⓣ  pcg32_random_t ; — typedef",
							"—Ⓕ– pcg32_random_r ( ) { … } — function",
							"—Ⓕ– pcg32_random ( ) { … } — function",
							"—Ⓕ– pcg32_init_state ( ) { … } — function",
							"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
							"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
							"—Ⓕ– js_string_free_func ( ) { … } — function",
							"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
							"—Ⓕ– js_misc_tostring ( ) { … } — function",
							"—Ⓕ– js_misc_topointer ( ) { … } — function",
							"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
							"—Ⓕ– js_misc_proclink ( ) { … } — function",
							"—Ⓕ– js_misc_procread ( ) { … } — function",
							"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
							"—Ⓕ– js_misc_hrtime ( ) { … } — function",
							"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
							"—Ⓕ– js_misc_uname ( ) { … } — function",
							"—Ⓕ– js_misc_btoa ( ) { … } — function",
							"—Ⓕ– js_misc_atob ( ) { … } — function",
							"—Ⓕ– js_misc_compile ( ) { … } — function",
							"—Ⓕ– js_misc_write_object ( ) { … } — function",
							"—Ⓕ– js_misc_read_object ( ) { … } — function",
							"—Ⓕ– js_misc_getx ( ) { … } — function",
							"—Ⓕ– js_misc_valuetype ( ) { … } — function",
							"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
							"—Ⓕ– js_misc_opcodes ( ) { … } — function",
							"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
							"—Ⓕ– js_misc_atom ( ) { … } — function",
							"—Ⓕ– js_misc_classid ( ) { … } — function",
							"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
							"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
							"—Ⓕ– js_misc_random ( ) { … } — function",
							"—Ⓕ– js_misc_escape ( ) { … } — function",
							"—Ⓕ– js_misc_quote ( ) { … } — function",
							"—Ⓕ– js_misc_error ( ) { … } — function",
							"—Ⓕ– js_misc_is ( ) { … } — function",
							"—Ⓕ– js_misc_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAC6CQAA4oCU4pK44oCTIHBjZ19zdGF0ZV9zZXRzZXFfNjQgeyDigKYgfSA7IOKAlCB0eXBlCiAg4pOJICBwY2czMl9yYW5kb21fdCA7IOKAlCB0eXBlZGVmCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX2luaXRfc3RhdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fYm91bmRlZF9kaXZpc2lvbmxlc3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ieXRlY29kZV9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdHJpbmdfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b3N0cmluZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9wb2ludGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b2FycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19kdXBhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVzaXplYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NvbmNhdGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19zZWFyY2hhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY3JlYWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHByb3RvdHlwZWNoYWluICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ocnRpbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2ZubWF0Y2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3VuYW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19idG9hICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9iICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb21waWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY193cml0ZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JlYWRfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXR4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY192YWx1ZXR5cGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2V2YWxiaW5hcnkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0X2J5dGVjb2RlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jbGFzc2lkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19iaXRmaWVsZF90b19hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXJyYXlfdG9fYml0ZmllbGQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXNjYXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19xdW90ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2lzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pbml0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0AAAAAAAAAADyBwAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					47,
					2,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
						"symkeys":
						[
							[
								644,
								663
							],
							[
								691,
								705
							],
							[
								817,
								831
							],
							[
								1140,
								1152
							],
							[
								1216,
								1232
							],
							[
								1329,
								1362
							],
							[
								1841,
								1862
							],
							[
								1943,
								1962
							],
							[
								2094,
								2118
							],
							[
								2257,
								2273
							],
							[
								2925,
								2942
							],
							[
								3474,
								3495
							],
							[
								4363,
								4385
							],
							[
								5061,
								5086
							],
							[
								5856,
								5881
							],
							[
								6555,
								6580
							],
							[
								8112,
								8141
							],
							[
								8380,
								8396
							],
							[
								9277,
								9293
							],
							[
								10396,
								10421
							],
							[
								10865,
								10879
							],
							[
								12013,
								12028
							],
							[
								12499,
								12512
							],
							[
								13106,
								13118
							],
							[
								13524,
								13536
							],
							[
								13951,
								13966
							],
							[
								15047,
								15067
							],
							[
								15406,
								15425
							],
							[
								15644,
								15656
							],
							[
								17909,
								17926
							],
							[
								18524,
								18542
							],
							[
								19754,
								19774
							],
							[
								20235,
								20256
							],
							[
								20730,
								20745
							],
							[
								21238,
								21258
							],
							[
								21717,
								21729
							],
							[
								22448,
								22463
							],
							[
								23962,
								23987
							],
							[
								24526,
								24551
							],
							[
								25803,
								25817
							],
							[
								26730,
								26744
							],
							[
								27036,
								27049
							],
							[
								29428,
								29441
							],
							[
								30348,
								30358
							],
							[
								38763,
								38775
							],
							[
								39305,
								39319
							],
							[
								39349,
								39363
							]
						],
						"symlist":
						[
							"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
							" Ⓣ  pcg32_random_t ; — typedef",
							"—Ⓕ– pcg32_random_r ( ) { … } — function",
							"—Ⓕ– pcg32_random ( ) { … } — function",
							"—Ⓕ– pcg32_init_state ( ) { … } — function",
							"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
							"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
							"—Ⓕ– js_string_free_func ( ) { … } — function",
							"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
							"—Ⓕ– js_misc_tostring ( ) { … } — function",
							"—Ⓕ– js_misc_topointer ( ) { … } — function",
							"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
							"—Ⓕ– js_misc_proclink ( ) { … } — function",
							"—Ⓕ– js_misc_procread ( ) { … } — function",
							"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
							"—Ⓕ– js_misc_hrtime ( ) { … } — function",
							"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
							"—Ⓕ– js_misc_uname ( ) { … } — function",
							"—Ⓕ– js_misc_btoa ( ) { … } — function",
							"—Ⓕ– js_misc_atob ( ) { … } — function",
							"—Ⓕ– js_misc_compile ( ) { … } — function",
							"—Ⓕ– js_misc_write_object ( ) { … } — function",
							"—Ⓕ– js_misc_read_object ( ) { … } — function",
							"—Ⓕ– js_misc_getx ( ) { … } — function",
							"—Ⓕ– js_misc_valuetype ( ) { … } — function",
							"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
							"—Ⓕ– js_misc_opcodes ( ) { … } — function",
							"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
							"—Ⓕ– js_misc_atom ( ) { … } — function",
							"—Ⓕ– js_misc_classid ( ) { … } — function",
							"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
							"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
							"—Ⓕ– js_misc_random ( ) { … } — function",
							"—Ⓕ– js_misc_escape ( ) { … } — function",
							"—Ⓕ– js_misc_quote ( ) { … } — function",
							"—Ⓕ– js_misc_error ( ) { … } — function",
							"—Ⓕ– js_misc_is ( ) { … } — function",
							"—Ⓕ– js_misc_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"BAAAAAAAAAAAAAAAAAAAAAAAAAC6CQAA4oCU4pK44oCTIHBjZ19zdGF0ZV9zZXRzZXFfNjQgeyDigKYgfSA7IOKAlCB0eXBlCiAg4pOJICBwY2czMl9yYW5kb21fdCA7IOKAlCB0eXBlZGVmCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX2luaXRfc3RhdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fYm91bmRlZF9kaXZpc2lvbmxlc3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ieXRlY29kZV9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdHJpbmdfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b3N0cmluZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9wb2ludGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b2FycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19kdXBhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVzaXplYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NvbmNhdGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19zZWFyY2hhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY3JlYWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHByb3RvdHlwZWNoYWluICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ocnRpbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2ZubWF0Y2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3VuYW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19idG9hICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9iICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb21waWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY193cml0ZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JlYWRfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXR4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY192YWx1ZXR5cGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2V2YWxiaW5hcnkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0X2J5dGVjb2RlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jbGFzc2lkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19iaXRmaWVsZF90b19hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXJyYXlfdG9fYml0ZmllbGQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXNjYXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19xdW90ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2lzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pbml0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0AAAAAAAAAADyBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugkAAOKAlOKSuOKAkyBwY2dfc3RhdGVfc2V0c2VxXzY0IHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcGNnMzJfcmFuZG9tX3QgOyDigJQgdHlwZWRlZgrigJTikrvigJMgcGNnMzJfcmFuZG9tX3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9pbml0X3N0YXRlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcGNnMzJfcmFuZG9tX2JvdW5kZWRfZGl2aXNpb25sZXNzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYnl0ZWNvZGVfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RyaW5nX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX2FycmF5YnVmZmVyX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9zdHJpbmcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3RvcG9pbnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9hcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZHVwYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Jlc2l6ZWFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb25jYXRhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfc2VhcmNoYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHBlcmZvcm1hbmNlY291bnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY2xpbmsgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Byb2NyZWFkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXRwcm90b3R5cGVjaGFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaHJ0aW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19mbm1hdGNoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY191bmFtZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYnRvYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvYiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY29tcGlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfd3JpdGVfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yZWFkX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0eCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdmFsdWV0eXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ldmFsYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19vcGNvZGVfYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldF9ieXRlY29kZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY2xhc3NpZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYml0ZmllbGRfdG9fYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2FycmF5X3RvX2JpdGZpZWxkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2VzY2FwZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcXVvdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBKU19JTklUX01PRFVMRSDigKYg4oCUIG1hY3JvIG9iamVjdAAAAAAAAAAA8gcAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					48,
					2,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
						"symkeys":
						[
							[
								644,
								663
							],
							[
								691,
								705
							],
							[
								817,
								831
							],
							[
								1140,
								1152
							],
							[
								1216,
								1232
							],
							[
								1329,
								1362
							],
							[
								1841,
								1862
							],
							[
								1943,
								1962
							],
							[
								2094,
								2118
							],
							[
								2257,
								2273
							],
							[
								2925,
								2942
							],
							[
								3474,
								3495
							],
							[
								4363,
								4385
							],
							[
								5061,
								5086
							],
							[
								5856,
								5881
							],
							[
								6555,
								6580
							],
							[
								8152,
								8181
							],
							[
								8420,
								8436
							],
							[
								9317,
								9333
							],
							[
								10436,
								10461
							],
							[
								10905,
								10919
							],
							[
								12053,
								12068
							],
							[
								12539,
								12552
							],
							[
								13146,
								13158
							],
							[
								13564,
								13576
							],
							[
								13991,
								14006
							],
							[
								15087,
								15107
							],
							[
								15446,
								15465
							],
							[
								15684,
								15696
							],
							[
								17949,
								17966
							],
							[
								18564,
								18582
							],
							[
								19794,
								19814
							],
							[
								20275,
								20296
							],
							[
								20770,
								20785
							],
							[
								21278,
								21298
							],
							[
								21757,
								21769
							],
							[
								22488,
								22503
							],
							[
								24002,
								24027
							],
							[
								24566,
								24591
							],
							[
								25843,
								25857
							],
							[
								26770,
								26784
							],
							[
								27076,
								27089
							],
							[
								29468,
								29481
							],
							[
								30388,
								30398
							],
							[
								38803,
								38815
							],
							[
								39345,
								39359
							],
							[
								39389,
								39403
							]
						],
						"symlist":
						[
							"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
							" Ⓣ  pcg32_random_t ; — typedef",
							"—Ⓕ– pcg32_random_r ( ) { … } — function",
							"—Ⓕ– pcg32_random ( ) { … } — function",
							"—Ⓕ– pcg32_init_state ( ) { … } — function",
							"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
							"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
							"—Ⓕ– js_string_free_func ( ) { … } — function",
							"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
							"—Ⓕ– js_misc_tostring ( ) { … } — function",
							"—Ⓕ– js_misc_topointer ( ) { … } — function",
							"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
							"—Ⓕ– js_misc_proclink ( ) { … } — function",
							"—Ⓕ– js_misc_procread ( ) { … } — function",
							"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
							"—Ⓕ– js_misc_hrtime ( ) { … } — function",
							"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
							"—Ⓕ– js_misc_uname ( ) { … } — function",
							"—Ⓕ– js_misc_btoa ( ) { … } — function",
							"—Ⓕ– js_misc_atob ( ) { … } — function",
							"—Ⓕ– js_misc_compile ( ) { … } — function",
							"—Ⓕ– js_misc_write_object ( ) { … } — function",
							"—Ⓕ– js_misc_read_object ( ) { … } — function",
							"—Ⓕ– js_misc_getx ( ) { … } — function",
							"—Ⓕ– js_misc_valuetype ( ) { … } — function",
							"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
							"—Ⓕ– js_misc_opcodes ( ) { … } — function",
							"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
							"—Ⓕ– js_misc_atom ( ) { … } — function",
							"—Ⓕ– js_misc_classid ( ) { … } — function",
							"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
							"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
							"—Ⓕ– js_misc_random ( ) { … } — function",
							"—Ⓕ– js_misc_escape ( ) { … } — function",
							"—Ⓕ– js_misc_quote ( ) { … } — function",
							"—Ⓕ– js_misc_error ( ) { … } — function",
							"—Ⓕ– js_misc_is ( ) { … } — function",
							"—Ⓕ– js_misc_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"BAAAAAAAAAAAAAAAAAAAAAAAAAC6CQAA4oCU4pK44oCTIHBjZ19zdGF0ZV9zZXRzZXFfNjQgeyDigKYgfSA7IOKAlCB0eXBlCiAg4pOJICBwY2czMl9yYW5kb21fdCA7IOKAlCB0eXBlZGVmCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX2luaXRfc3RhdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fYm91bmRlZF9kaXZpc2lvbmxlc3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ieXRlY29kZV9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdHJpbmdfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b3N0cmluZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9wb2ludGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b2FycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19kdXBhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVzaXplYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NvbmNhdGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19zZWFyY2hhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY3JlYWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHByb3RvdHlwZWNoYWluICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ocnRpbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2ZubWF0Y2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3VuYW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19idG9hICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9iICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb21waWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY193cml0ZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JlYWRfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXR4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY192YWx1ZXR5cGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2V2YWxiaW5hcnkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0X2J5dGVjb2RlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jbGFzc2lkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19iaXRmaWVsZF90b19hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXJyYXlfdG9fYml0ZmllbGQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXNjYXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19xdW90ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2lzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pbml0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0AAAAAAAAAADyBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugkAAOKAlOKSuOKAkyBwY2dfc3RhdGVfc2V0c2VxXzY0IHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcGNnMzJfcmFuZG9tX3QgOyDigJQgdHlwZWRlZgrigJTikrvigJMgcGNnMzJfcmFuZG9tX3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9pbml0X3N0YXRlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcGNnMzJfcmFuZG9tX2JvdW5kZWRfZGl2aXNpb25sZXNzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYnl0ZWNvZGVfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RyaW5nX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX2FycmF5YnVmZmVyX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9zdHJpbmcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3RvcG9pbnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9hcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZHVwYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Jlc2l6ZWFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb25jYXRhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfc2VhcmNoYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHBlcmZvcm1hbmNlY291bnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY2xpbmsgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Byb2NyZWFkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXRwcm90b3R5cGVjaGFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaHJ0aW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19mbm1hdGNoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY191bmFtZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYnRvYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvYiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY29tcGlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfd3JpdGVfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yZWFkX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0eCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdmFsdWV0eXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ldmFsYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19vcGNvZGVfYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldF9ieXRlY29kZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY2xhc3NpZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYml0ZmllbGRfdG9fYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2FycmF5X3RvX2JpdGZpZWxkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2VzY2FwZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcXVvdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBKU19JTklUX01PRFVMRSDigKYg4oCUIG1hY3JvIG9iamVjdAAAAAAAAAAA8gcAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					49,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
						"symkeys":
						[
							[
								644,
								663
							],
							[
								691,
								705
							],
							[
								817,
								831
							],
							[
								1140,
								1152
							],
							[
								1216,
								1232
							],
							[
								1329,
								1362
							],
							[
								1841,
								1862
							],
							[
								1943,
								1962
							],
							[
								2094,
								2118
							],
							[
								2257,
								2273
							],
							[
								2925,
								2942
							],
							[
								3474,
								3495
							],
							[
								4363,
								4385
							],
							[
								5061,
								5086
							],
							[
								5856,
								5881
							],
							[
								6555,
								6580
							],
							[
								8195,
								8224
							],
							[
								8463,
								8479
							],
							[
								9360,
								9376
							],
							[
								10479,
								10504
							],
							[
								10948,
								10962
							],
							[
								12096,
								12111
							],
							[
								12582,
								12595
							],
							[
								13189,
								13201
							],
							[
								13607,
								13619
							],
							[
								14034,
								14049
							],
							[
								15130,
								15150
							],
							[
								15489,
								15508
							],
							[
								15727,
								15739
							],
							[
								17992,
								18009
							],
							[
								18607,
								18625
							],
							[
								19837,
								19857
							],
							[
								20318,
								20339
							],
							[
								20813,
								20828
							],
							[
								21321,
								21341
							],
							[
								21800,
								21812
							],
							[
								22531,
								22546
							],
							[
								24045,
								24070
							],
							[
								24609,
								24634
							],
							[
								25886,
								25900
							],
							[
								26813,
								26827
							],
							[
								27119,
								27132
							],
							[
								29511,
								29524
							],
							[
								30431,
								30441
							],
							[
								38846,
								38858
							],
							[
								39388,
								39402
							],
							[
								39432,
								39446
							]
						],
						"symlist":
						[
							"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
							" Ⓣ  pcg32_random_t ; — typedef",
							"—Ⓕ– pcg32_random_r ( ) { … } — function",
							"—Ⓕ– pcg32_random ( ) { … } — function",
							"—Ⓕ– pcg32_init_state ( ) { … } — function",
							"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
							"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
							"—Ⓕ– js_string_free_func ( ) { … } — function",
							"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
							"—Ⓕ– js_misc_tostring ( ) { … } — function",
							"—Ⓕ– js_misc_topointer ( ) { … } — function",
							"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
							"—Ⓕ– js_misc_proclink ( ) { … } — function",
							"—Ⓕ– js_misc_procread ( ) { … } — function",
							"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
							"—Ⓕ– js_misc_hrtime ( ) { … } — function",
							"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
							"—Ⓕ– js_misc_uname ( ) { … } — function",
							"—Ⓕ– js_misc_btoa ( ) { … } — function",
							"—Ⓕ– js_misc_atob ( ) { … } — function",
							"—Ⓕ– js_misc_compile ( ) { … } — function",
							"—Ⓕ– js_misc_write_object ( ) { … } — function",
							"—Ⓕ– js_misc_read_object ( ) { … } — function",
							"—Ⓕ– js_misc_getx ( ) { … } — function",
							"—Ⓕ– js_misc_valuetype ( ) { … } — function",
							"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
							"—Ⓕ– js_misc_opcodes ( ) { … } — function",
							"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
							"—Ⓕ– js_misc_atom ( ) { … } — function",
							"—Ⓕ– js_misc_classid ( ) { … } — function",
							"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
							"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
							"—Ⓕ– js_misc_random ( ) { … } — function",
							"—Ⓕ– js_misc_escape ( ) { … } — function",
							"—Ⓕ– js_misc_quote ( ) { … } — function",
							"—Ⓕ– js_misc_error ( ) { … } — function",
							"—Ⓕ– js_misc_is ( ) { … } — function",
							"—Ⓕ– js_misc_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAC6CQAA4oCU4pK44oCTIHBjZ19zdGF0ZV9zZXRzZXFfNjQgeyDigKYgfSA7IOKAlCB0eXBlCiAg4pOJICBwY2czMl9yYW5kb21fdCA7IOKAlCB0eXBlZGVmCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX2luaXRfc3RhdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fYm91bmRlZF9kaXZpc2lvbmxlc3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ieXRlY29kZV9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdHJpbmdfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b3N0cmluZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9wb2ludGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b2FycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19kdXBhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVzaXplYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NvbmNhdGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19zZWFyY2hhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY3JlYWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHByb3RvdHlwZWNoYWluICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ocnRpbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2ZubWF0Y2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3VuYW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19idG9hICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9iICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb21waWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY193cml0ZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JlYWRfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXR4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY192YWx1ZXR5cGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2V2YWxiaW5hcnkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0X2J5dGVjb2RlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jbGFzc2lkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19iaXRmaWVsZF90b19hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXJyYXlfdG9fYml0ZmllbGQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXNjYXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19xdW90ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2lzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pbml0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0AAAAAAAAAADyBwAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					50,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
						"symkeys":
						[
							[
								644,
								663
							],
							[
								691,
								705
							],
							[
								817,
								831
							],
							[
								1140,
								1152
							],
							[
								1216,
								1232
							],
							[
								1329,
								1362
							],
							[
								1841,
								1862
							],
							[
								1943,
								1962
							],
							[
								2094,
								2118
							],
							[
								2257,
								2273
							],
							[
								2925,
								2942
							],
							[
								3474,
								3495
							],
							[
								4363,
								4385
							],
							[
								5061,
								5086
							],
							[
								5856,
								5881
							],
							[
								6555,
								6580
							],
							[
								8196,
								8225
							],
							[
								8464,
								8480
							],
							[
								9361,
								9377
							],
							[
								10480,
								10505
							],
							[
								10949,
								10963
							],
							[
								12097,
								12112
							],
							[
								12583,
								12596
							],
							[
								13190,
								13202
							],
							[
								13608,
								13620
							],
							[
								14035,
								14050
							],
							[
								15131,
								15151
							],
							[
								15490,
								15509
							],
							[
								15728,
								15740
							],
							[
								17993,
								18010
							],
							[
								18608,
								18626
							],
							[
								19838,
								19858
							],
							[
								20319,
								20340
							],
							[
								20814,
								20829
							],
							[
								21322,
								21342
							],
							[
								21801,
								21813
							],
							[
								22532,
								22547
							],
							[
								24046,
								24071
							],
							[
								24610,
								24635
							],
							[
								25887,
								25901
							],
							[
								26814,
								26828
							],
							[
								27120,
								27133
							],
							[
								29512,
								29525
							],
							[
								30432,
								30442
							],
							[
								38847,
								38859
							],
							[
								39389,
								39403
							],
							[
								39433,
								39447
							]
						],
						"symlist":
						[
							"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
							" Ⓣ  pcg32_random_t ; — typedef",
							"—Ⓕ– pcg32_random_r ( ) { … } — function",
							"—Ⓕ– pcg32_random ( ) { … } — function",
							"—Ⓕ– pcg32_init_state ( ) { … } — function",
							"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
							"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
							"—Ⓕ– js_string_free_func ( ) { … } — function",
							"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
							"—Ⓕ– js_misc_tostring ( ) { … } — function",
							"—Ⓕ– js_misc_topointer ( ) { … } — function",
							"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
							"—Ⓕ– js_misc_proclink ( ) { … } — function",
							"—Ⓕ– js_misc_procread ( ) { … } — function",
							"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
							"—Ⓕ– js_misc_hrtime ( ) { … } — function",
							"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
							"—Ⓕ– js_misc_uname ( ) { … } — function",
							"—Ⓕ– js_misc_btoa ( ) { … } — function",
							"—Ⓕ– js_misc_atob ( ) { … } — function",
							"—Ⓕ– js_misc_compile ( ) { … } — function",
							"—Ⓕ– js_misc_write_object ( ) { … } — function",
							"—Ⓕ– js_misc_read_object ( ) { … } — function",
							"—Ⓕ– js_misc_getx ( ) { … } — function",
							"—Ⓕ– js_misc_valuetype ( ) { … } — function",
							"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
							"—Ⓕ– js_misc_opcodes ( ) { … } — function",
							"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
							"—Ⓕ– js_misc_atom ( ) { … } — function",
							"—Ⓕ– js_misc_classid ( ) { … } — function",
							"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
							"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
							"—Ⓕ– js_misc_random ( ) { … } — function",
							"—Ⓕ– js_misc_escape ( ) { … } — function",
							"—Ⓕ– js_misc_quote ( ) { … } — function",
							"—Ⓕ– js_misc_error ( ) { … } — function",
							"—Ⓕ– js_misc_is ( ) { … } — function",
							"—Ⓕ– js_misc_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAC6CQAA4oCU4pK44oCTIHBjZ19zdGF0ZV9zZXRzZXFfNjQgeyDigKYgfSA7IOKAlCB0eXBlCiAg4pOJICBwY2czMl9yYW5kb21fdCA7IOKAlCB0eXBlZGVmCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX2luaXRfc3RhdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fYm91bmRlZF9kaXZpc2lvbmxlc3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ieXRlY29kZV9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdHJpbmdfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b3N0cmluZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9wb2ludGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b2FycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19kdXBhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVzaXplYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NvbmNhdGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19zZWFyY2hhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY3JlYWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHByb3RvdHlwZWNoYWluICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ocnRpbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2ZubWF0Y2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3VuYW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19idG9hICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9iICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb21waWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY193cml0ZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JlYWRfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXR4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY192YWx1ZXR5cGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2V2YWxiaW5hcnkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0X2J5dGVjb2RlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jbGFzc2lkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19iaXRmaWVsZF90b19hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXJyYXlfdG9fYml0ZmllbGQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXNjYXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19xdW90ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2lzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pbml0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0AAAAAAAAAADyBwAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					51,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
						"symkeys":
						[
							[
								644,
								663
							],
							[
								691,
								705
							],
							[
								817,
								831
							],
							[
								1140,
								1152
							],
							[
								1216,
								1232
							],
							[
								1329,
								1362
							],
							[
								1841,
								1862
							],
							[
								1943,
								1962
							],
							[
								2094,
								2118
							],
							[
								2257,
								2273
							],
							[
								2925,
								2942
							],
							[
								3474,
								3495
							],
							[
								4363,
								4385
							],
							[
								5061,
								5086
							],
							[
								5856,
								5881
							],
							[
								6555,
								6580
							],
							[
								8149,
								8178
							],
							[
								8417,
								8433
							],
							[
								9314,
								9330
							],
							[
								10433,
								10458
							],
							[
								10902,
								10916
							],
							[
								12050,
								12065
							],
							[
								12536,
								12549
							],
							[
								13143,
								13155
							],
							[
								13561,
								13573
							],
							[
								13988,
								14003
							],
							[
								15084,
								15104
							],
							[
								15443,
								15462
							],
							[
								15681,
								15693
							],
							[
								17946,
								17963
							],
							[
								18561,
								18579
							],
							[
								19791,
								19811
							],
							[
								20272,
								20293
							],
							[
								20767,
								20782
							],
							[
								21275,
								21295
							],
							[
								21754,
								21766
							],
							[
								22485,
								22500
							],
							[
								23999,
								24024
							],
							[
								24563,
								24588
							],
							[
								25840,
								25854
							],
							[
								26767,
								26781
							],
							[
								27073,
								27086
							],
							[
								29465,
								29478
							],
							[
								30385,
								30395
							],
							[
								38800,
								38812
							],
							[
								39342,
								39356
							],
							[
								39386,
								39400
							]
						],
						"symlist":
						[
							"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
							" Ⓣ  pcg32_random_t ; — typedef",
							"—Ⓕ– pcg32_random_r ( ) { … } — function",
							"—Ⓕ– pcg32_random ( ) { … } — function",
							"—Ⓕ– pcg32_init_state ( ) { … } — function",
							"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
							"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
							"—Ⓕ– js_string_free_func ( ) { … } — function",
							"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
							"—Ⓕ– js_misc_tostring ( ) { … } — function",
							"—Ⓕ– js_misc_topointer ( ) { … } — function",
							"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
							"—Ⓕ– js_misc_proclink ( ) { … } — function",
							"—Ⓕ– js_misc_procread ( ) { … } — function",
							"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
							"—Ⓕ– js_misc_hrtime ( ) { … } — function",
							"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
							"—Ⓕ– js_misc_uname ( ) { … } — function",
							"—Ⓕ– js_misc_btoa ( ) { … } — function",
							"—Ⓕ– js_misc_atob ( ) { … } — function",
							"—Ⓕ– js_misc_compile ( ) { … } — function",
							"—Ⓕ– js_misc_write_object ( ) { … } — function",
							"—Ⓕ– js_misc_read_object ( ) { … } — function",
							"—Ⓕ– js_misc_getx ( ) { … } — function",
							"—Ⓕ– js_misc_valuetype ( ) { … } — function",
							"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
							"—Ⓕ– js_misc_opcodes ( ) { … } — function",
							"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
							"—Ⓕ– js_misc_atom ( ) { … } — function",
							"—Ⓕ– js_misc_classid ( ) { … } — function",
							"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
							"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
							"—Ⓕ– js_misc_random ( ) { … } — function",
							"—Ⓕ– js_misc_escape ( ) { … } — function",
							"—Ⓕ– js_misc_quote ( ) { … } — function",
							"—Ⓕ– js_misc_error ( ) { … } — function",
							"—Ⓕ– js_misc_is ( ) { … } — function",
							"—Ⓕ– js_misc_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAC6CQAA4oCU4pK44oCTIHBjZ19zdGF0ZV9zZXRzZXFfNjQgeyDigKYgfSA7IOKAlCB0eXBlCiAg4pOJICBwY2czMl9yYW5kb21fdCA7IOKAlCB0eXBlZGVmCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX2luaXRfc3RhdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fYm91bmRlZF9kaXZpc2lvbmxlc3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ieXRlY29kZV9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdHJpbmdfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b3N0cmluZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9wb2ludGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b2FycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19kdXBhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVzaXplYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NvbmNhdGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19zZWFyY2hhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY3JlYWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHByb3RvdHlwZWNoYWluICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ocnRpbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2ZubWF0Y2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3VuYW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19idG9hICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9iICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb21waWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY193cml0ZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JlYWRfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXR4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY192YWx1ZXR5cGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2V2YWxiaW5hcnkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0X2J5dGVjb2RlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jbGFzc2lkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19iaXRmaWVsZF90b19hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXJyYXlfdG9fYml0ZmllbGQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXNjYXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19xdW90ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2lzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pbml0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0AAAAAAAAAADyBwAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					52,
					2,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
						"symkeys":
						[
							[
								644,
								663
							],
							[
								691,
								705
							],
							[
								817,
								831
							],
							[
								1140,
								1152
							],
							[
								1216,
								1232
							],
							[
								1329,
								1362
							],
							[
								1841,
								1862
							],
							[
								1943,
								1962
							],
							[
								2094,
								2118
							],
							[
								2257,
								2273
							],
							[
								2925,
								2942
							],
							[
								3474,
								3495
							],
							[
								4363,
								4385
							],
							[
								5061,
								5086
							],
							[
								5856,
								5881
							],
							[
								6555,
								6580
							],
							[
								8142,
								8171
							],
							[
								8410,
								8426
							],
							[
								9307,
								9323
							],
							[
								10426,
								10451
							],
							[
								10895,
								10909
							],
							[
								12043,
								12058
							],
							[
								12529,
								12542
							],
							[
								13136,
								13148
							],
							[
								13554,
								13566
							],
							[
								13981,
								13996
							],
							[
								15077,
								15097
							],
							[
								15436,
								15455
							],
							[
								15674,
								15686
							],
							[
								17939,
								17956
							],
							[
								18554,
								18572
							],
							[
								19784,
								19804
							],
							[
								20265,
								20286
							],
							[
								20760,
								20775
							],
							[
								21268,
								21288
							],
							[
								21747,
								21759
							],
							[
								22478,
								22493
							],
							[
								23992,
								24017
							],
							[
								24556,
								24581
							],
							[
								25833,
								25847
							],
							[
								26760,
								26774
							],
							[
								27066,
								27079
							],
							[
								29458,
								29471
							],
							[
								30378,
								30388
							],
							[
								38793,
								38805
							],
							[
								39335,
								39349
							],
							[
								39379,
								39393
							]
						],
						"symlist":
						[
							"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
							" Ⓣ  pcg32_random_t ; — typedef",
							"—Ⓕ– pcg32_random_r ( ) { … } — function",
							"—Ⓕ– pcg32_random ( ) { … } — function",
							"—Ⓕ– pcg32_init_state ( ) { … } — function",
							"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
							"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
							"—Ⓕ– js_string_free_func ( ) { … } — function",
							"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
							"—Ⓕ– js_misc_tostring ( ) { … } — function",
							"—Ⓕ– js_misc_topointer ( ) { … } — function",
							"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
							"—Ⓕ– js_misc_proclink ( ) { … } — function",
							"—Ⓕ– js_misc_procread ( ) { … } — function",
							"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
							"—Ⓕ– js_misc_hrtime ( ) { … } — function",
							"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
							"—Ⓕ– js_misc_uname ( ) { … } — function",
							"—Ⓕ– js_misc_btoa ( ) { … } — function",
							"—Ⓕ– js_misc_atob ( ) { … } — function",
							"—Ⓕ– js_misc_compile ( ) { … } — function",
							"—Ⓕ– js_misc_write_object ( ) { … } — function",
							"—Ⓕ– js_misc_read_object ( ) { … } — function",
							"—Ⓕ– js_misc_getx ( ) { … } — function",
							"—Ⓕ– js_misc_valuetype ( ) { … } — function",
							"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
							"—Ⓕ– js_misc_opcodes ( ) { … } — function",
							"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
							"—Ⓕ– js_misc_atom ( ) { … } — function",
							"—Ⓕ– js_misc_classid ( ) { … } — function",
							"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
							"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
							"—Ⓕ– js_misc_random ( ) { … } — function",
							"—Ⓕ– js_misc_escape ( ) { … } — function",
							"—Ⓕ– js_misc_quote ( ) { … } — function",
							"—Ⓕ– js_misc_error ( ) { … } — function",
							"—Ⓕ– js_misc_is ( ) { … } — function",
							"—Ⓕ– js_misc_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"BAAAAAAAAAAAAAAAAAAAAAAAAAC6CQAA4oCU4pK44oCTIHBjZ19zdGF0ZV9zZXRzZXFfNjQgeyDigKYgfSA7IOKAlCB0eXBlCiAg4pOJICBwY2czMl9yYW5kb21fdCA7IOKAlCB0eXBlZGVmCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX2luaXRfc3RhdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fYm91bmRlZF9kaXZpc2lvbmxlc3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ieXRlY29kZV9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdHJpbmdfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b3N0cmluZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9wb2ludGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b2FycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19kdXBhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVzaXplYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NvbmNhdGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19zZWFyY2hhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY3JlYWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHByb3RvdHlwZWNoYWluICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ocnRpbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2ZubWF0Y2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3VuYW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19idG9hICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9iICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb21waWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY193cml0ZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JlYWRfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXR4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY192YWx1ZXR5cGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2V2YWxiaW5hcnkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0X2J5dGVjb2RlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jbGFzc2lkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19iaXRmaWVsZF90b19hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXJyYXlfdG9fYml0ZmllbGQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXNjYXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19xdW90ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2lzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pbml0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0AAAAAAAAAADyBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugkAAOKAlOKSuOKAkyBwY2dfc3RhdGVfc2V0c2VxXzY0IHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcGNnMzJfcmFuZG9tX3QgOyDigJQgdHlwZWRlZgrigJTikrvigJMgcGNnMzJfcmFuZG9tX3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9pbml0X3N0YXRlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcGNnMzJfcmFuZG9tX2JvdW5kZWRfZGl2aXNpb25sZXNzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYnl0ZWNvZGVfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RyaW5nX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX2FycmF5YnVmZmVyX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9zdHJpbmcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3RvcG9pbnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9hcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZHVwYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Jlc2l6ZWFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb25jYXRhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfc2VhcmNoYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHBlcmZvcm1hbmNlY291bnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY2xpbmsgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Byb2NyZWFkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXRwcm90b3R5cGVjaGFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaHJ0aW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19mbm1hdGNoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY191bmFtZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYnRvYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvYiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY29tcGlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfd3JpdGVfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yZWFkX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0eCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdmFsdWV0eXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ldmFsYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19vcGNvZGVfYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldF9ieXRlY29kZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY2xhc3NpZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYml0ZmllbGRfdG9fYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2FycmF5X3RvX2JpdGZpZWxkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2VzY2FwZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcXVvdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBKU19JTklUX01PRFVMRSDigKYg4oCUIG1hY3JvIG9iamVjdAAAAAAAAAAA8gcAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					53,
					3,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
						"symkeys":
						[
							[
								644,
								663
							],
							[
								691,
								705
							],
							[
								817,
								831
							],
							[
								1140,
								1152
							],
							[
								1216,
								1232
							],
							[
								1329,
								1362
							],
							[
								1841,
								1862
							],
							[
								1943,
								1962
							],
							[
								2094,
								2118
							],
							[
								2257,
								2273
							],
							[
								2925,
								2942
							],
							[
								3474,
								3495
							],
							[
								4363,
								4385
							],
							[
								5061,
								5086
							],
							[
								5856,
								5881
							],
							[
								6555,
								6580
							],
							[
								8142,
								8171
							],
							[
								8410,
								8426
							],
							[
								9307,
								9323
							],
							[
								10426,
								10451
							],
							[
								10895,
								10909
							],
							[
								12043,
								12058
							],
							[
								12529,
								12542
							],
							[
								13136,
								13148
							],
							[
								13554,
								13566
							],
							[
								13981,
								13996
							],
							[
								15077,
								15097
							],
							[
								15436,
								15455
							],
							[
								15674,
								15686
							],
							[
								17939,
								17956
							],
							[
								18554,
								18572
							],
							[
								19784,
								19804
							],
							[
								20265,
								20286
							],
							[
								20760,
								20775
							],
							[
								21268,
								21288
							],
							[
								21747,
								21759
							],
							[
								22478,
								22493
							],
							[
								23992,
								24017
							],
							[
								24556,
								24581
							],
							[
								25833,
								25847
							],
							[
								26760,
								26774
							],
							[
								27066,
								27079
							],
							[
								29458,
								29471
							],
							[
								30378,
								30388
							],
							[
								38793,
								38805
							],
							[
								39335,
								39349
							],
							[
								39379,
								39393
							]
						],
						"symlist":
						[
							"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
							" Ⓣ  pcg32_random_t ; — typedef",
							"—Ⓕ– pcg32_random_r ( ) { … } — function",
							"—Ⓕ– pcg32_random ( ) { … } — function",
							"—Ⓕ– pcg32_init_state ( ) { … } — function",
							"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
							"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
							"—Ⓕ– js_string_free_func ( ) { … } — function",
							"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
							"—Ⓕ– js_misc_tostring ( ) { … } — function",
							"—Ⓕ– js_misc_topointer ( ) { … } — function",
							"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
							"—Ⓕ– js_misc_proclink ( ) { … } — function",
							"—Ⓕ– js_misc_procread ( ) { … } — function",
							"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
							"—Ⓕ– js_misc_hrtime ( ) { … } — function",
							"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
							"—Ⓕ– js_misc_uname ( ) { … } — function",
							"—Ⓕ– js_misc_btoa ( ) { … } — function",
							"—Ⓕ– js_misc_atob ( ) { … } — function",
							"—Ⓕ– js_misc_compile ( ) { … } — function",
							"—Ⓕ– js_misc_write_object ( ) { … } — function",
							"—Ⓕ– js_misc_read_object ( ) { … } — function",
							"—Ⓕ– js_misc_getx ( ) { … } — function",
							"—Ⓕ– js_misc_valuetype ( ) { … } — function",
							"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
							"—Ⓕ– js_misc_opcodes ( ) { … } — function",
							"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
							"—Ⓕ– js_misc_atom ( ) { … } — function",
							"—Ⓕ– js_misc_classid ( ) { … } — function",
							"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
							"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
							"—Ⓕ– js_misc_random ( ) { … } — function",
							"—Ⓕ– js_misc_escape ( ) { … } — function",
							"—Ⓕ– js_misc_quote ( ) { … } — function",
							"—Ⓕ– js_misc_error ( ) { … } — function",
							"—Ⓕ– js_misc_is ( ) { … } — function",
							"—Ⓕ– js_misc_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"BgAAAAAAAAAAAAAAAAAAAAAAAAC6CQAA4oCU4pK44oCTIHBjZ19zdGF0ZV9zZXRzZXFfNjQgeyDigKYgfSA7IOKAlCB0eXBlCiAg4pOJICBwY2czMl9yYW5kb21fdCA7IOKAlCB0eXBlZGVmCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX2luaXRfc3RhdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fYm91bmRlZF9kaXZpc2lvbmxlc3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ieXRlY29kZV9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdHJpbmdfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b3N0cmluZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9wb2ludGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b2FycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19kdXBhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVzaXplYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NvbmNhdGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19zZWFyY2hhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY3JlYWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHByb3RvdHlwZWNoYWluICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ocnRpbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2ZubWF0Y2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3VuYW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19idG9hICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9iICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb21waWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY193cml0ZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JlYWRfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXR4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY192YWx1ZXR5cGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2V2YWxiaW5hcnkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0X2J5dGVjb2RlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jbGFzc2lkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19iaXRmaWVsZF90b19hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXJyYXlfdG9fYml0ZmllbGQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXNjYXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19xdW90ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2lzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pbml0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0AAAAAAAAAADyBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugkAAOKAlOKSuOKAkyBwY2dfc3RhdGVfc2V0c2VxXzY0IHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcGNnMzJfcmFuZG9tX3QgOyDigJQgdHlwZWRlZgrigJTikrvigJMgcGNnMzJfcmFuZG9tX3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9pbml0X3N0YXRlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcGNnMzJfcmFuZG9tX2JvdW5kZWRfZGl2aXNpb25sZXNzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYnl0ZWNvZGVfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RyaW5nX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX2FycmF5YnVmZmVyX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9zdHJpbmcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3RvcG9pbnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9hcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZHVwYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Jlc2l6ZWFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb25jYXRhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfc2VhcmNoYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHBlcmZvcm1hbmNlY291bnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY2xpbmsgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Byb2NyZWFkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXRwcm90b3R5cGVjaGFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaHJ0aW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19mbm1hdGNoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY191bmFtZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYnRvYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvYiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY29tcGlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfd3JpdGVfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yZWFkX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0eCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdmFsdWV0eXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ldmFsYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19vcGNvZGVfYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldF9ieXRlY29kZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY2xhc3NpZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYml0ZmllbGRfdG9fYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2FycmF5X3RvX2JpdGZpZWxkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2VzY2FwZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcXVvdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBKU19JTklUX01PRFVMRSDigKYg4oCUIG1hY3JvIG9iamVjdAAAAAAAAAAA8gcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALoJAADigJTikrjigJMgcGNnX3N0YXRlX3NldHNlcV82NCB7IOKApiB9IDsg4oCUIHR5cGUKICDik4kgIHBjZzMyX3JhbmRvbV90IDsg4oCUIHR5cGVkZWYK4oCU4pK74oCTIHBjZzMyX3JhbmRvbV9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcGNnMzJfcmFuZG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcGNnMzJfaW5pdF9zdGF0ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbV9ib3VuZGVkX2RpdmlzaW9ubGVzcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX2J5dGVjb2RlX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0cmluZ19mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19hcnJheWJ1ZmZlcl9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Rvc3RyaW5nICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b3BvaW50ZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3RvYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2R1cGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yZXNpemVhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY29uY2F0YXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3NlYXJjaGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXRwZXJmb3JtYW5jZWNvdW50ZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Byb2NsaW5rICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jcmVhZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cHJvdG90eXBlY2hhaW4gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2hydGltZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZm5tYXRjaCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdW5hbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2J0b2EgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2F0b2IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NvbXBpbGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3dyaXRlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVhZF9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3ZhbHVldHlwZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXZhbGJpbmFyeSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX2FycmF5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19vcGNvZGVfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19vcGNvZGVzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXRfYnl0ZWNvZGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2F0b20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NsYXNzaWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2JpdGZpZWxkX3RvX2FycmF5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hcnJheV90b19iaXRmaWVsZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmFuZG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19lc2NhcGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3F1b3RlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19lcnJvciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCiAg4pOCICBKU19JTklUX01PRFVMRSDigKYg4oCUIG1hY3JvIG9iamVjdAogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QAAAAAAAAAAPIHAAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					54,
					2,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
						"symkeys":
						[
							[
								644,
								663
							],
							[
								691,
								705
							],
							[
								817,
								831
							],
							[
								1140,
								1152
							],
							[
								1216,
								1232
							],
							[
								1329,
								1362
							],
							[
								1841,
								1862
							],
							[
								1943,
								1962
							],
							[
								2094,
								2118
							],
							[
								2257,
								2273
							],
							[
								2925,
								2942
							],
							[
								3474,
								3495
							],
							[
								4363,
								4385
							],
							[
								5061,
								5086
							],
							[
								5856,
								5881
							],
							[
								6555,
								6580
							],
							[
								8146,
								8175
							],
							[
								8414,
								8430
							],
							[
								9311,
								9327
							],
							[
								10430,
								10455
							],
							[
								10899,
								10913
							],
							[
								12047,
								12062
							],
							[
								12533,
								12546
							],
							[
								13140,
								13152
							],
							[
								13558,
								13570
							],
							[
								13985,
								14000
							],
							[
								15081,
								15101
							],
							[
								15440,
								15459
							],
							[
								15678,
								15690
							],
							[
								17943,
								17960
							],
							[
								18558,
								18576
							],
							[
								19788,
								19808
							],
							[
								20269,
								20290
							],
							[
								20764,
								20779
							],
							[
								21272,
								21292
							],
							[
								21751,
								21763
							],
							[
								22482,
								22497
							],
							[
								23996,
								24021
							],
							[
								24560,
								24585
							],
							[
								25837,
								25851
							],
							[
								26764,
								26778
							],
							[
								27070,
								27083
							],
							[
								29462,
								29475
							],
							[
								30382,
								30392
							],
							[
								38797,
								38809
							],
							[
								39339,
								39353
							],
							[
								39383,
								39397
							]
						],
						"symlist":
						[
							"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
							" Ⓣ  pcg32_random_t ; — typedef",
							"—Ⓕ– pcg32_random_r ( ) { … } — function",
							"—Ⓕ– pcg32_random ( ) { … } — function",
							"—Ⓕ– pcg32_init_state ( ) { … } — function",
							"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
							"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
							"—Ⓕ– js_string_free_func ( ) { … } — function",
							"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
							"—Ⓕ– js_misc_tostring ( ) { … } — function",
							"—Ⓕ– js_misc_topointer ( ) { … } — function",
							"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
							"—Ⓕ– js_misc_proclink ( ) { … } — function",
							"—Ⓕ– js_misc_procread ( ) { … } — function",
							"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
							"—Ⓕ– js_misc_hrtime ( ) { … } — function",
							"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
							"—Ⓕ– js_misc_uname ( ) { … } — function",
							"—Ⓕ– js_misc_btoa ( ) { … } — function",
							"—Ⓕ– js_misc_atob ( ) { … } — function",
							"—Ⓕ– js_misc_compile ( ) { … } — function",
							"—Ⓕ– js_misc_write_object ( ) { … } — function",
							"—Ⓕ– js_misc_read_object ( ) { … } — function",
							"—Ⓕ– js_misc_getx ( ) { … } — function",
							"—Ⓕ– js_misc_valuetype ( ) { … } — function",
							"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
							"—Ⓕ– js_misc_opcodes ( ) { … } — function",
							"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
							"—Ⓕ– js_misc_atom ( ) { … } — function",
							"—Ⓕ– js_misc_classid ( ) { … } — function",
							"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
							"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
							"—Ⓕ– js_misc_random ( ) { … } — function",
							"—Ⓕ– js_misc_escape ( ) { … } — function",
							"—Ⓕ– js_misc_quote ( ) { … } — function",
							"—Ⓕ– js_misc_error ( ) { … } — function",
							"—Ⓕ– js_misc_is ( ) { … } — function",
							"—Ⓕ– js_misc_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"BAAAAAAAAAAAAAAAAAAAAAAAAAC6CQAA4oCU4pK44oCTIHBjZ19zdGF0ZV9zZXRzZXFfNjQgeyDigKYgfSA7IOKAlCB0eXBlCiAg4pOJICBwY2czMl9yYW5kb21fdCA7IOKAlCB0eXBlZGVmCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX2luaXRfc3RhdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb21fYm91bmRlZF9kaXZpc2lvbmxlc3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ieXRlY29kZV9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdHJpbmdfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b3N0cmluZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9wb2ludGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY190b2FycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19kdXBhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVzaXplYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NvbmNhdGFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19zZWFyY2hhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY3JlYWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHByb3RvdHlwZWNoYWluICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ocnRpbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2ZubWF0Y2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3VuYW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19idG9hICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9iICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb21waWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY193cml0ZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JlYWRfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXR4ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY192YWx1ZXR5cGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2V2YWxiaW5hcnkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0X2J5dGVjb2RlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jbGFzc2lkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19iaXRmaWVsZF90b19hcnJheSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXJyYXlfdG9fYml0ZmllbGQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3JhbmRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXNjYXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19xdW90ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2lzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pbml0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0AAAAAAAAAADyBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugkAAOKAlOKSuOKAkyBwY2dfc3RhdGVfc2V0c2VxXzY0IHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcGNnMzJfcmFuZG9tX3QgOyDigJQgdHlwZWRlZgrigJTikrvigJMgcGNnMzJfcmFuZG9tX3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBwY2czMl9pbml0X3N0YXRlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcGNnMzJfcmFuZG9tX2JvdW5kZWRfZGl2aXNpb25sZXNzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYnl0ZWNvZGVfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RyaW5nX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX2FycmF5YnVmZmVyX2ZyZWVfZnVuYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9zdHJpbmcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3RvcG9pbnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9hcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZHVwYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Jlc2l6ZWFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb25jYXRhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfc2VhcmNoYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHBlcmZvcm1hbmNlY291bnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY2xpbmsgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Byb2NyZWFkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXRwcm90b3R5cGVjaGFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaHJ0aW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19mbm1hdGNoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY191bmFtZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYnRvYSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvYiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY29tcGlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfd3JpdGVfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yZWFkX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0eCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdmFsdWV0eXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ldmFsYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19vcGNvZGVfYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZV9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX29wY29kZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldF9ieXRlY29kZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYXRvbSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfY2xhc3NpZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfYml0ZmllbGRfdG9fYXJyYXkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2FycmF5X3RvX2JpdGZpZWxkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19yYW5kb20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2VzY2FwZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcXVvdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19pcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIEpTX0lOSVRfTU9EVUxFIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBKU19JTklUX01PRFVMRSDigKYg4oCUIG1hY3JvIG9iamVjdAAAAAAAAAAA8gcAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				]
			]
		},
		{
			"contents": "#ifndef BUFFER_UTILS_H\n#define BUFFER_UTILS_H\n\n#include <quickjs.h>\n#include <cutils.h>\n#include <stdarg.h>\n\n#include \"char-utils.h\"\n\n#ifndef MAX_NUM\n#define MAX_NUM(a, b) ((a) > (b) ? (a) : (b))\n#endif\n#ifndef MIN_NUM\n#define MIN_NUM(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\nsize_t ansi_length(const char*, size_t);\nsize_t ansi_skip(const char*, size_t);\nsize_t ansi_truncate(const char*, size_t, size_t limit);\nint64_t array_search(void*, size_t, size_t elsz, void* needle);\nchar* str_escape(const char*);\nchar* byte_escape(const void*, size_t);\nsize_t byte_findb(const void*, size_t, const void* what, size_t wlen);\nsize_t byte_finds(const void*, size_t, const char* what);\nsize_t byte_equal(const void* s, size_t n, const void* t);\nchar* dbuf_at_n(const DynBuf*, size_t, size_t* n, char sep);\nconst char* dbuf_last_line(DynBuf*, size_t*);\nint dbuf_prepend(DynBuf*, const uint8_t*, size_t len);\nvoid dbuf_put_colorstr(DynBuf*, const char*, const char* color, int with_color);\nvoid dbuf_put_escaped_pred(DynBuf*, const char*, size_t len, int (*pred)(int));\nvoid dbuf_put_escaped_table(DynBuf*, const char*, size_t len, const char table[256]);\nvoid dbuf_put_unescaped_pred(DynBuf*, const char*, size_t len, int (*pred)(int));\nvoid dbuf_put_escaped(DynBuf*, const char*, size_t len);\nvoid dbuf_put_value(DynBuf*, JSContext*, JSValue value);\nint dbuf_reserve_start(DynBuf*, size_t);\nsize_t dbuf_token_pop(DynBuf*, char);\nsize_t dbuf_token_push(DynBuf*, const char*, size_t len, char delim);\nJSValue dbuf_tostring_free(DynBuf*, JSContext*);\nssize_t dbuf_load(DynBuf*, const char*);\n\nstatic inline int\ndbuf_putm(DynBuf* db, ...) {\n  int r = 0;\n  va_list a;\n  const char* s;\n  va_start(a, db);\n  while((s = va_arg(a, char*)))\n    if(dbuf_putstr(db, s))\n      return -1;\n  va_end(a);\n  return r;\n}\n\n#define dbuf_append(d, x, n) dbuf_put((d), (const uint8_t*)(x), (n))\n\nstatic inline size_t\ndbuf_count(DynBuf* db, int ch) {\n  return byte_count(db->buf, db->size, ch);\n}\n\nstatic inline void\ndbuf_0(DynBuf* db) {\n  dbuf_putc(db, '\\0');\n  db->size--;\n}\n\nstatic inline void\ndbuf_zero(DynBuf* db) {\n  dbuf_realloc(db, 0);\n}\n\nstatic inline int32_t\ndbuf_get_column(DynBuf* db) {\n  size_t len;\n  const char* str;\n  if(db->size) {\n    str = dbuf_last_line(db, &len);\n    return ansi_length(str, len);\n  }\n  return 0;\n}\n\nstatic inline size_t\ndbuf_bitflags(DynBuf* db, uint32_t bits, const char* const names[]) {\n  size_t i, n = 0;\n  for(i = 0; i < sizeof(bits) * 8; i++) {\n    if(bits & (1 << i)) {\n      size_t len = strlen(names[i]);\n      if(n) {\n        n++;\n        dbuf_putstr(db, \"|\");\n      }\n      dbuf_append(db, names[i], len);\n      n += len;\n    }\n  }\n  return n;\n}\n\nstruct memory_block;\nstruct pointer_range;\nstruct offset_length;\n\ntypedef struct memory_block {\n  uint8_t* base;\n  size_t size;\n} MemoryBlock;\n\nstatic inline void\nblock_init(MemoryBlock* mb) {\n  mb->base = 0;\n  mb->size = 0;\n}\n\nstatic inline void*\nblock_data(MemoryBlock* mb) {\n  return mb->base;\n}\n\nstatic inline size_t\nblock_length(MemoryBlock* mb) {\n  return mb->size;\n}\n\nstatic inline BOOL\nblock_arraybuffer(MemoryBlock* mb, JSValueConst ab, JSContext* ctx) {\n  return !!(mb->base = JS_GetArrayBuffer(ctx, &mb->size, ab));\n}\n\ntypedef struct pointer_range {\n  uint8_t *start, *end;\n} PointerRange;\n\nstatic inline void\nrange_init(PointerRange* pr) {\n  pr->end = pr->start = 0;\n}\n\nstatic inline PointerRange\nrange_from(const MemoryBlock* mb) {\n  return (PointerRange){mb->base, mb->base + mb->size};\n}\n\ntypedef struct offset_length {\n  int64_t offset, length;\n} OffsetLength;\n\nstatic inline void\noffset_init(OffsetLength* ol) {\n  ol->offset = 0;\n  ol->length = INT64_MAX;\n}\n\nstatic inline BOOL\noffset_is_default(const OffsetLength* ol) {\n  return ol->offset == 0 && ol->length == INT64_MAX;\n}\n\nstatic inline uint8_t*\noffset_data(const OffsetLength* ol, const void* x) {\n  return (uint8_t*)x + ol->offset;\n}\n\nstatic inline size_t\noffset_size(const OffsetLength* ol, size_t n) {\n  return MIN_NUM(ol->length, n - ol->offset);\n}\n\nstatic inline MemoryBlock\noffset_block(const OffsetLength* ol, const void* x, size_t n) {\n  return (MemoryBlock){offset_data(ol, x), offset_size(ol, n)};\n}\n\nstatic inline PointerRange\noffset_range(const OffsetLength* ol, const void* x, size_t n) {\n  MemoryBlock mb = offset_block(ol, x, n);\n  return range_from(&mb);\n}\n\nstatic inline OffsetLength\noffset_slice(const OffsetLength ol, int64_t start, int64_t end) {\n  if(start < 0)\n    start = ol.length + (start % ol.length);\n  else if(start > ol.length)\n    start = ol.length;\n  if(end < 0)\n    end = ol.length + (end % ol.length);\n  else if(end > ol.length)\n    end = ol.length;\n\n  return (OffsetLength){start, end - start};\n}\n\nstatic inline OffsetLength\noffset_offset(const OffsetLength* ol, const OffsetLength* by) {\n  OffsetLength ret;\n  ret.offset = ol->offset + by->offset;\n  ret.length = MIN_NUM(by->length, ol->length - by->offset);\n  return ret;\n}\n\nstatic inline MemoryBlock\nblock_range(const MemoryBlock* mb, struct offset_length* range) {\n  MemoryBlock ret;\n  ret.base = mb->base + range->offset;\n  ret.size = MIN_NUM(range->length, mb->size - range->offset);\n  return ret;\n}\n\ntypedef struct InputBuffer {\n  uint8_t* data;\n  size_t pos, size;\n  void (*free)(JSContext*, const char*, JSValue);\n  JSValue value;\n  OffsetLength range;\n} InputBuffer;\n\nstatic inline void\ninput_buffer_free_default(JSContext* ctx, const char* str, JSValue val) {\n  if(JS_IsString(val))\n    JS_FreeCString(ctx, str);\n\n  if(!JS_IsUndefined(val))\n    JS_FreeValue(ctx, val);\n}\n\nInputBuffer js_input_buffer(JSContext* ctx, JSValueConst value);\nInputBuffer js_input_chars(JSContext* ctx, JSValueConst value);\nInputBuffer input_buffer_clone(const InputBuffer* in, JSContext* ctx);\nBOOL input_buffer_valid(const InputBuffer* in);\nvoid input_buffer_dump(const InputBuffer* in, DynBuf* db);\nvoid input_buffer_free(InputBuffer* in, JSContext* ctx);\n\nstatic inline uint8_t*\ninput_buffer_data(const InputBuffer* in) {\n  return in->data + in->range.offset;\n}\n\nstatic inline size_t\ninput_buffer_length(const InputBuffer* in) {\n  return MIN_NUM(in->range.length, in->size);\n}\n\nstatic inline MemoryBlock\ninput_buffer_block(InputBuffer* in) {\n  return (MemoryBlock){input_buffer_data(in), input_buffer_length(in)};\n}\n\nstatic inline InputBuffer\ninput_buffer_offset(InputBuffer in, OffsetLength off) {\n  InputBuffer ret = in;\n\n  ret.data += off.offset;\n  ret.size -= off.offset;\n\n  if(ret.size > off.length)\n    ret.size = off.length;\n\n  return ret;\n}\n\nconst uint8_t* input_buffer_get(InputBuffer* in, size_t* lenp);\nconst uint8_t* input_buffer_peek(InputBuffer* in, size_t* lenp);\nconst char* input_buffer_currentline(InputBuffer*, size_t* len);\nsize_t input_buffer_column(InputBuffer*, size_t* len);\n\nstatic int\ninput_buffer_peekc(InputBuffer* in, size_t* lenp) {\n  const uint8_t *pos, *end, *next;\n  int cp;\n  pos = input_buffer_data(in) + in->pos;\n  end = input_buffer_data(in) + input_buffer_length(in);\n  cp = unicode_from_utf8(pos, end - pos, &next);\n  if(lenp)\n    *lenp = next - pos;\n\n  return cp;\n}\n\nstatic inline int\ninput_buffer_getc(InputBuffer* in) {\n  size_t n;\n  int ret;\n  ret = input_buffer_peekc(in, &n);\n  in->pos += n;\n  return ret;\n}\n\nstatic inline uint8_t*\ninput_buffer_begin(const InputBuffer* in) {\n  return input_buffer_data(in);\n}\nstatic inline uint8_t*\ninput_buffer_end(const InputBuffer* in) {\n  return input_buffer_data(in) + input_buffer_length(in);\n}\nstatic inline BOOL\ninput_buffer_eof(const InputBuffer* in) {\n  return in->pos == input_buffer_length(in);\n}\nstatic inline size_t\ninput_buffer_remain(const InputBuffer* in) {\n  return input_buffer_length(in) - in->pos;\n}\n\nOffsetLength js_offset_length(JSContext*, int64_t size, int argc, JSValue argv[]);\n\n#endif /* defined(BUFFER_UTILS) */\n",
			"file": "buffer-utils.h",
			"file_size": 7730,
			"file_write_time": 132770140952334745,
			"settings":
			{
				"buffer_size": 7730,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					35,
					1,
					"revert",
					null,
					"BAAAAAAAAAAAAAAAAAAAAAAAAACXHQAAI2lmbmRlZiBCVUZGRVJfVVRJTFNfSAojZGVmaW5lIEJVRkZFUl9VVElMU19ICgojaW5jbHVkZSA8cXVpY2tqcy5oPgojaW5jbHVkZSA8Y3V0aWxzLmg+CiNpbmNsdWRlIDxzdGRhcmcuaD4KCiNpbmNsdWRlICJjaGFyLXV0aWxzLmgiCgojaWZuZGVmIE1BWF9OVU0KI2RlZmluZSBNQVhfTlVNKGEsIGIpICgoYSkgPiAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgojaWZuZGVmIE1JTl9OVU0KI2RlZmluZSBNSU5fTlVNKGEsIGIpICgoYSkgPCAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgoKc2l6ZV90IGFuc2lfbGVuZ3RoKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV9za2lwKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV90cnVuY2F0ZShjb25zdCBjaGFyKiwgc2l6ZV90LCBzaXplX3QgbGltaXQpOwppbnQ2NF90IGFycmF5X3NlYXJjaCh2b2lkKiwgc2l6ZV90LCBzaXplX3QgZWxzeiwgdm9pZCogbmVlZGxlKTsKY2hhciogc3RyX2VzY2FwZShjb25zdCBjaGFyKik7CmNoYXIqIGJ5dGVfZXNjYXBlKGNvbnN0IHZvaWQqLCBzaXplX3QpOwpzaXplX3QgYnl0ZV9maW5kYihjb25zdCB2b2lkKiwgc2l6ZV90LCBjb25zdCB2b2lkKiB3aGF0LCBzaXplX3Qgd2xlbik7CnNpemVfdCBieXRlX2ZpbmRzKGNvbnN0IHZvaWQqLCBzaXplX3QsIGNvbnN0IGNoYXIqIHdoYXQpOwpzaXplX3QgYnl0ZV9lcXVhbChjb25zdCB2b2lkKiBzLCBzaXplX3QgbiwgY29uc3Qgdm9pZCogdCk7CmNoYXIqIGRidWZfYXRfbihjb25zdCBEeW5CdWYqLCBzaXplX3QsIHNpemVfdCogbiwgY2hhciBzZXApOwpjb25zdCBjaGFyKiBkYnVmX2xhc3RfbGluZShEeW5CdWYqLCBzaXplX3QqKTsKaW50IGRidWZfcHJlcGVuZChEeW5CdWYqLCBjb25zdCB1aW50OF90Kiwgc2l6ZV90IGxlbik7CnZvaWQgZGJ1Zl9wdXRfY29sb3JzdHIoRHluQnVmKiwgY29uc3QgY2hhciosIGNvbnN0IGNoYXIqIGNvbG9yLCBpbnQgd2l0aF9jb2xvcik7CnZvaWQgZGJ1Zl9wdXRfZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkX3RhYmxlKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBjb25zdCBjaGFyIHRhYmxlWzI1Nl0pOwp2b2lkIGRidWZfcHV0X3VuZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuKTsKdm9pZCBkYnVmX3B1dF92YWx1ZShEeW5CdWYqLCBKU0NvbnRleHQqLCBKU1ZhbHVlIHZhbHVlKTsKaW50IGRidWZfcmVzZXJ2ZV9zdGFydChEeW5CdWYqLCBzaXplX3QpOwpzaXplX3QgZGJ1Zl90b2tlbl9wb3AoRHluQnVmKiwgY2hhcik7CnNpemVfdCBkYnVmX3Rva2VuX3B1c2goRHluQnVmKiwgY29uc3QgY2hhciosIHNpemVfdCBsZW4sIGNoYXIgZGVsaW0pOwpKU1ZhbHVlIGRidWZfdG9zdHJpbmdfZnJlZShEeW5CdWYqLCBKU0NvbnRleHQqKTsKc3NpemVfdCBkYnVmX2xvYWQoRHluQnVmKiwgY29uc3QgY2hhciopOwoKc3RhdGljIGlubGluZSBpbnQKZGJ1Zl9wdXRtKER5bkJ1ZiogZGIsIC4uLikgewogIGludCByID0gMDsKICB2YV9saXN0IGE7CiAgY29uc3QgY2hhciogczsKICB2YV9zdGFydChhLCBkYik7CiAgd2hpbGUoKHMgPSB2YV9hcmcoYSwgY2hhciopKSkKICAgIGlmKGRidWZfcHV0c3RyKGRiLCBzKSkKICAgICAgcmV0dXJuIC0xOwogIHZhX2VuZChhKTsKICByZXR1cm4gcjsKfQoKI2RlZmluZSBkYnVmX2FwcGVuZChkLCB4LCBuKSBkYnVmX3B1dCgoZCksIChjb25zdCB1aW50OF90KikoeCksIChuKSkKCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfY291bnQoRHluQnVmKiBkYiwgaW50IGNoKSB7CiAgcmV0dXJuIGJ5dGVfY291bnQoZGItPmJ1ZiwgZGItPnNpemUsIGNoKTsKfQoKc3RhdGljIGlubGluZSB2b2lkCmRidWZfMChEeW5CdWYqIGRiKSB7CiAgZGJ1Zl9wdXRjKGRiLCAnXDAnKTsKICBkYi0+c2l6ZS0tOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQKZGJ1Zl96ZXJvKER5bkJ1ZiogZGIpIHsKICBkYnVmX3JlYWxsb2MoZGIsIDApOwp9CgpzdGF0aWMgaW5saW5lIGludDMyX3QKZGJ1Zl9nZXRfY29sdW1uKER5bkJ1ZiogZGIpIHsKICBzaXplX3QgbGVuOwogIGNvbnN0IGNoYXIqIHN0cjsKICBpZihkYi0+c2l6ZSkgewogICAgc3RyID0gZGJ1Zl9sYXN0X2xpbmUoZGIsICZsZW4pOwogICAgcmV0dXJuIGFuc2lfbGVuZ3RoKHN0ciwgbGVuKTsKICB9CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfYml0ZmxhZ3MoRHluQnVmKiBkYiwgdWludDMyX3QgYml0cywgY29uc3QgY2hhciogY29uc3QgbmFtZXNbXSkgewogIHNpemVfdCBpLCBuID0gMDsKICBmb3IoaSA9IDA7IGkgPCBzaXplb2YoYml0cykgKiA4OyBpKyspIHsKICAgIGlmKGJpdHMgJiAoMSA8PCBpKSkgewogICAgICBzaXplX3QgbGVuID0gc3RybGVuKG5hbWVzW2ldKTsKICAgICAgaWYobikgewogICAgICAgIG4rKzsKICAgICAgICBkYnVmX3B1dHN0cihkYiwgInwiKTsKICAgICAgfQogICAgICBkYnVmX2FwcGVuZChkYiwgbmFtZXNbaV0sIGxlbik7CiAgICAgIG4gKz0gbGVuOwogICAgfQogIH0KICByZXR1cm4gbjsKfQoKc3RydWN0IG1lbW9yeV9ibG9jazsKc3RydWN0IHBvaW50ZXJfcmFuZ2U7CnN0cnVjdCBvZmZzZXRfbGVuZ3RoOwoKdHlwZWRlZiBzdHJ1Y3QgbWVtb3J5X2Jsb2NrIHsKICB1aW50OF90KiBiYXNlOwogIHNpemVfdCBzaXplOwp9IE1lbW9yeUJsb2NrOwoKc3RhdGljIGlubGluZSB2b2lkCmJsb2NrX2luaXQoTWVtb3J5QmxvY2sqIG1iKSB7CiAgbWItPmJhc2UgPSAwOwogIG1iLT5zaXplID0gMDsKfQoKc3RhdGljIGlubGluZSB2b2lkKgpibG9ja19kYXRhKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+YmFzZTsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKYmxvY2tfbGVuZ3RoKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+c2l6ZTsKfQoKdHlwZWRlZiBzdHJ1Y3QgcG9pbnRlcl9yYW5nZSB7CiAgdWludDhfdCAqc3RhcnQsICplbmQ7Cn0gUG9pbnRlclJhbmdlOwoKc3RhdGljIGlubGluZSB2b2lkCnJhbmdlX2luaXQoUG9pbnRlclJhbmdlKiBwcikgewogIHByLT5lbmQgPSBwci0+c3RhcnQgPSAwOwp9CgpzdGF0aWMgaW5saW5lIFBvaW50ZXJSYW5nZQpyYW5nZV9mcm9tKGNvbnN0IE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiAoUG9pbnRlclJhbmdlKXttYi0+YmFzZSwgbWItPmJhc2UgKyBtYi0+c2l6ZX07Cn0KCnR5cGVkZWYgc3RydWN0IG9mZnNldF9sZW5ndGggewogIGludDY0X3Qgb2Zmc2V0LCBsZW5ndGg7Cn0gT2Zmc2V0TGVuZ3RoOwoKc3RhdGljIGlubGluZSB2b2lkCm9mZnNldF9pbml0KE9mZnNldExlbmd0aCogb2wpIHsKICBvbC0+b2Zmc2V0ID0gMDsKICBvbC0+bGVuZ3RoID0gSU5UNjRfTUFYOwp9CgpzdGF0aWMgaW5saW5lIEJPT0wKb2Zmc2V0X2lzX2RlZmF1bHQoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCkgewogIHJldHVybiBvbC0+b2Zmc2V0ID09IDAgJiYgb2wtPmxlbmd0aCA9PSBJTlQ2NF9NQVg7Cn0KCnN0YXRpYyBpbmxpbmUgdWludDhfdCoKb2Zmc2V0X2RhdGEoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCwgY29uc3Qgdm9pZCogeCkgewogIHJldHVybiAodWludDhfdCopeCArIG9sLT5vZmZzZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90Cm9mZnNldF9zaXplKGNvbnN0IE9mZnNldExlbmd0aCogb2wsIHNpemVfdCBuKSB7CiAgcmV0dXJuIE1JTl9OVU0ob2wtPmxlbmd0aCwgbiAtIG9sLT5vZmZzZXQpOwp9CgpzdGF0aWMgaW5saW5lIE1lbW9yeUJsb2NrCm9mZnNldF9ibG9jayhjb25zdCBPZmZzZXRMZW5ndGgqIG9sLCBjb25zdCB2b2lkKiB4LCBzaXplX3QgbikgewogIHJldHVybiAoTWVtb3J5QmxvY2spe29mZnNldF9kYXRhKG9sLCB4KSwgb2Zmc2V0X3NpemUob2wsIG4pfTsKfQoKc3RhdGljIGlubGluZSBQb2ludGVyUmFuZ2UKb2Zmc2V0X3JhbmdlKGNvbnN0IE9mZnNldExlbmd0aCogb2wsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBuKSB7CiAgTWVtb3J5QmxvY2sgbWIgPSBvZmZzZXRfYmxvY2sob2wsIHgsIG4pOwogIHJldHVybiByYW5nZV9mcm9tKCZtYik7Cn0KCnN0YXRpYyBpbmxpbmUgT2Zmc2V0TGVuZ3RoCm9mZnNldF9zbGljZShjb25zdCBPZmZzZXRMZW5ndGggb2wsIGludDY0X3Qgc3RhcnQsIGludDY0X3QgZW5kKSB7CiAgaWYoc3RhcnQgPCAwKQogICAgc3RhcnQgPSBvbC5sZW5ndGggKyAoc3RhcnQgJSBvbC5sZW5ndGgpOwogIGVsc2UgaWYoc3RhcnQgPiBvbC5sZW5ndGgpCiAgICBzdGFydCA9IG9sLmxlbmd0aDsKICBpZihlbmQgPCAwKQogICAgZW5kID0gb2wubGVuZ3RoICsgKGVuZCAlIG9sLmxlbmd0aCk7CiAgZWxzZSBpZihlbmQgPiBvbC5sZW5ndGgpCiAgICBlbmQgPSBvbC5sZW5ndGg7CgogIHJldHVybiAoT2Zmc2V0TGVuZ3RoKXtzdGFydCwgZW5kIC0gc3RhcnR9Owp9CgpzdGF0aWMgaW5saW5lIE9mZnNldExlbmd0aApvZmZzZXRfb2Zmc2V0KGNvbnN0IE9mZnNldExlbmd0aCogb2wsIGNvbnN0IE9mZnNldExlbmd0aCogYnkpIHsKICBPZmZzZXRMZW5ndGggcmV0OwogIHJldC5vZmZzZXQgPSBvbC0+b2Zmc2V0ICsgYnktPm9mZnNldDsKICByZXQubGVuZ3RoID0gTUlOX05VTShieS0+bGVuZ3RoLCBvbC0+bGVuZ3RoIC0gYnktPm9mZnNldCk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBNZW1vcnlCbG9jawpibG9ja19yYW5nZShjb25zdCBNZW1vcnlCbG9jayogbWIsIHN0cnVjdCBvZmZzZXRfbGVuZ3RoKiByYW5nZSkgewogIE1lbW9yeUJsb2NrIHJldDsKICByZXQuYmFzZSA9IG1iLT5iYXNlICsgcmFuZ2UtPm9mZnNldDsKICByZXQuc2l6ZSA9IE1JTl9OVU0ocmFuZ2UtPmxlbmd0aCwgbWItPnNpemUgLSByYW5nZS0+b2Zmc2V0KTsKICByZXR1cm4gcmV0Owp9Cgp0eXBlZGVmIHN0cnVjdCBJbnB1dEJ1ZmZlciB7CiAgdWludDhfdCogZGF0YTsKICBzaXplX3QgcG9zLCBzaXplOwogIHZvaWQgKCpmcmVlKShKU0NvbnRleHQqLCBjb25zdCBjaGFyKiwgSlNWYWx1ZSk7CiAgSlNWYWx1ZSB2YWx1ZTsKICBPZmZzZXRMZW5ndGggcmFuZ2U7Cn0gSW5wdXRCdWZmZXI7CgpzdGF0aWMgaW5saW5lIHZvaWQKaW5wdXRfYnVmZmVyX2ZyZWVfZGVmYXVsdChKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogc3RyLCBKU1ZhbHVlIHZhbCkgewogIGlmKEpTX0lzU3RyaW5nKHZhbCkpCiAgICBKU19GcmVlQ1N0cmluZyhjdHgsIHN0cik7CgogIGlmKCFKU19Jc1VuZGVmaW5lZCh2YWwpKQogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsKTsKfQoKSW5wdXRCdWZmZXIganNfaW5wdXRfYnVmZmVyKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwpJbnB1dEJ1ZmZlciBqc19pbnB1dF9jaGFycyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKSW5wdXRCdWZmZXIgaW5wdXRfYnVmZmVyX2Nsb25lKGNvbnN0IElucHV0QnVmZmVyKiBpbiwgSlNDb250ZXh0KiBjdHgpOwpCT09MIGlucHV0X2J1ZmZlcl92YWxpZChjb25zdCBJbnB1dEJ1ZmZlciogaW4pOwp2b2lkIGlucHV0X2J1ZmZlcl9kdW1wKGNvbnN0IElucHV0QnVmZmVyKiBpbiwgRHluQnVmKiBkYik7CnZvaWQgaW5wdXRfYnVmZmVyX2ZyZWUoSW5wdXRCdWZmZXIqIGluLCBKU0NvbnRleHQqIGN0eCk7CgpzdGF0aWMgaW5saW5lIHVpbnQ4X3QqCmlucHV0X2J1ZmZlcl9kYXRhKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbi0+ZGF0YSArIGluLT5yYW5nZS5vZmZzZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmlucHV0X2J1ZmZlcl9sZW5ndGgoY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIE1JTl9OVU0oaW4tPnJhbmdlLmxlbmd0aCwgaW4tPnNpemUpOwp9CgpzdGF0aWMgaW5saW5lIE1lbW9yeUJsb2NrCmlucHV0X2J1ZmZlcl9ibG9jayhJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gKE1lbW9yeUJsb2NrKXtpbnB1dF9idWZmZXJfZGF0YShpbiksIGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pfTsKfQoKc3RhdGljIGlubGluZSBJbnB1dEJ1ZmZlcgppbnB1dF9idWZmZXJfb2Zmc2V0KElucHV0QnVmZmVyIGluLCBPZmZzZXRMZW5ndGggb2ZmKSB7CiAgSW5wdXRCdWZmZXIgcmV0ID0gaW47CgogIHJldC5kYXRhICs9IG9mZi5vZmZzZXQ7CiAgcmV0LnNpemUgLT0gb2ZmLm9mZnNldDsKCiAgaWYocmV0LnNpemUgPiBvZmYubGVuZ3RoKQogICAgcmV0LnNpemUgPSBvZmYubGVuZ3RoOwoKICByZXR1cm4gcmV0Owp9Cgpjb25zdCB1aW50OF90KiBpbnB1dF9idWZmZXJfZ2V0KElucHV0QnVmZmVyKiBpbiwgc2l6ZV90KiBsZW5wKTsKY29uc3QgdWludDhfdCogaW5wdXRfYnVmZmVyX3BlZWsoSW5wdXRCdWZmZXIqIGluLCBzaXplX3QqIGxlbnApOwpjb25zdCBjaGFyKiBpbnB1dF9idWZmZXJfY3VycmVudGxpbmUoSW5wdXRCdWZmZXIqLCBzaXplX3QqIGxlbik7CnNpemVfdCBpbnB1dF9idWZmZXJfY29sdW1uKElucHV0QnVmZmVyKiwgc2l6ZV90KiBsZW4pOwoKc3RhdGljIGludAppbnB1dF9idWZmZXJfcGVla2MoSW5wdXRCdWZmZXIqIGluLCBzaXplX3QqIGxlbnApIHsKICBjb25zdCB1aW50OF90ICpwb3MsICplbmQsICpuZXh0OwogIGludCBjcDsKICBwb3MgPSBpbnB1dF9idWZmZXJfZGF0YShpbikgKyBpbi0+cG9zOwogIGVuZCA9IGlucHV0X2J1ZmZlcl9kYXRhKGluKSArIGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pOwogIGNwID0gdW5pY29kZV9mcm9tX3V0ZjgocG9zLCBlbmQgLSBwb3MsICZuZXh0KTsKICBpZihsZW5wKQogICAgKmxlbnAgPSBuZXh0IC0gcG9zOwoKICByZXR1cm4gY3A7Cn0KCnN0YXRpYyBpbmxpbmUgaW50CmlucHV0X2J1ZmZlcl9nZXRjKElucHV0QnVmZmVyKiBpbikgewogIHNpemVfdCBuOwogIGludCByZXQ7CiAgcmV0ID0gaW5wdXRfYnVmZmVyX3BlZWtjKGluLCAmbik7CiAgaW4tPnBvcyArPSBuOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgdWludDhfdCoKaW5wdXRfYnVmZmVyX2JlZ2luKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbnB1dF9idWZmZXJfZGF0YShpbik7Cn0Kc3RhdGljIGlubGluZSB1aW50OF90KgppbnB1dF9idWZmZXJfZW5kKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbnB1dF9idWZmZXJfZGF0YShpbikgKyBpbnB1dF9idWZmZXJfbGVuZ3RoKGluKTsKfQpzdGF0aWMgaW5saW5lIEJPT0wKaW5wdXRfYnVmZmVyX2VvZihjb25zdCBJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gaW4tPnBvcyA9PSBpbnB1dF9idWZmZXJfbGVuZ3RoKGluKTsKfQpzdGF0aWMgaW5saW5lIHNpemVfdAppbnB1dF9idWZmZXJfcmVtYWluKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbnB1dF9idWZmZXJfbGVuZ3RoKGluKSAtIGluLT5wb3M7Cn0KCk9mZnNldExlbmd0aCBqc19vZmZzZXRfbGVuZ3RoKEpTQ29udGV4dCosIGludDY0X3Qgc2l6ZSwgaW50IGFyZ2MsIEpTVmFsdWUgYXJndltdKTsKCiNlbmRpZiAvKiBkZWZpbmVkKEJVRkZFUl9VVElMUykgKi8KAAAAAAAAAACXHQAAAAAAAAAAAAAAAAAAAAAAAJcdAAAAAAAAAAAAAAAAAAAAAAAAlx0AAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAADw0AAAAAAAAWDQAAAAAAAAAAAAAAAPC/"
				],
				[
					106,
					1,
					"cut",
					null,
					"AQAAAI8LAAAAAAAAjwsAAAAAAABMAAAACgpzdGF0aWMgaW5saW5lIHNpemVfdApibG9ja19sZW5ndGgoTWVtb3J5QmxvY2sqIG1iKSB7CiAgcmV0dXJuIG1iLT5zaXplOwp9Cg",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAACPCwAAAAAAANsLAAAAAAAAAAAAAAAA8L8"
				],
				[
					107,
					2,
					"paste",
					null,
					"AgAAAI8LAAAAAAAA2wsAAAAAAAAAAAAA2wsAAAAAAAAnDAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAACPCwAAAAAAAI8LAAAAAAAAAAAAAAAA8L8"
				],
				[
					112,
					1,
					"insert",
					{
						"characters": "BOOL"
					},
					"BQAAAOsLAAAAAAAA7AsAAAAAAAAAAAAA7AsAAAAAAADsCwAAAAAAAAYAAABzaXplX3TsCwAAAAAAAO0LAAAAAAAAAAAAAO0LAAAAAAAA7gsAAAAAAAAAAAAA7gsAAAAAAADvCwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAADrCwAAAAAAAPELAAAAAAAAAAAAAAAA8L8"
				],
				[
					115,
					1,
					"insert",
					{
						"characters": "arraybuffer"
					},
					"DAAAAPYLAAAAAAAA9wsAAAAAAAAAAAAA9wsAAAAAAAD3CwAAAAAAAAYAAABsZW5ndGj3CwAAAAAAAPgLAAAAAAAAAAAAAPgLAAAAAAAA+QsAAAAAAAAAAAAA+QsAAAAAAAD6CwAAAAAAAAAAAAD6CwAAAAAAAPsLAAAAAAAAAAAAAPsLAAAAAAAA/AsAAAAAAAAAAAAA/AsAAAAAAAD9CwAAAAAAAAAAAAD9CwAAAAAAAP4LAAAAAAAAAAAAAP4LAAAAAAAA/wsAAAAAAAAAAAAA/wsAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAEMAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAD2CwAAAAAAAPwLAAAAAAAAAAAAAAAA8L8"
				],
				[
					118,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAABEMAAAAAAAAEgwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAARDAAAAAAAABEMAAAAAAAAAAAAAAAA8L8"
				],
				[
					119,
					1,
					"insert",
					{
						"characters": " JSVAlueC"
					},
					"CQAAABIMAAAAAAAAEwwAAAAAAAAAAAAAEwwAAAAAAAAUDAAAAAAAAAAAAAAUDAAAAAAAABUMAAAAAAAAAAAAABUMAAAAAAAAFgwAAAAAAAAAAAAAFgwAAAAAAAAXDAAAAAAAAAAAAAAXDAAAAAAAABgMAAAAAAAAAAAAABgMAAAAAAAAGQwAAAAAAAAAAAAAGQwAAAAAAAAaDAAAAAAAAAAAAAAaDAAAAAAAABsMAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAASDAAAAAAAABIMAAAAAAAAAAAAAAAA8L8"
				],
				[
					120,
					5,
					"left_delete",
					null,
					"BQAAABoMAAAAAAAAGgwAAAAAAAABAAAAQxkMAAAAAAAAGQwAAAAAAAABAAAAZRgMAAAAAAAAGAwAAAAAAAABAAAAdRcMAAAAAAAAFwwAAAAAAAABAAAAbBYMAAAAAAAAFgwAAAAAAAABAAAAQQ",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAbDAAAAAAAABsMAAAAAAAAAAAAAAAA8L8"
				],
				[
					121,
					1,
					"insert",
					{
						"characters": "alueConst"
					},
					"CQAAABYMAAAAAAAAFwwAAAAAAAAAAAAAFwwAAAAAAAAYDAAAAAAAAAAAAAAYDAAAAAAAABkMAAAAAAAAAAAAABkMAAAAAAAAGgwAAAAAAAAAAAAAGgwAAAAAAAAbDAAAAAAAAAAAAAAbDAAAAAAAABwMAAAAAAAAAAAAABwMAAAAAAAAHQwAAAAAAAAAAAAAHQwAAAAAAAAeDAAAAAAAAAAAAAAeDAAAAAAAAB8MAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAWDAAAAAAAABYMAAAAAAAAAAAAAAAA8L8"
				],
				[
					122,
					1,
					"insert",
					{
						"characters": " ar"
					},
					"AwAAAB8MAAAAAAAAIAwAAAAAAAAAAAAAIAwAAAAAAAAhDAAAAAAAAAAAAAAhDAAAAAAAACIMAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAfDAAAAAAAAB8MAAAAAAAAAAAAAAAA8L8"
				],
				[
					123,
					1,
					"left_delete",
					null,
					"AQAAACEMAAAAAAAAIQwAAAAAAAABAAAAcg",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAiDAAAAAAAACIMAAAAAAAAAAAAAAAA8L8"
				],
				[
					124,
					1,
					"insert",
					{
						"characters": "b"
					},
					"AQAAACEMAAAAAAAAIgwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAhDAAAAAAAACEMAAAAAAAAAAAAAAAA8L8"
				],
				[
					126,
					1,
					"insert",
					{
						"characters": "\nJS_GetArra"
					},
					"DAAAACUMAAAAAAAAJgwAAAAAAAAAAAAAJgwAAAAAAAAoDAAAAAAAAAAAAAAoDAAAAAAAACkMAAAAAAAAAAAAACkMAAAAAAAAKgwAAAAAAAAAAAAAKgwAAAAAAAArDAAAAAAAAAAAAAArDAAAAAAAACwMAAAAAAAAAAAAACwMAAAAAAAALQwAAAAAAAAAAAAALQwAAAAAAAAuDAAAAAAAAAAAAAAuDAAAAAAAAC8MAAAAAAAAAAAAAC8MAAAAAAAAMAwAAAAAAAAAAAAAMAwAAAAAAAAxDAAAAAAAAAAAAAAxDAAAAAAAADIMAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAlDAAAAAAAACUMAAAAAAAAAAAAAAAA8L8"
				],
				[
					127,
					1,
					"insert",
					{
						"characters": "yBuffer"
					},
					"BwAAADIMAAAAAAAAMwwAAAAAAAAAAAAAMwwAAAAAAAA0DAAAAAAAAAAAAAA0DAAAAAAAADUMAAAAAAAAAAAAADUMAAAAAAAANgwAAAAAAAAAAAAANgwAAAAAAAA3DAAAAAAAAAAAAAA3DAAAAAAAADgMAAAAAAAAAAAAADgMAAAAAAAAOQwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAyDAAAAAAAADIMAAAAAAAAAAAAAAAA8L8"
				],
				[
					128,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAADkMAAAAAAAAOwwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAA5DAAAAAAAADkMAAAAAAAAAAAAAAAA8L8"
				],
				[
					131,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAACUMAAAAAAAAJgwAAAAAAAAAAAAAJgwAAAAAAAAoDAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAlDAAAAAAAACUMAAAAAAAA////////738"
				],
				[
					134,
					1,
					"insert",
					{
						"characters": "mb->ase"
					},
					"BwAAACgMAAAAAAAAKQwAAAAAAAAAAAAAKQwAAAAAAAAqDAAAAAAAAAAAAAAqDAAAAAAAACsMAAAAAAAAAAAAACsMAAAAAAAALAwAAAAAAAAAAAAALAwAAAAAAAAtDAAAAAAAAAAAAAAtDAAAAAAAAC4MAAAAAAAAAAAAAC4MAAAAAAAALwwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAoDAAAAAAAACgMAAAAAAAAAAAAAAAANEA"
				],
				[
					135,
					3,
					"left_delete",
					null,
					"AwAAAC4MAAAAAAAALgwAAAAAAAABAAAAZS0MAAAAAAAALQwAAAAAAAABAAAAcywMAAAAAAAALAwAAAAAAAABAAAAYQ",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAvDAAAAAAAAC8MAAAAAAAAAAAAAAAA8L8"
				],
				[
					136,
					1,
					"insert",
					{
						"characters": "base"
					},
					"BAAAACwMAAAAAAAALQwAAAAAAAAAAAAALQwAAAAAAAAuDAAAAAAAAAAAAAAuDAAAAAAAAC8MAAAAAAAAAAAAAC8MAAAAAAAAMAwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAsDAAAAAAAACwMAAAAAAAAAAAAAAAA8L8"
				],
				[
					137,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAADAMAAAAAAAAMQwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAwDAAAAAAAADAMAAAAAAAAAAAAAAAA8L8"
				],
				[
					138,
					2,
					"right_delete",
					null,
					"AgAAADEMAAAAAAAAMQwAAAAAAAABAAAACjEMAAAAAAAAMQwAAAAAAAABAAAAIA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAxDAAAAAAAADEMAAAAAAAAAAAAAAAA8L8"
				],
				[
					139,
					1,
					"insert",
					{
						"characters": "="
					},
					"AQAAADEMAAAAAAAAMgwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAxDAAAAAAAADEMAAAAAAAAAAAAAAAA8L8"
				],
				[
					141,
					1,
					"left_delete",
					null,
					"AQAAAEUMAAAAAAAARQwAAAAAAAABAAAAKQ",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABGDAAAAAAAAEYMAAAAAAAA////////738"
				],
				[
					142,
					1,
					"insert",
					{
						"characters": "ctx"
					},
					"AwAAAEUMAAAAAAAARgwAAAAAAAAAAAAARgwAAAAAAABHDAAAAAAAAAAAAABHDAAAAAAAAEgMAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABFDAAAAAAAAEUMAAAAAAAAAAAAAAAA8L8"
				],
				[
					143,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAEgMAAAAAAAASQwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABIDAAAAAAAAEgMAAAAAAAAAAAAAAAA8L8"
				],
				[
					144,
					1,
					"left_delete",
					null,
					"AQAAAEgMAAAAAAAASAwAAAAAAAABAAAAIA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABJDAAAAAAAAEkMAAAAAAAAAAAAAAAA8L8"
				],
				[
					145,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAAEgMAAAAAAAASQwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABIDAAAAAAAAEgMAAAAAAAAAAAAAAAA8L8"
				],
				[
					146,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAEkMAAAAAAAASgwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABJDAAAAAAAAEkMAAAAAAAAAAAAAAAA8L8"
				],
				[
					150,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAACIMAAAAAAAAIwwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAiDAAAAAAAACIMAAAAAAAAAAAAAAAA8L8"
				],
				[
					151,
					1,
					"insert",
					{
						"characters": " JSContext"
					},
					"CgAAACMMAAAAAAAAJAwAAAAAAAAAAAAAJAwAAAAAAAAlDAAAAAAAAAAAAAAlDAAAAAAAACYMAAAAAAAAAAAAACYMAAAAAAAAJwwAAAAAAAAAAAAAJwwAAAAAAAAoDAAAAAAAAAAAAAAoDAAAAAAAACkMAAAAAAAAAAAAACkMAAAAAAAAKgwAAAAAAAAAAAAAKgwAAAAAAAArDAAAAAAAAAAAAAArDAAAAAAAACwMAAAAAAAAAAAAACwMAAAAAAAALQwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAjDAAAAAAAACMMAAAAAAAAAAAAAAAA8L8"
				],
				[
					152,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAC0MAAAAAAAALgwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAtDAAAAAAAAC0MAAAAAAAAAAAAAAAA8L8"
				],
				[
					153,
					1,
					"left_delete",
					null,
					"AQAAAC0MAAAAAAAALQwAAAAAAAABAAAAIA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAuDAAAAAAAAC4MAAAAAAAAAAAAAAAA8L8"
				],
				[
					154,
					1,
					"insert",
					{
						"characters": "*"
					},
					"AQAAAC0MAAAAAAAALgwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAtDAAAAAAAAC0MAAAAAAAAAAAAAAAA8L8"
				],
				[
					155,
					1,
					"insert",
					{
						"characters": " ctx"
					},
					"BAAAAC4MAAAAAAAALwwAAAAAAAAAAAAALwwAAAAAAAAwDAAAAAAAAAAAAAAwDAAAAAAAADEMAAAAAAAAAAAAADEMAAAAAAAAMgwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAuDAAAAAAAAC4MAAAAAAAAAAAAAAAA8L8"
				],
				[
					158,
					1,
					"insert",
					{
						"characters": "&mb-s"
					},
					"BQAAAFoMAAAAAAAAWwwAAAAAAAAAAAAAWwwAAAAAAABcDAAAAAAAAAAAAABcDAAAAAAAAF0MAAAAAAAAAAAAAF0MAAAAAAAAXgwAAAAAAAAAAAAAXgwAAAAAAABfDAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABaDAAAAAAAAFoMAAAAAAAAAAAAAADwhEA"
				],
				[
					159,
					1,
					"left_delete",
					null,
					"AQAAAF4MAAAAAAAAXgwAAAAAAAABAAAAcw",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABfDAAAAAAAAF8MAAAAAAAAAAAAAAAA8L8"
				],
				[
					160,
					1,
					"insert",
					{
						"characters": ">sitze"
					},
					"BgAAAF4MAAAAAAAAXwwAAAAAAAAAAAAAXwwAAAAAAABgDAAAAAAAAAAAAABgDAAAAAAAAGEMAAAAAAAAAAAAAGEMAAAAAAAAYgwAAAAAAAAAAAAAYgwAAAAAAABjDAAAAAAAAAAAAABjDAAAAAAAAGQMAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABeDAAAAAAAAF4MAAAAAAAAAAAAAAAA8L8"
				],
				[
					161,
					3,
					"left_delete",
					null,
					"AwAAAGMMAAAAAAAAYwwAAAAAAAABAAAAZWIMAAAAAAAAYgwAAAAAAAABAAAAemEMAAAAAAAAYQwAAAAAAAABAAAAdA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABkDAAAAAAAAGQMAAAAAAAAAAAAAAAA8L8"
				],
				[
					162,
					1,
					"insert",
					{
						"characters": "ze,"
					},
					"AwAAAGEMAAAAAAAAYgwAAAAAAAAAAAAAYgwAAAAAAABjDAAAAAAAAAAAAABjDAAAAAAAAGQMAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABhDAAAAAAAAGEMAAAAAAAAAAAAAAAA8L8"
				],
				[
					163,
					1,
					"insert",
					{
						"characters": " ab);"
					},
					"BQAAAGQMAAAAAAAAZQwAAAAAAAAAAAAAZQwAAAAAAABmDAAAAAAAAAAAAABmDAAAAAAAAGcMAAAAAAAAAAAAAGcMAAAAAAAAaAwAAAAAAAAAAAAAaAwAAAAAAABpDAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABkDAAAAAAAAGQMAAAAAAAAAAAAAAAA8L8"
				],
				[
					173,
					1,
					"left_delete",
					null,
					"AQAAAGoMAAAAAAAAagwAAAAAAAATAAAAICByZXR1cm4gbWItPnNpemU7Cg",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAB9DAAAAAAAAGoMAAAAAAAAAAAAAAAAAAA"
				],
				[
					177,
					1,
					"insert",
					{
						"characters": "return"
					},
					"BgAAADgMAAAAAAAAOQwAAAAAAAAAAAAAOQwAAAAAAAA6DAAAAAAAAAAAAAA6DAAAAAAAADsMAAAAAAAAAAAAADsMAAAAAAAAPAwAAAAAAAAAAAAAPAwAAAAAAAA9DAAAAAAAAAAAAAA9DAAAAAAAAD4MAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAA4DAAAAAAAADgMAAAAAAAAAAAAAAAA8L8"
				],
				[
					178,
					1,
					"insert",
					{
						"characters": " ("
					},
					"AgAAAD4MAAAAAAAAPwwAAAAAAAAAAAAAPwwAAAAAAABADAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAA+DAAAAAAAAD4MAAAAAAAAAAAAAAAA8L8"
				],
				[
					180,
					1,
					"left_delete",
					null,
					"AQAAAHAMAAAAAAAAcAwAAAAAAAABAAAAOw",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABxDAAAAAAAAHEMAAAAAAAA////////738"
				],
				[
					181,
					1,
					"insert",
					{
						"characters": ");"
					},
					"AgAAAHAMAAAAAAAAcQwAAAAAAAAAAAAAcQwAAAAAAAByDAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABwDAAAAAAAAHAMAAAAAAAAAAAAAAAA8L8"
				],
				[
					184,
					1,
					"insert",
					{
						"characters": "!!"
					},
					"AgAAAD8MAAAAAAAAQAwAAAAAAAAAAAAAQAwAAAAAAABBDAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAA/DAAAAAAAAD8MAAAAAAAAAAAAAAAA8L8"
				],
				[
					185,
					1,
					"left_delete",
					null,
					"AQAAAEAMAAAAAAAAQAwAAAAAAAABAAAAIQ",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABBDAAAAAAAAEEMAAAAAAAAAAAAAAAA8L8"
				],
				[
					186,
					1,
					"insert",
					{
						"characters": "!"
					},
					"AQAAAEAMAAAAAAAAQQwAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAABADAAAAAAAAEAMAAAAAAAAAAAAAAAA8L8"
				],
				[
					201,
					1,
					"left_delete",
					null,
					"AQAAANsLAAAAAAAA2wsAAAAAAAABAAAACg",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAADcCwAAAAAAANwLAAAAAAAAAAAAAAAA8L8"
				]
			]
		},
		{
			"file": "quickjs-blob.c",
			"settings":
			{
				"buffer_size": 8259,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					10,
					1,
					"insert",
					{
						"characters": "{"
					},
					"AQAAAE4FAAAAAAAATwUAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAATgUAAAAAAABOBQAAAAAAAAAAAAAAAPC/"
				],
				[
					13,
					1,
					"insert_snippet",
					{
						"contents": "{$0}"
					},
					"AQAAAFsFAAAAAAAAXQUAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAWwUAAAAAAABbBQAAAAAAAAAAAAAAAPC/"
				],
				[
					15,
					1,
					"left_delete",
					null,
					"AQAAAFwFAAAAAAAAXAUAAAAAAAABAAAAfQ",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAXQUAAAAAAABdBQAAAAAAAAAAAAAAAPC/"
				],
				[
					16,
					1,
					"run_macro_file",
					{
						"file": "res://Packages/Default/Delete Left Right.sublime-macro"
					},
					"AgAAAFsFAAAAAAAAWwUAAAAAAAABAAAAe1sFAAAAAAAAWwUAAAAAAAABAAAAfQ",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAXAUAAAAAAABcBQAAAAAAAAAAAAAAAPC/"
				],
				[
					19,
					1,
					"insert",
					{
						"characters": "}"
					},
					"AQAAAFwFAAAAAAAAXQUAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAXAUAAAAAAABcBQAAAAAAAAAAAAAAAPC/"
				],
				[
					23,
					1,
					"left_delete",
					null,
					"AQAAAAgFAAAAAAAACAUAAAAAAAABAAAAew",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAACQUAAAAAAAAJBQAAAAAAAAAAAAAAAPC/"
				],
				[
					28,
					1,
					"revert",
					null,
					"BQAAAAAAAAAAAAAAAAAAAAAAAABDIAAAI2luY2x1ZGUgInF1aWNranMtYmxvYi5oIgojaW5jbHVkZSAidXRpbHMuaCIKI2luY2x1ZGUgImJ1ZmZlci11dGlscy5oIgoKI2RlZmluZSBtYXgoYSwgYikgKChhKSA+IChiKSA/IChhKSA6IChiKSkKCnRocmVhZF9sb2NhbCBWSVNJQkxFIEpTQ2xhc3NJRCBqc19ibG9iX2NsYXNzX2lkID0gMDsKdGhyZWFkX2xvY2FsIEpTVmFsdWUgYmxvYl9wcm90byA9IHtKU19UQUdfVU5ERUZJTkVEfSwgYmxvYl9jdG9yID0ge0pTX1RBR19VTkRFRklORUR9OwoKZW51bSB7CiAgQkxPQl9TSVpFLAogIEJMT0JfVFlQRSwKfTsKZW51bSB7CiAgQkxPQl9BUlJBWUJVRkZFUiwKICBCTE9CX1NMSUNFLAogIEJMT0JfU1RSRUFNLAogIEJMT0JfVEVYVCwKfTsKCnZvaWQKYmxvYl9pbml0KEpTQ29udGV4dCogY3R4LCBCbG9iKiBibG9iLCBjb25zdCB2b2lkKiB4LCBzaXplX3QgbGVuLCBjb25zdCBjaGFyKiB0eXBlKSB7CiAgYmxvYi0+dmVjID0gVkVDVE9SKGN0eCk7CiAgYmxvYi0+dHlwZSA9IHR5cGUgPyBqc19zdHJkdXAoY3R4LCB0eXBlKSA6IDA7CgogIGlmKHggJiYgbGVuKQogICAgYmxvYl93cml0ZShjdHgsIGJsb2IsIHgsIGxlbik7Cn0KCkJsb2IqCmJsb2JfbmV3KEpTQ29udGV4dCogY3R4LCBjb25zdCB2b2lkKiB4LCBzaXplX3QgbGVuLCBjb25zdCBjaGFyKiB0eXBlKSB7CiAgQmxvYiogYmxvYjsKCiAgaWYoIShibG9iID0ganNfbWFsbG9jeihjdHgsIHNpemVvZihCbG9iKSkpKQogICAgcmV0dXJuIDA7CgogIGJsb2JfaW5pdChjdHgsIGJsb2IsIHgsIGxlbiwgdHlwZSk7CgogIHJldHVybiBibG9iOwp9Cgpzc2l6ZV90CmJsb2Jfd3JpdGUoSlNDb250ZXh0KiBjdHgsIEJsb2IqIGJsb2IsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBsZW4pIHsKICB1aW50OF90KiBwdHI7CiAgaWYoKHB0ciA9IHZlY3Rvcl9wdXQoJmJsb2ItPnZlYywgeCwgbGVuKSkpCiAgICByZXR1cm4gbGVuOwogIHJldHVybiAtMTsKfQoKdm9pZApibG9iX2ZyZWUoSlNDb250ZXh0KiBjdHgsIEJsb2IqIGJsb2IpIHsKICBpZihibG9iLT52ZWMuZGF0YSkKICAgIHZlY3Rvcl9mcmVlKCZibG9iLT52ZWMpOwogIGpzX2ZyZWUoY3R4LCBibG9iKTsKfQoKc3RhdGljIHZvaWQKYmxvYl9mcmVlX3J0KEpTUnVudGltZSogcnQsIEJsb2IqIGJsb2IpIHsKICBpZihibG9iLT52ZWMuZGF0YSkKICAgIHZlY3Rvcl9mcmVlKCZibG9iLT52ZWMpOwogIGpzX2ZyZWVfcnQocnQsIGJsb2IpOwp9CgpJbnB1dEJ1ZmZlcgpibG9iX2lucHV0KEpTQ29udGV4dCogY3R4LCBCbG9iKiBibG9iKSB7CiAgSW5wdXRCdWZmZXIgcmV0ID0ge2Jsb2ItPmRhdGEsIDAsIGJsb2ItPnNpemUsICZpbnB1dF9idWZmZXJfZnJlZV9kZWZhdWx0LCBKU19VTkRFRklORUQsIHswLCBJTlQ2NF9NQVh9fTsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgdm9pZApqc19ibG9iX2ZyZWVfZnVuYyhKU1J1bnRpbWUqIHJ0LCB2b2lkKiBvcGFxdWUsIHZvaWQqIHB0cikgewogIC8vIGpzX2ZyZWVfcnQocnQsIHB0cik7Cn0KCkpTVmFsdWUKanNfYmxvYl93cmFwKEpTQ29udGV4dCogY3R4LCBCbG9iKiBibG9iKSB7CiAgSlNWYWx1ZSBvYmo7CiAgb2JqID0gSlNfTmV3T2JqZWN0UHJvdG9DbGFzcyhjdHgsIGJsb2JfcHJvdG8sIGpzX2Jsb2JfY2xhc3NfaWQpOwogIEpTX1NldE9wYXF1ZShvYmosIGJsb2IpOwogIHJldHVybiBvYmo7Cn0KCkpTVmFsdWUKanNfYmxvYl9uZXcoSlNDb250ZXh0KiBjdHgsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBsZW4sIGNvbnN0IGNoYXIqIHR5cGUpIHsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBibG9iX25ldyhjdHgsIHgsIGxlbiwgdHlwZSkpKQogICAgcmV0dXJuIEpTX1Rocm93T3V0T2ZNZW1vcnkoY3R4KTsKCiAgcmV0dXJuIGpzX2Jsb2Jfd3JhcChjdHgsIGJsb2IpOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc19ibG9iX2dldChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgbWFnaWMpIHsKICBCbG9iKiBibG9iOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwogIGlmKCEoYmxvYiA9IGpzX2Jsb2JfZGF0YShjdHgsIHRoaXNfdmFsKSkpCiAgICByZXR1cm4gcmV0OwogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBCTE9CX1NJWkU6IHsKICAgICAgcmV0ID0gSlNfTmV3VWludDMyKGN0eCwgYmxvYi0+c2l6ZSk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgQkxPQl9UWVBFOiB7CiAgICAgIHJldCA9IEpTX05ld1N0cmluZyhjdHgsIGJsb2ItPnR5cGUpOwogICAgICBicmVhazsKICAgIH0KICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNfYmxvYl9jb25zdHJ1Y3RvcihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG5ld190YXJnZXQsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgSlNWYWx1ZSBvYmogPSBKU19VTkRFRklORUQ7CiAgSlNWYWx1ZSBwcm90bzsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBibG9iX25ldyhjdHgsIDAsIDAsIDApKSkKICAgIHJldHVybiBKU19UaHJvd091dE9mTWVtb3J5KGN0eCk7CgogIC8qIHVzaW5nIG5ld190YXJnZXQgdG8gZ2V0IHRoZSBwcm90b3R5cGUgaXMgbmVjZXNzYXJ5IHdoZW4gdGhlCiAgICAgY2xhc3MgaXMgZXh0ZW5kZWQuICovCiAgcHJvdG8gPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG5ld190YXJnZXQsICJwcm90b3R5cGUiKTsKICBpZihKU19Jc0V4Y2VwdGlvbihwcm90bykpCiAgICBnb3RvIGZhaWw7CiAgaWYoIUpTX0lzT2JqZWN0KHByb3RvKSkKICAgIHByb3RvID0gYmxvYl9wcm90bzsKCiAgLyogdXNpbmcgbmV3X3RhcmdldCB0byBnZXQgdGhlIHByb3RvdHlwZSBpcyBuZWNlc3Nhcnkgd2hlbiB0aGUKICAgICBjbGFzcyBpcyBleHRlbmRlZC4gKi8KICBvYmogPSBKU19OZXdPYmplY3RQcm90b0NsYXNzKGN0eCwgcHJvdG8sIGpzX2Jsb2JfY2xhc3NfaWQpOwogIGlmKEpTX0lzRXhjZXB0aW9uKG9iaikpCiAgICBnb3RvIGZhaWw7CgogIHsKICAgIHVpbnQ4X3QqIHB0cjsKICAgIHNpemVfdCBzaXplID0gMCwgb2ZmcyA9IDA7CiAgICBibG9iLT50eXBlID0gMDsKCiAgICBpZihhcmdjID49IDEpIHsKICAgICAgaWYoanNfaXNfYXJyYXkoY3R4LCBhcmd2WzBdKSkgewogICAgICAgIHVpbnQzMl90IGksIGxlbiA9IGpzX2FycmF5X2xlbmd0aChjdHgsIGFyZ3ZbMF0pOwogICAgICAgIElucHV0QnVmZmVyKiBwYXJ0cyA9IGpzX21hbGxvYyhjdHgsIHNpemVvZihJbnB1dEJ1ZmZlcikgKiBsZW4pOwoKICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgQmxvYiogb3RoZXI7CiAgICAgICAgICBKU1ZhbHVlIGl0ZW0gPSBKU19HZXRQcm9wZXJ0eVVpbnQzMihjdHgsIGFyZ3ZbMF0sIGkpOwogICAgICAgICAgcGFydHNbaV0gPSAob3RoZXIgPSBqc19ibG9iX2RhdGEoY3R4LCBpdGVtKSkgPyBibG9iX2lucHV0KGN0eCwgb3RoZXIpIDoganNfaW5wdXRfY2hhcnMoY3R4LCBpdGVtKTsKICAgICAgICAgIHNpemUgKz0gcGFydHNbaV0uc2l6ZTsKICAgICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGl0ZW0pOwogICAgICAgIH0KCiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgIGlmKGJsb2Jfd3JpdGUoY3R4LCBibG9iLCBpbnB1dF9idWZmZXJfZGF0YSgmcGFydHNbaV0pLCBpbnB1dF9idWZmZXJfbGVuZ3RoKCZwYXJ0c1tpXSkpID09IC0xKSB7CiAgICAgICAgICAgIHdoaWxlKGkgPCBsZW4pIGlucHV0X2J1ZmZlcl9mcmVlKCZwYXJ0c1tpKytdLCBjdHgpOwogICAgICAgICAgICBibG9iX2ZyZWUoY3R4LCBibG9iKTsKICAgICAgICAgICAganNfZnJlZShjdHgsIHBhcnRzKTsKICAgICAgICAgICAgcmV0dXJuIEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJibG9iX3dyaXRlIHJldHVybmVkIC0xIik7CiAgICAgICAgICB9CgogICAgICAgICAgaW5wdXRfYnVmZmVyX2ZyZWUoJnBhcnRzW2ldLCBjdHgpOwogICAgICAgIH0KICAgICAgICBqc19mcmVlKGN0eCwgcGFydHMpOwogICAgICB9IGVsc2UgewogICAgICAgIEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJhcmd1bWVudCAxIG11c3QgYmUgYXJyYXkiKTsKICAgICAgICBnb3RvIGZhaWw7CiAgICAgIH0KICAgIH0KCiAgICBpZihhcmdjID49IDIgJiYgSlNfSXNPYmplY3QoYXJndlsxXSkpIHsKICAgICAgSlNWYWx1ZSB0eXBlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBhcmd2WzFdLCAidHlwZSIpOwoKICAgICAgaWYoSlNfSXNTdHJpbmcodHlwZSkpCiAgICAgICAgYmxvYi0+dHlwZSA9IGpzX3Rvc3RyaW5nKGN0eCwgdHlwZSk7CiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHR5cGUpOwogICAgfQogICAgaWYoYmxvYi0+dHlwZSA9PSAwKQogICAgICBibG9iLT50eXBlID0ganNfc3RyZHVwKGN0eCwgImFwcGxpY2F0aW9uL2JpbmFyeSIpOwogIH0KCiAgSlNfU2V0T3BhcXVlKG9iaiwgYmxvYik7CgogIHJldHVybiBvYmo7CgpmYWlsOgogIGpzX2ZyZWUoY3R4LCBibG9iKTsKICBKU19GcmVlVmFsdWUoY3R4LCBvYmopOwogIHJldHVybiBKU19FWENFUFRJT047Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzX2Jsb2JfbWV0aG9kKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbWFnaWMpIHsKICBCbG9iKiBibG9iOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwoKICBpZighKGJsb2IgPSBqc19ibG9iX2RhdGEoY3R4LCB0aGlzX3ZhbCkpKQogICAgcmV0dXJuIEpTX0VYQ0VQVElPTjsKCiAgc3dpdGNoKG1hZ2ljKSB7CiAgICBjYXNlIEJMT0JfQVJSQVlCVUZGRVI6IHsKICAgICAgcmV0ID0ganNfYXJyYXlidWZmZXJfZnJvbXZhbHVlKGN0eCwgYmxvYi0+ZGF0YSwgYmxvYi0+c2l6ZSwgdGhpc192YWwpOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgQkxPQl9TTElDRTogewogICAgICBpbnQ2NF90IG4gPSBibG9iLT5zaXplLCBzID0gMCwgZSA9IElOVDY0X01BWDsKICAgICAgY2hhciogdHlwZSA9IDA7CgogICAgICBpZihhcmdjID49IDEpIHsKICAgICAgICBKU19Ub0ludDY0KGN0eCwgJnMsIGFyZ3ZbMF0pOwogICAgICAgIGlmKHMgPCAwKQogICAgICAgICAgcyA9IG4gKyBzICUgbjsKICAgICAgICBlbHNlIGlmKHMgPiBuKQogICAgICAgICAgcyA9IG47CgogICAgICAgIGlmKGFyZ2MgPj0gMikgewogICAgICAgICAgSlNfVG9JbnQ2NChjdHgsICZlLCBhcmd2WzFdKTsKICAgICAgICAgIGlmKGUgPCAwKQogICAgICAgICAgICBlID0gbiArIGUgJSBuOwogICAgICAgICAgZWxzZSBpZihlID4gbikKICAgICAgICAgICAgZSA9IG47CgogICAgICAgICAgaWYoYXJnYyA+PSAzKQogICAgICAgICAgICB0eXBlID0ganNfdG9zdHJpbmcoY3R4LCBhcmd2WzJdKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldCA9IGpzX2Jsb2JfbmV3KGN0eCwgJmJsb2ItPmRhdGFbc10sIGUgLSBzLCB0eXBlID8gdHlwZSA6IGJsb2ItPnR5cGUpOwogICAgICBpZih0eXBlKQogICAgICAgIGpzX2ZyZWUoY3R4LCB0eXBlKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEJMT0JfU1RSRUFNOiB7CiAgICAgIHJldCA9IEpTX1VOREVGSU5FRDsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEJMT0JfVEVYVDogewogICAgICByZXQgPSBKU19OZXdTdHJpbmdMZW4oY3R4LCAoY29uc3QgY2hhciopYmxvYi0+ZGF0YSwgYmxvYi0+c2l6ZSk7CiAgICAgIGJyZWFrOwogICAgfQogIH0KICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgSlNWYWx1ZQpqc19ibG9iX2luc3BlY3QoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10pIHsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBqc19ibG9iX2RhdGEoY3R4LCB0aGlzX3ZhbCkpKQogICAgcmV0dXJuIEpTX0VYQ0VQVElPTjsKCiAgSlNWYWx1ZSBvYmogPSBKU19OZXdPYmplY3RQcm90byhjdHgsIGJsb2JfcHJvdG8pOwogIEpTX0RlZmluZVByb3BlcnR5VmFsdWVTdHIoY3R4LCBvYmosICJzaXplIiwgSlNfTmV3VWludDMyKGN0eCwgYmxvYi0+c2l6ZSksIEpTX1BST1BfRU5VTUVSQUJMRSk7CiAgSlNfRGVmaW5lUHJvcGVydHlWYWx1ZVN0cihjdHgsIG9iaiwgInR5cGUiLCBKU19OZXdTdHJpbmcoY3R4LCBibG9iLT50eXBlKSwgSlNfUFJPUF9FTlVNRVJBQkxFKTsKICByZXR1cm4gb2JqOwp9CgpzdGF0aWMgdm9pZApqc19ibG9iX2ZpbmFsaXplcihKU1J1bnRpbWUqIHJ0LCBKU1ZhbHVlIHZhbCkgewogIEJsb2IqIGJsb2IgPSBKU19HZXRPcGFxdWUodmFsLCBqc19ibG9iX2NsYXNzX2lkKTsKICBpZihibG9iKSB7CiAgICBibG9iX2ZyZWVfcnQocnQsIGJsb2IpOwogIH0KICBKU19GcmVlVmFsdWVSVChydCwgdmFsKTsKfQoKc3RhdGljIEpTQ2xhc3NEZWYganNfYmxvYl9jbGFzcyA9IHsKICAgIC5jbGFzc19uYW1lID0gIkJsb2IiLAogICAgLmZpbmFsaXplciA9IGpzX2Jsb2JfZmluYWxpemVyLAp9OwoKc3RhdGljIGNvbnN0IEpTQ0Z1bmN0aW9uTGlzdEVudHJ5IGpzX2Jsb2JfZnVuY3NbXSA9IHsKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiYXJyYXlCdWZmZXIiLCAwLCBqc19ibG9iX21ldGhvZCwgQkxPQl9BUlJBWUJVRkZFUiksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoInN0cmVhbSIsIDAsIGpzX2Jsb2JfbWV0aG9kLCBCTE9CX1NUUkVBTSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoInNsaWNlIiwgMCwganNfYmxvYl9tZXRob2QsIEJMT0JfU0xJQ0UpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJ0ZXh0IiwgMCwganNfYmxvYl9tZXRob2QsIEJMT0JfVEVYVCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigic2l6ZSIsIGpzX2Jsb2JfZ2V0LCAwLCBCTE9CX1NJWkUpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoInR5cGUiLCBqc19ibG9iX2dldCwgMCwgQkxPQl9UWVBFKSwKICAgIEpTX1BST1BfU1RSSU5HX0RFRigiW1N5bWJvbC50b1N0cmluZ1RhZ10iLCAiQmxvYiIsIEpTX1BST1BfQ09ORklHVVJBQkxFKSwKfTsKCmludApqc19ibG9iX2luaXQoSlNDb250ZXh0KiBjdHgsIEpTTW9kdWxlRGVmKiBtKSB7CgogIGlmKGpzX2Jsb2JfY2xhc3NfaWQgPT0gMCkgewogICAgSlNfTmV3Q2xhc3NJRCgmanNfYmxvYl9jbGFzc19pZCk7CiAgICBKU19OZXdDbGFzcyhKU19HZXRSdW50aW1lKGN0eCksIGpzX2Jsb2JfY2xhc3NfaWQsICZqc19ibG9iX2NsYXNzKTsKCiAgICBibG9iX2N0b3IgPSBKU19OZXdDRnVuY3Rpb24yKGN0eCwganNfYmxvYl9jb25zdHJ1Y3RvciwgIkJsb2IiLCAxLCBKU19DRlVOQ19jb25zdHJ1Y3RvciwgMCk7CiAgICBibG9iX3Byb3RvID0gSlNfTmV3T2JqZWN0KGN0eCk7CgogICAgSlNfU2V0UHJvcGVydHlGdW5jdGlvbkxpc3QoY3R4LCBibG9iX3Byb3RvLCBqc19ibG9iX2Z1bmNzLCBjb3VudG9mKGpzX2Jsb2JfZnVuY3MpKTsKICAgIEpTX1NldENsYXNzUHJvdG8oY3R4LCBqc19ibG9iX2NsYXNzX2lkLCBibG9iX3Byb3RvKTsKCiAgICBqc19zZXRfaW5zcGVjdF9tZXRob2QoY3R4LCBibG9iX3Byb3RvLCBqc19ibG9iX2luc3BlY3QpOwogIH0KCiAgaWYobSkgewogICAgSlNfU2V0TW9kdWxlRXhwb3J0KGN0eCwgbSwgIkJsb2IiLCBibG9iX2N0b3IpOwogICAgLyoKICAgICAgICBjb25zdCBjaGFyKiBtb2R1bGVfbmFtZSA9IEpTX0F0b21Ub0NTdHJpbmcoY3R4LCBtLT5tb2R1bGVfbmFtZSk7CgogICAgICAgIGlmKCFzdHJjbXAobW9kdWxlX25hbWUsICJibG9iIikpCiAgICAgICAgICBKU19TZXRNb2R1bGVFeHBvcnQoY3R4LCBtLCAiZGVmYXVsdCIsIGJsb2JfY3Rvcik7CgogICAgICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgbW9kdWxlX25hbWUpOyovCiAgfQoKICByZXR1cm4gMDsKfQoKI2lmZGVmIEpTX0JMT0JfTU9EVUxFCiNkZWZpbmUgSlNfSU5JVF9NT0RVTEUganNfaW5pdF9tb2R1bGUKI2Vsc2UKI2RlZmluZSBKU19JTklUX01PRFVMRSBqc19pbml0X21vZHVsZV9ibG9iCiNlbmRpZgoKVklTSUJMRSBKU01vZHVsZURlZioKSlNfSU5JVF9NT0RVTEUoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIG1vZHVsZV9uYW1lKSB7CiAgSlNNb2R1bGVEZWYqIG07CiAgaWYoIShtID0gSlNfTmV3Q01vZHVsZShjdHgsIG1vZHVsZV9uYW1lLCAmanNfYmxvYl9pbml0KSkpCiAgICByZXR1cm4gbTsKICBKU19BZGRNb2R1bGVFeHBvcnQoY3R4LCBtLCAiQmxvYiIpOwoKICAvKiBpZighc3RyY21wKG1vZHVsZV9uYW1lLCAiYmxvYiIpKQogICAgIEpTX0FkZE1vZHVsZUV4cG9ydChjdHgsIG0sICJkZWZhdWx0Iik7Ki8KCiAgcmV0dXJuIG07Cn0KAAAAAAAAAABDIAAAAAAAAAAAAAAAAAAAAAAAAEMgAAAAAAAAAAAAAAAAAAAAAAAAQyAAAAAAAAAAAAAAAAAAAAAAAABDIAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAWwUAAAAAAABbBQAAAAAAAAAAAAAAAPC/"
				],
				[
					1,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAABDIAAAI2luY2x1ZGUgInF1aWNranMtYmxvYi5oIgojaW5jbHVkZSAidXRpbHMuaCIKI2luY2x1ZGUgImJ1ZmZlci11dGlscy5oIgoKI2RlZmluZSBtYXgoYSwgYikgKChhKSA+IChiKSA/IChhKSA6IChiKSkKCnRocmVhZF9sb2NhbCBWSVNJQkxFIEpTQ2xhc3NJRCBqc19ibG9iX2NsYXNzX2lkID0gMDsKdGhyZWFkX2xvY2FsIEpTVmFsdWUgYmxvYl9wcm90byA9IHtKU19UQUdfVU5ERUZJTkVEfSwgYmxvYl9jdG9yID0ge0pTX1RBR19VTkRFRklORUR9OwoKZW51bSB7CiAgQkxPQl9TSVpFLAogIEJMT0JfVFlQRSwKfTsKZW51bSB7CiAgQkxPQl9BUlJBWUJVRkZFUiwKICBCTE9CX1NMSUNFLAogIEJMT0JfU1RSRUFNLAogIEJMT0JfVEVYVCwKfTsKCnZvaWQKYmxvYl9pbml0KEpTQ29udGV4dCogY3R4LCBCbG9iKiBibG9iLCBjb25zdCB2b2lkKiB4LCBzaXplX3QgbGVuLCBjb25zdCBjaGFyKiB0eXBlKSB7CiAgYmxvYi0+dmVjID0gVkVDVE9SKGN0eCk7CiAgYmxvYi0+dHlwZSA9IHR5cGUgPyBqc19zdHJkdXAoY3R4LCB0eXBlKSA6IDA7CgogIGlmKHggJiYgbGVuKQogICAgYmxvYl93cml0ZShjdHgsIGJsb2IsIHgsIGxlbik7Cn0KCkJsb2IqCmJsb2JfbmV3KEpTQ29udGV4dCogY3R4LCBjb25zdCB2b2lkKiB4LCBzaXplX3QgbGVuLCBjb25zdCBjaGFyKiB0eXBlKSB7CiAgQmxvYiogYmxvYjsKCiAgaWYoIShibG9iID0ganNfbWFsbG9jeihjdHgsIHNpemVvZihCbG9iKSkpKQogICAgcmV0dXJuIDA7CgogIGJsb2JfaW5pdChjdHgsIGJsb2IsIHgsIGxlbiwgdHlwZSk7CgogIHJldHVybiBibG9iOwp9Cgpzc2l6ZV90CmJsb2Jfd3JpdGUoSlNDb250ZXh0KiBjdHgsIEJsb2IqIGJsb2IsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBsZW4pIHsKICB1aW50OF90KiBwdHI7CiAgaWYoKHB0ciA9IHZlY3Rvcl9wdXQoJmJsb2ItPnZlYywgeCwgbGVuKSkpCiAgICByZXR1cm4gbGVuOwogIHJldHVybiAtMTsKfQoKdm9pZApibG9iX2ZyZWUoSlNDb250ZXh0KiBjdHgsIEJsb2IqIGJsb2IpIHsKICBpZihibG9iLT52ZWMuZGF0YSkKICAgIHZlY3Rvcl9mcmVlKCZibG9iLT52ZWMpOwogIGpzX2ZyZWUoY3R4LCBibG9iKTsKfQoKc3RhdGljIHZvaWQKYmxvYl9mcmVlX3J0KEpTUnVudGltZSogcnQsIEJsb2IqIGJsb2IpIHsKICBpZihibG9iLT52ZWMuZGF0YSkKICAgIHZlY3Rvcl9mcmVlKCZibG9iLT52ZWMpOwogIGpzX2ZyZWVfcnQocnQsIGJsb2IpOwp9CgpJbnB1dEJ1ZmZlcgpibG9iX2lucHV0KEpTQ29udGV4dCogY3R4LCBCbG9iKiBibG9iKSB7CiAgSW5wdXRCdWZmZXIgcmV0ID0ge2Jsb2ItPmRhdGEsIDAsIGJsb2ItPnNpemUsICZpbnB1dF9idWZmZXJfZnJlZV9kZWZhdWx0LCBKU19VTkRFRklORUQsIHswLCBJTlQ2NF9NQVh9fTsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgdm9pZApqc19ibG9iX2ZyZWVfZnVuYyhKU1J1bnRpbWUqIHJ0LCB2b2lkKiBvcGFxdWUsIHZvaWQqIHB0cikgewogIC8vIGpzX2ZyZWVfcnQocnQsIHB0cik7Cn0KCkpTVmFsdWUKanNfYmxvYl93cmFwKEpTQ29udGV4dCogY3R4LCBCbG9iKiBibG9iKSB7CiAgSlNWYWx1ZSBvYmo7CiAgb2JqID0gSlNfTmV3T2JqZWN0UHJvdG9DbGFzcyhjdHgsIGJsb2JfcHJvdG8sIGpzX2Jsb2JfY2xhc3NfaWQpOwogIEpTX1NldE9wYXF1ZShvYmosIGJsb2IpOwogIHJldHVybiBvYmo7Cn0KCkpTVmFsdWUKanNfYmxvYl9uZXcoSlNDb250ZXh0KiBjdHgsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBsZW4sIGNvbnN0IGNoYXIqIHR5cGUpIHsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBibG9iX25ldyhjdHgsIHgsIGxlbiwgdHlwZSkpKQogICAgcmV0dXJuIEpTX1Rocm93T3V0T2ZNZW1vcnkoY3R4KTsKCiAgcmV0dXJuIGpzX2Jsb2Jfd3JhcChjdHgsIGJsb2IpOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc19ibG9iX2dldChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgbWFnaWMpIHsKICBCbG9iKiBibG9iOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwogIGlmKCEoYmxvYiA9IGpzX2Jsb2JfZGF0YShjdHgsIHRoaXNfdmFsKSkpCiAgICByZXR1cm4gcmV0OwogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBCTE9CX1NJWkU6IHsKICAgICAgcmV0ID0gSlNfTmV3VWludDMyKGN0eCwgYmxvYi0+c2l6ZSk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgQkxPQl9UWVBFOiB7CiAgICAgIHJldCA9IEpTX05ld1N0cmluZyhjdHgsIGJsb2ItPnR5cGUpOwogICAgICBicmVhazsKICAgIH0KICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNfYmxvYl9jb25zdHJ1Y3RvcihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG5ld190YXJnZXQsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgSlNWYWx1ZSBvYmogPSBKU19VTkRFRklORUQ7CiAgSlNWYWx1ZSBwcm90bzsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBibG9iX25ldyhjdHgsIDAsIDAsIDApKSkKICAgIHJldHVybiBKU19UaHJvd091dE9mTWVtb3J5KGN0eCk7CgogIC8qIHVzaW5nIG5ld190YXJnZXQgdG8gZ2V0IHRoZSBwcm90b3R5cGUgaXMgbmVjZXNzYXJ5IHdoZW4gdGhlCiAgICAgY2xhc3MgaXMgZXh0ZW5kZWQuICovCiAgcHJvdG8gPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG5ld190YXJnZXQsICJwcm90b3R5cGUiKTsKICBpZihKU19Jc0V4Y2VwdGlvbihwcm90bykpCiAgICBnb3RvIGZhaWw7CiAgaWYoIUpTX0lzT2JqZWN0KHByb3RvKSkKICAgIHByb3RvID0gYmxvYl9wcm90bzsKCiAgLyogdXNpbmcgbmV3X3RhcmdldCB0byBnZXQgdGhlIHByb3RvdHlwZSBpcyBuZWNlc3Nhcnkgd2hlbiB0aGUKICAgICBjbGFzcyBpcyBleHRlbmRlZC4gKi8KICBvYmogPSBKU19OZXdPYmplY3RQcm90b0NsYXNzKGN0eCwgcHJvdG8sIGpzX2Jsb2JfY2xhc3NfaWQpOwogIGlmKEpTX0lzRXhjZXB0aW9uKG9iaikpCiAgICBnb3RvIGZhaWw7CgogIHsKICAgIHVpbnQ4X3QqIHB0cjsKICAgIHNpemVfdCBzaXplID0gMCwgb2ZmcyA9IDA7CiAgICBibG9iLT50eXBlID0gMDsKCiAgICBpZihhcmdjID49IDEpIHsKICAgICAgaWYoanNfaXNfYXJyYXkoY3R4LCBhcmd2WzBdKSkgewogICAgICAgIHVpbnQzMl90IGksIGxlbiA9IGpzX2FycmF5X2xlbmd0aChjdHgsIGFyZ3ZbMF0pOwogICAgICAgIElucHV0QnVmZmVyKiBwYXJ0cyA9IGpzX21hbGxvYyhjdHgsIHNpemVvZihJbnB1dEJ1ZmZlcikgKiBsZW4pOwoKICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgQmxvYiogb3RoZXI7CiAgICAgICAgICBKU1ZhbHVlIGl0ZW0gPSBKU19HZXRQcm9wZXJ0eVVpbnQzMihjdHgsIGFyZ3ZbMF0sIGkpOwogICAgICAgICAgcGFydHNbaV0gPSAob3RoZXIgPSBqc19ibG9iX2RhdGEoY3R4LCBpdGVtKSkgPyBibG9iX2lucHV0KGN0eCwgb3RoZXIpIDoganNfaW5wdXRfY2hhcnMoY3R4LCBpdGVtKTsKICAgICAgICAgIHNpemUgKz0gcGFydHNbaV0uc2l6ZTsKICAgICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGl0ZW0pOwogICAgICAgIH0KCiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgIGlmKGJsb2Jfd3JpdGUoY3R4LCBibG9iLCBpbnB1dF9idWZmZXJfZGF0YSgmcGFydHNbaV0pLCBpbnB1dF9idWZmZXJfbGVuZ3RoKCZwYXJ0c1tpXSkpID09IC0xKSB7CiAgICAgICAgICAgIHdoaWxlKGkgPCBsZW4pIGlucHV0X2J1ZmZlcl9mcmVlKCZwYXJ0c1tpKytdLCBjdHgpOwogICAgICAgICAgICBibG9iX2ZyZWUoY3R4LCBibG9iKTsKICAgICAgICAgICAganNfZnJlZShjdHgsIHBhcnRzKTsKICAgICAgICAgICAgcmV0dXJuIEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJibG9iX3dyaXRlIHJldHVybmVkIC0xIik7CiAgICAgICAgICB9CgogICAgICAgICAgaW5wdXRfYnVmZmVyX2ZyZWUoJnBhcnRzW2ldLCBjdHgpOwogICAgICAgIH0KICAgICAgICBqc19mcmVlKGN0eCwgcGFydHMpOwogICAgICB9IGVsc2UgewogICAgICAgIEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJhcmd1bWVudCAxIG11c3QgYmUgYXJyYXkiKTsKICAgICAgICBnb3RvIGZhaWw7CiAgICAgIH0KICAgIH0KCiAgICBpZihhcmdjID49IDIgJiYgSlNfSXNPYmplY3QoYXJndlsxXSkpIHsKICAgICAgSlNWYWx1ZSB0eXBlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBhcmd2WzFdLCAidHlwZSIpOwoKICAgICAgaWYoSlNfSXNTdHJpbmcodHlwZSkpCiAgICAgICAgYmxvYi0+dHlwZSA9IGpzX3Rvc3RyaW5nKGN0eCwgdHlwZSk7CiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHR5cGUpOwogICAgfQogICAgaWYoYmxvYi0+dHlwZSA9PSAwKQogICAgICBibG9iLT50eXBlID0ganNfc3RyZHVwKGN0eCwgImFwcGxpY2F0aW9uL2JpbmFyeSIpOwogIH0KCiAgSlNfU2V0T3BhcXVlKG9iaiwgYmxvYik7CgogIHJldHVybiBvYmo7CgpmYWlsOgogIGpzX2ZyZWUoY3R4LCBibG9iKTsKICBKU19GcmVlVmFsdWUoY3R4LCBvYmopOwogIHJldHVybiBKU19FWENFUFRJT047Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzX2Jsb2JfbWV0aG9kKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbWFnaWMpIHsKICBCbG9iKiBibG9iOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwoKICBpZighKGJsb2IgPSBqc19ibG9iX2RhdGEoY3R4LCB0aGlzX3ZhbCkpKQogICAgcmV0dXJuIEpTX0VYQ0VQVElPTjsKCiAgc3dpdGNoKG1hZ2ljKSB7CiAgICBjYXNlIEJMT0JfQVJSQVlCVUZGRVI6IHsKICAgICAgcmV0ID0ganNfYXJyYXlidWZmZXJfZnJvbXZhbHVlKGN0eCwgYmxvYi0+ZGF0YSwgYmxvYi0+c2l6ZSwgdGhpc192YWwpOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgQkxPQl9TTElDRTogewogICAgICBpbnQ2NF90IG4gPSBibG9iLT5zaXplLCBzID0gMCwgZSA9IElOVDY0X01BWDsKICAgICAgY2hhciogdHlwZSA9IDA7CgogICAgICBpZihhcmdjID49IDEpIHsKICAgICAgICBKU19Ub0ludDY0KGN0eCwgJnMsIGFyZ3ZbMF0pOwogICAgICAgIGlmKHMgPCAwKQogICAgICAgICAgcyA9IG4gKyBzICUgbjsKICAgICAgICBlbHNlIGlmKHMgPiBuKQogICAgICAgICAgcyA9IG47CgogICAgICAgIGlmKGFyZ2MgPj0gMikgewogICAgICAgICAgSlNfVG9JbnQ2NChjdHgsICZlLCBhcmd2WzFdKTsKICAgICAgICAgIGlmKGUgPCAwKQogICAgICAgICAgICBlID0gbiArIGUgJSBuOwogICAgICAgICAgZWxzZSBpZihlID4gbikKICAgICAgICAgICAgZSA9IG47CgogICAgICAgICAgaWYoYXJnYyA+PSAzKQogICAgICAgICAgICB0eXBlID0ganNfdG9zdHJpbmcoY3R4LCBhcmd2WzJdKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldCA9IGpzX2Jsb2JfbmV3KGN0eCwgJmJsb2ItPmRhdGFbc10sIGUgLSBzLCB0eXBlID8gdHlwZSA6IGJsb2ItPnR5cGUpOwogICAgICBpZih0eXBlKQogICAgICAgIGpzX2ZyZWUoY3R4LCB0eXBlKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEJMT0JfU1RSRUFNOiB7CiAgICAgIHJldCA9IEpTX1VOREVGSU5FRDsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEJMT0JfVEVYVDogewogICAgICByZXQgPSBKU19OZXdTdHJpbmdMZW4oY3R4LCAoY29uc3QgY2hhciopYmxvYi0+ZGF0YSwgYmxvYi0+c2l6ZSk7CiAgICAgIGJyZWFrOwogICAgfQogIH0KICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgSlNWYWx1ZQpqc19ibG9iX2luc3BlY3QoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10pIHsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBqc19ibG9iX2RhdGEoY3R4LCB0aGlzX3ZhbCkpKQogICAgcmV0dXJuIEpTX0VYQ0VQVElPTjsKCiAgSlNWYWx1ZSBvYmogPSBKU19OZXdPYmplY3RQcm90byhjdHgsIGJsb2JfcHJvdG8pOwogIEpTX0RlZmluZVByb3BlcnR5VmFsdWVTdHIoY3R4LCBvYmosICJzaXplIiwgSlNfTmV3VWludDMyKGN0eCwgYmxvYi0+c2l6ZSksIEpTX1BST1BfRU5VTUVSQUJMRSk7CiAgSlNfRGVmaW5lUHJvcGVydHlWYWx1ZVN0cihjdHgsIG9iaiwgInR5cGUiLCBKU19OZXdTdHJpbmcoY3R4LCBibG9iLT50eXBlKSwgSlNfUFJPUF9FTlVNRVJBQkxFKTsKICByZXR1cm4gb2JqOwp9CgpzdGF0aWMgdm9pZApqc19ibG9iX2ZpbmFsaXplcihKU1J1bnRpbWUqIHJ0LCBKU1ZhbHVlIHZhbCkgewogIEJsb2IqIGJsb2IgPSBKU19HZXRPcGFxdWUodmFsLCBqc19ibG9iX2NsYXNzX2lkKTsKICBpZihibG9iKSB7CiAgICBibG9iX2ZyZWVfcnQocnQsIGJsb2IpOwogIH0KICBKU19GcmVlVmFsdWVSVChydCwgdmFsKTsKfQoKc3RhdGljIEpTQ2xhc3NEZWYganNfYmxvYl9jbGFzcyA9IHsKICAgIC5jbGFzc19uYW1lID0gIkJsb2IiLAogICAgLmZpbmFsaXplciA9IGpzX2Jsb2JfZmluYWxpemVyLAp9OwoKc3RhdGljIGNvbnN0IEpTQ0Z1bmN0aW9uTGlzdEVudHJ5IGpzX2Jsb2JfZnVuY3NbXSA9IHsKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiYXJyYXlCdWZmZXIiLCAwLCBqc19ibG9iX21ldGhvZCwgQkxPQl9BUlJBWUJVRkZFUiksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoInN0cmVhbSIsIDAsIGpzX2Jsb2JfbWV0aG9kLCBCTE9CX1NUUkVBTSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoInNsaWNlIiwgMCwganNfYmxvYl9tZXRob2QsIEJMT0JfU0xJQ0UpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJ0ZXh0IiwgMCwganNfYmxvYl9tZXRob2QsIEJMT0JfVEVYVCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigic2l6ZSIsIGpzX2Jsb2JfZ2V0LCAwLCBCTE9CX1NJWkUpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoInR5cGUiLCBqc19ibG9iX2dldCwgMCwgQkxPQl9UWVBFKSwKICAgIEpTX1BST1BfU1RSSU5HX0RFRigiW1N5bWJvbC50b1N0cmluZ1RhZ10iLCAiQmxvYiIsIEpTX1BST1BfQ09ORklHVVJBQkxFKSwKfTsKCmludApqc19ibG9iX2luaXQoSlNDb250ZXh0KiBjdHgsIEpTTW9kdWxlRGVmKiBtKSB7CgogIGlmKGpzX2Jsb2JfY2xhc3NfaWQgPT0gMCkgewogICAgSlNfTmV3Q2xhc3NJRCgmanNfYmxvYl9jbGFzc19pZCk7CiAgICBKU19OZXdDbGFzcyhKU19HZXRSdW50aW1lKGN0eCksIGpzX2Jsb2JfY2xhc3NfaWQsICZqc19ibG9iX2NsYXNzKTsKCiAgICBibG9iX2N0b3IgPSBKU19OZXdDRnVuY3Rpb24yKGN0eCwganNfYmxvYl9jb25zdHJ1Y3RvciwgIkJsb2IiLCAxLCBKU19DRlVOQ19jb25zdHJ1Y3RvciwgMCk7CiAgICBibG9iX3Byb3RvID0gSlNfTmV3T2JqZWN0KGN0eCk7CgogICAgSlNfU2V0UHJvcGVydHlGdW5jdGlvbkxpc3QoY3R4LCBibG9iX3Byb3RvLCBqc19ibG9iX2Z1bmNzLCBjb3VudG9mKGpzX2Jsb2JfZnVuY3MpKTsKICAgIEpTX1NldENsYXNzUHJvdG8oY3R4LCBqc19ibG9iX2NsYXNzX2lkLCBibG9iX3Byb3RvKTsKCiAgICBqc19zZXRfaW5zcGVjdF9tZXRob2QoY3R4LCBibG9iX3Byb3RvLCBqc19ibG9iX2luc3BlY3QpOwogIH0KCiAgaWYobSkgewogICAgSlNfU2V0TW9kdWxlRXhwb3J0KGN0eCwgbSwgIkJsb2IiLCBibG9iX2N0b3IpOwogICAgLyoKICAgICAgICBjb25zdCBjaGFyKiBtb2R1bGVfbmFtZSA9IEpTX0F0b21Ub0NTdHJpbmcoY3R4LCBtLT5tb2R1bGVfbmFtZSk7CgogICAgICAgIGlmKCFzdHJjbXAobW9kdWxlX25hbWUsICJibG9iIikpCiAgICAgICAgICBKU19TZXRNb2R1bGVFeHBvcnQoY3R4LCBtLCAiZGVmYXVsdCIsIGJsb2JfY3Rvcik7CgogICAgICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgbW9kdWxlX25hbWUpOyovCiAgfQoKICByZXR1cm4gMDsKfQoKI2lmZGVmIEpTX0JMT0JfTU9EVUxFCiNkZWZpbmUgSlNfSU5JVF9NT0RVTEUganNfaW5pdF9tb2R1bGUKI2Vsc2UKI2RlZmluZSBKU19JTklUX01PRFVMRSBqc19pbml0X21vZHVsZV9ibG9iCiNlbmRpZgoKVklTSUJMRSBKU01vZHVsZURlZioKSlNfSU5JVF9NT0RVTEUoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIG1vZHVsZV9uYW1lKSB7CiAgSlNNb2R1bGVEZWYqIG07CiAgaWYoIShtID0gSlNfTmV3Q01vZHVsZShjdHgsIG1vZHVsZV9uYW1lLCAmanNfYmxvYl9pbml0KSkpCiAgICByZXR1cm4gbTsKICBKU19BZGRNb2R1bGVFeHBvcnQoY3R4LCBtLCAiQmxvYiIpOwoKICAvKiBpZighc3RyY21wKG1vZHVsZV9uYW1lLCAiYmxvYiIpKQogICAgIEpTX0FkZE1vZHVsZUV4cG9ydChjdHgsIG0sICJkZWZhdWx0Iik7Ki8KCiAgcmV0dXJuIG07Cn0KAAAAAAAAAABDIAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAWwUAAAAAAABbBQAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "qjsm.c",
			"settings":
			{
				"buffer_size": 28329,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					5,
					1,
					"left_delete",
					null,
					"AQAAAB4LAAAAAAAAHgsAAAAAAAABAAAAOw",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAHwsAAAAAAAAfCwAAAAAAAAAAAAAAAPC/"
				],
				[
					6,
					1,
					"insert",
					{
						"characters": ":"
					},
					"AQAAAB4LAAAAAAAAHwsAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAHgsAAAAAAAAeCwAAAAAAAAAAAAAAAPC/"
				],
				[
					8,
					1,
					"left_delete",
					null,
					"AQAAAHoLAAAAAAAAegsAAAAAAAABAAAAOw",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAewsAAAAAAAB7CwAAAAAAAAAAAAAAAHlA"
				],
				[
					9,
					1,
					"insert",
					{
						"characters": "."
					},
					"AQAAAHoLAAAAAAAAewsAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAegsAAAAAAAB6CwAAAAAAAAAAAAAAAPC/"
				],
				[
					10,
					1,
					"left_delete",
					null,
					"AQAAAHoLAAAAAAAAegsAAAAAAAABAAAALg",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAewsAAAAAAAB7CwAAAAAAAAAAAAAAAPC/"
				],
				[
					11,
					1,
					"insert",
					{
						"characters": ":"
					},
					"AQAAAHoLAAAAAAAAewsAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAegsAAAAAAAB6CwAAAAAAAAAAAAAAAPC/"
				],
				[
					35,
					1,
					"revert",
					null,
					"AwAAAAAAAAAAAAAAAAAAAAAAAACwcAAAI2luY2x1ZGUgPHN0ZGxpYi5oPgojaW5jbHVkZSA8c3RkaW8uaD4KI2luY2x1ZGUgPHN0ZGFyZy5oPgojaW5jbHVkZSA8aW50dHlwZXMuaD4KI2luY2x1ZGUgPHN0cmluZy5oPgojaW5jbHVkZSA8YXNzZXJ0Lmg+CiNpbmNsdWRlIDx1bmlzdGQuaD4KI2luY2x1ZGUgPGVycm5vLmg+CiNpbmNsdWRlIDxmY250bC5oPgojaW5jbHVkZSA8dGltZS5oPgojaW5jbHVkZSA8c2lnbmFsLmg+CiNpbmNsdWRlIDxzeXMvcG9sbC5oPgojaWYgZGVmaW5lZChfX0FQUExFX18pCiNpbmNsdWRlIDxtYWxsb2MvbWFsbG9jLmg+CiNlbGlmIGRlZmluZWQoX19saW51eF9fKQojaW5jbHVkZSA8bWFsbG9jLmg+CiNlbmRpZgojaWZuZGVmIF9fd2FzaV9fCiNpbmNsdWRlIDxkbGZjbi5oPgojZW5kaWYKCiNpZiAxIC8vIGRlZiBIQVZFX1FVSUNLSlNfQ09ORklHX0gKI2luY2x1ZGUgInF1aWNranMtY29uZmlnLmgiCiNlbmRpZgoKI2lmZGVmIFVTRV9XT1JLRVIKI2luY2x1ZGUgPHB0aHJlYWQuaD4KI2luY2x1ZGUgPHN0ZGF0b21pYy5oPgoKc3RhdGljIGludAphdG9taWNfYWRkX2ludChpbnQqIHB0ciwgaW50IHYpIHsKICByZXR1cm4gYXRvbWljX2ZldGNoX2FkZCgoX0F0b21pYyh1aW50MzJfdCkqKXB0ciwgdikgKyB2Owp9CiNlbmRpZgoKI2luY2x1ZGUgImxpc3QuaCIKI2luY2x1ZGUgImN1dGlscy5oIgojaW5jbHVkZSAidXRpbHMuaCIKI2luY2x1ZGUgInZlY3Rvci5oIgojaW5jbHVkZSAicXVpY2tqcy1saWJjLmgiCiNpbmNsdWRlICJxdWlja2pzLWludGVybmFsLmgiCiNpbmNsdWRlICJidWZmZXItdXRpbHMuaCIKCnR5cGVkZWYgc3RydWN0IHBvbGxoYW5kbGVyIHsKICBzdHJ1Y3QgcG9sbGZkIHBmOwogIHZvaWQgKCpoYW5kbGVyKSh2b2lkKiBvcGFxdWUsIHN0cnVjdCBwb2xsZmQqKTsKICB2b2lkKiBvcGFxdWU7CiAgc3RydWN0IGxpc3RfaGVhZCBsaW5rOwp9IHBvbGxoYW5kbGVyX3Q7Cgp0aHJlYWRfbG9jYWwgdWludDY0X3QganNtX3BlbmRpbmdfc2lnbmFscyA9IDA7CnN0cnVjdCBsaXN0X2hlYWQgcG9sbGhhbmRsZXJzOwoKdm9pZCBqc19zdGRfc2V0X21vZHVsZV9sb2FkZXJfZnVuYyhKU01vZHVsZUxvYWRlckZ1bmMqIGZ1bmMpOwoKI2lmZGVmIEhBVkVfTUFMTE9DX1VTQUJMRV9TSVpFCiNpZm5kZWYgSEFWRV9NQUxMT0NfVVNBQkxFX1NJWkVfREVGSU5JVElPTgpleHRlcm4gc2l6ZV90IG1hbGxvY191c2FibGVfc2l6ZSgpOwojZW5kaWYKI2VuZGlmCgojZGVmaW5lIHRyaW1fZG90c2xhc2goc3RyKSAoIXN0cm5jbXAoKHN0ciksICIuLyIsIDIpID8gKHN0cikgKyAyIDogKHN0cikpCgojZGVmaW5lIGpzbV9kZWNsYXJlX21vZHVsZShuYW1lKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICBleHRlcm4gY29uc3QgdWludDhfdCBxanNjXyMjbmFtZVtdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgZXh0ZXJuIGNvbnN0IHVpbnQzMl90IHFqc2NfIyNuYW1lIyNfc2l6ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIEpTTW9kdWxlRGVmKiBqc19pbml0X21vZHVsZV8jI25hbWUoSlNDb250ZXh0KiwgY29uc3QgY2hhciopOwoKanNtX2RlY2xhcmVfbW9kdWxlKGNvbnNvbGUpOwpqc21fZGVjbGFyZV9tb2R1bGUoZXZlbnRzKTsKanNtX2RlY2xhcmVfbW9kdWxlKGZzKTsKanNtX2RlY2xhcmVfbW9kdWxlKHBlcmZfaG9va3MpOwpqc21fZGVjbGFyZV9tb2R1bGUocHJvY2Vzcyk7CmpzbV9kZWNsYXJlX21vZHVsZShyZXBsKTsKanNtX2RlY2xhcmVfbW9kdWxlKHJlcXVpcmUpOwpqc21fZGVjbGFyZV9tb2R1bGUodHR5KTsKanNtX2RlY2xhcmVfbW9kdWxlKHV0aWwpOwoKI2lmZGVmIENPTkZJR19CSUdOVU0KanNtX2RlY2xhcmVfbW9kdWxlKHFqc2NhbGMpOwpzdGF0aWMgaW50IGJpZ251bV9leHQgPSAxOwojZW5kaWYKCnZvaWQganNfc3RkX3NldF93b3JrZXJfbmV3X2NvbnRleHRfZnVuYyhKU0NvbnRleHQqICgqZnVuYykoSlNSdW50aW1lKiBydCkpOwoKc3RhdGljIHZvaWQKanNtX2R1bXBfZXJyb3IoSlNDb250ZXh0KiBjdHgpIHsKICAvKkpTUnVudGltZSogcnQgPSBKU19HZXRSdW50aW1lKGN0eCk7CiAgSlNWYWx1ZSBlcnJvciA9IHJ0LT5jdXJyZW50X2V4Y2VwdGlvbjsqLwogIC8qcHJpbnRmKCJxanNtOiBjdXJyZW50X2V4Y2VwdGlvbiAweCUwOHhcbiIsIG9mZnNldG9mKEpTUnVudGltZSwgY3VycmVudF9leGNlcHRpb24pKTsKICBwcmludGYoInFqc206IHNpemVvZihzdHJ1Y3QgbGlzdF9oZWFkKSAweCUwOHhcbiIsIHNpemVvZihzdHJ1Y3QgbGlzdF9oZWFkKSk7Ki8KCiAganNfZXJyb3JfcHJpbnQoY3R4LCBKU19HZXRFeGNlcHRpb24oY3R4KSk7Cn0KCnN0YXRpYyBpbnQgZGVidWdfbW9kdWxlX2xvYWRlciA9IDA7CnN0YXRpYyBWZWN0b3IgbW9kdWxlX2RlYnVnID0gVkVDVE9SX0lOSVQoKTsKc3RhdGljIFZlY3RvciBtb2R1bGVfbGlzdCA9IFZFQ1RPUl9JTklUKCk7CnN0YXRpYyBWZWN0b3IgYnVpbHRpbnMgPSBWRUNUT1JfSU5JVCgpOwoKc3RhdGljIGNvbnN0IGNoYXIganNtX2RlZmF1bHRfbW9kdWxlX3BhdGhbXSA9ICIuIgojaWZkZWYgUVVJQ0tKU19NT0RVTEVfUEFUSAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICI6IiBRVUlDS0pTX01PRFVMRV9QQVRIIAojZWxpZiBkZWZpbmVkKENPTkZJR19QUkVGSVgpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjoiIENPTkZJR19QUkVGSVggIi9saWIvcXVpY2tqcyIKI2VuZGlmCiAgICA7CgpKU1ZhbHVlIHBhY2thZ2VfanNvbjsKCnN0YXRpYyBKU1ZhbHVlCmV2YWxfYnVmKEpTQ29udGV4dCogY3R4LCBjb25zdCB2b2lkKiBidWYsIGludCBidWZfbGVuLCBjb25zdCBjaGFyKiBmaWxlbmFtZSwgaW50IGV2YWxfZmxhZ3MpIHsKICBKU1ZhbHVlIHZhbDsKCiAgaWYoKGV2YWxfZmxhZ3MgJiBKU19FVkFMX1RZUEVfTUFTSykgPT0gSlNfRVZBTF9UWVBFX01PRFVMRSkgewogICAgLyogZm9yIHRoZSBtb2R1bGVzLCB3ZSBjb21waWxlIHRoZW4gcnVuIHRvIGJlIGFibGUgdG8gc2V0IGltcG9ydC5tZXRhICovCiAgICB2YWwgPSBKU19FdmFsKGN0eCwgYnVmLCBidWZfbGVuLCBmaWxlbmFtZSwgZXZhbF9mbGFncyB8IEpTX0VWQUxfRkxBR19DT01QSUxFX09OTFkpOwogICAgaWYoIUpTX0lzRXhjZXB0aW9uKHZhbCkpIHsKICAgICAganNfbW9kdWxlX3NldF9pbXBvcnRfbWV0YShjdHgsIHZhbCwgVFJVRSwgVFJVRSk7CiAgICAgIEpTX0V2YWxGdW5jdGlvbihjdHgsIHZhbCk7CiAgICB9CiAgfSBlbHNlIHsKICAgIHZhbCA9IEpTX0V2YWwoY3R4LCBidWYsIGJ1Zl9sZW4sIGZpbGVuYW1lLCBldmFsX2ZsYWdzKTsKICB9CiAgaWYoSlNfSXNFeGNlcHRpb24odmFsKSkKICAgIGpzX2Vycm9yX3ByaW50KGN0eCwgSlNfR2V0UnVudGltZShjdHgpLT5jdXJyZW50X2V4Y2VwdGlvbik7CgogIGpzbV9kdW1wX2Vycm9yKGN0eCk7CiAgcmV0dXJuIHZhbDsKfQoKc3RhdGljIEpTVmFsdWUKanNtX2xvYWRfcGFja2FnZShKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogZmlsZSkgewogIGlmKEpTX0lzVW5kZWZpbmVkKHBhY2thZ2VfanNvbikpIHsKICAgIHVpbnQ4X3QqIGJ1ZjsKICAgIHNpemVfdCBsZW47CiAgICBpZihmaWxlID09IDApCiAgICAgIGZpbGUgPSAicGFja2FnZS5qc29uIjsKICAgIGlmKCEoYnVmID0ganNfbG9hZF9maWxlKGN0eCwgJmxlbiwgZmlsZSkpKQogICAgICBwYWNrYWdlX2pzb24gPSBKU19OVUxMOwogICAgZWxzZQogICAgICBwYWNrYWdlX2pzb24gPSBKU19QYXJzZUpTT04oY3R4LCBidWYsIGxlbiwgZmlsZSk7CiAgfQogIHJldHVybiBKU19EdXBWYWx1ZShjdHgsIHBhY2thZ2VfanNvbik7Cn0KCkpTTW9kdWxlRGVmKgpqc21fbW9kdWxlX2xvYWRlcihKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogbmFtZSwgdm9pZCogb3BhcXVlKSB7CiAgY2hhciAqbW9kdWxlLCAqZmlsZSA9IDA7CiAgSlNNb2R1bGVEZWYqIHJldCA9IDA7CiAgbW9kdWxlID0ganNfc3RyZHVwKGN0eCwgdHJpbV9kb3RzbGFzaChuYW1lKSk7CiAgZm9yKDs7KSB7CiAgICBpZihkZWJ1Z19tb2R1bGVfbG9hZGVyID4gMSkgewogICAgICBpZihmaWxlKQogICAgICAgIHByaW50ZigiXHgxYls0ODs1OzIxNG0oMSlceDFiWzBtICUtMzBzICclcydcbiIsIG5hbWUsIGZpbGUpOwogICAgICAvKiAgZWxzZSAgcHJpbnRmKCJqc21fbW9kdWxlX2xvYWRlclsleF0gXHgxYls0ODs1OzEyNG0oMSlceDFiWzBtICUtMjBzIC0+CiAgICAgICAqICVzXG4iLCBwdGhyZWFkX3NlbGYoKSwgdHJpbV9kb3RzbGFzaChuYW1lKSwgdHJpbV9kb3RzbGFzaChtb2R1bGUpKTsqLwogICAgfQogICAgaWYoIXN0cmNocihtb2R1bGUsICcvJykgJiYgKHJldCA9IGpzX21vZHVsZV9maW5kKGN0eCwgbW9kdWxlKSkpCiAgICAgIGdvdG8gZW5kOwoKICAgIGlmKCFoYXNfc3VmZml4KG5hbWUsICIuc28iKSAmJiAhZmlsZSkgewogICAgICBKU1ZhbHVlIHBhY2thZ2UgPSBqc21fbG9hZF9wYWNrYWdlKGN0eCwgMCk7CiAgICAgIGlmKCFKU19Jc051bGwocGFja2FnZSkpIHsKICAgICAgICBKU1ZhbHVlIGFsaWFzZXMgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIHBhY2thZ2UsICJfbW9kdWxlQWxpYXNlcyIpOwogICAgICAgIEpTVmFsdWUgdGFyZ2V0ID0gSlNfVU5ERUZJTkVEOwogICAgICAgIGlmKCFKU19Jc1VuZGVmaW5lZChhbGlhc2VzKSkgewogICAgICAgICAgdGFyZ2V0ID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBhbGlhc2VzLCBtb2R1bGUpOwogICAgICAgIH0KICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBhbGlhc2VzKTsKICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBwYWNrYWdlKTsKICAgICAgICBpZighSlNfSXNVbmRlZmluZWQodGFyZ2V0KSkgewogICAgICAgICAgY29uc3QgY2hhciogc3RyID0gSlNfVG9DU3RyaW5nKGN0eCwgdGFyZ2V0KTsKICAgICAgICAgIGlmKHN0cikgewogICAgICAgICAgICBpZihkZWJ1Z19tb2R1bGVfbG9hZGVyKQogICAgICAgICAgICAgIHByaW50ZigiXHgxYls0ODs1OzI4bSgyKVx4MWJbMG0gJS0zMHMgPT4gJXNcbiIsIG1vZHVsZSwgc3RyKTsKCiAgICAgICAgICAgIGpzX2ZyZWUoY3R4LCBtb2R1bGUpOwoKICAgICAgICAgICAgbW9kdWxlID0ganNfc3RyZHVwKGN0eCwgc3RyKTsKICAgICAgICAgICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBzdHIpOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGlmKCFmaWxlKSB7CiAgICAgIGlmKHN0cmNocigiLi8iLCBtb2R1bGVbMF0pKQogICAgICAgIGZpbGUgPSBqc19zdHJkdXAoY3R4LCBtb2R1bGUpOwogICAgICBlbHNlIGlmKCEoZmlsZSA9IGpzX21vZHVsZV9zZWFyY2goY3R4LCBqc21fZGVmYXVsdF9tb2R1bGVfcGF0aCwgbW9kdWxlKSkpCiAgICAgICAgYnJlYWs7CiAgICAgIGNvbnRpbnVlOwogICAgfQogICAgYnJlYWs7CiAgfQogIGlmKGZpbGUpIHsKICAgIGlmKGRlYnVnX21vZHVsZV9sb2FkZXIpCiAgICAgIGlmKHN0cmNtcCh0cmltX2RvdHNsYXNoKG1vZHVsZSksIHRyaW1fZG90c2xhc2goZmlsZSkpKQogICAgICAgIHByaW50ZigiXHgxYls0ODs1OzIxbSgzKVx4MWJbMG0gJS0zMHMgLT4gJXNcbiIsIG1vZHVsZSwgZmlsZSk7CgogICAgICByZXQgPSBqc19tb2R1bGVfbG9hZGVyKGN0eCwgZmlsZSwgb3BhcXVlKTsKICB9CmVuZDoKICBpZih2ZWN0b3JfZmluZHMoJm1vZHVsZV9kZWJ1ZywgImltcG9ydCIpICE9IC0xKSB7CiAgICBmcHJpbnRmKHN0ZGVyciwgKCFmaWxlIHx8IHN0cmNtcChtb2R1bGUsIGZpbGUpKSA/ICIhISEgSU1QT1JUICVzIC0+ICVzXG4iIDogIiEhISBJTVBPUlQgJXNcbiIsIG1vZHVsZSwgZmlsZSk7CiAgfQogIGlmKCFyZXQpCiAgICBwcmludGYoImpzbV9tb2R1bGVfbG9hZGVyKFwiJXNcIikgPSAlcFxuIiwgbmFtZSwgcmV0KTsKICBpZihtb2R1bGUpCiAgICBqc19mcmVlKGN0eCwgbW9kdWxlKTsKICBpZihmaWxlKQogICAganNfZnJlZShjdHgsIGZpbGUpOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzbV9ldmFsX2ZpbGUoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIGZpbGUsIGludCBtb2R1bGUpIHsKICB1aW50OF90KiBidWY7CiAgc2l6ZV90IGxlbjsKICBpbnQgZmxhZ3M7CgogIGJ1ZiA9IGpzX2xvYWRfZmlsZShjdHgsICZsZW4sIGZpbGUpOwogIGlmKCFidWYpIHsKICAgIHJldHVybiBKU19UaHJvd0ludGVybmFsRXJyb3IoY3R4LCAiRmFpbGVkIGxvYWRpbmcgJyVzJzogJXMiLCBmaWxlLCBzdHJlcnJvcihlcnJubykpOwogIH0KCiAgaWYobW9kdWxlIDwgMCkKICAgIG1vZHVsZSA9IChoYXNfc3VmZml4KGZpbGUsICIubWpzIikgfHwgSlNfRGV0ZWN0TW9kdWxlKChjb25zdCBjaGFyKilidWYsIGxlbikpOwogIGZsYWdzID0gbW9kdWxlID8gSlNfRVZBTF9UWVBFX01PRFVMRSA6IEpTX0VWQUxfVFlQRV9HTE9CQUw7CiAgcmV0dXJuIGV2YWxfYnVmKGN0eCwgYnVmLCBsZW4sIGZpbGUsIGZsYWdzKTsKfQoKc3RhdGljIGludApqc21fbG9hZF9zY3JpcHQoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIGZpbGUsIEJPT0wgbW9kdWxlKSB7CiAgSlNWYWx1ZSB2YWw7CiAgaW50MzJfdCByZXQgPSAwOwogIHZhbCA9IGpzbV9ldmFsX2ZpbGUoY3R4LCBmaWxlLCBtb2R1bGUpOwogIGlmKEpTX0lzRXhjZXB0aW9uKHZhbCkpIHsKICAgIGZwcmludGYoc3RkZXJyLCAiRmFpbGVkIGxvYWRpbmcgJyVzJzogJXNcbiIsIGZpbGUsIHN0cmVycm9yKGVycm5vKSk7CiAgICBqc192YWx1ZV9md3JpdGUoY3R4LCB2YWwsIHN0ZGVycik7CiAgICByZXR1cm4gLTE7CiAgfSBlbHNlIGlmKEpTX0lzTW9kdWxlKHZhbCkpIHsKICAgIEpTVmFsdWUgZ2xvYmFsID0gSlNfR2V0R2xvYmFsT2JqZWN0KGN0eCk7CiAgICBnZXRfbW9kdWxlX2V4cG9ydHMoY3R4LCBKU19WQUxVRV9HRVRfUFRSKHZhbCksIFRSVUUsIGdsb2JhbCk7CiAgfSBlbHNlIHsKICAgIEpTX1RvSW50MzIoY3R4LCAmcmV0LCB2YWwpOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsKTsKICB9CiAgcmV0dXJuIHJldDsKfQoKLyogYWxzbyB1c2VkIHRvIGluaXRpYWxpemUgdGhlIHdvcmtlciBjb250ZXh0ICovCnN0YXRpYyBKU0NvbnRleHQqCmpzbV9jb250ZXh0X25ldyhKU1J1bnRpbWUqIHJ0KSB7CiAgSlNDb250ZXh0KiBjdHg7CiAgY3R4ID0gSlNfTmV3Q29udGV4dChydCk7CiAgaWYoIWN0eCkKICAgIHJldHVybiAwOwojaWZkZWYgQ09ORklHX0JJR05VTQogIGlmKGJpZ251bV9leHQpIHsKICAgIEpTX0FkZEludHJpbnNpY0JpZ0Zsb2F0KGN0eCk7CiAgICBKU19BZGRJbnRyaW5zaWNCaWdEZWNpbWFsKGN0eCk7CiAgICBKU19BZGRJbnRyaW5zaWNPcGVyYXRvcnMoY3R4KTsKICAgIEpTX0VuYWJsZUJpZ251bUV4dChjdHgsIFRSVUUpOwogIH0KI2VuZGlmCgojZGVmaW5lIGpzbV9tb2R1bGVfbmF0aXZlKG5hbWUpIGpzX2luaXRfbW9kdWxlXyMjbmFtZShjdHgsICNuYW1lKTsKCiAganNtX21vZHVsZV9uYXRpdmUoc3RkKTsKICBqc21fbW9kdWxlX25hdGl2ZShvcyk7CiNpZm5kZWYgX193YXNpX18KICBqc21fbW9kdWxlX25hdGl2ZShjaGlsZF9wcm9jZXNzKTsKI2VuZGlmCiAganNtX21vZHVsZV9uYXRpdmUoZGVlcCk7CiAganNtX21vZHVsZV9uYXRpdmUoaW5zcGVjdCk7CiAganNtX21vZHVsZV9uYXRpdmUobGV4ZXIpOwogIGpzbV9tb2R1bGVfbmF0aXZlKG1pc2MpOwojaWZuZGVmIF9fd2FzaV9fCiAganNtX21vZHVsZV9uYXRpdmUobW1hcCk7CiNlbmRpZgogIGpzbV9tb2R1bGVfbmF0aXZlKHBhdGgpOwogIGpzbV9tb2R1bGVfbmF0aXZlKHBvaW50ZXIpOwogIGpzbV9tb2R1bGVfbmF0aXZlKHByZWRpY2F0ZSk7CiAganNtX21vZHVsZV9uYXRpdmUocmVwZWF0ZXIpOwogIGpzbV9tb2R1bGVfbmF0aXZlKHRyZWVfd2Fsa2VyKTsKICBqc21fbW9kdWxlX25hdGl2ZSh4bWwpOwogIHJldHVybiBjdHg7Cn0KCiNpZiBkZWZpbmVkKF9fQVBQTEVfXykKI2RlZmluZSBNQUxMT0NfT1ZFUkhFQUQgMAojZWxzZQojZGVmaW5lIE1BTExPQ19PVkVSSEVBRCA4CiNlbmRpZgoKc3RydWN0IHRyYWNlX21hbGxvY19kYXRhIHsKICB1aW50OF90KiBiYXNlOwp9OwoKc3RhdGljIHZvaWQKZHVtcF92ZWN0b3IoY29uc3QgVmVjdG9yKiB2ZWMsIHNpemVfdCBzdGFydCkgewogIHNpemVfdCBpLCBsZW4gPSB2ZWN0b3Jfc2l6ZSh2ZWMsIHNpemVvZihjaGFyKikpOwogIGZvcihpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykgewogICAgY29uc3QgY2hhciogc3RyID0gKihjaGFyKiopdmVjdG9yX2F0KHZlYywgc2l6ZW9mKGNoYXIqKSwgaSk7CiAgICBmcHV0cyhpID4gc3RhcnQgPyAiJyxcbiAgJyIgOiAiW1xuICAnIiwgc3Rkb3V0KTsKICAgIGZwdXRzKHN0ciwgc3Rkb3V0KTsKICAgIGlmKGkgKyAxID09IGxlbikKICAgICAgcHV0cygiJ1xuXSIpOwogIH0KfQoKc3RhdGljIGlubGluZSB1bnNpZ25lZCBsb25nIGxvbmcKanNtX3RyYWNlX21hbGxvY19wdHJfb2Zmc2V0KHVpbnQ4X3QqIHB0ciwgc3RydWN0IHRyYWNlX21hbGxvY19kYXRhKiBkcCkgewogIHJldHVybiBwdHIgLSBkcC0+YmFzZTsKfQoKLyogZGVmYXVsdCBtZW1vcnkgYWxsb2NhdGlvbiBmdW5jdGlvbnMgd2l0aCBtZW1vcnkgbGltaXRhdGlvbiAqLwpzdGF0aWMgaW5saW5lIHNpemVfdApqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplKHZvaWQqIHB0cikgewojaWYgZGVmaW5lZChfX0FQUExFX18pCiAgcmV0dXJuIG1hbGxvY19zaXplKHB0cik7CiNlbGlmIGRlZmluZWQoX1dJTjMyKQogIHJldHVybiBfbXNpemUocHRyKTsKI2VsaWYgZGVmaW5lZChFTVNDUklQVEVOKSB8fCBkZWZpbmVkKF9fZGlldGxpYmNfXykgfHwgZGVmaW5lZChfX01TWVNfXykgfHwgZGVmaW5lZChET05UX0hBVkVfTUFMTE9DX1VTQUJMRV9TSVpFKQogIHJldHVybiAwOwojZWxpZiBkZWZpbmVkKF9fbGludXhfXykgfHwgZGVmaW5lZChIQVZFX01BTExPQ19VU0FCTEVfU0laRSkKICByZXR1cm4gbWFsbG9jX3VzYWJsZV9zaXplKHB0cik7CiNlbHNlCiAgLyogY2hhbmdlIHRoaXMgdG8gYHJldHVybiAwO2AgaWYgY29tcGlsYXRpb24gZmFpbHMgKi8KICByZXR1cm4gbWFsbG9jX3VzYWJsZV9zaXplKHB0cik7CiNlbmRpZgp9CgpzdGF0aWMgdm9pZAojaWZkZWYgX1dJTjMyCiAgICAvKiBtaW5ndyBwcmludGYgaXMgdXNlZCAqLwogICAgX19hdHRyaWJ1dGVfXygoZm9ybWF0KGdudV9wcmludGYsIDIsIDMpKSkKI2Vsc2UKICAgIF9fYXR0cmlidXRlX18oKGZvcm1hdChwcmludGYsIDIsIDMpKSkKI2VuZGlmCiAgICBqc21fdHJhY2VfbWFsbG9jX3ByaW50ZihKU01hbGxvY1N0YXRlKiBzLCBjb25zdCBjaGFyKiBmbXQsIC4uLikgewogIHZhX2xpc3QgYXA7CiAgaW50IGM7CgogIHZhX3N0YXJ0KGFwLCBmbXQpOwogIHdoaWxlKChjID0gKmZtdCsrKSAhPSAnXDAnKSB7CiAgICBpZihjID09ICclJykgewogICAgICAvKiBvbmx5IGhhbmRsZSAlcCBhbmQgJXpkICovCiAgICAgIGlmKCpmbXQgPT0gJ3AnKSB7CiAgICAgICAgdWludDhfdCogcHRyID0gdmFfYXJnKGFwLCB2b2lkKik7CiAgICAgICAgaWYocHRyID09IDApIHsKICAgICAgICAgIHByaW50ZigiMCIpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBwcmludGYoIkglKzA2bGxkLiV6ZCIsIGpzbV90cmFjZV9tYWxsb2NfcHRyX29mZnNldChwdHIsIHMtPm9wYXF1ZSksIGpzbV90cmFjZV9tYWxsb2NfdXNhYmxlX3NpemUocHRyKSk7CiAgICAgICAgfQogICAgICAgIGZtdCsrOwogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICAgIGlmKGZtdFswXSA9PSAneicgJiYgZm10WzFdID09ICdkJykgewogICAgICAgIHNpemVfdCBzeiA9IHZhX2FyZyhhcCwgc2l6ZV90KTsKICAgICAgICBwcmludGYoIiV6ZCIsIHN6KTsKICAgICAgICBmbXQgKz0gMjsKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgfQogICAgcHV0YyhjLCBzdGRvdXQpOwogIH0KICB2YV9lbmQoYXApOwp9CgpzdGF0aWMgdm9pZApqc21fdHJhY2VfbWFsbG9jX2luaXQoc3RydWN0IHRyYWNlX21hbGxvY19kYXRhKiBzKSB7CiAgZnJlZShzLT5iYXNlID0gbWFsbG9jKDgpKTsKfQoKc3RhdGljIHZvaWQqCmpzbV90cmFjZV9tYWxsb2MoSlNNYWxsb2NTdGF0ZSogcywgc2l6ZV90IHNpemUpIHsKICB2b2lkKiBwdHI7CgogIC8qIERvIG5vdCBhbGxvY2F0ZSB6ZXJvIGJ5dGVzOiBiZWhhdmlvciBpcyBwbGF0Zm9ybSBkZXBlbmRlbnQgKi8KICBhc3NlcnQoc2l6ZSAhPSAwKTsKCiAgaWYodW5saWtlbHkocy0+bWFsbG9jX3NpemUgKyBzaXplID4gcy0+bWFsbG9jX2xpbWl0KSkKICAgIHJldHVybiAwOwogIHB0ciA9IG1hbGxvYyhzaXplKTsKICBqc21fdHJhY2VfbWFsbG9jX3ByaW50ZihzLCAiQSAlemQgLT4gJXBcbiIsIHNpemUsIHB0cik7CiAgaWYocHRyKSB7CiAgICBzLT5tYWxsb2NfY291bnQrKzsKICAgIHMtPm1hbGxvY19zaXplICs9IGpzbV90cmFjZV9tYWxsb2NfdXNhYmxlX3NpemUocHRyKSArIE1BTExPQ19PVkVSSEVBRDsKICB9CiAgcmV0dXJuIHB0cjsKfQoKc3RhdGljIHZvaWQKanNtX3RyYWNlX2ZyZWUoSlNNYWxsb2NTdGF0ZSogcywgdm9pZCogcHRyKSB7CiAgaWYoIXB0cikKICAgIHJldHVybjsKCiAganNtX3RyYWNlX21hbGxvY19wcmludGYocywgIkYgJXBcbiIsIHB0cik7CiAgcy0+bWFsbG9jX2NvdW50LS07CiAgcy0+bWFsbG9jX3NpemUgLT0ganNtX3RyYWNlX21hbGxvY191c2FibGVfc2l6ZShwdHIpICsgTUFMTE9DX09WRVJIRUFEOwogIGZyZWUocHRyKTsKfQoKc3RhdGljIHZvaWQqCmpzbV90cmFjZV9yZWFsbG9jKEpTTWFsbG9jU3RhdGUqIHMsIHZvaWQqIHB0ciwgc2l6ZV90IHNpemUpIHsKICBzaXplX3Qgb2xkX3NpemU7CgogIGlmKCFwdHIpIHsKICAgIGlmKHNpemUgPT0gMCkKICAgICAgcmV0dXJuIDA7CiAgICByZXR1cm4ganNtX3RyYWNlX21hbGxvYyhzLCBzaXplKTsKICB9CiAgb2xkX3NpemUgPSBqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplKHB0cik7CiAgaWYoc2l6ZSA9PSAwKSB7CiAgICBqc21fdHJhY2VfbWFsbG9jX3ByaW50ZihzLCAiUiAlemQgJXBcbiIsIHNpemUsIHB0cik7CiAgICBzLT5tYWxsb2NfY291bnQtLTsKICAgIHMtPm1hbGxvY19zaXplIC09IG9sZF9zaXplICsgTUFMTE9DX09WRVJIRUFEOwogICAgZnJlZShwdHIpOwogICAgcmV0dXJuIDA7CiAgfQogIGlmKHMtPm1hbGxvY19zaXplICsgc2l6ZSAtIG9sZF9zaXplID4gcy0+bWFsbG9jX2xpbWl0KQogICAgcmV0dXJuIDA7CgogIGpzbV90cmFjZV9tYWxsb2NfcHJpbnRmKHMsICJSICV6ZCAlcCIsIHNpemUsIHB0cik7CgogIHB0ciA9IHJlYWxsb2MocHRyLCBzaXplKTsKICBqc21fdHJhY2VfbWFsbG9jX3ByaW50ZihzLCAiIC0+ICVwXG4iLCBwdHIpOwogIGlmKHB0cikgewogICAgcy0+bWFsbG9jX3NpemUgKz0ganNtX3RyYWNlX21hbGxvY191c2FibGVfc2l6ZShwdHIpIC0gb2xkX3NpemU7CiAgfQogIHJldHVybiBwdHI7Cn0KCnN0YXRpYyBjb25zdCBKU01hbGxvY0Z1bmN0aW9ucyB0cmFjZV9tZiA9IHsKICAgIGpzbV90cmFjZV9tYWxsb2MsCiAgICBqc21fdHJhY2VfZnJlZSwKICAgIGpzbV90cmFjZV9yZWFsbG9jLAojaWYgZGVmaW5lZChfX0FQUExFX18pCiAgICBtYWxsb2Nfc2l6ZSwKI2VsaWYgZGVmaW5lZChfV0lOMzIpCiAgICAoc2l6ZV90KCopKGNvbnN0IHZvaWQqKSlfbXNpemUsCiNlbGlmIGRlZmluZWQoRU1TQ1JJUFRFTikgfHwgZGVmaW5lZChfX2RpZXRsaWJjX18pIHx8IGRlZmluZWQoX19NU1lTX18pIHx8IGRlZmluZWQoRE9OVF9IQVZFX01BTExPQ19VU0FCTEVfU0laRV9ERUZJTklUSU9OKQogICAgMCwKI2VsaWYgZGVmaW5lZChfX2xpbnV4X18pIHx8IGRlZmluZWQoSEFWRV9NQUxMT0NfVVNBQkxFX1NJWkUpCiAgICAoc2l6ZV90KCopKGNvbnN0IHZvaWQqKSltYWxsb2NfdXNhYmxlX3NpemUsCiNlbHNlCiAgICAvKiBjaGFuZ2UgdGhpcyB0byBgMCxgIGlmIGNvbXBpbGF0aW9uIGZhaWxzICovCiAgICBtYWxsb2NfdXNhYmxlX3NpemUsCiNlbmRpZgp9OwoKI2RlZmluZSBQUk9HX05BTUUgInFqc20iCgp2b2lkCmpzbV9oZWxwKHZvaWQpIHsKICBwcmludGYoIlF1aWNrSlMgdmVyc2lvbiAiIENPTkZJR19WRVJTSU9OICJcbiIKICAgICAgICAgInVzYWdlOiAiIFBST0dfTkFNRSAiIFtvcHRpb25zXSBbZmlsZSBbYXJnc11dXG4iCiAgICAgICAgICItaCAgLS1oZWxwICAgICAgICAgbGlzdCBvcHRpb25zXG4iCiAgICAgICAgICItZSAgLS1ldmFsIEVYUFIgICAgZXZhbHVhdGUgRVhQUlxuIgogICAgICAgICAiLWkgIC0taW50ZXJhY3RpdmUgIGdvIHRvIGludGVyYWN0aXZlIG1vZGVcbiIKICAgICAgICAgIi1tICAtLW1vZHVsZSBOQU1FICBsb2FkIGFuIEVTNiBtb2R1bGVcbiIKICAgICAgICAgIi1JICAtLWluY2x1ZGUgZmlsZSBpbmNsdWRlIGFuIGFkZGl0aW9uYWwgZmlsZVxuIgogICAgICAgICAiICAgIC0tc3RkICAgICAgICAgIG1ha2UgJ3N0ZCcgYW5kICdvcycgYXZhaWxhYmxlIHRvIHRoZSBsb2FkZWQgc2NyaXB0XG4iCiNpZmRlZiBDT05GSUdfQklHTlVNCiAgICAgICAgICIgICAgLS1uby1iaWdudW0gICAgZGlzYWJsZSB0aGUgYmlnbnVtIGV4dGVuc2lvbnMgKEJpZ0Zsb2F0LCAiCiAgICAgICAgICJCaWdEZWNpbWFsKVxuIgogICAgICAgICAiICAgIC0tcWpzY2FsYyAgICAgIGxvYWQgdGhlIFFKU0NhbGMgcnVudGltZSAoZGVmYXVsdCBpZiBpbnZva2VkIGFzICIKICAgICAgICAgInFqc2NhbGMpXG4iCiNlbmRpZgogICAgICAgICAiLVQgIC0tdHJhY2UgICAgICAgIHRyYWNlIG1lbW9yeSBhbGxvY2F0aW9uXG4iCiAgICAgICAgICItZCAgLS1kdW1wICAgICAgICAgZHVtcCB0aGUgbWVtb3J5IHVzYWdlIHN0YXRzXG4iCiAgICAgICAgICIgICAgLS1tZW1vcnktbGltaXQgbiAgICAgICBsaW1pdCB0aGUgbWVtb3J5IHVzYWdlIHRvICduJyBieXRlc1xuIgogICAgICAgICAiICAgIC0tc3RhY2stc2l6ZSBuICAgICAgICAgbGltaXQgdGhlIHN0YWNrIHNpemUgdG8gJ24nIGJ5dGVzXG4iCiAgICAgICAgICIgICAgLS11bmhhbmRsZWQtcmVqZWN0aW9uICBkdW1wIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiIKICAgICAgICAgIi1xICAtLXF1aXQgICAgICAgICBqdXN0IGluc3RhbnRpYXRlIHRoZSBpbnRlcnByZXRlciBhbmQgcXVpdFxuIik7CiAgZXhpdCgxKTsKfQoKc3RhdGljIEpTVmFsdWUKanNtX2V2YWxfc2NyaXB0KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbWFnaWMpIHsKICBjb25zdCBjaGFyKiBzdHI7CiAgc2l6ZV90IGxlbjsKICBKU1ZhbHVlIHJldDsKICBpbnQzMl90IG1vZHVsZTsKICBzdHIgPSBKU19Ub0NTdHJpbmdMZW4oY3R4LCAmbGVuLCBhcmd2WzBdKTsKICBpZihhcmdjID4gMSkKICAgIEpTX1RvSW50MzIoY3R4LCAmbW9kdWxlLCBhcmd2WzFdKTsKICBlbHNlCiAgICBtb2R1bGUgPSBzdHJfZW5kcyhzdHIsICIubWpzIik7CiAgc3dpdGNoKG1hZ2ljKSB7CiAgICBjYXNlIDA6IHsKICAgICAgcmV0ID0ganNtX2V2YWxfZmlsZShjdHgsIHN0ciwgbW9kdWxlKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIDE6IHsKICAgICAgcmV0ID0gZXZhbF9idWYoY3R4LCBzdHIsIGxlbiwgMCwgbW9kdWxlKTsKICAgICAgYnJlYWs7CiAgICB9CiAgfQogIGlmKEpTX0lzRXhjZXB0aW9uKHJldCkpIHsKICAgIGlmKEpTX0lzTnVsbChKU19HZXRSdW50aW1lKGN0eCktPmN1cnJlbnRfZXhjZXB0aW9uKSkgewogICAgICByZXQgPSBKU19HZXRFeGNlcHRpb24oY3R4KTsKICAgICAgLy8gcmV0ID0gSlNfVU5ERUZJTkVEOwogICAgfQogIH0KICBpZihKU19WQUxVRV9HRVRfVEFHKHJldCkgPT0gSlNfVEFHX01PRFVMRSkgewogICAgSlNNb2R1bGVEZWYqIGRlZiA9IEpTX1ZBTFVFX0dFVF9QVFIocmV0KTsKICAgIEpTVmFsdWUgb2JqID0gSlNfTmV3T2JqZWN0KGN0eCk7CiAgICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgIm5hbWUiLCBtb2R1bGVfbmFtZShjdHgsIGRlZikpOwogICAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCBvYmosICJleHBvcnRzIiwgbW9kdWxlX2V4cG9ydHMoY3R4LCBkZWYpKTsKICAgIHJldCA9IG9iajsKICB9CiAgSlNfRnJlZUNTdHJpbmcoY3R4LCBzdHIpOwogIHJldHVybiByZXQ7Cn0KCmVudW0gewogIEZJTkRfTU9EVUxFLAogIExPQURfTU9EVUxFLAogIFJFU09MVkVfTU9EVUxFLAogIEdFVF9NT0RVTEVfTkFNRSwKICBHRVRfTU9EVUxFX09CSkVDVCwKICBHRVRfTU9EVUxFX0VYUE9SVFMsCiAgR0VUX01PRFVMRV9OQU1FU1BBQ0UsCiAgR0VUX01PRFVMRV9GVU5DVElPTiwKICBHRVRfTU9EVUxFX0VYQ0VQVElPTiwKICBHRVRfTU9EVUxFX01FVEFfT0JKLAp9OwoKc3RhdGljIEpTVmFsdWUKanNtX21vZHVsZV9mdW5jKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbWFnaWMpIHsKICBKU1ZhbHVlIHZhbCA9IEpTX0VYQ0VQVElPTjsKICBKU01vZHVsZURlZiogZGVmID0gMDsKICBjb25zdCBjaGFyKiBuYW1lID0gMDsKCiAgaWYobWFnaWMgPj0gR0VUX01PRFVMRV9OQU1FKSB7CiAgICBpZighKGRlZiA9IGpzX21vZHVsZV9kZWYoY3R4LCBhcmd2WzBdKSkpCiAgICAgIHJldHVybiBKU19UaHJvd1R5cGVFcnJvcihjdHgsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiJXM6IGFyZ3VtZW50IDEgZXhwZWN0aW5nIG1vZHVsZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGNvbnN0IGNoYXIqIGNvbnN0W10pewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJnZXRNb2R1bGVOYW1lIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZ2V0TW9kdWxlT2JqZWN0IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZ2V0TW9kdWxlRXhwb3J0cyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImdldE1vZHVsZU5hbWVzcGFjZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImdldE1vZHVsZUZ1bmN0aW9uIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZ2V0TW9kdWxlRXhjZXB0aW9uIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZ2V0TW9kdWxlTWV0YU9iamVjdCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVttYWdpYyAtIDNdKTsKICB9IGVsc2UgewogICAgbmFtZSA9IEpTX1RvQ1N0cmluZyhjdHgsIGFyZ3ZbMF0pOwogIH0KCiAgc3dpdGNoKG1hZ2ljKSB7CiAgICBjYXNlIEZJTkRfTU9EVUxFOiB7CiAgICAgIGlmKChkZWYgPSBqc19tb2R1bGVfZmluZChjdHgsIG5hbWUpKSkKICAgICAgICB2YWwgPSBKU19EdXBWYWx1ZShjdHgsIEpTX01LUFRSKEpTX1RBR19NT0RVTEUsIGRlZikpOwogICAgICBlbHNlCiAgICAgICAgdmFsID0gSlNfTlVMTDsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIExPQURfTU9EVUxFOiB7CiAgICAgIEltcG9ydERpcmVjdGl2ZSBpbXA7CiAgICAgIG1lbXNldCgmaW1wLCAwLCBzaXplb2YoaW1wKSk7CiAgICAgIGludCByLCBuID0gY291bnRvZihpbXAuYXJncyk7CiAgICAgIHIgPSBqc19zdHJ2X2NvcHlzKGN0eCwgYXJnYywgYXJndiwgbiwgaW1wLmFyZ3MpOwogICAgICAvLyBwcmludGYoIkxPQURfTU9EVUxFIHI9JWkgYXJnYz0laVxuIiwgciwgYXJnYyk7CgogICAgICB2YWwgPSBqc19pbXBvcnRfZXZhbChjdHgsIGltcCk7CgogICAgICAvKiAgIGlmKEpTX0lzTW9kdWxlKHZhbCkpCiAgICAgICAgICAgZGVmID0gSlNfVkFMVUVfR0VUX1BUUih2YWwpOwogICAgICAgICBlbHNlKi8KICAgICAgZGVmID0ganNfbW9kdWxlX2ZpbmQoY3R4LCBpbXAucGF0aCk7CgogICAgICBpZihkZWYpCiAgICAgICAgdmFsID0gbW9kdWxlX29iamVjdChjdHgsIGRlZik7CgogICAgICBqc19zdHJ2X2ZyZWVfbihjdHgsIG4sIGltcC5hcmdzKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIFJFU09MVkVfTU9EVUxFOiB7CiAgICAgIHZhbCA9IEpTX05ld0ludDMyKGN0eCwgSlNfUmVzb2x2ZU1vZHVsZShjdHgsIEpTX01LUFRSKEpTX1RBR19NT0RVTEUsIGRlZikpKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEdFVF9NT0RVTEVfTkFNRTogewogICAgICB2YWwgPSBtb2R1bGVfbmFtZShjdHgsIGRlZik7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBHRVRfTU9EVUxFX09CSkVDVDogewogICAgICB2YWwgPSBtb2R1bGVfb2JqZWN0KGN0eCwgZGVmKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEdFVF9NT0RVTEVfRVhQT1JUUzogewogICAgICB2YWwgPSBtb2R1bGVfZXhwb3J0cyhjdHgsIGRlZik7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBHRVRfTU9EVUxFX05BTUVTUEFDRTogewogICAgICB2YWwgPSBKU19EdXBWYWx1ZShjdHgsIGRlZi0+bW9kdWxlX25zKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEdFVF9NT0RVTEVfRlVOQ1RJT046IHsKCiAgICAgIHZhbCA9IG1vZHVsZV9mdW5jKGN0eCwgZGVmKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEdFVF9NT0RVTEVfRVhDRVBUSU9OOiB7CiAgICAgIGlmKGRlZi0+ZXZhbF9oYXNfZXhjZXB0aW9uKQogICAgICAgIHZhbCA9IEpTX0R1cFZhbHVlKGN0eCwgZGVmLT5ldmFsX2V4Y2VwdGlvbik7CiAgICAgIGVsc2UKICAgICAgICB2YWwgPSBKU19OVUxMOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgR0VUX01PRFVMRV9NRVRBX09CSjogewogICAgICB2YWwgPSBKU19EdXBWYWx1ZShjdHgsIGRlZi0+bWV0YV9vYmopOwogICAgICBicmVhazsKICAgIH0KICB9CiAgaWYobmFtZSkKICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgbmFtZSk7CgogIHJldHVybiB2YWw7Cn0KCnN0YXRpYyBjb25zdCBKU0NGdW5jdGlvbkxpc3RFbnRyeSBqc21fZ2xvYmFsX2Z1bmNzW10gPSB7CiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImV2YWxGaWxlIiwgMSwganNtX2V2YWxfc2NyaXB0LCAwKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZXZhbFNjcmlwdCIsIDEsIGpzbV9ldmFsX3NjcmlwdCwgMSksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigibW9kdWxlTGlzdCIsIGpzX21vZHVsZXNfYXJyYXksIDAsIDApLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoIm1vZHVsZU9iamVjdCIsIGpzX21vZHVsZXNfb2JqZWN0LCAwLCAwKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJtb2R1bGVNYXAiLCBqc19tb2R1bGVzX21hcCwgMCwgMCksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImZpbmRNb2R1bGUiLCAxLCBqc21fbW9kdWxlX2Z1bmMsIEZJTkRfTU9EVUxFKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigibG9hZE1vZHVsZSIsIDEsIGpzbV9tb2R1bGVfZnVuYywgTE9BRF9NT0RVTEUpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJyZXNvbHZlTW9kdWxlIiwgMSwganNtX21vZHVsZV9mdW5jLCBSRVNPTFZFX01PRFVMRSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImdldE1vZHVsZU5hbWUiLCAxLCBqc21fbW9kdWxlX2Z1bmMsIEdFVF9NT0RVTEVfTkFNRSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImdldE1vZHVsZU9iamVjdCIsIDEsIGpzbV9tb2R1bGVfZnVuYywgR0VUX01PRFVMRV9PQkpFQ1QpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRNb2R1bGVFeHBvcnRzIiwgMSwganNtX21vZHVsZV9mdW5jLCBHRVRfTU9EVUxFX0VYUE9SVFMpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRNb2R1bGVOYW1lc3BhY2UiLCAxLCBqc21fbW9kdWxlX2Z1bmMsIEdFVF9NT0RVTEVfTkFNRVNQQUNFKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0TW9kdWxlRnVuY3Rpb24iLCAxLCBqc21fbW9kdWxlX2Z1bmMsIEdFVF9NT0RVTEVfRlVOQ1RJT04pLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRNb2R1bGVFeGNlcHRpb24iLCAxLCBqc21fbW9kdWxlX2Z1bmMsIEdFVF9NT0RVTEVfRVhDRVBUSU9OKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0TW9kdWxlTWV0YU9iamVjdCIsIDEsIGpzbV9tb2R1bGVfZnVuYywgR0VUX01PRFVMRV9NRVRBX09CSiksCn07CgppbnQKbWFpbihpbnQgYXJnYywgY2hhcioqIGFyZ3YpIHsKICBKU1J1bnRpbWUqIHJ0OwogIEpTQ29udGV4dCogY3R4OwogIHN0cnVjdCB0cmFjZV9tYWxsb2NfZGF0YSB0cmFjZV9kYXRhID0gezB9OwogIGludCBvcHRpbmQ7CiAgY2hhciogZXhwciA9IDA7CiAgaW50IGludGVyYWN0aXZlID0gMDsKICBpbnQgZHVtcF9tZW1vcnkgPSAwOwogIGludCB0cmFjZV9tZW1vcnkgPSAwOwogIGludCBlbXB0eV9ydW4gPSAwOwogIGludCBtb2R1bGUgPSAxOwogIGludCBsb2FkX3N0ZCA9IDE7CiAgaW50IGR1bXBfdW5oYW5kbGVkX3Byb21pc2VfcmVqZWN0aW9uID0gMDsKICBzaXplX3QgbWVtb3J5X2xpbWl0ID0gMDsKICBjaGFyKiBpbmNsdWRlX2xpc3RbMzJdOwogIGludCBpLCBpbmNsdWRlX2NvdW50ID0gMDsKI2lmZGVmIENPTkZJR19CSUdOVU0KICBpbnQgbG9hZF9qc2NhbGM7CiNlbmRpZgogIHNpemVfdCBzdGFja19zaXplID0gMDsKICBjb25zdCBjaGFyKiBleGVuYW1lOwoKICBwYWNrYWdlX2pzb24gPSBKU19VTkRFRklORUQ7CgogIGluaXRfbGlzdF9oZWFkKCZwb2xsaGFuZGxlcnMpOwoKICB7CiAgICBjb25zdCBjaGFyKiBwOwogICAgZXhlbmFtZSA9IGFyZ3ZbMF07CiAgICBwID0gc3RycmNocihleGVuYW1lLCAnLycpOwogICAgaWYocCkKICAgICAgZXhlbmFtZSA9IHAgKyAxOwogICAgLyogbG9hZCBqc2NhbGMgcnVudGltZSBpZiBpbnZva2VkIGFzICdxanNjYWxjJyAqLwogICAgbG9hZF9qc2NhbGMgPSAhc3RyY21wKGV4ZW5hbWUsICJxanNjYWxjIik7CiAgfQoKICAvKiBjYW5ub3QgdXNlIGdldG9wdCBiZWNhdXNlIHdlIHdhbnQgdG8gcGFzcyB0aGUgY29tbWFuZCBsaW5lIHRvCiAgICAgdGhlIHNjcmlwdCAqLwogIG9wdGluZCA9IDE7CiAgd2hpbGUob3B0aW5kIDwgYXJnYyAmJiAqYXJndltvcHRpbmRdID09ICctJykgewogICAgY2hhciogYXJnID0gYXJndltvcHRpbmRdICsgMTsKICAgIGNvbnN0IGNoYXIqIGxvbmdvcHQgPSAiIjsKICAgIGNvbnN0IGNoYXIqIG9wdGFyZzsKCiAgICAvKiBhIHNpbmdsZSAtIGlzIG5vdCBhbiBvcHRpb24sIGl0IGFsc28gc3RvcHMgYXJndW1lbnQgc2Nhbm5pbmcgKi8KICAgIGlmKCEqYXJnKQogICAgICBicmVhazsKCiAgICBpZihhcmdbMV0pIHsKICAgICAgb3B0YXJnID0gJmFyZ1sxXTsKICAgIH0gZWxzZSB7CiAgICAgIG9wdGFyZyA9IGFyZ3ZbKytvcHRpbmRdOwogICAgfQoKICAgIGlmKCphcmcgPT0gJy0nKSB7CiAgICAgIGxvbmdvcHQgPSBhcmcgKyAxOwogICAgICBhcmcgKz0gc3RybGVuKGFyZyk7CiAgICAgIC8qIC0tIHN0b3BzIGFyZ3VtZW50IHNjYW5uaW5nICovCiAgICAgIGlmKCEqbG9uZ29wdCkKICAgICAgICBicmVhazsKICAgIH0KICAgIGZvcig7ICphcmcgfHwgKmxvbmdvcHQ7IGxvbmdvcHQgPSAiIikgewogICAgICBjaGFyIG9wdCA9ICphcmc7CiAgICAgIGlmKG9wdCkKICAgICAgICBhcmcrKzsKICAgICAgaWYob3B0ID09ICdoJyB8fCBvcHQgPT0gJz8nIHx8ICFzdHJjbXAobG9uZ29wdCwgImhlbHAiKSkgewogICAgICAgIGpzbV9oZWxwKCk7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KICAgICAgaWYob3B0ID09ICdlJyB8fCAhc3RyY21wKGxvbmdvcHQsICJldmFsIikpIHsKICAgICAgICBpZigqYXJnKSB7CiAgICAgICAgICBleHByID0gYXJnOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIGlmKG9wdGluZCA8IGFyZ2MpIHsKICAgICAgICAgIGV4cHIgPSBhcmd2W29wdGluZCsrXTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICBmcHJpbnRmKHN0ZGVyciwgIiVzOiBtaXNzaW5nIGV4cHJlc3Npb24gZm9yIC1lXG4iLCBleGVuYW1lKTsKICAgICAgICBleGl0KDIpOwogICAgICB9CiAgICAgIGlmKG9wdCA9PSAnSScgfHwgIXN0cmNtcChsb25nb3B0LCAiaW5jbHVkZSIpKSB7CiAgICAgICAgaWYob3B0aW5kID49IGFyZ2MpIHsKICAgICAgICAgIGZwcmludGYoc3RkZXJyLCAiZXhwZWN0aW5nIGZpbGVuYW1lIik7CiAgICAgICAgICBleGl0KDEpOwogICAgICAgIH0KICAgICAgICBpZihpbmNsdWRlX2NvdW50ID49IGNvdW50b2YoaW5jbHVkZV9saXN0KSkgewogICAgICAgICAgZnByaW50ZihzdGRlcnIsICJ0b28gbWFueSBpbmNsdWRlZCBmaWxlcyIpOwogICAgICAgICAgZXhpdCgxKTsKICAgICAgICB9CiAgICAgICAgaW5jbHVkZV9saXN0W2luY2x1ZGVfY291bnQrK10gPSBvcHRhcmc7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYob3B0ID09ICdpJyB8fCAhc3RyY21wKGxvbmdvcHQsICJpbnRlcmFjdGl2ZSIpKSB7CiAgICAgICAgaW50ZXJhY3RpdmUrKzsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZihvcHQgPT0gJ20nIHx8ICFzdHJjbXAobG9uZ29wdCwgIm1vZHVsZSIpKSB7CiAgICAgICAgY29uc3QgY2hhciogbW9kdWxlcyA9IGFyZ3Zbb3B0aW5kXTsKICAgICAgICBzaXplX3QgaSwgbGVuOwoKICAgICAgICBmb3IoaSA9IDA7IG1vZHVsZXNbaV07IGkgKz0gbGVuKSB7CiAgICAgICAgICBsZW4gPSBzdHJfY2hyKCZtb2R1bGVzW2ldLCAnLCcpOwogICAgICAgICAgdmVjdG9yX3B1dHB0cigmbW9kdWxlX2xpc3QsIHN0cl9uZHVwKCZtb2R1bGVzW2ldLCBsZW4pKTsKCiAgICAgICAgICBpZihtb2R1bGVzW2kgKyBsZW5dID09ICcsJykKICAgICAgICAgICAgbGVuKys7CiAgICAgICAgfQoKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZihvcHQgPT0gJ2QnIHx8ICFzdHJjbXAobG9uZ29wdCwgImR1bXAiKSkgewogICAgICAgIGR1bXBfbWVtb3J5Kys7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYob3B0ID09ICdUJyB8fCAhc3RyY21wKGxvbmdvcHQsICJ0cmFjZSIpKSB7CiAgICAgICAgdHJhY2VfbWVtb3J5Kys7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYoIXN0cmNtcChsb25nb3B0LCAic3RkIikpIHsKICAgICAgICBsb2FkX3N0ZCA9IDE7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYoIXN0cmNtcChsb25nb3B0LCAidW5oYW5kbGVkLXJlamVjdGlvbiIpKSB7CiAgICAgICAgZHVtcF91bmhhbmRsZWRfcHJvbWlzZV9yZWplY3Rpb24gPSAxOwogICAgICAgIGJyZWFrOwogICAgICB9CiNpZmRlZiBDT05GSUdfQklHTlVNCiAgICAgIGlmKCFzdHJjbXAobG9uZ29wdCwgIm5vLWJpZ251bSIpKSB7CiAgICAgICAgYmlnbnVtX2V4dCA9IDA7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYoIXN0cmNtcChsb25nb3B0LCAiYmlnbnVtIikpIHsKICAgICAgICBiaWdudW1fZXh0ID0gMTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZighc3RyY21wKGxvbmdvcHQsICJxanNjYWxjIikpIHsKICAgICAgICBsb2FkX2pzY2FsYyA9IDE7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KI2VuZGlmCiAgICAgIGlmKG9wdCA9PSAncScgfHwgIXN0cmNtcChsb25nb3B0LCAicXVpdCIpKSB7CiAgICAgICAgZW1wdHlfcnVuKys7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYoIXN0cmNtcChsb25nb3B0LCAibWVtb3J5LWxpbWl0IikpIHsKICAgICAgICBpZihvcHRpbmQgPj0gYXJnYykgewogICAgICAgICAgZnByaW50ZihzdGRlcnIsICJleHBlY3RpbmcgbWVtb3J5IGxpbWl0Iik7CiAgICAgICAgICBleGl0KDEpOwogICAgICAgIH0KICAgICAgICBtZW1vcnlfbGltaXQgPSAoc2l6ZV90KXN0cnRvZChhcmd2W29wdGluZCsrXSwgMCk7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYoIXN0cmNtcChsb25nb3B0LCAic3RhY2stc2l6ZSIpKSB7CiAgICAgICAgaWYob3B0aW5kID49IGFyZ2MpIHsKICAgICAgICAgIGZwcmludGYoc3RkZXJyLCAiZXhwZWN0aW5nIHN0YWNrIHNpemUiKTsKICAgICAgICAgIGV4aXQoMSk7CiAgICAgICAgfQogICAgICAgIHN0YWNrX3NpemUgPSAoc2l6ZV90KXN0cnRvZChhcmd2W29wdGluZCsrXSwgMCk7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYob3B0KSB7CiAgICAgICAgZnByaW50ZihzdGRlcnIsICIlczogdW5rbm93biBvcHRpb24gJy0lYydcbiIsIGV4ZW5hbWUsIG9wdCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZnByaW50ZihzdGRlcnIsICIlczogdW5rbm93biBvcHRpb24gJy0tJXMnXG4iLCBleGVuYW1lLCBsb25nb3B0KTsKICAgICAgfQogICAgICBqc21faGVscCgpOwogICAgfQogICAgb3B0aW5kKys7CiAgfQoKICB7CiAgICBjb25zdCBjaGFyKiBtb2R1bGVzOwoKICAgIGlmKChtb2R1bGVzID0gZ2V0ZW52KCJERUJVRyIpKSkgewogICAgICBzaXplX3QgaSwgbGVuOwogICAgICBmb3IoaSA9IDA7IG1vZHVsZXNbaV07IGkgKz0gbGVuKSB7CiAgICAgICAgbGVuID0gc3RyX2NocigmbW9kdWxlc1tpXSwgJywnKTsKICAgICAgICB2ZWN0b3JfcHV0cHRyKCZtb2R1bGVfZGVidWcsIHN0cl9uZHVwKCZtb2R1bGVzW2ldLCBsZW4pKTsKCiAgICAgICAgaWYobW9kdWxlc1tpICsgbGVuXSA9PSAnLCcpCiAgICAgICAgICBsZW4rKzsKICAgICAgfQoKICAgICAgZGVidWdfbW9kdWxlX2xvYWRlciA9IHZlY3Rvcl9jb3VudHMoJm1vZHVsZV9kZWJ1ZywgIm1vZHVsZXMiKTsKICAgIH0KICB9CgogIGlmKGxvYWRfanNjYWxjKQogICAgYmlnbnVtX2V4dCA9IDE7CgogIGlmKHRyYWNlX21lbW9yeSkgewogICAganNtX3RyYWNlX21hbGxvY19pbml0KCZ0cmFjZV9kYXRhKTsKICAgIHJ0ID0gSlNfTmV3UnVudGltZTIoJnRyYWNlX21mLCAmdHJhY2VfZGF0YSk7CiAgfSBlbHNlIHsKICAgIHJ0ID0gSlNfTmV3UnVudGltZSgpOwogIH0KICBpZighcnQpIHsKICAgIGZwcmludGYoc3RkZXJyLCAiJXM6IGNhbm5vdCBhbGxvY2F0ZSBKUyBydW50aW1lXG4iLCBleGVuYW1lKTsKICAgIGV4aXQoMik7CiAgfQoKICBKU19TZXRNb2R1bGVMb2FkZXJGdW5jKHJ0LCAwLCBqc21fbW9kdWxlX2xvYWRlciwgMCk7CgogIGlmKG1lbW9yeV9saW1pdCAhPSAwKQogICAgSlNfU2V0TWVtb3J5TGltaXQocnQsIG1lbW9yeV9saW1pdCk7CiAgLy8gaWYgKHN0YWNrX3NpemUgIT0gMCkKICBKU19TZXRNYXhTdGFja1NpemUocnQsIHN0YWNrX3NpemUgIT0gMCA/IHN0YWNrX3NpemUgOiAyNTYgKiAxMDQ4NTc2KTsKCiAganNfc3RkX3NldF93b3JrZXJfbmV3X2NvbnRleHRfZnVuYyhqc21fY29udGV4dF9uZXcpOwoKICBqc19zdGRfaW5pdF9oYW5kbGVycyhydCk7CiAgY3R4ID0ganNtX2NvbnRleHRfbmV3KHJ0KTsKICBpZighY3R4KSB7CiAgICBmcHJpbnRmKHN0ZGVyciwgIiVzOiBjYW5ub3QgYWxsb2NhdGUgSlMgY29udGV4dFxuIiwgZXhlbmFtZSk7CiAgICBleGl0KDIpOwogIH0KCiAgLyogbG9hZGVyIGZvciBFUzYgbW9kdWxlcyAqLwogIEpTX1NldE1vZHVsZUxvYWRlckZ1bmMocnQsIGpzX21vZHVsZV9ub3JtYWxpemUsIGpzbV9tb2R1bGVfbG9hZGVyLCAwKTsKICAvLyBqc19zdGRfc2V0X21vZHVsZV9sb2FkZXJfZnVuYyhqc21fbW9kdWxlX2xvYWRlcik7CgogIGlmKGR1bXBfdW5oYW5kbGVkX3Byb21pc2VfcmVqZWN0aW9uKSB7CiAgICBKU19TZXRIb3N0UHJvbWlzZVJlamVjdGlvblRyYWNrZXIocnQsIGpzX3N0ZF9wcm9taXNlX3JlamVjdGlvbl90cmFja2VyLCAwKTsKICB9CgogIGlmKCFlbXB0eV9ydW4pIHsKI2lmZGVmIENPTkZJR19CSUdOVU0KICAgIGlmKGxvYWRfanNjYWxjKSB7CiAgICAgIGpzX2V2YWxfYmluYXJ5KGN0eCwgcWpzY19xanNjYWxjLCBxanNjX3Fqc2NhbGNfc2l6ZSwgMCk7CiAgICB9CiNlbmRpZgogICAganNfc3RkX2FkZF9oZWxwZXJzKGN0eCwgYXJnYyAtIG9wdGluZCwgYXJndiArIG9wdGluZCk7CgogICAgaW50IG51bV9uYXRpdmUsIG51bV9jb21waWxlZDsKCiNkZWZpbmUganNtX2J1aWx0aW5fbmF0aXZlKG5hbWUpIHZlY3Rvcl9wdXRwdHIoJmJ1aWx0aW5zLCAjbmFtZSkKCiAgICBqc21fYnVpbHRpbl9uYXRpdmUoc3RkKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShvcyk7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUoY2hpbGRfcHJvY2Vzcyk7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUoZGVlcCk7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUoaW5zcGVjdCk7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUobGV4ZXIpOwogICAganNtX2J1aWx0aW5fbmF0aXZlKG1pc2MpOwogICAganNtX2J1aWx0aW5fbmF0aXZlKG1tYXApOwogICAganNtX2J1aWx0aW5fbmF0aXZlKHBhdGgpOwogICAganNtX2J1aWx0aW5fbmF0aXZlKHBvaW50ZXIpOwogICAganNtX2J1aWx0aW5fbmF0aXZlKHByZWRpY2F0ZSk7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUocmVwZWF0ZXIpOwogICAganNtX2J1aWx0aW5fbmF0aXZlKHRyZWVfd2Fsa2VyKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZSh4bWwpOwogICAgbnVtX25hdGl2ZSA9IHZlY3Rvcl9zaXplKCZidWlsdGlucywgc2l6ZW9mKGNoYXIqKSk7CgogICAgLy8gcHJpbnRmKCJuYXRpdmUgYnVpbHRpbnM6ICIpOyBkdW1wX3ZlY3RvcigmYnVpbHRpbnMsIDApOwoKI2RlZmluZSBqc21fYnVpbHRpbl9jb21waWxlZChuYW1lKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAganNfc3RkX2V2YWxfYmluYXJ5KGN0eCwgcWpzY18jI25hbWUsIHFqc2NfIyNuYW1lIyNfc2l6ZSwgMCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIHZlY3Rvcl9wdXRwdHIoJmJ1aWx0aW5zLCAjbmFtZSkKCiAgICBqc21fYnVpbHRpbl9jb21waWxlZChjb25zb2xlKTsKICAgIGpzbV9idWlsdGluX2NvbXBpbGVkKGV2ZW50cyk7CiAgICBqc21fYnVpbHRpbl9jb21waWxlZChmcyk7CiAgICBqc21fYnVpbHRpbl9jb21waWxlZChwZXJmX2hvb2tzKTsKICAgIGpzbV9idWlsdGluX2NvbXBpbGVkKHByb2Nlc3MpOwogICAgLy8ganNtX2J1aWx0aW5fY29tcGlsZWQocmVwbCk7CiAgICBqc21fYnVpbHRpbl9jb21waWxlZChyZXF1aXJlKTsKICAgIGpzbV9idWlsdGluX2NvbXBpbGVkKHR0eSk7CiAgICBqc21fYnVpbHRpbl9jb21waWxlZCh1dGlsKTsKCiAgICBudW1fY29tcGlsZWQgPSB2ZWN0b3Jfc2l6ZSgmYnVpbHRpbnMsIHNpemVvZihjaGFyKikpIC0gbnVtX25hdGl2ZTsKCiAgICB7CiAgICAgIGNvbnN0IGNoYXIqIHN0ciA9ICJpbXBvcnQgcHJvY2VzcyBmcm9tICdwcm9jZXNzJztcbmdsb2JhbFRoaXMucHJvY2VzcyA9IHByb2Nlc3M7XG4iOwogICAgICBqc19ldmFsX3N0cihjdHgsIHN0ciwgMCwgSlNfRVZBTF9UWVBFX01PRFVMRSk7CiAgICB9CgogICAgSlNfU2V0UHJvcGVydHlGdW5jdGlvbkxpc3QoY3R4LCBKU19HZXRHbG9iYWxPYmplY3QoY3R4KSwganNtX2dsb2JhbF9mdW5jcywgY291bnRvZihqc21fZ2xvYmFsX2Z1bmNzKSk7CiAgICBpZihsb2FkX3N0ZCkgewogICAgICBjb25zdCBjaGFyKiBzdHIgPSAiaW1wb3J0ICogYXMgc3RkIGZyb20gJ3N0ZCc7XG5pbXBvcnQgKiBhcyBvcyBmcm9tICIKICAgICAgICAgICAgICAgICAgICAgICAgIidvcyc7XG5nbG9iYWxUaGlzLnN0ZCA9ICIKICAgICAgICAgICAgICAgICAgICAgICAgInN0ZDtcbmdsb2JhbFRoaXMub3MgIgogICAgICAgICAgICAgICAgICAgICAgICAiPSBvcztcbmdsb2JhbFRoaXMuc2V0VGltZW91dCA9ICIKICAgICAgICAgICAgICAgICAgICAgICAgIm9zLnNldFRpbWVvdXQ7XG5nbG9iYWxUaGlzLmNsZWFyVGltZW91dCA9ICIKICAgICAgICAgICAgICAgICAgICAgICAgIm9zLmNsZWFyVGltZW91dDtcbiI7CiAgICAgIGpzX2V2YWxfc3RyKGN0eCwgc3RyLCAwLCBKU19FVkFMX1RZUEVfTU9EVUxFKTsKICAgIH0KCiAgICAvLyBqc21fbGlzdF9tb2R1bGVzKGN0eCk7CgogICAgewogICAgICBjaGFyKiogbmFtZTsKICAgICAgSlNNb2R1bGVEZWYqIG07CiAgICAgIHZlY3Rvcl9mb3JlYWNoX3QoJm1vZHVsZV9saXN0LCBuYW1lKSB7CiAgICAgICAgaWYoIShtID0ganNfbW9kdWxlX2ltcG9ydF9uYW1lc3BhY2UoY3R4LCAqbmFtZSwgMCkpKSB7CiAgICAgICAgICBmcHJpbnRmKHN0ZGVyciwgImVycm9yIGxvYWRpbmcgbW9kdWxlICclcydcbiIsICpuYW1lKTsKICAgICAgICAgIGpzbV9kdW1wX2Vycm9yKGN0eCk7CiAgICAgICAgICBleGl0KDEpOwogICAgICAgIH0KICAgICAgICBmcmVlKCpuYW1lKTsKICAgICAgfQogICAgICB2ZWN0b3JfZnJlZSgmbW9kdWxlX2xpc3QpOwogICAgfQoKICAgIGZvcihpID0gMDsgaSA8IGluY2x1ZGVfY291bnQ7IGkrKykgewogICAgICBpZihqc21fbG9hZF9zY3JpcHQoY3R4LCBpbmNsdWRlX2xpc3RbaV0sIG1vZHVsZSkgPT0gLTEpCiAgICAgICAgZ290byBmYWlsOwogICAgfQoKICAgIGlmKGV4cHIpIHsKICAgICAgaWYoanNfZXZhbF9zdHIoY3R4LCBleHByLCAiPGNtZGxpbmU+IiwgMCkgPT0gLTEpCiAgICAgICAgZ290byBmYWlsOwogICAgfSBlbHNlIGlmKG9wdGluZCA+PSBhcmdjKSB7CiAgICAgIC8qIGludGVyYWN0aXZlIG1vZGUgKi8KICAgICAgaW50ZXJhY3RpdmUgPSAxOwogICAgfSBlbHNlIHsKICAgICAgY29uc3QgY2hhciogZmlsZW5hbWU7CiAgICAgIGZpbGVuYW1lID0gYXJndltvcHRpbmRdOwogICAgICBpZihqc21fbG9hZF9zY3JpcHQoY3R4LCBmaWxlbmFtZSwgbW9kdWxlKSA9PSAtMSkgewogICAgICAgIGpzX3ZhbHVlX2Z3cml0ZShjdHgsIEpTX0dldEV4Y2VwdGlvbihjdHgpLCBzdGRlcnIpOwogICAgICAgIGdvdG8gZmFpbDsKICAgICAgfQogICAgfQogICAgaWYoaW50ZXJhY3RpdmUpIHsKICAgICAgY2hhciBzdHJbNTEyXTsKICAgICAgY29uc3QgY2hhciogaG9tZSA9IGdldGVudigiSE9NRSIpOwoKICAgICAgc25wcmludGYoc3RyLAogICAgICAgICAgICAgICBzaXplb2Yoc3RyKSwKICAgICAgICAgICAgICAgImltcG9ydCBSRVBMIGZyb20gJ3JlcGwnO1xuIgogICAgICAgICAgICAgICAiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbiIKICAgICAgICAgICAgICAgImNvbnN0IGhpc3RvcnkgPSAnJXMvLiVzX2hpc3RvcnknO1xuIgogICAgICAgICAgICAgICAiZ2xvYmFsVGhpcy5yZXBsID0gbmV3IFJFUEwoJ3Fqc20nKTtcbiIKICAgICAgICAgICAgICAgInJlcGwuZnMgPSBmcztcbiIKICAgICAgICAgICAgICAgInJlcGwuc2hvdyA9IGNvbnNvbGUubG9nO1xuIgogICAgICAgICAgICAgICAicmVwbC5oaXN0b3J5TG9hZChoaXN0b3J5KTtcbiIKICAgICAgICAgICAgICAgInJlcGwuYWRkQ2xlYW51cEhhbmRsZXIoKCkgPT4gcmVwbC5oaXN0b3J5U2F2ZShoaXN0b3J5KSk7XG4iCiAgICAgICAgICAgICAgICJyZXBsLnJ1blN5bmMoKTtcbiIsCiAgICAgICAgICAgICAgIGhvbWUsCiAgICAgICAgICAgICAgIGV4ZW5hbWUpOwogICAgICBwcmludGYoInN0cjogJXNcbiIsIHN0cik7CiAgICAgIGpzX2V2YWxfYmluYXJ5KGN0eCwgcWpzY19yZXBsLCBxanNjX3JlcGxfc2l6ZSwgMCk7CiAgICAgIGpzX2V2YWxfc3RyKGN0eCwgc3RyLCAwLCBKU19FVkFMX1RZUEVfTU9EVUxFKTsKICAgIH0KCiAgICBqc19zdGRfbG9vcChjdHgpOwogIH0KCiAgaWYoIUpTX0lzTnVsbChjdHgtPnJ0LT5jdXJyZW50X2V4Y2VwdGlvbikpCiAgICBqc21fZHVtcF9lcnJvcihjdHgpOwoKICBpZihkdW1wX21lbW9yeSkgewogICAgSlNNZW1vcnlVc2FnZSBzdGF0czsKICAgIEpTX0NvbXB1dGVNZW1vcnlVc2FnZShydCwgJnN0YXRzKTsKICAgIEpTX0R1bXBNZW1vcnlVc2FnZShzdGRvdXQsICZzdGF0cywgcnQpOwogIH0KICBqc19zdGRfZnJlZV9oYW5kbGVycyhydCk7CiAgSlNfRnJlZUNvbnRleHQoY3R4KTsKICBKU19GcmVlUnVudGltZShydCk7CgogIGlmKGVtcHR5X3J1biAmJiBkdW1wX21lbW9yeSkgewogICAgY2xvY2tfdCB0WzVdOwogICAgZG91YmxlIGJlc3RbNV07CiAgICBpbnQgaSwgajsKICAgIGZvcihpID0gMDsgaSA8IDEwMDsgaSsrKSB7CiAgICAgIHRbMF0gPSBjbG9jaygpOwogICAgICBydCA9IEpTX05ld1J1bnRpbWUoKTsKICAgICAgdFsxXSA9IGNsb2NrKCk7CiAgICAgIGN0eCA9IEpTX05ld0NvbnRleHQocnQpOwogICAgICB0WzJdID0gY2xvY2soKTsKICAgICAgSlNfRnJlZUNvbnRleHQoY3R4KTsKICAgICAgdFszXSA9IGNsb2NrKCk7CiAgICAgIEpTX0ZyZWVSdW50aW1lKHJ0KTsKICAgICAgdFs0XSA9IGNsb2NrKCk7CiAgICAgIGZvcihqID0gNDsgaiA+IDA7IGotLSkgewogICAgICAgIGRvdWJsZSBtcyA9IDEwMDAuMCAqICh0W2pdIC0gdFtqIC0gMV0pIC8gQ0xPQ0tTX1BFUl9TRUM7CiAgICAgICAgaWYoaSA9PSAwIHx8IGJlc3Rbal0gPiBtcykKICAgICAgICAgIGJlc3Rbal0gPSBtczsKICAgICAgfQogICAgfQogICAgcHJpbnRmKCJcbkluc3RhbnRpYXRpb24gdGltZXMgKG1zKTogJS4zZiA9ICUuM2YrJS4zZislLjNmKyUuM2ZcbiIsIGJlc3RbMV0gKyBiZXN0WzJdICsgYmVzdFszXSArIGJlc3RbNF0sIGJlc3RbMV0sIGJlc3RbMl0sIGJlc3RbM10sIGJlc3RbNF0pOwogIH0KICByZXR1cm4gMDsKZmFpbDoKICBqc19zdGRfZnJlZV9oYW5kbGVycyhydCk7CiAgSlNfRnJlZUNvbnRleHQoY3R4KTsKICBKU19GcmVlUnVudGltZShydCk7CiAgcmV0dXJuIDE7Cn0KAAAAAAAAAAC9cAAAAAAAAAAAAAAAAAAAAAAAAL1wAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAZGcAAAAAAABvZwAAAAAAAAAAAAAAAPC/"
				],
				[
					1,
					1,
					"revert",
					null,
					"BAAAAAAAAAAAAAAAAAAAAAAAAAC9cAAAI2luY2x1ZGUgPHN0ZGxpYi5oPgojaW5jbHVkZSA8c3RkaW8uaD4KI2luY2x1ZGUgPHN0ZGFyZy5oPgojaW5jbHVkZSA8aW50dHlwZXMuaD4KI2luY2x1ZGUgPHN0cmluZy5oPgojaW5jbHVkZSA8YXNzZXJ0Lmg+CiNpbmNsdWRlIDx1bmlzdGQuaD4KI2luY2x1ZGUgPGVycm5vLmg+CiNpbmNsdWRlIDxmY250bC5oPgojaW5jbHVkZSA8dGltZS5oPgojaW5jbHVkZSA8c2lnbmFsLmg+CiNpbmNsdWRlIDxzeXMvcG9sbC5oPgojaWYgZGVmaW5lZChfX0FQUExFX18pCiNpbmNsdWRlIDxtYWxsb2MvbWFsbG9jLmg+CiNlbGlmIGRlZmluZWQoX19saW51eF9fKQojaW5jbHVkZSA8bWFsbG9jLmg+CiNlbmRpZgojaWZuZGVmIF9fd2FzaV9fCiNpbmNsdWRlIDxkbGZjbi5oPgojZW5kaWYKCiNpZiAxIC8vIGRlZiBIQVZFX1FVSUNLSlNfQ09ORklHX0gKI2luY2x1ZGUgInF1aWNranMtY29uZmlnLmgiCiNlbmRpZgoKI2lmZGVmIFVTRV9XT1JLRVIKI2luY2x1ZGUgPHB0aHJlYWQuaD4KI2luY2x1ZGUgPHN0ZGF0b21pYy5oPgoKc3RhdGljIGludAphdG9taWNfYWRkX2ludChpbnQqIHB0ciwgaW50IHYpIHsKICByZXR1cm4gYXRvbWljX2ZldGNoX2FkZCgoX0F0b21pYyh1aW50MzJfdCkqKXB0ciwgdikgKyB2Owp9CiNlbmRpZgoKI2luY2x1ZGUgImxpc3QuaCIKI2luY2x1ZGUgImN1dGlscy5oIgojaW5jbHVkZSAidXRpbHMuaCIKI2luY2x1ZGUgInZlY3Rvci5oIgojaW5jbHVkZSAicXVpY2tqcy1saWJjLmgiCiNpbmNsdWRlICJxdWlja2pzLWludGVybmFsLmgiCiNpbmNsdWRlICJidWZmZXItdXRpbHMuaCIKCnR5cGVkZWYgc3RydWN0IHBvbGxoYW5kbGVyIHsKICBzdHJ1Y3QgcG9sbGZkIHBmOwogIHZvaWQgKCpoYW5kbGVyKSh2b2lkKiBvcGFxdWUsIHN0cnVjdCBwb2xsZmQqKTsKICB2b2lkKiBvcGFxdWU7CiAgc3RydWN0IGxpc3RfaGVhZCBsaW5rOwp9IHBvbGxoYW5kbGVyX3Q7Cgp0aHJlYWRfbG9jYWwgdWludDY0X3QganNtX3BlbmRpbmdfc2lnbmFscyA9IDA7CnN0cnVjdCBsaXN0X2hlYWQgcG9sbGhhbmRsZXJzOwoKdm9pZCBqc19zdGRfc2V0X21vZHVsZV9sb2FkZXJfZnVuYyhKU01vZHVsZUxvYWRlckZ1bmMqIGZ1bmMpOwoKI2lmZGVmIEhBVkVfTUFMTE9DX1VTQUJMRV9TSVpFCiNpZm5kZWYgSEFWRV9NQUxMT0NfVVNBQkxFX1NJWkVfREVGSU5JVElPTgpleHRlcm4gc2l6ZV90IG1hbGxvY191c2FibGVfc2l6ZSgpOwojZW5kaWYKI2VuZGlmCgojZGVmaW5lIHRyaW1fZG90c2xhc2goc3RyKSAoIXN0cm5jbXAoKHN0ciksICIuLyIsIDIpID8gKHN0cikgKyAyIDogKHN0cikpCgojZGVmaW5lIGpzbV9kZWNsYXJlX21vZHVsZShuYW1lKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICBleHRlcm4gY29uc3QgdWludDhfdCBxanNjXyMjbmFtZVtdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgZXh0ZXJuIGNvbnN0IHVpbnQzMl90IHFqc2NfIyNuYW1lIyNfc2l6ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIEpTTW9kdWxlRGVmKiBqc19pbml0X21vZHVsZV8jI25hbWUoSlNDb250ZXh0KiwgY29uc3QgY2hhciopOwoKanNtX2RlY2xhcmVfbW9kdWxlKGNvbnNvbGUpOwpqc21fZGVjbGFyZV9tb2R1bGUoZXZlbnRzKTsKanNtX2RlY2xhcmVfbW9kdWxlKGZzKTsKanNtX2RlY2xhcmVfbW9kdWxlKHBlcmZfaG9va3MpOwpqc21fZGVjbGFyZV9tb2R1bGUocHJvY2Vzcyk7CmpzbV9kZWNsYXJlX21vZHVsZShyZXBsKTsKanNtX2RlY2xhcmVfbW9kdWxlKHJlcXVpcmUpOwpqc21fZGVjbGFyZV9tb2R1bGUodHR5KTsKanNtX2RlY2xhcmVfbW9kdWxlKHV0aWwpOwoKI2lmZGVmIENPTkZJR19CSUdOVU0KanNtX2RlY2xhcmVfbW9kdWxlKHFqc2NhbGMpOwpzdGF0aWMgaW50IGJpZ251bV9leHQgPSAxOwojZW5kaWYKCnZvaWQganNfc3RkX3NldF93b3JrZXJfbmV3X2NvbnRleHRfZnVuYyhKU0NvbnRleHQqICgqZnVuYykoSlNSdW50aW1lKiBydCkpOwoKc3RhdGljIHZvaWQKanNtX2R1bXBfZXJyb3IoSlNDb250ZXh0KiBjdHgpIHsKICAvKkpTUnVudGltZSogcnQgPSBKU19HZXRSdW50aW1lKGN0eCk7CiAgSlNWYWx1ZSBlcnJvciA9IHJ0LT5jdXJyZW50X2V4Y2VwdGlvbjsqLwogIC8qcHJpbnRmKCJxanNtOiBjdXJyZW50X2V4Y2VwdGlvbiAweCUwOHhcbiIsIG9mZnNldG9mKEpTUnVudGltZSwgY3VycmVudF9leGNlcHRpb24pKTsKICBwcmludGYoInFqc206IHNpemVvZihzdHJ1Y3QgbGlzdF9oZWFkKSAweCUwOHhcbiIsIHNpemVvZihzdHJ1Y3QgbGlzdF9oZWFkKSk7Ki8KCiAganNfZXJyb3JfcHJpbnQoY3R4LCBKU19HZXRFeGNlcHRpb24oY3R4KSk7Cn0KCnN0YXRpYyBpbnQgZGVidWdfbW9kdWxlX2xvYWRlciA9IDA7CnN0YXRpYyBWZWN0b3IgbW9kdWxlX2RlYnVnID0gVkVDVE9SX0lOSVQoKTsKc3RhdGljIFZlY3RvciBtb2R1bGVfbGlzdCA9IFZFQ1RPUl9JTklUKCk7CnN0YXRpYyBWZWN0b3IgYnVpbHRpbnMgPSBWRUNUT1JfSU5JVCgpOwoKc3RhdGljIGNvbnN0IGNoYXIganNtX2RlZmF1bHRfbW9kdWxlX3BhdGhbXSA9ICIuIgojaWZkZWYgUVVJQ0tKU19NT0RVTEVfUEFUSAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjoiIFFVSUNLSlNfTU9EVUxFX1BBVEgKI2VsaWYgZGVmaW5lZChDT05GSUdfUFJFRklYKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjoiIENPTkZJR19QUkVGSVggIi9saWIvcXVpY2tqcyIKI2VuZGlmCiAgICA7CgpKU1ZhbHVlIHBhY2thZ2VfanNvbjsKCnN0YXRpYyBKU1ZhbHVlCmV2YWxfYnVmKEpTQ29udGV4dCogY3R4LCBjb25zdCB2b2lkKiBidWYsIGludCBidWZfbGVuLCBjb25zdCBjaGFyKiBmaWxlbmFtZSwgaW50IGV2YWxfZmxhZ3MpIHsKICBKU1ZhbHVlIHZhbDsKCiAgaWYoKGV2YWxfZmxhZ3MgJiBKU19FVkFMX1RZUEVfTUFTSykgPT0gSlNfRVZBTF9UWVBFX01PRFVMRSkgewogICAgLyogZm9yIHRoZSBtb2R1bGVzLCB3ZSBjb21waWxlIHRoZW4gcnVuIHRvIGJlIGFibGUgdG8gc2V0IGltcG9ydC5tZXRhICovCiAgICB2YWwgPSBKU19FdmFsKGN0eCwgYnVmLCBidWZfbGVuLCBmaWxlbmFtZSwgZXZhbF9mbGFncyB8IEpTX0VWQUxfRkxBR19DT01QSUxFX09OTFkpOwogICAgaWYoIUpTX0lzRXhjZXB0aW9uKHZhbCkpIHsKICAgICAganNfbW9kdWxlX3NldF9pbXBvcnRfbWV0YShjdHgsIHZhbCwgVFJVRSwgVFJVRSk7CiAgICAgIEpTX0V2YWxGdW5jdGlvbihjdHgsIHZhbCk7CiAgICB9CiAgfSBlbHNlIHsKICAgIHZhbCA9IEpTX0V2YWwoY3R4LCBidWYsIGJ1Zl9sZW4sIGZpbGVuYW1lLCBldmFsX2ZsYWdzKTsKICB9CiAgaWYoSlNfSXNFeGNlcHRpb24odmFsKSkKICAgIGpzX2Vycm9yX3ByaW50KGN0eCwgSlNfR2V0UnVudGltZShjdHgpLT5jdXJyZW50X2V4Y2VwdGlvbik7CgogIGpzbV9kdW1wX2Vycm9yKGN0eCk7CiAgcmV0dXJuIHZhbDsKfQoKc3RhdGljIEpTVmFsdWUKanNtX2xvYWRfcGFja2FnZShKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogZmlsZSkgewogIGlmKEpTX0lzVW5kZWZpbmVkKHBhY2thZ2VfanNvbikpIHsKICAgIHVpbnQ4X3QqIGJ1ZjsKICAgIHNpemVfdCBsZW47CiAgICBpZihmaWxlID09IDApCiAgICAgIGZpbGUgPSAicGFja2FnZS5qc29uIjsKICAgIGlmKCEoYnVmID0ganNfbG9hZF9maWxlKGN0eCwgJmxlbiwgZmlsZSkpKQogICAgICBwYWNrYWdlX2pzb24gPSBKU19OVUxMOwogICAgZWxzZQogICAgICBwYWNrYWdlX2pzb24gPSBKU19QYXJzZUpTT04oY3R4LCBidWYsIGxlbiwgZmlsZSk7CiAgfQogIHJldHVybiBKU19EdXBWYWx1ZShjdHgsIHBhY2thZ2VfanNvbik7Cn0KCkpTTW9kdWxlRGVmKgpqc21fbW9kdWxlX2xvYWRlcihKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogbmFtZSwgdm9pZCogb3BhcXVlKSB7CiAgY2hhciAqbW9kdWxlLCAqZmlsZSA9IDA7CiAgSlNNb2R1bGVEZWYqIHJldCA9IDA7CiAgbW9kdWxlID0ganNfc3RyZHVwKGN0eCwgdHJpbV9kb3RzbGFzaChuYW1lKSk7CiAgZm9yKDs7KSB7CiAgICBpZihkZWJ1Z19tb2R1bGVfbG9hZGVyID4gMSkgewogICAgICBpZihmaWxlKQogICAgICAgIHByaW50ZigiXHgxYls0ODs1OzIxNG0oMSlceDFiWzBtICUtMzBzICclcydcbiIsIG5hbWUsIGZpbGUpOwogICAgICAvKiAgZWxzZSAgcHJpbnRmKCJqc21fbW9kdWxlX2xvYWRlclsleF0gXHgxYls0ODs1OzEyNG0oMSlceDFiWzBtICUtMjBzIC0+CiAgICAgICAqICVzXG4iLCBwdGhyZWFkX3NlbGYoKSwgdHJpbV9kb3RzbGFzaChuYW1lKSwgdHJpbV9kb3RzbGFzaChtb2R1bGUpKTsqLwogICAgfQogICAgaWYoIXN0cmNocihtb2R1bGUsICcvJykgJiYgKHJldCA9IGpzX21vZHVsZV9maW5kKGN0eCwgbW9kdWxlKSkpCiAgICAgIGdvdG8gZW5kOwoKICAgIGlmKCFoYXNfc3VmZml4KG5hbWUsICIuc28iKSAmJiAhZmlsZSkgewogICAgICBKU1ZhbHVlIHBhY2thZ2UgPSBqc21fbG9hZF9wYWNrYWdlKGN0eCwgMCk7CiAgICAgIGlmKCFKU19Jc051bGwocGFja2FnZSkpIHsKICAgICAgICBKU1ZhbHVlIGFsaWFzZXMgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIHBhY2thZ2UsICJfbW9kdWxlQWxpYXNlcyIpOwogICAgICAgIEpTVmFsdWUgdGFyZ2V0ID0gSlNfVU5ERUZJTkVEOwogICAgICAgIGlmKCFKU19Jc1VuZGVmaW5lZChhbGlhc2VzKSkgewogICAgICAgICAgdGFyZ2V0ID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBhbGlhc2VzLCBtb2R1bGUpOwogICAgICAgIH0KICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBhbGlhc2VzKTsKICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBwYWNrYWdlKTsKICAgICAgICBpZighSlNfSXNVbmRlZmluZWQodGFyZ2V0KSkgewogICAgICAgICAgY29uc3QgY2hhciogc3RyID0gSlNfVG9DU3RyaW5nKGN0eCwgdGFyZ2V0KTsKICAgICAgICAgIGlmKHN0cikgewogICAgICAgICAgICBpZihkZWJ1Z19tb2R1bGVfbG9hZGVyKQogICAgICAgICAgICAgIHByaW50ZigiXHgxYls0ODs1OzI4bSgyKVx4MWJbMG0gJS0zMHMgPT4gJXNcbiIsIG1vZHVsZSwgc3RyKTsKCiAgICAgICAgICAgIGpzX2ZyZWUoY3R4LCBtb2R1bGUpOwoKICAgICAgICAgICAgbW9kdWxlID0ganNfc3RyZHVwKGN0eCwgc3RyKTsKICAgICAgICAgICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBzdHIpOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGlmKCFmaWxlKSB7CiAgICAgIGlmKHN0cmNocigiLi8iLCBtb2R1bGVbMF0pKQogICAgICAgIGZpbGUgPSBqc19zdHJkdXAoY3R4LCBtb2R1bGUpOwogICAgICBlbHNlIGlmKCEoZmlsZSA9IGpzX21vZHVsZV9zZWFyY2goY3R4LCBqc21fZGVmYXVsdF9tb2R1bGVfcGF0aCwgbW9kdWxlKSkpCiAgICAgICAgYnJlYWs7CiAgICAgIGNvbnRpbnVlOwogICAgfQogICAgYnJlYWs7CiAgfQogIGlmKGZpbGUpIHsKICAgIGlmKGRlYnVnX21vZHVsZV9sb2FkZXIpCiAgICAgIGlmKHN0cmNtcCh0cmltX2RvdHNsYXNoKG1vZHVsZSksIHRyaW1fZG90c2xhc2goZmlsZSkpKQogICAgICAgIHByaW50ZigiXHgxYls0ODs1OzIxbSgzKVx4MWJbMG0gJS0zMHMgLT4gJXNcbiIsIG1vZHVsZSwgZmlsZSk7CgogICAgcmV0ID0ganNfbW9kdWxlX2xvYWRlcihjdHgsIGZpbGUsIG9wYXF1ZSk7CiAgfQplbmQ6CiAgaWYodmVjdG9yX2ZpbmRzKCZtb2R1bGVfZGVidWcsICJpbXBvcnQiKSAhPSAtMSkgewogICAgZnByaW50ZihzdGRlcnIsICghZmlsZSB8fCBzdHJjbXAobW9kdWxlLCBmaWxlKSkgPyAiISEhIElNUE9SVCAlcyAtPiAlc1xuIiA6ICIhISEgSU1QT1JUICVzXG4iLCBtb2R1bGUsIGZpbGUpOwogIH0KICBpZighcmV0KQogICAgcHJpbnRmKCJqc21fbW9kdWxlX2xvYWRlcihcIiVzXCIpID0gJXBcbiIsIG5hbWUsIHJldCk7CiAgaWYobW9kdWxlKQogICAganNfZnJlZShjdHgsIG1vZHVsZSk7CiAgaWYoZmlsZSkKICAgIGpzX2ZyZWUoY3R4LCBmaWxlKTsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgSlNWYWx1ZQpqc21fZXZhbF9maWxlKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBmaWxlLCBpbnQgbW9kdWxlKSB7CiAgdWludDhfdCogYnVmOwogIHNpemVfdCBsZW47CiAgaW50IGZsYWdzOwoKICBidWYgPSBqc19sb2FkX2ZpbGUoY3R4LCAmbGVuLCBmaWxlKTsKICBpZighYnVmKSB7CiAgICByZXR1cm4gSlNfVGhyb3dJbnRlcm5hbEVycm9yKGN0eCwgIkZhaWxlZCBsb2FkaW5nICclcyc6ICVzIiwgZmlsZSwgc3RyZXJyb3IoZXJybm8pKTsKICB9CgogIGlmKG1vZHVsZSA8IDApCiAgICBtb2R1bGUgPSAoaGFzX3N1ZmZpeChmaWxlLCAiLm1qcyIpIHx8IEpTX0RldGVjdE1vZHVsZSgoY29uc3QgY2hhciopYnVmLCBsZW4pKTsKICBmbGFncyA9IG1vZHVsZSA/IEpTX0VWQUxfVFlQRV9NT0RVTEUgOiBKU19FVkFMX1RZUEVfR0xPQkFMOwogIHJldHVybiBldmFsX2J1ZihjdHgsIGJ1ZiwgbGVuLCBmaWxlLCBmbGFncyk7Cn0KCnN0YXRpYyBpbnQKanNtX2xvYWRfc2NyaXB0KEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBmaWxlLCBCT09MIG1vZHVsZSkgewogIEpTVmFsdWUgdmFsOwogIGludDMyX3QgcmV0ID0gMDsKICB2YWwgPSBqc21fZXZhbF9maWxlKGN0eCwgZmlsZSwgbW9kdWxlKTsKICBpZihKU19Jc0V4Y2VwdGlvbih2YWwpKSB7CiAgICBmcHJpbnRmKHN0ZGVyciwgIkZhaWxlZCBsb2FkaW5nICclcyc6ICVzXG4iLCBmaWxlLCBzdHJlcnJvcihlcnJubykpOwogICAganNfdmFsdWVfZndyaXRlKGN0eCwgdmFsLCBzdGRlcnIpOwogICAgcmV0dXJuIC0xOwogIH0gZWxzZSBpZihKU19Jc01vZHVsZSh2YWwpKSB7CiAgICBKU1ZhbHVlIGdsb2JhbCA9IEpTX0dldEdsb2JhbE9iamVjdChjdHgpOwogICAgZ2V0X21vZHVsZV9leHBvcnRzKGN0eCwgSlNfVkFMVUVfR0VUX1BUUih2YWwpLCBUUlVFLCBnbG9iYWwpOwogIH0gZWxzZSB7CiAgICBKU19Ub0ludDMyKGN0eCwgJnJldCwgdmFsKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbCk7CiAgfQogIHJldHVybiByZXQ7Cn0KCi8qIGFsc28gdXNlZCB0byBpbml0aWFsaXplIHRoZSB3b3JrZXIgY29udGV4dCAqLwpzdGF0aWMgSlNDb250ZXh0Kgpqc21fY29udGV4dF9uZXcoSlNSdW50aW1lKiBydCkgewogIEpTQ29udGV4dCogY3R4OwogIGN0eCA9IEpTX05ld0NvbnRleHQocnQpOwogIGlmKCFjdHgpCiAgICByZXR1cm4gMDsKI2lmZGVmIENPTkZJR19CSUdOVU0KICBpZihiaWdudW1fZXh0KSB7CiAgICBKU19BZGRJbnRyaW5zaWNCaWdGbG9hdChjdHgpOwogICAgSlNfQWRkSW50cmluc2ljQmlnRGVjaW1hbChjdHgpOwogICAgSlNfQWRkSW50cmluc2ljT3BlcmF0b3JzKGN0eCk7CiAgICBKU19FbmFibGVCaWdudW1FeHQoY3R4LCBUUlVFKTsKICB9CiNlbmRpZgoKI2RlZmluZSBqc21fbW9kdWxlX25hdGl2ZShuYW1lKSBqc19pbml0X21vZHVsZV8jI25hbWUoY3R4LCAjbmFtZSk7CgogIGpzbV9tb2R1bGVfbmF0aXZlKHN0ZCk7CiAganNtX21vZHVsZV9uYXRpdmUob3MpOwojaWZuZGVmIF9fd2FzaV9fCiAganNtX21vZHVsZV9uYXRpdmUoY2hpbGRfcHJvY2Vzcyk7CiNlbmRpZgogIGpzbV9tb2R1bGVfbmF0aXZlKGRlZXApOwogIGpzbV9tb2R1bGVfbmF0aXZlKGluc3BlY3QpOwogIGpzbV9tb2R1bGVfbmF0aXZlKGxleGVyKTsKICBqc21fbW9kdWxlX25hdGl2ZShtaXNjKTsKI2lmbmRlZiBfX3dhc2lfXwogIGpzbV9tb2R1bGVfbmF0aXZlKG1tYXApOwojZW5kaWYKICBqc21fbW9kdWxlX25hdGl2ZShwYXRoKTsKICBqc21fbW9kdWxlX25hdGl2ZShwb2ludGVyKTsKICBqc21fbW9kdWxlX25hdGl2ZShwcmVkaWNhdGUpOwogIGpzbV9tb2R1bGVfbmF0aXZlKHJlcGVhdGVyKTsKICBqc21fbW9kdWxlX25hdGl2ZSh0cmVlX3dhbGtlcik7CiAganNtX21vZHVsZV9uYXRpdmUoeG1sKTsKICByZXR1cm4gY3R4Owp9CgojaWYgZGVmaW5lZChfX0FQUExFX18pCiNkZWZpbmUgTUFMTE9DX09WRVJIRUFEIDAKI2Vsc2UKI2RlZmluZSBNQUxMT0NfT1ZFUkhFQUQgOAojZW5kaWYKCnN0cnVjdCB0cmFjZV9tYWxsb2NfZGF0YSB7CiAgdWludDhfdCogYmFzZTsKfTsKCnN0YXRpYyB2b2lkCmR1bXBfdmVjdG9yKGNvbnN0IFZlY3RvciogdmVjLCBzaXplX3Qgc3RhcnQpIHsKICBzaXplX3QgaSwgbGVuID0gdmVjdG9yX3NpemUodmVjLCBzaXplb2YoY2hhciopKTsKICBmb3IoaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHsKICAgIGNvbnN0IGNoYXIqIHN0ciA9ICooY2hhcioqKXZlY3Rvcl9hdCh2ZWMsIHNpemVvZihjaGFyKiksIGkpOwogICAgZnB1dHMoaSA+IHN0YXJ0ID8gIicsXG4gICciIDogIltcbiAgJyIsIHN0ZG91dCk7CiAgICBmcHV0cyhzdHIsIHN0ZG91dCk7CiAgICBpZihpICsgMSA9PSBsZW4pCiAgICAgIHB1dHMoIidcbl0iKTsKICB9Cn0KCnN0YXRpYyBpbmxpbmUgdW5zaWduZWQgbG9uZyBsb25nCmpzbV90cmFjZV9tYWxsb2NfcHRyX29mZnNldCh1aW50OF90KiBwdHIsIHN0cnVjdCB0cmFjZV9tYWxsb2NfZGF0YSogZHApIHsKICByZXR1cm4gcHRyIC0gZHAtPmJhc2U7Cn0KCi8qIGRlZmF1bHQgbWVtb3J5IGFsbG9jYXRpb24gZnVuY3Rpb25zIHdpdGggbWVtb3J5IGxpbWl0YXRpb24gKi8Kc3RhdGljIGlubGluZSBzaXplX3QKanNtX3RyYWNlX21hbGxvY191c2FibGVfc2l6ZSh2b2lkKiBwdHIpIHsKI2lmIGRlZmluZWQoX19BUFBMRV9fKQogIHJldHVybiBtYWxsb2Nfc2l6ZShwdHIpOwojZWxpZiBkZWZpbmVkKF9XSU4zMikKICByZXR1cm4gX21zaXplKHB0cik7CiNlbGlmIGRlZmluZWQoRU1TQ1JJUFRFTikgfHwgZGVmaW5lZChfX2RpZXRsaWJjX18pIHx8IGRlZmluZWQoX19NU1lTX18pIHx8IGRlZmluZWQoRE9OVF9IQVZFX01BTExPQ19VU0FCTEVfU0laRSkKICByZXR1cm4gMDsKI2VsaWYgZGVmaW5lZChfX2xpbnV4X18pIHx8IGRlZmluZWQoSEFWRV9NQUxMT0NfVVNBQkxFX1NJWkUpCiAgcmV0dXJuIG1hbGxvY191c2FibGVfc2l6ZShwdHIpOwojZWxzZQogIC8qIGNoYW5nZSB0aGlzIHRvIGByZXR1cm4gMDtgIGlmIGNvbXBpbGF0aW9uIGZhaWxzICovCiAgcmV0dXJuIG1hbGxvY191c2FibGVfc2l6ZShwdHIpOwojZW5kaWYKfQoKc3RhdGljIHZvaWQKI2lmZGVmIF9XSU4zMgogICAgLyogbWluZ3cgcHJpbnRmIGlzIHVzZWQgKi8KICAgIF9fYXR0cmlidXRlX18oKGZvcm1hdChnbnVfcHJpbnRmLCAyLCAzKSkpCiNlbHNlCiAgICBfX2F0dHJpYnV0ZV9fKChmb3JtYXQocHJpbnRmLCAyLCAzKSkpCiNlbmRpZgogICAganNtX3RyYWNlX21hbGxvY19wcmludGYoSlNNYWxsb2NTdGF0ZSogcywgY29uc3QgY2hhciogZm10LCAuLi4pIHsKICB2YV9saXN0IGFwOwogIGludCBjOwoKICB2YV9zdGFydChhcCwgZm10KTsKICB3aGlsZSgoYyA9ICpmbXQrKykgIT0gJ1wwJykgewogICAgaWYoYyA9PSAnJScpIHsKICAgICAgLyogb25seSBoYW5kbGUgJXAgYW5kICV6ZCAqLwogICAgICBpZigqZm10ID09ICdwJykgewogICAgICAgIHVpbnQ4X3QqIHB0ciA9IHZhX2FyZyhhcCwgdm9pZCopOwogICAgICAgIGlmKHB0ciA9PSAwKSB7CiAgICAgICAgICBwcmludGYoIjAiKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcHJpbnRmKCJIJSswNmxsZC4lemQiLCBqc21fdHJhY2VfbWFsbG9jX3B0cl9vZmZzZXQocHRyLCBzLT5vcGFxdWUpLCBqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplKHB0cikpOwogICAgICAgIH0KICAgICAgICBmbXQrKzsKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICBpZihmbXRbMF0gPT0gJ3onICYmIGZtdFsxXSA9PSAnZCcpIHsKICAgICAgICBzaXplX3Qgc3ogPSB2YV9hcmcoYXAsIHNpemVfdCk7CiAgICAgICAgcHJpbnRmKCIlemQiLCBzeik7CiAgICAgICAgZm10ICs9IDI7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KICAgIH0KICAgIHB1dGMoYywgc3Rkb3V0KTsKICB9CiAgdmFfZW5kKGFwKTsKfQoKc3RhdGljIHZvaWQKanNtX3RyYWNlX21hbGxvY19pbml0KHN0cnVjdCB0cmFjZV9tYWxsb2NfZGF0YSogcykgewogIGZyZWUocy0+YmFzZSA9IG1hbGxvYyg4KSk7Cn0KCnN0YXRpYyB2b2lkKgpqc21fdHJhY2VfbWFsbG9jKEpTTWFsbG9jU3RhdGUqIHMsIHNpemVfdCBzaXplKSB7CiAgdm9pZCogcHRyOwoKICAvKiBEbyBub3QgYWxsb2NhdGUgemVybyBieXRlczogYmVoYXZpb3IgaXMgcGxhdGZvcm0gZGVwZW5kZW50ICovCiAgYXNzZXJ0KHNpemUgIT0gMCk7CgogIGlmKHVubGlrZWx5KHMtPm1hbGxvY19zaXplICsgc2l6ZSA+IHMtPm1hbGxvY19saW1pdCkpCiAgICByZXR1cm4gMDsKICBwdHIgPSBtYWxsb2Moc2l6ZSk7CiAganNtX3RyYWNlX21hbGxvY19wcmludGYocywgIkEgJXpkIC0+ICVwXG4iLCBzaXplLCBwdHIpOwogIGlmKHB0cikgewogICAgcy0+bWFsbG9jX2NvdW50Kys7CiAgICBzLT5tYWxsb2Nfc2l6ZSArPSBqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplKHB0cikgKyBNQUxMT0NfT1ZFUkhFQUQ7CiAgfQogIHJldHVybiBwdHI7Cn0KCnN0YXRpYyB2b2lkCmpzbV90cmFjZV9mcmVlKEpTTWFsbG9jU3RhdGUqIHMsIHZvaWQqIHB0cikgewogIGlmKCFwdHIpCiAgICByZXR1cm47CgogIGpzbV90cmFjZV9tYWxsb2NfcHJpbnRmKHMsICJGICVwXG4iLCBwdHIpOwogIHMtPm1hbGxvY19jb3VudC0tOwogIHMtPm1hbGxvY19zaXplIC09IGpzbV90cmFjZV9tYWxsb2NfdXNhYmxlX3NpemUocHRyKSArIE1BTExPQ19PVkVSSEVBRDsKICBmcmVlKHB0cik7Cn0KCnN0YXRpYyB2b2lkKgpqc21fdHJhY2VfcmVhbGxvYyhKU01hbGxvY1N0YXRlKiBzLCB2b2lkKiBwdHIsIHNpemVfdCBzaXplKSB7CiAgc2l6ZV90IG9sZF9zaXplOwoKICBpZighcHRyKSB7CiAgICBpZihzaXplID09IDApCiAgICAgIHJldHVybiAwOwogICAgcmV0dXJuIGpzbV90cmFjZV9tYWxsb2Mocywgc2l6ZSk7CiAgfQogIG9sZF9zaXplID0ganNtX3RyYWNlX21hbGxvY191c2FibGVfc2l6ZShwdHIpOwogIGlmKHNpemUgPT0gMCkgewogICAganNtX3RyYWNlX21hbGxvY19wcmludGYocywgIlIgJXpkICVwXG4iLCBzaXplLCBwdHIpOwogICAgcy0+bWFsbG9jX2NvdW50LS07CiAgICBzLT5tYWxsb2Nfc2l6ZSAtPSBvbGRfc2l6ZSArIE1BTExPQ19PVkVSSEVBRDsKICAgIGZyZWUocHRyKTsKICAgIHJldHVybiAwOwogIH0KICBpZihzLT5tYWxsb2Nfc2l6ZSArIHNpemUgLSBvbGRfc2l6ZSA+IHMtPm1hbGxvY19saW1pdCkKICAgIHJldHVybiAwOwoKICBqc21fdHJhY2VfbWFsbG9jX3ByaW50ZihzLCAiUiAlemQgJXAiLCBzaXplLCBwdHIpOwoKICBwdHIgPSByZWFsbG9jKHB0ciwgc2l6ZSk7CiAganNtX3RyYWNlX21hbGxvY19wcmludGYocywgIiAtPiAlcFxuIiwgcHRyKTsKICBpZihwdHIpIHsKICAgIHMtPm1hbGxvY19zaXplICs9IGpzbV90cmFjZV9tYWxsb2NfdXNhYmxlX3NpemUocHRyKSAtIG9sZF9zaXplOwogIH0KICByZXR1cm4gcHRyOwp9CgpzdGF0aWMgY29uc3QgSlNNYWxsb2NGdW5jdGlvbnMgdHJhY2VfbWYgPSB7CiAgICBqc21fdHJhY2VfbWFsbG9jLAogICAganNtX3RyYWNlX2ZyZWUsCiAgICBqc21fdHJhY2VfcmVhbGxvYywKI2lmIGRlZmluZWQoX19BUFBMRV9fKQogICAgbWFsbG9jX3NpemUsCiNlbGlmIGRlZmluZWQoX1dJTjMyKQogICAgKHNpemVfdCgqKShjb25zdCB2b2lkKikpX21zaXplLAojZWxpZiBkZWZpbmVkKEVNU0NSSVBURU4pIHx8IGRlZmluZWQoX19kaWV0bGliY19fKSB8fCBkZWZpbmVkKF9fTVNZU19fKSB8fCBkZWZpbmVkKERPTlRfSEFWRV9NQUxMT0NfVVNBQkxFX1NJWkVfREVGSU5JVElPTikKICAgIDAsCiNlbGlmIGRlZmluZWQoX19saW51eF9fKSB8fCBkZWZpbmVkKEhBVkVfTUFMTE9DX1VTQUJMRV9TSVpFKQogICAgKHNpemVfdCgqKShjb25zdCB2b2lkKikpbWFsbG9jX3VzYWJsZV9zaXplLAojZWxzZQogICAgLyogY2hhbmdlIHRoaXMgdG8gYDAsYCBpZiBjb21waWxhdGlvbiBmYWlscyAqLwogICAgbWFsbG9jX3VzYWJsZV9zaXplLAojZW5kaWYKfTsKCiNkZWZpbmUgUFJPR19OQU1FICJxanNtIgoKdm9pZApqc21faGVscCh2b2lkKSB7CiAgcHJpbnRmKCJRdWlja0pTIHZlcnNpb24gIiBDT05GSUdfVkVSU0lPTiAiXG4iCiAgICAgICAgICJ1c2FnZTogIiBQUk9HX05BTUUgIiBbb3B0aW9uc10gW2ZpbGUgW2FyZ3NdXVxuIgogICAgICAgICAiLWggIC0taGVscCAgICAgICAgIGxpc3Qgb3B0aW9uc1xuIgogICAgICAgICAiLWUgIC0tZXZhbCBFWFBSICAgIGV2YWx1YXRlIEVYUFJcbiIKICAgICAgICAgIi1pICAtLWludGVyYWN0aXZlICBnbyB0byBpbnRlcmFjdGl2ZSBtb2RlXG4iCiAgICAgICAgICItbSAgLS1tb2R1bGUgTkFNRSAgbG9hZCBhbiBFUzYgbW9kdWxlXG4iCiAgICAgICAgICItSSAgLS1pbmNsdWRlIGZpbGUgaW5jbHVkZSBhbiBhZGRpdGlvbmFsIGZpbGVcbiIKICAgICAgICAgIiAgICAtLXN0ZCAgICAgICAgICBtYWtlICdzdGQnIGFuZCAnb3MnIGF2YWlsYWJsZSB0byB0aGUgbG9hZGVkIHNjcmlwdFxuIgojaWZkZWYgQ09ORklHX0JJR05VTQogICAgICAgICAiICAgIC0tbm8tYmlnbnVtICAgIGRpc2FibGUgdGhlIGJpZ251bSBleHRlbnNpb25zIChCaWdGbG9hdCwgIgogICAgICAgICAiQmlnRGVjaW1hbClcbiIKICAgICAgICAgIiAgICAtLXFqc2NhbGMgICAgICBsb2FkIHRoZSBRSlNDYWxjIHJ1bnRpbWUgKGRlZmF1bHQgaWYgaW52b2tlZCBhcyAiCiAgICAgICAgICJxanNjYWxjKVxuIgojZW5kaWYKICAgICAgICAgIi1UICAtLXRyYWNlICAgICAgICB0cmFjZSBtZW1vcnkgYWxsb2NhdGlvblxuIgogICAgICAgICAiLWQgIC0tZHVtcCAgICAgICAgIGR1bXAgdGhlIG1lbW9yeSB1c2FnZSBzdGF0c1xuIgogICAgICAgICAiICAgIC0tbWVtb3J5LWxpbWl0IG4gICAgICAgbGltaXQgdGhlIG1lbW9yeSB1c2FnZSB0byAnbicgYnl0ZXNcbiIKICAgICAgICAgIiAgICAtLXN0YWNrLXNpemUgbiAgICAgICAgIGxpbWl0IHRoZSBzdGFjayBzaXplIHRvICduJyBieXRlc1xuIgogICAgICAgICAiICAgIC0tdW5oYW5kbGVkLXJlamVjdGlvbiAgZHVtcCB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25zXG4iCiAgICAgICAgICItcSAgLS1xdWl0ICAgICAgICAganVzdCBpbnN0YW50aWF0ZSB0aGUgaW50ZXJwcmV0ZXIgYW5kIHF1aXRcbiIpOwogIGV4aXQoMSk7Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzbV9ldmFsX3NjcmlwdChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSwgaW50IG1hZ2ljKSB7CiAgY29uc3QgY2hhciogc3RyOwogIHNpemVfdCBsZW47CiAgSlNWYWx1ZSByZXQ7CiAgaW50MzJfdCBtb2R1bGU7CiAgc3RyID0gSlNfVG9DU3RyaW5nTGVuKGN0eCwgJmxlbiwgYXJndlswXSk7CiAgaWYoYXJnYyA+IDEpCiAgICBKU19Ub0ludDMyKGN0eCwgJm1vZHVsZSwgYXJndlsxXSk7CiAgZWxzZQogICAgbW9kdWxlID0gc3RyX2VuZHMoc3RyLCAiLm1qcyIpOwogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSAwOiB7CiAgICAgIHJldCA9IGpzbV9ldmFsX2ZpbGUoY3R4LCBzdHIsIG1vZHVsZSk7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSAxOiB7CiAgICAgIHJldCA9IGV2YWxfYnVmKGN0eCwgc3RyLCBsZW4sIDAsIG1vZHVsZSk7CiAgICAgIGJyZWFrOwogICAgfQogIH0KICBpZihKU19Jc0V4Y2VwdGlvbihyZXQpKSB7CiAgICBpZihKU19Jc051bGwoSlNfR2V0UnVudGltZShjdHgpLT5jdXJyZW50X2V4Y2VwdGlvbikpIHsKICAgICAgcmV0ID0gSlNfR2V0RXhjZXB0aW9uKGN0eCk7CiAgICAgIC8vIHJldCA9IEpTX1VOREVGSU5FRDsKICAgIH0KICB9CiAgaWYoSlNfVkFMVUVfR0VUX1RBRyhyZXQpID09IEpTX1RBR19NT0RVTEUpIHsKICAgIEpTTW9kdWxlRGVmKiBkZWYgPSBKU19WQUxVRV9HRVRfUFRSKHJldCk7CiAgICBKU1ZhbHVlIG9iaiA9IEpTX05ld09iamVjdChjdHgpOwogICAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCBvYmosICJuYW1lIiwgbW9kdWxlX25hbWUoY3R4LCBkZWYpKTsKICAgIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgb2JqLCAiZXhwb3J0cyIsIG1vZHVsZV9leHBvcnRzKGN0eCwgZGVmKSk7CiAgICByZXQgPSBvYmo7CiAgfQogIEpTX0ZyZWVDU3RyaW5nKGN0eCwgc3RyKTsKICByZXR1cm4gcmV0Owp9CgplbnVtIHsKICBGSU5EX01PRFVMRSwKICBMT0FEX01PRFVMRSwKICBSRVNPTFZFX01PRFVMRSwKICBHRVRfTU9EVUxFX05BTUUsCiAgR0VUX01PRFVMRV9PQkpFQ1QsCiAgR0VUX01PRFVMRV9FWFBPUlRTLAogIEdFVF9NT0RVTEVfTkFNRVNQQUNFLAogIEdFVF9NT0RVTEVfRlVOQ1RJT04sCiAgR0VUX01PRFVMRV9FWENFUFRJT04sCiAgR0VUX01PRFVMRV9NRVRBX09CSiwKfTsKCnN0YXRpYyBKU1ZhbHVlCmpzbV9tb2R1bGVfZnVuYyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSwgaW50IG1hZ2ljKSB7CiAgSlNWYWx1ZSB2YWwgPSBKU19FWENFUFRJT047CiAgSlNNb2R1bGVEZWYqIGRlZiA9IDA7CiAgY29uc3QgY2hhciogbmFtZSA9IDA7CgogIGlmKG1hZ2ljID49IEdFVF9NT0RVTEVfTkFNRSkgewogICAgaWYoIShkZWYgPSBqc19tb2R1bGVfZGVmKGN0eCwgYXJndlswXSkpKQogICAgICByZXR1cm4gSlNfVGhyb3dUeXBlRXJyb3IoY3R4LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIiVzOiBhcmd1bWVudCAxIGV4cGVjdGluZyBtb2R1bGUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChjb25zdCBjaGFyKiBjb25zdFtdKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZ2V0TW9kdWxlTmFtZSIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImdldE1vZHVsZU9iamVjdCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImdldE1vZHVsZUV4cG9ydHMiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJnZXRNb2R1bGVOYW1lc3BhY2UiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJnZXRNb2R1bGVGdW5jdGlvbiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImdldE1vZHVsZUV4Y2VwdGlvbiIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImdldE1vZHVsZU1ldGFPYmplY3QiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlbbWFnaWMgLSAzXSk7CiAgfSBlbHNlIHsKICAgIG5hbWUgPSBKU19Ub0NTdHJpbmcoY3R4LCBhcmd2WzBdKTsKICB9CgogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBGSU5EX01PRFVMRTogewogICAgICBpZigoZGVmID0ganNfbW9kdWxlX2ZpbmQoY3R4LCBuYW1lKSkpCiAgICAgICAgdmFsID0gSlNfRHVwVmFsdWUoY3R4LCBKU19NS1BUUihKU19UQUdfTU9EVUxFLCBkZWYpKTsKICAgICAgZWxzZQogICAgICAgIHZhbCA9IEpTX05VTEw7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBMT0FEX01PRFVMRTogewogICAgICBJbXBvcnREaXJlY3RpdmUgaW1wOwogICAgICBtZW1zZXQoJmltcCwgMCwgc2l6ZW9mKGltcCkpOwogICAgICBpbnQgciwgbiA9IGNvdW50b2YoaW1wLmFyZ3MpOwogICAgICByID0ganNfc3Rydl9jb3B5cyhjdHgsIGFyZ2MsIGFyZ3YsIG4sIGltcC5hcmdzKTsKICAgICAgLy8gcHJpbnRmKCJMT0FEX01PRFVMRSByPSVpIGFyZ2M9JWlcbiIsIHIsIGFyZ2MpOwoKICAgICAgdmFsID0ganNfaW1wb3J0X2V2YWwoY3R4LCBpbXApOwoKICAgICAgLyogICBpZihKU19Jc01vZHVsZSh2YWwpKQogICAgICAgICAgIGRlZiA9IEpTX1ZBTFVFX0dFVF9QVFIodmFsKTsKICAgICAgICAgZWxzZSovCiAgICAgIGRlZiA9IGpzX21vZHVsZV9maW5kKGN0eCwgaW1wLnBhdGgpOwoKICAgICAgaWYoZGVmKQogICAgICAgIHZhbCA9IG1vZHVsZV9vYmplY3QoY3R4LCBkZWYpOwoKICAgICAganNfc3Rydl9mcmVlX24oY3R4LCBuLCBpbXAuYXJncyk7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBSRVNPTFZFX01PRFVMRTogewogICAgICB2YWwgPSBKU19OZXdJbnQzMihjdHgsIEpTX1Jlc29sdmVNb2R1bGUoY3R4LCBKU19NS1BUUihKU19UQUdfTU9EVUxFLCBkZWYpKSk7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBHRVRfTU9EVUxFX05BTUU6IHsKICAgICAgdmFsID0gbW9kdWxlX25hbWUoY3R4LCBkZWYpOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgR0VUX01PRFVMRV9PQkpFQ1Q6IHsKICAgICAgdmFsID0gbW9kdWxlX29iamVjdChjdHgsIGRlZik7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBHRVRfTU9EVUxFX0VYUE9SVFM6IHsKICAgICAgdmFsID0gbW9kdWxlX2V4cG9ydHMoY3R4LCBkZWYpOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgR0VUX01PRFVMRV9OQU1FU1BBQ0U6IHsKICAgICAgdmFsID0gSlNfRHVwVmFsdWUoY3R4LCBkZWYtPm1vZHVsZV9ucyk7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBHRVRfTU9EVUxFX0ZVTkNUSU9OOiB7CgogICAgICB2YWwgPSBtb2R1bGVfZnVuYyhjdHgsIGRlZik7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBHRVRfTU9EVUxFX0VYQ0VQVElPTjogewogICAgICBpZihkZWYtPmV2YWxfaGFzX2V4Y2VwdGlvbikKICAgICAgICB2YWwgPSBKU19EdXBWYWx1ZShjdHgsIGRlZi0+ZXZhbF9leGNlcHRpb24pOwogICAgICBlbHNlCiAgICAgICAgdmFsID0gSlNfTlVMTDsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEdFVF9NT0RVTEVfTUVUQV9PQko6IHsKICAgICAgdmFsID0gSlNfRHVwVmFsdWUoY3R4LCBkZWYtPm1ldGFfb2JqKTsKICAgICAgYnJlYWs7CiAgICB9CiAgfQogIGlmKG5hbWUpCiAgICBKU19GcmVlQ1N0cmluZyhjdHgsIG5hbWUpOwoKICByZXR1cm4gdmFsOwp9CgpzdGF0aWMgY29uc3QgSlNDRnVuY3Rpb25MaXN0RW50cnkganNtX2dsb2JhbF9mdW5jc1tdID0gewogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJldmFsRmlsZSIsIDEsIGpzbV9ldmFsX3NjcmlwdCwgMCksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImV2YWxTY3JpcHQiLCAxLCBqc21fZXZhbF9zY3JpcHQsIDEpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoIm1vZHVsZUxpc3QiLCBqc19tb2R1bGVzX2FycmF5LCAwLCAwKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJtb2R1bGVPYmplY3QiLCBqc19tb2R1bGVzX29iamVjdCwgMCwgMCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigibW9kdWxlTWFwIiwganNfbW9kdWxlc19tYXAsIDAsIDApLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJmaW5kTW9kdWxlIiwgMSwganNtX21vZHVsZV9mdW5jLCBGSU5EX01PRFVMRSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImxvYWRNb2R1bGUiLCAxLCBqc21fbW9kdWxlX2Z1bmMsIExPQURfTU9EVUxFKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigicmVzb2x2ZU1vZHVsZSIsIDEsIGpzbV9tb2R1bGVfZnVuYywgUkVTT0xWRV9NT0RVTEUpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRNb2R1bGVOYW1lIiwgMSwganNtX21vZHVsZV9mdW5jLCBHRVRfTU9EVUxFX05BTUUpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRNb2R1bGVPYmplY3QiLCAxLCBqc21fbW9kdWxlX2Z1bmMsIEdFVF9NT0RVTEVfT0JKRUNUKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0TW9kdWxlRXhwb3J0cyIsIDEsIGpzbV9tb2R1bGVfZnVuYywgR0VUX01PRFVMRV9FWFBPUlRTKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0TW9kdWxlTmFtZXNwYWNlIiwgMSwganNtX21vZHVsZV9mdW5jLCBHRVRfTU9EVUxFX05BTUVTUEFDRSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImdldE1vZHVsZUZ1bmN0aW9uIiwgMSwganNtX21vZHVsZV9mdW5jLCBHRVRfTU9EVUxFX0ZVTkNUSU9OKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0TW9kdWxlRXhjZXB0aW9uIiwgMSwganNtX21vZHVsZV9mdW5jLCBHRVRfTU9EVUxFX0VYQ0VQVElPTiksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImdldE1vZHVsZU1ldGFPYmplY3QiLCAxLCBqc21fbW9kdWxlX2Z1bmMsIEdFVF9NT0RVTEVfTUVUQV9PQkopLAp9OwoKaW50Cm1haW4oaW50IGFyZ2MsIGNoYXIqKiBhcmd2KSB7CiAgSlNSdW50aW1lKiBydDsKICBKU0NvbnRleHQqIGN0eDsKICBzdHJ1Y3QgdHJhY2VfbWFsbG9jX2RhdGEgdHJhY2VfZGF0YSA9IHswfTsKICBpbnQgb3B0aW5kOwogIGNoYXIqIGV4cHIgPSAwOwogIGludCBpbnRlcmFjdGl2ZSA9IDA7CiAgaW50IGR1bXBfbWVtb3J5ID0gMDsKICBpbnQgdHJhY2VfbWVtb3J5ID0gMDsKICBpbnQgZW1wdHlfcnVuID0gMDsKICBpbnQgbW9kdWxlID0gMTsKICBpbnQgbG9hZF9zdGQgPSAxOwogIGludCBkdW1wX3VuaGFuZGxlZF9wcm9taXNlX3JlamVjdGlvbiA9IDA7CiAgc2l6ZV90IG1lbW9yeV9saW1pdCA9IDA7CiAgY2hhciogaW5jbHVkZV9saXN0WzMyXTsKICBpbnQgaSwgaW5jbHVkZV9jb3VudCA9IDA7CiNpZmRlZiBDT05GSUdfQklHTlVNCiAgaW50IGxvYWRfanNjYWxjOwojZW5kaWYKICBzaXplX3Qgc3RhY2tfc2l6ZSA9IDA7CiAgY29uc3QgY2hhciogZXhlbmFtZTsKCiAgcGFja2FnZV9qc29uID0gSlNfVU5ERUZJTkVEOwoKICBpbml0X2xpc3RfaGVhZCgmcG9sbGhhbmRsZXJzKTsKCiAgewogICAgY29uc3QgY2hhciogcDsKICAgIGV4ZW5hbWUgPSBhcmd2WzBdOwogICAgcCA9IHN0cnJjaHIoZXhlbmFtZSwgJy8nKTsKICAgIGlmKHApCiAgICAgIGV4ZW5hbWUgPSBwICsgMTsKICAgIC8qIGxvYWQganNjYWxjIHJ1bnRpbWUgaWYgaW52b2tlZCBhcyAncWpzY2FsYycgKi8KICAgIGxvYWRfanNjYWxjID0gIXN0cmNtcChleGVuYW1lLCAicWpzY2FsYyIpOwogIH0KCiAgLyogY2Fubm90IHVzZSBnZXRvcHQgYmVjYXVzZSB3ZSB3YW50IHRvIHBhc3MgdGhlIGNvbW1hbmQgbGluZSB0bwogICAgIHRoZSBzY3JpcHQgKi8KICBvcHRpbmQgPSAxOwogIHdoaWxlKG9wdGluZCA8IGFyZ2MgJiYgKmFyZ3Zbb3B0aW5kXSA9PSAnLScpIHsKICAgIGNoYXIqIGFyZyA9IGFyZ3Zbb3B0aW5kXSArIDE7CiAgICBjb25zdCBjaGFyKiBsb25nb3B0ID0gIiI7CiAgICBjb25zdCBjaGFyKiBvcHRhcmc7CgogICAgLyogYSBzaW5nbGUgLSBpcyBub3QgYW4gb3B0aW9uLCBpdCBhbHNvIHN0b3BzIGFyZ3VtZW50IHNjYW5uaW5nICovCiAgICBpZighKmFyZykKICAgICAgYnJlYWs7CgogICAgaWYoYXJnWzFdKSB7CiAgICAgIG9wdGFyZyA9ICZhcmdbMV07CiAgICB9IGVsc2UgewogICAgICBvcHRhcmcgPSBhcmd2Wysrb3B0aW5kXTsKICAgIH0KCiAgICBpZigqYXJnID09ICctJykgewogICAgICBsb25nb3B0ID0gYXJnICsgMTsKICAgICAgYXJnICs9IHN0cmxlbihhcmcpOwogICAgICAvKiAtLSBzdG9wcyBhcmd1bWVudCBzY2FubmluZyAqLwogICAgICBpZighKmxvbmdvcHQpCiAgICAgICAgYnJlYWs7CiAgICB9CiAgICBmb3IoOyAqYXJnIHx8ICpsb25nb3B0OyBsb25nb3B0ID0gIiIpIHsKICAgICAgY2hhciBvcHQgPSAqYXJnOwogICAgICBpZihvcHQpCiAgICAgICAgYXJnKys7CiAgICAgIGlmKG9wdCA9PSAnaCcgfHwgb3B0ID09ICc/JyB8fCAhc3RyY21wKGxvbmdvcHQsICJoZWxwIikpIHsKICAgICAgICBqc21faGVscCgpOwogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICAgIGlmKG9wdCA9PSAnZScgfHwgIXN0cmNtcChsb25nb3B0LCAiZXZhbCIpKSB7CiAgICAgICAgaWYoKmFyZykgewogICAgICAgICAgZXhwciA9IGFyZzsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICBpZihvcHRpbmQgPCBhcmdjKSB7CiAgICAgICAgICBleHByID0gYXJndltvcHRpbmQrK107CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgZnByaW50ZihzdGRlcnIsICIlczogbWlzc2luZyBleHByZXNzaW9uIGZvciAtZVxuIiwgZXhlbmFtZSk7CiAgICAgICAgZXhpdCgyKTsKICAgICAgfQogICAgICBpZihvcHQgPT0gJ0knIHx8ICFzdHJjbXAobG9uZ29wdCwgImluY2x1ZGUiKSkgewogICAgICAgIGlmKG9wdGluZCA+PSBhcmdjKSB7CiAgICAgICAgICBmcHJpbnRmKHN0ZGVyciwgImV4cGVjdGluZyBmaWxlbmFtZSIpOwogICAgICAgICAgZXhpdCgxKTsKICAgICAgICB9CiAgICAgICAgaWYoaW5jbHVkZV9jb3VudCA+PSBjb3VudG9mKGluY2x1ZGVfbGlzdCkpIHsKICAgICAgICAgIGZwcmludGYoc3RkZXJyLCAidG9vIG1hbnkgaW5jbHVkZWQgZmlsZXMiKTsKICAgICAgICAgIGV4aXQoMSk7CiAgICAgICAgfQogICAgICAgIGluY2x1ZGVfbGlzdFtpbmNsdWRlX2NvdW50KytdID0gb3B0YXJnOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmKG9wdCA9PSAnaScgfHwgIXN0cmNtcChsb25nb3B0LCAiaW50ZXJhY3RpdmUiKSkgewogICAgICAgIGludGVyYWN0aXZlKys7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYob3B0ID09ICdtJyB8fCAhc3RyY21wKGxvbmdvcHQsICJtb2R1bGUiKSkgewogICAgICAgIGNvbnN0IGNoYXIqIG1vZHVsZXMgPSBhcmd2W29wdGluZF07CiAgICAgICAgc2l6ZV90IGksIGxlbjsKCiAgICAgICAgZm9yKGkgPSAwOyBtb2R1bGVzW2ldOyBpICs9IGxlbikgewogICAgICAgICAgbGVuID0gc3RyX2NocigmbW9kdWxlc1tpXSwgJywnKTsKICAgICAgICAgIHZlY3Rvcl9wdXRwdHIoJm1vZHVsZV9saXN0LCBzdHJfbmR1cCgmbW9kdWxlc1tpXSwgbGVuKSk7CgogICAgICAgICAgaWYobW9kdWxlc1tpICsgbGVuXSA9PSAnLCcpCiAgICAgICAgICAgIGxlbisrOwogICAgICAgIH0KCiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYob3B0ID09ICdkJyB8fCAhc3RyY21wKGxvbmdvcHQsICJkdW1wIikpIHsKICAgICAgICBkdW1wX21lbW9yeSsrOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmKG9wdCA9PSAnVCcgfHwgIXN0cmNtcChsb25nb3B0LCAidHJhY2UiKSkgewogICAgICAgIHRyYWNlX21lbW9yeSsrOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmKCFzdHJjbXAobG9uZ29wdCwgInN0ZCIpKSB7CiAgICAgICAgbG9hZF9zdGQgPSAxOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmKCFzdHJjbXAobG9uZ29wdCwgInVuaGFuZGxlZC1yZWplY3Rpb24iKSkgewogICAgICAgIGR1bXBfdW5oYW5kbGVkX3Byb21pc2VfcmVqZWN0aW9uID0gMTsKICAgICAgICBicmVhazsKICAgICAgfQojaWZkZWYgQ09ORklHX0JJR05VTQogICAgICBpZighc3RyY21wKGxvbmdvcHQsICJuby1iaWdudW0iKSkgewogICAgICAgIGJpZ251bV9leHQgPSAwOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmKCFzdHJjbXAobG9uZ29wdCwgImJpZ251bSIpKSB7CiAgICAgICAgYmlnbnVtX2V4dCA9IDE7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYoIXN0cmNtcChsb25nb3B0LCAicWpzY2FsYyIpKSB7CiAgICAgICAgbG9hZF9qc2NhbGMgPSAxOwogICAgICAgIGJyZWFrOwogICAgICB9CiNlbmRpZgogICAgICBpZihvcHQgPT0gJ3EnIHx8ICFzdHJjbXAobG9uZ29wdCwgInF1aXQiKSkgewogICAgICAgIGVtcHR5X3J1bisrOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmKCFzdHJjbXAobG9uZ29wdCwgIm1lbW9yeS1saW1pdCIpKSB7CiAgICAgICAgaWYob3B0aW5kID49IGFyZ2MpIHsKICAgICAgICAgIGZwcmludGYoc3RkZXJyLCAiZXhwZWN0aW5nIG1lbW9yeSBsaW1pdCIpOwogICAgICAgICAgZXhpdCgxKTsKICAgICAgICB9CiAgICAgICAgbWVtb3J5X2xpbWl0ID0gKHNpemVfdClzdHJ0b2QoYXJndltvcHRpbmQrK10sIDApOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmKCFzdHJjbXAobG9uZ29wdCwgInN0YWNrLXNpemUiKSkgewogICAgICAgIGlmKG9wdGluZCA+PSBhcmdjKSB7CiAgICAgICAgICBmcHJpbnRmKHN0ZGVyciwgImV4cGVjdGluZyBzdGFjayBzaXplIik7CiAgICAgICAgICBleGl0KDEpOwogICAgICAgIH0KICAgICAgICBzdGFja19zaXplID0gKHNpemVfdClzdHJ0b2QoYXJndltvcHRpbmQrK10sIDApOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmKG9wdCkgewogICAgICAgIGZwcmludGYoc3RkZXJyLCAiJXM6IHVua25vd24gb3B0aW9uICctJWMnXG4iLCBleGVuYW1lLCBvcHQpOwogICAgICB9IGVsc2UgewogICAgICAgIGZwcmludGYoc3RkZXJyLCAiJXM6IHVua25vd24gb3B0aW9uICctLSVzJ1xuIiwgZXhlbmFtZSwgbG9uZ29wdCk7CiAgICAgIH0KICAgICAganNtX2hlbHAoKTsKICAgIH0KICAgIG9wdGluZCsrOwogIH0KCiAgewogICAgY29uc3QgY2hhciogbW9kdWxlczsKCiAgICBpZigobW9kdWxlcyA9IGdldGVudigiREVCVUciKSkpIHsKICAgICAgc2l6ZV90IGksIGxlbjsKICAgICAgZm9yKGkgPSAwOyBtb2R1bGVzW2ldOyBpICs9IGxlbikgewogICAgICAgIGxlbiA9IHN0cl9jaHIoJm1vZHVsZXNbaV0sICcsJyk7CiAgICAgICAgdmVjdG9yX3B1dHB0cigmbW9kdWxlX2RlYnVnLCBzdHJfbmR1cCgmbW9kdWxlc1tpXSwgbGVuKSk7CgogICAgICAgIGlmKG1vZHVsZXNbaSArIGxlbl0gPT0gJywnKQogICAgICAgICAgbGVuKys7CiAgICAgIH0KCiAgICAgIGRlYnVnX21vZHVsZV9sb2FkZXIgPSB2ZWN0b3JfY291bnRzKCZtb2R1bGVfZGVidWcsICJtb2R1bGVzIik7CiAgICB9CiAgfQoKICBpZihsb2FkX2pzY2FsYykKICAgIGJpZ251bV9leHQgPSAxOwoKICBpZih0cmFjZV9tZW1vcnkpIHsKICAgIGpzbV90cmFjZV9tYWxsb2NfaW5pdCgmdHJhY2VfZGF0YSk7CiAgICBydCA9IEpTX05ld1J1bnRpbWUyKCZ0cmFjZV9tZiwgJnRyYWNlX2RhdGEpOwogIH0gZWxzZSB7CiAgICBydCA9IEpTX05ld1J1bnRpbWUoKTsKICB9CiAgaWYoIXJ0KSB7CiAgICBmcHJpbnRmKHN0ZGVyciwgIiVzOiBjYW5ub3QgYWxsb2NhdGUgSlMgcnVudGltZVxuIiwgZXhlbmFtZSk7CiAgICBleGl0KDIpOwogIH0KCiAgSlNfU2V0TW9kdWxlTG9hZGVyRnVuYyhydCwgMCwganNtX21vZHVsZV9sb2FkZXIsIDApOwoKICBpZihtZW1vcnlfbGltaXQgIT0gMCkKICAgIEpTX1NldE1lbW9yeUxpbWl0KHJ0LCBtZW1vcnlfbGltaXQpOwogIC8vIGlmIChzdGFja19zaXplICE9IDApCiAgSlNfU2V0TWF4U3RhY2tTaXplKHJ0LCBzdGFja19zaXplICE9IDAgPyBzdGFja19zaXplIDogMjU2ICogMTA0ODU3Nik7CgogIGpzX3N0ZF9zZXRfd29ya2VyX25ld19jb250ZXh0X2Z1bmMoanNtX2NvbnRleHRfbmV3KTsKCiAganNfc3RkX2luaXRfaGFuZGxlcnMocnQpOwogIGN0eCA9IGpzbV9jb250ZXh0X25ldyhydCk7CiAgaWYoIWN0eCkgewogICAgZnByaW50ZihzdGRlcnIsICIlczogY2Fubm90IGFsbG9jYXRlIEpTIGNvbnRleHRcbiIsIGV4ZW5hbWUpOwogICAgZXhpdCgyKTsKICB9CgogIC8qIGxvYWRlciBmb3IgRVM2IG1vZHVsZXMgKi8KICBKU19TZXRNb2R1bGVMb2FkZXJGdW5jKHJ0LCBqc19tb2R1bGVfbm9ybWFsaXplLCBqc21fbW9kdWxlX2xvYWRlciwgMCk7CiAgLy8ganNfc3RkX3NldF9tb2R1bGVfbG9hZGVyX2Z1bmMoanNtX21vZHVsZV9sb2FkZXIpOwoKICBpZihkdW1wX3VuaGFuZGxlZF9wcm9taXNlX3JlamVjdGlvbikgewogICAgSlNfU2V0SG9zdFByb21pc2VSZWplY3Rpb25UcmFja2VyKHJ0LCBqc19zdGRfcHJvbWlzZV9yZWplY3Rpb25fdHJhY2tlciwgMCk7CiAgfQoKICBpZighZW1wdHlfcnVuKSB7CiNpZmRlZiBDT05GSUdfQklHTlVNCiAgICBpZihsb2FkX2pzY2FsYykgewogICAgICBqc19ldmFsX2JpbmFyeShjdHgsIHFqc2NfcWpzY2FsYywgcWpzY19xanNjYWxjX3NpemUsIDApOwogICAgfQojZW5kaWYKICAgIGpzX3N0ZF9hZGRfaGVscGVycyhjdHgsIGFyZ2MgLSBvcHRpbmQsIGFyZ3YgKyBvcHRpbmQpOwoKICAgIGludCBudW1fbmF0aXZlLCBudW1fY29tcGlsZWQ7CgojZGVmaW5lIGpzbV9idWlsdGluX25hdGl2ZShuYW1lKSB2ZWN0b3JfcHV0cHRyKCZidWlsdGlucywgI25hbWUpCgogICAganNtX2J1aWx0aW5fbmF0aXZlKHN0ZCk7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUob3MpOwogICAganNtX2J1aWx0aW5fbmF0aXZlKGNoaWxkX3Byb2Nlc3MpOwogICAganNtX2J1aWx0aW5fbmF0aXZlKGRlZXApOwogICAganNtX2J1aWx0aW5fbmF0aXZlKGluc3BlY3QpOwogICAganNtX2J1aWx0aW5fbmF0aXZlKGxleGVyKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShtaXNjKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShtbWFwKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShwYXRoKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShwb2ludGVyKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShwcmVkaWNhdGUpOwogICAganNtX2J1aWx0aW5fbmF0aXZlKHJlcGVhdGVyKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZSh0cmVlX3dhbGtlcik7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUoeG1sKTsKICAgIG51bV9uYXRpdmUgPSB2ZWN0b3Jfc2l6ZSgmYnVpbHRpbnMsIHNpemVvZihjaGFyKikpOwoKICAgIC8vIHByaW50ZigibmF0aXZlIGJ1aWx0aW5zOiAiKTsgZHVtcF92ZWN0b3IoJmJ1aWx0aW5zLCAwKTsKCiNkZWZpbmUganNtX2J1aWx0aW5fY29tcGlsZWQobmFtZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIGpzX3N0ZF9ldmFsX2JpbmFyeShjdHgsIHFqc2NfIyNuYW1lLCBxanNjXyMjbmFtZSMjX3NpemUsIDApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICB2ZWN0b3JfcHV0cHRyKCZidWlsdGlucywgI25hbWUpCgogICAganNtX2J1aWx0aW5fY29tcGlsZWQoY29uc29sZSk7CiAgICBqc21fYnVpbHRpbl9jb21waWxlZChldmVudHMpOwogICAganNtX2J1aWx0aW5fY29tcGlsZWQoZnMpOwogICAganNtX2J1aWx0aW5fY29tcGlsZWQocGVyZl9ob29rcyk7CiAgICBqc21fYnVpbHRpbl9jb21waWxlZChwcm9jZXNzKTsKICAgIC8vIGpzbV9idWlsdGluX2NvbXBpbGVkKHJlcGwpOwogICAganNtX2J1aWx0aW5fY29tcGlsZWQocmVxdWlyZSk7CiAgICBqc21fYnVpbHRpbl9jb21waWxlZCh0dHkpOwogICAganNtX2J1aWx0aW5fY29tcGlsZWQodXRpbCk7CgogICAgbnVtX2NvbXBpbGVkID0gdmVjdG9yX3NpemUoJmJ1aWx0aW5zLCBzaXplb2YoY2hhciopKSAtIG51bV9uYXRpdmU7CgogICAgewogICAgICBjb25zdCBjaGFyKiBzdHIgPSAiaW1wb3J0IHByb2Nlc3MgZnJvbSAncHJvY2Vzcyc7XG5nbG9iYWxUaGlzLnByb2Nlc3MgPSBwcm9jZXNzO1xuIjsKICAgICAganNfZXZhbF9zdHIoY3R4LCBzdHIsIDAsIEpTX0VWQUxfVFlQRV9NT0RVTEUpOwogICAgfQoKICAgIEpTX1NldFByb3BlcnR5RnVuY3Rpb25MaXN0KGN0eCwgSlNfR2V0R2xvYmFsT2JqZWN0KGN0eCksIGpzbV9nbG9iYWxfZnVuY3MsIGNvdW50b2YoanNtX2dsb2JhbF9mdW5jcykpOwogICAgaWYobG9hZF9zdGQpIHsKICAgICAgY29uc3QgY2hhciogc3RyID0gImltcG9ydCAqIGFzIHN0ZCBmcm9tICdzdGQnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAiCiAgICAgICAgICAgICAgICAgICAgICAgICInb3MnO1xuZ2xvYmFsVGhpcy5zdGQgPSAiCiAgICAgICAgICAgICAgICAgICAgICAgICJzdGQ7XG5nbG9iYWxUaGlzLm9zICIKICAgICAgICAgICAgICAgICAgICAgICAgIj0gb3M7XG5nbG9iYWxUaGlzLnNldFRpbWVvdXQgPSAiCiAgICAgICAgICAgICAgICAgICAgICAgICJvcy5zZXRUaW1lb3V0O1xuZ2xvYmFsVGhpcy5jbGVhclRpbWVvdXQgPSAiCiAgICAgICAgICAgICAgICAgICAgICAgICJvcy5jbGVhclRpbWVvdXQ7XG4iOwogICAgICBqc19ldmFsX3N0cihjdHgsIHN0ciwgMCwgSlNfRVZBTF9UWVBFX01PRFVMRSk7CiAgICB9CgogICAgLy8ganNtX2xpc3RfbW9kdWxlcyhjdHgpOwoKICAgIHsKICAgICAgY2hhcioqIG5hbWU7CiAgICAgIEpTTW9kdWxlRGVmKiBtOwogICAgICB2ZWN0b3JfZm9yZWFjaF90KCZtb2R1bGVfbGlzdCwgbmFtZSkgewogICAgICAgIGlmKCEobSA9IGpzX21vZHVsZV9pbXBvcnRfbmFtZXNwYWNlKGN0eCwgKm5hbWUsIDApKSkgewogICAgICAgICAgZnByaW50ZihzdGRlcnIsICJlcnJvciBsb2FkaW5nIG1vZHVsZSAnJXMnXG4iLCAqbmFtZSk7CiAgICAgICAgICBqc21fZHVtcF9lcnJvcihjdHgpOwogICAgICAgICAgZXhpdCgxKTsKICAgICAgICB9CiAgICAgICAgZnJlZSgqbmFtZSk7CiAgICAgIH0KICAgICAgdmVjdG9yX2ZyZWUoJm1vZHVsZV9saXN0KTsKICAgIH0KCiAgICBmb3IoaSA9IDA7IGkgPCBpbmNsdWRlX2NvdW50OyBpKyspIHsKICAgICAgaWYoanNtX2xvYWRfc2NyaXB0KGN0eCwgaW5jbHVkZV9saXN0W2ldLCBtb2R1bGUpID09IC0xKQogICAgICAgIGdvdG8gZmFpbDsKICAgIH0KCiAgICBpZihleHByKSB7CiAgICAgIGlmKGpzX2V2YWxfc3RyKGN0eCwgZXhwciwgIjxjbWRsaW5lPiIsIDApID09IC0xKQogICAgICAgIGdvdG8gZmFpbDsKICAgIH0gZWxzZSBpZihvcHRpbmQgPj0gYXJnYykgewogICAgICAvKiBpbnRlcmFjdGl2ZSBtb2RlICovCiAgICAgIGludGVyYWN0aXZlID0gMTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbnN0IGNoYXIqIGZpbGVuYW1lOwogICAgICBmaWxlbmFtZSA9IGFyZ3Zbb3B0aW5kXTsKICAgICAgaWYoanNtX2xvYWRfc2NyaXB0KGN0eCwgZmlsZW5hbWUsIG1vZHVsZSkgPT0gLTEpIHsKICAgICAgICBqc192YWx1ZV9md3JpdGUoY3R4LCBKU19HZXRFeGNlcHRpb24oY3R4KSwgc3RkZXJyKTsKICAgICAgICBnb3RvIGZhaWw7CiAgICAgIH0KICAgIH0KICAgIGlmKGludGVyYWN0aXZlKSB7CiAgICAgIGNoYXIgc3RyWzUxMl07CiAgICAgIGNvbnN0IGNoYXIqIGhvbWUgPSBnZXRlbnYoIkhPTUUiKTsKCiAgICAgIHNucHJpbnRmKHN0ciwKICAgICAgICAgICAgICAgc2l6ZW9mKHN0ciksCiAgICAgICAgICAgICAgICJpbXBvcnQgUkVQTCBmcm9tICdyZXBsJztcbiIKICAgICAgICAgICAgICAgImltcG9ydCBmcyBmcm9tICdmcyc7XG4iCiAgICAgICAgICAgICAgICJjb25zdCBoaXN0b3J5ID0gJyVzLy4lc19oaXN0b3J5JztcbiIKICAgICAgICAgICAgICAgImdsb2JhbFRoaXMucmVwbCA9IG5ldyBSRVBMKCdxanNtJyk7XG4iCiAgICAgICAgICAgICAgICJyZXBsLmZzID0gZnM7XG4iCiAgICAgICAgICAgICAgICJyZXBsLnNob3cgPSBjb25zb2xlLmxvZztcbiIKICAgICAgICAgICAgICAgInJlcGwuaGlzdG9yeUxvYWQoaGlzdG9yeSk7XG4iCiAgICAgICAgICAgICAgICJyZXBsLmFkZENsZWFudXBIYW5kbGVyKCgpID0+IHJlcGwuaGlzdG9yeVNhdmUoaGlzdG9yeSkpO1xuIgogICAgICAgICAgICAgICAicmVwbC5ydW5TeW5jKCk7XG4iLAogICAgICAgICAgICAgICBob21lLAogICAgICAgICAgICAgICBleGVuYW1lKTsKICAgICAgcHJpbnRmKCJzdHI6ICVzXG4iLCBzdHIpOwogICAgICBqc19ldmFsX2JpbmFyeShjdHgsIHFqc2NfcmVwbCwgcWpzY19yZXBsX3NpemUsIDApOwogICAgICBqc19ldmFsX3N0cihjdHgsIHN0ciwgMCwgSlNfRVZBTF9UWVBFX01PRFVMRSk7CiAgICB9CgogICAganNfc3RkX2xvb3AoY3R4KTsKICB9CgogIGlmKCFKU19Jc051bGwoY3R4LT5ydC0+Y3VycmVudF9leGNlcHRpb24pKQogICAganNtX2R1bXBfZXJyb3IoY3R4KTsKCiAgaWYoZHVtcF9tZW1vcnkpIHsKICAgIEpTTWVtb3J5VXNhZ2Ugc3RhdHM7CiAgICBKU19Db21wdXRlTWVtb3J5VXNhZ2UocnQsICZzdGF0cyk7CiAgICBKU19EdW1wTWVtb3J5VXNhZ2Uoc3Rkb3V0LCAmc3RhdHMsIHJ0KTsKICB9CiAganNfc3RkX2ZyZWVfaGFuZGxlcnMocnQpOwogIEpTX0ZyZWVDb250ZXh0KGN0eCk7CiAgSlNfRnJlZVJ1bnRpbWUocnQpOwoKICBpZihlbXB0eV9ydW4gJiYgZHVtcF9tZW1vcnkpIHsKICAgIGNsb2NrX3QgdFs1XTsKICAgIGRvdWJsZSBiZXN0WzVdOwogICAgaW50IGksIGo7CiAgICBmb3IoaSA9IDA7IGkgPCAxMDA7IGkrKykgewogICAgICB0WzBdID0gY2xvY2soKTsKICAgICAgcnQgPSBKU19OZXdSdW50aW1lKCk7CiAgICAgIHRbMV0gPSBjbG9jaygpOwogICAgICBjdHggPSBKU19OZXdDb250ZXh0KHJ0KTsKICAgICAgdFsyXSA9IGNsb2NrKCk7CiAgICAgIEpTX0ZyZWVDb250ZXh0KGN0eCk7CiAgICAgIHRbM10gPSBjbG9jaygpOwogICAgICBKU19GcmVlUnVudGltZShydCk7CiAgICAgIHRbNF0gPSBjbG9jaygpOwogICAgICBmb3IoaiA9IDQ7IGogPiAwOyBqLS0pIHsKICAgICAgICBkb3VibGUgbXMgPSAxMDAwLjAgKiAodFtqXSAtIHRbaiAtIDFdKSAvIENMT0NLU19QRVJfU0VDOwogICAgICAgIGlmKGkgPT0gMCB8fCBiZXN0W2pdID4gbXMpCiAgICAgICAgICBiZXN0W2pdID0gbXM7CiAgICAgIH0KICAgIH0KICAgIHByaW50ZigiXG5JbnN0YW50aWF0aW9uIHRpbWVzIChtcyk6ICUuM2YgPSAlLjNmKyUuM2YrJS4zZislLjNmXG4iLCBiZXN0WzFdICsgYmVzdFsyXSArIGJlc3RbM10gKyBiZXN0WzRdLCBiZXN0WzFdLCBiZXN0WzJdLCBiZXN0WzNdLCBiZXN0WzRdKTsKICB9CiAgcmV0dXJuIDA7CmZhaWw6CiAganNfc3RkX2ZyZWVfaGFuZGxlcnMocnQpOwogIEpTX0ZyZWVDb250ZXh0KGN0eCk7CiAgSlNfRnJlZVJ1bnRpbWUocnQpOwogIHJldHVybiAxOwp9CgAAAAAAAAAAqW4AAAAAAAAAAAAAAAAAAAAAAACpbgAAAAAAAAAAAAAAAAAAAAAAAKluAAAAAAAAAAAAAA",
					"AwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAGRnAAAAAAAAb2cAAAAAAAAAAAAAAADwvw"
				],
				[
					1,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAACpbgAAI2luY2x1ZGUgPHN0ZGxpYi5oPgojaW5jbHVkZSA8c3RkaW8uaD4KI2luY2x1ZGUgPHN0ZGFyZy5oPgojaW5jbHVkZSA8aW50dHlwZXMuaD4KI2luY2x1ZGUgPHN0cmluZy5oPgojaW5jbHVkZSA8YXNzZXJ0Lmg+CiNpbmNsdWRlIDx1bmlzdGQuaD4KI2luY2x1ZGUgPGVycm5vLmg+CiNpbmNsdWRlIDxmY250bC5oPgojaW5jbHVkZSA8dGltZS5oPgojaW5jbHVkZSA8c2lnbmFsLmg+CiNpbmNsdWRlIDxzeXMvcG9sbC5oPgojaWYgZGVmaW5lZChfX0FQUExFX18pCiNpbmNsdWRlIDxtYWxsb2MvbWFsbG9jLmg+CiNlbGlmIGRlZmluZWQoX19saW51eF9fKQojaW5jbHVkZSA8bWFsbG9jLmg+CiNlbmRpZgojaWZuZGVmIF9fd2FzaV9fCiNpbmNsdWRlIDxkbGZjbi5oPgojZW5kaWYKCiNpZiAxIC8vIGRlZiBIQVZFX1FVSUNLSlNfQ09ORklHX0gKI2luY2x1ZGUgInF1aWNranMtY29uZmlnLmgiCiNlbmRpZgoKI2lmZGVmIFVTRV9XT1JLRVIKI2luY2x1ZGUgPHB0aHJlYWQuaD4KI2luY2x1ZGUgPHN0ZGF0b21pYy5oPgoKc3RhdGljIGludAphdG9taWNfYWRkX2ludChpbnQqIHB0ciwgaW50IHYpIHsKICByZXR1cm4gYXRvbWljX2ZldGNoX2FkZCgoX0F0b21pYyh1aW50MzJfdCkqKXB0ciwgdikgKyB2Owp9CiNlbmRpZgoKI2luY2x1ZGUgImxpc3QuaCIKI2luY2x1ZGUgImN1dGlscy5oIgojaW5jbHVkZSAidXRpbHMuaCIKI2luY2x1ZGUgInZlY3Rvci5oIgojaW5jbHVkZSAicXVpY2tqcy1saWJjLmgiCiNpbmNsdWRlICJxdWlja2pzLWludGVybmFsLmgiCiNpbmNsdWRlICJidWZmZXItdXRpbHMuaCIKCnR5cGVkZWYgc3RydWN0IHBvbGxoYW5kbGVyIHsKICBzdHJ1Y3QgcG9sbGZkIHBmOwogIHZvaWQgKCpoYW5kbGVyKSh2b2lkKiBvcGFxdWUsIHN0cnVjdCBwb2xsZmQqKTsKICB2b2lkKiBvcGFxdWU7CiAgc3RydWN0IGxpc3RfaGVhZCBsaW5rOwp9IHBvbGxoYW5kbGVyX3Q7Cgp0aHJlYWRfbG9jYWwgdWludDY0X3QganNtX3BlbmRpbmdfc2lnbmFscyA9IDA7CnN0cnVjdCBsaXN0X2hlYWQgcG9sbGhhbmRsZXJzOwoKdm9pZCBqc19zdGRfc2V0X21vZHVsZV9sb2FkZXJfZnVuYyhKU01vZHVsZUxvYWRlckZ1bmMqIGZ1bmMpOwoKI2lmZGVmIEhBVkVfTUFMTE9DX1VTQUJMRV9TSVpFCiNpZm5kZWYgSEFWRV9NQUxMT0NfVVNBQkxFX1NJWkVfREVGSU5JVElPTgpleHRlcm4gc2l6ZV90IG1hbGxvY191c2FibGVfc2l6ZSgpOwojZW5kaWYKI2VuZGlmCgojZGVmaW5lIHRyaW1fZG90c2xhc2goc3RyKSAoIXN0cm5jbXAoKHN0ciksICIuLyIsIDIpID8gKHN0cikgKyAyIDogKHN0cikpCgojZGVmaW5lIGpzbV9kZWNsYXJlX21vZHVsZShuYW1lKSBcCiAgZXh0ZXJuIGNvbnN0IHVpbnQ4X3QgcWpzY18jI25hbWVbXTsgXAogIGV4dGVybiBjb25zdCB1aW50MzJfdCBxanNjXyMjbmFtZSMjX3NpemU7IFwKICBKU01vZHVsZURlZioganNfaW5pdF9tb2R1bGVfIyNuYW1lKEpTQ29udGV4dCosIGNvbnN0IGNoYXIqKTsKCmpzbV9kZWNsYXJlX21vZHVsZShjb25zb2xlKTsKanNtX2RlY2xhcmVfbW9kdWxlKGV2ZW50cyk7CmpzbV9kZWNsYXJlX21vZHVsZShmcyk7CmpzbV9kZWNsYXJlX21vZHVsZShwZXJmX2hvb2tzKTsKanNtX2RlY2xhcmVfbW9kdWxlKHByb2Nlc3MpOwpqc21fZGVjbGFyZV9tb2R1bGUocmVwbCk7CmpzbV9kZWNsYXJlX21vZHVsZShyZXF1aXJlKTsKanNtX2RlY2xhcmVfbW9kdWxlKHR0eSk7CmpzbV9kZWNsYXJlX21vZHVsZSh1dGlsKTsKCiNpZmRlZiBDT05GSUdfQklHTlVNCmpzbV9kZWNsYXJlX21vZHVsZShxanNjYWxjKTsKc3RhdGljIGludCBiaWdudW1fZXh0ID0gMTsKI2VuZGlmCgp2b2lkIGpzX3N0ZF9zZXRfd29ya2VyX25ld19jb250ZXh0X2Z1bmMoSlNDb250ZXh0KiAoKmZ1bmMpKEpTUnVudGltZSogcnQpKTsKCnN0YXRpYyB2b2lkCmpzbV9kdW1wX2Vycm9yKEpTQ29udGV4dCogY3R4KSB7CiAgLypKU1J1bnRpbWUqIHJ0ID0gSlNfR2V0UnVudGltZShjdHgpOwogIEpTVmFsdWUgZXJyb3IgPSBydC0+Y3VycmVudF9leGNlcHRpb247Ki8KICAvKnByaW50ZigicWpzbTogY3VycmVudF9leGNlcHRpb24gMHglMDh4XG4iLCBvZmZzZXRvZihKU1J1bnRpbWUsIGN1cnJlbnRfZXhjZXB0aW9uKSk7CiAgcHJpbnRmKCJxanNtOiBzaXplb2Yoc3RydWN0IGxpc3RfaGVhZCkgMHglMDh4XG4iLCBzaXplb2Yoc3RydWN0IGxpc3RfaGVhZCkpOyovCgogIGpzX2Vycm9yX3ByaW50KGN0eCwgSlNfR2V0RXhjZXB0aW9uKGN0eCkpOwp9CgpzdGF0aWMgaW50IGRlYnVnX21vZHVsZV9sb2FkZXIgPSAwOwpzdGF0aWMgVmVjdG9yIG1vZHVsZV9kZWJ1ZyA9IFZFQ1RPUl9JTklUKCk7CnN0YXRpYyBWZWN0b3IgbW9kdWxlX2xpc3QgPSBWRUNUT1JfSU5JVCgpOwpzdGF0aWMgVmVjdG9yIGJ1aWx0aW5zID0gVkVDVE9SX0lOSVQoKTsKCnN0YXRpYyBjb25zdCBjaGFyIGpzbV9kZWZhdWx0X21vZHVsZV9wYXRoW10gPSAiLiIKI2lmZGVmIFFVSUNLSlNfTU9EVUxFX1BBVEgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICI6IiBRVUlDS0pTX01PRFVMRV9QQVRICiNlbGlmIGRlZmluZWQoQ09ORklHX1BSRUZJWCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICI6IiBDT05GSUdfUFJFRklYICIvbGliL3F1aWNranMiCiNlbmRpZgogICAgOwoKSlNWYWx1ZSBwYWNrYWdlX2pzb247CgpzdGF0aWMgSlNWYWx1ZQpldmFsX2J1ZihKU0NvbnRleHQqIGN0eCwgY29uc3Qgdm9pZCogYnVmLCBpbnQgYnVmX2xlbiwgY29uc3QgY2hhciogZmlsZW5hbWUsIGludCBldmFsX2ZsYWdzKSB7CiAgSlNWYWx1ZSB2YWw7CgogIGlmKChldmFsX2ZsYWdzICYgSlNfRVZBTF9UWVBFX01BU0spID09IEpTX0VWQUxfVFlQRV9NT0RVTEUpIHsKICAgIC8qIGZvciB0aGUgbW9kdWxlcywgd2UgY29tcGlsZSB0aGVuIHJ1biB0byBiZSBhYmxlIHRvIHNldCBpbXBvcnQubWV0YSAqLwogICAgdmFsID0gSlNfRXZhbChjdHgsIGJ1ZiwgYnVmX2xlbiwgZmlsZW5hbWUsIGV2YWxfZmxhZ3MgfCBKU19FVkFMX0ZMQUdfQ09NUElMRV9PTkxZKTsKICAgIGlmKCFKU19Jc0V4Y2VwdGlvbih2YWwpKSB7CiAgICAgIGpzX21vZHVsZV9zZXRfaW1wb3J0X21ldGEoY3R4LCB2YWwsIFRSVUUsIFRSVUUpOwogICAgICBKU19FdmFsRnVuY3Rpb24oY3R4LCB2YWwpOwogICAgfQogIH0gZWxzZSB7CiAgICB2YWwgPSBKU19FdmFsKGN0eCwgYnVmLCBidWZfbGVuLCBmaWxlbmFtZSwgZXZhbF9mbGFncyk7CiAgfQogIGlmKEpTX0lzRXhjZXB0aW9uKHZhbCkpCiAgICBqc19lcnJvcl9wcmludChjdHgsIEpTX0dldFJ1bnRpbWUoY3R4KS0+Y3VycmVudF9leGNlcHRpb24pOwoKICBqc21fZHVtcF9lcnJvcihjdHgpOwogIHJldHVybiB2YWw7Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzbV9sb2FkX3BhY2thZ2UoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIGZpbGUpIHsKICBpZihKU19Jc1VuZGVmaW5lZChwYWNrYWdlX2pzb24pKSB7CiAgICB1aW50OF90KiBidWY7CiAgICBzaXplX3QgbGVuOwogICAgaWYoZmlsZSA9PSAwKQogICAgICBmaWxlID0gInBhY2thZ2UuanNvbiI7CiAgICBpZighKGJ1ZiA9IGpzX2xvYWRfZmlsZShjdHgsICZsZW4sIGZpbGUpKSkKICAgICAgcGFja2FnZV9qc29uID0gSlNfTlVMTDsKICAgIGVsc2UKICAgICAgcGFja2FnZV9qc29uID0gSlNfUGFyc2VKU09OKGN0eCwgYnVmLCBsZW4sIGZpbGUpOwogIH0KICByZXR1cm4gSlNfRHVwVmFsdWUoY3R4LCBwYWNrYWdlX2pzb24pOwp9CgpKU01vZHVsZURlZioKanNtX21vZHVsZV9sb2FkZXIoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIG5hbWUsIHZvaWQqIG9wYXF1ZSkgewogIGNoYXIgKm1vZHVsZSwgKmZpbGUgPSAwOwogIEpTTW9kdWxlRGVmKiByZXQgPSAwOwogIG1vZHVsZSA9IGpzX3N0cmR1cChjdHgsIHRyaW1fZG90c2xhc2gobmFtZSkpOwogIGZvcig7OykgewogICAgaWYoZGVidWdfbW9kdWxlX2xvYWRlciA+IDEpIHsKICAgICAgaWYoZmlsZSkKICAgICAgICBwcmludGYoIlx4MWJbNDg7NTsyMTRtKDEpXHgxYlswbSAlLTMwcyAnJXMnXG4iLCBuYW1lLCBmaWxlKTsKICAgICAgLyogIGVsc2UgIHByaW50ZigianNtX21vZHVsZV9sb2FkZXJbJXhdIFx4MWJbNDg7NTsxMjRtKDEpXHgxYlswbSAlLTIwcyAtPgogICAgICAgKiAlc1xuIiwgcHRocmVhZF9zZWxmKCksIHRyaW1fZG90c2xhc2gobmFtZSksIHRyaW1fZG90c2xhc2gobW9kdWxlKSk7Ki8KICAgIH0KICAgIGlmKCFzdHJjaHIobW9kdWxlLCAnLycpICYmIChyZXQgPSBqc19tb2R1bGVfZmluZChjdHgsIG1vZHVsZSkpKQogICAgICBnb3RvIGVuZDsKCiAgICBpZighaGFzX3N1ZmZpeChuYW1lLCAiLnNvIikgJiYgIWZpbGUpIHsKICAgICAgSlNWYWx1ZSBwYWNrYWdlID0ganNtX2xvYWRfcGFja2FnZShjdHgsIDApOwogICAgICBpZighSlNfSXNOdWxsKHBhY2thZ2UpKSB7CiAgICAgICAgSlNWYWx1ZSBhbGlhc2VzID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBwYWNrYWdlLCAiX21vZHVsZUFsaWFzZXMiKTsKICAgICAgICBKU1ZhbHVlIHRhcmdldCA9IEpTX1VOREVGSU5FRDsKICAgICAgICBpZighSlNfSXNVbmRlZmluZWQoYWxpYXNlcykpIHsKICAgICAgICAgIHRhcmdldCA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgYWxpYXNlcywgbW9kdWxlKTsKICAgICAgICB9CiAgICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgYWxpYXNlcyk7CiAgICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgcGFja2FnZSk7CiAgICAgICAgaWYoIUpTX0lzVW5kZWZpbmVkKHRhcmdldCkpIHsKICAgICAgICAgIGNvbnN0IGNoYXIqIHN0ciA9IEpTX1RvQ1N0cmluZyhjdHgsIHRhcmdldCk7CiAgICAgICAgICBpZihzdHIpIHsKICAgICAgICAgICAgaWYoZGVidWdfbW9kdWxlX2xvYWRlcikKICAgICAgICAgICAgICBwcmludGYoIlx4MWJbNDg7NTsyOG0oMilceDFiWzBtICUtMzBzID0+ICVzXG4iLCBtb2R1bGUsIHN0cik7CgogICAgICAgICAgICBqc19mcmVlKGN0eCwgbW9kdWxlKTsKCiAgICAgICAgICAgIG1vZHVsZSA9IGpzX3N0cmR1cChjdHgsIHN0cik7CiAgICAgICAgICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgc3RyKTsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBpZighZmlsZSkgewogICAgICBpZihzdHJjaHIoIi4vIiwgbW9kdWxlWzBdKSkKICAgICAgICBmaWxlID0ganNfc3RyZHVwKGN0eCwgbW9kdWxlKTsKICAgICAgZWxzZSBpZighKGZpbGUgPSBqc19tb2R1bGVfc2VhcmNoKGN0eCwganNtX2RlZmF1bHRfbW9kdWxlX3BhdGgsIG1vZHVsZSkpKQogICAgICAgIGJyZWFrOwogICAgICBjb250aW51ZTsKICAgIH0KICAgIGJyZWFrOwogIH0KICBpZihmaWxlKSB7CiAgICBpZihkZWJ1Z19tb2R1bGVfbG9hZGVyKQogICAgICBpZihzdHJjbXAodHJpbV9kb3RzbGFzaChtb2R1bGUpLCB0cmltX2RvdHNsYXNoKGZpbGUpKSkKICAgICAgICBwcmludGYoIlx4MWJbNDg7NTsyMW0oMylceDFiWzBtICUtMzBzIC0+ICVzXG4iLCBtb2R1bGUsIGZpbGUpOwoKICAgIHJldCA9IGpzX21vZHVsZV9sb2FkZXIoY3R4LCBmaWxlLCBvcGFxdWUpOwogIH0KZW5kOgogIGlmKHZlY3Rvcl9maW5kcygmbW9kdWxlX2RlYnVnLCAiaW1wb3J0IikgIT0gLTEpIHsKICAgIGZwcmludGYoc3RkZXJyLCAoIWZpbGUgfHwgc3RyY21wKG1vZHVsZSwgZmlsZSkpID8gIiEhISBJTVBPUlQgJXMgLT4gJXNcbiIgOiAiISEhIElNUE9SVCAlc1xuIiwgbW9kdWxlLCBmaWxlKTsKICB9CiAgaWYoIXJldCkKICAgIHByaW50ZigianNtX21vZHVsZV9sb2FkZXIoXCIlc1wiKSA9ICVwXG4iLCBuYW1lLCByZXQpOwogIGlmKG1vZHVsZSkKICAgIGpzX2ZyZWUoY3R4LCBtb2R1bGUpOwogIGlmKGZpbGUpCiAgICBqc19mcmVlKGN0eCwgZmlsZSk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNtX2V2YWxfZmlsZShKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogZmlsZSwgaW50IG1vZHVsZSkgewogIHVpbnQ4X3QqIGJ1ZjsKICBzaXplX3QgbGVuOwogIGludCBmbGFnczsKCiAgYnVmID0ganNfbG9hZF9maWxlKGN0eCwgJmxlbiwgZmlsZSk7CiAgaWYoIWJ1ZikgewogICAgcmV0dXJuIEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJGYWlsZWQgbG9hZGluZyAnJXMnOiAlcyIsIGZpbGUsIHN0cmVycm9yKGVycm5vKSk7CiAgfQoKICBpZihtb2R1bGUgPCAwKQogICAgbW9kdWxlID0gKGhhc19zdWZmaXgoZmlsZSwgIi5tanMiKSB8fCBKU19EZXRlY3RNb2R1bGUoKGNvbnN0IGNoYXIqKWJ1ZiwgbGVuKSk7CiAgZmxhZ3MgPSBtb2R1bGUgPyBKU19FVkFMX1RZUEVfTU9EVUxFIDogSlNfRVZBTF9UWVBFX0dMT0JBTDsKICByZXR1cm4gZXZhbF9idWYoY3R4LCBidWYsIGxlbiwgZmlsZSwgZmxhZ3MpOwp9CgpzdGF0aWMgaW50CmpzbV9sb2FkX3NjcmlwdChKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogZmlsZSwgQk9PTCBtb2R1bGUpIHsKICBKU1ZhbHVlIHZhbDsKICBpbnQzMl90IHJldCA9IDA7CiAgdmFsID0ganNtX2V2YWxfZmlsZShjdHgsIGZpbGUsIG1vZHVsZSk7CiAgaWYoSlNfSXNFeGNlcHRpb24odmFsKSkgewogICAgZnByaW50ZihzdGRlcnIsICJGYWlsZWQgbG9hZGluZyAnJXMnOiAlc1xuIiwgZmlsZSwgc3RyZXJyb3IoZXJybm8pKTsKICAgIGpzX3ZhbHVlX2Z3cml0ZShjdHgsIHZhbCwgc3RkZXJyKTsKICAgIHJldHVybiAtMTsKICB9IGVsc2UgaWYoSlNfSXNNb2R1bGUodmFsKSkgewogICAgSlNWYWx1ZSBnbG9iYWwgPSBKU19HZXRHbG9iYWxPYmplY3QoY3R4KTsKICAgIGdldF9tb2R1bGVfZXhwb3J0cyhjdHgsIEpTX1ZBTFVFX0dFVF9QVFIodmFsKSwgVFJVRSwgZ2xvYmFsKTsKICB9IGVsc2UgewogICAgSlNfVG9JbnQzMihjdHgsICZyZXQsIHZhbCk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWwpOwogIH0KICByZXR1cm4gcmV0Owp9CgovKiBhbHNvIHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGUgd29ya2VyIGNvbnRleHQgKi8Kc3RhdGljIEpTQ29udGV4dCoKanNtX2NvbnRleHRfbmV3KEpTUnVudGltZSogcnQpIHsKICBKU0NvbnRleHQqIGN0eDsKICBjdHggPSBKU19OZXdDb250ZXh0KHJ0KTsKICBpZighY3R4KQogICAgcmV0dXJuIDA7CiNpZmRlZiBDT05GSUdfQklHTlVNCiAgaWYoYmlnbnVtX2V4dCkgewogICAgSlNfQWRkSW50cmluc2ljQmlnRmxvYXQoY3R4KTsKICAgIEpTX0FkZEludHJpbnNpY0JpZ0RlY2ltYWwoY3R4KTsKICAgIEpTX0FkZEludHJpbnNpY09wZXJhdG9ycyhjdHgpOwogICAgSlNfRW5hYmxlQmlnbnVtRXh0KGN0eCwgVFJVRSk7CiAgfQojZW5kaWYKCiNkZWZpbmUganNtX21vZHVsZV9uYXRpdmUobmFtZSkganNfaW5pdF9tb2R1bGVfIyNuYW1lKGN0eCwgI25hbWUpOwoKICBqc21fbW9kdWxlX25hdGl2ZShzdGQpOwogIGpzbV9tb2R1bGVfbmF0aXZlKG9zKTsKI2lmbmRlZiBfX3dhc2lfXwogIGpzbV9tb2R1bGVfbmF0aXZlKGNoaWxkX3Byb2Nlc3MpOwojZW5kaWYKICBqc21fbW9kdWxlX25hdGl2ZShkZWVwKTsKICBqc21fbW9kdWxlX25hdGl2ZShpbnNwZWN0KTsKICBqc21fbW9kdWxlX25hdGl2ZShsZXhlcik7CiAganNtX21vZHVsZV9uYXRpdmUobWlzYyk7CiNpZm5kZWYgX193YXNpX18KICBqc21fbW9kdWxlX25hdGl2ZShtbWFwKTsKI2VuZGlmCiAganNtX21vZHVsZV9uYXRpdmUocGF0aCk7CiAganNtX21vZHVsZV9uYXRpdmUocG9pbnRlcik7CiAganNtX21vZHVsZV9uYXRpdmUocHJlZGljYXRlKTsKICBqc21fbW9kdWxlX25hdGl2ZShyZXBlYXRlcik7CiAganNtX21vZHVsZV9uYXRpdmUodHJlZV93YWxrZXIpOwogIGpzbV9tb2R1bGVfbmF0aXZlKHhtbCk7CiAgcmV0dXJuIGN0eDsKfQoKI2lmIGRlZmluZWQoX19BUFBMRV9fKQojZGVmaW5lIE1BTExPQ19PVkVSSEVBRCAwCiNlbHNlCiNkZWZpbmUgTUFMTE9DX09WRVJIRUFEIDgKI2VuZGlmCgpzdHJ1Y3QgdHJhY2VfbWFsbG9jX2RhdGEgewogIHVpbnQ4X3QqIGJhc2U7Cn07CgpzdGF0aWMgdm9pZApkdW1wX3ZlY3Rvcihjb25zdCBWZWN0b3IqIHZlYywgc2l6ZV90IHN0YXJ0KSB7CiAgc2l6ZV90IGksIGxlbiA9IHZlY3Rvcl9zaXplKHZlYywgc2l6ZW9mKGNoYXIqKSk7CiAgZm9yKGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7CiAgICBjb25zdCBjaGFyKiBzdHIgPSAqKGNoYXIqKil2ZWN0b3JfYXQodmVjLCBzaXplb2YoY2hhciopLCBpKTsKICAgIGZwdXRzKGkgPiBzdGFydCA/ICInLFxuICAnIiA6ICJbXG4gICciLCBzdGRvdXQpOwogICAgZnB1dHMoc3RyLCBzdGRvdXQpOwogICAgaWYoaSArIDEgPT0gbGVuKQogICAgICBwdXRzKCInXG5dIik7CiAgfQp9CgpzdGF0aWMgaW5saW5lIHVuc2lnbmVkIGxvbmcgbG9uZwpqc21fdHJhY2VfbWFsbG9jX3B0cl9vZmZzZXQodWludDhfdCogcHRyLCBzdHJ1Y3QgdHJhY2VfbWFsbG9jX2RhdGEqIGRwKSB7CiAgcmV0dXJuIHB0ciAtIGRwLT5iYXNlOwp9CgovKiBkZWZhdWx0IG1lbW9yeSBhbGxvY2F0aW9uIGZ1bmN0aW9ucyB3aXRoIG1lbW9yeSBsaW1pdGF0aW9uICovCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmpzbV90cmFjZV9tYWxsb2NfdXNhYmxlX3NpemUodm9pZCogcHRyKSB7CiNpZiBkZWZpbmVkKF9fQVBQTEVfXykKICByZXR1cm4gbWFsbG9jX3NpemUocHRyKTsKI2VsaWYgZGVmaW5lZChfV0lOMzIpCiAgcmV0dXJuIF9tc2l6ZShwdHIpOwojZWxpZiBkZWZpbmVkKEVNU0NSSVBURU4pIHx8IGRlZmluZWQoX19kaWV0bGliY19fKSB8fCBkZWZpbmVkKF9fTVNZU19fKSB8fCBkZWZpbmVkKERPTlRfSEFWRV9NQUxMT0NfVVNBQkxFX1NJWkUpCiAgcmV0dXJuIDA7CiNlbGlmIGRlZmluZWQoX19saW51eF9fKSB8fCBkZWZpbmVkKEhBVkVfTUFMTE9DX1VTQUJMRV9TSVpFKQogIHJldHVybiBtYWxsb2NfdXNhYmxlX3NpemUocHRyKTsKI2Vsc2UKICAvKiBjaGFuZ2UgdGhpcyB0byBgcmV0dXJuIDA7YCBpZiBjb21waWxhdGlvbiBmYWlscyAqLwogIHJldHVybiBtYWxsb2NfdXNhYmxlX3NpemUocHRyKTsKI2VuZGlmCn0KCnN0YXRpYyB2b2lkCiNpZmRlZiBfV0lOMzIKICAgIC8qIG1pbmd3IHByaW50ZiBpcyB1c2VkICovCiAgICBfX2F0dHJpYnV0ZV9fKChmb3JtYXQoZ251X3ByaW50ZiwgMiwgMykpKQojZWxzZQogICAgX19hdHRyaWJ1dGVfXygoZm9ybWF0KHByaW50ZiwgMiwgMykpKQojZW5kaWYKICAgIGpzbV90cmFjZV9tYWxsb2NfcHJpbnRmKEpTTWFsbG9jU3RhdGUqIHMsIGNvbnN0IGNoYXIqIGZtdCwgLi4uKSB7CiAgdmFfbGlzdCBhcDsKICBpbnQgYzsKCiAgdmFfc3RhcnQoYXAsIGZtdCk7CiAgd2hpbGUoKGMgPSAqZm10KyspICE9ICdcMCcpIHsKICAgIGlmKGMgPT0gJyUnKSB7CiAgICAgIC8qIG9ubHkgaGFuZGxlICVwIGFuZCAlemQgKi8KICAgICAgaWYoKmZtdCA9PSAncCcpIHsKICAgICAgICB1aW50OF90KiBwdHIgPSB2YV9hcmcoYXAsIHZvaWQqKTsKICAgICAgICBpZihwdHIgPT0gMCkgewogICAgICAgICAgcHJpbnRmKCIwIik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHByaW50ZigiSCUrMDZsbGQuJXpkIiwganNtX3RyYWNlX21hbGxvY19wdHJfb2Zmc2V0KHB0ciwgcy0+b3BhcXVlKSwganNtX3RyYWNlX21hbGxvY191c2FibGVfc2l6ZShwdHIpKTsKICAgICAgICB9CiAgICAgICAgZm10Kys7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KICAgICAgaWYoZm10WzBdID09ICd6JyAmJiBmbXRbMV0gPT0gJ2QnKSB7CiAgICAgICAgc2l6ZV90IHN6ID0gdmFfYXJnKGFwLCBzaXplX3QpOwogICAgICAgIHByaW50ZigiJXpkIiwgc3opOwogICAgICAgIGZtdCArPSAyOwogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICB9CiAgICBwdXRjKGMsIHN0ZG91dCk7CiAgfQogIHZhX2VuZChhcCk7Cn0KCnN0YXRpYyB2b2lkCmpzbV90cmFjZV9tYWxsb2NfaW5pdChzdHJ1Y3QgdHJhY2VfbWFsbG9jX2RhdGEqIHMpIHsKICBmcmVlKHMtPmJhc2UgPSBtYWxsb2MoOCkpOwp9CgpzdGF0aWMgdm9pZCoKanNtX3RyYWNlX21hbGxvYyhKU01hbGxvY1N0YXRlKiBzLCBzaXplX3Qgc2l6ZSkgewogIHZvaWQqIHB0cjsKCiAgLyogRG8gbm90IGFsbG9jYXRlIHplcm8gYnl0ZXM6IGJlaGF2aW9yIGlzIHBsYXRmb3JtIGRlcGVuZGVudCAqLwogIGFzc2VydChzaXplICE9IDApOwoKICBpZih1bmxpa2VseShzLT5tYWxsb2Nfc2l6ZSArIHNpemUgPiBzLT5tYWxsb2NfbGltaXQpKQogICAgcmV0dXJuIDA7CiAgcHRyID0gbWFsbG9jKHNpemUpOwogIGpzbV90cmFjZV9tYWxsb2NfcHJpbnRmKHMsICJBICV6ZCAtPiAlcFxuIiwgc2l6ZSwgcHRyKTsKICBpZihwdHIpIHsKICAgIHMtPm1hbGxvY19jb3VudCsrOwogICAgcy0+bWFsbG9jX3NpemUgKz0ganNtX3RyYWNlX21hbGxvY191c2FibGVfc2l6ZShwdHIpICsgTUFMTE9DX09WRVJIRUFEOwogIH0KICByZXR1cm4gcHRyOwp9CgpzdGF0aWMgdm9pZApqc21fdHJhY2VfZnJlZShKU01hbGxvY1N0YXRlKiBzLCB2b2lkKiBwdHIpIHsKICBpZighcHRyKQogICAgcmV0dXJuOwoKICBqc21fdHJhY2VfbWFsbG9jX3ByaW50ZihzLCAiRiAlcFxuIiwgcHRyKTsKICBzLT5tYWxsb2NfY291bnQtLTsKICBzLT5tYWxsb2Nfc2l6ZSAtPSBqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplKHB0cikgKyBNQUxMT0NfT1ZFUkhFQUQ7CiAgZnJlZShwdHIpOwp9CgpzdGF0aWMgdm9pZCoKanNtX3RyYWNlX3JlYWxsb2MoSlNNYWxsb2NTdGF0ZSogcywgdm9pZCogcHRyLCBzaXplX3Qgc2l6ZSkgewogIHNpemVfdCBvbGRfc2l6ZTsKCiAgaWYoIXB0cikgewogICAgaWYoc2l6ZSA9PSAwKQogICAgICByZXR1cm4gMDsKICAgIHJldHVybiBqc21fdHJhY2VfbWFsbG9jKHMsIHNpemUpOwogIH0KICBvbGRfc2l6ZSA9IGpzbV90cmFjZV9tYWxsb2NfdXNhYmxlX3NpemUocHRyKTsKICBpZihzaXplID09IDApIHsKICAgIGpzbV90cmFjZV9tYWxsb2NfcHJpbnRmKHMsICJSICV6ZCAlcFxuIiwgc2l6ZSwgcHRyKTsKICAgIHMtPm1hbGxvY19jb3VudC0tOwogICAgcy0+bWFsbG9jX3NpemUgLT0gb2xkX3NpemUgKyBNQUxMT0NfT1ZFUkhFQUQ7CiAgICBmcmVlKHB0cik7CiAgICByZXR1cm4gMDsKICB9CiAgaWYocy0+bWFsbG9jX3NpemUgKyBzaXplIC0gb2xkX3NpemUgPiBzLT5tYWxsb2NfbGltaXQpCiAgICByZXR1cm4gMDsKCiAganNtX3RyYWNlX21hbGxvY19wcmludGYocywgIlIgJXpkICVwIiwgc2l6ZSwgcHRyKTsKCiAgcHRyID0gcmVhbGxvYyhwdHIsIHNpemUpOwogIGpzbV90cmFjZV9tYWxsb2NfcHJpbnRmKHMsICIgLT4gJXBcbiIsIHB0cik7CiAgaWYocHRyKSB7CiAgICBzLT5tYWxsb2Nfc2l6ZSArPSBqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplKHB0cikgLSBvbGRfc2l6ZTsKICB9CiAgcmV0dXJuIHB0cjsKfQoKc3RhdGljIGNvbnN0IEpTTWFsbG9jRnVuY3Rpb25zIHRyYWNlX21mID0gewogICAganNtX3RyYWNlX21hbGxvYywKICAgIGpzbV90cmFjZV9mcmVlLAogICAganNtX3RyYWNlX3JlYWxsb2MsCiNpZiBkZWZpbmVkKF9fQVBQTEVfXykKICAgIG1hbGxvY19zaXplLAojZWxpZiBkZWZpbmVkKF9XSU4zMikKICAgIChzaXplX3QoKikoY29uc3Qgdm9pZCopKV9tc2l6ZSwKI2VsaWYgZGVmaW5lZChFTVNDUklQVEVOKSB8fCBkZWZpbmVkKF9fZGlldGxpYmNfXykgfHwgZGVmaW5lZChfX01TWVNfXykgfHwgZGVmaW5lZChET05UX0hBVkVfTUFMTE9DX1VTQUJMRV9TSVpFX0RFRklOSVRJT04pCiAgICAwLAojZWxpZiBkZWZpbmVkKF9fbGludXhfXykgfHwgZGVmaW5lZChIQVZFX01BTExPQ19VU0FCTEVfU0laRSkKICAgIChzaXplX3QoKikoY29uc3Qgdm9pZCopKW1hbGxvY191c2FibGVfc2l6ZSwKI2Vsc2UKICAgIC8qIGNoYW5nZSB0aGlzIHRvIGAwLGAgaWYgY29tcGlsYXRpb24gZmFpbHMgKi8KICAgIG1hbGxvY191c2FibGVfc2l6ZSwKI2VuZGlmCn07CgojZGVmaW5lIFBST0dfTkFNRSAicWpzbSIKCnZvaWQKanNtX2hlbHAodm9pZCkgewogIHByaW50ZigiUXVpY2tKUyB2ZXJzaW9uICIgQ09ORklHX1ZFUlNJT04gIlxuIgogICAgICAgICAidXNhZ2U6ICIgUFJPR19OQU1FICIgW29wdGlvbnNdIFtmaWxlIFthcmdzXV1cbiIKICAgICAgICAgIi1oICAtLWhlbHAgICAgICAgICBsaXN0IG9wdGlvbnNcbiIKICAgICAgICAgIi1lICAtLWV2YWwgRVhQUiAgICBldmFsdWF0ZSBFWFBSXG4iCiAgICAgICAgICItaSAgLS1pbnRlcmFjdGl2ZSAgZ28gdG8gaW50ZXJhY3RpdmUgbW9kZVxuIgogICAgICAgICAiLW0gIC0tbW9kdWxlIE5BTUUgIGxvYWQgYW4gRVM2IG1vZHVsZVxuIgogICAgICAgICAiLUkgIC0taW5jbHVkZSBmaWxlIGluY2x1ZGUgYW4gYWRkaXRpb25hbCBmaWxlXG4iCiAgICAgICAgICIgICAgLS1zdGQgICAgICAgICAgbWFrZSAnc3RkJyBhbmQgJ29zJyBhdmFpbGFibGUgdG8gdGhlIGxvYWRlZCBzY3JpcHRcbiIKI2lmZGVmIENPTkZJR19CSUdOVU0KICAgICAgICAgIiAgICAtLW5vLWJpZ251bSAgICBkaXNhYmxlIHRoZSBiaWdudW0gZXh0ZW5zaW9ucyAoQmlnRmxvYXQsICIKICAgICAgICAgIkJpZ0RlY2ltYWwpXG4iCiAgICAgICAgICIgICAgLS1xanNjYWxjICAgICAgbG9hZCB0aGUgUUpTQ2FsYyBydW50aW1lIChkZWZhdWx0IGlmIGludm9rZWQgYXMgIgogICAgICAgICAicWpzY2FsYylcbiIKI2VuZGlmCiAgICAgICAgICItVCAgLS10cmFjZSAgICAgICAgdHJhY2UgbWVtb3J5IGFsbG9jYXRpb25cbiIKICAgICAgICAgIi1kICAtLWR1bXAgICAgICAgICBkdW1wIHRoZSBtZW1vcnkgdXNhZ2Ugc3RhdHNcbiIKICAgICAgICAgIiAgICAtLW1lbW9yeS1saW1pdCBuICAgICAgIGxpbWl0IHRoZSBtZW1vcnkgdXNhZ2UgdG8gJ24nIGJ5dGVzXG4iCiAgICAgICAgICIgICAgLS1zdGFjay1zaXplIG4gICAgICAgICBsaW1pdCB0aGUgc3RhY2sgc2l6ZSB0byAnbicgYnl0ZXNcbiIKICAgICAgICAgIiAgICAtLXVuaGFuZGxlZC1yZWplY3Rpb24gIGR1bXAgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uc1xuIgogICAgICAgICAiLXEgIC0tcXVpdCAgICAgICAgIGp1c3QgaW5zdGFudGlhdGUgdGhlIGludGVycHJldGVyIGFuZCBxdWl0XG4iKTsKICBleGl0KDEpOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc21fZXZhbF9zY3JpcHQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10sIGludCBtYWdpYykgewogIGNvbnN0IGNoYXIqIHN0cjsKICBzaXplX3QgbGVuOwogIEpTVmFsdWUgcmV0OwogIGludDMyX3QgbW9kdWxlOwogIHN0ciA9IEpTX1RvQ1N0cmluZ0xlbihjdHgsICZsZW4sIGFyZ3ZbMF0pOwogIGlmKGFyZ2MgPiAxKQogICAgSlNfVG9JbnQzMihjdHgsICZtb2R1bGUsIGFyZ3ZbMV0pOwogIGVsc2UKICAgIG1vZHVsZSA9IHN0cl9lbmRzKHN0ciwgIi5tanMiKTsKICBzd2l0Y2gobWFnaWMpIHsKICAgIGNhc2UgMDogewogICAgICByZXQgPSBqc21fZXZhbF9maWxlKGN0eCwgc3RyLCBtb2R1bGUpOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgMTogewogICAgICByZXQgPSBldmFsX2J1ZihjdHgsIHN0ciwgbGVuLCAwLCBtb2R1bGUpOwogICAgICBicmVhazsKICAgIH0KICB9CiAgaWYoSlNfSXNFeGNlcHRpb24ocmV0KSkgewogICAgaWYoSlNfSXNOdWxsKEpTX0dldFJ1bnRpbWUoY3R4KS0+Y3VycmVudF9leGNlcHRpb24pKSB7CiAgICAgIHJldCA9IEpTX0dldEV4Y2VwdGlvbihjdHgpOwogICAgICAvLyByZXQgPSBKU19VTkRFRklORUQ7CiAgICB9CiAgfQogIGlmKEpTX1ZBTFVFX0dFVF9UQUcocmV0KSA9PSBKU19UQUdfTU9EVUxFKSB7CiAgICBKU01vZHVsZURlZiogZGVmID0gSlNfVkFMVUVfR0VUX1BUUihyZXQpOwogICAgSlNWYWx1ZSBvYmogPSBKU19OZXdPYmplY3QoY3R4KTsKICAgIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgb2JqLCAibmFtZSIsIG1vZHVsZV9uYW1lKGN0eCwgZGVmKSk7CiAgICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgImV4cG9ydHMiLCBtb2R1bGVfZXhwb3J0cyhjdHgsIGRlZikpOwogICAgcmV0ID0gb2JqOwogIH0KICBKU19GcmVlQ1N0cmluZyhjdHgsIHN0cik7CiAgcmV0dXJuIHJldDsKfQoKZW51bSB7CiAgRklORF9NT0RVTEUsCiAgTE9BRF9NT0RVTEUsCiAgUkVTT0xWRV9NT0RVTEUsCiAgR0VUX01PRFVMRV9OQU1FLAogIEdFVF9NT0RVTEVfT0JKRUNULAogIEdFVF9NT0RVTEVfRVhQT1JUUywKICBHRVRfTU9EVUxFX05BTUVTUEFDRSwKICBHRVRfTU9EVUxFX0ZVTkNUSU9OLAogIEdFVF9NT0RVTEVfRVhDRVBUSU9OLAogIEdFVF9NT0RVTEVfTUVUQV9PQkosCn07CgpzdGF0aWMgSlNWYWx1ZQpqc21fbW9kdWxlX2Z1bmMoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10sIGludCBtYWdpYykgewogIEpTVmFsdWUgdmFsID0gSlNfRVhDRVBUSU9OOwogIEpTTW9kdWxlRGVmKiBkZWYgPSAwOwogIGNvbnN0IGNoYXIqIG5hbWUgPSAwOwoKICBpZihtYWdpYyA+PSBHRVRfTU9EVUxFX05BTUUpIHsKICAgIGlmKCEoZGVmID0ganNfbW9kdWxlX2RlZihjdHgsIGFyZ3ZbMF0pKSkKICAgICAgcmV0dXJuIEpTX1Rocm93VHlwZUVycm9yKGN0eCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICIlczogYXJndW1lbnQgMSBleHBlY3RpbmcgbW9kdWxlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoY29uc3QgY2hhciogY29uc3RbXSl7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImdldE1vZHVsZU5hbWUiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJnZXRNb2R1bGVPYmplY3QiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJnZXRNb2R1bGVFeHBvcnRzIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZ2V0TW9kdWxlTmFtZXNwYWNlIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZ2V0TW9kdWxlRnVuY3Rpb24iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJnZXRNb2R1bGVFeGNlcHRpb24iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJnZXRNb2R1bGVNZXRhT2JqZWN0IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pW21hZ2ljIC0gM10pOwogIH0gZWxzZSB7CiAgICBuYW1lID0gSlNfVG9DU3RyaW5nKGN0eCwgYXJndlswXSk7CiAgfQoKICBzd2l0Y2gobWFnaWMpIHsKICAgIGNhc2UgRklORF9NT0RVTEU6IHsKICAgICAgaWYoKGRlZiA9IGpzX21vZHVsZV9maW5kKGN0eCwgbmFtZSkpKQogICAgICAgIHZhbCA9IEpTX0R1cFZhbHVlKGN0eCwgSlNfTUtQVFIoSlNfVEFHX01PRFVMRSwgZGVmKSk7CiAgICAgIGVsc2UKICAgICAgICB2YWwgPSBKU19OVUxMOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgTE9BRF9NT0RVTEU6IHsKICAgICAgSW1wb3J0RGlyZWN0aXZlIGltcDsKICAgICAgbWVtc2V0KCZpbXAsIDAsIHNpemVvZihpbXApKTsKICAgICAgaW50IHIsIG4gPSBjb3VudG9mKGltcC5hcmdzKTsKICAgICAgciA9IGpzX3N0cnZfY29weXMoY3R4LCBhcmdjLCBhcmd2LCBuLCBpbXAuYXJncyk7CiAgICAgIC8vIHByaW50ZigiTE9BRF9NT0RVTEUgcj0laSBhcmdjPSVpXG4iLCByLCBhcmdjKTsKCiAgICAgIHZhbCA9IGpzX2ltcG9ydF9ldmFsKGN0eCwgaW1wKTsKCiAgICAgIC8qICAgaWYoSlNfSXNNb2R1bGUodmFsKSkKICAgICAgICAgICBkZWYgPSBKU19WQUxVRV9HRVRfUFRSKHZhbCk7CiAgICAgICAgIGVsc2UqLwogICAgICBkZWYgPSBqc19tb2R1bGVfZmluZChjdHgsIGltcC5wYXRoKTsKCiAgICAgIGlmKGRlZikKICAgICAgICB2YWwgPSBtb2R1bGVfb2JqZWN0KGN0eCwgZGVmKTsKCiAgICAgIGpzX3N0cnZfZnJlZV9uKGN0eCwgbiwgaW1wLmFyZ3MpOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgUkVTT0xWRV9NT0RVTEU6IHsKICAgICAgdmFsID0gSlNfTmV3SW50MzIoY3R4LCBKU19SZXNvbHZlTW9kdWxlKGN0eCwgSlNfTUtQVFIoSlNfVEFHX01PRFVMRSwgZGVmKSkpOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgR0VUX01PRFVMRV9OQU1FOiB7CiAgICAgIHZhbCA9IG1vZHVsZV9uYW1lKGN0eCwgZGVmKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEdFVF9NT0RVTEVfT0JKRUNUOiB7CiAgICAgIHZhbCA9IG1vZHVsZV9vYmplY3QoY3R4LCBkZWYpOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgR0VUX01PRFVMRV9FWFBPUlRTOiB7CiAgICAgIHZhbCA9IG1vZHVsZV9leHBvcnRzKGN0eCwgZGVmKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEdFVF9NT0RVTEVfTkFNRVNQQUNFOiB7CiAgICAgIHZhbCA9IEpTX0R1cFZhbHVlKGN0eCwgZGVmLT5tb2R1bGVfbnMpOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgR0VUX01PRFVMRV9GVU5DVElPTjogewoKICAgICAgdmFsID0gbW9kdWxlX2Z1bmMoY3R4LCBkZWYpOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgR0VUX01PRFVMRV9FWENFUFRJT046IHsKICAgICAgaWYoZGVmLT5ldmFsX2hhc19leGNlcHRpb24pCiAgICAgICAgdmFsID0gSlNfRHVwVmFsdWUoY3R4LCBkZWYtPmV2YWxfZXhjZXB0aW9uKTsKICAgICAgZWxzZQogICAgICAgIHZhbCA9IEpTX05VTEw7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBHRVRfTU9EVUxFX01FVEFfT0JKOiB7CiAgICAgIHZhbCA9IEpTX0R1cFZhbHVlKGN0eCwgZGVmLT5tZXRhX29iaik7CiAgICAgIGJyZWFrOwogICAgfQogIH0KICBpZihuYW1lKQogICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBuYW1lKTsKCiAgcmV0dXJuIHZhbDsKfQoKc3RhdGljIGNvbnN0IEpTQ0Z1bmN0aW9uTGlzdEVudHJ5IGpzbV9nbG9iYWxfZnVuY3NbXSA9IHsKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZXZhbEZpbGUiLCAxLCBqc21fZXZhbF9zY3JpcHQsIDApLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJldmFsU2NyaXB0IiwgMSwganNtX2V2YWxfc2NyaXB0LCAxKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJtb2R1bGVMaXN0IiwganNfbW9kdWxlc19hcnJheSwgMCwgMCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigibW9kdWxlT2JqZWN0IiwganNfbW9kdWxlc19vYmplY3QsIDAsIDApLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoIm1vZHVsZU1hcCIsIGpzX21vZHVsZXNfbWFwLCAwLCAwKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZmluZE1vZHVsZSIsIDEsIGpzbV9tb2R1bGVfZnVuYywgRklORF9NT0RVTEUpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJsb2FkTW9kdWxlIiwgMSwganNtX21vZHVsZV9mdW5jLCBMT0FEX01PRFVMRSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoInJlc29sdmVNb2R1bGUiLCAxLCBqc21fbW9kdWxlX2Z1bmMsIFJFU09MVkVfTU9EVUxFKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0TW9kdWxlTmFtZSIsIDEsIGpzbV9tb2R1bGVfZnVuYywgR0VUX01PRFVMRV9OQU1FKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0TW9kdWxlT2JqZWN0IiwgMSwganNtX21vZHVsZV9mdW5jLCBHRVRfTU9EVUxFX09CSkVDVCksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImdldE1vZHVsZUV4cG9ydHMiLCAxLCBqc21fbW9kdWxlX2Z1bmMsIEdFVF9NT0RVTEVfRVhQT1JUUyksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImdldE1vZHVsZU5hbWVzcGFjZSIsIDEsIGpzbV9tb2R1bGVfZnVuYywgR0VUX01PRFVMRV9OQU1FU1BBQ0UpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRNb2R1bGVGdW5jdGlvbiIsIDEsIGpzbV9tb2R1bGVfZnVuYywgR0VUX01PRFVMRV9GVU5DVElPTiksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImdldE1vZHVsZUV4Y2VwdGlvbiIsIDEsIGpzbV9tb2R1bGVfZnVuYywgR0VUX01PRFVMRV9FWENFUFRJT04pLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRNb2R1bGVNZXRhT2JqZWN0IiwgMSwganNtX21vZHVsZV9mdW5jLCBHRVRfTU9EVUxFX01FVEFfT0JKKSwKfTsKCmludAptYWluKGludCBhcmdjLCBjaGFyKiogYXJndikgewogIEpTUnVudGltZSogcnQ7CiAgSlNDb250ZXh0KiBjdHg7CiAgc3RydWN0IHRyYWNlX21hbGxvY19kYXRhIHRyYWNlX2RhdGEgPSB7MH07CiAgaW50IG9wdGluZDsKICBjaGFyKiBleHByID0gMDsKICBpbnQgaW50ZXJhY3RpdmUgPSAwOwogIGludCBkdW1wX21lbW9yeSA9IDA7CiAgaW50IHRyYWNlX21lbW9yeSA9IDA7CiAgaW50IGVtcHR5X3J1biA9IDA7CiAgaW50IG1vZHVsZSA9IDE7CiAgaW50IGxvYWRfc3RkID0gMTsKICBpbnQgZHVtcF91bmhhbmRsZWRfcHJvbWlzZV9yZWplY3Rpb24gPSAwOwogIHNpemVfdCBtZW1vcnlfbGltaXQgPSAwOwogIGNoYXIqIGluY2x1ZGVfbGlzdFszMl07CiAgaW50IGksIGluY2x1ZGVfY291bnQgPSAwOwojaWZkZWYgQ09ORklHX0JJR05VTQogIGludCBsb2FkX2pzY2FsYzsKI2VuZGlmCiAgc2l6ZV90IHN0YWNrX3NpemUgPSAwOwogIGNvbnN0IGNoYXIqIGV4ZW5hbWU7CgogIHBhY2thZ2VfanNvbiA9IEpTX1VOREVGSU5FRDsKCiAgaW5pdF9saXN0X2hlYWQoJnBvbGxoYW5kbGVycyk7CgogIHsKICAgIGNvbnN0IGNoYXIqIHA7CiAgICBleGVuYW1lID0gYXJndlswXTsKICAgIHAgPSBzdHJyY2hyKGV4ZW5hbWUsICcvJyk7CiAgICBpZihwKQogICAgICBleGVuYW1lID0gcCArIDE7CiAgICAvKiBsb2FkIGpzY2FsYyBydW50aW1lIGlmIGludm9rZWQgYXMgJ3Fqc2NhbGMnICovCiAgICBsb2FkX2pzY2FsYyA9ICFzdHJjbXAoZXhlbmFtZSwgInFqc2NhbGMiKTsKICB9CgogIC8qIGNhbm5vdCB1c2UgZ2V0b3B0IGJlY2F1c2Ugd2Ugd2FudCB0byBwYXNzIHRoZSBjb21tYW5kIGxpbmUgdG8KICAgICB0aGUgc2NyaXB0ICovCiAgb3B0aW5kID0gMTsKICB3aGlsZShvcHRpbmQgPCBhcmdjICYmICphcmd2W29wdGluZF0gPT0gJy0nKSB7CiAgICBjaGFyKiBhcmcgPSBhcmd2W29wdGluZF0gKyAxOwogICAgY29uc3QgY2hhciogbG9uZ29wdCA9ICIiOwogICAgY29uc3QgY2hhciogb3B0YXJnOwoKICAgIC8qIGEgc2luZ2xlIC0gaXMgbm90IGFuIG9wdGlvbiwgaXQgYWxzbyBzdG9wcyBhcmd1bWVudCBzY2FubmluZyAqLwogICAgaWYoISphcmcpCiAgICAgIGJyZWFrOwoKICAgIGlmKGFyZ1sxXSkgewogICAgICBvcHRhcmcgPSAmYXJnWzFdOwogICAgfSBlbHNlIHsKICAgICAgb3B0YXJnID0gYXJndlsrK29wdGluZF07CiAgICB9CgogICAgaWYoKmFyZyA9PSAnLScpIHsKICAgICAgbG9uZ29wdCA9IGFyZyArIDE7CiAgICAgIGFyZyArPSBzdHJsZW4oYXJnKTsKICAgICAgLyogLS0gc3RvcHMgYXJndW1lbnQgc2Nhbm5pbmcgKi8KICAgICAgaWYoISpsb25nb3B0KQogICAgICAgIGJyZWFrOwogICAgfQogICAgZm9yKDsgKmFyZyB8fCAqbG9uZ29wdDsgbG9uZ29wdCA9ICIiKSB7CiAgICAgIGNoYXIgb3B0ID0gKmFyZzsKICAgICAgaWYob3B0KQogICAgICAgIGFyZysrOwogICAgICBpZihvcHQgPT0gJ2gnIHx8IG9wdCA9PSAnPycgfHwgIXN0cmNtcChsb25nb3B0LCAiaGVscCIpKSB7CiAgICAgICAganNtX2hlbHAoKTsKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICBpZihvcHQgPT0gJ2UnIHx8ICFzdHJjbXAobG9uZ29wdCwgImV2YWwiKSkgewogICAgICAgIGlmKCphcmcpIHsKICAgICAgICAgIGV4cHIgPSBhcmc7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgaWYob3B0aW5kIDwgYXJnYykgewogICAgICAgICAgZXhwciA9IGFyZ3Zbb3B0aW5kKytdOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIGZwcmludGYoc3RkZXJyLCAiJXM6IG1pc3NpbmcgZXhwcmVzc2lvbiBmb3IgLWVcbiIsIGV4ZW5hbWUpOwogICAgICAgIGV4aXQoMik7CiAgICAgIH0KICAgICAgaWYob3B0ID09ICdJJyB8fCAhc3RyY21wKGxvbmdvcHQsICJpbmNsdWRlIikpIHsKICAgICAgICBpZihvcHRpbmQgPj0gYXJnYykgewogICAgICAgICAgZnByaW50ZihzdGRlcnIsICJleHBlY3RpbmcgZmlsZW5hbWUiKTsKICAgICAgICAgIGV4aXQoMSk7CiAgICAgICAgfQogICAgICAgIGlmKGluY2x1ZGVfY291bnQgPj0gY291bnRvZihpbmNsdWRlX2xpc3QpKSB7CiAgICAgICAgICBmcHJpbnRmKHN0ZGVyciwgInRvbyBtYW55IGluY2x1ZGVkIGZpbGVzIik7CiAgICAgICAgICBleGl0KDEpOwogICAgICAgIH0KICAgICAgICBpbmNsdWRlX2xpc3RbaW5jbHVkZV9jb3VudCsrXSA9IG9wdGFyZzsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZihvcHQgPT0gJ2knIHx8ICFzdHJjbXAobG9uZ29wdCwgImludGVyYWN0aXZlIikpIHsKICAgICAgICBpbnRlcmFjdGl2ZSsrOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmKG9wdCA9PSAnbScgfHwgIXN0cmNtcChsb25nb3B0LCAibW9kdWxlIikpIHsKICAgICAgICBjb25zdCBjaGFyKiBtb2R1bGVzID0gYXJndltvcHRpbmRdOwogICAgICAgIHNpemVfdCBpLCBsZW47CgogICAgICAgIGZvcihpID0gMDsgbW9kdWxlc1tpXTsgaSArPSBsZW4pIHsKICAgICAgICAgIGxlbiA9IHN0cl9jaHIoJm1vZHVsZXNbaV0sICcsJyk7CiAgICAgICAgICB2ZWN0b3JfcHV0cHRyKCZtb2R1bGVfbGlzdCwgc3RyX25kdXAoJm1vZHVsZXNbaV0sIGxlbikpOwoKICAgICAgICAgIGlmKG1vZHVsZXNbaSArIGxlbl0gPT0gJywnKQogICAgICAgICAgICBsZW4rKzsKICAgICAgICB9CgogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmKG9wdCA9PSAnZCcgfHwgIXN0cmNtcChsb25nb3B0LCAiZHVtcCIpKSB7CiAgICAgICAgZHVtcF9tZW1vcnkrKzsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZihvcHQgPT0gJ1QnIHx8ICFzdHJjbXAobG9uZ29wdCwgInRyYWNlIikpIHsKICAgICAgICB0cmFjZV9tZW1vcnkrKzsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZighc3RyY21wKGxvbmdvcHQsICJzdGQiKSkgewogICAgICAgIGxvYWRfc3RkID0gMTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZighc3RyY21wKGxvbmdvcHQsICJ1bmhhbmRsZWQtcmVqZWN0aW9uIikpIHsKICAgICAgICBkdW1wX3VuaGFuZGxlZF9wcm9taXNlX3JlamVjdGlvbiA9IDE7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KI2lmZGVmIENPTkZJR19CSUdOVU0KICAgICAgaWYoIXN0cmNtcChsb25nb3B0LCAibm8tYmlnbnVtIikpIHsKICAgICAgICBiaWdudW1fZXh0ID0gMDsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZighc3RyY21wKGxvbmdvcHQsICJiaWdudW0iKSkgewogICAgICAgIGJpZ251bV9leHQgPSAxOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmKCFzdHJjbXAobG9uZ29wdCwgInFqc2NhbGMiKSkgewogICAgICAgIGxvYWRfanNjYWxjID0gMTsKICAgICAgICBicmVhazsKICAgICAgfQojZW5kaWYKICAgICAgaWYob3B0ID09ICdxJyB8fCAhc3RyY21wKGxvbmdvcHQsICJxdWl0IikpIHsKICAgICAgICBlbXB0eV9ydW4rKzsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZighc3RyY21wKGxvbmdvcHQsICJtZW1vcnktbGltaXQiKSkgewogICAgICAgIGlmKG9wdGluZCA+PSBhcmdjKSB7CiAgICAgICAgICBmcHJpbnRmKHN0ZGVyciwgImV4cGVjdGluZyBtZW1vcnkgbGltaXQiKTsKICAgICAgICAgIGV4aXQoMSk7CiAgICAgICAgfQogICAgICAgIG1lbW9yeV9saW1pdCA9IChzaXplX3Qpc3RydG9kKGFyZ3Zbb3B0aW5kKytdLCAwKTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZighc3RyY21wKGxvbmdvcHQsICJzdGFjay1zaXplIikpIHsKICAgICAgICBpZihvcHRpbmQgPj0gYXJnYykgewogICAgICAgICAgZnByaW50ZihzdGRlcnIsICJleHBlY3Rpbmcgc3RhY2sgc2l6ZSIpOwogICAgICAgICAgZXhpdCgxKTsKICAgICAgICB9CiAgICAgICAgc3RhY2tfc2l6ZSA9IChzaXplX3Qpc3RydG9kKGFyZ3Zbb3B0aW5kKytdLCAwKTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZihvcHQpIHsKICAgICAgICBmcHJpbnRmKHN0ZGVyciwgIiVzOiB1bmtub3duIG9wdGlvbiAnLSVjJ1xuIiwgZXhlbmFtZSwgb3B0KTsKICAgICAgfSBlbHNlIHsKICAgICAgICBmcHJpbnRmKHN0ZGVyciwgIiVzOiB1bmtub3duIG9wdGlvbiAnLS0lcydcbiIsIGV4ZW5hbWUsIGxvbmdvcHQpOwogICAgICB9CiAgICAgIGpzbV9oZWxwKCk7CiAgICB9CiAgICBvcHRpbmQrKzsKICB9CgogIHsKICAgIGNvbnN0IGNoYXIqIG1vZHVsZXM7CgogICAgaWYoKG1vZHVsZXMgPSBnZXRlbnYoIkRFQlVHIikpKSB7CiAgICAgIHNpemVfdCBpLCBsZW47CiAgICAgIGZvcihpID0gMDsgbW9kdWxlc1tpXTsgaSArPSBsZW4pIHsKICAgICAgICBsZW4gPSBzdHJfY2hyKCZtb2R1bGVzW2ldLCAnLCcpOwogICAgICAgIHZlY3Rvcl9wdXRwdHIoJm1vZHVsZV9kZWJ1Zywgc3RyX25kdXAoJm1vZHVsZXNbaV0sIGxlbikpOwoKICAgICAgICBpZihtb2R1bGVzW2kgKyBsZW5dID09ICcsJykKICAgICAgICAgIGxlbisrOwogICAgICB9CgogICAgICBkZWJ1Z19tb2R1bGVfbG9hZGVyID0gdmVjdG9yX2NvdW50cygmbW9kdWxlX2RlYnVnLCAibW9kdWxlcyIpOwogICAgfQogIH0KCiAgaWYobG9hZF9qc2NhbGMpCiAgICBiaWdudW1fZXh0ID0gMTsKCiAgaWYodHJhY2VfbWVtb3J5KSB7CiAgICBqc21fdHJhY2VfbWFsbG9jX2luaXQoJnRyYWNlX2RhdGEpOwogICAgcnQgPSBKU19OZXdSdW50aW1lMigmdHJhY2VfbWYsICZ0cmFjZV9kYXRhKTsKICB9IGVsc2UgewogICAgcnQgPSBKU19OZXdSdW50aW1lKCk7CiAgfQogIGlmKCFydCkgewogICAgZnByaW50ZihzdGRlcnIsICIlczogY2Fubm90IGFsbG9jYXRlIEpTIHJ1bnRpbWVcbiIsIGV4ZW5hbWUpOwogICAgZXhpdCgyKTsKICB9CgogIEpTX1NldE1vZHVsZUxvYWRlckZ1bmMocnQsIDAsIGpzbV9tb2R1bGVfbG9hZGVyLCAwKTsKCiAgaWYobWVtb3J5X2xpbWl0ICE9IDApCiAgICBKU19TZXRNZW1vcnlMaW1pdChydCwgbWVtb3J5X2xpbWl0KTsKICAvLyBpZiAoc3RhY2tfc2l6ZSAhPSAwKQogIEpTX1NldE1heFN0YWNrU2l6ZShydCwgc3RhY2tfc2l6ZSAhPSAwID8gc3RhY2tfc2l6ZSA6IDI1NiAqIDEwNDg1NzYpOwoKICBqc19zdGRfc2V0X3dvcmtlcl9uZXdfY29udGV4dF9mdW5jKGpzbV9jb250ZXh0X25ldyk7CgogIGpzX3N0ZF9pbml0X2hhbmRsZXJzKHJ0KTsKICBjdHggPSBqc21fY29udGV4dF9uZXcocnQpOwogIGlmKCFjdHgpIHsKICAgIGZwcmludGYoc3RkZXJyLCAiJXM6IGNhbm5vdCBhbGxvY2F0ZSBKUyBjb250ZXh0XG4iLCBleGVuYW1lKTsKICAgIGV4aXQoMik7CiAgfQoKICAvKiBsb2FkZXIgZm9yIEVTNiBtb2R1bGVzICovCiAgSlNfU2V0TW9kdWxlTG9hZGVyRnVuYyhydCwganNfbW9kdWxlX25vcm1hbGl6ZSwganNtX21vZHVsZV9sb2FkZXIsIDApOwogIC8vIGpzX3N0ZF9zZXRfbW9kdWxlX2xvYWRlcl9mdW5jKGpzbV9tb2R1bGVfbG9hZGVyKTsKCiAgaWYoZHVtcF91bmhhbmRsZWRfcHJvbWlzZV9yZWplY3Rpb24pIHsKICAgIEpTX1NldEhvc3RQcm9taXNlUmVqZWN0aW9uVHJhY2tlcihydCwganNfc3RkX3Byb21pc2VfcmVqZWN0aW9uX3RyYWNrZXIsIDApOwogIH0KCiAgaWYoIWVtcHR5X3J1bikgewojaWZkZWYgQ09ORklHX0JJR05VTQogICAgaWYobG9hZF9qc2NhbGMpIHsKICAgICAganNfZXZhbF9iaW5hcnkoY3R4LCBxanNjX3Fqc2NhbGMsIHFqc2NfcWpzY2FsY19zaXplLCAwKTsKICAgIH0KI2VuZGlmCiAgICBqc19zdGRfYWRkX2hlbHBlcnMoY3R4LCBhcmdjIC0gb3B0aW5kLCBhcmd2ICsgb3B0aW5kKTsKCiAgICBpbnQgbnVtX25hdGl2ZSwgbnVtX2NvbXBpbGVkOwoKI2RlZmluZSBqc21fYnVpbHRpbl9uYXRpdmUobmFtZSkgdmVjdG9yX3B1dHB0cigmYnVpbHRpbnMsICNuYW1lKQoKICAgIGpzbV9idWlsdGluX25hdGl2ZShzdGQpOwogICAganNtX2J1aWx0aW5fbmF0aXZlKG9zKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShjaGlsZF9wcm9jZXNzKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShkZWVwKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShpbnNwZWN0KTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShsZXhlcik7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUobWlzYyk7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUobW1hcCk7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUocGF0aCk7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUocG9pbnRlcik7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUocHJlZGljYXRlKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShyZXBlYXRlcik7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUodHJlZV93YWxrZXIpOwogICAganNtX2J1aWx0aW5fbmF0aXZlKHhtbCk7CiAgICBudW1fbmF0aXZlID0gdmVjdG9yX3NpemUoJmJ1aWx0aW5zLCBzaXplb2YoY2hhciopKTsKCiAgICAvLyBwcmludGYoIm5hdGl2ZSBidWlsdGluczogIik7IGR1bXBfdmVjdG9yKCZidWlsdGlucywgMCk7CgojZGVmaW5lIGpzbV9idWlsdGluX2NvbXBpbGVkKG5hbWUpIFwKICBqc19zdGRfZXZhbF9iaW5hcnkoY3R4LCBxanNjXyMjbmFtZSwgcWpzY18jI25hbWUjI19zaXplLCAwKTsgXAogIHZlY3Rvcl9wdXRwdHIoJmJ1aWx0aW5zLCAjbmFtZSkKCiAgICBqc21fYnVpbHRpbl9jb21waWxlZChjb25zb2xlKTsKICAgIGpzbV9idWlsdGluX2NvbXBpbGVkKGV2ZW50cyk7CiAgICBqc21fYnVpbHRpbl9jb21waWxlZChmcyk7CiAgICBqc21fYnVpbHRpbl9jb21waWxlZChwZXJmX2hvb2tzKTsKICAgIGpzbV9idWlsdGluX2NvbXBpbGVkKHByb2Nlc3MpOwogICAgLy8ganNtX2J1aWx0aW5fY29tcGlsZWQocmVwbCk7CiAgICBqc21fYnVpbHRpbl9jb21waWxlZChyZXF1aXJlKTsKICAgIGpzbV9idWlsdGluX2NvbXBpbGVkKHR0eSk7CiAgICBqc21fYnVpbHRpbl9jb21waWxlZCh1dGlsKTsKCiAgICBudW1fY29tcGlsZWQgPSB2ZWN0b3Jfc2l6ZSgmYnVpbHRpbnMsIHNpemVvZihjaGFyKikpIC0gbnVtX25hdGl2ZTsKCiAgICB7CiAgICAgIGNvbnN0IGNoYXIqIHN0ciA9ICJpbXBvcnQgcHJvY2VzcyBmcm9tICdwcm9jZXNzJztcbmdsb2JhbFRoaXMucHJvY2VzcyA9IHByb2Nlc3M7XG4iOwogICAgICBqc19ldmFsX3N0cihjdHgsIHN0ciwgMCwgSlNfRVZBTF9UWVBFX01PRFVMRSk7CiAgICB9CgogICAgSlNfU2V0UHJvcGVydHlGdW5jdGlvbkxpc3QoY3R4LCBKU19HZXRHbG9iYWxPYmplY3QoY3R4KSwganNtX2dsb2JhbF9mdW5jcywgY291bnRvZihqc21fZ2xvYmFsX2Z1bmNzKSk7CiAgICBpZihsb2FkX3N0ZCkgewogICAgICBjb25zdCBjaGFyKiBzdHIgPSAiaW1wb3J0ICogYXMgc3RkIGZyb20gJ3N0ZCc7XG5pbXBvcnQgKiBhcyBvcyBmcm9tICIKICAgICAgICAgICAgICAgICAgICAgICAgIidvcyc7XG5nbG9iYWxUaGlzLnN0ZCA9ICIKICAgICAgICAgICAgICAgICAgICAgICAgInN0ZDtcbmdsb2JhbFRoaXMub3MgIgogICAgICAgICAgICAgICAgICAgICAgICAiPSBvcztcbmdsb2JhbFRoaXMuc2V0VGltZW91dCA9ICIKICAgICAgICAgICAgICAgICAgICAgICAgIm9zLnNldFRpbWVvdXQ7XG5nbG9iYWxUaGlzLmNsZWFyVGltZW91dCA9ICIKICAgICAgICAgICAgICAgICAgICAgICAgIm9zLmNsZWFyVGltZW91dDtcbiI7CiAgICAgIGpzX2V2YWxfc3RyKGN0eCwgc3RyLCAwLCBKU19FVkFMX1RZUEVfTU9EVUxFKTsKICAgIH0KCiAgICAvLyBqc21fbGlzdF9tb2R1bGVzKGN0eCk7CgogICAgewogICAgICBjaGFyKiogbmFtZTsKICAgICAgSlNNb2R1bGVEZWYqIG07CiAgICAgIHZlY3Rvcl9mb3JlYWNoX3QoJm1vZHVsZV9saXN0LCBuYW1lKSB7CiAgICAgICAgaWYoIShtID0ganNfbW9kdWxlX2ltcG9ydF9uYW1lc3BhY2UoY3R4LCAqbmFtZSwgMCkpKSB7CiAgICAgICAgICBmcHJpbnRmKHN0ZGVyciwgImVycm9yIGxvYWRpbmcgbW9kdWxlICclcydcbiIsICpuYW1lKTsKICAgICAgICAgIGpzbV9kdW1wX2Vycm9yKGN0eCk7CiAgICAgICAgICBleGl0KDEpOwogICAgICAgIH0KICAgICAgICBmcmVlKCpuYW1lKTsKICAgICAgfQogICAgICB2ZWN0b3JfZnJlZSgmbW9kdWxlX2xpc3QpOwogICAgfQoKICAgIGZvcihpID0gMDsgaSA8IGluY2x1ZGVfY291bnQ7IGkrKykgewogICAgICBpZihqc21fbG9hZF9zY3JpcHQoY3R4LCBpbmNsdWRlX2xpc3RbaV0sIG1vZHVsZSkgPT0gLTEpCiAgICAgICAgZ290byBmYWlsOwogICAgfQoKICAgIGlmKGV4cHIpIHsKICAgICAgaWYoanNfZXZhbF9zdHIoY3R4LCBleHByLCAiPGNtZGxpbmU+IiwgMCkgPT0gLTEpCiAgICAgICAgZ290byBmYWlsOwogICAgfSBlbHNlIGlmKG9wdGluZCA+PSBhcmdjKSB7CiAgICAgIC8qIGludGVyYWN0aXZlIG1vZGUgKi8KICAgICAgaW50ZXJhY3RpdmUgPSAxOwogICAgfSBlbHNlIHsKICAgICAgY29uc3QgY2hhciogZmlsZW5hbWU7CiAgICAgIGZpbGVuYW1lID0gYXJndltvcHRpbmRdOwogICAgICBpZihqc21fbG9hZF9zY3JpcHQoY3R4LCBmaWxlbmFtZSwgbW9kdWxlKSA9PSAtMSkgewogICAgICAgIGpzX3ZhbHVlX2Z3cml0ZShjdHgsIEpTX0dldEV4Y2VwdGlvbihjdHgpLCBzdGRlcnIpOwogICAgICAgIGdvdG8gZmFpbDsKICAgICAgfQogICAgfQogICAgaWYoaW50ZXJhY3RpdmUpIHsKICAgICAgY2hhciBzdHJbNTEyXTsKICAgICAgY29uc3QgY2hhciogaG9tZSA9IGdldGVudigiSE9NRSIpOwoKICAgICAgc25wcmludGYoc3RyLAogICAgICAgICAgICAgICBzaXplb2Yoc3RyKSwKICAgICAgICAgICAgICAgImltcG9ydCBSRVBMIGZyb20gJ3JlcGwnO1xuIgogICAgICAgICAgICAgICAiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbiIKICAgICAgICAgICAgICAgImNvbnN0IGhpc3RvcnkgPSAnJXMvLiVzX2hpc3RvcnknO1xuIgogICAgICAgICAgICAgICAiZ2xvYmFsVGhpcy5yZXBsID0gbmV3IFJFUEwoJ3Fqc20nKTtcbiIKICAgICAgICAgICAgICAgInJlcGwuZnMgPSBmcztcbiIKICAgICAgICAgICAgICAgInJlcGwuc2hvdyA9IGNvbnNvbGUubG9nO1xuIgogICAgICAgICAgICAgICAicmVwbC5oaXN0b3J5TG9hZChoaXN0b3J5KTtcbiIKICAgICAgICAgICAgICAgInJlcGwuYWRkQ2xlYW51cEhhbmRsZXIoKCkgPT4gcmVwbC5oaXN0b3J5U2F2ZShoaXN0b3J5KSk7XG4iCiAgICAgICAgICAgICAgICJyZXBsLnJ1blN5bmMoKTtcbiIsCiAgICAgICAgICAgICAgIGhvbWUsCiAgICAgICAgICAgICAgIGV4ZW5hbWUpOwogICAgICBwcmludGYoInN0cjogJXNcbiIsIHN0cik7CiAgICAgIGpzX2V2YWxfYmluYXJ5KGN0eCwgcWpzY19yZXBsLCBxanNjX3JlcGxfc2l6ZSwgMCk7CiAgICAgIGpzX2V2YWxfc3RyKGN0eCwgc3RyLCAwLCBKU19FVkFMX1RZUEVfTU9EVUxFKTsKICAgIH0KCiAgICBqc19zdGRfbG9vcChjdHgpOwogIH0KCiAgaWYoIUpTX0lzTnVsbChjdHgtPnJ0LT5jdXJyZW50X2V4Y2VwdGlvbikpCiAgICBqc21fZHVtcF9lcnJvcihjdHgpOwoKICBpZihkdW1wX21lbW9yeSkgewogICAgSlNNZW1vcnlVc2FnZSBzdGF0czsKICAgIEpTX0NvbXB1dGVNZW1vcnlVc2FnZShydCwgJnN0YXRzKTsKICAgIEpTX0R1bXBNZW1vcnlVc2FnZShzdGRvdXQsICZzdGF0cywgcnQpOwogIH0KICBqc19zdGRfZnJlZV9oYW5kbGVycyhydCk7CiAgSlNfRnJlZUNvbnRleHQoY3R4KTsKICBKU19GcmVlUnVudGltZShydCk7CgogIGlmKGVtcHR5X3J1biAmJiBkdW1wX21lbW9yeSkgewogICAgY2xvY2tfdCB0WzVdOwogICAgZG91YmxlIGJlc3RbNV07CiAgICBpbnQgaSwgajsKICAgIGZvcihpID0gMDsgaSA8IDEwMDsgaSsrKSB7CiAgICAgIHRbMF0gPSBjbG9jaygpOwogICAgICBydCA9IEpTX05ld1J1bnRpbWUoKTsKICAgICAgdFsxXSA9IGNsb2NrKCk7CiAgICAgIGN0eCA9IEpTX05ld0NvbnRleHQocnQpOwogICAgICB0WzJdID0gY2xvY2soKTsKICAgICAgSlNfRnJlZUNvbnRleHQoY3R4KTsKICAgICAgdFszXSA9IGNsb2NrKCk7CiAgICAgIEpTX0ZyZWVSdW50aW1lKHJ0KTsKICAgICAgdFs0XSA9IGNsb2NrKCk7CiAgICAgIGZvcihqID0gNDsgaiA+IDA7IGotLSkgewogICAgICAgIGRvdWJsZSBtcyA9IDEwMDAuMCAqICh0W2pdIC0gdFtqIC0gMV0pIC8gQ0xPQ0tTX1BFUl9TRUM7CiAgICAgICAgaWYoaSA9PSAwIHx8IGJlc3Rbal0gPiBtcykKICAgICAgICAgIGJlc3Rbal0gPSBtczsKICAgICAgfQogICAgfQogICAgcHJpbnRmKCJcbkluc3RhbnRpYXRpb24gdGltZXMgKG1zKTogJS4zZiA9ICUuM2YrJS4zZislLjNmKyUuM2ZcbiIsIGJlc3RbMV0gKyBiZXN0WzJdICsgYmVzdFszXSArIGJlc3RbNF0sIGJlc3RbMV0sIGJlc3RbMl0sIGJlc3RbM10sIGJlc3RbNF0pOwogIH0KICByZXR1cm4gMDsKZmFpbDoKICBqc19zdGRfZnJlZV9oYW5kbGVycyhydCk7CiAgSlNfRnJlZUNvbnRleHQoY3R4KTsKICBKU19GcmVlUnVudGltZShydCk7CiAgcmV0dXJuIDE7Cn0KAAAAAAAAAACpbgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAZGcAAAAAAABvZwAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "quickjs-inspect.c",
			"settings":
			{
				"buffer_size": 34538,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					139,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AQAAAKxeAAAAAAAArV4AAAAAAAAAAAAA",
					"AwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKxeAAAAAAAArF4AAAAAAAAAAAAAAADwvw"
				],
				[
					140,
					1,
					"paste",
					null,
					"AQAAAK1eAAAAAAAA014AAAAAAAAAAAAA",
					"AwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAK1eAAAAAAAArV4AAAAAAAAAAAAAAADwvw"
				],
				[
					143,
					1,
					"insert",
					{
						"characters": "!("
					},
					"AgAAALZeAAAAAAAAt14AAAAAAAAAAAAAt14AAAAAAAC4XgAAAAAAAAAAAAA",
					"AwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALZeAAAAAAAAtl4AAAAAAAAAAAAAAADwvw"
				],
				[
					146,
					1,
					"insert",
					{
						"characters": ")"
					},
					"AQAAANJeAAAAAAAA014AAAAAAAAAAAAA",
					"AwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANJeAAAAAAAA0l4AAAAAAAAAAAAAAADwvw"
				],
				[
					147,
					1,
					"left_delete",
					null,
					"AQAAANJeAAAAAAAA0l4AAAAAAAABAAAAKQ",
					"AwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANNeAAAAAAAA014AAAAAAAAAAAAAAADwvw"
				],
				[
					148,
					1,
					"insert",
					{
						"characters": ")"
					},
					"AQAAANJeAAAAAAAA014AAAAAAAAAAAAA",
					"AwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANJeAAAAAAAA0l4AAAAAAAAAAAAAAADwvw"
				],
				[
					151,
					1,
					"left_delete",
					null,
					"AQAAANZeAAAAAAAA1l4AAAAAAAABAAAACg",
					"AwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANdeAAAAAAAA114AAAAAAAAAAAAAAADwvw"
				],
				[
					153,
					1,
					"insert",
					{
						"characters": "}"
					},
					"AQAAADxhAAAAAAAAPWEAAAAAAAAAAAAA",
					"AwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAADxhAAAAAAAAPGEAAAAAAAAAAAAAAAAAAA"
				],
				[
					154,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AQAAAD1hAAAAAAAAPmEAAAAAAAAAAAAA",
					"AwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAD1hAAAAAAAAPWEAAAAAAAAAAAAAAADwvw"
				],
				[
					156,
					1,
					"revert",
					null,
					"BAAAAAAAAAAAAAAAAAAAAAAAAAByiAAAI2luY2x1ZGUgImN1dGlscy5oIgojaW5jbHVkZSAiaXRlcmF0aW9uLmgiCiNpbmNsdWRlICJsaXN0LmgiCiNpbmNsdWRlICJwcm9wZXJ0eS1lbnVtZXJhdGlvbi5oIgojaW5jbHVkZSAicXVpY2tqcy1pbnRlcm5hbC5oIgojaW5jbHVkZSAicXVpY2tqcy5oIgojaW5jbHVkZSAicXVpY2tqcy1jb25maWcuaCIKI2luY2x1ZGUgInV0aWxzLmgiCiNpbmNsdWRlICJ2ZWN0b3IuaCIKI2luY2x1ZGUgImJ1ZmZlci11dGlscy5oIgoKI2luY2x1ZGUgPGN0eXBlLmg+CiNpbmNsdWRlIDxtYXRoLmg+CiNpbmNsdWRlIDxzdHJpbmcuaD4KI2luY2x1ZGUgPHN5cy9pb2N0bC5oPgojaW5jbHVkZSA8dW5pc3RkLmg+CiNpZmRlZiBIQVZFX1RFUk1JT1NfSAojaW5jbHVkZSA8dGVybWlvcy5oPgojZW5kaWYKCnRocmVhZF9sb2NhbCBKU0F0b20gaW5zcGVjdF9jdXN0b21fYXRvbSA9IDAsIGluc3BlY3RfY3VzdG9tX2F0b21fbm9kZSA9IDA7CgojZGVmaW5lIElOU1BFQ1RfSU5UMzJUX0lOUkFOR0UoaSkgKChpKSA+IElOVDMyX01JTiAmJiAoaSkgPCBJTlQzMl9NQVgpCiNkZWZpbmUgSU5TUEVDVF9MRVZFTChvcHRzKSAoKG9wdHMpLT5kZXB0aCAtIChkZXB0aCkpCiNkZWZpbmUgSU5TUEVDVF9JU19DT01QQUNUKG9wdHMpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICgob3B0cyktPmNvbXBhY3QgPT0gSU5UMzJfTUFYID8gVFJVRSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgOiBJTlNQRUNUX0lOVDMyVF9JTlJBTkdFKChvcHRzKS0+Y29tcGFjdCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICAgICA/ICgob3B0cyktPmNvbXBhY3QgPCAwID8gSU5TUEVDVF9MRVZFTChvcHRzKSA+PSAtKG9wdHMtPmNvbXBhY3QpIDogSU5TUEVDVF9MRVZFTChvcHRzKSA+PSAob3B0cyktPmNvbXBhY3QpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgICAgOiAwKQoKdHlwZWRlZiBzdHJ1Y3QgewogIGludCBjb2xvcnMgOiAxOwogIGludCBzaG93X2hpZGRlbiA6IDE7CiAgaW50IGN1c3RvbV9pbnNwZWN0IDogMTsKICBpbnQgc2hvd19wcm94eSA6IDE7CiAgaW50IGdldHRlcnMgOiAxOwogIGludCBzdHJpbmdfYnJlYWtfbmV3bGluZSA6IDE7CiAgaW50MzJfdCBkZXB0aDsKICBpbnQzMl90IG1heF9hcnJheV9sZW5ndGg7CiAgaW50MzJfdCBtYXhfc3RyaW5nX2xlbmd0aDsKICBpbnQzMl90IGJyZWFrX2xlbmd0aDsKICBpbnQzMl90IGNvbXBhY3Q7CiAgaW50MzJfdCBwcm90b19jaGFpbjsKICBpbnQzMl90IG51bWJlcl9iYXNlOwogIFZlY3RvciBoaWRlX2tleXM7Cn0gaW5zcGVjdF9vcHRpb25zX3Q7CgpzdHJ1Y3QgcHJvcF9rZXk7Cgp0eXBlZGVmIHN0cnVjdCBwcm9wX2tleSB7CiAgc3RydWN0IGxpc3RfaGVhZCBsaW5rOwogIGNvbnN0IGNoYXIqIG5hbWU7CiAgSlNBdG9tIGF0b207Cn0gcHJvcF9rZXlfdDsKCnN0YXRpYyBpbnQgc3Rkb3V0X2lzYXR0eSwgc3RkZXJyX2lzYXR0eTsKc3RhdGljIGludDMyX3Qgc2NyZWVuX3dpZHRoID0gLTE7CgpzdGF0aWMgaW50IGpzX2luc3BlY3RfcHJpbnQoSlNDb250ZXh0KiBjdHgsIER5bkJ1ZiogYnVmLCBKU1ZhbHVlQ29uc3QgdmFsdWUsIGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBpbnQzMl90IGRlcHRoKTsKCnN0YXRpYyBpbnQKcmVnZXhwX3ByZWRpY2F0ZShpbnQgYykgewogIHN3aXRjaChjKSB7CiAgICBjYXNlIDg6IHJldHVybiAndSc7CiAgICBjYXNlIDEyOiByZXR1cm4gJ2YnOwogICAgY2FzZSAxMDogcmV0dXJuICduJzsKICAgIGNhc2UgMTM6IHJldHVybiAncic7CiAgICBjYXNlIDk6IHJldHVybiAndCc7CiAgICBjYXNlIDExOiByZXR1cm4gJ3YnOwogIH0KICBpZihjIDwgMHgyMCkKICAgIHJldHVybiAndSc7CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbmxpbmUgaW50Cmluc3BlY3Rfc2NyZWVuX3dpZHRoKHZvaWQpIHsKICBpZihzY3JlZW5fd2lkdGggIT0gLTEpCiAgICByZXR1cm4gc2NyZWVuX3dpZHRoOwoKI2lmZGVmIEhBVkVfVEVSTUlPU19ICiAgewogICAgICBzdHJ1Y3Qgd2luc2l6ZSB3ID0gey53c19jb2wgPSAtMSwgLndzX3JvdyA9IC0xfTsKCiAgaWYoc3Rkb3V0X2lzYXR0eSkKICAgIGlvY3RsKFNURE9VVF9GSUxFTk8sIFRJT0NHV0lOU1osICZ3KTsKICBlbHNlIGlmKHN0ZGVycl9pc2F0dHkpCiAgICBpb2N0bChTVERFUlJfRklMRU5PLCBUSU9DR1dJTlNaLCAmdyk7CgogIHJldHVybiBzY3JlZW5fd2lkdGggPSB3LndzX2NvbDsKfQojZWxzZQogIHJldHVybiA4MDsKI2VuZGlmCn0KCnN0YXRpYyB2b2lkCmluc3BlY3Rfb3B0aW9uc19pbml0KGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBKU0NvbnRleHQqIGN0eCkgewogIG9wdHMtPmNvbG9ycyA9IFRSVUU7CiAgb3B0cy0+c2hvd19oaWRkZW4gPSBGQUxTRTsKICBvcHRzLT5jdXN0b21faW5zcGVjdCA9IFRSVUU7CiAgb3B0cy0+c2hvd19wcm94eSA9IEZBTFNFOwogIG9wdHMtPmdldHRlcnMgPSBGQUxTRTsKICBvcHRzLT5zdHJpbmdfYnJlYWtfbmV3bGluZSA9IEZBTFNFOwogIG9wdHMtPmRlcHRoID0gSU5UMzJfTUFYOwogIG9wdHMtPm1heF9hcnJheV9sZW5ndGggPSAzMDA7CiAgb3B0cy0+bWF4X3N0cmluZ19sZW5ndGggPSBJTlQzMl9NQVg7CiAgb3B0cy0+YnJlYWtfbGVuZ3RoID0gaW5zcGVjdF9zY3JlZW5fd2lkdGgoKTsKICBvcHRzLT5jb21wYWN0ID0gNTsKICBvcHRzLT5wcm90b19jaGFpbiA9IDA7CiAgb3B0cy0+bnVtYmVyX2Jhc2UgPSAxMDsKICB2ZWN0b3JfaW5pdCgmb3B0cy0+aGlkZV9rZXlzLCBjdHgpOwp9CgpzdGF0aWMgdm9pZAppbnNwZWN0X29wdGlvbnNfZnJlZShpbnNwZWN0X29wdGlvbnNfdCogb3B0cywgSlNDb250ZXh0KiBjdHgpIHsKCiAgcHJvcF9rZXlfdCoga2V5OwoKICB2ZWN0b3JfZm9yZWFjaF90KCZvcHRzLT5oaWRlX2tleXMsIGtleSkgewogICAgSlNfRnJlZUF0b20oY3R4LCBrZXktPmF0b20pOwogICAganNfY3N0cmluZ19mcmVlKGN0eCwga2V5LT5uYW1lKTsKICB9CiAgdmVjdG9yX2ZyZWUoJm9wdHMtPmhpZGVfa2V5cyk7Cn0KCnN0YXRpYyB2b2lkCmluc3BlY3Rfb3B0aW9uc19nZXQoaW5zcGVjdF9vcHRpb25zX3QqIG9wdHMsIEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqZWN0KSB7CiAgSlNWYWx1ZSB2YWx1ZTsKICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqZWN0LCAiY29sb3JzIik7CiAgaWYoIUpTX0lzRXhjZXB0aW9uKHZhbHVlKSAmJiAhSlNfSXNVbmRlZmluZWQodmFsdWUpKSB7CiAgICBvcHRzLT5jb2xvcnMgPSBKU19Ub0Jvb2woY3R4LCB2YWx1ZSk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgfQoKICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqZWN0LCAic2hvd0hpZGRlbiIpOwogIGlmKCFKU19Jc0V4Y2VwdGlvbih2YWx1ZSkgJiYgIUpTX0lzVW5kZWZpbmVkKHZhbHVlKSkgewogICAgb3B0cy0+c2hvd19oaWRkZW4gPSBKU19Ub0Jvb2woY3R4LCB2YWx1ZSk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgfQogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJjdXN0b21JbnNwZWN0Iik7CiAgaWYoIUpTX0lzRXhjZXB0aW9uKHZhbHVlKSAmJiAhSlNfSXNVbmRlZmluZWQodmFsdWUpKSB7CiAgICBvcHRzLT5jdXN0b21faW5zcGVjdCA9IEpTX1RvQm9vbChjdHgsIHZhbHVlKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICB9CgogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJzaG93UHJveHkiKTsKICBpZighSlNfSXNFeGNlcHRpb24odmFsdWUpICYmICFKU19Jc1VuZGVmaW5lZCh2YWx1ZSkpIHsKICAgIG9wdHMtPnNob3dfcHJveHkgPSBKU19Ub0Jvb2woY3R4LCB2YWx1ZSk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgfQoKICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqZWN0LCAiZ2V0dGVycyIpOwogIGlmKCFKU19Jc0V4Y2VwdGlvbih2YWx1ZSkgJiYgIUpTX0lzVW5kZWZpbmVkKHZhbHVlKSkgewogICAgb3B0cy0+Z2V0dGVycyA9IEpTX1RvQm9vbChjdHgsIHZhbHVlKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICB9CgogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJzdHJpbmdCcmVha05ld2xpbmUiKTsKICBpZighSlNfSXNFeGNlcHRpb24odmFsdWUpICYmICFKU19Jc1VuZGVmaW5lZCh2YWx1ZSkpIHsKICAgIG9wdHMtPnN0cmluZ19icmVha19uZXdsaW5lID0gSlNfVG9Cb29sKGN0eCwgdmFsdWUpOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIH0KCiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iamVjdCwgImRlcHRoIik7CiAgaWYoIUpTX0lzVW5kZWZpbmVkKHZhbHVlKSAmJiAhSlNfSXNFeGNlcHRpb24odmFsdWUpKSB7CiAgICBpZihKU19WQUxVRV9HRVRfVEFHKHZhbHVlKSA9PSBKU19UQUdfRkxPQVQ2NCAmJiBpc2luZihKU19WQUxVRV9HRVRfRkxPQVQ2NCh2YWx1ZSkpKQogICAgICBvcHRzLT5kZXB0aCA9IElOVDMyX01BWDsKICAgIGVsc2UKICAgICAgSlNfVG9JbnQzMihjdHgsICZvcHRzLT5kZXB0aCwgdmFsdWUpOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIH0KICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqZWN0LCAibWF4QXJyYXlMZW5ndGgiKTsKICBpZighSlNfSXNVbmRlZmluZWQodmFsdWUpICYmICFKU19Jc0V4Y2VwdGlvbih2YWx1ZSkpIHsKICAgIGlmKEpTX1ZBTFVFX0dFVF9UQUcodmFsdWUpID09IEpTX1RBR19GTE9BVDY0ICYmIGlzaW5mKEpTX1ZBTFVFX0dFVF9GTE9BVDY0KHZhbHVlKSkpCiAgICAgIG9wdHMtPm1heF9hcnJheV9sZW5ndGggPSBJTlQzMl9NQVg7CiAgICBlbHNlCiAgICAgIEpTX1RvSW50MzIoY3R4LCAmb3B0cy0+bWF4X2FycmF5X2xlbmd0aCwgdmFsdWUpOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIH0KICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqZWN0LCAibWF4U3RyaW5nTGVuZ3RoIik7CiAgaWYoIUpTX0lzVW5kZWZpbmVkKHZhbHVlKSAmJiAhSlNfSXNFeGNlcHRpb24odmFsdWUpKSB7CiAgICBpZihKU19WQUxVRV9HRVRfVEFHKHZhbHVlKSA9PSBKU19UQUdfRkxPQVQ2NCAmJiBpc2luZihKU19WQUxVRV9HRVRfRkxPQVQ2NCh2YWx1ZSkpKQogICAgICBvcHRzLT5tYXhfc3RyaW5nX2xlbmd0aCA9IElOVDMyX01BWDsKICAgIGVsc2UKICAgICAgSlNfVG9JbnQzMihjdHgsICZvcHRzLT5tYXhfc3RyaW5nX2xlbmd0aCwgdmFsdWUpOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIH0KICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqZWN0LCAiYnJlYWtMZW5ndGgiKTsKICBpZighSlNfSXNVbmRlZmluZWQodmFsdWUpICYmICFKU19Jc0V4Y2VwdGlvbih2YWx1ZSkpIHsKICAgIGlmKEpTX1ZBTFVFX0dFVF9UQUcodmFsdWUpID09IEpTX1RBR19GTE9BVDY0ICYmIGlzaW5mKEpTX1ZBTFVFX0dFVF9GTE9BVDY0KHZhbHVlKSkpCiAgICAgIG9wdHMtPmJyZWFrX2xlbmd0aCA9IElOVDMyX01BWDsKICAgIGVsc2UKICAgICAgSlNfVG9JbnQzMihjdHgsICZvcHRzLT5icmVha19sZW5ndGgsIHZhbHVlKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICB9CiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iamVjdCwgImNvbXBhY3QiKTsKICBpZighSlNfSXNVbmRlZmluZWQodmFsdWUpICYmICFKU19Jc0V4Y2VwdGlvbih2YWx1ZSkpIHsKICAgIGlmKEpTX1ZBTFVFX0dFVF9UQUcodmFsdWUpID09IEpTX1RBR19CT09MKQogICAgICBvcHRzLT5jb21wYWN0ID0gSlNfVkFMVUVfR0VUX0JPT0wodmFsdWUpID09IDAgPyAwIDogSU5UMzJfTUFYOwogICAgZWxzZSBpZihKU19WQUxVRV9HRVRfVEFHKHZhbHVlKSA9PSBKU19UQUdfRkxPQVQ2NCAmJiBpc2luZihKU19WQUxVRV9HRVRfRkxPQVQ2NCh2YWx1ZSkpKQogICAgICBvcHRzLT5jb21wYWN0ID0gSU5UMzJfTUFYOwogICAgZWxzZQogICAgICBKU19Ub0ludDMyKGN0eCwgJm9wdHMtPmNvbXBhY3QsIHZhbHVlKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICB9CiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iamVjdCwgImhpZGVLZXlzIik7CiAgaWYoSlNfSXNBcnJheShjdHgsIHZhbHVlKSkgewogICAgaW50NjRfdCBsZW4sIHBvczsKICAgIGxlbiA9IGpzX2FycmF5X2xlbmd0aChjdHgsIHZhbHVlKTsKCiAgICBmb3IocG9zID0gMDsgcG9zIDwgbGVuOyBwb3MrKykgewogICAgICBKU1ZhbHVlIGl0ZW0gPSBKU19HZXRQcm9wZXJ0eVVpbnQzMihjdHgsIHZhbHVlLCBwb3MpOwogICAgICBwcm9wX2tleV90IGtleTsKICAgICAga2V5Lm5hbWUgPSBKU19WQUxVRV9HRVRfVEFHKGl0ZW0pID09IEpTX1RBR19TWU1CT0wgPyAwIDogSlNfVG9DU3RyaW5nKGN0eCwgaXRlbSk7CiAgICAgIGtleS5hdG9tID0gSlNfVmFsdWVUb0F0b20oY3R4LCBpdGVtKTsKICAgICAgdmVjdG9yX3B1c2goJm9wdHMtPmhpZGVfa2V5cywga2V5KTsKICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgaXRlbSk7CiAgICB9CiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgfQogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJwcm90b0NoYWluIik7CiAgLy8gaWYoSlNfSXNOdW1iZXIodmFsdWUpKQogIEpTX1RvSW50MzIoY3R4LCAmb3B0cy0+cHJvdG9fY2hhaW4sIHZhbHVlKTsKICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CgogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJudW1iZXJCYXNlIik7CiAgaWYoSlNfSXNOdW1iZXIodmFsdWUpKQogICAgSlNfVG9JbnQzMihjdHgsICZvcHRzLT5udW1iZXJfYmFzZSwgdmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKfQoKc3RhdGljIEpTVmFsdWUKaW5zcGVjdF9vcHRpb25zX29iamVjdChpbnNwZWN0X29wdGlvbnNfdCogb3B0cywgSlNDb250ZXh0KiBjdHgpIHsKICBKU1ZhbHVlIGFyciwgcmV0ID0gSlNfTmV3T2JqZWN0KGN0eCk7CiAgdWludDMyX3QgbjsKICBwcm9wX2tleV90KiBrZXk7CgogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAiY29sb3JzIiwgSlNfTmV3Qm9vbChjdHgsIG9wdHMtPmNvbG9ycykpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAic2hvd0hpZGRlbiIsIEpTX05ld0Jvb2woY3R4LCBvcHRzLT5zaG93X2hpZGRlbikpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAiY3VzdG9tSW5zcGVjdCIsIEpTX05ld0Jvb2woY3R4LCBvcHRzLT5jdXN0b21faW5zcGVjdCkpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAic2hvd1Byb3h5IiwgSlNfTmV3Qm9vbChjdHgsIG9wdHMtPnNob3dfcHJveHkpKTsKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgImdldHRlcnMiLCBKU19OZXdCb29sKGN0eCwgb3B0cy0+Z2V0dGVycykpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAic3RyaW5nQnJlYWtOZXdsaW5lIiwgSlNfTmV3Qm9vbChjdHgsIG9wdHMtPnN0cmluZ19icmVha19uZXdsaW5lKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJkZXB0aCIsIGpzX251bWJlcl9uZXcoY3R4LCBvcHRzLT5kZXB0aCkpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAibWF4QXJyYXlMZW5ndGgiLCBqc19udW1iZXJfbmV3KGN0eCwgb3B0cy0+bWF4X2FycmF5X2xlbmd0aCkpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAibWF4U3RyaW5nTGVuZ3RoIiwganNfbnVtYmVyX25ldyhjdHgsIG9wdHMtPm1heF9zdHJpbmdfbGVuZ3RoKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJicmVha0xlbmd0aCIsIGpzX251bWJlcl9uZXcoY3R4LCBvcHRzLT5icmVha19sZW5ndGgpKTsKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgImNvbXBhY3QiLCBqc19uZXdfYm9vbF9vcl9udW1iZXIoY3R4LCBvcHRzLT5jb21wYWN0KSk7CiAgaWYob3B0cy0+cHJvdG9fY2hhaW4pCiAgICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgInByb3RvQ2hhaW4iLCBqc19udW1iZXJfbmV3KGN0eCwgb3B0cy0+cHJvdG9fY2hhaW4pKTsKICBhcnIgPSBKU19OZXdBcnJheShjdHgpOwogIG4gPSAwOwogIHZlY3Rvcl9mb3JlYWNoX3QoJm9wdHMtPmhpZGVfa2V5cywga2V5KSB7IEpTX1NldFByb3BlcnR5VWludDMyKGN0eCwgYXJyLCBuKyssIGpzX2F0b21fdG92YWx1ZShjdHgsIGtleS0+YXRvbSkpOyB9CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJoaWRlS2V5cyIsIGFycik7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJudW1iZXJCYXNlIiwganNfbnVtYmVyX25ldyhjdHgsIG9wdHMtPm51bWJlcl9iYXNlKSk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGludAppbnNwZWN0X29wdGlvbnNfaGlkZGVuKGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBKU0F0b20gYXRvbSkgewogIHByb3Bfa2V5X3QqIGtleTsKICB2ZWN0b3JfZm9yZWFjaF90KCZvcHRzLT5oaWRlX2tleXMsIGtleSkgewogICAgaWYoa2V5LT5hdG9tID09IGF0b20pIC8vISBzdHJjbXAoa2V5LT5uYW1lLCBzdHIpKQogICAgICByZXR1cm4gMTsKICB9CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkCmluc3BlY3RfbmV3bGluZShEeW5CdWYqIGJ1ZiwgaW50MzJfdCBkZXB0aCkgewogIGRidWZfcHV0YyhidWYsICdcbicpOwogIHdoaWxlKGRlcHRoLS0gPiAwKSBkYnVmX3B1dHN0cihidWYsICIgICIpOwp9CgpzdGF0aWMgaW50CmpzX29iamVjdF9nZXRwcm9wZXJ0eW5hbWVzKEpTQ29udGV4dCogY3R4LCB1bmlvbiBWZWN0b3IqIHByb3BlbnVtX3RhYiwgSlNWYWx1ZUNvbnN0IG9iaiwgaW50IGZsYWdzKSB7CiAgaW50IHJldDsKICBKU1Byb3BlcnR5RW51bSogdG1wX3RhYjsKICB1aW50MzJfdCBpLCB0bXBfbGVuOwogIHJldCA9IEpTX0dldE93blByb3BlcnR5TmFtZXMoY3R4LCAmdG1wX3RhYiwgJnRtcF9sZW4sIG9iaiwgZmxhZ3MpOwoKICBmb3IoaSA9IDA7IGkgPCB0bXBfbGVuOyBpKyspIHsKICAgIGlmKHZlY3Rvcl9maW5kKHByb3BlbnVtX3RhYiwgc2l6ZW9mKEpTUHJvcGVydHlFbnVtKSwgJnRtcF90YWJbaV0pID09IC0xKQogICAgICB2ZWN0b3JfcHV0KHByb3BlbnVtX3RhYiwgJnRtcF90YWJbaV0sIHNpemVvZihKU1Byb3BlcnR5RW51bSkpOwogIH0KCiAganNfZnJlZShjdHgsIHRtcF90YWIpOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQKanNfb2JqZWN0X2dldHByb3BlcnR5bmFtZXNfcmVjdXJzaXZlKEpTQ29udGV4dCogY3R4LCB1bmlvbiBWZWN0b3IqIHByb3BlbnVtX3RhYiwgSlNWYWx1ZUNvbnN0IG9iaiwgaW50IGZsYWdzKSB7CiAgaW50IHJldDsKCiAgd2hpbGUoKHJldCA9IGpzX29iamVjdF9nZXRwcm9wZXJ0eW5hbWVzKGN0eCwgcHJvcGVudW1fdGFiLCBvYmosIGZsYWdzKSkgPj0gMCkgewogICAgSlNWYWx1ZSBwcm90byA9IEpTX0dldFByb3RvdHlwZShjdHgsIG9iaik7CgogICAgaWYoIUpTX0lzT2JqZWN0KHByb3RvKSkKICAgICAgYnJlYWs7CgogICAgb2JqID0gcHJvdG87CiAgICAvLyAgICAgIHJldCA9IGpzX29iamVjdF9nZXRwcm9wZXJ0eW5hbWVzX3JlY3Vyc2l2ZShjdHgsIHByb3BlbnVtX3RhYiwgcHJvdG8sIGZsYWdzKTsKICB9CgogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBKU0F0b20KanNfaW5zcGVjdF9jdXN0b21fYXRvbShKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogc3ltX2ZvcikgewogIEpTVmFsdWUga2V5LCBzeW07CiAgSlNBdG9tIGF0b207CiAga2V5ID0gSlNfTmV3U3RyaW5nKGN0eCwgc3ltX2ZvciA/IHN5bV9mb3IgOiAicXVpY2tqcy5pbnNwZWN0LmN1c3RvbSIpOwogIHN5bSA9IGpzX3N5bWJvbF9pbnZva2Vfc3RhdGljKGN0eCwgImZvciIsIGtleSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwga2V5KTsKICBhdG9tID0gSlNfVmFsdWVUb0F0b20oY3R4LCBzeW0pOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHN5bSk7CgogIHJldHVybiBhdG9tOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc19pbnNwZWN0X2N1c3RvbV9jYWxsKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBpbnNwZWN0X29wdGlvbnNfdCogb3B0cywgaW50MzJfdCBkZXB0aCkgewogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwogIEpTVmFsdWUgaW5zcGVjdCA9IEpTX1VOREVGSU5FRDsKICBKU0F0b20gcHJvcDsKCiAgaWYoSlNfVkFMVUVfR0VUX09CSihvYmopLT5jbGFzc19pZCkgewogICAgaWYoSlNfSGFzUHJvcGVydHkoY3R4LCBvYmosIGluc3BlY3RfY3VzdG9tX2F0b20pKQogICAgICBpbnNwZWN0ID0gSlNfR2V0UHJvcGVydHkoY3R4LCBvYmosIGluc3BlY3RfY3VzdG9tX2F0b20pOwogICAgZWxzZSBpZihKU19IYXNQcm9wZXJ0eShjdHgsIG9iaiwgaW5zcGVjdF9jdXN0b21fYXRvbV9ub2RlKSkKICAgICAgaW5zcGVjdCA9IEpTX0dldFByb3BlcnR5KGN0eCwgb2JqLCBpbnNwZWN0X2N1c3RvbV9hdG9tX25vZGUpOwogIH0KICBpZihKU19Jc0Z1bmN0aW9uKGN0eCwgaW5zcGVjdCkpIHsKICAgIEpTVmFsdWVDb25zdCBhcmdzWzJdOwogICAgaW5zcGVjdF9vcHRpb25zX3Qgb3B0c19ub2N1c3RvbTsKICAgIG1lbWNweSgmb3B0c19ub2N1c3RvbSwgb3B0cywgc2l6ZW9mKGluc3BlY3Rfb3B0aW9uc190KSk7CiAgICBvcHRzX25vY3VzdG9tLmN1c3RvbV9pbnNwZWN0ID0gRkFMU0U7CiAgICBhcmdzWzBdID0ganNfbnVtYmVyX25ldyhjdHgsIElOU1BFQ1RfTEVWRUwob3B0cykpOwogICAgYXJnc1sxXSA9IGluc3BlY3Rfb3B0aW9uc19vYmplY3QoJm9wdHNfbm9jdXN0b20sIGN0eCk7CiAgICByZXQgPSBKU19DYWxsKGN0eCwgaW5zcGVjdCwgb2JqLCAyLCBhcmdzKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGFyZ3NbMF0pOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgYXJnc1sxXSk7CiAgICAvKiAgIHN0ciA9IEpTX1RvQ1N0cmluZyhjdHgsIHJldCk7CiAgICAgICBKU19GcmVlVmFsdWUoY3R4LCByZXQpOyovCiAgfQoKICBKU19GcmVlVmFsdWUoY3R4LCBpbnNwZWN0KTsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50CmpzX2luc3BlY3RfbWFwKEpTQ29udGV4dCogY3R4LCBEeW5CdWYqIGJ1ZiwgSlNWYWx1ZUNvbnN0IG9iaiwgaW5zcGVjdF9vcHRpb25zX3QqIG9wdHMsIGludDMyX3QgZGVwdGgpIHsKICBCT09MIHJldCwgZmluaXNoID0gRkFMU0U7CiAgc2l6ZV90IGkgPSAwOwogIGludCBjb21wYWN0ID0gSU5TUEVDVF9JU19DT01QQUNUKG9wdHMpOwogIC8vIHByaW50ZigianNfaW5zcGVjdF9tYXAgbGV2ZWw9JXUgb3B0cy0+ZGVwdGg9JSIgUFJJZDMyICIgZGVwdGg9JSIgUFJJZDMyICIKICAvLyBjb21wYWN0PSVpXG4iLCBJTlNQRUNUX0xFVkVMKG9wdHMpLCBvcHRzLT5kZXB0aCwgZGVwdGgsIGNvbXBhY3QpOwogIEpTVmFsdWUgZGF0YSwga2V5LCB2YWx1ZTsKICBJdGVyYXRpb24gaXQ7CiAgaWYoIShyZXQgPSBpdGVyYXRpb25fbWV0aG9kX3N5bWJvbCgmaXQsIGN0eCwgb2JqLCAiaXRlcmF0b3IiKSkpIHsKICAgIEpTX1Rocm93VHlwZUVycm9yKGN0eCwgImpzX2luc3BlY3RfbWFwIHRhZz0lZFxuIiwgSlNfVkFMVUVfR0VUX1RBRyhvYmopKTsKICAgIHJldHVybiAwOwogIH0KICBkYnVmX3B1dHN0cihidWYsICJNYXAgeyIpOwogIGlmKCFjb21wYWN0ICYmIG9wdHMtPmJyZWFrX2xlbmd0aCAhPSBJTlQzMl9NQVgpCiAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpKTsKICBmb3IoaSA9IDA7ICEoZmluaXNoID0gaXRlcmF0aW9uX25leHQoJml0LCBjdHgpKTsgaSsrKSB7CiAgICBpZighZmluaXNoKSB7CiAgICAgIGRhdGEgPSBpdGVyYXRpb25fdmFsdWUoJml0LCBjdHgpOwogICAgICBpZihpKSB7CiAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCAiLCIpOwogICAgICAgIGlmKCFjb21wYWN0ICYmIG9wdHMtPmJyZWFrX2xlbmd0aCAhPSBJTlQzMl9NQVgpCiAgICAgICAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpKTsKICAgICAgfQogICAgICBkYnVmX3B1dHN0cihidWYsIGNvbXBhY3QgPyAiICIgOiAiICAiKTsKICAgICAga2V5ID0gSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCBkYXRhLCAwKTsKICAgICAganNfaW5zcGVjdF9wcmludChjdHgsIGJ1Ziwga2V5LCBvcHRzLCBkZXB0aCAtIDEpOwogICAgICBkYnVmX3B1dHN0cihidWYsICIgPT4gIik7CiAgICAgIHZhbHVlID0gSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCBkYXRhLCAxKTsKICAgICAganNfaW5zcGVjdF9wcmludChjdHgsIGJ1ZiwgdmFsdWUsIG9wdHMsIGRlcHRoIC0gMSk7CiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGtleSk7CiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgZGF0YSk7CiAgICB9CiAgfQogIGlmKCFjb21wYWN0ICYmIG9wdHMtPmJyZWFrX2xlbmd0aCAhPSBJTlQzMl9NQVgpCiAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpKTsKICBkYnVmX3B1dHN0cihidWYsIGNvbXBhY3QgPyAiIH0iIDogIn0iKTsKICBpdGVyYXRpb25fcmVzZXQoJml0LCBKU19HZXRSdW50aW1lKGN0eCkpOwogIHJldHVybiAwOwp9CgpzdGF0aWMgaW50CmpzX2luc3BlY3Rfc2V0KEpTQ29udGV4dCogY3R4LCBEeW5CdWYqIGJ1ZiwgSlNWYWx1ZUNvbnN0IG9iaiwgaW5zcGVjdF9vcHRpb25zX3QqIG9wdHMsIGludDMyX3QgZGVwdGgpIHsKICBCT09MIHJldCwgZmluaXNoID0gRkFMU0U7CiAgc2l6ZV90IGkgPSAwOwogIGludCBjb21wYWN0ID0gSU5TUEVDVF9JU19DT01QQUNUKG9wdHMpOwogIEpTVmFsdWUgdmFsdWU7CiAgSXRlcmF0aW9uIGl0OwoKICBpZighKHJldCA9IGl0ZXJhdGlvbl9tZXRob2Rfc3ltYm9sKCZpdCwgY3R4LCBvYmosICJpdGVyYXRvciIpKSkgewogICAgSlNfVGhyb3dUeXBlRXJyb3IoY3R4LCAianNfaW5zcGVjdF9tYXAgdGFnPSVkXG4iLCBKU19WQUxVRV9HRVRfVEFHKG9iaikpOwogICAgcmV0dXJuIDA7CiAgfQogIGRidWZfcHV0c3RyKGJ1ZiwgIlNldCBbIik7CiAgaWYoIWNvbXBhY3QgJiYgb3B0cy0+YnJlYWtfbGVuZ3RoICE9IElOVDMyX01BWCkKICAgIGluc3BlY3RfbmV3bGluZShidWYsIElOU1BFQ1RfTEVWRUwob3B0cykpOwogIGZvcihpID0gMDsgIShmaW5pc2ggPSBpdGVyYXRpb25fbmV4dCgmaXQsIGN0eCkpOyBpKyspIHsKICAgIGlmKCFmaW5pc2gpIHsKICAgICAgdmFsdWUgPSBpdGVyYXRpb25fdmFsdWUoJml0LCBjdHgpOwogICAgICBpZihpKSB7CiAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCAiLCIpOwogICAgICAgIGlmKCFjb21wYWN0ICYmIG9wdHMtPmJyZWFrX2xlbmd0aCAhPSBJTlQzMl9NQVgpCiAgICAgICAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpKTsKICAgICAgfQogICAgICBkYnVmX3B1dHN0cihidWYsIGNvbXBhY3QgPyAiICIgOiAiICAiKTsKICAgICAganNfaW5zcGVjdF9wcmludChjdHgsIGJ1ZiwgdmFsdWUsIG9wdHMsIGRlcHRoKTsKICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogICAgfQogIH0KICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgSU5TUEVDVF9MRVZFTChvcHRzKSk7CiAgZGJ1Zl9wdXRzdHIoYnVmLCBjb21wYWN0ID8gIiBdIiA6ICJdIik7CiAgaXRlcmF0aW9uX3Jlc2V0KCZpdCwgSlNfR2V0UnVudGltZShjdHgpKTsKICByZXR1cm4gMDsKfQoKc3RhdGljIGludApqc19pbnNwZWN0X2FycmF5YnVmZmVyKEpTQ29udGV4dCogY3R4LCBEeW5CdWYqIGJ1ZiwgSlNWYWx1ZUNvbnN0IHZhbHVlLCBpbnNwZWN0X29wdGlvbnNfdCogb3B0cywgaW50MzJfdCBkZXB0aCkgewogIGNvbnN0IGNoYXIgKnN0ciwgKnN0cjI7CiAgdWludDhfdCogcHRyOwogIHNpemVfdCBpLCBzbGVuLCBzaXplOwogIGludCBicmVha19sZW4gPSBvcHRzLT5icmVha19sZW5ndGg7IC8vIGluc3BlY3Rfc2NyZWVuX3dpZHRoKCk7CiAgaW50IGNvbHVtbiA9IGRidWZfZ2V0X2NvbHVtbihidWYpOwogIEpTVmFsdWUgcHJvdG87CiAgYnJlYWtfbGVuID0gKGJyZWFrX2xlbiArIDEpIC8gMzsKICBicmVha19sZW4gKj0gMzsKCiAgaWYoYnJlYWtfbGVuID4gb3B0cy0+YnJlYWtfbGVuZ3RoKQogICAgYnJlYWtfbGVuID0gb3B0cy0+YnJlYWtfbGVuZ3RoOwogIHB0ciA9IEpTX0dldEFycmF5QnVmZmVyKGN0eCwgJnNpemUsIHZhbHVlKTsKICAvLyBwcmludGYoIm1heEFycmF5TGVuZ3RoOiAlaVxuIiwgb3B0cy0+bWF4X2FycmF5X2xlbmd0aCk7CiAgcHJvdG8gPSBKU19HZXRQcm90b3R5cGUoY3R4LCB2YWx1ZSk7CiAgc3RyID0ganNfb2JqZWN0X3Rvc3RyaW5nKGN0eCwgcHJvdG8pOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHByb3RvKTsKCiAgaWYoanNfaXNfYXJyYXlidWZmZXIoY3R4LCB2YWx1ZSkpCiAgICBkYnVmX3B1dHN0cihidWYsICJBcnJheUJ1ZmZlciIpOwogIGVsc2UgaWYoanNfaXNfc2hhcmVkYXJyYXlidWZmZXIoY3R4LCB2YWx1ZSkpCiAgICBkYnVmX3B1dHN0cihidWYsICJTaGFyZWRBcnJheUJ1ZmZlciIpOwogIGVsc2UgaWYoc3RyICYmIChzdHIyID0gc3RyY2hyKHN0ciwgJyAnKSkpIHsKICAgIHN0cjIrKzsKICAgIHNsZW4gPSBieXRlX2NocihzdHIyLCBzdHJsZW4oc3RyMiksICddJyk7CiAgICBkYnVmX2FwcGVuZChidWYsIChjb25zdCB1aW50OF90KilzdHIyLCBzbGVuKTsKICB9CgogIGlmKHN0cikKICAgIGpzX2NzdHJpbmdfZnJlZShjdHgsIHN0cik7CgogIGRidWZfcHV0c3RyKGJ1ZiwgIiB7Iik7CiAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgKG9wdHMtPmRlcHRoIC0gZGVwdGgpICsgMik7CiAgZGJ1Zl9wcmludGYoYnVmLCAiYnl0ZUxlbmd0aDogJXp1IFsiLCBzaXplKTsKICBpbnNwZWN0X25ld2xpbmUoYnVmLCAob3B0cy0+ZGVwdGggLSBkZXB0aCkgKyAzKTsKICBicmVha19sZW4gLT0gKChvcHRzLT5kZXB0aCAtIGRlcHRoKSArIDMpICogMjsKICBjb2x1bW4gPSAwOwoKICBmb3IoaSA9IDA7IGkgPCBzaXplOyBpKyspIHsKICAgIGlmKGkgPT0gKHNpemVfdClvcHRzLT5tYXhfYXJyYXlfbGVuZ3RoKQogICAgICBicmVhazsKICAgIGlmKGNvbHVtbiArIDMgPj0gYnJlYWtfbGVuICYmIG9wdHMtPmJyZWFrX2xlbmd0aCAhPSBJTlQzMl9NQVgpIHsKICAgICAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgKG9wdHMtPmRlcHRoIC0gZGVwdGgpICsgMyk7CiAgICAgIGNvbHVtbiA9IDA7CiAgICB9CiAgICBkYnVmX3ByaW50ZihidWYsIGNvbHVtbiA/ICIgJTAyeCIgOiAiJTAyeCIsIHB0cltpXSk7CiAgICBjb2x1bW4gKz0gY29sdW1uID8gMyA6IDI7CiAgfQogIGlmKGkgPCBzaXplKSB7CiAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCAob3B0cy0+ZGVwdGggLSBkZXB0aCkgKyAzKTsKCiAgICBkYnVmX3ByaW50ZihidWYsICIuLi4gJXp1IG1vcmUgYnl0ZXMiLCBzaXplIC0gaSk7CiAgfQogIGluc3BlY3RfbmV3bGluZShidWYsIChvcHRzLT5kZXB0aCAtIGRlcHRoKSArIDIpOwogIGRidWZfcHV0c3RyKGJ1ZiwgIl0iKTsKICBpbnNwZWN0X25ld2xpbmUoYnVmLCAob3B0cy0+ZGVwdGggLSBkZXB0aCkgKyAxKTsKICBkYnVmX3B1dHN0cihidWYsICJ9Iik7CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQKanNfaW5zcGVjdF9yZWdleHAoSlNDb250ZXh0KiBjdHgsIER5bkJ1ZiogYnVmLCBKU1ZhbHVlQ29uc3QgdmFsdWUsIGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBpbnQzMl90IGRlcHRoKSB7CiAgY29uc3QgY2hhciogc3RyOwogIHNpemVfdCBsZW47CiAgc3RyID0gSlNfVG9DU3RyaW5nTGVuKGN0eCwgJmxlbiwgdmFsdWUpOwogIGlmKG9wdHMtPmNvbG9ycykKICAgIGRidWZfcHV0c3RyKGJ1ZiwgIlx4MWJbMDszMW0iKTsKICBkYnVmX3B1dF9lc2NhcGVkX3ByZWQoYnVmLCBzdHIsIGxlbiwgcmVnZXhwX3ByZWRpY2F0ZSk7CiAgaWYob3B0cy0+Y29sb3JzKQogICAgZGJ1Zl9wdXRzdHIoYnVmLCAiXHgxYlttIik7CiAganNfY3N0cmluZ19mcmVlKGN0eCwgc3RyKTsKICByZXR1cm4gMDsKfQoKc3RhdGljIGludApqc19pbnNwZWN0X251bWJlcihKU0NvbnRleHQqIGN0eCwgRHluQnVmKiBidWYsIEpTVmFsdWVDb25zdCB2YWx1ZSwgaW5zcGVjdF9vcHRpb25zX3QqIG9wdHMsIGludDMyX3QgZGVwdGgpIHsKICBpbnQgdGFnID0gSlNfVkFMVUVfR0VUX1RBRyh2YWx1ZSk7CiAgY29uc3QgY2hhciogc3RyOwogIHNpemVfdCBsZW47CiAgSlNWYWx1ZSBudW1iZXIsIGJhc2U7CiAgaWYodGFnICE9IEpTX1RBR19TWU1CT0wgJiYgb3B0cy0+Y29sb3JzKQogICAgZGJ1Zl9wdXRzdHIoYnVmLCBDT0xPUl9MSUdIVFlFTExPVyk7CiAgaWYob3B0cy0+bnVtYmVyX2Jhc2UgJiYgb3B0cy0+bnVtYmVyX2Jhc2UgIT0gMTApIHsKICAgIGJhc2UgPSBKU19OZXdJbnQzMihjdHgsIDE2KTsKICAgIG51bWJlciA9IGpzX2ludm9rZShjdHgsIHZhbHVlLCAidG9TdHJpbmciLCAxLCAmYmFzZSk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCBiYXNlKTsKCiAgfSBlbHNlIHsKICAgIG51bWJlciA9IEpTX0R1cFZhbHVlKGN0eCwgdmFsdWUpOwogIH0KICBzdHIgPSBKU19Ub0NTdHJpbmdMZW4oY3R4LCAmbGVuLCBudW1iZXIpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIG51bWJlcik7CgogIHN3aXRjaChvcHRzLT5udW1iZXJfYmFzZSkgewogICAgY2FzZSAxNjogZGJ1Zl9wdXRzdHIoYnVmLCAiMHgiKTsgYnJlYWs7CiAgICBjYXNlIDI6IGRidWZfcHV0c3RyKGJ1ZiwgIjBiIik7IGJyZWFrOwogICAgY2FzZSA4OiBkYnVmX3B1dHN0cihidWYsICIwIik7IGJyZWFrOwogIH0KCiAgZGJ1Zl9hcHBlbmQoYnVmLCAoY29uc3QgdWludDhfdCopc3RyLCBsZW4pOwogIGpzX2NzdHJpbmdfZnJlZShjdHgsIHN0cik7CiAgaWYodGFnIDw9IEpTX1RBR19CSUdfRkxPQVQpCiAgICBkYnVmX3B1dGMoYnVmLCB0YWcgPT0gSlNfVEFHX0JJR19ERUNJTUFMID8gJ20nIDogdGFnID09IEpTX1RBR19CSUdfRkxPQVQgPyAnbCcgOiAnbicpOwogIGlmKG9wdHMtPmNvbG9ycykKICAgIGRidWZfcHV0c3RyKGJ1ZiwgQ09MT1JfTk9ORSk7CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQKanNfaW5zcGVjdF9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIER5bkJ1ZiogYnVmLCBKU1ZhbHVlQ29uc3QgdmFsdWUsIGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBpbnQzMl90IGRlcHRoKSB7CiAgaW50IHRhZyA9IEpTX1ZBTFVFX0dFVF9UQUcodmFsdWUpOwogIGludCBjb21wYWN0ID0gSU5TUEVDVF9JU19DT01QQUNUKG9wdHMpOwoKICBjb25zdCBjaGFyKiBzdHI7CiAgc2l6ZV90IHBvcywgbGVuLCBtYXhfbGVuLCBsaW1pdCwgY29sdW1uX3N0YXJ0ID0gKElOU1BFQ1RfTEVWRUwob3B0cykgKiAyKTsKICBpbnQgY29sID0gZGJ1Zl9nZXRfY29sdW1uKGJ1Zik7CiAgc3RyID0gSlNfVG9DU3RyaW5nTGVuKGN0eCwgJmxlbiwgdmFsdWUpOwogIG1heF9sZW4gPSBtaW5fc2l6ZShvcHRzLT5icmVha19sZW5ndGggLSBjb2wgLSAxMCwgbGVuKTsKCiAgaWYodGFnICE9IEpTX1RBR19TWU1CT0wgJiYgb3B0cy0+Y29sb3JzKQogICAgZGJ1Zl9wdXRzdHIoYnVmLCBDT0xPUl9HUkVFTik7CiAgZGJ1Zl9wdXRjKGJ1ZiwgdGFnID09IEpTX1RBR19TWU1CT0wgPyAnKCcgOiAnXCcnKTsKICBsaW1pdCA9IG1pbl9zaXplKG9wdHMtPm1heF9zdHJpbmdfbGVuZ3RoLCBsZW4pOwoKICBmb3IocG9zID0gMDsgcG9zIDwgbGltaXQ7KSB7CiAgICBzaXplX3QgaSwgbiwgZW9sOwogICAgbiA9IGxpbWl0IC0gcG9zOwogICAgaWYocG9zID4gMCkgewogICAgICBkYnVmX3B1dHN0cihidWYsIG9wdHMtPmNvbG9ycyA/ICInIiBDT0xPUl9OT05FICIgKyIgOiAiJyArIik7CiAgICAgIG1heF9sZW4gPSBvcHRzLT5icmVha19sZW5ndGggLSBjb2x1bW5fc3RhcnQgLSA4OwogICAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpICsgMSk7CiAgICAgIGRidWZfcHV0c3RyKGJ1Ziwgb3B0cy0+Y29sb3JzID8gQ09MT1JfR1JFRU4gIiciIDogIiciKTsKICAgIH0KICAgIGlmKGNvbXBhY3QpIHsKICAgICAgbiA9IGFuc2lfdHJ1bmNhdGUoJnN0cltwb3NdLCBuLCBtYXhfbGVuKTsKICAgIH0gZWxzZSBpZihvcHRzLT5zdHJpbmdfYnJlYWtfbmV3bGluZSkgewogICAgICBmb3IoaSA9IHBvczsgaSA8IGxpbWl0OyBpICs9IGVvbCkgewogICAgICAgIGVvbCA9IGJ5dGVfY2hyKCZzdHJbaV0sIGxpbWl0IC0gaSwgJ1xuJyk7CiAgICAgICAgaWYoc3RyW2kgKyBlb2xdID09ICdcbicpCiAgICAgICAgICBlb2wrKzsKCiAgICAgICAgaWYoaSA+IHBvcyAmJiBhbnNpX3RydW5jYXRlKCZzdHJbcG9zXSwgaSArIGVvbCAtIHBvcywgbWF4X2xlbikgPCBpICsgZW9sIC0gcG9zKSB7CiAgICAgICAgICBuID0gaSAtIHBvczsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgZGJ1Zl9wdXRfZXNjYXBlZChidWYsICZzdHJbcG9zXSwgbik7CiAgICBwb3MgKz0gbjsKICB9CiAganNfY3N0cmluZ19mcmVlKGN0eCwgc3RyKTsKICBkYnVmX3B1dGMoYnVmLCB0YWcgPT0gSlNfVEFHX1NZTUJPTCA/ICcpJyA6ICdcJycpOwoKICBpZihvcHRzLT5jb2xvcnMpCiAgICBkYnVmX3B1dHN0cihidWYsIENPTE9SX05PTkUpOwoKICBpZihsaW1pdCA8IGxlbikgewogICAgaWYob3B0cy0+YnJlYWtfbGVuZ3RoICE9IElOVDMyX01BWCAmJiBkYnVmX2dldF9jb2x1bW4oYnVmKSArIDI2ID4gb3B0cy0+YnJlYWtfbGVuZ3RoKQogICAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpICsgMSk7CiAgICBkYnVmX3ByaW50ZihidWYsICIuLi4gJXp1IG1vcmUgY2hhcmFjdGVycyIsIGxlbiAtIHBvcyk7CiAgfQogIHJldHVybiAwOwp9CgpzdGF0aWMgaW50CmpzX2luc3BlY3RfcHJpbnQoSlNDb250ZXh0KiBjdHgsIER5bkJ1ZiogYnVmLCBKU1ZhbHVlQ29uc3QgdmFsdWUsIGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBpbnQzMl90IGRlcHRoKSB7CiAgaW50IHRhZyA9IEpTX1ZBTFVFX0dFVF9UQUcodmFsdWUpOwogIC8vIGludCBjb21wYWN0ID0gSU5TUEVDVF9JU19DT01QQUNUKG9wdHMpOwogIC8vIHByaW50ZigianNfaW5zcGVjdF9wcmludCBsZXZlbDogJWRcbiIsIElOU1BFQ1RfTEVWRUwob3B0cykpOwogIHN3aXRjaCh0YWcpIHsKICAgIGNhc2UgSlNfVEFHX0ZMT0FUNjQ6CiAgICBjYXNlIEpTX1RBR19CSUdfREVDSU1BTDoKICAgIGNhc2UgSlNfVEFHX0JJR19JTlQ6CiAgICBjYXNlIEpTX1RBR19JTlQ6CiAgICBjYXNlIEpTX1RBR19CSUdfRkxPQVQ6IHsKICAgICAgcmV0dXJuIGpzX2luc3BlY3RfbnVtYmVyKGN0eCwgYnVmLCB2YWx1ZSwgb3B0cywgZGVwdGgpOwogICAgfQoKICAgICAgLyogY2FzZSBKU19UQUdfSU5UOiB7CiAgICAgICAgIGludCBpID0gSlNfVkFMVUVfR0VUX0lOVCh2YWx1ZSk7CiAgICAgICAgIGlmKG9wdHMtPmNvbG9ycykKICAgICAgICAgICBkYnVmX3B1dHN0cihidWYsIENPTE9SX1lFTExPVyk7CiAgICAgICAgIGRidWZfcHJpbnRmKGJ1ZiwgIiVpIiwgaSk7CiAgICAgICAgIGlmKG9wdHMtPmNvbG9ycykKICAgICAgICAgICBkYnVmX3B1dHN0cihidWYsIENPTE9SX05PTkUpOwogICAgICAgICBicmVhazsKICAgICAgIH0qLwoKICAgIGNhc2UgSlNfVEFHX0JPT0w6IHsKICAgICAgaWYob3B0cy0+Y29sb3JzKQogICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgQ09MT1JfWUVMTE9XKTsKICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBKU19WQUxVRV9HRVRfQk9PTCh2YWx1ZSkgPyAidHJ1ZSIgOiAiZmFsc2UiKTsKICAgICAgaWYob3B0cy0+Y29sb3JzKQogICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgQ09MT1JfTk9ORSk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgSlNfVEFHX05VTEw6IHsKICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBvcHRzLT5jb2xvcnMgPyAiXHgxYlszODs1OzEyOW1udWxsXHgxYlttIiA6ICJudWxsIik7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgSlNfVEFHX1VOREVGSU5FRDogewogICAgICBkYnVmX3B1dF9jb2xvcnN0cihidWYsICJ1bmRlZmluZWQiLCBDT0xPUl9HUkFZLCBvcHRzLT5jb2xvcnMpOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIEpTX1RBR19FWENFUFRJT046IHsKICAgICAgZGJ1Zl9wdXRfY29sb3JzdHIoYnVmLCAiW2V4Y2VwdGlvbl0iLCBDT0xPUl9SRUQsIG9wdHMtPmNvbG9ycyk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgSlNfVEFHX1NZTUJPTDogewogICAgICB2YWx1ZSA9IGpzX3N5bWJvbF90b19zdHJpbmcoY3R4LCB2YWx1ZSk7CiAgICAgIGlmKG9wdHMtPmNvbG9ycykKICAgICAgICBkYnVmX3B1dHN0cihidWYsIENPTE9SX0dSRUVOKTsKICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCAiU3ltYm9sIik7CiAgICAgIF9fYXR0cmlidXRlX18oKGZhbGx0aHJvdWdoKSk7CiAgICB9CgogICAgY2FzZSBKU19UQUdfU1RSSU5HOiB7CiAgICAgIHJldHVybiBqc19pbnNwZWN0X3N0cmluZyhjdHgsIGJ1ZiwgdmFsdWUsIG9wdHMsIGRlcHRoKTsKICAgIH0KCiAgICBjYXNlIEpTX1RBR19PQkpFQ1Q6IHsKICAgICAgQk9PTCBpc19hcnJheSA9IDAsIGlzX3R5cGVkYXJyYXkgPSAwLCBpc19mdW5jdGlvbiA9IDA7CiAgICAgIHVpbnQzMl90IHBvcywgbGVuLCBsaW1pdDsKICAgICAgVmVjdG9yIHByb3BlbnVtX3RhYjsKICAgICAgY29uc3QgY2hhciogcyA9IDA7CiAgICAgIGludCBjb21wYWN0ID0gb3B0cy0+Y29tcGFjdDsKICAgICAgSlNPYmplY3QqIG9iaiA9IEpTX1ZBTFVFX0dFVF9PQkoodmFsdWUpOwoKICAgICAgaWYoIW9iai0+cHJvcCB8fCAhb2JqLT5zaGFwZSkgewogICAgICAgIGRidWZfcHJpbnRmKGJ1ZiwgImpzX2luc3BlY3RfcHJpbnQgT2JqZWN0IHByb3AgPSAlcCwgc2hhcGUgPSAlcCAiLCBvYmotPnByb3AsIG9iai0+c2hhcGUpOwogICAgICAgIHJldHVybiAtMTsKICAgICAgfQoKICAgICAgaWYob3B0cy0+Y3VzdG9tX2luc3BlY3QpIHsKICAgICAgICBKU1ZhbHVlIHRtcCA9IGpzX2luc3BlY3RfY3VzdG9tX2NhbGwoY3R4LCB2YWx1ZSwgb3B0cywgZGVwdGgpOwogICAgICAgIGlmKEpTX0lzU3RyaW5nKHRtcCkpIHsKICAgICAgICAgIGNvbnN0IGNoYXIqIHMgPSBKU19Ub0NTdHJpbmcoY3R4LCB0bXApOwogICAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBzKTsKICAgICAgICAgIGpzX2NzdHJpbmdfZnJlZShjdHgsIHMpOwogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQoKICAgICAgICBpZihKU19Jc0V4Y2VwdGlvbih0bXApKSB7CiAgICAgICAgICBKU1ZhbHVlIGV4Y2VwdGlvbiA9IEpTX0dldEV4Y2VwdGlvbihjdHgpOwoKICAgICAgICAgIC8vIGRidWZfcHJpbnRmKGJ1ZiwgImV4Y2VwdGlvbjogJXNcbiIsIEpTX1RvQ1N0cmluZyhjdHgsIGV4Y2VwdGlvbikpOwogICAgICAgICAgLy8gcmV0dXJuIDA7CgogICAgICAgIH0gZWxzZSBpZighSlNfSXNVbmRlZmluZWQodG1wKSkgewogICAgICAgICAgaWYoIUpTX0lzT2JqZWN0KHRtcCkpCiAgICAgICAgICAgIHJldHVybiBqc19pbnNwZWN0X3ByaW50KGN0eCwgYnVmLCB0bXAsIG9wdHMsIGRlcHRoICsgMSk7CgogICAgICAgICAgdmFsdWUgPSB0bXA7CiAgICAgICAgICBjb21wYWN0Kys7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZihvcHRzLT5jb21wYWN0IDwgMCkgewogICAgICAgIGNvbXBhY3QgPSBkZXB0aCA+PSAtb3B0cy0+Y29tcGFjdDsKICAgICAgfSBlbHNlIGlmKElOU1BFQ1RfSU5UMzJUX0lOUkFOR0Uob3B0cy0+Y29tcGFjdCkgJiYgb3B0cy0+Y29tcGFjdCA+IDApIHsKICAgICAgICBpbnQzMl90IGRlZXBlc3QgPSAxOwoKICAgICAgICBpZighanNfaXNfYXJyYXlidWZmZXIoY3R4LCB2YWx1ZSkpCiAgICAgICAgICBkZWVwZXN0ID0gcHJvcGVydHlfZW51bWVyYXRpb25fZGVlcGVzdChjdHgsIHZhbHVlKTsKICAgICAgICBjb25zdCBjaGFyKiB0eXBlc3RyID0ganNfdmFsdWVfdHlwZXN0cihjdHgsIHZhbHVlKTsKICAgICAgICAvLyBwcmludGYoIiVzIG9wdHMtPmNvbXBhY3QgPSAlZCwgZGVlcGVzdCA9ICVkLCBkZXB0aCA9ICVkXG4iLCB0eXBlc3RyID8KICAgICAgICAvLyB0eXBlc3RyIDoKICAgICAgICAvLyAiKG51bGwpIiwgb3B0cy0+Y29tcGFjdCwgZGVlcGVzdCwgZGVwdGgpOwoKICAgICAgICBjb21wYWN0ID0gY29tcGFjdCA+IGRlZXBlc3Q7CiAgICAgIH0KCiAgICAgIGlmKCEoaXNfZnVuY3Rpb24gPSBKU19Jc0Z1bmN0aW9uKGN0eCwgdmFsdWUpKSkgewogICAgICAgIGlzX2FycmF5ID0ganNfaXNfYXJyYXkoY3R4LCB2YWx1ZSk7CiAgICAgICAgaXNfdHlwZWRhcnJheSA9IGpzX2lzX3R5cGVkYXJyYXkodmFsdWUpOwoKICAgICAgICBpZighaXNfYXJyYXkgJiYgIWlzX3R5cGVkYXJyYXkpIHsKICAgICAgICAgIGlmKGpzX2lzX2FycmF5YnVmZmVyKGN0eCwgdmFsdWUpIHx8IGpzX2lzX3NoYXJlZGFycmF5YnVmZmVyKGN0eCwgdmFsdWUpKQogICAgICAgICAgICByZXR1cm4ganNfaW5zcGVjdF9hcnJheWJ1ZmZlcihjdHgsIGJ1ZiwgdmFsdWUsIG9wdHMsIGRlcHRoICsgMSk7CgogICAgICAgICAgaWYoanNfaXNfbWFwKGN0eCwgdmFsdWUpKQogICAgICAgICAgICByZXR1cm4ganNfaW5zcGVjdF9tYXAoY3R4LCBidWYsIHZhbHVlLCBvcHRzLCBkZXB0aCAvKisgMSovKTsKICAgICAgICAgIGlmKGpzX2lzX3NldChjdHgsIHZhbHVlKSkKICAgICAgICAgICAgcmV0dXJuIGpzX2luc3BlY3Rfc2V0KGN0eCwgYnVmLCB2YWx1ZSwgb3B0cywgZGVwdGggKyAxKTsKICAgICAgICAgIGlmKGpzX2lzX3JlZ2V4cChjdHgsIHZhbHVlKSkKICAgICAgICAgICAgcmV0dXJuIGpzX2luc3BlY3RfcmVnZXhwKGN0eCwgYnVmLCB2YWx1ZSwgb3B0cywgZGVwdGggKyAxKTsKICAgICAgICAgIC8qaWYoSlNfSXNJbnN0YW5jZU9mKGN0eCwgdmFsdWUsIHByb3h5X2N0b3IpKSB7CiAgICAgICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgIltQcm94eV0iKTsKICAgICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgICB9Ki8KICAgICAgICB9CgogICAgICAgIGlmKGpzX29iamVjdF90bXBtYXJrX2lzc2V0KHZhbHVlKSkgewogICAgICAgICAgSlNfVGhyb3dUeXBlRXJyb3IoY3R4LCAiY2lyY3VsYXIgcmVmZXJlbmNlIik7CiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgfQoKICAgICAgICBpZihqc19pc19nZW5lcmF0b3IoY3R4LCB2YWx1ZSkpIHsKICAgICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgIk9iamVjdCBbR2VuZXJhdG9yXSB7fSIpOwogICAgICAgICAganNfY3N0cmluZ19mcmVlKGN0eCwgcyk7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmKCFKU19Jc0FycmF5KGN0eCwgdmFsdWUpICYmICFpc19mdW5jdGlvbikgewogICAgICAgIGlmKHMgPT0gMCkKICAgICAgICAgIHMgPSBqc19vYmplY3RfdG9zdHJpbmcoY3R4LCB2YWx1ZSk7CgogICAgICAgIGlmKCFzdHJuY21wKHMsICJbb2JqZWN0ICIsIDgpKSB7CiAgICAgICAgICBjb25zdCBjaGFyKiBlID0gc3RyY2hyKHMsICddJyk7CiAgICAgICAgICBzaXplX3Qgc2xlbiA9IGUgLSAocyArIDgpOwoKICAgICAgICAgIGlmKHNsZW4gIT0gNiB8fCBtZW1jbXAocyArIDgsICJPYmplY3QiLCA2KSkgewogICAgICAgICAgICBkYnVmX3B1dHN0cihidWYsIG9wdHMtPmNvbG9ycyA/IENPTE9SX0xJR0hUUkVEIDogIlsiKTsKICAgICAgICAgICAgLy8gZGJ1Zl9wdXRzdHIoYnVmLCBvcHRzLT5jb2xvcnMgPyBDT0xPUl9NQVJJTkUgIlsiIDogIlsiKTsKICAgICAgICAgICAgZGJ1Zl9hcHBlbmQoYnVmLCAoY29uc3QgdWludDhfdCopcyArIDgsIGUgLSAocyArIDgpKTsKICAgICAgICAgICAgLy8gZGJ1Zl9wdXRzdHIoYnVmLCBvcHRzLT5jb2xvcnMgPyAiXSIgQ09MT1JfTk9ORSAiICIgOiAiXSAiKTsKICAgICAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBvcHRzLT5jb2xvcnMgPyBDT0xPUl9OT05FICIgIiA6ICJdICIpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBpZihzKQogICAgICAgIGpzX2NzdHJpbmdfZnJlZShjdHgsIHMpOwoKICAgICAgaWYoIShpc19hcnJheSB8fCBpc190eXBlZGFycmF5KSkgewogICAgICB2ZWN0b3JfaW5pdCgmcHJvcGVudW1fdGFiLCBjdHgpOwogICAgICAvLyBwcmludGYoInByb3RvX2NoYWluOiAlaVxuIiwgb3B0cy0+cHJvdG9fY2hhaW4pOwogICAgICBpZigoMSB8fCBvcHRzLT5wcm90b19jaGFpbiA/IGpzX29iamVjdF9nZXRwcm9wZXJ0eW5hbWVzX3JlY3Vyc2l2ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGpzX29iamVjdF9nZXRwcm9wZXJ0eW5hbWVzKShjdHgsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICZwcm9wZW51bV90YWIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG9wdHMtPnByb3RvX2NoYWluIDw9IDAgPyBKU19HZXRQcm90b3R5cGUoY3R4LCB2YWx1ZSkgOiAqLyB2YWx1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNfR1BOX1NUUklOR19NQVNLIHwgSlNfR1BOX1NZTUJPTF9NQVNLIHwgKG9wdHMtPnNob3dfaGlkZGVuID8gMCA6IEpTX0dQTl9FTlVNX09OTFkpKSkKICAgICAgICByZXR1cm4gLTE7Cn0KCiAgICAgIGlmKGlzX2Z1bmN0aW9uKSB7CiAgICAgICAgSlNWYWx1ZSBuYW1lOwogICAgICAgIGRidWZfcHV0c3RyKGJ1Ziwgb3B0cy0+Y29sb3JzID8gQ09MT1JfTUFSSU5FICJbRnVuY3Rpb24iIDogIltGdW5jdGlvbiIpOwogICAgICAgIG5hbWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIHZhbHVlLCAibmFtZSIpOwogICAgICAgIGlmKCFKU19Jc1VuZGVmaW5lZChuYW1lKSkgewogICAgICAgICAgcyA9IEpTX1RvQ1N0cmluZyhjdHgsIG5hbWUpOwogICAgICAgICAgaWYoKnMpIHsKICAgICAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCAiOiAiKTsKICAgICAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBzKTsKICAgICAgICAgIH0KICAgICAgICAgIGpzX2NzdHJpbmdfZnJlZShjdHgsIHMpOwogICAgICAgIH0KICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBuYW1lKTsKICAgICAgICBkYnVmX3B1dHN0cihidWYsIG9wdHMtPmNvbG9ycyA/ICJdIiBDT0xPUl9OT05FIDogIl0iKTsKICAgICAgICAvKiAgaWYodmVjdG9yX3NpemUoJnByb3BlbnVtX3RhYiwgc2l6ZW9mKEpTUHJvcGVydHlEZXNjcmlwdG9yKSkgJiYgZGVwdGggPj0gMCkKICAgICAgICAgICAgZGJ1Zl9wdXRjKGJ1ZiwgJyAnKTsKICAgICAgICAgIGVsc2UqLwogICAgICAgIGdvdG8gZW5kX29iajsKICAgICAgfQogICAgICBpZihkZXB0aCA8IDApIHsKICAgICAgICBkYnVmX3B1dF9jb2xvcnN0cihidWYsIGlzX2FycmF5ID8gIltBcnJheV0iIDogIltPYmplY3RdIiwgQ09MT1JfTUFSSU5FLCBvcHRzLT5jb2xvcnMpOwogICAgICAgIGdvdG8gZW5kX29iajsKICAgICAgfQoKICAgICAganNfb2JqZWN0X3RtcG1hcmtfc2V0KHZhbHVlKTsKCiAgICAgIGlmKGlzX2FycmF5IHx8IGlzX3R5cGVkYXJyYXkpIHsKICAgICAgICBsZW4gPSBqc19hcnJheV9sZW5ndGgoY3R4LCB2YWx1ZSk7CiAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBjb21wYWN0ICYmIG9wdHMtPmJyZWFrX2xlbmd0aCAhPSBJTlQzMl9NQVggPyAiWyAiIDogIlsiKTsKICAgICAgICBsaW1pdCA9IG1pbl9zaXplKG9wdHMtPm1heF9hcnJheV9sZW5ndGgsIGxlbik7CiAgICAgICAgaWYobGVuICYmICFjb21wYWN0ICYmIG9wdHMtPmJyZWFrX2xlbmd0aCAhPSBJTlQzMl9NQVgpCiAgICAgICAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpICsgMSk7CiAgICAgICAgZm9yKHBvcyA9IDA7IHBvcyA8IGxlbjsgcG9zKyspIHsKICAgICAgICAgIEpTUHJvcGVydHlEZXNjcmlwdG9yIGRlc2M7CiAgICAgICAgICBKU0F0b20gcHJvcDsKICAgICAgICAgIGlmKHBvcyA9PSBsaW1pdCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBpZihwb3MgPiAwKSB7CiAgICAgICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgIiwgIik7CiAgICAgICAgICAgIC8vIGRidWZfcHV0c3RyKGJ1ZiwgY29tcGFjdCA/ICIsICIgOiAiLCIpOwogICAgICAgICAgICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgICAgICAgICAgIGluc3BlY3RfbmV3bGluZShidWYsIElOU1BFQ1RfTEVWRUwob3B0cykgKyAxKTsKICAgICAgICAgIH0KICAgICAgICAgIHByb3AgPSBKU19OZXdBdG9tVUludDMyKGN0eCwgcG9zKTsKICAgICAgICAgIG1lbXNldCgmZGVzYywgMCwgc2l6ZW9mKGRlc2MpKTsKICAgICAgICAgIGRlc2MudmFsdWUgPSBKU19VTkRFRklORUQ7CiAgICAgICAgICBKU19HZXRPd25Qcm9wZXJ0eShjdHgsICZkZXNjLCB2YWx1ZSwgcHJvcCk7CiAgICAgICAgICBKU19GcmVlQXRvbShjdHgsIHByb3ApOwoKICAgICAgICAgIGlmKChkZXNjLmZsYWdzICYgSlNfUFJPUF9HRVRTRVQpICYmIG9wdHMtPmdldHRlcnMpIHsKICAgICAgICAgICAgaW50IGlkeCA9IChKU19Jc1VuZGVmaW5lZChkZXNjLmdldHRlcikgPyAwIDogMSkgfCAoSlNfSXNVbmRlZmluZWQoZGVzYy5zZXR0ZXIpID8gMCA6IDIpOwogICAgICAgICAgICBzdGF0aWMgY29uc3QgY2hhciogY29uc3Qgc3Ryc1s0XSA9IHswLCAiW0dldHRlcl0iLCAiW1NldHRlcl0iLCAiW0dldHRlci9TZXR0ZXJdIn07CiAgICAgICAgICAgIGlmKGlkeCkKICAgICAgICAgICAgICBkYnVmX3B1dF9jb2xvcnN0cihidWYsIHN0cnNbaWR4XSwgQ09MT1JfTUFSSU5FLCBvcHRzLT5jb2xvcnMpOwoKICAgICAgICAgIH0gZWxzZSBpZihKU19IYXNQcm9wZXJ0eShjdHgsIHZhbHVlLCBKU19BVE9NX1RBR19JTlQgfCBwb3MpKSB7CiAgICAgICAgICAgIC8qICBpZihjb21wYWN0IHx8IG9wdHMtPmJyZWFrX2xlbmd0aCA9PSBJTlQzMl9NQVgpCiAgICAgICAgICAgICAgICBkYnVmX3B1dGMoYnVmLCAnICcpOyovCiAgICAgICAgICAgIGpzX2luc3BlY3RfcHJpbnQoY3R4LCBidWYsIGRlc2MudmFsdWUsIG9wdHMsIGRlcHRoIC0gMSk7CiAgICAgICAgICB9CiAgICAgICAgICBqc19wcm9wZXJ0eWRlc2NyaXB0b3JfZnJlZShjdHgsICZkZXNjKTsKICAgICAgICB9CiAgICAgICAgaWYobGVuICYmIGxpbWl0IDwgbGVuKSB7CiAgICAgICAgICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgICAgICAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpICsgMSk7CiAgICAgICAgICBkYnVmX3ByaW50ZihidWYsICIuLi4gJXUgbW9yZSBpdGVtIiwgbGVuIC0gcG9zKTsKICAgICAgICAgIGlmKHBvcyArIDEgPCBsZW4pCiAgICAgICAgICAgIGRidWZfcHV0YyhidWYsICdzJyk7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZighaXNfYXJyYXkgJiYgIWlzX3R5cGVkYXJyYXkpIHsKICAgICAgICBkYnVmX3B1dHN0cihidWYsIChjb21wYWN0ICYmIHZlY3Rvcl9zaXplKCZwcm9wZW51bV90YWIsIHNpemVvZihKU1Byb3BlcnR5RW51bSkpKSA/ICJ7ICIgOiAieyIpOwogICAgICAgIGxlbiA9IDA7CiAgICAgIH0KCiAgICAgIGZvcihwb3MgPSAwOyBwb3MgPCB2ZWN0b3Jfc2l6ZSgmcHJvcGVudW1fdGFiLCBzaXplb2YoSlNQcm9wZXJ0eUVudW0pKTsgcG9zKyspIHsKICAgICAgICBKU1Byb3BlcnR5RGVzY3JpcHRvciBkZXNjOwogICAgICAgIGNvbnN0IGNoYXIqIG5hbWU7CiAgICAgICAgSlNQcm9wZXJ0eUVudW0qIHByb3BlbnVtID0gKEpTUHJvcGVydHlFbnVtKil2ZWN0b3JfYXQoJnByb3BlbnVtX3RhYiwgc2l6ZW9mKEpTUHJvcGVydHlFbnVtKSwgcG9zKTsKICAgICAgICBKU1ZhbHVlIGtleSA9IGpzX2F0b21fdG92YWx1ZShjdHgsIHByb3BlbnVtLT5hdG9tKTsKICAgICAgICBuYW1lID0gSlNfQXRvbVRvQ1N0cmluZyhjdHgsIHByb3BlbnVtLT5hdG9tKTsKICAgICAgICBpZighSlNfSXNTeW1ib2woa2V5KSkgewogICAgICAgICAgaWYoKChpc19hcnJheSB8fCBpc190eXBlZGFycmF5KSAmJiBpc19pbnRlZ2VyKG5hbWUpKSB8fCBpbnNwZWN0X29wdGlvbnNfaGlkZGVuKG9wdHMsIHByb3BlbnVtLT5hdG9tKSkgewogICAgICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBrZXkpOwogICAgICAgICAgICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBuYW1lKTsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmKHBvcyA+IDApCiAgICAgICAgICBkYnVmX3B1dHN0cihidWYsIGNvbXBhY3QgPyAiLCAiIDogIiwiKTsKICAgICAgICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgICAgICAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgSU5TUEVDVF9MRVZFTChvcHRzKSArIDEpOwogICAgICAgIGlmKCFKU19Jc1N5bWJvbChrZXkpICYmIChpc19pZGVudGlmaWVyKG5hbWUpIHx8IGlzX2ludGVnZXIobmFtZSkpKSB7CiAgICAgICAgICBkYnVmX3B1dHN0cihidWYsIG5hbWUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZighSlNfSXNTdHJpbmcoa2V5KSkKICAgICAgICAgICAgZGJ1Zl9wdXRjKGJ1ZiwgJ1snKTsKICAgICAgICAgIGpzX2luc3BlY3RfcHJpbnQoY3R4LCBidWYsIGtleSwgb3B0cywgZGVwdGggLSAxKTsKICAgICAgICAgIGlmKCFKU19Jc1N0cmluZyhrZXkpKQogICAgICAgICAgICBkYnVmX3B1dGMoYnVmLCAnXScpOwogICAgICAgIH0KICAgICAgICBkYnVmX3B1dHN0cihidWYsICI6ICIpOwogICAgICAgIGpzX2NzdHJpbmdfZnJlZShjdHgsIG5hbWUpOwogICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGtleSk7CgogICAgICAgIGlmKGpzX2dldF9wcm9wZXJ0eWRlc2NyaXB0b3IoY3R4LCAmZGVzYywgdmFsdWUsIHByb3BlbnVtLT5hdG9tKSA9PSBUUlVFKSB7CiAgICAgICAgICBpZigoZGVzYy5mbGFncyAmIEpTX1BST1BfR0VUU0VUKSkgewogICAgICAgICAgICBpZighb3B0cy0+Z2V0dGVycykgewogICAgICAgICAgICAgLy8gSlNWYWx1ZSB2ID0gSlNfR2V0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcHJvcGVudW0tPmF0b20pOwogICAgICAgICAgICAgIEpTVmFsdWUgdiA9IEpTX0NhbGwoY3R4LCBkZXNjLmdldHRlciwgdmFsdWUsIDAsIDApOwogICAgICAgICAgICAgIGpzX2luc3BlY3RfcHJpbnQoY3R4LCBidWYsIHYsIG9wdHMsIGRlcHRoIC0gMSk7CiAgICAgICAgICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgdik7CiAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgIGRidWZfcHV0X2NvbG9yc3RyKGJ1ZiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU19Jc1VuZGVmaW5lZChkZXNjLmdldHRlcikgICA/ICJbU2V0dGVyXSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IEpTX0lzVW5kZWZpbmVkKGRlc2Muc2V0dGVyKSA/ICJbR2V0dGVyXSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICJbR2V0dGVyL1NldHRlcl0iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTE9SX01BUklORSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLT5jb2xvcnMpOwogICAgICAgICAgfSBlbHNlIHsKCiAgICAgICAgICAgIGlmKEpTX0lzT2JqZWN0KGRlc2MudmFsdWUpICYmIGpzX29iamVjdF90bXBtYXJrX2lzc2V0KGRlc2MudmFsdWUpKQogICAgICAgICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgIlx4MWJbMDszMW1bQ2lyY3VsYXIgUmVmZXJlbmNlXVx4MWJbMG0iKTsKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgIGpzX2luc3BlY3RfcHJpbnQoY3R4LCBidWYsIGRlc2MudmFsdWUsIG9wdHMsIGRlcHRoIC0gMSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGpzX3Byb3BlcnR5ZGVzY3JpcHRvcl9mcmVlKGN0eCwgJmRlc2MpOwogICAgICAgIGxlbisrOwogICAgICB9CiAgICAgIGpzX29iamVjdF90bXBtYXJrX2NsZWFyKHZhbHVlKTsKCiAgICAgIGlmKCFjb21wYWN0ICYmIGxlbiAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgICAgIGluc3BlY3RfbmV3bGluZShidWYsIElOU1BFQ1RfTEVWRUwob3B0cykpOwogICAgICBkYnVmX3B1dHN0cihidWYsCiAgICAgICAgICAgICAgICAgIChpc19hcnJheSB8fCBpc190eXBlZGFycmF5KSA/ICgoY29tcGFjdCB8fCBvcHRzLT5icmVha19sZW5ndGggPT0gSU5UMzJfTUFYKSAmJiBsZW4gPyAiIF0iIDogIl0iKSA6IChjb21wYWN0ICYmIGxlbiA/ICIgfSIgOiAifSIpKTsKCiAgICBlbmRfb2JqOgogICAgICBpZighdmVjdG9yX2VtcHR5KCZwcm9wZW51bV90YWIpKQogICAgICAgIGpzX3Byb3BlcnR5ZW51bXNfZnJlZShjdHgsIHZlY3Rvcl9iZWdpbigmcHJvcGVudW1fdGFiKSwgdmVjdG9yX3NpemUoJnByb3BlbnVtX3RhYiwgc2l6ZW9mKEpTUHJvcGVydHlFbnVtKSkpOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIEpTX1RBR19GVU5DVElPTl9CWVRFQ09ERTogewogICAgICBkYnVmX3B1dHN0cihidWYsIG9wdHMtPmNvbG9ycyA/IENPTE9SX0xJR0hUUkVEICJbYnl0ZWNvZGVdIiBDT0xPUl9OT05FIDogIltieXRlY29kZV0iKTsKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBKU19UQUdfTU9EVUxFOiB7CiAgICAgIGRidWZfcHV0c3RyKGJ1Ziwgb3B0cy0+Y29sb3JzID8gQ09MT1JfTElHSFRNQVJJTkUgIlttb2R1bGVdIiBDT0xPUl9OT05FIDogIlttb2R1bGVdIik7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGRlZmF1bHQ6IHsKICAgICAgSlNfVGhyb3dUeXBlRXJyb3IoY3R4LCAiVW5oYW5kbGVkIHZhbHVlIHRhZyBpbiBqc19pbnNwZWN0X3ByaW50OiAlZFxuIiwgdGFnKTsKICAgICAgcmV0dXJuIC0xOwogICAgfQogIH0KICByZXR1cm4gMDsKfQoKc3RhdGljIEpTVmFsdWUKanNfaW5zcGVjdChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSkgewogIER5bkJ1ZiBkYnVmOwogIGluc3BlY3Rfb3B0aW9uc190IG9wdGlvbnM7CiAgaW50MzJfdCBsZXZlbDsKICBpbnQgb3B0aW5kID0gMTsKICBKU1ZhbHVlIHJldDsKCiAganNfZGJ1Zl9pbml0KGN0eCwgJmRidWYpOwogIGluc3BlY3Rfb3B0aW9uc19pbml0KCZvcHRpb25zLCBjdHgpOwoKICBpZihhcmdjID4gMSAmJiBKU19Jc051bWJlcihhcmd2WzFdKSkKICAgIG9wdGluZCsrOwoKICBpZihvcHRpbmQgPCBhcmdjKQogICAgaW5zcGVjdF9vcHRpb25zX2dldCgmb3B0aW9ucywgY3R4LCBhcmd2W29wdGluZF0pOwoKICBpZihvcHRpbmQgPiAxKSB7CiAgICBkb3VibGUgZDsKICAgIEpTX1RvRmxvYXQ2NChjdHgsICZkLCBhcmd2WzFdKTsKICAgIGxldmVsID0gaXNpbmYoZCkgPyBJTlQzMl9NQVggOiBkOwogIH0gZWxzZSB7CiAgICBsZXZlbCA9IDA7CiAgfQoKICAvKnByaW50ZigianNfaW5zcGVjdCBicmVha19sZW5ndGg6ICVkLCBtYXhfYXJyYXlfbGVuZ3RoOiAlZCwKICAgICBtYXhfc3RyaW5nX2xlbmd0aDogJWRcbiIsIG9wdGlvbnMuYnJlYWtfbGVuZ3RoLCBvcHRpb25zLm1heF9hcnJheV9sZW5ndGgsCiAgICAgb3B0aW9ucy5tYXhfc3RyaW5nX2xlbmd0aCk7Ki8KCiAganNfaW5zcGVjdF9wcmludChjdHgsICZkYnVmLCBhcmd2WzBdLCAmb3B0aW9ucywgb3B0aW9ucy5kZXB0aCAtIGxldmVsKTsKCiAgcmV0ID0gSlNfTmV3U3RyaW5nTGVuKGN0eCwgKGNvbnN0IGNoYXIqKWRidWYuYnVmLCBkYnVmLnNpemUpOwoKICBkYnVmX2ZyZWUoJmRidWYpOwoKICBpbnNwZWN0X29wdGlvbnNfZnJlZSgmb3B0aW9ucywgY3R4KTsKCiAgcmV0dXJuIHJldDsKfQoKY2hhcioKanNfaW5zcGVjdF90b3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgRHluQnVmIGRidWY7CiAgaW5zcGVjdF9vcHRpb25zX3Qgb3B0aW9uczsKICBqc19kYnVmX2luaXQoY3R4LCAmZGJ1Zik7CiAgaW5zcGVjdF9vcHRpb25zX2luaXQoJm9wdGlvbnMsIGN0eCk7CgogIG9wdGlvbnMuY29sb3JzID0gRkFMU0U7CiAgb3B0aW9ucy5jb21wYWN0ID0gMDsKICBvcHRpb25zLmdldHRlcnMgPSBUUlVFOwogIGpzX2luc3BlY3RfcHJpbnQoY3R4LCAmZGJ1ZiwgdmFsdWUsICZvcHRpb25zLCBvcHRpb25zLmRlcHRoKTsKCiAgaW5zcGVjdF9vcHRpb25zX2ZyZWUoJm9wdGlvbnMsIGN0eCk7CgogIGRidWZfMCgmZGJ1Zik7CiAgcmV0dXJuIChjaGFyKilkYnVmLmJ1ZjsKfQoKLypjb25zdCBjaGFyKgpqc19pbnNwZWN0X3Rvc3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBKU1ZhbHVlIG91dHB1dDsKICBpbnNwZWN0X29wdGlvbnNfdCBvcHRzOwogIEpTVmFsdWVDb25zdCBhcmdzW10gPSB7dmFsdWUsIEpTX1VOREVGSU5FRH07CiAgaW5zcGVjdF9vcHRpb25zX2luaXQoJm9wdHMsIGN0eCk7CiAgb3B0cy5jb2xvcnMgPSBGQUxTRTsKICBhcmdzWzFdID0gaW5zcGVjdF9vcHRpb25zX29iamVjdCgmb3B0cywgY3R4KTsKICBpbnNwZWN0X29wdGlvbnNfZnJlZSgmb3B0cywgY3R4KTsKCiAgb3V0cHV0ID0ganNfaW5zcGVjdChjdHgsIEpTX1VOREVGSU5FRCwgMiwgYXJncyk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgYXJnc1sxXSk7CiAgcmV0dXJuIEpTX1RvQ1N0cmluZyhjdHgsIG91dHB1dCk7Cn0qLwoKSlNWYWx1ZSBqc19kZWJ1Z2dlcl9idWlsZF9iYWNrdHJhY2UoSlNDb250ZXh0KiBjdHgsIGNvbnN0IHVpbnQ4X3QqIGN1cl9wYyk7CgpKU1ZhbHVlCmpzX2luc3BlY3Rfc3RhY2t0cmFjZV92YWx1ZShKU0NvbnRleHQqIGN0eCkgewogIEpTUnVudGltZSogcnQgPSBKU19HZXRSdW50aW1lKGN0eCk7CiAgc3RydWN0IEpTU3RhY2tGcmFtZSogZnJhbWU7CiAgSlNWYWx1ZSByZXQgPSBKU19VTkRFRklORUQ7CiAgaWYoKGZyYW1lID0gcnQtPmN1cnJlbnRfc3RhY2tfZnJhbWUpKSB7CiNpZmRlZiBDT05GSUdfREVCVUdHRVIKICAgIHJldCA9IGpzX2RlYnVnZ2VyX2J1aWxkX2JhY2t0cmFjZShjdHgsIGZyYW1lLT5jdXJfcGMpOwojZW5kaWYKICB9CiAgcmV0dXJuIHJldDsKfQoKY29uc3QgY2hhcioKanNfaW5zcGVjdF9zdGFja3RyYWNlKEpTQ29udGV4dCogY3R4KSB7CiAgSlNWYWx1ZSBzdGFjayA9IGpzX2luc3BlY3Rfc3RhY2t0cmFjZV92YWx1ZShjdHgpOwogIHJldHVybiBqc19pbnNwZWN0X3Rvc3RyaW5nKGN0eCwgc3RhY2spOwp9CgpzdGF0aWMgY29uc3QgSlNDRnVuY3Rpb25MaXN0RW50cnkganNfaW5zcGVjdF9mdW5jc1tdID0gewogICAgSlNfQ0ZVTkNfREVGKCJpbnNwZWN0IiwgMSwganNfaW5zcGVjdCksCn07CgpzdGF0aWMgaW50CmpzX2luc3BlY3RfaW5pdChKU0NvbnRleHQqIGN0eCwgSlNNb2R1bGVEZWYqIG0pIHsKICBKU1ZhbHVlIGluc3BlY3QsIGluc3BlY3Rfc3ltYm9sLCBzeW1ib2xfY3RvcjsKICBzdGRvdXRfaXNhdHR5ID0gaXNhdHR5KFNURE9VVF9GSUxFTk8pOwogIHN0ZGVycl9pc2F0dHkgPSBpc2F0dHkoU1RERVJSX0ZJTEVOTyk7CgogIGluc3BlY3QgPSBKU19OZXdDRnVuY3Rpb24oY3R4LCBqc19pbnNwZWN0LCAiaW5zcGVjdCIsIDIpOwoKICBpbnNwZWN0X3N5bWJvbCA9IGpzX3N5bWJvbF9mb3IoY3R4LCAicXVpY2tqcy5pbnNwZWN0LmN1c3RvbSIpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgaW5zcGVjdCwgInN5bWJvbCIsIEpTX0R1cFZhbHVlKGN0eCwgaW5zcGVjdF9zeW1ib2wpKTsKICBzeW1ib2xfY3RvciA9IGpzX3N5bWJvbF9jdG9yKGN0eCk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCBzeW1ib2xfY3RvciwgImluc3BlY3QiLCBKU19EdXBWYWx1ZShjdHgsIGluc3BlY3Rfc3ltYm9sKSk7CgogIEpTX0ZyZWVWYWx1ZShjdHgsIHN5bWJvbF9jdG9yKTsKICBKU19GcmVlVmFsdWUoY3R4LCBpbnNwZWN0X3N5bWJvbCk7CgogIGluc3BlY3RfY3VzdG9tX2F0b20gPSBqc19pbnNwZWN0X2N1c3RvbV9hdG9tKGN0eCwgInF1aWNranMuaW5zcGVjdC5jdXN0b20iKTsKICBpbnNwZWN0X2N1c3RvbV9hdG9tX25vZGUgPSBqc19pbnNwZWN0X2N1c3RvbV9hdG9tKGN0eCwgIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tIik7CgogIGlmKG0pIHsKICAgIEpTX1NldE1vZHVsZUV4cG9ydExpc3QoY3R4LCBtLCBqc19pbnNwZWN0X2Z1bmNzLCBjb3VudG9mKGpzX2luc3BlY3RfZnVuY3MpKTsKICAgIEpTX1NldE1vZHVsZUV4cG9ydChjdHgsIG0sICJkZWZhdWx0IiwgaW5zcGVjdCk7CiAgfQoKICByZXR1cm4gMDsKfQoKI2lmIGRlZmluZWQoSlNfU0hBUkVEX0xJQlJBUlkpICYmIGRlZmluZWQoSlNfSU5TUEVDVF9NT0RVTEUpCiNkZWZpbmUgSlNfSU5JVF9NT0RVTEUganNfaW5pdF9tb2R1bGUKI2Vsc2UKI2RlZmluZSBKU19JTklUX01PRFVMRSBqc19pbml0X21vZHVsZV9pbnNwZWN0CiNlbmRpZgoKVklTSUJMRSBKU01vZHVsZURlZioKSlNfSU5JVF9NT0RVTEUoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIG1vZHVsZV9uYW1lKSB7CiAgSlNNb2R1bGVEZWYqIG07CiAgbSA9IEpTX05ld0NNb2R1bGUoY3R4LCBtb2R1bGVfbmFtZSwganNfaW5zcGVjdF9pbml0KTsKICBpZighbSkKICAgIHJldHVybiBOVUxMOwogIEpTX0FkZE1vZHVsZUV4cG9ydExpc3QoY3R4LCBtLCBqc19pbnNwZWN0X2Z1bmNzLCBjb3VudG9mKGpzX2luc3BlY3RfZnVuY3MpKTsKICBKU19BZGRNb2R1bGVFeHBvcnQoY3R4LCBtLCAiZGVmYXVsdCIpOwogIHJldHVybiBtOwp9CgAAAAAAAAAA6oYAAAAAAAAAAAAAAAAAAAAAAADqhgAAAAAAAAAAAAAAAAAAAAAAAOqGAAAAAAAAAAAAAA",
					"AwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAD5hAAAAAAAAPmEAAAAAAAAAAAAAAADwvw"
				],
				[
					1,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAADqhgAAI2luY2x1ZGUgImN1dGlscy5oIgojaW5jbHVkZSAiaXRlcmF0aW9uLmgiCiNpbmNsdWRlICJsaXN0LmgiCiNpbmNsdWRlICJwcm9wZXJ0eS1lbnVtZXJhdGlvbi5oIgojaW5jbHVkZSAicXVpY2tqcy1pbnRlcm5hbC5oIgojaW5jbHVkZSAicXVpY2tqcy5oIgojaW5jbHVkZSAicXVpY2tqcy1jb25maWcuaCIKI2luY2x1ZGUgInV0aWxzLmgiCiNpbmNsdWRlICJ2ZWN0b3IuaCIKI2luY2x1ZGUgImJ1ZmZlci11dGlscy5oIgoKI2luY2x1ZGUgPGN0eXBlLmg+CiNpbmNsdWRlIDxtYXRoLmg+CiNpbmNsdWRlIDxzdHJpbmcuaD4KI2luY2x1ZGUgPHN5cy9pb2N0bC5oPgojaW5jbHVkZSA8dW5pc3RkLmg+CiNpZmRlZiBIQVZFX1RFUk1JT1NfSAojaW5jbHVkZSA8dGVybWlvcy5oPgojZW5kaWYKCnRocmVhZF9sb2NhbCBKU0F0b20gaW5zcGVjdF9jdXN0b21fYXRvbSA9IDAsIGluc3BlY3RfY3VzdG9tX2F0b21fbm9kZSA9IDA7CgojZGVmaW5lIElOU1BFQ1RfSU5UMzJUX0lOUkFOR0UoaSkgKChpKSA+IElOVDMyX01JTiAmJiAoaSkgPCBJTlQzMl9NQVgpCiNkZWZpbmUgSU5TUEVDVF9MRVZFTChvcHRzKSAoKG9wdHMpLT5kZXB0aCAtIChkZXB0aCkpCiNkZWZpbmUgSU5TUEVDVF9JU19DT01QQUNUKG9wdHMpIFwKICAoKG9wdHMpLT5jb21wYWN0ID09IElOVDMyX01BWCA/IFRSVUUgXAogICA6IElOU1BFQ1RfSU5UMzJUX0lOUkFOR0UoKG9wdHMpLT5jb21wYWN0KSBcCiAgICAgICA/ICgob3B0cyktPmNvbXBhY3QgPCAwID8gSU5TUEVDVF9MRVZFTChvcHRzKSA+PSAtKG9wdHMtPmNvbXBhY3QpIDogSU5TUEVDVF9MRVZFTChvcHRzKSA+PSAob3B0cyktPmNvbXBhY3QpIFwKICAgICAgIDogMCkKCnR5cGVkZWYgc3RydWN0IHsKICBpbnQgY29sb3JzIDogMTsKICBpbnQgc2hvd19oaWRkZW4gOiAxOwogIGludCBjdXN0b21faW5zcGVjdCA6IDE7CiAgaW50IHNob3dfcHJveHkgOiAxOwogIGludCBnZXR0ZXJzIDogMTsKICBpbnQgc3RyaW5nX2JyZWFrX25ld2xpbmUgOiAxOwogIGludDMyX3QgZGVwdGg7CiAgaW50MzJfdCBtYXhfYXJyYXlfbGVuZ3RoOwogIGludDMyX3QgbWF4X3N0cmluZ19sZW5ndGg7CiAgaW50MzJfdCBicmVha19sZW5ndGg7CiAgaW50MzJfdCBjb21wYWN0OwogIGludDMyX3QgcHJvdG9fY2hhaW47CiAgaW50MzJfdCBudW1iZXJfYmFzZTsKICBWZWN0b3IgaGlkZV9rZXlzOwp9IGluc3BlY3Rfb3B0aW9uc190OwoKc3RydWN0IHByb3Bfa2V5OwoKdHlwZWRlZiBzdHJ1Y3QgcHJvcF9rZXkgewogIHN0cnVjdCBsaXN0X2hlYWQgbGluazsKICBjb25zdCBjaGFyKiBuYW1lOwogIEpTQXRvbSBhdG9tOwp9IHByb3Bfa2V5X3Q7CgpzdGF0aWMgaW50IHN0ZG91dF9pc2F0dHksIHN0ZGVycl9pc2F0dHk7CnN0YXRpYyBpbnQzMl90IHNjcmVlbl93aWR0aCA9IC0xOwoKc3RhdGljIGludCBqc19pbnNwZWN0X3ByaW50KEpTQ29udGV4dCogY3R4LCBEeW5CdWYqIGJ1ZiwgSlNWYWx1ZUNvbnN0IHZhbHVlLCBpbnNwZWN0X29wdGlvbnNfdCogb3B0cywgaW50MzJfdCBkZXB0aCk7CgpzdGF0aWMgaW50CnJlZ2V4cF9wcmVkaWNhdGUoaW50IGMpIHsKICBzd2l0Y2goYykgewogICAgY2FzZSA4OiByZXR1cm4gJ3UnOwogICAgY2FzZSAxMjogcmV0dXJuICdmJzsKICAgIGNhc2UgMTA6IHJldHVybiAnbic7CiAgICBjYXNlIDEzOiByZXR1cm4gJ3InOwogICAgY2FzZSA5OiByZXR1cm4gJ3QnOwogICAgY2FzZSAxMTogcmV0dXJuICd2JzsKICB9CiAgaWYoYyA8IDB4MjApCiAgICByZXR1cm4gJ3UnOwogIHJldHVybiAwOwp9CgpzdGF0aWMgaW5saW5lIGludAppbnNwZWN0X3NjcmVlbl93aWR0aCh2b2lkKSB7CiAgaWYoc2NyZWVuX3dpZHRoICE9IC0xKQogICAgcmV0dXJuIHNjcmVlbl93aWR0aDsKCiNpZmRlZiBIQVZFX1RFUk1JT1NfSAogIHsKICAgIHN0cnVjdCB3aW5zaXplIHcgPSB7LndzX2NvbCA9IC0xLCAud3Nfcm93ID0gLTF9OwoKICAgIGlmKHN0ZG91dF9pc2F0dHkpCiAgICAgIGlvY3RsKFNURE9VVF9GSUxFTk8sIFRJT0NHV0lOU1osICZ3KTsKICAgIGVsc2UgaWYoc3RkZXJyX2lzYXR0eSkKICAgICAgaW9jdGwoU1RERVJSX0ZJTEVOTywgVElPQ0dXSU5TWiwgJncpOwoKICAgIHJldHVybiBzY3JlZW5fd2lkdGggPSB3LndzX2NvbDsKICB9CiNlbHNlCiAgcmV0dXJuIDgwOwojZW5kaWYKfQoKc3RhdGljIHZvaWQKaW5zcGVjdF9vcHRpb25zX2luaXQoaW5zcGVjdF9vcHRpb25zX3QqIG9wdHMsIEpTQ29udGV4dCogY3R4KSB7CiAgb3B0cy0+Y29sb3JzID0gVFJVRTsKICBvcHRzLT5zaG93X2hpZGRlbiA9IEZBTFNFOwogIG9wdHMtPmN1c3RvbV9pbnNwZWN0ID0gVFJVRTsKICBvcHRzLT5zaG93X3Byb3h5ID0gRkFMU0U7CiAgb3B0cy0+Z2V0dGVycyA9IEZBTFNFOwogIG9wdHMtPnN0cmluZ19icmVha19uZXdsaW5lID0gRkFMU0U7CiAgb3B0cy0+ZGVwdGggPSBJTlQzMl9NQVg7CiAgb3B0cy0+bWF4X2FycmF5X2xlbmd0aCA9IDMwMDsKICBvcHRzLT5tYXhfc3RyaW5nX2xlbmd0aCA9IElOVDMyX01BWDsKICBvcHRzLT5icmVha19sZW5ndGggPSBpbnNwZWN0X3NjcmVlbl93aWR0aCgpOwogIG9wdHMtPmNvbXBhY3QgPSA1OwogIG9wdHMtPnByb3RvX2NoYWluID0gMDsKICBvcHRzLT5udW1iZXJfYmFzZSA9IDEwOwogIHZlY3Rvcl9pbml0KCZvcHRzLT5oaWRlX2tleXMsIGN0eCk7Cn0KCnN0YXRpYyB2b2lkCmluc3BlY3Rfb3B0aW9uc19mcmVlKGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBKU0NvbnRleHQqIGN0eCkgewoKICBwcm9wX2tleV90KiBrZXk7CgogIHZlY3Rvcl9mb3JlYWNoX3QoJm9wdHMtPmhpZGVfa2V5cywga2V5KSB7CiAgICBKU19GcmVlQXRvbShjdHgsIGtleS0+YXRvbSk7CiAgICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBrZXktPm5hbWUpOwogIH0KICB2ZWN0b3JfZnJlZSgmb3B0cy0+aGlkZV9rZXlzKTsKfQoKc3RhdGljIHZvaWQKaW5zcGVjdF9vcHRpb25zX2dldChpbnNwZWN0X29wdGlvbnNfdCogb3B0cywgSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmplY3QpIHsKICBKU1ZhbHVlIHZhbHVlOwogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJjb2xvcnMiKTsKICBpZighSlNfSXNFeGNlcHRpb24odmFsdWUpICYmICFKU19Jc1VuZGVmaW5lZCh2YWx1ZSkpIHsKICAgIG9wdHMtPmNvbG9ycyA9IEpTX1RvQm9vbChjdHgsIHZhbHVlKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICB9CgogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJzaG93SGlkZGVuIik7CiAgaWYoIUpTX0lzRXhjZXB0aW9uKHZhbHVlKSAmJiAhSlNfSXNVbmRlZmluZWQodmFsdWUpKSB7CiAgICBvcHRzLT5zaG93X2hpZGRlbiA9IEpTX1RvQm9vbChjdHgsIHZhbHVlKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICB9CiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iamVjdCwgImN1c3RvbUluc3BlY3QiKTsKICBpZighSlNfSXNFeGNlcHRpb24odmFsdWUpICYmICFKU19Jc1VuZGVmaW5lZCh2YWx1ZSkpIHsKICAgIG9wdHMtPmN1c3RvbV9pbnNwZWN0ID0gSlNfVG9Cb29sKGN0eCwgdmFsdWUpOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIH0KCiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iamVjdCwgInNob3dQcm94eSIpOwogIGlmKCFKU19Jc0V4Y2VwdGlvbih2YWx1ZSkgJiYgIUpTX0lzVW5kZWZpbmVkKHZhbHVlKSkgewogICAgb3B0cy0+c2hvd19wcm94eSA9IEpTX1RvQm9vbChjdHgsIHZhbHVlKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICB9CgogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJnZXR0ZXJzIik7CiAgaWYoIUpTX0lzRXhjZXB0aW9uKHZhbHVlKSAmJiAhSlNfSXNVbmRlZmluZWQodmFsdWUpKSB7CiAgICBvcHRzLT5nZXR0ZXJzID0gSlNfVG9Cb29sKGN0eCwgdmFsdWUpOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIH0KCiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iamVjdCwgInN0cmluZ0JyZWFrTmV3bGluZSIpOwogIGlmKCFKU19Jc0V4Y2VwdGlvbih2YWx1ZSkgJiYgIUpTX0lzVW5kZWZpbmVkKHZhbHVlKSkgewogICAgb3B0cy0+c3RyaW5nX2JyZWFrX25ld2xpbmUgPSBKU19Ub0Jvb2woY3R4LCB2YWx1ZSk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgfQoKICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqZWN0LCAiZGVwdGgiKTsKICBpZighSlNfSXNVbmRlZmluZWQodmFsdWUpICYmICFKU19Jc0V4Y2VwdGlvbih2YWx1ZSkpIHsKICAgIGlmKEpTX1ZBTFVFX0dFVF9UQUcodmFsdWUpID09IEpTX1RBR19GTE9BVDY0ICYmIGlzaW5mKEpTX1ZBTFVFX0dFVF9GTE9BVDY0KHZhbHVlKSkpCiAgICAgIG9wdHMtPmRlcHRoID0gSU5UMzJfTUFYOwogICAgZWxzZQogICAgICBKU19Ub0ludDMyKGN0eCwgJm9wdHMtPmRlcHRoLCB2YWx1ZSk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgfQogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJtYXhBcnJheUxlbmd0aCIpOwogIGlmKCFKU19Jc1VuZGVmaW5lZCh2YWx1ZSkgJiYgIUpTX0lzRXhjZXB0aW9uKHZhbHVlKSkgewogICAgaWYoSlNfVkFMVUVfR0VUX1RBRyh2YWx1ZSkgPT0gSlNfVEFHX0ZMT0FUNjQgJiYgaXNpbmYoSlNfVkFMVUVfR0VUX0ZMT0FUNjQodmFsdWUpKSkKICAgICAgb3B0cy0+bWF4X2FycmF5X2xlbmd0aCA9IElOVDMyX01BWDsKICAgIGVsc2UKICAgICAgSlNfVG9JbnQzMihjdHgsICZvcHRzLT5tYXhfYXJyYXlfbGVuZ3RoLCB2YWx1ZSk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgfQogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJtYXhTdHJpbmdMZW5ndGgiKTsKICBpZighSlNfSXNVbmRlZmluZWQodmFsdWUpICYmICFKU19Jc0V4Y2VwdGlvbih2YWx1ZSkpIHsKICAgIGlmKEpTX1ZBTFVFX0dFVF9UQUcodmFsdWUpID09IEpTX1RBR19GTE9BVDY0ICYmIGlzaW5mKEpTX1ZBTFVFX0dFVF9GTE9BVDY0KHZhbHVlKSkpCiAgICAgIG9wdHMtPm1heF9zdHJpbmdfbGVuZ3RoID0gSU5UMzJfTUFYOwogICAgZWxzZQogICAgICBKU19Ub0ludDMyKGN0eCwgJm9wdHMtPm1heF9zdHJpbmdfbGVuZ3RoLCB2YWx1ZSk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgfQogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJicmVha0xlbmd0aCIpOwogIGlmKCFKU19Jc1VuZGVmaW5lZCh2YWx1ZSkgJiYgIUpTX0lzRXhjZXB0aW9uKHZhbHVlKSkgewogICAgaWYoSlNfVkFMVUVfR0VUX1RBRyh2YWx1ZSkgPT0gSlNfVEFHX0ZMT0FUNjQgJiYgaXNpbmYoSlNfVkFMVUVfR0VUX0ZMT0FUNjQodmFsdWUpKSkKICAgICAgb3B0cy0+YnJlYWtfbGVuZ3RoID0gSU5UMzJfTUFYOwogICAgZWxzZQogICAgICBKU19Ub0ludDMyKGN0eCwgJm9wdHMtPmJyZWFrX2xlbmd0aCwgdmFsdWUpOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIH0KICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqZWN0LCAiY29tcGFjdCIpOwogIGlmKCFKU19Jc1VuZGVmaW5lZCh2YWx1ZSkgJiYgIUpTX0lzRXhjZXB0aW9uKHZhbHVlKSkgewogICAgaWYoSlNfVkFMVUVfR0VUX1RBRyh2YWx1ZSkgPT0gSlNfVEFHX0JPT0wpCiAgICAgIG9wdHMtPmNvbXBhY3QgPSBKU19WQUxVRV9HRVRfQk9PTCh2YWx1ZSkgPT0gMCA/IDAgOiBJTlQzMl9NQVg7CiAgICBlbHNlIGlmKEpTX1ZBTFVFX0dFVF9UQUcodmFsdWUpID09IEpTX1RBR19GTE9BVDY0ICYmIGlzaW5mKEpTX1ZBTFVFX0dFVF9GTE9BVDY0KHZhbHVlKSkpCiAgICAgIG9wdHMtPmNvbXBhY3QgPSBJTlQzMl9NQVg7CiAgICBlbHNlCiAgICAgIEpTX1RvSW50MzIoY3R4LCAmb3B0cy0+Y29tcGFjdCwgdmFsdWUpOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIH0KICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqZWN0LCAiaGlkZUtleXMiKTsKICBpZihKU19Jc0FycmF5KGN0eCwgdmFsdWUpKSB7CiAgICBpbnQ2NF90IGxlbiwgcG9zOwogICAgbGVuID0ganNfYXJyYXlfbGVuZ3RoKGN0eCwgdmFsdWUpOwoKICAgIGZvcihwb3MgPSAwOyBwb3MgPCBsZW47IHBvcysrKSB7CiAgICAgIEpTVmFsdWUgaXRlbSA9IEpTX0dldFByb3BlcnR5VWludDMyKGN0eCwgdmFsdWUsIHBvcyk7CiAgICAgIHByb3Bfa2V5X3Qga2V5OwogICAgICBrZXkubmFtZSA9IEpTX1ZBTFVFX0dFVF9UQUcoaXRlbSkgPT0gSlNfVEFHX1NZTUJPTCA/IDAgOiBKU19Ub0NTdHJpbmcoY3R4LCBpdGVtKTsKICAgICAga2V5LmF0b20gPSBKU19WYWx1ZVRvQXRvbShjdHgsIGl0ZW0pOwogICAgICB2ZWN0b3JfcHVzaCgmb3B0cy0+aGlkZV9rZXlzLCBrZXkpOwogICAgICBKU19GcmVlVmFsdWUoY3R4LCBpdGVtKTsKICAgIH0KICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICB9CiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iamVjdCwgInByb3RvQ2hhaW4iKTsKICAvLyBpZihKU19Jc051bWJlcih2YWx1ZSkpCiAgSlNfVG9JbnQzMihjdHgsICZvcHRzLT5wcm90b19jaGFpbiwgdmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKCiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iamVjdCwgIm51bWJlckJhc2UiKTsKICBpZihKU19Jc051bWJlcih2YWx1ZSkpCiAgICBKU19Ub0ludDMyKGN0eCwgJm9wdHMtPm51bWJlcl9iYXNlLCB2YWx1ZSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwp9CgpzdGF0aWMgSlNWYWx1ZQppbnNwZWN0X29wdGlvbnNfb2JqZWN0KGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBKU0NvbnRleHQqIGN0eCkgewogIEpTVmFsdWUgYXJyLCByZXQgPSBKU19OZXdPYmplY3QoY3R4KTsKICB1aW50MzJfdCBuOwogIHByb3Bfa2V5X3QqIGtleTsKCiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJjb2xvcnMiLCBKU19OZXdCb29sKGN0eCwgb3B0cy0+Y29sb3JzKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJzaG93SGlkZGVuIiwgSlNfTmV3Qm9vbChjdHgsIG9wdHMtPnNob3dfaGlkZGVuKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJjdXN0b21JbnNwZWN0IiwgSlNfTmV3Qm9vbChjdHgsIG9wdHMtPmN1c3RvbV9pbnNwZWN0KSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJzaG93UHJveHkiLCBKU19OZXdCb29sKGN0eCwgb3B0cy0+c2hvd19wcm94eSkpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAiZ2V0dGVycyIsIEpTX05ld0Jvb2woY3R4LCBvcHRzLT5nZXR0ZXJzKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJzdHJpbmdCcmVha05ld2xpbmUiLCBKU19OZXdCb29sKGN0eCwgb3B0cy0+c3RyaW5nX2JyZWFrX25ld2xpbmUpKTsKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgImRlcHRoIiwganNfbnVtYmVyX25ldyhjdHgsIG9wdHMtPmRlcHRoKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJtYXhBcnJheUxlbmd0aCIsIGpzX251bWJlcl9uZXcoY3R4LCBvcHRzLT5tYXhfYXJyYXlfbGVuZ3RoKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJtYXhTdHJpbmdMZW5ndGgiLCBqc19udW1iZXJfbmV3KGN0eCwgb3B0cy0+bWF4X3N0cmluZ19sZW5ndGgpKTsKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgImJyZWFrTGVuZ3RoIiwganNfbnVtYmVyX25ldyhjdHgsIG9wdHMtPmJyZWFrX2xlbmd0aCkpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAiY29tcGFjdCIsIGpzX25ld19ib29sX29yX251bWJlcihjdHgsIG9wdHMtPmNvbXBhY3QpKTsKICBpZihvcHRzLT5wcm90b19jaGFpbikKICAgIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAicHJvdG9DaGFpbiIsIGpzX251bWJlcl9uZXcoY3R4LCBvcHRzLT5wcm90b19jaGFpbikpOwogIGFyciA9IEpTX05ld0FycmF5KGN0eCk7CiAgbiA9IDA7CiAgdmVjdG9yX2ZvcmVhY2hfdCgmb3B0cy0+aGlkZV9rZXlzLCBrZXkpIHsgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCBhcnIsIG4rKywganNfYXRvbV90b3ZhbHVlKGN0eCwga2V5LT5hdG9tKSk7IH0KICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgImhpZGVLZXlzIiwgYXJyKTsKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgIm51bWJlckJhc2UiLCBqc19udW1iZXJfbmV3KGN0eCwgb3B0cy0+bnVtYmVyX2Jhc2UpKTsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50Cmluc3BlY3Rfb3B0aW9uc19oaWRkZW4oaW5zcGVjdF9vcHRpb25zX3QqIG9wdHMsIEpTQXRvbSBhdG9tKSB7CiAgcHJvcF9rZXlfdCoga2V5OwogIHZlY3Rvcl9mb3JlYWNoX3QoJm9wdHMtPmhpZGVfa2V5cywga2V5KSB7CiAgICBpZihrZXktPmF0b20gPT0gYXRvbSkgLy8hIHN0cmNtcChrZXktPm5hbWUsIHN0cikpCiAgICAgIHJldHVybiAxOwogIH0KICByZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQKaW5zcGVjdF9uZXdsaW5lKER5bkJ1ZiogYnVmLCBpbnQzMl90IGRlcHRoKSB7CiAgZGJ1Zl9wdXRjKGJ1ZiwgJ1xuJyk7CiAgd2hpbGUoZGVwdGgtLSA+IDApIGRidWZfcHV0c3RyKGJ1ZiwgIiAgIik7Cn0KCnN0YXRpYyBpbnQKanNfb2JqZWN0X2dldHByb3BlcnR5bmFtZXMoSlNDb250ZXh0KiBjdHgsIHVuaW9uIFZlY3RvciogcHJvcGVudW1fdGFiLCBKU1ZhbHVlQ29uc3Qgb2JqLCBpbnQgZmxhZ3MpIHsKICBpbnQgcmV0OwogIEpTUHJvcGVydHlFbnVtKiB0bXBfdGFiOwogIHVpbnQzMl90IGksIHRtcF9sZW47CiAgcmV0ID0gSlNfR2V0T3duUHJvcGVydHlOYW1lcyhjdHgsICZ0bXBfdGFiLCAmdG1wX2xlbiwgb2JqLCBmbGFncyk7CgogIGZvcihpID0gMDsgaSA8IHRtcF9sZW47IGkrKykgewogICAgaWYodmVjdG9yX2ZpbmQocHJvcGVudW1fdGFiLCBzaXplb2YoSlNQcm9wZXJ0eUVudW0pLCAmdG1wX3RhYltpXSkgPT0gLTEpCiAgICAgIHZlY3Rvcl9wdXQocHJvcGVudW1fdGFiLCAmdG1wX3RhYltpXSwgc2l6ZW9mKEpTUHJvcGVydHlFbnVtKSk7CiAgfQoKICBqc19mcmVlKGN0eCwgdG1wX3RhYik7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGludApqc19vYmplY3RfZ2V0cHJvcGVydHluYW1lc19yZWN1cnNpdmUoSlNDb250ZXh0KiBjdHgsIHVuaW9uIFZlY3RvciogcHJvcGVudW1fdGFiLCBKU1ZhbHVlQ29uc3Qgb2JqLCBpbnQgZmxhZ3MpIHsKICBpbnQgcmV0OwoKICB3aGlsZSgocmV0ID0ganNfb2JqZWN0X2dldHByb3BlcnR5bmFtZXMoY3R4LCBwcm9wZW51bV90YWIsIG9iaiwgZmxhZ3MpKSA+PSAwKSB7CiAgICBKU1ZhbHVlIHByb3RvID0gSlNfR2V0UHJvdG90eXBlKGN0eCwgb2JqKTsKCiAgICBpZighSlNfSXNPYmplY3QocHJvdG8pKQogICAgICBicmVhazsKCiAgICBvYmogPSBwcm90bzsKICAgIC8vICAgICAgcmV0ID0ganNfb2JqZWN0X2dldHByb3BlcnR5bmFtZXNfcmVjdXJzaXZlKGN0eCwgcHJvcGVudW1fdGFiLCBwcm90bywgZmxhZ3MpOwogIH0KCiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTQXRvbQpqc19pbnNwZWN0X2N1c3RvbV9hdG9tKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBzeW1fZm9yKSB7CiAgSlNWYWx1ZSBrZXksIHN5bTsKICBKU0F0b20gYXRvbTsKICBrZXkgPSBKU19OZXdTdHJpbmcoY3R4LCBzeW1fZm9yID8gc3ltX2ZvciA6ICJxdWlja2pzLmluc3BlY3QuY3VzdG9tIik7CiAgc3ltID0ganNfc3ltYm9sX2ludm9rZV9zdGF0aWMoY3R4LCAiZm9yIiwga2V5KTsKICBKU19GcmVlVmFsdWUoY3R4LCBrZXkpOwogIGF0b20gPSBKU19WYWx1ZVRvQXRvbShjdHgsIHN5bSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgc3ltKTsKCiAgcmV0dXJuIGF0b207Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzX2luc3BlY3RfY3VzdG9tX2NhbGwoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBpbnQzMl90IGRlcHRoKSB7CiAgSlNWYWx1ZSByZXQgPSBKU19VTkRFRklORUQ7CiAgSlNWYWx1ZSBpbnNwZWN0ID0gSlNfVU5ERUZJTkVEOwogIEpTQXRvbSBwcm9wOwoKICBpZihKU19WQUxVRV9HRVRfT0JKKG9iaiktPmNsYXNzX2lkKSB7CiAgICBpZihKU19IYXNQcm9wZXJ0eShjdHgsIG9iaiwgaW5zcGVjdF9jdXN0b21fYXRvbSkpCiAgICAgIGluc3BlY3QgPSBKU19HZXRQcm9wZXJ0eShjdHgsIG9iaiwgaW5zcGVjdF9jdXN0b21fYXRvbSk7CiAgICBlbHNlIGlmKEpTX0hhc1Byb3BlcnR5KGN0eCwgb2JqLCBpbnNwZWN0X2N1c3RvbV9hdG9tX25vZGUpKQogICAgICBpbnNwZWN0ID0gSlNfR2V0UHJvcGVydHkoY3R4LCBvYmosIGluc3BlY3RfY3VzdG9tX2F0b21fbm9kZSk7CiAgfQogIGlmKEpTX0lzRnVuY3Rpb24oY3R4LCBpbnNwZWN0KSkgewogICAgSlNWYWx1ZUNvbnN0IGFyZ3NbMl07CiAgICBpbnNwZWN0X29wdGlvbnNfdCBvcHRzX25vY3VzdG9tOwogICAgbWVtY3B5KCZvcHRzX25vY3VzdG9tLCBvcHRzLCBzaXplb2YoaW5zcGVjdF9vcHRpb25zX3QpKTsKICAgIG9wdHNfbm9jdXN0b20uY3VzdG9tX2luc3BlY3QgPSBGQUxTRTsKICAgIGFyZ3NbMF0gPSBqc19udW1iZXJfbmV3KGN0eCwgSU5TUEVDVF9MRVZFTChvcHRzKSk7CiAgICBhcmdzWzFdID0gaW5zcGVjdF9vcHRpb25zX29iamVjdCgmb3B0c19ub2N1c3RvbSwgY3R4KTsKICAgIHJldCA9IEpTX0NhbGwoY3R4LCBpbnNwZWN0LCBvYmosIDIsIGFyZ3MpOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgYXJnc1swXSk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCBhcmdzWzFdKTsKICAgIC8qICAgc3RyID0gSlNfVG9DU3RyaW5nKGN0eCwgcmV0KTsKICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHJldCk7Ki8KICB9CgogIEpTX0ZyZWVWYWx1ZShjdHgsIGluc3BlY3QpOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQKanNfaW5zcGVjdF9tYXAoSlNDb250ZXh0KiBjdHgsIER5bkJ1ZiogYnVmLCBKU1ZhbHVlQ29uc3Qgb2JqLCBpbnNwZWN0X29wdGlvbnNfdCogb3B0cywgaW50MzJfdCBkZXB0aCkgewogIEJPT0wgcmV0LCBmaW5pc2ggPSBGQUxTRTsKICBzaXplX3QgaSA9IDA7CiAgaW50IGNvbXBhY3QgPSBJTlNQRUNUX0lTX0NPTVBBQ1Qob3B0cyk7CiAgLy8gcHJpbnRmKCJqc19pbnNwZWN0X21hcCBsZXZlbD0ldSBvcHRzLT5kZXB0aD0lIiBQUklkMzIgIiBkZXB0aD0lIiBQUklkMzIgIgogIC8vIGNvbXBhY3Q9JWlcbiIsIElOU1BFQ1RfTEVWRUwob3B0cyksIG9wdHMtPmRlcHRoLCBkZXB0aCwgY29tcGFjdCk7CiAgSlNWYWx1ZSBkYXRhLCBrZXksIHZhbHVlOwogIEl0ZXJhdGlvbiBpdDsKICBpZighKHJldCA9IGl0ZXJhdGlvbl9tZXRob2Rfc3ltYm9sKCZpdCwgY3R4LCBvYmosICJpdGVyYXRvciIpKSkgewogICAgSlNfVGhyb3dUeXBlRXJyb3IoY3R4LCAianNfaW5zcGVjdF9tYXAgdGFnPSVkXG4iLCBKU19WQUxVRV9HRVRfVEFHKG9iaikpOwogICAgcmV0dXJuIDA7CiAgfQogIGRidWZfcHV0c3RyKGJ1ZiwgIk1hcCB7Iik7CiAgaWYoIWNvbXBhY3QgJiYgb3B0cy0+YnJlYWtfbGVuZ3RoICE9IElOVDMyX01BWCkKICAgIGluc3BlY3RfbmV3bGluZShidWYsIElOU1BFQ1RfTEVWRUwob3B0cykpOwogIGZvcihpID0gMDsgIShmaW5pc2ggPSBpdGVyYXRpb25fbmV4dCgmaXQsIGN0eCkpOyBpKyspIHsKICAgIGlmKCFmaW5pc2gpIHsKICAgICAgZGF0YSA9IGl0ZXJhdGlvbl92YWx1ZSgmaXQsIGN0eCk7CiAgICAgIGlmKGkpIHsKICAgICAgICBkYnVmX3B1dHN0cihidWYsICIsIik7CiAgICAgICAgaWYoIWNvbXBhY3QgJiYgb3B0cy0+YnJlYWtfbGVuZ3RoICE9IElOVDMyX01BWCkKICAgICAgICAgIGluc3BlY3RfbmV3bGluZShidWYsIElOU1BFQ1RfTEVWRUwob3B0cykpOwogICAgICB9CiAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgY29tcGFjdCA/ICIgIiA6ICIgICIpOwogICAgICBrZXkgPSBKU19HZXRQcm9wZXJ0eVVpbnQzMihjdHgsIGRhdGEsIDApOwogICAgICBqc19pbnNwZWN0X3ByaW50KGN0eCwgYnVmLCBrZXksIG9wdHMsIGRlcHRoIC0gMSk7CiAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgIiA9PiAiKTsKICAgICAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVVpbnQzMihjdHgsIGRhdGEsIDEpOwogICAgICBqc19pbnNwZWN0X3ByaW50KGN0eCwgYnVmLCB2YWx1ZSwgb3B0cywgZGVwdGggLSAxKTsKICAgICAgSlNfRnJlZVZhbHVlKGN0eCwga2V5KTsKICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogICAgICBKU19GcmVlVmFsdWUoY3R4LCBkYXRhKTsKICAgIH0KICB9CiAgaWYoIWNvbXBhY3QgJiYgb3B0cy0+YnJlYWtfbGVuZ3RoICE9IElOVDMyX01BWCkKICAgIGluc3BlY3RfbmV3bGluZShidWYsIElOU1BFQ1RfTEVWRUwob3B0cykpOwogIGRidWZfcHV0c3RyKGJ1ZiwgY29tcGFjdCA/ICIgfSIgOiAifSIpOwogIGl0ZXJhdGlvbl9yZXNldCgmaXQsIEpTX0dldFJ1bnRpbWUoY3R4KSk7CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQKanNfaW5zcGVjdF9zZXQoSlNDb250ZXh0KiBjdHgsIER5bkJ1ZiogYnVmLCBKU1ZhbHVlQ29uc3Qgb2JqLCBpbnNwZWN0X29wdGlvbnNfdCogb3B0cywgaW50MzJfdCBkZXB0aCkgewogIEJPT0wgcmV0LCBmaW5pc2ggPSBGQUxTRTsKICBzaXplX3QgaSA9IDA7CiAgaW50IGNvbXBhY3QgPSBJTlNQRUNUX0lTX0NPTVBBQ1Qob3B0cyk7CiAgSlNWYWx1ZSB2YWx1ZTsKICBJdGVyYXRpb24gaXQ7CgogIGlmKCEocmV0ID0gaXRlcmF0aW9uX21ldGhvZF9zeW1ib2woJml0LCBjdHgsIG9iaiwgIml0ZXJhdG9yIikpKSB7CiAgICBKU19UaHJvd1R5cGVFcnJvcihjdHgsICJqc19pbnNwZWN0X21hcCB0YWc9JWRcbiIsIEpTX1ZBTFVFX0dFVF9UQUcob2JqKSk7CiAgICByZXR1cm4gMDsKICB9CiAgZGJ1Zl9wdXRzdHIoYnVmLCAiU2V0IFsiKTsKICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgSU5TUEVDVF9MRVZFTChvcHRzKSk7CiAgZm9yKGkgPSAwOyAhKGZpbmlzaCA9IGl0ZXJhdGlvbl9uZXh0KCZpdCwgY3R4KSk7IGkrKykgewogICAgaWYoIWZpbmlzaCkgewogICAgICB2YWx1ZSA9IGl0ZXJhdGlvbl92YWx1ZSgmaXQsIGN0eCk7CiAgICAgIGlmKGkpIHsKICAgICAgICBkYnVmX3B1dHN0cihidWYsICIsIik7CiAgICAgICAgaWYoIWNvbXBhY3QgJiYgb3B0cy0+YnJlYWtfbGVuZ3RoICE9IElOVDMyX01BWCkKICAgICAgICAgIGluc3BlY3RfbmV3bGluZShidWYsIElOU1BFQ1RfTEVWRUwob3B0cykpOwogICAgICB9CiAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgY29tcGFjdCA/ICIgIiA6ICIgICIpOwogICAgICBqc19pbnNwZWN0X3ByaW50KGN0eCwgYnVmLCB2YWx1ZSwgb3B0cywgZGVwdGgpOwogICAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgICB9CiAgfQogIGlmKCFjb21wYWN0ICYmIG9wdHMtPmJyZWFrX2xlbmd0aCAhPSBJTlQzMl9NQVgpCiAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpKTsKICBkYnVmX3B1dHN0cihidWYsIGNvbXBhY3QgPyAiIF0iIDogIl0iKTsKICBpdGVyYXRpb25fcmVzZXQoJml0LCBKU19HZXRSdW50aW1lKGN0eCkpOwogIHJldHVybiAwOwp9CgpzdGF0aWMgaW50CmpzX2luc3BlY3RfYXJyYXlidWZmZXIoSlNDb250ZXh0KiBjdHgsIER5bkJ1ZiogYnVmLCBKU1ZhbHVlQ29uc3QgdmFsdWUsIGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBpbnQzMl90IGRlcHRoKSB7CiAgY29uc3QgY2hhciAqc3RyLCAqc3RyMjsKICB1aW50OF90KiBwdHI7CiAgc2l6ZV90IGksIHNsZW4sIHNpemU7CiAgaW50IGJyZWFrX2xlbiA9IG9wdHMtPmJyZWFrX2xlbmd0aDsgLy8gaW5zcGVjdF9zY3JlZW5fd2lkdGgoKTsKICBpbnQgY29sdW1uID0gZGJ1Zl9nZXRfY29sdW1uKGJ1Zik7CiAgSlNWYWx1ZSBwcm90bzsKICBicmVha19sZW4gPSAoYnJlYWtfbGVuICsgMSkgLyAzOwogIGJyZWFrX2xlbiAqPSAzOwoKICBpZihicmVha19sZW4gPiBvcHRzLT5icmVha19sZW5ndGgpCiAgICBicmVha19sZW4gPSBvcHRzLT5icmVha19sZW5ndGg7CiAgcHRyID0gSlNfR2V0QXJyYXlCdWZmZXIoY3R4LCAmc2l6ZSwgdmFsdWUpOwogIC8vIHByaW50ZigibWF4QXJyYXlMZW5ndGg6ICVpXG4iLCBvcHRzLT5tYXhfYXJyYXlfbGVuZ3RoKTsKICBwcm90byA9IEpTX0dldFByb3RvdHlwZShjdHgsIHZhbHVlKTsKICBzdHIgPSBqc19vYmplY3RfdG9zdHJpbmcoY3R4LCBwcm90byk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgcHJvdG8pOwoKICBpZihqc19pc19hcnJheWJ1ZmZlcihjdHgsIHZhbHVlKSkKICAgIGRidWZfcHV0c3RyKGJ1ZiwgIkFycmF5QnVmZmVyIik7CiAgZWxzZSBpZihqc19pc19zaGFyZWRhcnJheWJ1ZmZlcihjdHgsIHZhbHVlKSkKICAgIGRidWZfcHV0c3RyKGJ1ZiwgIlNoYXJlZEFycmF5QnVmZmVyIik7CiAgZWxzZSBpZihzdHIgJiYgKHN0cjIgPSBzdHJjaHIoc3RyLCAnICcpKSkgewogICAgc3RyMisrOwogICAgc2xlbiA9IGJ5dGVfY2hyKHN0cjIsIHN0cmxlbihzdHIyKSwgJ10nKTsKICAgIGRidWZfYXBwZW5kKGJ1ZiwgKGNvbnN0IHVpbnQ4X3QqKXN0cjIsIHNsZW4pOwogIH0KCiAgaWYoc3RyKQogICAganNfY3N0cmluZ19mcmVlKGN0eCwgc3RyKTsKCiAgZGJ1Zl9wdXRzdHIoYnVmLCAiIHsiKTsKICBpbnNwZWN0X25ld2xpbmUoYnVmLCAob3B0cy0+ZGVwdGggLSBkZXB0aCkgKyAyKTsKICBkYnVmX3ByaW50ZihidWYsICJieXRlTGVuZ3RoOiAlenUgWyIsIHNpemUpOwogIGluc3BlY3RfbmV3bGluZShidWYsIChvcHRzLT5kZXB0aCAtIGRlcHRoKSArIDMpOwogIGJyZWFrX2xlbiAtPSAoKG9wdHMtPmRlcHRoIC0gZGVwdGgpICsgMykgKiAyOwogIGNvbHVtbiA9IDA7CgogIGZvcihpID0gMDsgaSA8IHNpemU7IGkrKykgewogICAgaWYoaSA9PSAoc2l6ZV90KW9wdHMtPm1heF9hcnJheV9sZW5ndGgpCiAgICAgIGJyZWFrOwogICAgaWYoY29sdW1uICsgMyA+PSBicmVha19sZW4gJiYgb3B0cy0+YnJlYWtfbGVuZ3RoICE9IElOVDMyX01BWCkgewogICAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCAob3B0cy0+ZGVwdGggLSBkZXB0aCkgKyAzKTsKICAgICAgY29sdW1uID0gMDsKICAgIH0KICAgIGRidWZfcHJpbnRmKGJ1ZiwgY29sdW1uID8gIiAlMDJ4IiA6ICIlMDJ4IiwgcHRyW2ldKTsKICAgIGNvbHVtbiArPSBjb2x1bW4gPyAzIDogMjsKICB9CiAgaWYoaSA8IHNpemUpIHsKICAgIGluc3BlY3RfbmV3bGluZShidWYsIChvcHRzLT5kZXB0aCAtIGRlcHRoKSArIDMpOwoKICAgIGRidWZfcHJpbnRmKGJ1ZiwgIi4uLiAlenUgbW9yZSBieXRlcyIsIHNpemUgLSBpKTsKICB9CiAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgKG9wdHMtPmRlcHRoIC0gZGVwdGgpICsgMik7CiAgZGJ1Zl9wdXRzdHIoYnVmLCAiXSIpOwogIGluc3BlY3RfbmV3bGluZShidWYsIChvcHRzLT5kZXB0aCAtIGRlcHRoKSArIDEpOwogIGRidWZfcHV0c3RyKGJ1ZiwgIn0iKTsKICByZXR1cm4gMDsKfQoKc3RhdGljIGludApqc19pbnNwZWN0X3JlZ2V4cChKU0NvbnRleHQqIGN0eCwgRHluQnVmKiBidWYsIEpTVmFsdWVDb25zdCB2YWx1ZSwgaW5zcGVjdF9vcHRpb25zX3QqIG9wdHMsIGludDMyX3QgZGVwdGgpIHsKICBjb25zdCBjaGFyKiBzdHI7CiAgc2l6ZV90IGxlbjsKICBzdHIgPSBKU19Ub0NTdHJpbmdMZW4oY3R4LCAmbGVuLCB2YWx1ZSk7CiAgaWYob3B0cy0+Y29sb3JzKQogICAgZGJ1Zl9wdXRzdHIoYnVmLCAiXHgxYlswOzMxbSIpOwogIGRidWZfcHV0X2VzY2FwZWRfcHJlZChidWYsIHN0ciwgbGVuLCByZWdleHBfcHJlZGljYXRlKTsKICBpZihvcHRzLT5jb2xvcnMpCiAgICBkYnVmX3B1dHN0cihidWYsICJceDFiW20iKTsKICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBzdHIpOwogIHJldHVybiAwOwp9CgpzdGF0aWMgaW50CmpzX2luc3BlY3RfbnVtYmVyKEpTQ29udGV4dCogY3R4LCBEeW5CdWYqIGJ1ZiwgSlNWYWx1ZUNvbnN0IHZhbHVlLCBpbnNwZWN0X29wdGlvbnNfdCogb3B0cywgaW50MzJfdCBkZXB0aCkgewogIGludCB0YWcgPSBKU19WQUxVRV9HRVRfVEFHKHZhbHVlKTsKICBjb25zdCBjaGFyKiBzdHI7CiAgc2l6ZV90IGxlbjsKICBKU1ZhbHVlIG51bWJlciwgYmFzZTsKICBpZih0YWcgIT0gSlNfVEFHX1NZTUJPTCAmJiBvcHRzLT5jb2xvcnMpCiAgICBkYnVmX3B1dHN0cihidWYsIENPTE9SX0xJR0hUWUVMTE9XKTsKICBpZihvcHRzLT5udW1iZXJfYmFzZSAmJiBvcHRzLT5udW1iZXJfYmFzZSAhPSAxMCkgewogICAgYmFzZSA9IEpTX05ld0ludDMyKGN0eCwgMTYpOwogICAgbnVtYmVyID0ganNfaW52b2tlKGN0eCwgdmFsdWUsICJ0b1N0cmluZyIsIDEsICZiYXNlKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGJhc2UpOwoKICB9IGVsc2UgewogICAgbnVtYmVyID0gSlNfRHVwVmFsdWUoY3R4LCB2YWx1ZSk7CiAgfQogIHN0ciA9IEpTX1RvQ1N0cmluZ0xlbihjdHgsICZsZW4sIG51bWJlcik7CiAgSlNfRnJlZVZhbHVlKGN0eCwgbnVtYmVyKTsKCiAgc3dpdGNoKG9wdHMtPm51bWJlcl9iYXNlKSB7CiAgICBjYXNlIDE2OiBkYnVmX3B1dHN0cihidWYsICIweCIpOyBicmVhazsKICAgIGNhc2UgMjogZGJ1Zl9wdXRzdHIoYnVmLCAiMGIiKTsgYnJlYWs7CiAgICBjYXNlIDg6IGRidWZfcHV0c3RyKGJ1ZiwgIjAiKTsgYnJlYWs7CiAgfQoKICBkYnVmX2FwcGVuZChidWYsIChjb25zdCB1aW50OF90KilzdHIsIGxlbik7CiAganNfY3N0cmluZ19mcmVlKGN0eCwgc3RyKTsKICBpZih0YWcgPD0gSlNfVEFHX0JJR19GTE9BVCkKICAgIGRidWZfcHV0YyhidWYsIHRhZyA9PSBKU19UQUdfQklHX0RFQ0lNQUwgPyAnbScgOiB0YWcgPT0gSlNfVEFHX0JJR19GTE9BVCA/ICdsJyA6ICduJyk7CiAgaWYob3B0cy0+Y29sb3JzKQogICAgZGJ1Zl9wdXRzdHIoYnVmLCBDT0xPUl9OT05FKTsKICByZXR1cm4gMDsKfQoKc3RhdGljIGludApqc19pbnNwZWN0X3N0cmluZyhKU0NvbnRleHQqIGN0eCwgRHluQnVmKiBidWYsIEpTVmFsdWVDb25zdCB2YWx1ZSwgaW5zcGVjdF9vcHRpb25zX3QqIG9wdHMsIGludDMyX3QgZGVwdGgpIHsKICBpbnQgdGFnID0gSlNfVkFMVUVfR0VUX1RBRyh2YWx1ZSk7CiAgaW50IGNvbXBhY3QgPSBJTlNQRUNUX0lTX0NPTVBBQ1Qob3B0cyk7CgogIGNvbnN0IGNoYXIqIHN0cjsKICBzaXplX3QgcG9zLCBsZW4sIG1heF9sZW4sIGxpbWl0LCBjb2x1bW5fc3RhcnQgPSAoSU5TUEVDVF9MRVZFTChvcHRzKSAqIDIpOwogIGludCBjb2wgPSBkYnVmX2dldF9jb2x1bW4oYnVmKTsKICBzdHIgPSBKU19Ub0NTdHJpbmdMZW4oY3R4LCAmbGVuLCB2YWx1ZSk7CiAgbWF4X2xlbiA9IG1pbl9zaXplKG9wdHMtPmJyZWFrX2xlbmd0aCAtIGNvbCAtIDEwLCBsZW4pOwoKICBpZih0YWcgIT0gSlNfVEFHX1NZTUJPTCAmJiBvcHRzLT5jb2xvcnMpCiAgICBkYnVmX3B1dHN0cihidWYsIENPTE9SX0dSRUVOKTsKICBkYnVmX3B1dGMoYnVmLCB0YWcgPT0gSlNfVEFHX1NZTUJPTCA/ICcoJyA6ICdcJycpOwogIGxpbWl0ID0gbWluX3NpemUob3B0cy0+bWF4X3N0cmluZ19sZW5ndGgsIGxlbik7CgogIGZvcihwb3MgPSAwOyBwb3MgPCBsaW1pdDspIHsKICAgIHNpemVfdCBpLCBuLCBlb2w7CiAgICBuID0gbGltaXQgLSBwb3M7CiAgICBpZihwb3MgPiAwKSB7CiAgICAgIGRidWZfcHV0c3RyKGJ1Ziwgb3B0cy0+Y29sb3JzID8gIiciIENPTE9SX05PTkUgIiArIiA6ICInICsiKTsKICAgICAgbWF4X2xlbiA9IG9wdHMtPmJyZWFrX2xlbmd0aCAtIGNvbHVtbl9zdGFydCAtIDg7CiAgICAgIGluc3BlY3RfbmV3bGluZShidWYsIElOU1BFQ1RfTEVWRUwob3B0cykgKyAxKTsKICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBvcHRzLT5jb2xvcnMgPyBDT0xPUl9HUkVFTiAiJyIgOiAiJyIpOwogICAgfQogICAgaWYoY29tcGFjdCkgewogICAgICBuID0gYW5zaV90cnVuY2F0ZSgmc3RyW3Bvc10sIG4sIG1heF9sZW4pOwogICAgfSBlbHNlIGlmKG9wdHMtPnN0cmluZ19icmVha19uZXdsaW5lKSB7CiAgICAgIGZvcihpID0gcG9zOyBpIDwgbGltaXQ7IGkgKz0gZW9sKSB7CiAgICAgICAgZW9sID0gYnl0ZV9jaHIoJnN0cltpXSwgbGltaXQgLSBpLCAnXG4nKTsKICAgICAgICBpZihzdHJbaSArIGVvbF0gPT0gJ1xuJykKICAgICAgICAgIGVvbCsrOwoKICAgICAgICBpZihpID4gcG9zICYmIGFuc2lfdHJ1bmNhdGUoJnN0cltwb3NdLCBpICsgZW9sIC0gcG9zLCBtYXhfbGVuKSA8IGkgKyBlb2wgLSBwb3MpIHsKICAgICAgICAgIG4gPSBpIC0gcG9zOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBkYnVmX3B1dF9lc2NhcGVkKGJ1ZiwgJnN0cltwb3NdLCBuKTsKICAgIHBvcyArPSBuOwogIH0KICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBzdHIpOwogIGRidWZfcHV0YyhidWYsIHRhZyA9PSBKU19UQUdfU1lNQk9MID8gJyknIDogJ1wnJyk7CgogIGlmKG9wdHMtPmNvbG9ycykKICAgIGRidWZfcHV0c3RyKGJ1ZiwgQ09MT1JfTk9ORSk7CgogIGlmKGxpbWl0IDwgbGVuKSB7CiAgICBpZihvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYICYmIGRidWZfZ2V0X2NvbHVtbihidWYpICsgMjYgPiBvcHRzLT5icmVha19sZW5ndGgpCiAgICAgIGluc3BlY3RfbmV3bGluZShidWYsIElOU1BFQ1RfTEVWRUwob3B0cykgKyAxKTsKICAgIGRidWZfcHJpbnRmKGJ1ZiwgIi4uLiAlenUgbW9yZSBjaGFyYWN0ZXJzIiwgbGVuIC0gcG9zKTsKICB9CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQKanNfaW5zcGVjdF9wcmludChKU0NvbnRleHQqIGN0eCwgRHluQnVmKiBidWYsIEpTVmFsdWVDb25zdCB2YWx1ZSwgaW5zcGVjdF9vcHRpb25zX3QqIG9wdHMsIGludDMyX3QgZGVwdGgpIHsKICBpbnQgdGFnID0gSlNfVkFMVUVfR0VUX1RBRyh2YWx1ZSk7CiAgLy8gaW50IGNvbXBhY3QgPSBJTlNQRUNUX0lTX0NPTVBBQ1Qob3B0cyk7CiAgLy8gcHJpbnRmKCJqc19pbnNwZWN0X3ByaW50IGxldmVsOiAlZFxuIiwgSU5TUEVDVF9MRVZFTChvcHRzKSk7CiAgc3dpdGNoKHRhZykgewogICAgY2FzZSBKU19UQUdfRkxPQVQ2NDoKICAgIGNhc2UgSlNfVEFHX0JJR19ERUNJTUFMOgogICAgY2FzZSBKU19UQUdfQklHX0lOVDoKICAgIGNhc2UgSlNfVEFHX0lOVDoKICAgIGNhc2UgSlNfVEFHX0JJR19GTE9BVDogewogICAgICByZXR1cm4ganNfaW5zcGVjdF9udW1iZXIoY3R4LCBidWYsIHZhbHVlLCBvcHRzLCBkZXB0aCk7CiAgICB9CgogICAgICAvKiBjYXNlIEpTX1RBR19JTlQ6IHsKICAgICAgICAgaW50IGkgPSBKU19WQUxVRV9HRVRfSU5UKHZhbHVlKTsKICAgICAgICAgaWYob3B0cy0+Y29sb3JzKQogICAgICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgQ09MT1JfWUVMTE9XKTsKICAgICAgICAgZGJ1Zl9wcmludGYoYnVmLCAiJWkiLCBpKTsKICAgICAgICAgaWYob3B0cy0+Y29sb3JzKQogICAgICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgQ09MT1JfTk9ORSk7CiAgICAgICAgIGJyZWFrOwogICAgICAgfSovCgogICAgY2FzZSBKU19UQUdfQk9PTDogewogICAgICBpZihvcHRzLT5jb2xvcnMpCiAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBDT0xPUl9ZRUxMT1cpOwogICAgICBkYnVmX3B1dHN0cihidWYsIEpTX1ZBTFVFX0dFVF9CT09MKHZhbHVlKSA/ICJ0cnVlIiA6ICJmYWxzZSIpOwogICAgICBpZihvcHRzLT5jb2xvcnMpCiAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBDT0xPUl9OT05FKTsKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBKU19UQUdfTlVMTDogewogICAgICBkYnVmX3B1dHN0cihidWYsIG9wdHMtPmNvbG9ycyA/ICJceDFiWzM4OzU7MTI5bW51bGxceDFiW20iIDogIm51bGwiKTsKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBKU19UQUdfVU5ERUZJTkVEOiB7CiAgICAgIGRidWZfcHV0X2NvbG9yc3RyKGJ1ZiwgInVuZGVmaW5lZCIsIENPTE9SX0dSQVksIG9wdHMtPmNvbG9ycyk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgSlNfVEFHX0VYQ0VQVElPTjogewogICAgICBkYnVmX3B1dF9jb2xvcnN0cihidWYsICJbZXhjZXB0aW9uXSIsIENPTE9SX1JFRCwgb3B0cy0+Y29sb3JzKTsKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBKU19UQUdfU1lNQk9MOiB7CiAgICAgIHZhbHVlID0ganNfc3ltYm9sX3RvX3N0cmluZyhjdHgsIHZhbHVlKTsKICAgICAgaWYob3B0cy0+Y29sb3JzKQogICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgQ09MT1JfR1JFRU4pOwogICAgICBkYnVmX3B1dHN0cihidWYsICJTeW1ib2wiKTsKICAgICAgX19hdHRyaWJ1dGVfXygoZmFsbHRocm91Z2gpKTsKICAgIH0KCiAgICBjYXNlIEpTX1RBR19TVFJJTkc6IHsKICAgICAgcmV0dXJuIGpzX2luc3BlY3Rfc3RyaW5nKGN0eCwgYnVmLCB2YWx1ZSwgb3B0cywgZGVwdGgpOwogICAgfQoKICAgIGNhc2UgSlNfVEFHX09CSkVDVDogewogICAgICBCT09MIGlzX2FycmF5ID0gMCwgaXNfdHlwZWRhcnJheSA9IDAsIGlzX2Z1bmN0aW9uID0gMDsKICAgICAgdWludDMyX3QgcG9zLCBsZW4sIGxpbWl0OwogICAgICBWZWN0b3IgcHJvcGVudW1fdGFiOwogICAgICBjb25zdCBjaGFyKiBzID0gMDsKICAgICAgaW50IGNvbXBhY3QgPSBvcHRzLT5jb21wYWN0OwogICAgICBKU09iamVjdCogb2JqID0gSlNfVkFMVUVfR0VUX09CSih2YWx1ZSk7CgogICAgICBpZighb2JqLT5wcm9wIHx8ICFvYmotPnNoYXBlKSB7CiAgICAgICAgZGJ1Zl9wcmludGYoYnVmLCAianNfaW5zcGVjdF9wcmludCBPYmplY3QgcHJvcCA9ICVwLCBzaGFwZSA9ICVwICIsIG9iai0+cHJvcCwgb2JqLT5zaGFwZSk7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CgogICAgICBpZihvcHRzLT5jdXN0b21faW5zcGVjdCkgewogICAgICAgIEpTVmFsdWUgdG1wID0ganNfaW5zcGVjdF9jdXN0b21fY2FsbChjdHgsIHZhbHVlLCBvcHRzLCBkZXB0aCk7CiAgICAgICAgaWYoSlNfSXNTdHJpbmcodG1wKSkgewogICAgICAgICAgY29uc3QgY2hhciogcyA9IEpTX1RvQ1N0cmluZyhjdHgsIHRtcCk7CiAgICAgICAgICBkYnVmX3B1dHN0cihidWYsIHMpOwogICAgICAgICAganNfY3N0cmluZ19mcmVlKGN0eCwgcyk7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CgogICAgICAgIGlmKEpTX0lzRXhjZXB0aW9uKHRtcCkpIHsKICAgICAgICAgIEpTVmFsdWUgZXhjZXB0aW9uID0gSlNfR2V0RXhjZXB0aW9uKGN0eCk7CgogICAgICAgICAgLy8gZGJ1Zl9wcmludGYoYnVmLCAiZXhjZXB0aW9uOiAlc1xuIiwgSlNfVG9DU3RyaW5nKGN0eCwgZXhjZXB0aW9uKSk7CiAgICAgICAgICAvLyByZXR1cm4gMDsKCiAgICAgICAgfSBlbHNlIGlmKCFKU19Jc1VuZGVmaW5lZCh0bXApKSB7CiAgICAgICAgICBpZighSlNfSXNPYmplY3QodG1wKSkKICAgICAgICAgICAgcmV0dXJuIGpzX2luc3BlY3RfcHJpbnQoY3R4LCBidWYsIHRtcCwgb3B0cywgZGVwdGggKyAxKTsKCiAgICAgICAgICB2YWx1ZSA9IHRtcDsKICAgICAgICAgIGNvbXBhY3QrKzsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmKG9wdHMtPmNvbXBhY3QgPCAwKSB7CiAgICAgICAgY29tcGFjdCA9IGRlcHRoID49IC1vcHRzLT5jb21wYWN0OwogICAgICB9IGVsc2UgaWYoSU5TUEVDVF9JTlQzMlRfSU5SQU5HRShvcHRzLT5jb21wYWN0KSAmJiBvcHRzLT5jb21wYWN0ID4gMCkgewogICAgICAgIGludDMyX3QgZGVlcGVzdCA9IDE7CgogICAgICAgIGlmKCFqc19pc19hcnJheWJ1ZmZlcihjdHgsIHZhbHVlKSkKICAgICAgICAgIGRlZXBlc3QgPSBwcm9wZXJ0eV9lbnVtZXJhdGlvbl9kZWVwZXN0KGN0eCwgdmFsdWUpOwogICAgICAgIGNvbnN0IGNoYXIqIHR5cGVzdHIgPSBqc192YWx1ZV90eXBlc3RyKGN0eCwgdmFsdWUpOwogICAgICAgIC8vIHByaW50ZigiJXMgb3B0cy0+Y29tcGFjdCA9ICVkLCBkZWVwZXN0ID0gJWQsIGRlcHRoID0gJWRcbiIsIHR5cGVzdHIgPwogICAgICAgIC8vIHR5cGVzdHIgOgogICAgICAgIC8vICIobnVsbCkiLCBvcHRzLT5jb21wYWN0LCBkZWVwZXN0LCBkZXB0aCk7CgogICAgICAgIGNvbXBhY3QgPSBjb21wYWN0ID4gZGVlcGVzdDsKICAgICAgfQoKICAgICAgaWYoIShpc19mdW5jdGlvbiA9IEpTX0lzRnVuY3Rpb24oY3R4LCB2YWx1ZSkpKSB7CiAgICAgICAgaXNfYXJyYXkgPSBqc19pc19hcnJheShjdHgsIHZhbHVlKTsKICAgICAgICBpc190eXBlZGFycmF5ID0ganNfaXNfdHlwZWRhcnJheSh2YWx1ZSk7CgogICAgICAgIGlmKCFpc19hcnJheSAmJiAhaXNfdHlwZWRhcnJheSkgewogICAgICAgICAgaWYoanNfaXNfYXJyYXlidWZmZXIoY3R4LCB2YWx1ZSkgfHwganNfaXNfc2hhcmVkYXJyYXlidWZmZXIoY3R4LCB2YWx1ZSkpCiAgICAgICAgICAgIHJldHVybiBqc19pbnNwZWN0X2FycmF5YnVmZmVyKGN0eCwgYnVmLCB2YWx1ZSwgb3B0cywgZGVwdGggKyAxKTsKCiAgICAgICAgICBpZihqc19pc19tYXAoY3R4LCB2YWx1ZSkpCiAgICAgICAgICAgIHJldHVybiBqc19pbnNwZWN0X21hcChjdHgsIGJ1ZiwgdmFsdWUsIG9wdHMsIGRlcHRoIC8qKyAxKi8pOwogICAgICAgICAgaWYoanNfaXNfc2V0KGN0eCwgdmFsdWUpKQogICAgICAgICAgICByZXR1cm4ganNfaW5zcGVjdF9zZXQoY3R4LCBidWYsIHZhbHVlLCBvcHRzLCBkZXB0aCArIDEpOwogICAgICAgICAgaWYoanNfaXNfcmVnZXhwKGN0eCwgdmFsdWUpKQogICAgICAgICAgICByZXR1cm4ganNfaW5zcGVjdF9yZWdleHAoY3R4LCBidWYsIHZhbHVlLCBvcHRzLCBkZXB0aCArIDEpOwogICAgICAgICAgLyppZihKU19Jc0luc3RhbmNlT2YoY3R4LCB2YWx1ZSwgcHJveHlfY3RvcikpIHsKICAgICAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCAiW1Byb3h5XSIpOwogICAgICAgICAgICByZXR1cm4gMDsKICAgICAgICAgIH0qLwogICAgICAgIH0KCiAgICAgICAgaWYoanNfb2JqZWN0X3RtcG1hcmtfaXNzZXQodmFsdWUpKSB7CiAgICAgICAgICBKU19UaHJvd1R5cGVFcnJvcihjdHgsICJjaXJjdWxhciByZWZlcmVuY2UiKTsKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CgogICAgICAgIGlmKGpzX2lzX2dlbmVyYXRvcihjdHgsIHZhbHVlKSkgewogICAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCAiT2JqZWN0IFtHZW5lcmF0b3JdIHt9Iik7CiAgICAgICAgICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBzKTsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYoIUpTX0lzQXJyYXkoY3R4LCB2YWx1ZSkgJiYgIWlzX2Z1bmN0aW9uKSB7CiAgICAgICAgaWYocyA9PSAwKQogICAgICAgICAgcyA9IGpzX29iamVjdF90b3N0cmluZyhjdHgsIHZhbHVlKTsKCiAgICAgICAgaWYoIXN0cm5jbXAocywgIltvYmplY3QgIiwgOCkpIHsKICAgICAgICAgIGNvbnN0IGNoYXIqIGUgPSBzdHJjaHIocywgJ10nKTsKICAgICAgICAgIHNpemVfdCBzbGVuID0gZSAtIChzICsgOCk7CgogICAgICAgICAgaWYoc2xlbiAhPSA2IHx8IG1lbWNtcChzICsgOCwgIk9iamVjdCIsIDYpKSB7CiAgICAgICAgICAgIGRidWZfcHV0c3RyKGJ1Ziwgb3B0cy0+Y29sb3JzID8gQ09MT1JfTElHSFRSRUQgOiAiWyIpOwogICAgICAgICAgICAvLyBkYnVmX3B1dHN0cihidWYsIG9wdHMtPmNvbG9ycyA/IENPTE9SX01BUklORSAiWyIgOiAiWyIpOwogICAgICAgICAgICBkYnVmX2FwcGVuZChidWYsIChjb25zdCB1aW50OF90KilzICsgOCwgZSAtIChzICsgOCkpOwogICAgICAgICAgICAvLyBkYnVmX3B1dHN0cihidWYsIG9wdHMtPmNvbG9ycyA/ICJdIiBDT0xPUl9OT05FICIgIiA6ICJdICIpOwogICAgICAgICAgICBkYnVmX3B1dHN0cihidWYsIG9wdHMtPmNvbG9ycyA/IENPTE9SX05PTkUgIiAiIDogIl0gIik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmKHMpCiAgICAgICAganNfY3N0cmluZ19mcmVlKGN0eCwgcyk7CgogICAgICBpZighKGlzX2FycmF5IHx8IGlzX3R5cGVkYXJyYXkpKSB7CiAgICAgICAgdmVjdG9yX2luaXQoJnByb3BlbnVtX3RhYiwgY3R4KTsKICAgICAgICAvLyBwcmludGYoInByb3RvX2NoYWluOiAlaVxuIiwgb3B0cy0+cHJvdG9fY2hhaW4pOwogICAgICAgIGlmKCgxIHx8IG9wdHMtPnByb3RvX2NoYWluCiAgICAgICAgICAgICAgICA/IGpzX29iamVjdF9nZXRwcm9wZXJ0eW5hbWVzX3JlY3Vyc2l2ZQogICAgICAgICAgICAgICAgOiBqc19vYmplY3RfZ2V0cHJvcGVydHluYW1lcykoY3R4LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJnByb3BlbnVtX3RhYiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG9wdHMtPnByb3RvX2NoYWluIDw9IDAgPyBKU19HZXRQcm90b3R5cGUoY3R4LCB2YWx1ZSkgOiAqLyB2YWx1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTX0dQTl9TVFJJTkdfTUFTSyB8IEpTX0dQTl9TWU1CT0xfTUFTSyB8IChvcHRzLT5zaG93X2hpZGRlbiA/IDAgOiBKU19HUE5fRU5VTV9PTkxZKSkpCiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgIH0KCiAgICAgIGlmKGlzX2Z1bmN0aW9uKSB7CiAgICAgICAgSlNWYWx1ZSBuYW1lOwogICAgICAgIGRidWZfcHV0c3RyKGJ1Ziwgb3B0cy0+Y29sb3JzID8gQ09MT1JfTUFSSU5FICJbRnVuY3Rpb24iIDogIltGdW5jdGlvbiIpOwogICAgICAgIG5hbWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIHZhbHVlLCAibmFtZSIpOwogICAgICAgIGlmKCFKU19Jc1VuZGVmaW5lZChuYW1lKSkgewogICAgICAgICAgcyA9IEpTX1RvQ1N0cmluZyhjdHgsIG5hbWUpOwogICAgICAgICAgaWYoKnMpIHsKICAgICAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCAiOiAiKTsKICAgICAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBzKTsKICAgICAgICAgIH0KICAgICAgICAgIGpzX2NzdHJpbmdfZnJlZShjdHgsIHMpOwogICAgICAgIH0KICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBuYW1lKTsKICAgICAgICBkYnVmX3B1dHN0cihidWYsIG9wdHMtPmNvbG9ycyA/ICJdIiBDT0xPUl9OT05FIDogIl0iKTsKICAgICAgICAvKiAgaWYodmVjdG9yX3NpemUoJnByb3BlbnVtX3RhYiwgc2l6ZW9mKEpTUHJvcGVydHlEZXNjcmlwdG9yKSkgJiYgZGVwdGggPj0gMCkKICAgICAgICAgICAgZGJ1Zl9wdXRjKGJ1ZiwgJyAnKTsKICAgICAgICAgIGVsc2UqLwogICAgICAgIGdvdG8gZW5kX29iajsKICAgICAgfQogICAgICBpZihkZXB0aCA8IDApIHsKICAgICAgICBkYnVmX3B1dF9jb2xvcnN0cihidWYsIGlzX2FycmF5ID8gIltBcnJheV0iIDogIltPYmplY3RdIiwgQ09MT1JfTUFSSU5FLCBvcHRzLT5jb2xvcnMpOwogICAgICAgIGdvdG8gZW5kX29iajsKICAgICAgfQoKICAgICAganNfb2JqZWN0X3RtcG1hcmtfc2V0KHZhbHVlKTsKCiAgICAgIGlmKGlzX2FycmF5IHx8IGlzX3R5cGVkYXJyYXkpIHsKICAgICAgICBsZW4gPSBqc19hcnJheV9sZW5ndGgoY3R4LCB2YWx1ZSk7CiAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBjb21wYWN0ICYmIG9wdHMtPmJyZWFrX2xlbmd0aCAhPSBJTlQzMl9NQVggPyAiWyAiIDogIlsiKTsKICAgICAgICBsaW1pdCA9IG1pbl9zaXplKG9wdHMtPm1heF9hcnJheV9sZW5ndGgsIGxlbik7CiAgICAgICAgaWYobGVuICYmICFjb21wYWN0ICYmIG9wdHMtPmJyZWFrX2xlbmd0aCAhPSBJTlQzMl9NQVgpCiAgICAgICAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpICsgMSk7CiAgICAgICAgZm9yKHBvcyA9IDA7IHBvcyA8IGxlbjsgcG9zKyspIHsKICAgICAgICAgIEpTUHJvcGVydHlEZXNjcmlwdG9yIGRlc2M7CiAgICAgICAgICBKU0F0b20gcHJvcDsKICAgICAgICAgIGlmKHBvcyA9PSBsaW1pdCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBpZihwb3MgPiAwKSB7CiAgICAgICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgIiwgIik7CiAgICAgICAgICAgIC8vIGRidWZfcHV0c3RyKGJ1ZiwgY29tcGFjdCA/ICIsICIgOiAiLCIpOwogICAgICAgICAgICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgICAgICAgICAgIGluc3BlY3RfbmV3bGluZShidWYsIElOU1BFQ1RfTEVWRUwob3B0cykgKyAxKTsKICAgICAgICAgIH0KICAgICAgICAgIHByb3AgPSBKU19OZXdBdG9tVUludDMyKGN0eCwgcG9zKTsKICAgICAgICAgIG1lbXNldCgmZGVzYywgMCwgc2l6ZW9mKGRlc2MpKTsKICAgICAgICAgIGRlc2MudmFsdWUgPSBKU19VTkRFRklORUQ7CiAgICAgICAgICBKU19HZXRPd25Qcm9wZXJ0eShjdHgsICZkZXNjLCB2YWx1ZSwgcHJvcCk7CiAgICAgICAgICBKU19GcmVlQXRvbShjdHgsIHByb3ApOwoKICAgICAgICAgIGlmKChkZXNjLmZsYWdzICYgSlNfUFJPUF9HRVRTRVQpICYmIG9wdHMtPmdldHRlcnMpIHsKICAgICAgICAgICAgaW50IGlkeCA9IChKU19Jc1VuZGVmaW5lZChkZXNjLmdldHRlcikgPyAwIDogMSkgfCAoSlNfSXNVbmRlZmluZWQoZGVzYy5zZXR0ZXIpID8gMCA6IDIpOwogICAgICAgICAgICBzdGF0aWMgY29uc3QgY2hhciogY29uc3Qgc3Ryc1s0XSA9IHswLCAiW0dldHRlcl0iLCAiW1NldHRlcl0iLCAiW0dldHRlci9TZXR0ZXJdIn07CiAgICAgICAgICAgIGlmKGlkeCkKICAgICAgICAgICAgICBkYnVmX3B1dF9jb2xvcnN0cihidWYsIHN0cnNbaWR4XSwgQ09MT1JfTUFSSU5FLCBvcHRzLT5jb2xvcnMpOwoKICAgICAgICAgIH0gZWxzZSBpZihKU19IYXNQcm9wZXJ0eShjdHgsIHZhbHVlLCBKU19BVE9NX1RBR19JTlQgfCBwb3MpKSB7CiAgICAgICAgICAgIC8qICBpZihjb21wYWN0IHx8IG9wdHMtPmJyZWFrX2xlbmd0aCA9PSBJTlQzMl9NQVgpCiAgICAgICAgICAgICAgICBkYnVmX3B1dGMoYnVmLCAnICcpOyovCiAgICAgICAgICAgIGpzX2luc3BlY3RfcHJpbnQoY3R4LCBidWYsIGRlc2MudmFsdWUsIG9wdHMsIGRlcHRoIC0gMSk7CiAgICAgICAgICB9CiAgICAgICAgICBqc19wcm9wZXJ0eWRlc2NyaXB0b3JfZnJlZShjdHgsICZkZXNjKTsKICAgICAgICB9CiAgICAgICAgaWYobGVuICYmIGxpbWl0IDwgbGVuKSB7CiAgICAgICAgICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgICAgICAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpICsgMSk7CiAgICAgICAgICBkYnVmX3ByaW50ZihidWYsICIuLi4gJXUgbW9yZSBpdGVtIiwgbGVuIC0gcG9zKTsKICAgICAgICAgIGlmKHBvcyArIDEgPCBsZW4pCiAgICAgICAgICAgIGRidWZfcHV0YyhidWYsICdzJyk7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZighaXNfYXJyYXkgJiYgIWlzX3R5cGVkYXJyYXkpIHsKICAgICAgICBkYnVmX3B1dHN0cihidWYsIChjb21wYWN0ICYmIHZlY3Rvcl9zaXplKCZwcm9wZW51bV90YWIsIHNpemVvZihKU1Byb3BlcnR5RW51bSkpKSA/ICJ7ICIgOiAieyIpOwogICAgICAgIGxlbiA9IDA7CiAgICAgIH0KCiAgICAgIGZvcihwb3MgPSAwOyBwb3MgPCB2ZWN0b3Jfc2l6ZSgmcHJvcGVudW1fdGFiLCBzaXplb2YoSlNQcm9wZXJ0eUVudW0pKTsgcG9zKyspIHsKICAgICAgICBKU1Byb3BlcnR5RGVzY3JpcHRvciBkZXNjOwogICAgICAgIGNvbnN0IGNoYXIqIG5hbWU7CiAgICAgICAgSlNQcm9wZXJ0eUVudW0qIHByb3BlbnVtID0gKEpTUHJvcGVydHlFbnVtKil2ZWN0b3JfYXQoJnByb3BlbnVtX3RhYiwgc2l6ZW9mKEpTUHJvcGVydHlFbnVtKSwgcG9zKTsKICAgICAgICBKU1ZhbHVlIGtleSA9IGpzX2F0b21fdG92YWx1ZShjdHgsIHByb3BlbnVtLT5hdG9tKTsKICAgICAgICBuYW1lID0gSlNfQXRvbVRvQ1N0cmluZyhjdHgsIHByb3BlbnVtLT5hdG9tKTsKICAgICAgICBpZighSlNfSXNTeW1ib2woa2V5KSkgewogICAgICAgICAgaWYoKChpc19hcnJheSB8fCBpc190eXBlZGFycmF5KSAmJiBpc19pbnRlZ2VyKG5hbWUpKSB8fCBpbnNwZWN0X29wdGlvbnNfaGlkZGVuKG9wdHMsIHByb3BlbnVtLT5hdG9tKSkgewogICAgICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBrZXkpOwogICAgICAgICAgICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBuYW1lKTsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmKHBvcyA+IDApCiAgICAgICAgICBkYnVmX3B1dHN0cihidWYsIGNvbXBhY3QgPyAiLCAiIDogIiwiKTsKICAgICAgICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgICAgICAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgSU5TUEVDVF9MRVZFTChvcHRzKSArIDEpOwogICAgICAgIGlmKCFKU19Jc1N5bWJvbChrZXkpICYmIChpc19pZGVudGlmaWVyKG5hbWUpIHx8IGlzX2ludGVnZXIobmFtZSkpKSB7CiAgICAgICAgICBkYnVmX3B1dHN0cihidWYsIG5hbWUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZighSlNfSXNTdHJpbmcoa2V5KSkKICAgICAgICAgICAgZGJ1Zl9wdXRjKGJ1ZiwgJ1snKTsKICAgICAgICAgIGpzX2luc3BlY3RfcHJpbnQoY3R4LCBidWYsIGtleSwgb3B0cywgZGVwdGggLSAxKTsKICAgICAgICAgIGlmKCFKU19Jc1N0cmluZyhrZXkpKQogICAgICAgICAgICBkYnVmX3B1dGMoYnVmLCAnXScpOwogICAgICAgIH0KICAgICAgICBkYnVmX3B1dHN0cihidWYsICI6ICIpOwogICAgICAgIGpzX2NzdHJpbmdfZnJlZShjdHgsIG5hbWUpOwogICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGtleSk7CgogICAgICAgIGlmKGpzX2dldF9wcm9wZXJ0eWRlc2NyaXB0b3IoY3R4LCAmZGVzYywgdmFsdWUsIHByb3BlbnVtLT5hdG9tKSA9PSBUUlVFKSB7CiAgICAgICAgICBpZigoZGVzYy5mbGFncyAmIEpTX1BST1BfR0VUU0VUKSkgewogICAgICAgICAgICBpZighb3B0cy0+Z2V0dGVycykgewogICAgICAgICAgICAgIC8vIEpTVmFsdWUgdiA9IEpTX0dldFByb3BlcnR5KGN0eCwgdmFsdWUsIHByb3BlbnVtLT5hdG9tKTsKICAgICAgICAgICAgICBKU1ZhbHVlIHYgPSBKU19DYWxsKGN0eCwgZGVzYy5nZXR0ZXIsIHZhbHVlLCAwLCAwKTsKICAgICAgICAgICAgICBqc19pbnNwZWN0X3ByaW50KGN0eCwgYnVmLCB2LCBvcHRzLCBkZXB0aCAtIDEpOwogICAgICAgICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHYpOwogICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICBkYnVmX3B1dF9jb2xvcnN0cihidWYsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNfSXNVbmRlZmluZWQoZGVzYy5nZXR0ZXIpICAgPyAiW1NldHRlcl0iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBKU19Jc1VuZGVmaW5lZChkZXNjLnNldHRlcikgPyAiW0dldHRlcl0iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAiW0dldHRlci9TZXR0ZXJdIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT0xPUl9NQVJJTkUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy0+Y29sb3JzKTsKICAgICAgICAgIH0gZWxzZSB7CgogICAgICAgICAgICBpZihKU19Jc09iamVjdChkZXNjLnZhbHVlKSAmJiBqc19vYmplY3RfdG1wbWFya19pc3NldChkZXNjLnZhbHVlKSkKICAgICAgICAgICAgICBkYnVmX3B1dHN0cihidWYsICJceDFiWzA7MzFtW0NpcmN1bGFyIFJlZmVyZW5jZV1ceDFiWzBtIik7CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICBqc19pbnNwZWN0X3ByaW50KGN0eCwgYnVmLCBkZXNjLnZhbHVlLCBvcHRzLCBkZXB0aCAtIDEpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBqc19wcm9wZXJ0eWRlc2NyaXB0b3JfZnJlZShjdHgsICZkZXNjKTsKICAgICAgICBsZW4rKzsKICAgICAgfQogICAgICBqc19vYmplY3RfdG1wbWFya19jbGVhcih2YWx1ZSk7CgogICAgICBpZighY29tcGFjdCAmJiBsZW4gJiYgb3B0cy0+YnJlYWtfbGVuZ3RoICE9IElOVDMyX01BWCkKICAgICAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpKTsKICAgICAgZGJ1Zl9wdXRzdHIoYnVmLAogICAgICAgICAgICAgICAgICAoaXNfYXJyYXkgfHwgaXNfdHlwZWRhcnJheSkgPyAoKGNvbXBhY3QgfHwgb3B0cy0+YnJlYWtfbGVuZ3RoID09IElOVDMyX01BWCkgJiYgbGVuID8gIiBdIiA6ICJdIikgOiAoY29tcGFjdCAmJiBsZW4gPyAiIH0iIDogIn0iKSk7CgogICAgZW5kX29iajoKICAgICAgaWYoIXZlY3Rvcl9lbXB0eSgmcHJvcGVudW1fdGFiKSkKICAgICAgICBqc19wcm9wZXJ0eWVudW1zX2ZyZWUoY3R4LCB2ZWN0b3JfYmVnaW4oJnByb3BlbnVtX3RhYiksIHZlY3Rvcl9zaXplKCZwcm9wZW51bV90YWIsIHNpemVvZihKU1Byb3BlcnR5RW51bSkpKTsKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBKU19UQUdfRlVOQ1RJT05fQllURUNPREU6IHsKICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBvcHRzLT5jb2xvcnMgPyBDT0xPUl9MSUdIVFJFRCAiW2J5dGVjb2RlXSIgQ09MT1JfTk9ORSA6ICJbYnl0ZWNvZGVdIik7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgSlNfVEFHX01PRFVMRTogewogICAgICBkYnVmX3B1dHN0cihidWYsIG9wdHMtPmNvbG9ycyA/IENPTE9SX0xJR0hUTUFSSU5FICJbbW9kdWxlXSIgQ09MT1JfTk9ORSA6ICJbbW9kdWxlXSIpOwogICAgICBicmVhazsKICAgIH0KCiAgICBkZWZhdWx0OiB7CiAgICAgIEpTX1Rocm93VHlwZUVycm9yKGN0eCwgIlVuaGFuZGxlZCB2YWx1ZSB0YWcgaW4ganNfaW5zcGVjdF9wcmludDogJWRcbiIsIHRhZyk7CiAgICAgIHJldHVybiAtMTsKICAgIH0KICB9CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzX2luc3BlY3QoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10pIHsKICBEeW5CdWYgZGJ1ZjsKICBpbnNwZWN0X29wdGlvbnNfdCBvcHRpb25zOwogIGludDMyX3QgbGV2ZWw7CiAgaW50IG9wdGluZCA9IDE7CiAgSlNWYWx1ZSByZXQ7CgogIGpzX2RidWZfaW5pdChjdHgsICZkYnVmKTsKICBpbnNwZWN0X29wdGlvbnNfaW5pdCgmb3B0aW9ucywgY3R4KTsKCiAgaWYoYXJnYyA+IDEgJiYgSlNfSXNOdW1iZXIoYXJndlsxXSkpCiAgICBvcHRpbmQrKzsKCiAgaWYob3B0aW5kIDwgYXJnYykKICAgIGluc3BlY3Rfb3B0aW9uc19nZXQoJm9wdGlvbnMsIGN0eCwgYXJndltvcHRpbmRdKTsKCiAgaWYob3B0aW5kID4gMSkgewogICAgZG91YmxlIGQ7CiAgICBKU19Ub0Zsb2F0NjQoY3R4LCAmZCwgYXJndlsxXSk7CiAgICBsZXZlbCA9IGlzaW5mKGQpID8gSU5UMzJfTUFYIDogZDsKICB9IGVsc2UgewogICAgbGV2ZWwgPSAwOwogIH0KCiAgLypwcmludGYoImpzX2luc3BlY3QgYnJlYWtfbGVuZ3RoOiAlZCwgbWF4X2FycmF5X2xlbmd0aDogJWQsCiAgICAgbWF4X3N0cmluZ19sZW5ndGg6ICVkXG4iLCBvcHRpb25zLmJyZWFrX2xlbmd0aCwgb3B0aW9ucy5tYXhfYXJyYXlfbGVuZ3RoLAogICAgIG9wdGlvbnMubWF4X3N0cmluZ19sZW5ndGgpOyovCgogIGpzX2luc3BlY3RfcHJpbnQoY3R4LCAmZGJ1ZiwgYXJndlswXSwgJm9wdGlvbnMsIG9wdGlvbnMuZGVwdGggLSBsZXZlbCk7CgogIHJldCA9IEpTX05ld1N0cmluZ0xlbihjdHgsIChjb25zdCBjaGFyKilkYnVmLmJ1ZiwgZGJ1Zi5zaXplKTsKCiAgZGJ1Zl9mcmVlKCZkYnVmKTsKCiAgaW5zcGVjdF9vcHRpb25zX2ZyZWUoJm9wdGlvbnMsIGN0eCk7CgogIHJldHVybiByZXQ7Cn0KCmNoYXIqCmpzX2luc3BlY3RfdG9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIER5bkJ1ZiBkYnVmOwogIGluc3BlY3Rfb3B0aW9uc190IG9wdGlvbnM7CiAganNfZGJ1Zl9pbml0KGN0eCwgJmRidWYpOwogIGluc3BlY3Rfb3B0aW9uc19pbml0KCZvcHRpb25zLCBjdHgpOwoKICBvcHRpb25zLmNvbG9ycyA9IEZBTFNFOwogIG9wdGlvbnMuY29tcGFjdCA9IDA7CiAgb3B0aW9ucy5nZXR0ZXJzID0gVFJVRTsKICBqc19pbnNwZWN0X3ByaW50KGN0eCwgJmRidWYsIHZhbHVlLCAmb3B0aW9ucywgb3B0aW9ucy5kZXB0aCk7CgogIGluc3BlY3Rfb3B0aW9uc19mcmVlKCZvcHRpb25zLCBjdHgpOwoKICBkYnVmXzAoJmRidWYpOwogIHJldHVybiAoY2hhciopZGJ1Zi5idWY7Cn0KCi8qY29uc3QgY2hhcioKanNfaW5zcGVjdF90b3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgSlNWYWx1ZSBvdXRwdXQ7CiAgaW5zcGVjdF9vcHRpb25zX3Qgb3B0czsKICBKU1ZhbHVlQ29uc3QgYXJnc1tdID0ge3ZhbHVlLCBKU19VTkRFRklORUR9OwogIGluc3BlY3Rfb3B0aW9uc19pbml0KCZvcHRzLCBjdHgpOwogIG9wdHMuY29sb3JzID0gRkFMU0U7CiAgYXJnc1sxXSA9IGluc3BlY3Rfb3B0aW9uc19vYmplY3QoJm9wdHMsIGN0eCk7CiAgaW5zcGVjdF9vcHRpb25zX2ZyZWUoJm9wdHMsIGN0eCk7CgogIG91dHB1dCA9IGpzX2luc3BlY3QoY3R4LCBKU19VTkRFRklORUQsIDIsIGFyZ3MpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGFyZ3NbMV0pOwogIHJldHVybiBKU19Ub0NTdHJpbmcoY3R4LCBvdXRwdXQpOwp9Ki8KCkpTVmFsdWUganNfZGVidWdnZXJfYnVpbGRfYmFja3RyYWNlKEpTQ29udGV4dCogY3R4LCBjb25zdCB1aW50OF90KiBjdXJfcGMpOwoKSlNWYWx1ZQpqc19pbnNwZWN0X3N0YWNrdHJhY2VfdmFsdWUoSlNDb250ZXh0KiBjdHgpIHsKICBKU1J1bnRpbWUqIHJ0ID0gSlNfR2V0UnVudGltZShjdHgpOwogIHN0cnVjdCBKU1N0YWNrRnJhbWUqIGZyYW1lOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwogIGlmKChmcmFtZSA9IHJ0LT5jdXJyZW50X3N0YWNrX2ZyYW1lKSkgewojaWZkZWYgQ09ORklHX0RFQlVHR0VSCiAgICByZXQgPSBqc19kZWJ1Z2dlcl9idWlsZF9iYWNrdHJhY2UoY3R4LCBmcmFtZS0+Y3VyX3BjKTsKI2VuZGlmCiAgfQogIHJldHVybiByZXQ7Cn0KCmNvbnN0IGNoYXIqCmpzX2luc3BlY3Rfc3RhY2t0cmFjZShKU0NvbnRleHQqIGN0eCkgewogIEpTVmFsdWUgc3RhY2sgPSBqc19pbnNwZWN0X3N0YWNrdHJhY2VfdmFsdWUoY3R4KTsKICByZXR1cm4ganNfaW5zcGVjdF90b3N0cmluZyhjdHgsIHN0YWNrKTsKfQoKc3RhdGljIGNvbnN0IEpTQ0Z1bmN0aW9uTGlzdEVudHJ5IGpzX2luc3BlY3RfZnVuY3NbXSA9IHsKICAgIEpTX0NGVU5DX0RFRigiaW5zcGVjdCIsIDEsIGpzX2luc3BlY3QpLAp9OwoKc3RhdGljIGludApqc19pbnNwZWN0X2luaXQoSlNDb250ZXh0KiBjdHgsIEpTTW9kdWxlRGVmKiBtKSB7CiAgSlNWYWx1ZSBpbnNwZWN0LCBpbnNwZWN0X3N5bWJvbCwgc3ltYm9sX2N0b3I7CiAgc3Rkb3V0X2lzYXR0eSA9IGlzYXR0eShTVERPVVRfRklMRU5PKTsKICBzdGRlcnJfaXNhdHR5ID0gaXNhdHR5KFNUREVSUl9GSUxFTk8pOwoKICBpbnNwZWN0ID0gSlNfTmV3Q0Z1bmN0aW9uKGN0eCwganNfaW5zcGVjdCwgImluc3BlY3QiLCAyKTsKCiAgaW5zcGVjdF9zeW1ib2wgPSBqc19zeW1ib2xfZm9yKGN0eCwgInF1aWNranMuaW5zcGVjdC5jdXN0b20iKTsKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIGluc3BlY3QsICJzeW1ib2wiLCBKU19EdXBWYWx1ZShjdHgsIGluc3BlY3Rfc3ltYm9sKSk7CiAgc3ltYm9sX2N0b3IgPSBqc19zeW1ib2xfY3RvcihjdHgpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgc3ltYm9sX2N0b3IsICJpbnNwZWN0IiwgSlNfRHVwVmFsdWUoY3R4LCBpbnNwZWN0X3N5bWJvbCkpOwoKICBKU19GcmVlVmFsdWUoY3R4LCBzeW1ib2xfY3Rvcik7CiAgSlNfRnJlZVZhbHVlKGN0eCwgaW5zcGVjdF9zeW1ib2wpOwoKICBpbnNwZWN0X2N1c3RvbV9hdG9tID0ganNfaW5zcGVjdF9jdXN0b21fYXRvbShjdHgsICJxdWlja2pzLmluc3BlY3QuY3VzdG9tIik7CiAgaW5zcGVjdF9jdXN0b21fYXRvbV9ub2RlID0ganNfaW5zcGVjdF9jdXN0b21fYXRvbShjdHgsICJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbSIpOwoKICBpZihtKSB7CiAgICBKU19TZXRNb2R1bGVFeHBvcnRMaXN0KGN0eCwgbSwganNfaW5zcGVjdF9mdW5jcywgY291bnRvZihqc19pbnNwZWN0X2Z1bmNzKSk7CiAgICBKU19TZXRNb2R1bGVFeHBvcnQoY3R4LCBtLCAiZGVmYXVsdCIsIGluc3BlY3QpOwogIH0KCiAgcmV0dXJuIDA7Cn0KCiNpZiBkZWZpbmVkKEpTX1NIQVJFRF9MSUJSQVJZKSAmJiBkZWZpbmVkKEpTX0lOU1BFQ1RfTU9EVUxFKQojZGVmaW5lIEpTX0lOSVRfTU9EVUxFIGpzX2luaXRfbW9kdWxlCiNlbHNlCiNkZWZpbmUgSlNfSU5JVF9NT0RVTEUganNfaW5pdF9tb2R1bGVfaW5zcGVjdAojZW5kaWYKClZJU0lCTEUgSlNNb2R1bGVEZWYqCkpTX0lOSVRfTU9EVUxFKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBtb2R1bGVfbmFtZSkgewogIEpTTW9kdWxlRGVmKiBtOwogIG0gPSBKU19OZXdDTW9kdWxlKGN0eCwgbW9kdWxlX25hbWUsIGpzX2luc3BlY3RfaW5pdCk7CiAgaWYoIW0pCiAgICByZXR1cm4gTlVMTDsKICBKU19BZGRNb2R1bGVFeHBvcnRMaXN0KGN0eCwgbSwganNfaW5zcGVjdF9mdW5jcywgY291bnRvZihqc19pbnNwZWN0X2Z1bmNzKSk7CiAgSlNfQWRkTW9kdWxlRXhwb3J0KGN0eCwgbSwgImRlZmF1bHQiKTsKICByZXR1cm4gbTsKfQoAAAAAAAAAAOqGAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAvTAAAAAAAAC9MAAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "quickjs-misc.c",
			"settings":
			{
				"buffer_size": 39830,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					894,
					4,
					"left_delete",
					null,
					"BAAAAIAdAAAAAAAAgB0AAAAAAAABAAAAZX8dAAAAAAAAfx0AAAAAAAABAAAAdX4dAAAAAAAAfh0AAAAAAAABAAAAcn0dAAAAAAAAfR0AAAAAAAABAAAAdA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAACBHQAAAAAAAIEdAAAAAAAAAAAAAAAA8L8"
				],
				[
					895,
					1,
					"insert",
					{
						"characters": "TRUE"
					},
					"BAAAAH0dAAAAAAAAfh0AAAAAAAAAAAAAfh0AAAAAAAB/HQAAAAAAAAAAAAB/HQAAAAAAAIAdAAAAAAAAAAAAAIAdAAAAAAAAgR0AAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAB9HQAAAAAAAH0dAAAAAAAAAAAAAAAA8L8"
				],
				[
					903,
					1,
					"insert",
					{
						"characters": "FALSE"
					},
					"BgAAABweAAAAAAAAHR4AAAAAAAAAAAAAHR4AAAAAAAAdHgAAAAAAAAEAAAAwHR4AAAAAAAAeHgAAAAAAAAAAAAAeHgAAAAAAAB8eAAAAAAAAAAAAAB8eAAAAAAAAIB4AAAAAAAAAAAAAIB4AAAAAAAAhHgAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAcHgAAAAAAAB0eAAAAAAAAAAAAAAAA8L8"
				],
				[
					108,
					1,
					"insert",
					{
						"characters": "2"
					},
					"AgAAAHYcAAAAAAAAdxwAAAAAAAAAAAAAdxwAAAAAAAB3HAAAAAAAAAEAAAAx",
					"AQAAAAAAAAABAAAAdhwAAAAAAAB3HAAAAAAAAAAAAAAAAPC/"
				],
				[
					200,
					1,
					"cut",
					null,
					"AQAAAL8dAAAAAAAAvx0AAAAAAAAMAAAAbWFzay5iYXNlW2pd",
					"AQAAAAAAAAABAAAAvx0AAAAAAADLHQAAAAAAAAAAAAAAAPC/"
				],
				[
					201,
					1,
					"paste",
					null,
					"AQAAAL8dAAAAAAAAyx0AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAvx0AAAAAAAC/HQAAAAAAAAAAAAAAAPC/"
				],
				[
					211,
					1,
					"right_delete",
					null,
					"AQAAANYdAAAAAAAA1h0AAAAAAAABAAAAKA",
					"AQAAAAAAAAABAAAA1h0AAAAAAADWHQAAAAAAAAAAAAAAAPC/"
				],
				[
					216,
					1,
					"insert",
					{
						"characters": "^"
					},
					"AgAAAPAdAAAAAAAA8R0AAAAAAAAAAAAA8R0AAAAAAADxHQAAAAAAAAIAAAAhPQ",
					"AQAAAAAAAAABAAAA8B0AAAAAAADyHQAAAAAAAAAAAAAAAPC/"
				],
				[
					219,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAAYeAAAAAAAACB4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAABh4AAAAAAAAGHgAAAAAAAAAAAAAAAPC/"
				],
				[
					221,
					1,
					"left_delete",
					null,
					"AQAAAAceAAAAAAAABx4AAAAAAAABAAAAKQ",
					"AQAAAAAAAAABAAAACB4AAAAAAAAIHgAAAAAAAAAAAAAAAPC/"
				],
				[
					222,
					1,
					"run_macro_file",
					{
						"file": "res://Packages/Default/Delete Left Right.sublime-macro"
					},
					"AgAAAAYeAAAAAAAABh4AAAAAAAABAAAAKAYeAAAAAAAABh4AAAAAAAABAAAAKQ",
					"AQAAAAAAAAABAAAABx4AAAAAAAAHHgAAAAAAAAAAAAAAAPC/"
				],
				[
					223,
					1,
					"insert",
					{
						"characters": ")"
					},
					"AQAAAAYeAAAAAAAABx4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAABh4AAAAAAAAGHgAAAAAAAAAAAAAAAPC/"
				],
				[
					224,
					1,
					"insert",
					{
						"characters": " %&"
					},
					"AwAAAAceAAAAAAAACB4AAAAAAAAAAAAACB4AAAAAAAAJHgAAAAAAAAAAAAAJHgAAAAAAAAoeAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAABx4AAAAAAAAHHgAAAAAAAAAAAAAAAPC/"
				],
				[
					225,
					2,
					"left_delete",
					null,
					"AgAAAAkeAAAAAAAACR4AAAAAAAABAAAAJggeAAAAAAAACB4AAAAAAAABAAAAJQ",
					"AQAAAAAAAAABAAAACh4AAAAAAAAKHgAAAAAAAAAAAAAAAPC/"
				],
				[
					226,
					1,
					"insert",
					{
						"characters": "&"
					},
					"AQAAAAgeAAAAAAAACR4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAACB4AAAAAAAAIHgAAAAAAAAAAAAAAAPC/"
				],
				[
					227,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAAkeAAAAAAAACh4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAACR4AAAAAAAAJHgAAAAAAAAAAAAAAAPC/"
				],
				[
					228,
					1,
					"paste",
					null,
					"AQAAAAoeAAAAAAAAFh4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAACh4AAAAAAAAKHgAAAAAAAAAAAAAAAPC/"
				],
				[
					229,
					1,
					"insert",
					{
						"characters": ")"
					},
					"AQAAABYeAAAAAAAAFx4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAFh4AAAAAAAAWHgAAAAAAAAAAAAAAAPC/"
				],
				[
					232,
					1,
					"insert",
					{
						"characters": "/("
					},
					"AgAAANYdAAAAAAAA1x0AAAAAAAAAAAAA1x0AAAAAAADYHQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA1h0AAAAAAADWHQAAAAAAAAAAAAAAAPC/"
				],
				[
					233,
					2,
					"left_delete",
					null,
					"AgAAANcdAAAAAAAA1x0AAAAAAAABAAAAKNYdAAAAAAAA1h0AAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAA2B0AAAAAAADYHQAAAAAAAAAAAAAAAPC/"
				],
				[
					234,
					1,
					"insert",
					{
						"characters": "/("
					},
					"AgAAANYdAAAAAAAA1x0AAAAAAAAAAAAA1x0AAAAAAADYHQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA1h0AAAAAAADWHQAAAAAAAAAAAAAAAPC/"
				],
				[
					235,
					2,
					"left_delete",
					null,
					"AgAAANcdAAAAAAAA1x0AAAAAAAABAAAAKNYdAAAAAAAA1h0AAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAA2B0AAAAAAADYHQAAAAAAAAAAAAAAAPC/"
				],
				[
					236,
					1,
					"insert",
					{
						"characters": "/("
					},
					"AgAAANYdAAAAAAAA1x0AAAAAAAAAAAAA1x0AAAAAAADYHQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA1h0AAAAAAADWHQAAAAAAAAAAAAAAAPC/"
				],
				[
					237,
					2,
					"left_delete",
					null,
					"AgAAANcdAAAAAAAA1x0AAAAAAAABAAAAKNYdAAAAAAAA1h0AAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAA2B0AAAAAAADYHQAAAAAAAAAAAAAAAPC/"
				],
				[
					238,
					1,
					"insert",
					{
						"characters": "("
					},
					"AQAAANYdAAAAAAAA1x0AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA1h0AAAAAAADWHQAAAAAAAAAAAAAAAPC/"
				],
				[
					263,
					1,
					"right_delete",
					null,
					"AQAAANYdAAAAAAAA1h0AAAAAAAABAAAAKA",
					"AQAAAAAAAAABAAAA1h0AAAAAAADWHQAAAAAAAAAAAAAAAPC/"
				],
				[
					268,
					1,
					"right_delete",
					null,
					"AQAAAOodAAAAAAAA6h0AAAAAAAAFAAAAICYgbSk",
					"AQAAAAAAAAABAAAA6h0AAAAAAADvHQAAAAAAAAAAAAAAAPC/"
				],
				[
					273,
					1,
					"left_delete",
					null,
					"AQAAAO0dAAAAAAAA7R0AAAAAAAABAAAAKA",
					"AQAAAAAAAAABAAAA7h0AAAAAAADuHQAAAAAAAAAAAAAAAPC/"
				],
				[
					276,
					3,
					"left_delete",
					null,
					"AwAAAP4dAAAAAAAA/h0AAAAAAAABAAAAbf0dAAAAAAAA/R0AAAAAAAABAAAAIPwdAAAAAAAA/B0AAAAAAAABAAAAJg",
					"AQAAAAAAAAABAAAA/x0AAAAAAAD/HQAAAAAAAAAAAAAAAPC/"
				],
				[
					277,
					1,
					"right_delete",
					null,
					"AQAAAPwdAAAAAAAA/B0AAAAAAAABAAAAKQ",
					"AQAAAAAAAAABAAAA/B0AAAAAAAD8HQAAAAAAAAAAAAAAAPC/"
				],
				[
					278,
					1,
					"left_delete",
					null,
					"AQAAAPsdAAAAAAAA+x0AAAAAAAABAAAAIA",
					"AQAAAAAAAAABAAAA/B0AAAAAAAD8HQAAAAAAAAAAAAAAAPC/"
				],
				[
					281,
					1,
					"insert",
					{
						"characters": "/"
					},
					"AQAAANYdAAAAAAAA1x0AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA1h0AAAAAAADWHQAAAAAAAAAAAAAAAPC/"
				],
				[
					282,
					1,
					"left_delete",
					null,
					"AQAAANYdAAAAAAAA1h0AAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAA1x0AAAAAAADXHQAAAAAAAAAAAAAAAPC/"
				],
				[
					283,
					1,
					"insert",
					{
						"characters": "("
					},
					"AQAAANYdAAAAAAAA1x0AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA1h0AAAAAAADWHQAAAAAAAAAAAAAAAPC/"
				],
				[
					295,
					1,
					"insert",
					{
						"characters": "mot"
					},
					"BAAAAHAdAAAAAAAAcR0AAAAAAAAAAAAAcR0AAAAAAABxHQAAAAAAAAQAAABCT09McR0AAAAAAAByHQAAAAAAAAAAAAByHQAAAAAAAHMdAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcB0AAAAAAAB0HQAAAAAAAAAAAAAAAPC/"
				],
				[
					296,
					3,
					"left_delete",
					null,
					"AwAAAHIdAAAAAAAAch0AAAAAAAABAAAAdHEdAAAAAAAAcR0AAAAAAAABAAAAb3AdAAAAAAAAcB0AAAAAAAABAAAAbQ",
					"AQAAAAAAAAABAAAAcx0AAAAAAABzHQAAAAAAAAAAAAAAAPC/"
				],
				[
					297,
					1,
					"insert",
					{
						"characters": "ion"
					},
					"AwAAAHAdAAAAAAAAcR0AAAAAAAAAAAAAcR0AAAAAAAByHQAAAAAAAAAAAAByHQAAAAAAAHMdAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcB0AAAAAAABwHQAAAAAAAAAAAAAAAPC/"
				],
				[
					298,
					2,
					"left_delete",
					null,
					"AgAAAHIdAAAAAAAAch0AAAAAAAABAAAAbnEdAAAAAAAAcR0AAAAAAAABAAAAbw",
					"AQAAAAAAAAABAAAAcx0AAAAAAABzHQAAAAAAAAAAAAAAAPC/"
				],
				[
					299,
					1,
					"insert",
					{
						"characters": "nt"
					},
					"AgAAAHEdAAAAAAAAch0AAAAAAAAAAAAAch0AAAAAAABzHQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcR0AAAAAAABxHQAAAAAAAAAAAAAAAPC/"
				],
				[
					302,
					4,
					"left_delete",
					null,
					"BAAAAH8dAAAAAAAAfx0AAAAAAAABAAAARX4dAAAAAAAAfh0AAAAAAAABAAAAVX0dAAAAAAAAfR0AAAAAAAABAAAAUnwdAAAAAAAAfB0AAAAAAAABAAAAVA",
					"AQAAAAAAAAABAAAAgB0AAAAAAACAHQAAAAAAAAAAAAAAAPC/"
				],
				[
					303,
					1,
					"insert",
					{
						"characters": "1"
					},
					"AQAAAHwdAAAAAAAAfR0AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAfB0AAAAAAAB8HQAAAAAAAAAAAAAAAPC/"
				],
				[
					310,
					1,
					"insert_snippet",
					{
						"contents": "'${0:$SELECTION}'"
					},
					"AgAAABweAAAAAAAAHB4AAAAAAAAFAAAARkFMU0UcHgAAAAAAACMeAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAHB4AAAAAAAAhHgAAAAAAAAAAAAAAAPC/"
				],
				[
					311,
					1,
					"insert",
					{
						"characters": "0"
					},
					"AgAAAB0eAAAAAAAAHh4AAAAAAAAAAAAAHh4AAAAAAAAeHgAAAAAAAAUAAABGQUxTRQ",
					"AQAAAAAAAAABAAAAHR4AAAAAAAAiHgAAAAAAAAAAAAAAAPC/"
				],
				[
					312,
					1,
					"left_delete",
					null,
					"AQAAAB0eAAAAAAAAHR4AAAAAAAABAAAAMA",
					"AQAAAAAAAAABAAAAHh4AAAAAAAAeHgAAAAAAAAAAAAAAAPC/"
				],
				[
					313,
					1,
					"run_macro_file",
					{
						"file": "res://Packages/Default/Delete Left Right.sublime-macro"
					},
					"AgAAABweAAAAAAAAHB4AAAAAAAABAAAAJxweAAAAAAAAHB4AAAAAAAABAAAAJw",
					"AQAAAAAAAAABAAAAHR4AAAAAAAAdHgAAAAAAAAAAAAAAAPC/"
				],
				[
					314,
					1,
					"insert",
					{
						"characters": "0"
					},
					"AQAAABweAAAAAAAAHR4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAHB4AAAAAAAAcHgAAAAAAAAAAAAAAAPC/"
				],
				[
					341,
					1,
					"insert",
					{
						"characters": " "
					},
					"AgAAAKkdAAAAAAAAqh0AAAAAAAAAAAAAqh0AAAAAAACqHQAAAAAAACAAAAAgICAgICB1aW50OF90IG0gPSBtYXNrLmJhc2Vbal07Cg",
					"AQAAAAAAAAABAAAAqR0AAAAAAADJHQAAAAAAAAAAAAAAAPC/"
				],
				[
					356,
					1,
					"insert",
					{
						"characters": "size_t"
					},
					"BwAAACUaAAAAAAAAJhoAAAAAAAAAAAAAJhoAAAAAAAAmGgAAAAAAAAcAAABpbnQ2NF90JhoAAAAAAAAnGgAAAAAAAAAAAAAnGgAAAAAAACgaAAAAAAAAAAAAACgaAAAAAAAAKRoAAAAAAAAAAAAAKRoAAAAAAAAqGgAAAAAAAAAAAAAqGgAAAAAAACsaAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAJRoAAAAAAAAsGgAAAAAAAAAAAAAAAPC/"
				],
				[
					364,
					1,
					"paste",
					null,
					"AgAAAEodAAAAAAAAUB0AAAAAAAAAAAAAUB0AAAAAAABQHQAAAAAAAAcAAABpbnQ2NF90",
					"AQAAAAAAAAABAAAASh0AAAAAAABRHQAAAAAAAAAAAAAAAPC/"
				],
				[
					370,
					1,
					"paste",
					null,
					"AgAAAIUdAAAAAAAAix0AAAAAAAAAAAAAix0AAAAAAACLHQAAAAAAAAcAAABpbnQ2NF90",
					"AQAAAAAAAAABAAAAhR0AAAAAAACMHQAAAAAAAAAAAAAAAPC/"
				],
				[
					377,
					1,
					"insert",
					{
						"characters": "/"
					},
					"AQAAAEYeAAAAAAAARx4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAARh4AAAAAAABGHgAAAAAAAAAAAAAAAPC/"
				],
				[
					378,
					1,
					"left_delete",
					null,
					"AQAAAEYeAAAAAAAARh4AAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAARx4AAAAAAABHHgAAAAAAAAAAAAAAAPC/"
				],
				[
					379,
					1,
					"insert",
					{
						"characters": "(iot"
					},
					"BAAAAEYeAAAAAAAARx4AAAAAAAAAAAAARx4AAAAAAABIHgAAAAAAAAAAAABIHgAAAAAAAEkeAAAAAAAAAAAAAEkeAAAAAAAASh4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAARh4AAAAAAABGHgAAAAAAAAAAAAAAAPC/"
				],
				[
					380,
					2,
					"left_delete",
					null,
					"AgAAAEkeAAAAAAAASR4AAAAAAAABAAAAdEgeAAAAAAAASB4AAAAAAAABAAAAbw",
					"AQAAAAAAAAABAAAASh4AAAAAAABKHgAAAAAAAAAAAAAAAPC/"
				],
				[
					381,
					1,
					"insert",
					{
						"characters": "nt64_t"
					},
					"BgAAAEgeAAAAAAAASR4AAAAAAAAAAAAASR4AAAAAAABKHgAAAAAAAAAAAABKHgAAAAAAAEseAAAAAAAAAAAAAEseAAAAAAAATB4AAAAAAAAAAAAATB4AAAAAAABNHgAAAAAAAAAAAABNHgAAAAAAAE4eAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAASB4AAAAAAABIHgAAAAAAAAAAAAAAAPC/"
				],
				[
					382,
					7,
					"left_delete",
					null,
					"BwAAAE0eAAAAAAAATR4AAAAAAAABAAAAdEweAAAAAAAATB4AAAAAAAABAAAAX0seAAAAAAAASx4AAAAAAAABAAAANEoeAAAAAAAASh4AAAAAAAABAAAANkkeAAAAAAAASR4AAAAAAAABAAAAdEgeAAAAAAAASB4AAAAAAAABAAAAbkceAAAAAAAARx4AAAAAAAABAAAAaQ",
					"AQAAAAAAAAABAAAATh4AAAAAAABOHgAAAAAAAAAAAAAAAPC/"
				],
				[
					383,
					1,
					"insert",
					{
						"characters": "size-t)"
					},
					"BwAAAEceAAAAAAAASB4AAAAAAAAAAAAASB4AAAAAAABJHgAAAAAAAAAAAABJHgAAAAAAAEoeAAAAAAAAAAAAAEoeAAAAAAAASx4AAAAAAAAAAAAASx4AAAAAAABMHgAAAAAAAAAAAABMHgAAAAAAAE0eAAAAAAAAAAAAAE0eAAAAAAAATh4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAARx4AAAAAAABHHgAAAAAAAAAAAAAAAPC/"
				],
				[
					384,
					3,
					"left_delete",
					null,
					"AwAAAE0eAAAAAAAATR4AAAAAAAABAAAAKUweAAAAAAAATB4AAAAAAAABAAAAdEseAAAAAAAASx4AAAAAAAABAAAALQ",
					"AQAAAAAAAAABAAAATh4AAAAAAABOHgAAAAAAAAAAAAAAAPC/"
				],
				[
					385,
					1,
					"insert",
					{
						"characters": "_t)"
					},
					"AwAAAEseAAAAAAAATB4AAAAAAAAAAAAATB4AAAAAAABNHgAAAAAAAAAAAABNHgAAAAAAAE4eAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAASx4AAAAAAABLHgAAAAAAAAAAAAAAAPC/"
				],
				[
					398,
					1,
					"insert",
					{
						"characters": "int64_t"
					},
					"CAAAAEceAAAAAAAASB4AAAAAAAAAAAAASB4AAAAAAABIHgAAAAAAAAYAAABzaXplX3RIHgAAAAAAAEkeAAAAAAAAAAAAAEkeAAAAAAAASh4AAAAAAAAAAAAASh4AAAAAAABLHgAAAAAAAAAAAABLHgAAAAAAAEweAAAAAAAAAAAAAEweAAAAAAAATR4AAAAAAAAAAAAATR4AAAAAAABOHgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAARx4AAAAAAABNHgAAAAAAAAAAAAAAAPC/"
				],
				[
					413,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAACceAAAAAAAAKB4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAJx4AAAAAAAAnHgAAAAAAAAAAAAAAAPC/"
				],
				[
					414,
					1,
					"wrap_block",
					{
						"begin": "{",
						"end": "}"
					},
					"AgAAACgeAAAAAAAAKR4AAAAAAAAAAAAAVR4AAAAAAABbHgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAKB4AAAAAAAAoHgAAAAAAAAAAAAAAAPC/"
				],
				[
					427,
					1,
					"paste",
					null,
					"AQAAAC8eAAAAAAAAyx4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAALx4AAAAAAAAvHgAAAAAAAAAAAAAAAPC/"
				],
				[
					428,
					1,
					"insert",
					{
						"characters": "\n\n"
					},
					"BQAAAMseAAAAAAAAzB4AAAAAAAAAAAAAzB4AAAAAAADQHgAAAAAAAAAAAADQHgAAAAAAANEeAAAAAAAAAAAAANEeAAAAAAAA1R4AAAAAAAAAAAAAzB4AAAAAAADMHgAAAAAAAAQAAAAgICAg",
					"AQAAAAAAAAABAAAAyx4AAAAAAADLHgAAAAAAAAAAAAAAAPC/"
				],
				[
					440,
					1,
					"insert",
					{
						"characters": "\nprintf"
					},
					"CQAAAFceAAAAAAAAWB4AAAAAAAAAAAAAWB4AAAAAAABhHgAAAAAAAAAAAABhHgAAAAAAAGIeAAAAAAAAAAAAAGIeAAAAAAAAYx4AAAAAAAAAAAAAYx4AAAAAAABkHgAAAAAAAAAAAABkHgAAAAAAAGUeAAAAAAAAAAAAAGUeAAAAAAAAZh4AAAAAAAAAAAAAZh4AAAAAAABnHgAAAAAAAAAAAABnHgAAAAAAAGgeAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAVx4AAAAAAABXHgAAAAAAAAAAAAAAIHxA"
				],
				[
					441,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAGgeAAAAAAAAah4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAaB4AAAAAAABoHgAAAAAAAAAAAAAAAPC/"
				],
				[
					442,
					1,
					"insert_snippet",
					{
						"contents": "\"$0\""
					},
					"AQAAAGkeAAAAAAAAax4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAaR4AAAAAAABpHgAAAAAAAAAAAAAAAPC/"
				],
				[
					443,
					1,
					"insert",
					{
						"characters": "XOR"
					},
					"AwAAAGoeAAAAAAAAax4AAAAAAAAAAAAAax4AAAAAAABsHgAAAAAAAAAAAABsHgAAAAAAAG0eAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAah4AAAAAAABqHgAAAAAAAAAAAAAAAPC/"
				],
				[
					444,
					1,
					"insert",
					{
						"characters": " %02"
					},
					"BAAAAG0eAAAAAAAAbh4AAAAAAAAAAAAAbh4AAAAAAABvHgAAAAAAAAAAAABvHgAAAAAAAHAeAAAAAAAAAAAAAHAeAAAAAAAAcR4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbR4AAAAAAABtHgAAAAAAAAAAAAAAAPC/"
				],
				[
					445,
					1,
					"insert",
					{
						"characters": "x\\n"
					},
					"AwAAAHEeAAAAAAAAch4AAAAAAAAAAAAAch4AAAAAAABzHgAAAAAAAAAAAABzHgAAAAAAAHQeAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcR4AAAAAAABxHgAAAAAAAAAAAAAAAPC/"
				],
				[
					447,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAAHUeAAAAAAAAdh4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAdR4AAAAAAAB1HgAAAAAAAAAAAAAAAPC/"
				],
				[
					448,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAHYeAAAAAAAAdx4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAdh4AAAAAAAB2HgAAAAAAAAAAAAAAAPC/"
				],
				[
					451,
					1,
					"insert",
					{
						"characters": "="
					},
					"AQAAAGoeAAAAAAAAax4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAah4AAAAAAABqHgAAAAAAAAAAAAAAAPC/"
				],
				[
					452,
					1,
					"left_delete",
					null,
					"AQAAAGoeAAAAAAAAah4AAAAAAAABAAAAPQ",
					"AQAAAAAAAAABAAAAax4AAAAAAABrHgAAAAAAAAAAAAAAAPC/"
				],
				[
					453,
					1,
					"insert",
					{
						"characters": "%02x"
					},
					"BAAAAGoeAAAAAAAAax4AAAAAAAAAAAAAax4AAAAAAABsHgAAAAAAAAAAAABsHgAAAAAAAG0eAAAAAAAAAAAAAG0eAAAAAAAAbh4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAah4AAAAAAABqHgAAAAAAAAAAAAAAAPC/"
				],
				[
					454,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAG4eAAAAAAAAbx4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbh4AAAAAAABuHgAAAAAAAAAAAAAAAPC/"
				],
				[
					456,
					1,
					"insert",
					{
						"characters": " ?="
					},
					"AwAAAHceAAAAAAAAeB4AAAAAAAAAAAAAeB4AAAAAAAB5HgAAAAAAAAAAAAB5HgAAAAAAAHoeAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAdx4AAAAAAAB3HgAAAAAAAAAAAAAAAPC/"
				],
				[
					457,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAHoeAAAAAAAAex4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAeh4AAAAAAAB6HgAAAAAAAAAAAAAAAPC/"
				],
				[
					458,
					3,
					"left_delete",
					null,
					"AwAAAHoeAAAAAAAAeh4AAAAAAAABAAAAIHkeAAAAAAAAeR4AAAAAAAABAAAAPXgeAAAAAAAAeB4AAAAAAAABAAAAPw",
					"AQAAAAAAAAABAAAAex4AAAAAAAB7HgAAAAAAAAAAAAAAAPC/"
				],
				[
					459,
					1,
					"insert",
					{
						"characters": "="
					},
					"AQAAAHgeAAAAAAAAeR4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAeB4AAAAAAAB4HgAAAAAAAAAAAAAAAPC/"
				],
				[
					460,
					1,
					"insert",
					{
						"characters": " %02x"
					},
					"BQAAAHkeAAAAAAAAeh4AAAAAAAAAAAAAeh4AAAAAAAB7HgAAAAAAAAAAAAB7HgAAAAAAAHweAAAAAAAAAAAAAHweAAAAAAAAfR4AAAAAAAAAAAAAfR4AAAAAAAB+HgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAeR4AAAAAAAB5HgAAAAAAAAAAAAAAAPC/"
				],
				[
					465,
					1,
					"cut",
					null,
					"AQAAAJAeAAAAAAAAkB4AAAAAAAAVAAAAaGF5c3RhY2suYmFzZVtpICsgal0g",
					"AQAAAAAAAAABAAAAkB4AAAAAAAClHgAAAAAAAAAAAAAAAPC/"
				],
				[
					466,
					1,
					"paste",
					null,
					"AQAAAJAeAAAAAAAApR4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAkB4AAAAAAACQHgAAAAAAAAAAAAAAAPC/"
				],
				[
					471,
					1,
					"paste",
					null,
					"AQAAAIMeAAAAAAAAmB4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAgx4AAAAAAACDHgAAAAAAAAAAAAAAAPC/"
				],
				[
					472,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAJgeAAAAAAAAmR4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmB4AAAAAAACYHgAAAAAAAAAAAAAAAPC/"
				],
				[
					473,
					2,
					"left_delete",
					null,
					"AgAAAJgeAAAAAAAAmB4AAAAAAAABAAAAIJceAAAAAAAAlx4AAAAAAAABAAAAIA",
					"AQAAAAAAAAABAAAAmR4AAAAAAACZHgAAAAAAAAAAAAAAAPC/"
				],
				[
					474,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAAJceAAAAAAAAmB4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAlx4AAAAAAACXHgAAAAAAAAAAAAAAAPC/"
				],
				[
					475,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAJgeAAAAAAAAmR4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmB4AAAAAAACYHgAAAAAAAAAAAAAAAPC/"
				],
				[
					479,
					3,
					"left_delete",
					null,
					"AwAAAJkeAAAAAAAAmR4AAAAAAAAiAAAAKQogICAgICAgaWYoKGhheXN0YWNrLmJhc2VbaSArIGpdIJgeAAAAAAAAmB4AAAAAAAABAAAAIJceAAAAAAAAlx4AAAAAAAABAAAALA",
					"AQAAAAAAAAABAAAAmR4AAAAAAAC7HgAAAAAAAAAAAAAAAPC/"
				],
				[
					480,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAJceAAAAAAAAmB4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAlx4AAAAAAACXHgAAAAAAAAAAAAAAAPC/"
				],
				[
					482,
					2,
					"left_delete",
					null,
					"AgAAAJgeAAAAAAAAmB4AAAAAAAABAAAAXpceAAAAAAAAlx4AAAAAAAABAAAAIA",
					"AQAAAAAAAAABAAAAmR4AAAAAAACZHgAAAAAAAAAAAAAAAPC/"
				],
				[
					483,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAAJceAAAAAAAAmB4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAlx4AAAAAAACXHgAAAAAAAAAAAAAAAPC/"
				],
				[
					485,
					2,
					"left_delete",
					null,
					"AgAAAKgeAAAAAAAAqB4AAAAAAAABAAAAIKceAAAAAAAApx4AAAAAAAABAAAAKQ",
					"AQAAAAAAAAABAAAAqR4AAAAAAACpHgAAAAAAAAAAAAAAAPC/"
				],
				[
					486,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAAKceAAAAAAAAqB4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAApx4AAAAAAACnHgAAAAAAAAAAAAAAAPC/"
				],
				[
					487,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAKgeAAAAAAAAqR4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAqB4AAAAAAACoHgAAAAAAAAAAAAAAAPC/"
				],
				[
					500,
					1,
					"paste",
					null,
					"AQAAAKkeAAAAAAAAzh4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAqR4AAAAAAACpHgAAAAAAAAAAAAAAAPC/"
				],
				[
					501,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAM4eAAAAAAAAzx4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAzh4AAAAAAADOHgAAAAAAAAAAAAAAAPC/"
				],
				[
					502,
					1,
					"left_delete",
					null,
					"AQAAAM4eAAAAAAAAzh4AAAAAAAABAAAAIA",
					"AQAAAAAAAAABAAAAzx4AAAAAAADPHgAAAAAAAAAAAAAAAPC/"
				],
				[
					503,
					1,
					"insert",
					{
						"characters": ");"
					},
					"AgAAAM4eAAAAAAAAzx4AAAAAAAAAAAAAzx4AAAAAAADQHgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAzh4AAAAAAADOHgAAAAAAAAAAAAAAAPC/"
				],
				[
					505,
					1,
					"left_delete",
					null,
					"AQAAANAeAAAAAAAA0B4AAAAAAAARAAAAJiBtYXNrLmJhc2Vbal0pIHs",
					"AQAAAAAAAAABAAAA0B4AAAAAAADhHgAAAAAAAP///////+9/"
				],
				[
					506,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAANAeAAAAAAAA0R4AAAAAAAAAAAAA0R4AAAAAAADbHgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA0B4AAAAAAADQHgAAAAAAAAAAAAAAAPC/"
				],
				[
					508,
					1,
					"cut",
					null,
					"AQAAAGIeAAAAAAAAYh4AAAAAAAB5AAAAcHJpbnRmKCIlMDJ4IFhPUiAlMDJ4ID0gJTAyeFxuIiwgaGF5c3RhY2suYmFzZVtpICsgal0sIG5lZWRsZS5iYXNlW2ldLCBoYXlzdGFjay5iYXNlW2kgKyBqXSBeIG5lZWRsZS5iYXNlW2ldKTsKICAgICAgICAgIA",
					"AQAAAAAAAAABAAAA2x4AAAAAAABiHgAAAAAAAAAAAAAAAFlA"
				],
				[
					509,
					2,
					"paste",
					null,
					"AgAAAGIeAAAAAAAA2x4AAAAAAAAAAAAA2x4AAAAAAABUHwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAYh4AAAAAAABiHgAAAAAAAAAAAAAAAPC/"
				],
				[
					512,
					1,
					"insert",
					{
						"characters": " "
					},
					"AwAAAPweAAAAAAAA/R4AAAAAAAAAAAAA/R4AAAAAAAD9HgAAAAAAACYAAABoYXlzdGFjay5iYXNlW2kgKyBqXSwgbmVlZGxlLmJhc2VbaV0sICUfAAAAAAAAJR8AAAAAAAAKAAAAICAgICAgICAgIA",
					"AQAAAAAAAAABAAAA/B4AAAAAAAAiHwAAAAAAAAAAAAAAAPC/"
				],
				[
					516,
					1,
					"insert",
					{
						"characters": "AMD"
					},
					"BAAAAOgeAAAAAAAA6R4AAAAAAAAAAAAA6R4AAAAAAADpHgAAAAAAAAMAAABYT1LpHgAAAAAAAOoeAAAAAAAAAAAAAOoeAAAAAAAA6x4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA6B4AAAAAAADrHgAAAAAAAAAAAAAAAPC/"
				],
				[
					517,
					2,
					"left_delete",
					null,
					"AgAAAOoeAAAAAAAA6h4AAAAAAAABAAAAROkeAAAAAAAA6R4AAAAAAAABAAAATQ",
					"AQAAAAAAAAABAAAA6x4AAAAAAADrHgAAAAAAAAAAAAAAAPC/"
				],
				[
					518,
					1,
					"insert",
					{
						"characters": "ND"
					},
					"AgAAAOkeAAAAAAAA6h4AAAAAAAAAAAAA6h4AAAAAAADrHgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA6R4AAAAAAADpHgAAAAAAAAAAAAAAAPC/"
				],
				[
					528,
					1,
					"cut",
					null,
					"AQAAAKkeAAAAAAAAqR4AAAAAAAAlAAAAaGF5c3RhY2suYmFzZVtpICsgal0gXiBuZWVkbGUuYmFzZVtpXQ",
					"AQAAAAAAAAABAAAAqR4AAAAAAADOHgAAAAAAAAAAAAAAAPC/"
				],
				[
					529,
					1,
					"insert",
					{
						"characters": "xorval"
					},
					"BgAAAKkeAAAAAAAAqh4AAAAAAAAAAAAAqh4AAAAAAACrHgAAAAAAAAAAAACrHgAAAAAAAKweAAAAAAAAAAAAAKweAAAAAAAArR4AAAAAAAAAAAAArR4AAAAAAACuHgAAAAAAAAAAAACuHgAAAAAAAK8eAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAqR4AAAAAAACpHgAAAAAAAAAAAAAAAPC/"
				],
				[
					531,
					1,
					"insert",
					{
						"characters": "\nuint8_t"
					},
					"CgAAAFceAAAAAAAAWB4AAAAAAAAAAAAAWB4AAAAAAABhHgAAAAAAAAAAAABhHgAAAAAAAGIeAAAAAAAAAAAAAGIeAAAAAAAAYx4AAAAAAAAAAAAAYx4AAAAAAABkHgAAAAAAAAAAAABkHgAAAAAAAGUeAAAAAAAAAAAAAGUeAAAAAAAAZh4AAAAAAAAAAAAAZh4AAAAAAABnHgAAAAAAAAAAAABnHgAAAAAAAGgeAAAAAAAAAAAAAGgeAAAAAAAAaR4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAVx4AAAAAAABXHgAAAAAAAAAAAAAAMItA"
				],
				[
					532,
					1,
					"insert",
					{
						"characters": " xorval"
					},
					"BwAAAGkeAAAAAAAAah4AAAAAAAAAAAAAah4AAAAAAABrHgAAAAAAAAAAAABrHgAAAAAAAGweAAAAAAAAAAAAAGweAAAAAAAAbR4AAAAAAAAAAAAAbR4AAAAAAABuHgAAAAAAAAAAAABuHgAAAAAAAG8eAAAAAAAAAAAAAG8eAAAAAAAAcB4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAaR4AAAAAAABpHgAAAAAAAAAAAAAAAPC/"
				],
				[
					533,
					1,
					"insert",
					{
						"characters": " ="
					},
					"AgAAAHAeAAAAAAAAcR4AAAAAAAAAAAAAcR4AAAAAAAByHgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcB4AAAAAAABwHgAAAAAAAAAAAAAAAPC/"
				],
				[
					534,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAHIeAAAAAAAAcx4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAch4AAAAAAAByHgAAAAAAAAAAAAAAAPC/"
				],
				[
					535,
					1,
					"paste",
					null,
					"AQAAAHMeAAAAAAAAmB4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcx4AAAAAAABzHgAAAAAAAAAAAAAAAPC/"
				],
				[
					544,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAAJgeAAAAAAAAmR4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmB4AAAAAAACYHgAAAAAAAAAAAAAAAPC/"
				],
				[
					547,
					1,
					"insert",
					{
						"characters": "xorval"
					},
					"BgAAACAfAAAAAAAAIR8AAAAAAAAAAAAAIR8AAAAAAAAiHwAAAAAAAAAAAAAiHwAAAAAAACMfAAAAAAAAAAAAACMfAAAAAAAAJB8AAAAAAAAAAAAAJB8AAAAAAAAlHwAAAAAAAAAAAAAlHwAAAAAAACYfAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAIB8AAAAAAAAgHwAAAAAAAAAAAAAAAPC/"
				],
				[
					548,
					1,
					"insert",
					{
						"characters": "  "
					},
					"AgAAACYfAAAAAAAAJx8AAAAAAAAAAAAAJx8AAAAAAAAoHwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAJh8AAAAAAAAmHwAAAAAAAAAAAAAAAPC/"
				],
				[
					549,
					2,
					"left_delete",
					null,
					"AgAAACcfAAAAAAAAJx8AAAAAAAABAAAAICYfAAAAAAAAJh8AAAAAAAABAAAAIA",
					"AQAAAAAAAAABAAAAKB8AAAAAAAAoHwAAAAAAAAAAAAAAAPC/"
				],
				[
					550,
					1,
					"insert",
					{
						"characters": "."
					},
					"AQAAACYfAAAAAAAAJx8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAJh8AAAAAAAAmHwAAAAAAAAAAAAAAAPC/"
				],
				[
					551,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAACcfAAAAAAAAKB8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAJx8AAAAAAAAnHwAAAAAAAAAAAAAAAPC/"
				],
				[
					552,
					2,
					"left_delete",
					null,
					"AgAAACcfAAAAAAAAJx8AAAAAAAABAAAAICYfAAAAAAAAJh8AAAAAAAABAAAALg",
					"AQAAAAAAAAABAAAAKB8AAAAAAAAoHwAAAAAAAAAAAAAAAPC/"
				],
				[
					553,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAACYfAAAAAAAAJx8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAJh8AAAAAAAAmHwAAAAAAAAAAAAAAAPC/"
				],
				[
					554,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAACcfAAAAAAAAKB8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAJx8AAAAAAAAnHwAAAAAAAAAAAAAAAPC/"
				],
				[
					562,
					1,
					"paste",
					null,
					"AQAAACcfAAAAAAAAMx8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAJx8AAAAAAAAnHwAAAAAAAAAAAAAAAPC/"
				],
				[
					563,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAADMfAAAAAAAANB8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAMx8AAAAAAAAzHwAAAAAAAAAAAAAAAPC/"
				],
				[
					564,
					1,
					"insert",
					{
						"characters": " xorval"
					},
					"BwAAADQfAAAAAAAANR8AAAAAAAAAAAAANR8AAAAAAAA2HwAAAAAAAAAAAAA2HwAAAAAAADcfAAAAAAAAAAAAADcfAAAAAAAAOB8AAAAAAAAAAAAAOB8AAAAAAAA5HwAAAAAAAAAAAAA5HwAAAAAAADofAAAAAAAAAAAAADofAAAAAAAAOx8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAANB8AAAAAAAA0HwAAAAAAAAAAAAAAAPC/"
				],
				[
					565,
					1,
					"insert",
					{
						"characters": " &"
					},
					"AgAAADsfAAAAAAAAPB8AAAAAAAAAAAAAPB8AAAAAAAA9HwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAOx8AAAAAAAA7HwAAAAAAAAAAAAAAAPC/"
				],
				[
					566,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAD0fAAAAAAAAPh8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAPR8AAAAAAAA9HwAAAAAAAAAAAAAAAPC/"
				],
				[
					567,
					1,
					"paste",
					null,
					"AQAAAD4fAAAAAAAASh8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAPh8AAAAAAAA+HwAAAAAAAAAAAAAAAPC/"
				],
				[
					568,
					1,
					"insert",
					{
						"characters": ");"
					},
					"AgAAAEofAAAAAAAASx8AAAAAAAAAAAAASx8AAAAAAABMHwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAASh8AAAAAAABKHwAAAAAAAAAAAAAAAPC/"
				],
				[
					571,
					1,
					"left_delete",
					null,
					"AQAAAEwfAAAAAAAATB8AAAAAAAAoAAAAIGhheXN0YWNrLmJhc2VbaSArIGpdIF4gbmVlZGxlLmJhc2VbaV0pOw",
					"AQAAAAAAAAABAAAATB8AAAAAAAB0HwAAAAAAAP///////+9/"
				],
				[
					585,
					1,
					"cut",
					null,
					"AQAAAJoeAAAAAAAAmh4AAAAAAABaAAAAICAgICAgICAgIHByaW50ZigiJTAyeCBYT1IgJTAyeCA9ICUwMnhcbiIsIGhheXN0YWNrLmJhc2VbaSArIGpdLCBuZWVkbGUuYmFzZVtpXSwgeG9ydmFsKTsK",
					"AQAAAAAAAAABAAAAmh4AAAAAAAD0HgAAAAAAAAAAAAAAAPC/"
				],
				[
					586,
					2,
					"paste",
					null,
					"AgAAAJoeAAAAAAAA9B4AAAAAAAAAAAAA9B4AAAAAAABOHwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmh4AAAAAAACaHgAAAAAAAAAAAAAAAPC/"
				],
				[
					611,
					1,
					"insert",
					{
						"characters": "@(%"
					},
					"AwAAAKweAAAAAAAArR4AAAAAAAAAAAAArR4AAAAAAACuHgAAAAAAAAAAAACuHgAAAAAAAK8eAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAArB4AAAAAAACsHgAAAAAAAAAAAAAAAPC/"
				],
				[
					612,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAK8eAAAAAAAAsB4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAArx4AAAAAAACvHgAAAAAAAAAAAAAAAPC/"
				],
				[
					613,
					1,
					"left_delete",
					null,
					"AQAAAK8eAAAAAAAArx4AAAAAAAABAAAAIA",
					"AQAAAAAAAAABAAAAsB4AAAAAAACwHgAAAAAAAAAAAAAAAPC/"
				],
				[
					614,
					1,
					"insert",
					{
						"characters": "zu"
					},
					"AgAAAK8eAAAAAAAAsB4AAAAAAAAAAAAAsB4AAAAAAACxHgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAArx4AAAAAAACvHgAAAAAAAAAAAAAAAPC/"
				],
				[
					615,
					1,
					"insert",
					{
						"characters": " +"
					},
					"AgAAALEeAAAAAAAAsh4AAAAAAAAAAAAAsh4AAAAAAACzHgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAsR4AAAAAAACxHgAAAAAAAAAAAAAAAPC/"
				],
				[
					616,
					1,
					"insert",
					{
						"characters": " %zu"
					},
					"BAAAALMeAAAAAAAAtB4AAAAAAAAAAAAAtB4AAAAAAAC1HgAAAAAAAAAAAAC1HgAAAAAAALYeAAAAAAAAAAAAALYeAAAAAAAAtx4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAsx4AAAAAAACzHgAAAAAAAAAAAAAAAPC/"
				],
				[
					617,
					1,
					"insert",
					{
						"characters": ")\\\\"
					},
					"AwAAALceAAAAAAAAuB4AAAAAAAAAAAAAuB4AAAAAAAC5HgAAAAAAAAAAAAC5HgAAAAAAALoeAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAtx4AAAAAAAC3HgAAAAAAAAAAAAAAAPC/"
				],
				[
					618,
					1,
					"left_delete",
					null,
					"AQAAALkeAAAAAAAAuR4AAAAAAAABAAAAXA",
					"AQAAAAAAAAABAAAAuh4AAAAAAAC6HgAAAAAAAAAAAAAAAPC/"
				],
				[
					619,
					1,
					"insert",
					{
						"characters": "n\","
					},
					"AwAAALkeAAAAAAAAuh4AAAAAAAAAAAAAuh4AAAAAAAC7HgAAAAAAAAAAAAC7HgAAAAAAALweAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAuR4AAAAAAAC5HgAAAAAAAAAAAAAAAPC/"
				],
				[
					620,
					1,
					"insert",
					{
						"characters": "  "
					},
					"AgAAALweAAAAAAAAvR4AAAAAAAAAAAAAvR4AAAAAAAC+HgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAvB4AAAAAAAC8HgAAAAAAAAAAAAAAAPC/"
				],
				[
					621,
					1,
					"insert",
					{
						"characters": "i"
					},
					"AQAAAL4eAAAAAAAAvx4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAvh4AAAAAAAC+HgAAAAAAAAAAAAAAAPC/"
				],
				[
					622,
					1,
					"insert",
					{
						"characters": "m"
					},
					"AQAAAL8eAAAAAAAAwB4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAvx4AAAAAAAC/HgAAAAAAAAAAAAAAAPC/"
				],
				[
					623,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAMAeAAAAAAAAwR4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAwB4AAAAAAADAHgAAAAAAAAAAAAAAAPC/"
				],
				[
					624,
					2,
					"left_delete",
					null,
					"AgAAAMAeAAAAAAAAwB4AAAAAAAABAAAAIL8eAAAAAAAAvx4AAAAAAAABAAAAbQ",
					"AQAAAAAAAAABAAAAwR4AAAAAAADBHgAAAAAAAAAAAAAAAPC/"
				],
				[
					625,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAAL8eAAAAAAAAwB4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAvx4AAAAAAAC/HgAAAAAAAAAAAAAAAPC/"
				],
				[
					626,
					1,
					"insert",
					{
						"characters": " j);"
					},
					"BAAAAMAeAAAAAAAAwR4AAAAAAAAAAAAAwR4AAAAAAADCHgAAAAAAAAAAAADCHgAAAAAAAMMeAAAAAAAAAAAAAMMeAAAAAAAAxB4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAwB4AAAAAAADAHgAAAAAAAAAAAAAAAPC/"
				],
				[
					628,
					1,
					"left_delete",
					null,
					"AQAAAMQeAAAAAAAAxB4AAAAAAABHAAAAJTAyeCBYT1IgJTAyeCA9ICUwMnhcbiIsIGhheXN0YWNrLmJhc2VbaSArIGpdLCBuZWVkbGUuYmFzZVtpXSwgeG9ydmFsKTs",
					"AQAAAAAAAAABAAAAxB4AAAAAAAALHwAAAAAAAAAAAAAAQHpA"
				],
				[
					632,
					1,
					"insert",
					{
						"characters": "}"
					},
					"AQAAAHgfAAAAAAAAeR8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAeB8AAAAAAAB4HwAAAAAAAAAAAAAAQHpA"
				],
				[
					636,
					1,
					"left_delete",
					null,
					"AQAAAHsfAAAAAAAAex8AAAAAAAATAAAAICAgICAgIGZvdW5kID0gMDsKIA",
					"AQAAAAAAAAABAAAAex8AAAAAAACOHwAAAAAAAAAAAAAAACRA"
				],
				[
					638,
					1,
					"left_delete",
					null,
					"AQAAAHsfAAAAAAAAex8AAAAAAAAcAAAAICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9Cg",
					"AQAAAAAAAAABAAAAex8AAAAAAACXHwAAAAAAAAAAAAAAACRA"
				],
				[
					640,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAACZmwAAI2luY2x1ZGUgPHF1aWNranMtbGliYy5oPgojaW5jbHVkZSAicXVpY2tqcy1taXNjLmgiCiNpbmNsdWRlICJxdWlja2pzLWludGVybmFsLmgiCiNpbmNsdWRlICJxdWlja2pzLWxvY2F0aW9uLmgiCiNpbmNsdWRlICJxdWlja2pzLXN0cmluZ2RlY29kZXIuaCIKI2luY2x1ZGUgInV0aWxzLmgiCiNpbmNsdWRlICJwYXRoLmgiCiNpbmNsdWRlICJiYXNlNjQuaCIKI2luY2x1ZGUgPHRpbWUuaD4KI2luY2x1ZGUgPHN5cy91dHNuYW1lLmg+CiNpbmNsdWRlIDxlcnJuby5oPgojaW5jbHVkZSAiYnVmZmVyLXV0aWxzLmgiCgplbnVtIHsKICBGVU5DX0dFVEVYRUNVVEFCTEUgPSAwLAogIEZVTkNfR0VUQ1dELAogIEZVTkNfR0VUUk9PVCwKICBGVU5DX0dFVEZELAogIEZVTkNfR0VUQ09NTUFORExJTkUsCiAgRlVOQ19HRVRQUk9DTUFQUywKICBGVU5DX0dFVFBST0NNT1VOVFMsCiAgRlVOQ19HRVRQUk9DU1RBVCwKICBGVU5DX0dFVFBJRCwKICBGVU5DX0dFVFBQSUQsCiAgRlVOQ19HRVRTSUQsCiAgRlVOQ19HRVRVSUQsCiAgRlVOQ19HRVRHSUQsCiAgRlVOQ19HRVRFVUlELAogIEZVTkNfR0VURUdJRCwKICBGVU5DX1NFVFVJRCwKICBGVU5DX1NFVEdJRCwKICBGVU5DX1NFVEVVSUQsCiAgRlVOQ19TRVRFR0lECn07Cgp0eXBlZGVmIHN0cnVjdCBwY2dfc3RhdGVfc2V0c2VxXzY0IHsKICB1aW50NjRfdCBzdGF0ZSwgaW5jOwp9IHBjZzMyX3JhbmRvbV90OwoKc3RhdGljIHBjZzMyX3JhbmRvbV90IHBjZzMyX2dsb2JhbCA9IHsweDg1M2M0OWU2NzQ4ZmVhOWJVTEwsIDB4ZGEzZTM5Y2I5NGI5NWJkYlVMTH07CgpzdGF0aWMgaW5saW5lIHVpbnQzMl90CnBjZzMyX3JhbmRvbV9yKHBjZzMyX3JhbmRvbV90KiBybmcpIHsKICB1aW50NjRfdCBvbGRzdGF0ZSA9IHJuZy0+c3RhdGU7CiAgcm5nLT5zdGF0ZSA9IG9sZHN0YXRlICogNjM2NDEzNjIyMzg0Njc5MzAwNVVMTCArIHJuZy0+aW5jOwogIHVpbnQzMl90IHhvcnNoaWZ0ZWQgPSAodWludDMyX3QpKCgob2xkc3RhdGUgPj4gMTh1KSBeIG9sZHN0YXRlKSA+PiAyN3UpOwogIHVpbnQzMl90IHJvdCA9IG9sZHN0YXRlID4+IDU5dTsKICByZXR1cm4gKHhvcnNoaWZ0ZWQgPj4gcm90KSB8ICh4b3JzaGlmdGVkIDw8ICgoLXJvdCkgJiAzMSkpOwp9CgpzdGF0aWMgdWludDMyX3QKcGNnMzJfcmFuZG9tKHZvaWQpIHsKICByZXR1cm4gcGNnMzJfcmFuZG9tX3IoJnBjZzMyX2dsb2JhbCk7Cn0KCnN0YXRpYyB2b2lkCnBjZzMyX2luaXRfc3RhdGUodWludDMyX3Qgc3RhdGUpIHsKICBwY2czMl9nbG9iYWwuc3RhdGUgPSB+KCgodWludDY0X3Qpc3RhdGUpIDw8IDMyKSB8IHN0YXRlOwp9CgpzdGF0aWMgdWludDMyX3QKcGNnMzJfcmFuZG9tX2JvdW5kZWRfZGl2aXNpb25sZXNzKHVpbnQzMl90IHJhbmdlKSB7CiAgdWludDY0X3QgcmFuZG9tMzJiaXQsIG11bHRpcmVzdWx0OwogIHVpbnQzMl90IGxlZnRvdmVyOwogIHVpbnQzMl90IHRocmVzaG9sZDsKICByYW5kb20zMmJpdCA9IHBjZzMyX3JhbmRvbSgpOwogIG11bHRpcmVzdWx0ID0gcmFuZG9tMzJiaXQgKiByYW5nZTsKICBsZWZ0b3ZlciA9ICh1aW50MzJfdCltdWx0aXJlc3VsdDsKICBpZihsZWZ0b3ZlciA8IHJhbmdlKSB7CiAgICB0aHJlc2hvbGQgPSAtcmFuZ2UgJSByYW5nZTsKICAgIHdoaWxlKGxlZnRvdmVyIDwgdGhyZXNob2xkKSB7CiAgICAgIHJhbmRvbTMyYml0ID0gcGNnMzJfcmFuZG9tKCk7CiAgICAgIG11bHRpcmVzdWx0ID0gcmFuZG9tMzJiaXQgKiByYW5nZTsKICAgICAgbGVmdG92ZXIgPSAodWludDMyX3QpbXVsdGlyZXN1bHQ7CiAgICB9CiAgfQogIHJldHVybiBtdWx0aXJlc3VsdCA+PiAzMjsgLy8gWzAsIHJhbmdlKQp9CgpzdGF0aWMgdm9pZApqc19ieXRlY29kZV9mcmVlX2Z1bmMoSlNSdW50aW1lKiBydCwgdm9pZCogb3BhcXVlLCB2b2lkKiBwdHIpIHsKICBqc19mcmVlX3J0KHJ0LCBwdHIpOwp9CgpzdGF0aWMgdm9pZApqc19zdHJpbmdfZnJlZV9mdW5jKEpTUnVudGltZSogcnQsIHZvaWQqIG9wYXF1ZSwgdm9pZCogcHRyKSB7CiAgSlNWYWx1ZSB2YWx1ZSA9IGpzX2NzdHJpbmdfdmFsdWUob3BhcXVlKTsKCiAgSlNfRnJlZVZhbHVlUlQocnQsIHZhbHVlKTsKfQoKc3RhdGljIHZvaWQKanNfYXJyYXlidWZmZXJfZnJlZV9mdW5jKEpTUnVudGltZSogcnQsIHZvaWQqIG9wYXF1ZSwgdm9pZCogcHRyKSB7CiAgSlNWYWx1ZSB2YWx1ZSA9IEpTX01LUFRSKEpTX1RBR19PQkpFQ1QsIHB0cik7CgogIEpTX0ZyZWVWYWx1ZVJUKHJ0LCB2YWx1ZSk7Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzX21pc2NfdG9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10pIHsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKICBKU1ZhbHVlIGFycmF5YnVmZmVyX2N0b3IgPSBqc19nbG9iYWxfZ2V0KGN0eCwgIkFycmF5QnVmZmVyIik7CgogIGlmKGpzX3ZhbHVlX2lzY2xhc3MoY3R4LCBhcmd2WzBdLCBKU19DTEFTU19BUlJBWV9CVUZGRVIpIHx8IGpzX2lzX2FycmF5YnVmZmVyKGN0eCwgYXJndlswXSkgfHwgSlNfSXNJbnN0YW5jZU9mKGN0eCwgYXJndlswXSwgYXJyYXlidWZmZXJfY3RvcikpIHsKICAgIHVpbnQ4X3QqIGRhdGE7CiAgICBzaXplX3QgbGVuOwoKICAgIGlmKChkYXRhID0gSlNfR2V0QXJyYXlCdWZmZXIoY3R4LCAmbGVuLCBhcmd2WzBdKSkpIHsKICAgICAgT2Zmc2V0TGVuZ3RoIG9sOwoKICAgICAgb2wgPSBqc19vZmZzZXRfbGVuZ3RoKGN0eCwgbGVuLCBhcmdjIC0gMSwgYXJndiArIDEpOwoKICAgICAgcmV0ID0gSlNfTmV3U3RyaW5nTGVuKGN0eCwgKGNvbnN0IGNoYXIqKWRhdGEgKyBvbC5vZmZzZXQsIG9sLmxlbmd0aCk7CiAgICB9CiAgfQoKICBKU19GcmVlVmFsdWUoY3R4LCBhcnJheWJ1ZmZlcl9jdG9yKTsKCiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNfbWlzY190b3BvaW50ZXIoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10pIHsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKICB2b2lkKiBwdHIgPSAwOwogIGNoYXIgYnVmWzEyOF07CgogIGlmKGpzX3ZhbHVlX2lzY2xhc3MoY3R4LCBhcmd2WzBdLCBKU19DTEFTU19BUlJBWV9CVUZGRVIpIHx8IGpzX2lzX2FycmF5YnVmZmVyKGN0eCwgYXJndlswXSkpIHsKICAgIHNpemVfdCBsZW47CiAgICBwdHIgPSBKU19HZXRBcnJheUJ1ZmZlcihjdHgsICZsZW4sIGFyZ3ZbMF0pOwogIH0gZWxzZSBpZihKU19Jc1N0cmluZyhhcmd2WzBdKSkgewogICAgcHRyID0ganNfY3N0cmluZ19wdHIoYXJndlswXSk7CiAgfQoKICBpZihwdHIpIHsKICAgIHNucHJpbnRmKGJ1Ziwgc2l6ZW9mKGJ1ZiksICIlcCIsIHB0cik7CiAgICByZXQgPSBKU19OZXdTdHJpbmcoY3R4LCBidWYpOwogIH0gZWxzZSB7CiAgICByZXQgPSBKU19OVUxMOwogIH0KCiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNfbWlzY190b2FycmF5YnVmZmVyKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgSlNWYWx1ZSByZXQgPSBKU19VTkRFRklORUQ7CiAgTWVtb3J5QmxvY2sgYjsKICBPZmZzZXRMZW5ndGggbyA9IGpzX29mZnNldF9sZW5ndGgoY3R4LCBJTlQ2NF9NQVgsIGFyZ2MgLSAxLCBhcmd2ICsgMSk7CiAgSlNGcmVlQXJyYXlCdWZmZXJEYXRhRnVuYyogZjsKICB2b2lkKiBvcGFxdWU7CgogIC8qICBpZihKU19Jc1N0cmluZyhhcmd2WzBdKSkgewogICAgICBKU1ZhbHVlQ29uc3QgdmFsdWUgPSBhcmd2WzBdOyAvLyBKU19EdXBWYWx1ZShjdHgsIGFyZ3ZbMF0pOwogICAgICBiLmJhc2UgPSBKU19Ub0NTdHJpbmdMZW4oY3R4LCAmYi5zaXplLCB2YWx1ZSk7CiAgICAgIGYgPSAmanNfc3RyaW5nX2ZyZWVfZnVuYzsKICAgICAgb3BhcXVlID0gYi5iYXNlOwogICAgICByZXQgPQogICAgICAgICAgSlNfTmV3QXJyYXlCdWZmZXIoY3R4LCBiLmJhc2UgKyBvLm9mZnNldCwgTUlOX05VTShiLnNpemUsIG8ubGVuZ3RoKSwKICAgIGpzX3N0cmluZ19mcmVlX2Z1bmMsICh2b2lkKiliLmJhc2UsIEZBTFNFKTsgfSBlbHNlKi8KICB7CiAgICBJbnB1dEJ1ZmZlciBpbnB1dCA9IGpzX2lucHV0X2NoYXJzKGN0eCwgYXJndlswXSk7CiAgICBiID0gaW5wdXRfYnVmZmVyX2Jsb2NrKCZpbnB1dCk7CiAgICAvLyAgICBiID0gYmxvY2tfcmFuZ2UoJmIsICZpbnB1dC5yYW5nZSk7CiAgICBiID0gYmxvY2tfcmFuZ2UoJmIsICZvKTsKICAgIHJldCA9IGpzX2FycmF5YnVmZmVyX2Zyb212YWx1ZShjdHgsIGIuYmFzZSwgYi5zaXplLCBhcmd2WzBdKTsKICB9CgogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzX21pc2NfZHVwYXJyYXlidWZmZXIoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10pIHsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKICBKU1ZhbHVlIGFycmF5YnVmZmVyX2N0b3IgPSBqc19nbG9iYWxfZ2V0KGN0eCwgIkFycmF5QnVmZmVyIik7CgogIGlmKEpTX0lzSW5zdGFuY2VPZihjdHgsIGFyZ3ZbMF0sIGFycmF5YnVmZmVyX2N0b3IpKSB7CiAgICBKU1ZhbHVlIHZhbHVlID0gSlNfRHVwVmFsdWUoY3R4LCBhcmd2WzBdKTsKICAgIHVpbnQ4X3QqIGRhdGE7CiAgICBzaXplX3QgbGVuOwoKICAgIGlmKChkYXRhID0gSlNfR2V0QXJyYXlCdWZmZXIoY3R4LCAmbGVuLCBhcmd2WzBdKSkpIHsKICAgICAgT2Zmc2V0TGVuZ3RoIG9sID0ganNfb2Zmc2V0X2xlbmd0aChjdHgsIGxlbiwgYXJnYyAtIDEsIGFyZ3YgKyAxKTsKICAgICAgSlNPYmplY3QqIG9iaiA9IEpTX1ZBTFVFX0dFVF9PQkoodmFsdWUpOwogICAgICByZXQgPSBKU19OZXdBcnJheUJ1ZmZlcihjdHgsIGRhdGEgKyBvbC5vZmZzZXQsIG9sLmxlbmd0aCwganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jLCAodm9pZCopb2JqLCBGQUxTRSk7CiAgICB9CiAgfQoKICBKU19GcmVlVmFsdWUoY3R4LCBhcnJheWJ1ZmZlcl9jdG9yKTsKCiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNfbWlzY19yZXNpemVhcnJheWJ1ZmZlcihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSkgewogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwoKICBpZihqc19pc19hcnJheWJ1ZmZlcihjdHgsIGFyZ3ZbMF0pKSB7CiAgICBKU09iamVjdCogb2JqID0gSlNfVkFMVUVfR0VUX09CSihhcmd2WzBdKTsKICAgIEpTQXJyYXlCdWZmZXIqIGFycmF5YnVmID0gb2JqLT51LmFycmF5X2J1ZmZlcjsKICAgIHVpbnQ2NF90IG5ld2xlbjsKICAgIEpTX1RvSW5kZXgoY3R4LCAmbmV3bGVuLCBhcmd2WzFdKTsKCiAgICBpZihhcnJheWJ1Zi0+c2hhcmVkKQogICAgICByZXQgPSBKU19UaHJvd1R5cGVFcnJvcihjdHgsICJBcnJheUJ1ZmZlciBtdXN0IG5vdCBiZSBzaGFyZWQiKTsKICAgIGVsc2UgaWYoYXJyYXlidWYtPnNoYXJlZCkKICAgICAgcmV0ID0gSlNfVGhyb3dUeXBlRXJyb3IoY3R4LCAiQXJyYXlCdWZmZXIgbXVzdCBoYXZlIG9wYXF1ZSA9PSAwIik7CiAgICBlbHNlIHsKICAgICAgYXJyYXlidWYtPmRhdGEgPSBqc19yZWFsbG9jKGN0eCwgYXJyYXlidWYtPmRhdGEsIG5ld2xlbik7CiAgICAgIGFycmF5YnVmLT5ieXRlX2xlbmd0aCA9IG5ld2xlbjsKCiAgICAgIHJldCA9IEpTX01LUFRSKEpTX1RBR19PQkpFQ1QsIG9iaik7CiAgICB9CiAgfSBlbHNlIHsKICAgIHJldCA9IEpTX1Rocm93VHlwZUVycm9yKGN0eCwgIkV4cGVjdGluZyBBcnJheUJ1ZmZlciIpOwogIH0KCiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNfbWlzY19jb25jYXRhcnJheWJ1ZmZlcihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSkgewogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwogIGludCBpOwogIHNpemVfdCB0b3RhbF9sZW4gPSAwLCBwb3MgPSAwOwogIHVpbnQ4X3QqIGJ1ZjsKCiAgZm9yKGkgPSAwOyBpIDwgYXJnYzsgaSsrKSB7CiAgICBpZighanNfaXNfYXJyYXlidWZmZXIoY3R4LCBhcmd2WzBdKSkKICAgICAgcmV0dXJuIEpTX1Rocm93VHlwZUVycm9yKGN0eCwgImFyZ3VtZW50ICVkIGlzIG5vdCBBcnJheUJ1ZmZlciIsIGkgKyAxKTsKICAgIHRvdGFsX2xlbiArPSBqc19hcnJheWJ1ZmZlcl9sZW5ndGgoY3R4LCBhcmd2W2ldKTsKICB9CgogIGJ1ZiA9IGpzX21hbGxvYyhjdHgsIHRvdGFsX2xlbik7CgogIGZvcihpID0gMDsgaSA8IGFyZ2M7IGkrKykgewogICAgc2l6ZV90IGxlbjsKICAgIHVpbnQ4X3QqIHB0cjsKICAgIHB0ciA9IEpTX0dldEFycmF5QnVmZmVyKGN0eCwgJmxlbiwgYXJndltpXSk7CgogICAgbWVtY3B5KCZidWZbcG9zXSwgcHRyLCBsZW4pOwogICAgcG9zICs9IGxlbjsKICB9CgogIHJldHVybiBKU19OZXdBcnJheUJ1ZmZlcihjdHgsIGJ1ZiwgdG90YWxfbGVuLCBqc19ieXRlY29kZV9mcmVlX2Z1bmMsIDAsIEZBTFNFKTsKfQoKc3RhdGljIEpTVmFsdWUKanNfbWlzY19zZWFyY2hhcnJheWJ1ZmZlcihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSkgewogIE1lbW9yeUJsb2NrIGhheXN0YWNrLCBuZWVkbGUsIG1hc2s7CiAgc2l6ZV90IG5fc2l6ZSwgaF9lbmQ7CgogIGlmKCFibG9ja19hcnJheWJ1ZmZlcigmaGF5c3RhY2ssIGFyZ3ZbMF0sIGN0eCkpCiAgICByZXR1cm4gSlNfVGhyb3dUeXBlRXJyb3IoY3R4LCAiYXJndW1lbnQgMSAoaGF5c3RhY2spIG11c3QgYmUgYW4gQXJyYXlCdWZmZXIiKTsKICBpZighYmxvY2tfYXJyYXlidWZmZXIoJm5lZWRsZSwgYXJndlsxXSwgY3R4KSkKICAgIHJldHVybiBKU19UaHJvd1R5cGVFcnJvcihjdHgsICJhcmd1bWVudCAyIChoYXlzdGFjaykgbXVzdCBiZSBhbiBBcnJheUJ1ZmZlciIpOwogIGlmKGFyZ2MgPCAzKSB7CiAgICB1aW50OF90KiBwdHI7CiAgICBwdHJkaWZmX3Qgb2ZzOwoKICAgIGlmKG5lZWRsZS5zaXplIDw9IGhheXN0YWNrLnNpemUgJiYgKHB0ciA9IG1lbW1lbShoYXlzdGFjay5iYXNlLCBoYXlzdGFjay5zaXplLCBuZWVkbGUuYmFzZSwgbmVlZGxlLnNpemUpKSkgewogICAgICBvZnMgPSBwdHIgLSBoYXlzdGFjay5iYXNlOwogICAgICByZXR1cm4gSlNfTmV3SW50NjQoY3R4LCBvZnMpOwogICAgfQoKICAgIHJldHVybiBKU19OVUxMOwogIH0KCiAgaWYoIWJsb2NrX2FycmF5YnVmZmVyKCZtYXNrLCBhcmd2WzJdLCBjdHgpKQogICAgcmV0dXJuIEpTX1Rocm93VHlwZUVycm9yKGN0eCwgImFyZ3VtZW50IDMgKG1hc2spIG11c3QgYmUgYW4gQXJyYXlCdWZmZXIiKTsKCiAgbl9zaXplID0gTUlOX05VTShuZWVkbGUuc2l6ZSwgbWFzay5zaXplKTsKICBoX2VuZCA9IGhheXN0YWNrLnNpemUgLSBuX3NpemU7CgogIC8vIG5haXZlIHNlYXJjaGluZyBhbGdvcml0aG0gKHNsb3cpCiAgZm9yKHNpemVfdCBpID0gMDsgaSA8IGhfZW5kOyBpKyspIHsKICAgIGludCBmb3VuZCA9IDE7CiAgICBmb3Ioc2l6ZV90IGogPSAwOyBqIDwgbl9zaXplOyBqKyspIHsKICAgICAgIGlmKChoYXlzdGFjay5iYXNlW2kgKyBqXSBeIG5lZWRsZS5iYXNlW2ldKSAmIG1hc2suYmFzZVtqXSkgewogICAgICAgIGZvdW5kID0gMDsKICAgICAgICBicmVhazsKICAgICAgfQogICAgfQogICAgaWYoZm91bmQpIHsKICAgICAgICAgZm9yKHNpemVfdCBqID0gMDsgaiA8IG5fc2l6ZTsgaisrKSB7CiAgICAgICAgICB1aW50OF90IHhvcnZhbCA9IGhheXN0YWNrLmJhc2VbaSArIGpdIF4gbmVlZGxlLmJhc2VbaV07CiAgICAgICAgICBwcmludGYoIkAoJXp1ICsgJXp1KVxuIiwgIGksIGopOwogICAgICAgICAgcHJpbnRmKCIlMDJ4IFhPUiAlMDJ4ID0gJTAyeFxuIiwgaGF5c3RhY2suYmFzZVtpICsgal0sIG5lZWRsZS5iYXNlW2ldLCB4b3J2YWwpOwogICAgICAgICAgcHJpbnRmKCIlMDJ4IEFORCAlMDJ4ID0gJTAyeFxuIiwgIHhvcnZhbCxtYXNrLmJhc2Vbal0sIHhvcnZhbCAmIG1hc2suYmFzZVtqXSk7Cn0KIAogICAgIHJldHVybiBKU19OZXdJbnQ2NChjdHgsIChpbnQ2NF90KWkpOwogICAgfQogIH0KCiAgcmV0dXJuIEpTX05VTEw7Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgc3RydWN0IHRpbWVzcGVjIHRzOwoKICBjbG9ja19nZXR0aW1lKENMT0NLX01PTk9UT05JQywgJnRzKTsKCiAgcmV0dXJuIEpTX05ld0Zsb2F0NjQoY3R4LCAoZG91YmxlKXRzLnR2X3NlYyAqIDEwMDAgKyAoKGRvdWJsZSl0cy50dl9uc2VjIC8gMWUwNikpOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc19taXNjX3Byb2NsaW5rKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbWFnaWMpIHsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKICBEeW5CdWYgZGJ1ZiA9IHswfTsKICBjb25zdCBjaGFyKiBsaW5rOwogIGNoYXIgcGF0aFsyNTZdOwogIHNpemVfdCBuOwogIHNzaXplX3QgcjsKCiAgc3dpdGNoKG1hZ2ljKSB7CiAgICBjYXNlIEZVTkNfR0VURVhFQ1VUQUJMRTogbGluayA9ICJleGUiOyBicmVhazsKICAgIGNhc2UgRlVOQ19HRVRDV0Q6IGxpbmsgPSAiY3dkIjsgYnJlYWs7CiAgICBjYXNlIEZVTkNfR0VUUk9PVDogbGluayA9ICJyb290IjsgYnJlYWs7CiAgICBjYXNlIEZVTkNfR0VURkQ6IGxpbmsgPSAiZmQvIjsgYnJlYWs7CiAgfQoKICBuID0gc25wcmludGYocGF0aCwgc2l6ZW9mKHBhdGgpLCAiL3Byb2Mvc2VsZi8lcyIsIGxpbmspOwoKICBpZihtYWdpYyA9PSBGVU5DX0dFVEZEKSB7CiAgICBpbnQzMl90IGZkOwogICAgaWYoYXJnYyA8IDEgfHwgIUpTX0lzTnVtYmVyKGFyZ3ZbMF0pKQogICAgICByZXR1cm4gSlNfVGhyb3dUeXBlRXJyb3IoY3R4LCAiYXJndW1lbnQgMSBtdXN0IGJlIE51bWJlciIpOwoKICAgIEpTX1RvSW50MzIoY3R4LCAmZmQsIGFyZ3ZbMF0pOwogICAgc25wcmludGYoJnBhdGhbbl0sIHNpemVvZihwYXRoKSAtIG4sICIlZCIsIGZkKTsKICB9CgogIGpzX2RidWZfaW5pdChjdHgsICZkYnVmKTsKCiAgaWYoKHIgPSBwYXRoX3JlYWRsaW5rKHBhdGgsICZkYnVmKSkgPiAwKSB7CiAgICByZXQgPSBkYnVmX3Rvc3RyaW5nX2ZyZWUoJmRidWYsIGN0eCk7CiAgfSBlbHNlIGlmKHIgPCAwKSB7CiAgfQoKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgSlNWYWx1ZQpqc19taXNjX3Byb2NyZWFkKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbWFnaWMpIHsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKICBEeW5CdWYgZGJ1ZiA9IHswfTsKICBzc2l6ZV90IGksIGogPSAwLCBzaXplLCBuOwogIGNvbnN0IGNoYXIqIGZpbGU7CiAgY2hhciBzZXAgPSAnXG4nOwoKICBzd2l0Y2gobWFnaWMpIHsKICAgIGNhc2UgRlVOQ19HRVRDT01NQU5ETElORToKICAgICAgZmlsZSA9ICIvcHJvYy9zZWxmL2NtZGxpbmUiOwogICAgICBzZXAgPSAnXDAnOwogICAgICBicmVhazsKICAgIGNhc2UgRlVOQ19HRVRQUk9DTUFQUzoKICAgICAgZmlsZSA9ICIvcHJvYy9zZWxmL21hcHMiOwogICAgICBzZXAgPSAnXG4nOwogICAgICBicmVhazsKICAgIGNhc2UgRlVOQ19HRVRQUk9DTU9VTlRTOgogICAgICBmaWxlID0gIi9wcm9jL3NlbGYvbW91bnRzIjsKICAgICAgc2VwID0gJ1xuJzsKICAgICAgYnJlYWs7CiAgICBjYXNlIEZVTkNfR0VUUFJPQ1NUQVQ6CiAgICAgIGZpbGUgPSAiL3Byb2Mvc2VsZi9zdGF0IjsKICAgICAgc2VwID0gJyAnOwogICAgICBicmVhazsKICB9CgogIGpzX2RidWZfaW5pdChjdHgsICZkYnVmKTsKCiAgaWYoKHNpemUgPSBkYnVmX2xvYWQoJmRidWYsIGZpbGUpKSA+IDApIHsKCiAgICB3aGlsZShzaXplID4gMCAmJiBkYnVmLmJ1ZltzaXplIC0gMV0gPT0gJ1xuJykgc2l6ZS0tOwoKICAgIHJldCA9IEpTX05ld0FycmF5KGN0eCk7CiAgICBmb3IoaSA9IDA7IGkgPCBzaXplOyBpICs9IG4gKyAxKSB7CiAgICAgIHNpemVfdCBsZW47CiAgICAgIGxlbiA9IG4gPSBieXRlX2NocigmZGJ1Zi5idWZbaV0sIHNpemUgLSBpLCBzZXApOwogICAgICB3aGlsZShsZW4gPiAwICYmIGlzX3doaXRlc3BhY2VfY2hhcihkYnVmLmJ1ZltpICsgbGVuIC0gMV0pKSBsZW4tLTsKICAgICAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCByZXQsIGorKywgSlNfTmV3U3RyaW5nTGVuKGN0eCwgKGNvbnN0IGNoYXIqKSZkYnVmLmJ1ZltpXSwgbGVuKSk7CiAgICB9CiAgfQoKICBkYnVmX2ZyZWUoJmRidWYpOwoKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgSlNWYWx1ZQpqc19taXNjX2dldHByb3RvdHlwZWNoYWluKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgSlNWYWx1ZSBwcm90bywgcmV0OwogIHNpemVfdCBqID0gMDsKCiAgaWYoYXJnYyA8IDEgfHwgIUpTX0lzT2JqZWN0KGFyZ3ZbMF0pKQogICAgcmV0dXJuIEpTX1Rocm93VHlwZUVycm9yKGN0eCwgImFyZ3VtZW50IDEgb2JqZWN0IGV4Y2VwdGVkIik7CgogIHJldCA9IEpTX05ld0FycmF5KGN0eCk7CgogIGZvcihwcm90byA9IGFyZ3ZbMF07ICFKU19Jc0V4Y2VwdGlvbihwcm90byk7IHByb3RvID0gSlNfR2V0UHJvdG90eXBlKGN0eCwgcHJvdG8pKSB7CgogICAgaWYoaiA+IDApCiAgICAgIEpTX1NldFByb3BlcnR5VWludDMyKGN0eCwgcmV0LCBqIC0gMSwgcHJvdG8pOwogICAgaisrOwogIH0KCiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNfbWlzY19ocnRpbWUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10pIHsKICBzdHJ1Y3QgdGltZXNwZWMgdHM7CiAgSlNWYWx1ZSByZXQ7CgogIGNsb2NrX2dldHRpbWUoQ0xPQ0tfTU9OT1RPTklDLCAmdHMpOwoKICBpZihhcmdjID49IDEgJiYgSlNfSXNBcnJheShjdHgsIGFyZ3ZbMF0pKSB7CiAgICBpbnQ2NF90IHNlYywgbnNlYzsKICAgIEpTVmFsdWUgcHNlYywgcG5zZWM7CgogICAgcHNlYyA9IEpTX0dldFByb3BlcnR5VWludDMyKGN0eCwgYXJndlswXSwgMCk7CiAgICBwbnNlYyA9IEpTX0dldFByb3BlcnR5VWludDMyKGN0eCwgYXJndlswXSwgMSk7CgogICAgSlNfVG9JbnQ2NChjdHgsICZzZWMsIHBzZWMpOwogICAgSlNfVG9JbnQ2NChjdHgsICZuc2VjLCBwbnNlYyk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCBwc2VjKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHBuc2VjKTsKCiAgICBpZihuc2VjID4gdHMudHZfbnNlYykgewogICAgICB0cy50dl9zZWMgLT0gMTsKICAgICAgdHMudHZfbnNlYyArPSAxMDAwMDAwMDAwOwogICAgfQoKICAgIHRzLnR2X3NlYyAtPSBzZWM7CiAgICB0cy50dl9uc2VjIC09IG5zZWM7CiAgfQoKICByZXQgPSBKU19OZXdBcnJheShjdHgpOwogIEpTX1NldFByb3BlcnR5VWludDMyKGN0eCwgcmV0LCAwLCBKU19OZXdJbnQ2NChjdHgsIHRzLnR2X3NlYykpOwogIEpTX1NldFByb3BlcnR5VWludDMyKGN0eCwgcmV0LCAxLCBKU19OZXdJbnQ2NChjdHgsIHRzLnR2X25zZWMpKTsKCiAgcmV0dXJuIHJldDsKfQoKLypzdGF0aWMgSlNWYWx1ZQpqc19taXNjX3JlYWxwYXRoKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgY2hhciByZXNvbHZlZFtQQVRIX01BWF07CiAgY29uc3QgY2hhciogcGF0aCA9IEpTX1RvQ1N0cmluZyhjdHgsIGFyZ3ZbMF0pOwogIGNoYXIqIHJlc3VsdDsKCiNpZm5kZWYgX193YXNpX18KICBpZigocmVzdWx0ID0gcmVhbHBhdGgocGF0aCwgcmVzb2x2ZWQpKSkKI2VuZGlmCiAgICByZXR1cm4gSlNfTmV3U3RyaW5nKGN0eCwgcmVzdWx0KTsKICByZXR1cm4gSlNfTlVMTDsKfSovCgpzdGF0aWMgSlNWYWx1ZQpqc19taXNjX2ZubWF0Y2goSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10pIHsKICBzaXplX3QgcGxlbiwgc2xlbjsKICBpbnQzMl90IGZsYWdzID0gMCwgcmV0OwoKICBjb25zdCBjaGFyKiBwYXR0ZXJuID0gSlNfVG9DU3RyaW5nTGVuKGN0eCwgJnBsZW4sIGFyZ3ZbMF0pOwogIGNvbnN0IGNoYXIqIHN0cmluZyA9IEpTX1RvQ1N0cmluZ0xlbihjdHgsICZzbGVuLCBhcmd2WzFdKTsKCiAgaWYoYXJnYyA+PSAzKQogICAgSlNfVG9JbnQzMihjdHgsICZmbGFncywgYXJndlsyXSk7CgogIHJldCA9IHBhdGhfZm5tYXRjaChwYXR0ZXJuLCBwbGVuLCBzdHJpbmcsIHNsZW4sIGZsYWdzKTsKICBKU19GcmVlQ1N0cmluZyhjdHgsIHBhdHRlcm4pOwogIEpTX0ZyZWVDU3RyaW5nKGN0eCwgc3RyaW5nKTsKICByZXR1cm4gSlNfTmV3Qm9vbChjdHgsICFyZXQpOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc19taXNjX3VuYW1lKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgc3RydWN0IHV0c25hbWUgdW47CiAgSlNWYWx1ZSByZXQgPSBKU19VTkRFRklORUQ7CgogIGlmKHVuYW1lKCZ1bikgIT0gLTEpIHsKICAgIHJldCA9IEpTX05ld09iamVjdChjdHgpOwoKICAgIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAic3lzbmFtZSIsIEpTX05ld1N0cmluZyhjdHgsIHVuLnN5c25hbWUpKTsKICAgIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAibm9kZW5hbWUiLCBKU19OZXdTdHJpbmcoY3R4LCB1bi5ub2RlbmFtZSkpOwogICAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJyZWxlYXNlIiwgSlNfTmV3U3RyaW5nKGN0eCwgdW4ucmVsZWFzZSkpOwogICAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJ2ZXJzaW9uIiwgSlNfTmV3U3RyaW5nKGN0eCwgdW4udmVyc2lvbikpOwogICAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJtYWNoaW5lIiwgSlNfTmV3U3RyaW5nKGN0eCwgdW4ubWFjaGluZSkpOwogIH0KCiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNfbWlzY19idG9hKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgSlNWYWx1ZSByZXQ7CiAgSW5wdXRCdWZmZXIgaW5wdXQgPSBqc19pbnB1dF9jaGFycyhjdHgsIGFyZ3ZbMF0pOwogIHNpemVfdCBlbmNsZW4gPSBiNjRfZ2V0X2VuY29kZWRfYnVmZmVyX3NpemUoaW5wdXQuc2l6ZSk7CiAgdWludDhfdCogZW5jYnVmID0ganNfbWFsbG9jKGN0eCwgZW5jbGVuKTsKCiAgYjY0X2VuY29kZShpbnB1dC5kYXRhLCBpbnB1dC5zaXplLCBlbmNidWYpOwoKICByZXQgPSBKU19OZXdTdHJpbmdMZW4oY3R4LCAoY29uc3QgY2hhciopZW5jYnVmLCBlbmNsZW4pOwogIGpzX2ZyZWUoY3R4LCBlbmNidWYpOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzX21pc2NfYXRvYihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSkgewogIEpTVmFsdWUgcmV0OwogIElucHV0QnVmZmVyIGlucHV0ID0ganNfaW5wdXRfY2hhcnMoY3R4LCBhcmd2WzBdKTsKICBzaXplX3QgZGVjbGVuID0gYjY0X2dldF9kZWNvZGVkX2J1ZmZlcl9zaXplKGlucHV0LnNpemUpOwogIHVpbnQ4X3QqIGRlY2J1ZiA9IGpzX21hbGxvYyhjdHgsIGRlY2xlbik7CgogIGI2NF9kZWNvZGUoaW5wdXQuZGF0YSwgaW5wdXQuc2l6ZSwgZGVjYnVmKTsKCiAgcmV0ID0gSlNfTmV3QXJyYXlCdWZmZXJDb3B5KGN0eCwgKGNvbnN0IHVpbnQ4X3QqKWRlY2J1ZiwgZGVjbGVuKTsKICBqc19mcmVlKGN0eCwgZGVjYnVmKTsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgSlNWYWx1ZQpqc19taXNjX2NvbXBpbGUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10sIGludCBtYWdpYykgewogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwogIGNvbnN0IGNoYXIqIGZpbGUgPSBKU19Ub0NTdHJpbmcoY3R4LCBhcmd2WzBdKTsKICBCT09MIGlzX21vZCA9IEZBTFNFOwogIHVpbnQ4X3QqIGJ1ZjsKICBzaXplX3QgbGVuOwogIGludDMyX3QgZmxhZ3MgPSBKU19FVkFMX1RZUEVfR0xPQkFMOwoKICBpZihhcmdjID49IDIgJiYgSlNfSXNOdW1iZXIoYXJndlsxXSkpIHsKICAgIEpTX1RvSW50MzIoY3R4LCAmZmxhZ3MsIGFyZ3ZbMV0pOwogIH0gZWxzZSBpZihhcmdjID49IDIgJiYgSlNfSXNCb29sKGFyZ3ZbMV0pKSB7CiAgICBpZihKU19Ub0Jvb2woY3R4LCBhcmd2WzFdKSkKICAgICAgZmxhZ3MgfD0gSlNfRVZBTF9UWVBFX01PRFVMRTsKICB9CiAgaXNfbW9kID0gISEoZmxhZ3MgJiBKU19FVkFMX1RZUEVfTU9EVUxFKTsKICBpZihzdHJfZW5kcyhmaWxlLCAiLmpzbSIpKQogICAgaXNfbW9kID0gVFJVRTsKICBpZigoYnVmID0ganNfbG9hZF9maWxlKGN0eCwgJmxlbiwgZmlsZSkpKSB7CiAgICBpZighaXNfbW9kICYmIEpTX0RldGVjdE1vZHVsZSgoY29uc3QgY2hhciopYnVmLCBsZW4pKQogICAgICBpc19tb2QgPSBUUlVFOwogICAgZmxhZ3MgfD0gKGlzX21vZCA/IEpTX0VWQUxfVFlQRV9NT0RVTEUgOiBKU19FVkFMX1RZUEVfR0xPQkFMKTsKICAgIHJldCA9IEpTX0V2YWwoY3R4LCAoY29uc3QgY2hhciopYnVmLCBsZW4sIGZpbGUsIGZsYWdzIHwgKGlzX21vZCA/IEpTX0VWQUxfRkxBR19DT01QSUxFX09OTFkgOiAwKSk7CgogICAgaWYoaXNfbW9kICYmICEoZmxhZ3MgJiBKU19FVkFMX0ZMQUdfQ09NUElMRV9PTkxZKSkgewogICAgICByZXQgPSBKU19FdmFsRnVuY3Rpb24oY3R4LCByZXQpOwogICAgfQogIH0gZWxzZSB7CiAgICByZXQgPSBKU19UaHJvd1JlZmVyZW5jZUVycm9yKGN0eCwgImNvdWxkIG5vdCBsb2FkICclcyc6ICVzIiwgZmlsZSwgc3RyZXJyb3IoZXJybm8pKTsKICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNfbWlzY193cml0ZV9vYmplY3QoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10pIHsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKICBzaXplX3Qgc2l6ZTsKICB1aW50OF90KiBieXRlY29kZTsKCiAgaWYoKGJ5dGVjb2RlID0gSlNfV3JpdGVPYmplY3QoY3R4LCAmc2l6ZSwgYXJndlswXSwgSlNfV1JJVEVfT0JKX0JZVEVDT0RFKSkpIHsKICAgIHJldCA9IEpTX05ld0FycmF5QnVmZmVyKGN0eCwgYnl0ZWNvZGUsIHNpemUsIGpzX2J5dGVjb2RlX2ZyZWVfZnVuYywgMCwgRkFMU0UpOwogIH0KICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgSlNWYWx1ZQpqc19taXNjX3JlYWRfb2JqZWN0KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgSW5wdXRCdWZmZXIgaW5wdXQgPSBqc19pbnB1dF9jaGFycyhjdHgsIGFyZ3ZbMF0pOwoKICByZXR1cm4gSlNfUmVhZE9iamVjdChjdHgsIGlucHV0LmRhdGEsIGlucHV0LnNpemUsIEpTX1JFQURfT0JKX0JZVEVDT0RFKTsKfQoKc3RhdGljIEpTVmFsdWUKanNfbWlzY19nZXR4KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbWFnaWMpIHsKCiAgaW50MzJfdCByZXQgPSAwOwoKICBzd2l0Y2gobWFnaWMpIHsKI2lmbmRlZiBfX3dhc2lfXwogICAgY2FzZSBGVU5DX0dFVFBJRDogewogICAgICByZXQgPSBnZXRwaWQoKTsKICAgICAgYnJlYWs7CiAgICB9CiNlbmRpZgojaWZuZGVmIF9fd2FzaV9fCiAgICBjYXNlIEZVTkNfR0VUUFBJRDogewogICAgICByZXQgPSBnZXRwcGlkKCk7CiAgICAgIGJyZWFrOwogICAgfQojZW5kaWYKICAgIGNhc2UgRlVOQ19HRVRTSUQ6IHsKICAgICAgLy8gc3JldCA9IGdldHNpZCgpOwogICAgICBicmVhazsKICAgIH0KI2lmbmRlZiBfX3dhc2lfXwogICAgY2FzZSBGVU5DX0dFVFVJRDogewogICAgICByZXQgPSBnZXR1aWQoKTsKICAgICAgYnJlYWs7CiAgICB9CiNlbmRpZgojaWZuZGVmIF9fd2FzaV9fCiAgICBjYXNlIEZVTkNfR0VUR0lEOiB7CiAgICAgIHJldCA9IGdldGdpZCgpOwogICAgICBicmVhazsKICAgIH0KI2VuZGlmCiNpZm5kZWYgX193YXNpX18KICAgIGNhc2UgRlVOQ19HRVRFVUlEOiB7CiAgICAgIHJldCA9IGdldGV1aWQoKTsKICAgICAgYnJlYWs7CiAgICB9CiNlbmRpZgojaWZuZGVmIF9fd2FzaV9fCiAgICBjYXNlIEZVTkNfR0VURUdJRDogewogICAgICByZXQgPSBnZXRlZ2lkKCk7CiAgICAgIGJyZWFrOwogICAgfQojZW5kaWYKI2lmbmRlZiBfX3dhc2lfXwogICAgY2FzZSBGVU5DX1NFVFVJRDogewogICAgICBpbnQzMl90IHVpZDsKICAgICAgSlNfVG9JbnQzMihjdHgsICZ1aWQsIGFyZ3ZbMF0pOwogICAgICByZXQgPSBzZXR1aWQodWlkKTsKICAgICAgYnJlYWs7CiAgICB9CiNlbmRpZgojaWZuZGVmIF9fd2FzaV9fCiAgICBjYXNlIEZVTkNfU0VUR0lEOiB7CiAgICAgIGludDMyX3QgZ2lkOwogICAgICBKU19Ub0ludDMyKGN0eCwgJmdpZCwgYXJndlswXSk7CiAgICAgIHJldCA9IHNldGdpZChnaWQpOwogICAgICBicmVhazsKICAgIH0KI2VuZGlmCiAgICBjYXNlIEZVTkNfU0VURVVJRDogewogICAgICBpbnQzMl90IGV1aWQ7CiAgICAgIEpTX1RvSW50MzIoY3R4LCAmZXVpZCwgYXJndlswXSk7CiNpZm5kZWYgX193YXNpX18KICAgICAgcmV0ID0gc2V0dWlkKGV1aWQpOwojZW5kaWYKICAgICAgYnJlYWs7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBGVU5DX1NFVEVHSUQ6IHsKICAgICAgaW50MzJfdCBlZ2lkOwogICAgICBKU19Ub0ludDMyKGN0eCwgJmVnaWQsIGFyZ3ZbMF0pOwojaWZuZGVmIF9fd2FzaV9fCiAgICAgIHJldCA9IHNldGdpZChlZ2lkKTsKI2VuZGlmCiAgICAgIGJyZWFrOwogICAgfQogIH0KICBpZihyZXQgPT0gLTEpCiAgICByZXR1cm4gSlNfVGhyb3dJbnRlcm5hbEVycm9yKGN0eCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIiVzKCkgZmFpbGVkOiAlcyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoY29uc3QgY2hhciogY29uc3RbXSl7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZ2V0cGlkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJnZXRwcGlkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJnZXRzaWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImdldHVpZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiZ2V0Z2lkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJnZXRldWlkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJnZXRlZ2lkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJzZXR1aWQiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgInNldGdpZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic2V0ZXVpZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAic2V0ZWdpZCIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pW21hZ2ljIC0gRlVOQ19HRVRQSURdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlcnJvcihlcnJubykpOwoKICByZXR1cm4gSlNfTmV3SW50MzIoY3R4LCByZXQpOwp9CgplbnVtIHsKICBWQUxVRV9UWVBFID0gMCwKICBWQUxVRV9UQUcsCiAgVkFMVUVfUFRSLAp9OwoKc3RhdGljIEpTVmFsdWUKanNfbWlzY192YWx1ZXR5cGUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10sIGludCBtYWdpYykgewogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwoKICBzd2l0Y2gobWFnaWMpIHsKICAgIGNhc2UgVkFMVUVfVFlQRTogewogICAgICBjb25zdCBjaGFyKiB0eXBlc3RyID0ganNfdmFsdWVfdHlwZXN0cihjdHgsIGFyZ3ZbMF0pOwogICAgICByZXQgPSBKU19OZXdTdHJpbmcoY3R4LCB0eXBlc3RyKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIFZBTFVFX1RBRzogewogICAgICByZXQgPSBKU19OZXdJbnQzMihjdHgsIEpTX1ZBTFVFX0dFVF9UQUcoYXJndlswXSkpOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgVkFMVUVfUFRSOiB7CiAgICAgIHZvaWQqIHB0ciA9IEpTX1ZBTFVFX0dFVF9QVFIoYXJndlswXSk7CiAgICAgIGNoYXIgYnVmWzEyOF07CgogICAgICBzbnByaW50ZihidWYsIHNpemVvZihidWYpLCAiJXAiLCBwdHIpOwogICAgICByZXQgPSBKU19OZXdTdHJpbmcoY3R4LCBidWYpOwogICAgICBicmVhazsKICAgIH0KICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNfbWlzY19ldmFsYmluYXJ5KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgSlNWYWx1ZSByZXQgPSBKU19VTkRFRklORUQ7CiAgQk9PTCBsb2FkX29ubHkgPSBGQUxTRTsKICBKU1ZhbHVlQ29uc3Qgb2JqOwogIGludCB0YWcgPSBKU19WQUxVRV9HRVRfVEFHKGFyZ3ZbMF0pOwogIGlmKGFyZ2MgPj0gMikKICAgIGxvYWRfb25seSA9IEpTX1RvQm9vbChjdHgsIGFyZ3ZbMV0pOwoKICBpZih0YWcgIT0gSlNfVEFHX01PRFVMRSAmJiB0YWcgIT0gSlNfVEFHX0ZVTkNUSU9OX0JZVEVDT0RFKQogICAgb2JqID0ganNfbWlzY19yZWFkX29iamVjdChjdHgsIHRoaXNfdmFsLCBhcmdjLCBhcmd2KTsKICBlbHNlCiAgICBvYmogPSBhcmd2WzBdOwogIGlmKEpTX0lzRXhjZXB0aW9uKG9iaikpCiAgICByZXR1cm4gb2JqOwoKICB0YWcgPSBKU19WQUxVRV9HRVRfVEFHKG9iaik7CgogIGlmKHRhZyAhPSBKU19UQUdfTU9EVUxFICYmIHRhZyAhPSBKU19UQUdfRlVOQ1RJT05fQllURUNPREUpCiAgICByZXR1cm4gSlNfVGhyb3dUeXBlRXJyb3IoY3R4LCAib2JqIGlzIG5vdCBNT0RVTEUgbm9yIEJZVEVDT0RFIik7CgogIGlmKGxvYWRfb25seSkgewogICAgaWYodGFnID09IEpTX1RBR19NT0RVTEUpCiAgICAgIGpzX21vZHVsZV9zZXRfaW1wb3J0X21ldGEoY3R4LCBvYmosIEZBTFNFLCBGQUxTRSk7CiAgfSBlbHNlIHsKICAgIGlmKHRhZyA9PSBKU19UQUdfTU9EVUxFKSB7CiAgICAgIGlmKEpTX1Jlc29sdmVNb2R1bGUoY3R4LCBvYmopIDwgMCkgewogICAgICAgIEpTTW9kdWxlRGVmKiBtID0gSlNfVkFMVUVfR0VUX1BUUihvYmopOwogICAgICAgIGNvbnN0IGNoYXIqIG5hbWUgPSBKU19BdG9tVG9DU3RyaW5nKGN0eCwgbS0+bW9kdWxlX25hbWUpOwogICAgICAgIHJldCA9IEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJGYWlsZWQgcmVzb2x2aW5nIG1vZHVsZSAnJXMnIiwgbmFtZSk7CiAgICAgICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBuYW1lKTsKICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBvYmopOwogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAganNfbW9kdWxlX3NldF9pbXBvcnRfbWV0YShjdHgsIG9iaiwgRkFMU0UsIFRSVUUpOwogICAgfQogICAgcmV0ID0gSlNfRXZhbEZ1bmN0aW9uKGN0eCwgb2JqKTsKICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNfbWlzY19vcGNvZGVfYXJyYXkoSlNDb250ZXh0KiBjdHgsIGNvbnN0IEpTT3BDb2RlKiBvcGNvZGUpIHsKICBKU1ZhbHVlIHJldCA9IEpTX05ld0FycmF5KGN0eCk7CiAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCByZXQsIDAsIEpTX05ld1VpbnQzMihjdHgsIG9wY29kZS0+c2l6ZSkpOwogIEpTX1NldFByb3BlcnR5VWludDMyKGN0eCwgcmV0LCAxLCBKU19OZXdVaW50MzIoY3R4LCBvcGNvZGUtPm5fcG9wKSk7CiAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCByZXQsIDIsIEpTX05ld1VpbnQzMihjdHgsIG9wY29kZS0+bl9wdXNoKSk7CiAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCByZXQsIDMsIEpTX05ld1VpbnQzMihjdHgsIG9wY29kZS0+Zm10KSk7CiAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCByZXQsIDQsIEpTX05ld1N0cmluZyhjdHgsIG9wY29kZS0+bmFtZSkpOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzX21pc2Nfb3Bjb2RlX29iamVjdChKU0NvbnRleHQqIGN0eCwgY29uc3QgSlNPcENvZGUqIG9wY29kZSkgewogIEpTVmFsdWUgcmV0ID0gSlNfTmV3T2JqZWN0KGN0eCk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJzaXplIiwgSlNfTmV3VWludDMyKGN0eCwgb3Bjb2RlLT5zaXplKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJuX3BvcCIsIEpTX05ld1VpbnQzMihjdHgsIG9wY29kZS0+bl9wb3ApKTsKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgIm5fcHVzaCIsIEpTX05ld1VpbnQzMihjdHgsIG9wY29kZS0+bl9wdXNoKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJmbXQiLCBKU19OZXdVaW50MzIoY3R4LCBvcGNvZGUtPmZtdCkpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAibmFtZSIsIEpTX05ld1N0cmluZyhjdHgsIG9wY29kZS0+bmFtZSkpOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzX21pc2Nfb3Bjb2RlcyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSkgewogIEpTVmFsdWUgcmV0ID0gSlNfTmV3QXJyYXkoY3R4KTsKICBzaXplX3QgaSwgaiwgbGVuID0gY291bnRvZihqc19vcGNvZGVzKTsKICBCT09MIGFzX29iamVjdCA9IEZBTFNFOwoKICBpZihhcmdjID49IDEpCiAgICBhc19vYmplY3QgPSBKU19Ub0Jvb2woY3R4LCBhcmd2WzBdKTsKCiAgZm9yKGkgPSAwLCBqID0gMDsgaSA8IGxlbjsgaSsrKSB7CgogICAgaWYoaSA+PSBPUF9URU1QX1NUQVJUICYmIGkgPCBPUF9URU1QX0VORCkKICAgICAgY29udGludWU7CgogICAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCByZXQsIGorKywgKGFzX29iamVjdCA/IGpzX21pc2Nfb3Bjb2RlX29iamVjdCA6IGpzX21pc2Nfb3Bjb2RlX2FycmF5KShjdHgsICZqc19vcGNvZGVzW2ldKSk7CiAgfQoKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgSlNWYWx1ZQpqc19taXNjX2dldF9ieXRlY29kZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSkgewogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwoKICBpZihKU19Jc0Z1bmN0aW9uKGN0eCwgYXJndlswXSkpIHsKICAgIEpTT2JqZWN0KiBvYmogPSBKU19WQUxVRV9HRVRfT0JKKGFyZ3ZbMF0pOwogICAgSlNGdW5jdGlvbkJ5dGVjb2RlKiBmbmJjOwoKICAgIGlmKChmbmJjID0gb2JqLT51LmZ1bmMuZnVuY3Rpb25fYnl0ZWNvZGUpKSB7CiAgICAgIHJldCA9IEpTX05ld0FycmF5QnVmZmVyQ29weShjdHgsIGZuYmMtPmJ5dGVfY29kZV9idWYsIGZuYmMtPmJ5dGVfY29kZV9sZW4pOwogICAgfQogIH0KCiAgcmV0dXJuIHJldDsKfQoKZW51bSB7CiAgQVRPTV9UT19TVFJJTkcgPSAwLAogIEFUT01fVE9fVkFMVUUsCiAgVkFMVUVfVE9fQVRPTSwKfTsKCnN0YXRpYyBKU1ZhbHVlCmpzX21pc2NfYXRvbShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSwgaW50IG1hZ2ljKSB7CiAgSlNWYWx1ZSByZXQgPSBKU19VTkRFRklORUQ7CgogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBBVE9NX1RPX1NUUklORzogewogICAgICBpbnQzMl90IGF0b207CiAgICAgIEpTX1RvSW50MzIoY3R4LCAmYXRvbSwgYXJndlswXSk7CiAgICAgIHJldCA9IEpTX0F0b21Ub1N0cmluZyhjdHgsIGF0b20pOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgQVRPTV9UT19WQUxVRTogewogICAgICBpbnQzMl90IGF0b207CiAgICAgIEpTX1RvSW50MzIoY3R4LCAmYXRvbSwgYXJndlswXSk7CiAgICAgIHJldCA9IEpTX0F0b21Ub1ZhbHVlKGN0eCwgYXRvbSk7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBWQUxVRV9UT19BVE9NOiB7CiAgICAgIEpTQXRvbSBhdG9tID0gSlNfVmFsdWVUb0F0b20oY3R4LCBhcmd2WzBdKTsKICAgICAgcmV0ID0gSlNfTmV3VWludDMyKGN0eCwgYXRvbSk7CiAgICAgIGJyZWFrOwogICAgfQogIH0KICByZXR1cm4gcmV0Owp9CgplbnVtIHsKICBHRVRfQ0xBU1NfSUQgPSAwLAogIEdFVF9DTEFTU19OQU1FLAogIEdFVF9DTEFTU19BVE9NLAogIEdFVF9DTEFTU19DT1VOVCwKICBHRVRfQ0xBU1NfUFJPVE8sCiAgR0VUX0NMQVNTX0NPTlNUUlVDVE9SLAp9OwoKc3RhdGljIEpTVmFsdWUKanNfbWlzY19jbGFzc2lkKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbWFnaWMpIHsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKICBKU09iamVjdCogb2JqOwogIGludDMyX3QgY2xhc3NfaWQgPSAwOwoKICBpZihhcmdjID49IDEpIHsKICAgIGlmKEpTX0lzTnVtYmVyKGFyZ3ZbMF0pKQogICAgICBKU19Ub0ludDMyKGN0eCwgJmNsYXNzX2lkLCBhcmd2WzBdKTsKICAgIGVsc2UgaWYoKG9iaiA9IGpzX3ZhbHVlX29iaihhcmd2WzBdKSkpCiAgICAgIGNsYXNzX2lkID0gb2JqLT5jbGFzc19pZDsKICB9CgogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBHRVRfQ0xBU1NfSUQ6IHsKICAgICAgaWYoY2xhc3NfaWQgPiAwKQogICAgICAgIHJldCA9IEpTX05ld1VpbnQzMihjdHgsIGNsYXNzX2lkKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEdFVF9DTEFTU19OQU1FOiB7CiAgICAgIGlmKGNsYXNzX2lkID4gMCkgewogICAgICAgIEpTQXRvbSBhdG9tOwogICAgICAgIGlmKChhdG9tID0ganNfY2xhc3NfYXRvbShjdHgsIGNsYXNzX2lkKSkpCiAgICAgICAgICByZXQgPSBKU19BdG9tVG9WYWx1ZShjdHgsIGF0b20pOwogICAgICB9CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBHRVRfQ0xBU1NfQVRPTTogewogICAgICBpZihjbGFzc19pZCA+IDApIHsKICAgICAgICBKU0F0b20gYXRvbTsKICAgICAgICBpZigoYXRvbSA9IGpzX2NsYXNzX2F0b20oY3R4LCBjbGFzc19pZCkpKQogICAgICAgICAgcmV0ID0gSlNfTmV3SW50MzIoY3R4LCBhdG9tKTsKICAgICAgfQogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgR0VUX0NMQVNTX0NPVU5UOiB7CiAgICAgIHVpbnQzMl90IGksIGNsYXNzX2NvdW50ID0gY3R4LT5ydC0+Y2xhc3NfY291bnQ7CiAgICAgIGZvcihpID0gMTsgaSA8IGNsYXNzX2NvdW50OyBpKyspCiAgICAgICAgaWYoIUpTX0lzUmVnaXN0ZXJlZENsYXNzKGN0eC0+cnQsIGkpKQogICAgICAgICAgYnJlYWs7CgogICAgICByZXQgPSBKU19OZXdVaW50MzIoY3R4LCBpKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEdFVF9DTEFTU19QUk9UTzogewogICAgICBpZihjbGFzc19pZCA+IDApCiAgICAgICAgcmV0ID0gSlNfR2V0Q2xhc3NQcm90byhjdHgsIGNsYXNzX2lkKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEdFVF9DTEFTU19DT05TVFJVQ1RPUjogewogICAgICBpZihjbGFzc19pZCA+IDApIHsKICAgICAgICBKU1ZhbHVlIHByb3RvID0gSlNfR2V0Q2xhc3NQcm90byhjdHgsIGNsYXNzX2lkKTsKICAgICAgICBpZihKU19Jc09iamVjdChwcm90bykpCiAgICAgICAgICByZXQgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIHByb3RvLCAiY29uc3RydWN0b3IiKTsKICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBwcm90byk7CiAgICAgIH0KICAgICAgYnJlYWs7CiAgICB9CiAgfQogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBKU1ZhbHVlCgpqc19taXNjX2JpdGZpZWxkX3RvX2FycmF5KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgY29uc3QgdWludDhfdCogYnVmOwogIHNpemVfdCBsZW47CiAgaW50NjRfdCBvZmZzZXQgPSAwOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwoKICBpZihhcmdjID49IDIpCiAgICBKU19Ub0ludDY0KGN0eCwgJm9mZnNldCwgYXJndlsxXSk7CgogIGlmKChidWYgPSBKU19HZXRBcnJheUJ1ZmZlcihjdHgsICZsZW4sIGFyZ3ZbMF0pKSkgewogICAgc2l6ZV90IGksIGogPSAwLCBiaXRzID0gbGVuICogODsKICAgIHJldCA9IEpTX05ld0FycmF5KGN0eCk7CgogICAgZm9yKGkgPSAwOyBpIDwgYml0czsgaSsrKSB7CiAgICAgIGlmKGJ1ZltpID4+IDNdICYgKDF1IDw8IChpICYgMHg3KSkpIHsKICAgICAgICBKU19TZXRQcm9wZXJ0eVVpbnQzMihjdHgsIHJldCwgaisrLCBKU19OZXdJbnQ2NChjdHgsIGkgKyBvZmZzZXQpKTsKICAgICAgfQogICAgfQogIH0KICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgSlNWYWx1ZQpqc19taXNjX2FycmF5X3RvX2JpdGZpZWxkKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgc2l6ZV90IGxlbjsKICBpbnQ2NF90IG9mZnNldCA9IDA7CiAgSlNWYWx1ZSByZXQgPSBKU19VTkRFRklORUQ7CgogIGlmKGFyZ2MgPj0gMikKICAgIEpTX1RvSW50NjQoY3R4LCAmb2Zmc2V0LCBhcmd2WzFdKTsKCiAgaWYoIUpTX0lzQXJyYXkoY3R4LCBhcmd2WzBdKSkKICAgIHJldHVybiBKU19UaHJvd1R5cGVFcnJvcihjdHgsICJhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5Iik7CgogIGlmKChsZW4gPSBqc19hcnJheV9sZW5ndGgoY3R4LCBhcmd2WzBdKSkpIHsKICAgIHNpemVfdCBpOwogICAgaW50NjRfdCBtYXggPSAtMTsKICAgIHVpbnQ4X3QqIGJ1ZnB0cjsKICAgIHNpemVfdCBidWZzaXplOwoKICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgIEpTVmFsdWUgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVVpbnQzMihjdHgsIGFyZ3ZbMF0sIGkpOwogICAgICB1aW50MzJfdCBudW1iZXI7CiAgICAgIEpTX1RvVWludDMyKGN0eCwgJm51bWJlciwgdmFsdWUpOwogICAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CgogICAgICBpZihtYXggPCBudW1iZXIpCiAgICAgICAgbWF4ID0gbnVtYmVyOwogICAgfQogICAgYnVmc2l6ZSA9ICgobWF4ICsgMSkgKyA3KSA+PiAzOwogICAgaWYoKGJ1ZnB0ciA9IGpzX21hbGxvY3ooY3R4LCBidWZzaXplKSkgPT0gMCkKICAgICAgcmV0dXJuIEpTX1Rocm93T3V0T2ZNZW1vcnkoY3R4KTsKCiAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICBKU1ZhbHVlIHZhbHVlID0gSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCBhcmd2WzBdLCBpKTsKICAgICAgdWludDMyX3QgbnVtYmVyOwogICAgICBKU19Ub1VpbnQzMihjdHgsICZudW1iZXIsIHZhbHVlKTsKICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwoKICAgICAgbnVtYmVyIC09IG9mZnNldDsKCiAgICAgIGJ1ZnB0cltudW1iZXIgPj4gM10gfD0gMXUgPDwgKG51bWJlciAmIDB4Nyk7CiAgICB9CgogICAgcmV0ID0gSlNfTmV3QXJyYXlCdWZmZXIoY3R4LCBidWZwdHIsIGJ1ZnNpemUsIGpzX2FycmF5YnVmZmVyX2ZyZWVfZnVuYywgTlVMTCwgRkFMU0UpOwogIH0KICByZXR1cm4gcmV0Owp9CgplbnVtIHsKICBSQU5ET01fUkFORCwKICBSQU5ET01fUkFOREksCiAgUkFORE9NX1JBTkRGLAogIFJBTkRPTV9TUkFORCwKfTsKCnN0YXRpYyBKU1ZhbHVlCmpzX21pc2NfcmFuZG9tKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbWFnaWMpIHsKICB1aW50MzJfdCBib3VuZCA9IDA7CiAgSlNWYWx1ZSByZXQgPSBKU19VTkRFRklORUQ7CgogIGlmKGFyZ2MgPiAwICYmIEpTX0lzTnVtYmVyKGFyZ3ZbMF0pKQogICAgSlNfVG9VaW50MzIoY3R4LCAmYm91bmQsIGFyZ3ZbMF0pOwoKICBzd2l0Y2gobWFnaWMpIHsKICAgIGNhc2UgUkFORE9NX1JBTkQ6IHsKICAgICAgdWludDMyX3QgbnVtID0gYXJnYyA+IDAgPyBwY2czMl9yYW5kb21fYm91bmRlZF9kaXZpc2lvbmxlc3MoYm91bmQpIDogcGNnMzJfcmFuZG9tKCk7CiAgICAgIHJldCA9IEpTX05ld1VpbnQzMihjdHgsIG51bSk7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBSQU5ET01fUkFOREk6IHsKICAgICAgaW50MzJfdCBudW0gPSBhcmdjID4gMCA/IHBjZzMyX3JhbmRvbV9ib3VuZGVkX2RpdmlzaW9ubGVzcyhib3VuZCAqIDIpIC0gYm91bmQgOiBwY2czMl9yYW5kb20oKTsKICAgICAgcmV0ID0gSlNfTmV3SW50MzIoY3R4LCBudW0pOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgUkFORE9NX1JBTkRGOiB7CiAgICAgIHVpbnQzMl90IG51bSA9IHBjZzMyX3JhbmRvbSgpOwogICAgICByZXQgPSBKU19OZXdGbG9hdDY0KGN0eCwgKGRvdWJsZSludW0gLyBVSU5UMzJfTUFYKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIFJBTkRPTV9TUkFORDogewogICAgICB1aW50MzJfdCBzdCA9IDA7CiAgICAgIEpTX1RvVWludDMyKGN0eCwgJnN0LCBhcmd2WzBdKTsKICAgICAgcGNnMzJfaW5pdF9zdGF0ZShzdCk7CiAgICAgIHJldCA9IEpTX1VOREVGSU5FRDsKICAgICAgYnJlYWs7CiAgICB9CiAgfQoKICByZXR1cm4gcmV0Owp9CgpKU1ZhbHVlCmpzX21pc2NfZXNjYXBlKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgSW5wdXRCdWZmZXIgaW5wdXQgPSBqc19pbnB1dF9jaGFycyhjdHgsIGFyZ3ZbMF0pOwogIER5bkJ1ZiBvdXRwdXQ7CiAganNfZGJ1Zl9pbml0KGN0eCwgJm91dHB1dCk7CiAgZGJ1Zl9wdXRfZXNjYXBlZCgmb3V0cHV0LCAoY29uc3QgY2hhciopaW5wdXQuZGF0YSwgaW5wdXQuc2l6ZSk7CiAgcmV0dXJuIGRidWZfdG9zdHJpbmdfZnJlZSgmb3V0cHV0LCBjdHgpOwp9CgpKU1ZhbHVlCmpzX21pc2NfcXVvdGUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10pIHsKICBJbnB1dEJ1ZmZlciBpbnB1dCA9IGpzX2lucHV0X2NoYXJzKGN0eCwgYXJndlswXSk7CiAgRHluQnVmIG91dHB1dDsKICBjaGFyIHF1b3RlID0gJyInLAogICAgICAgdGFibGVbMjU2XSA9IHsKICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAnYicsICAndCcsICAnbicsICAndicsICAnZicsICAncicsICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLAogICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsCiAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwKICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLAogICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICdcXCcsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsCiAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwKICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLAogICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsCiAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwKICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLAogICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsCiAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwKICAgICAgIH07CgogIGpzX2RidWZfaW5pdChjdHgsICZvdXRwdXQpOwogIGlmKGFyZ2MgPj0gMikgewogICAgY29uc3QgY2hhciogc3RyID0gSlNfVG9DU3RyaW5nKGN0eCwgYXJndlsxXSk7CiAgICBpZihzdHJbMF0pCiAgICAgIHF1b3RlID0gc3RyWzBdOwogICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBzdHIpOwogIH0KCiAgdGFibGVbKHVuc2lnbmVkKXF1b3RlXSA9IHF1b3RlOwoKICBpZihxdW90ZSA9PSAnYCcpIHsKICAgIHRhYmxlWyh1bnNpZ25lZCknXHInXSA9IDA7CiAgICB0YWJsZVsodW5zaWduZWQpJ1xuJ10gPSAwOwogICAgdGFibGVbKHVuc2lnbmVkKSckJ10gPSAnJCc7CiAgfQoKICBkYnVmX3B1dGMoJm91dHB1dCwgcXVvdGUpOwogIGRidWZfcHV0X2VzY2FwZWRfdGFibGUoJm91dHB1dCwgKGNvbnN0IGNoYXIqKWlucHV0LmRhdGEsIGlucHV0LnNpemUsIHRhYmxlKTsKICBkYnVmX3B1dGMoJm91dHB1dCwgcXVvdGUpOwogIHJldHVybiBkYnVmX3Rvc3RyaW5nX2ZyZWUoJm91dHB1dCwgY3R4KTsKfQoKSlNWYWx1ZQpqc19taXNjX2Vycm9yKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgaW50MzJfdCBlcnJudW0gPSBlcnJubzsKICBjb25zdCBjaGFyKiBzeXNjYWxsID0gMDsKICBKU1ZhbHVlIGVycjsKICBpZihhcmdjID49IDEpCiAgICBKU19Ub0ludDMyKGN0eCwgJmVycm51bSwgYXJndlswXSk7CiAgaWYoYXJnYyA+PSAyKQogICAgc3lzY2FsbCA9IEpTX1RvQ1N0cmluZyhjdHgsIGFyZ3ZbMV0pOwoKICBlcnIgPSBKU19OZXdPYmplY3QoY3R4KTsKCiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCBlcnIsICJlcnJubyIsIEpTX05ld0ludDMyKGN0eCwgZXJybnVtKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCBlcnIsICJzeXNjYWxsIiwgSlNfTmV3U3RyaW5nKGN0eCwgc3lzY2FsbCkpOwoKICBpZihzeXNjYWxsKQogICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBzeXNjYWxsKTsKCiAgcmV0dXJuIGVycjsKfQplbnVtIHsKICBJU19BUlJBWSwKICBJU19CSUdERUNJTUFMLAogIElTX0JJR0ZMT0FULAogIElTX0JJR0lOVCwKICBJU19CT09MLAogIElTX0NGVU5DVElPTiwKICBJU19DT05TVFJVQ1RPUiwKICBJU19FTVBUWVNUUklORywKICBJU19FUlJPUiwKICBJU19FWENFUFRJT04sCiAgSVNfRVhURU5TSUJMRSwKICBJU19GVU5DVElPTiwKICBJU19IVE1MRERBLAogIElTX0lOU1RBTkNFT0YsCiAgSVNfSU5URUdFUiwKICBJU19KT0JQRU5ESU5HLAogIElTX0xJVkVPQkpFQ1QsCiAgSVNfTlVMTCwKICBJU19OVU1CRVIsCiAgSVNfT0JKRUNULAogIElTX1JFR0lTVEVSRURDTEFTUywKICBJU19TVFJJTkcsCiAgSVNfU1lNQk9MLAogIElTX1VOQ0FUQ0hBQkxFRVJST1IsCiAgSVNfVU5ERUZJTkVELAogIElTX1VOSU5JVElBTElaRUQsCn07CgpKU1ZhbHVlCmpzX21pc2NfaXMoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10sIGludCBtYWdpYykgewogIGludDMyX3QgciA9IC0xOwogIEpTVmFsdWVDb25zdCBhcmcgPSBhcmd2WzBdOwoKICBzd2l0Y2gobWFnaWMpIHsKICAgIGNhc2UgSVNfQVJSQVk6IHIgPSBKU19Jc0FycmF5KGN0eCwgYXJnKTsgYnJlYWs7CiAgICBjYXNlIElTX0JJR0RFQ0lNQUw6IHIgPSBKU19Jc0JpZ0RlY2ltYWwoYXJnKTsgYnJlYWs7CiAgICBjYXNlIElTX0JJR0ZMT0FUOiByID0gSlNfSXNCaWdGbG9hdChhcmcpOyBicmVhazsKICAgIGNhc2UgSVNfQklHSU5UOiByID0gSlNfSXNCaWdJbnQoY3R4LCBhcmcpOyBicmVhazsKICAgIGNhc2UgSVNfQk9PTDogciA9IEpTX0lzQm9vbChhcmcpOyBicmVhazsKICAgIGNhc2UgSVNfQ0ZVTkNUSU9OOiByID0gSlNfR2V0Q2xhc3NJRChhcmcpID09IEpTX0NMQVNTX0NfRlVOQ1RJT047IGJyZWFrOwogICAgY2FzZSBJU19DT05TVFJVQ1RPUjogciA9IEpTX0lzQ29uc3RydWN0b3IoY3R4LCBhcmcpOyBicmVhazsKICAgIGNhc2UgSVNfRU1QVFlTVFJJTkc6IHIgPSBKU19WQUxVRV9HRVRfVEFHKGFyZykgPT0gSlNfVEFHX1NUUklORyAmJiBKU19WQUxVRV9HRVRfU1RSSU5HKGFyZyktPmxlbiA9PSAwOyBicmVhazsKICAgIGNhc2UgSVNfRVJST1I6IHIgPSBKU19Jc0Vycm9yKGN0eCwgYXJnKTsgYnJlYWs7CiAgICBjYXNlIElTX0VYQ0VQVElPTjogciA9IEpTX0lzRXhjZXB0aW9uKGFyZyk7IGJyZWFrOwogICAgY2FzZSBJU19FWFRFTlNJQkxFOiByID0gSlNfSXNFeHRlbnNpYmxlKGN0eCwgYXJnKTsgYnJlYWs7CiAgICBjYXNlIElTX0ZVTkNUSU9OOiByID0gSlNfSXNGdW5jdGlvbihjdHgsIGFyZyk7IGJyZWFrOwogICAgY2FzZSBJU19IVE1MRERBOiByID0gSlNfVkFMVUVfR0VUX1RBRyhhcmcpID09IEpTX1RBR19PQkpFQ1QgJiYgSlNfVkFMVUVfR0VUX09CSihhcmcpLT5pc19IVE1MRERBOyBicmVhazsKICAgIGNhc2UgSVNfSU5TVEFOQ0VPRjogciA9IEpTX0lzSW5zdGFuY2VPZihjdHgsIGFyZywgYXJndlsxXSk7IGJyZWFrOwogICAgY2FzZSBJU19JTlRFR0VSOiByID0gSlNfSXNOdW1iZXIoYXJnKSAmJiBKU19WQUxVRV9HRVRfVEFHKGFyZykgIT0gSlNfVEFHX0ZMT0FUNjQ7IGJyZWFrOwogICAgY2FzZSBJU19KT0JQRU5ESU5HOiByID0gSlNfSXNKb2JQZW5kaW5nKEpTX0dldFJ1bnRpbWUoY3R4KSk7IGJyZWFrOwogICAgY2FzZSBJU19MSVZFT0JKRUNUOiByID0gSlNfSXNMaXZlT2JqZWN0KEpTX0dldFJ1bnRpbWUoY3R4KSwgYXJnKTsgYnJlYWs7CiAgICBjYXNlIElTX05VTEw6IHIgPSBKU19Jc051bGwoYXJnKTsgYnJlYWs7CiAgICBjYXNlIElTX05VTUJFUjogciA9IEpTX0lzTnVtYmVyKGFyZyk7IGJyZWFrOwogICAgY2FzZSBJU19PQkpFQ1Q6IHIgPSBKU19Jc09iamVjdChhcmcpOyBicmVhazsKICAgIGNhc2UgSVNfUkVHSVNURVJFRENMQVNTOiByID0gIUpTX1RvSW50MzIoY3R4LCAmciwgYXJnKSAmJiBKU19Jc1JlZ2lzdGVyZWRDbGFzcyhKU19HZXRSdW50aW1lKGN0eCksIHIpOyBicmVhazsKICAgIGNhc2UgSVNfU1RSSU5HOiByID0gSlNfSXNTdHJpbmcoYXJnKTsgYnJlYWs7CiAgICBjYXNlIElTX1NZTUJPTDogciA9IEpTX0lzU3ltYm9sKGFyZyk7IGJyZWFrOwogICAgY2FzZSBJU19VTkNBVENIQUJMRUVSUk9SOiByID0gSlNfSXNVbmNhdGNoYWJsZUVycm9yKGN0eCwgYXJnKTsgYnJlYWs7CiAgICBjYXNlIElTX1VOREVGSU5FRDogciA9IEpTX0lzVW5kZWZpbmVkKGFyZyk7IGJyZWFrOwogICAgY2FzZSBJU19VTklOSVRJQUxJWkVEOiByID0gSlNfSXNVbmluaXRpYWxpemVkKGFyZyk7IGJyZWFrOwogIH0KICBpZihyID09IC0xKQogICAgcmV0dXJuIEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJqc19taXNjX2lzICVkIiwgbWFnaWMpOwogIHJldHVybiBKU19OZXdCb29sKGN0eCwgciA+PSAxKTsKfQoKc3RhdGljIGNvbnN0IEpTQ0Z1bmN0aW9uTGlzdEVudHJ5IGpzX21pc2NfZnVuY3NbXSA9IHsKI2lmbmRlZiBfX3dhc2lfXwovLyBKU19DRlVOQ19ERUYoInJlYWxwYXRoIiwgMSwganNfbWlzY19yZWFscGF0aCksCiNlbmRpZgogICAgSlNfQ0ZVTkNfREVGKCJmbm1hdGNoIiwgMywganNfbWlzY19mbm1hdGNoKSwKICAgIEpTX0NGVU5DX0RFRigidG9TdHJpbmciLCAxLCBqc19taXNjX3Rvc3RyaW5nKSwKICAgIEpTX0NGVU5DX0RFRigidG9Qb2ludGVyIiwgMSwganNfbWlzY190b3BvaW50ZXIpLAogICAgSlNfQ0ZVTkNfREVGKCJ0b0FycmF5QnVmZmVyIiwgMSwganNfbWlzY190b2FycmF5YnVmZmVyKSwKICAgIEpTX0NGVU5DX0RFRigiZHVwQXJyYXlCdWZmZXIiLCAxLCBqc19taXNjX2R1cGFycmF5YnVmZmVyKSwKICAgIEpTX0NGVU5DX0RFRigicmVzaXplQXJyYXlCdWZmZXIiLCAxLCBqc19taXNjX3Jlc2l6ZWFycmF5YnVmZmVyKSwKICAgIEpTX0NGVU5DX0RFRigiY29uY2F0QXJyYXlCdWZmZXIiLCAxLCBqc19taXNjX2NvbmNhdGFycmF5YnVmZmVyKSwKICAgIEpTX0NGVU5DX0RFRigic2VhcmNoQXJyYXlCdWZmZXIiLCAyLCBqc19taXNjX3NlYXJjaGFycmF5YnVmZmVyKSwKICAgIEpTX0NGVU5DX0RFRigiZ2V0UGVyZm9ybWFuY2VDb3VudGVyIiwgMCwganNfbWlzY19nZXRwZXJmb3JtYW5jZWNvdW50ZXIpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRFeGVjdXRhYmxlIiwgMCwganNfbWlzY19wcm9jbGluaywgRlVOQ19HRVRFWEVDVVRBQkxFKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0Q3VycmVudFdvcmtpbmdEaXJlY3RvcnkiLCAwLCBqc19taXNjX3Byb2NsaW5rLCBGVU5DX0dFVENXRCksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImdldFJvb3REaXJlY3RvcnkiLCAwLCBqc19taXNjX3Byb2NsaW5rLCBGVU5DX0dFVFJPT1QpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRGaWxlRGVzY3JpcHRvciIsIDAsIGpzX21pc2NfcHJvY2xpbmssIEZVTkNfR0VURkQpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRDb21tYW5kTGluZSIsIDAsIGpzX21pc2NfcHJvY3JlYWQsIEZVTkNfR0VUQ09NTUFORExJTkUpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRQcm9jTWFwcyIsIDAsIGpzX21pc2NfcHJvY3JlYWQsIEZVTkNfR0VUUFJPQ01BUFMpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRQcm9jTW91bnRzIiwgMCwganNfbWlzY19wcm9jcmVhZCwgRlVOQ19HRVRQUk9DTU9VTlRTKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0UHJvY1N0YXQiLCAwLCBqc19taXNjX3Byb2NyZWFkLCBGVU5DX0dFVFBST0NTVEFUKSwKICAgIEpTX0NGVU5DX0RFRigiZ2V0UHJvdG90eXBlQ2hhaW4iLCAwLCBqc19taXNjX2dldHByb3RvdHlwZWNoYWluKSwKI2lmbmRlZiBfX3dhc2lfXwogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRwaWQiLCAwLCBqc19taXNjX2dldHgsIEZVTkNfR0VUUElEKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0cHBpZCIsIDAsIGpzX21pc2NfZ2V0eCwgRlVOQ19HRVRQUElEKSwKI2VuZGlmCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImdldHNpZCIsIDAsIGpzX21pc2NfZ2V0eCwgRlVOQ19HRVRTSUQpLAojaWZuZGVmIF9fd2FzaV9fCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImdldHVpZCIsIDAsIGpzX21pc2NfZ2V0eCwgRlVOQ19HRVRVSUQpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRnaWQiLCAwLCBqc19taXNjX2dldHgsIEZVTkNfR0VUR0lEKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0ZXVpZCIsIDAsIGpzX21pc2NfZ2V0eCwgRlVOQ19HRVRFVUlEKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0ZWdpZCIsIDAsIGpzX21pc2NfZ2V0eCwgRlVOQ19HRVRFR0lEKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigic2V0dWlkIiwgMSwganNfbWlzY19nZXR4LCBGVU5DX1NFVFVJRCksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoInNldGdpZCIsIDEsIGpzX21pc2NfZ2V0eCwgRlVOQ19TRVRHSUQpLAojZW5kaWYKICAgIEpTX0NGVU5DX01BR0lDX0RFRigic2V0ZXVpZCIsIDEsIGpzX21pc2NfZ2V0eCwgRlVOQ19TRVRFVUlEKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigic2V0ZWdpZCIsIDEsIGpzX21pc2NfZ2V0eCwgRlVOQ19TRVRFR0lEKSwKICAgIEpTX0NGVU5DX0RFRigiaHJ0aW1lIiwgMCwganNfbWlzY19ocnRpbWUpLAogICAgSlNfQ0ZVTkNfREVGKCJ1bmFtZSIsIDAsIGpzX21pc2NfdW5hbWUpLAogICAgSlNfQ0ZVTkNfREVGKCJidG9hIiwgMSwganNfbWlzY19idG9hKSwKICAgIEpTX0NGVU5DX0RFRigiYXRvYiIsIDEsIGpzX21pc2NfYXRvYiksCiAgICBKU19DRlVOQ19ERUYoImJpdGZpZWxkVG9BcnJheSIsIDEsIGpzX21pc2NfYml0ZmllbGRfdG9fYXJyYXkpLAogICAgSlNfQ0ZVTkNfREVGKCJhcnJheVRvQml0ZmllbGQiLCAxLCBqc19taXNjX2FycmF5X3RvX2JpdGZpZWxkKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiY29tcGlsZVNjcmlwdCIsIDEsIGpzX21pc2NfY29tcGlsZSwgMCksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImV2YWxTY3JpcHQiLCAxLCBqc19taXNjX2NvbXBpbGUsIDEpLAogICAgSlNfQ0ZVTkNfREVGKCJ3cml0ZU9iamVjdCIsIDEsIGpzX21pc2Nfd3JpdGVfb2JqZWN0KSwKICAgIEpTX0NGVU5DX0RFRigicmVhZE9iamVjdCIsIDEsIGpzX21pc2NfcmVhZF9vYmplY3QpLAogICAgSlNfQ0ZVTkNfREVGKCJnZXRPcENvZGVzIiwgMCwganNfbWlzY19vcGNvZGVzKSwKICAgIEpTX0NGVU5DX0RFRigiZ2V0Qnl0ZUNvZGUiLCAxLCBqc19taXNjX2dldF9ieXRlY29kZSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoInZhbHVlVHlwZSIsIDEsIGpzX21pc2NfdmFsdWV0eXBlLCBWQUxVRV9UWVBFKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigidmFsdWVUYWciLCAxLCBqc19taXNjX3ZhbHVldHlwZSwgVkFMVUVfVEFHKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigidmFsdWVQdHIiLCAxLCBqc19taXNjX3ZhbHVldHlwZSwgVkFMVUVfUFRSKSwKICAgIEpTX0NGVU5DX0RFRigiZXZhbEJpbmFyeSIsIDEsIGpzX21pc2NfZXZhbGJpbmFyeSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImF0b21Ub1N0cmluZyIsIDEsIGpzX21pc2NfYXRvbSwgQVRPTV9UT19TVFJJTkcpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJhdG9tVG9WYWx1ZSIsIDEsIGpzX21pc2NfYXRvbSwgQVRPTV9UT19WQUxVRSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoInZhbHVlVG9BdG9tIiwgMSwganNfbWlzY19hdG9tLCBWQUxVRV9UT19BVE9NKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0Q2xhc3NJRCIsIDEsIGpzX21pc2NfY2xhc3NpZCwgR0VUX0NMQVNTX0lEKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0Q2xhc3NOYW1lIiwgMSwganNfbWlzY19jbGFzc2lkLCBHRVRfQ0xBU1NfTkFNRSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImdldENsYXNzQXRvbSIsIDEsIGpzX21pc2NfY2xhc3NpZCwgR0VUX0NMQVNTX0FUT00pLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRDbGFzc0NvdW50IiwgMSwganNfbWlzY19jbGFzc2lkLCBHRVRfQ0xBU1NfQ09VTlQpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRDbGFzc1Byb3RvIiwgMSwganNfbWlzY19jbGFzc2lkLCBHRVRfQ0xBU1NfUFJPVE8pLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRDbGFzc0NvbnN0cnVjdG9yIiwgMSwganNfbWlzY19jbGFzc2lkLCBHRVRfQ0xBU1NfQ09OU1RSVUNUT1IpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJyYW5kIiwgMCwganNfbWlzY19yYW5kb20sIFJBTkRPTV9SQU5EKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigicmFuZGkiLCAwLCBqc19taXNjX3JhbmRvbSwgUkFORE9NX1JBTkRJKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigicmFuZGYiLCAwLCBqc19taXNjX3JhbmRvbSwgUkFORE9NX1JBTkRGKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigic3JhbmQiLCAxLCBqc19taXNjX3JhbmRvbSwgUkFORE9NX1NSQU5EKSwKICAgIEpTX0NGVU5DX0RFRigiZXNjYXBlIiwgMSwganNfbWlzY19lc2NhcGUpLAogICAgSlNfQ0ZVTkNfREVGKCJxdW90ZSIsIDEsIGpzX21pc2NfcXVvdGUpLAogICAgSlNfQ0ZVTkNfREVGKCJlcnJvciIsIDAsIGpzX21pc2NfZXJyb3IpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJpc0FycmF5IiwgMSwganNfbWlzY19pcywgSVNfQVJSQVkpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJpc0JpZ0RlY2ltYWwiLCAxLCBqc19taXNjX2lzLCBJU19CSUdERUNJTUFMKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiaXNCaWdGbG9hdCIsIDEsIGpzX21pc2NfaXMsIElTX0JJR0ZMT0FUKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiaXNCaWdJbnQiLCAxLCBqc19taXNjX2lzLCBJU19CSUdJTlQpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJpc0Jvb2wiLCAxLCBqc19taXNjX2lzLCBJU19CT09MKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiaXNDRnVuY3Rpb24iLCAxLCBqc19taXNjX2lzLCBJU19DRlVOQ1RJT04pLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJpc0NvbnN0cnVjdG9yIiwgMSwganNfbWlzY19pcywgSVNfQ09OU1RSVUNUT1IpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJpc0VtcHR5U3RyaW5nIiwgMSwganNfbWlzY19pcywgSVNfRU1QVFlTVFJJTkcpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJpc0Vycm9yIiwgMSwganNfbWlzY19pcywgSVNfRVJST1IpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJpc0V4Y2VwdGlvbiIsIDEsIGpzX21pc2NfaXMsIElTX0VYQ0VQVElPTiksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImlzRXh0ZW5zaWJsZSIsIDEsIGpzX21pc2NfaXMsIElTX0VYVEVOU0lCTEUpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJpc0Z1bmN0aW9uIiwgMSwganNfbWlzY19pcywgSVNfRlVOQ1RJT04pLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJpc0hUTUxEREEiLCAxLCBqc19taXNjX2lzLCBJU19IVE1MRERBKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiaXNJbnN0YW5jZU9mIiwgMSwganNfbWlzY19pcywgSVNfSU5TVEFOQ0VPRiksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImlzSW50ZWdlciIsIDEsIGpzX21pc2NfaXMsIElTX0lOVEVHRVIpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJpc0pvYlBlbmRpbmciLCAxLCBqc19taXNjX2lzLCBJU19KT0JQRU5ESU5HKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiaXNMaXZlT2JqZWN0IiwgMSwganNfbWlzY19pcywgSVNfTElWRU9CSkVDVCksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImlzTnVsbCIsIDEsIGpzX21pc2NfaXMsIElTX05VTEwpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJpc051bWJlciIsIDEsIGpzX21pc2NfaXMsIElTX05VTUJFUiksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImlzT2JqZWN0IiwgMSwganNfbWlzY19pcywgSVNfT0JKRUNUKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiaXNSZWdpc3RlcmVkQ2xhc3MiLCAxLCBqc19taXNjX2lzLCBJU19SRUdJU1RFUkVEQ0xBU1MpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJpc1N0cmluZyIsIDEsIGpzX21pc2NfaXMsIElTX1NUUklORyksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImlzU3ltYm9sIiwgMSwganNfbWlzY19pcywgSVNfU1lNQk9MKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiaXNVbmNhdGNoYWJsZUVycm9yIiwgMSwganNfbWlzY19pcywgSVNfVU5DQVRDSEFCTEVFUlJPUiksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImlzVW5kZWZpbmVkIiwgMSwganNfbWlzY19pcywgSVNfVU5ERUZJTkVEKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiaXNVbmluaXRpYWxpemVkIiwgMSwganNfbWlzY19pcywgSVNfVU5JTklUSUFMSVpFRCksCgogICAgSlNfQ09OU1RBTlQoSlNfRVZBTF9UWVBFX0dMT0JBTCksCiAgICBKU19DT05TVEFOVChKU19FVkFMX1RZUEVfTU9EVUxFKSwKICAgIEpTX0NPTlNUQU5UKEpTX0VWQUxfVFlQRV9ESVJFQ1QpLAogICAgSlNfQ09OU1RBTlQoSlNfRVZBTF9UWVBFX0lORElSRUNUKSwKICAgIEpTX0NPTlNUQU5UKEpTX0VWQUxfVFlQRV9NQVNLKSwKICAgIEpTX0NPTlNUQU5UKEpTX0VWQUxfRkxBR19TVFJJQ1QpLAogICAgSlNfQ09OU1RBTlQoSlNfRVZBTF9GTEFHX1NUUklQKSwKICAgIEpTX0NPTlNUQU5UKEpTX0VWQUxfRkxBR19DT01QSUxFX09OTFkpLAogICAgSlNfQ09OU1RBTlQoSlNfRVZBTF9GTEFHX0JBQ0tUUkFDRV9CQVJSSUVSKSwKICAgIC8vICAgSlNfT0JKRUNUX0RFRigiU3RyaW5nRGVjb2RlciIsIGpzX3N0cmluZ2RlY29kZXJfcHJvcHMsCiAgICAvLyAgIGNvdW50b2YoanNfc3RyaW5nZGVjb2Rlcl9wcm9wcyksIEpTX1BST1BfQ09ORklHVVJBQkxFKSwKCn07CgpzdGF0aWMgaW50CmpzX21pc2NfaW5pdChKU0NvbnRleHQqIGN0eCwgSlNNb2R1bGVEZWYqIG0pIHsKCiAgaWYoIWpzX2xvY2F0aW9uX2NsYXNzX2lkKQogICAganNfbG9jYXRpb25faW5pdChjdHgsIDApOwoKICBpZihtKSB7CiAgICAvLyBKU19TZXRNb2R1bGVFeHBvcnRMaXN0KGN0eCwgbSwgbG9jYXRpb25fY3Rvcik7CiAgICBKU19TZXRNb2R1bGVFeHBvcnRMaXN0KGN0eCwgbSwganNfbWlzY19mdW5jcywgY291bnRvZihqc19taXNjX2Z1bmNzKSk7CiAgICBKU19TZXRNb2R1bGVFeHBvcnQoY3R4LCBtLCAiTG9jYXRpb24iLCBsb2NhdGlvbl9jdG9yKTsKICAgIC8vIEpTX1NldE1vZHVsZUV4cG9ydChjdHgsIG0sICJTdHJpbmdEZWNvZGVyIiwgc3RyaW5nZGVjb2Rlcl9jdG9yKTsKICB9CgogIC8vIGpzX3N0cmluZ2RlY29kZXJfaW5pdChjdHgsIG0pOwoKICAvLyBwcmludGYoIiVzXG4iLCBqc19vcGNvZGVzWzBdLm5hbWUpOwoKICByZXR1cm4gMDsKfQoKI2lmIGRlZmluZWQoSlNfU0hBUkVEX0xJQlJBUlkpICYmIGRlZmluZWQoSlNfTUlTQ19NT0RVTEUpCiNkZWZpbmUgSlNfSU5JVF9NT0RVTEUganNfaW5pdF9tb2R1bGUKI2Vsc2UKI2RlZmluZSBKU19JTklUX01PRFVMRSBqc19pbml0X21vZHVsZV9taXNjCiNlbmRpZgoKVklTSUJMRSBKU01vZHVsZURlZioKSlNfSU5JVF9NT0RVTEUoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIG1vZHVsZV9uYW1lKSB7CiAgSlNNb2R1bGVEZWYqIG07CiAgbSA9IEpTX05ld0NNb2R1bGUoY3R4LCBtb2R1bGVfbmFtZSwganNfbWlzY19pbml0KTsKICBpZighbSkKICAgIHJldHVybiBOVUxMOwogIEpTX0FkZE1vZHVsZUV4cG9ydExpc3QoY3R4LCBtLCBqc19taXNjX2Z1bmNzLCBjb3VudG9mKGpzX21pc2NfZnVuY3MpKTsKICAvLyBKU19BZGRNb2R1bGVFeHBvcnQoY3R4LCBtLCAiU3lzY2FsbEVycm9yIik7CiAgSlNfQWRkTW9kdWxlRXhwb3J0KGN0eCwgbSwgIkxvY2F0aW9uIik7CiAgLy8gSlNfQWRkTW9kdWxlRXhwb3J0KGN0eCwgbSwgIlN0cmluZ0RlY29kZXIiKTsKICByZXR1cm4gbTsKfQoAAAAAAAAAAJKbAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAex8AAAAAAAB7HwAAAAAAAAAAAAAAAPC/"
				],
				[
					663,
					1,
					"insert",
					{
						"characters": "j"
					},
					"AgAAANMdAAAAAAAA1B0AAAAAAAAAAAAA1B0AAAAAAADUHQAAAAAAAAEAAABp",
					"AQAAAAAAAAABAAAA0x0AAAAAAADUHQAAAAAAAAAAAAAAAPC/"
				],
				[
					669,
					1,
					"insert",
					{
						"characters": "j"
					},
					"AgAAAAcfAAAAAAAACB8AAAAAAAAAAAAACB8AAAAAAAAIHwAAAAAAAAEAAABp",
					"AQAAAAAAAAABAAAABx8AAAAAAAAIHwAAAAAAAAAAAAAAAPC/"
				],
				[
					673,
					1,
					"insert",
					{
						"characters": "j"
					},
					"AgAAAJAeAAAAAAAAkR4AAAAAAAAAAAAAkR4AAAAAAACRHgAAAAAAAAEAAABp",
					"AQAAAAAAAAABAAAAkB4AAAAAAACRHgAAAAAAAAAAAAAAAPC/"
				],
				[
					689,
					2,
					"left_delete",
					null,
					"AgAAALEeAAAAAAAAsR4AAAAAAAABAAAAbrAeAAAAAAAAsB4AAAAAAAABAAAAXA",
					"AQAAAAAAAAABAAAAsh4AAAAAAACyHgAAAAAAAAAAAAAAAPC/"
				],
				[
					690,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAALAeAAAAAAAAsR4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAsB4AAAAAAACwHgAAAAAAAAAAAAAAAPC/"
				],
				[
					696,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAALAeAAAAAAAAsR4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAsB4AAAAAAACwHgAAAAAAAAAAAAAAAPC/"
				],
				[
					699,
					2,
					"left_delete",
					null,
					"AgAAAOEeAAAAAAAA4R4AAAAAAAABAAAAbuAeAAAAAAAA4B4AAAAAAAABAAAAXA",
					"AQAAAAAAAAABAAAA4h4AAAAAAADiHgAAAAAAAAAAAAAAAPC/"
				],
				[
					700,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAAOAeAAAAAAAA4R4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA4B4AAAAAAADgHgAAAAAAAAAAAAAAAPC/"
				],
				[
					701,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAOEeAAAAAAAA4h4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA4R4AAAAAAADhHgAAAAAAAAAAAAAAAPC/"
				],
				[
					710,
					1,
					"toggle_comment",
					{
						"block": true
					},
					"AgAAAHIfAAAAAAAAdB8AAAAAAAAAAAAALx4AAAAAAAAxHgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAch8AAAAAAAAvHgAAAAAAAAAAAAAAAE5A"
				]
			]
		},
		{
			"file": "quickjs-location.h",
			"settings":
			{
				"buffer_size": 997,
				"line_ending": "Unix"
			}
		},
		{
			"file": "quickjs-location.c",
			"settings":
			{
				"buffer_size": 11602,
				"line_ending": "Unix"
			}
		},
		{
			"file": "lib/util.js",
			"settings":
			{
				"buffer_size": 20821,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					52,
					1,
					"insert",
					{
						"characters": "searchArrayB"
					},
					"DAAAAIpQAAAAAAAAi1AAAAAAAAAAAAAAi1AAAAAAAACMUAAAAAAAAAAAAACMUAAAAAAAAI1QAAAAAAAAAAAAAI1QAAAAAAAAjlAAAAAAAAAAAAAAjlAAAAAAAACPUAAAAAAAAAAAAACPUAAAAAAAAJBQAAAAAAAAAAAAAJBQAAAAAAAAkVAAAAAAAAAAAAAAkVAAAAAAAACSUAAAAAAAAAAAAACSUAAAAAAAAJNQAAAAAAAAAAAAAJNQAAAAAAAAlFAAAAAAAAAAAAAAlFAAAAAAAACVUAAAAAAAAAAAAACVUAAAAAAAAJZQAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAACKUAAAAAAAAIpQAAAAAAAAAAAAAAAA8L8"
				],
				[
					53,
					1,
					"insert",
					{
						"characters": "uzff"
					},
					"BAAAAJZQAAAAAAAAl1AAAAAAAAAAAAAAl1AAAAAAAACYUAAAAAAAAAAAAACYUAAAAAAAAJlQAAAAAAAAAAAAAJlQAAAAAAAAmlAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAACWUAAAAAAAAJZQAAAAAAAAAAAAAAAA8L8"
				],
				[
					54,
					3,
					"left_delete",
					null,
					"AwAAAJlQAAAAAAAAmVAAAAAAAAABAAAAZphQAAAAAAAAmFAAAAAAAAABAAAAZpdQAAAAAAAAl1AAAAAAAAABAAAAeg",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAACaUAAAAAAAAJpQAAAAAAAAAAAAAAAA8L8"
				],
				[
					55,
					1,
					"insert",
					{
						"characters": "ffer,"
					},
					"BQAAAJdQAAAAAAAAmFAAAAAAAAAAAAAAmFAAAAAAAACZUAAAAAAAAAAAAACZUAAAAAAAAJpQAAAAAAAAAAAAAJpQAAAAAAAAm1AAAAAAAAAAAAAAm1AAAAAAAACcUAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAACXUAAAAAAAAJdQAAAAAAAAAAAAAAAA8L8"
				],
				[
					59,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAABUUQAAaW1wb3J0IGluc3BlY3QgZnJvbSAnaW5zcGVjdCc7CmltcG9ydCB7IFN5c2NhbGxFcnJvciB9IGZyb20gJ3N5c2NhbGxlcnJvcic7CmltcG9ydCB7IGFycmF5VG9CaXRmaWVsZCwgYXRvYiwgYXRvbVRvU3RyaW5nLCBhdG9tVG9WYWx1ZSwgYml0ZmllbGRUb0FycmF5LCBidG9hLCBjb21waWxlU2NyaXB0LCBjb25jYXRBcnJheUJ1ZmZlciwgZHVwQXJyYXlCdWZmZXIsIGV2YWxCaW5hcnksIGdldEJ5dGVDb2RlLCBnZXRDbGFzc0F0b20sIGdldENsYXNzQ29uc3RydWN0b3IsIGdldENsYXNzQ291bnQsIGdldENsYXNzSUQsIGdldENsYXNzTmFtZSwgZ2V0Q2xhc3NQcm90bywgZ2V0Q29tbWFuZExpbmUsIGdldEN1cnJlbnRXb3JraW5nRGlyZWN0b3J5LCBnZXRFeGVjdXRhYmxlLCBnZXRGaWxlRGVzY3JpcHRvciwgZ2V0T3BDb2RlcywgZ2V0UGVyZm9ybWFuY2VDb3VudGVyLCBnZXRQcm9jTWFwcywgZ2V0UHJvY01vdW50cywgZ2V0UHJvY1N0YXQsIGdldFByb3RvdHlwZUNoYWluLCBnZXRSb290RGlyZWN0b3J5LCBnZXRlZ2lkLCBnZXRldWlkLCBnZXRnaWQsIGdldHBpZCwgZ2V0cHBpZCwgZ2V0c2lkLCBnZXR1aWQsIGhydGltZSwgcmVhZE9iamVjdCwgcmVzaXplQXJyYXlCdWZmZXIsIHNldGVnaWQsIHNldGV1aWQsIHNldGdpZCwgc2V0dWlkLCB0b0FycmF5QnVmZmVyLCB0b1BvaW50ZXIsIHRvU3RyaW5nLCB1bmFtZSwgdmFsdWVQdHIsIHZhbHVlVGFnLCB2YWx1ZVRvQXRvbSwgdmFsdWVUeXBlLCB3cml0ZU9iamVjdCwgcmFuZCwgcmFuZGksIHJhbmRmLCBzcmFuZCB9IGZyb20gJ21pc2MnOwppbXBvcnQgeyBleHRlbmRBcnJheSwgQXJyYXlFeHRlbnNpb25zIH0gZnJvbSAnLi9leHRlbmRBcnJheS5qcyc7CmltcG9ydCB7IGV4dGVuZEdlbmVyYXRvciwgR2VuZXJhdG9yRXh0ZW5zaW9ucywgR2VuZXJhdG9yUHJvdG90eXBlLCBHZW5lcmF0b3JDb25zdHJ1Y3RvciB9IGZyb20gJy4vZXh0ZW5kR2VuZXJhdG9yLmpzJzsKaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnOwoKY29uc3Qgc2xpY2UgPSAoeCwgcywgZSkgPT4gU3RyaW5nLnByb3RvdHlwZS5zbGljZS5jYWxsKHgsIHMsIGUpOwpjb25zdCBzdHJpbmdpZnkgPSB2ID0+IGAke3Z9YDsKY29uc3QgcHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsKY29uc3QgZm9ybWF0TnVtYmVyID0gbiA9PiAobiA9PT0gLTAgPyAnLTAnIDogYCR7bn1gKTsKY29uc3QgaXNOYXRpdmUgPSBmbiA9PiAvXFtuYXRpdmVcc2NvZGVcXS8udGVzdChzdHJpbmdpZnkoZm4pKTsKCmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHV0aWwoKSB7CiAgcmV0dXJuIHV0aWw7Cn0KCnV0aWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdXRpbDsKCmNvbnN0IEFzeW5jRnVuY3Rpb24gPSBhc3luYyBmdW5jdGlvbiB4KCkge30uY29uc3RydWN0b3I7CmNvbnN0IEdlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24qICgpIHt9LmNvbnN0cnVjdG9yOwpjb25zdCBBc3luY0dlbmVyYXRvckZ1bmN0aW9uID0gYXN5bmMgZnVuY3Rpb24qICgpIHt9LmNvbnN0cnVjdG9yOwpjb25zdCBUeXBlZEFycmF5ID0gcHJvdG9PZihwcm90b09mKG5ldyBVaW50MTZBcnJheSgxMCkpKS5jb25zdHJ1Y3RvcjsKCmNvbnN0IFNldEl0ZXJhdG9yUHJvdG90eXBlID0gcHJvdG9PZihuZXcgU2V0KCkudmFsdWVzKCkpOwpjb25zdCBNYXBJdGVyYXRvclByb3RvdHlwZSA9IHByb3RvT2YobmV3IE1hcCgpLmVudHJpZXMoKSk7CmNvbnN0IEdlbmVyYXRvclByb3RvdHlwZSA9IHByb3RvT2YoKGZ1bmN0aW9uKiAoKSB7fSkoKSk7CgpleHBvcnQgY29uc3QgZXJyb3JzID0gWwogIG51bGwsCiAgJ0VQRVJNJywKICAnRU5PRU5UJywKICAnRVNSQ0gnLAogICdFSU5UUicsCiAgJ0VJTycsCiAgJ0VOWElPJywKICAnRTJCSUcnLAogICdFTk9FWEVDJywKICAnRUJBREYnLAogICdFQ0hJTEQnLAogICdFQUdBSU4nLAogICdFTk9NRU0nLAogICdFQUNDRVMnLAogICdFRkFVTFQnLAogICdFTk9UQkxLJywKICAnRUJVU1knLAogICdFRVhJU1QnLAogICdFWERFVicsCiAgJ0VOT0RFVicsCiAgJ0VOT1RESVInLAogICdFSVNESVInLAogICdFSU5WQUwnLAogICdFTkZJTEUnLAogICdFTUZJTEUnLAogICdFTk9UVFknLAogICdFVFhUQlNZJywKICAnRUZCSUcnLAogICdFTk9TUEMnLAogICdFU1BJUEUnLAogICdFUk9GUycsCiAgJ0VNTElOSycsCiAgJ0VQSVBFJywKICAnRURPTScsCiAgJ0VSQU5HRScsCiAgJ0VERUFETEsnLAogICdFTkFNRVRPT0xPTkcnLAogICdFTk9MQ0snLAogICdFTk9TWVMnLAogICdFTk9URU1QVFknLAogIG51bGwsCiAgbnVsbCwKICAnRU5PTVNHJywKICAnRUlEUk0nLAogICdFQ0hSTkcnLAogICdFTDJOU1lOQycsCiAgJ0VMM0hMVCcsCiAgJ0VMM1JTVCcsCiAgJ0VMTlJORycsCiAgJ0VVTkFUQ0gnLAogICdFTk9DU0knLAogICdFTDJITFQnLAogICdFQkFERScsCiAgJ0VCQURSJywKICAnRVhGVUxMJywKICAnRU5PQU5PJywKICAnRUJBRFJRQycsCiAgbnVsbCwKICAnJywKICAnRUJGT05UJywKICAnRU5PU1RSJywKICAnRU5PREFUQScsCiAgJ0VUSU1FJywKICAnRU5PU1InLAogICdFTk9ORVQnLAogICdFTk9QS0cnLAogICdFUkVNT1RFJywKICAnRU5PTElOSycsCiAgJ0VBRFYnLAogICdFU1JNTlQnLAogICdFQ09NTScsCiAgJ0VQUk9UTycsCiAgJ0VNVUxUSUhPUCcsCiAgJ0VET1RET1QnLAogICdFQkFETVNHJywKICAnRU9WRVJGTE9XJywKICAnRU5PVFVOSVEnLAogICdFQkFERkQnLAogICdFUkVNQ0hHJywKICAnRUxJQkFDQycsCiAgJ0VMSUJCQUQnLAogICdFTElCU0NOJywKICAnRUxJQk1BWCcsCiAgJ0VMSUJFWEVDJywKICAnRUlMU0VRJywKICAnRVJFU1RBUlQnLAogICdFU1RSUElQRScsCiAgJ0VVU0VSUycsCiAgJ0VOT1RTT0NLJywKICAnRURFU1RBRERSUkVRJywKICAnRU1TR1NJWkUnLAogICdFUFJPVE9UWVBFJywKICAnRU5PUFJPVE9PUFQnLAogICdFUFJPVE9OT1NVUFBPUlQnLAogICdFU09DS1ROT1NVUFBPUlQnLAogICdFT1BOT1RTVVBQJywKICAnRVBGTk9TVVBQT1JUJywKICAnRUFGTk9TVVBQT1JUJywKICAnRUFERFJJTlVTRScsCiAgJ0VBRERSTk9UQVZBSUwnLAogICdFTkVURE9XTicsCiAgJ0VORVRVTlJFQUNIJywKICAnRU5FVFJFU0VUJywKICAnRUNPTk5BQk9SVEVEJywKICAnRUNPTk5SRVNFVCcsCiAgJ0VOT0JVRlMnLAogICdFSVNDT05OJywKICAnRU5PVENPTk4nLAogICdFU0hVVERPV04nLAogICdFVE9PTUFOWVJFRlMnLAogICdFVElNRURPVVQnLAogICdFQ09OTlJFRlVTRUQnLAogICdFSE9TVERPV04nLAogICdFSE9TVFVOUkVBQ0gnLAogICdFQUxSRUFEWScsCiAgJ0VJTlBST0dSRVNTJywKICAnRVNUQUxFJywKICAnRVVDTEVBTicsCiAgJ0VOT1ROQU0nLAogICdFTkFWQUlMJywKICAnRUlTTkFNJywKICAnRVJFTU9URUlPJywKICAnRURRVU9UJywKICAnRU5PTUVESVVNJywKICAnRU1FRElVTVRZUEUnLAogICdFQ0FOQ0VMRUQnLAogICdFTk9LRVknLAogICdFS0VZRVhQSVJFRCcsCiAgJ0VLRVlSRVZPS0VEJywKICAnRUtFWVJFSkVDVEVEJywKICAnRU9XTkVSREVBRCcsCiAgJ0VOT1RSRUNPVkVSQUJMRScsCiAgJ0VSRktJTEwnCl07CgpleHBvcnQgY29uc3QgdHlwZXMgPSB7CiAgaXNBbnlBcnJheUJ1ZmZlcih2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgKHYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCB2IGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpOwogIH0sCiAgaXNBcnJheUJ1ZmZlcih2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyOwogIH0sCiAgaXNCaWdJbnQ2NEFycmF5KHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgQmlnSW50NjRBcnJheTsKICB9LAogIGlzQmlnVWludDY0QXJyYXkodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBCaWdVaW50NjRBcnJheTsKICB9LAogIGlzRGF0ZSh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIERhdGU7CiAgfSwKICBpc0Zsb2F0MzJBcnJheSh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheTsKICB9LAogIGlzRmxvYXQ2NEFycmF5KHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5OwogIH0sCiAgaXNJbnQ4QXJyYXkodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBJbnQ4QXJyYXk7CiAgfSwKICBpc0ludDE2QXJyYXkodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBJbnQxNkFycmF5OwogIH0sCiAgaXNJbnQzMkFycmF5KHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgSW50MzJBcnJheTsKICB9LAogIGlzTWFwKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgTWFwOwogIH0sCiAgaXNQcm9taXNlKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgUHJvbWlzZTsKICB9LAogIGlzUHJveHkodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBQcm94eTsKICB9LAogIGlzUmVnRXhwKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgUmVnRXhwOwogIH0sCiAgaXNTZXQodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBTZXQ7CiAgfSwKICBpc1NoYXJlZEFycmF5QnVmZmVyKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXI7CiAgfSwKICBpc1VpbnQ4QXJyYXkodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBVaW50OEFycmF5OwogIH0sCiAgaXNVaW50OENsYW1wZWRBcnJheSh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5OwogIH0sCiAgaXNVaW50MTZBcnJheSh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIFVpbnQxNkFycmF5OwogIH0sCiAgaXNVaW50MzJBcnJheSh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIFVpbnQzMkFycmF5OwogIH0sCiAgaXNXZWFrTWFwKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgV2Vha01hcDsKICB9LAogIGlzV2Vha1NldCh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIFdlYWtTZXQ7CiAgfSwKICBpc0RhdGFWaWV3KHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgRGF0YVZpZXc7CiAgfSwKICBpc0Jvb2xlYW5PYmplY3QodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBCb29sZWFuOwogIH0sCiAgaXNBc3luY0Z1bmN0aW9uKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgQXN5bmNGdW5jdGlvbjsKICB9LAogIGlzR2VuZXJhdG9yRnVuY3Rpb24odikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBHZW5lcmF0b3JGdW5jdGlvbjsKICB9LAogIGlzQXN5bmNHZW5lcmF0b3JGdW5jdGlvbih2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIEFzeW5jR2VuZXJhdG9yRnVuY3Rpb247CiAgfSwKICBpc051bWJlck9iamVjdCh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIE51bWJlcjsKICB9LAogIGlzQmlnSW50T2JqZWN0KHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgQmlnSW50OwogIH0sCiAgaXNTeW1ib2xPYmplY3QodikgewogICAgcmV0dXJuIHYgJiYgdiBpbnN0YW5jZW9mIFN5bWJvbDsKICB9LAogIGlzTmF0aXZlRXJyb3IodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBFcnJvciAmJiBpc05hdGl2ZSh2LmNvbnN0cnVjdG9yKTsKICB9LAogIGlzTWFwSXRlcmF0b3IodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHByb3RvT2YodikgPT0gTWFwSXRlcmF0b3JQcm90b3R5cGU7CiAgfSwKICBpc1NldEl0ZXJhdG9yKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiBwcm90b09mKHYpID09IFNldEl0ZXJhdG9yUHJvdG90eXBlOwogIH0sCiAgaXNTdHJpbmdPYmplY3QodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBTdHJpbmc7CiAgfSwKICBpc0FycmF5QnVmZmVyVmlldyh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KHYpOwogIH0sCiAgaXNBcmd1bWVudHNPYmplY3QodikgewogICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJzsKICB9LAoKICAvKiBpc0V4dGVybmFsKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgRXh0ZXJuYWw7CiAgfSwqLwoKICBpc0JveGVkUHJpbWl0aXZlKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiBbTnVtYmVyLCBTdHJpbmcsIEJvb2xlYW4sIEJpZ0ludCwgU3ltYm9sXS5zb21lKGN0b3IgPT4gdiBpbnN0YW5jZW9mIGN0b3IpOwogIH0sCgogIGlzR2VuZXJhdG9yT2JqZWN0KHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiBwcm90b09mKHYpID09IEdlbmVyYXRvclByb3RvdHlwZTsKICB9LAogIGlzVHlwZWRBcnJheSh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIFR5cGVkQXJyYXk7CiAgfSwKICBpc01vZHVsZU5hbWVzcGFjZU9iamVjdCh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdltTeW1ib2wudG9TdHJpbmdUYWddID09ICdNb2R1bGUnOwogIH0KfTsKCmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2KSB7CiAgcmV0dXJuIHYgIT0gbnVsbCAmJiB7IGZ1bmN0aW9uOiB0cnVlLCBvYmplY3Q6IHRydWUgfVt0eXBlb2Ygdl07Cn0KCmV4cG9ydCBmdW5jdGlvbiBoYXNCdWlsdEluKG8sIG0pIHsKICByZXR1cm4gaXNOYXRpdmUocHJvdG9PZihvKVttXSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoLi4uYXJncykgewogIHJldHVybiBmb3JtYXRXaXRoT3B0aW9uc0ludGVybmFsKHsgaGlkZUtleXM6IFsnY29uc3RydWN0b3InXSB9LCBhcmdzKTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdpdGhPcHRpb25zKG9wdHMsIC4uLmFyZ3MpIHsKICBpZighaXNPYmplY3Qob3B0cykpIHRocm93IG5ldyBUeXBlRXJyb3IoYG9wdGlvbnMgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdGApOwogIHJldHVybiBmb3JtYXRXaXRoT3B0aW9uc0ludGVybmFsKG9wdHMsIGFyZ3MpOwp9CgpmdW5jdGlvbiBmb3JtYXRXaXRoT3B0aW9uc0ludGVybmFsKG8sIHYpIHsKICBjb25zdCB4ID0gdlswXTsKICBsZXQgYSA9IDA7CiAgbGV0IHMgPSAnJzsKICBsZXQgaiA9ICcnOwogIGlmKHR5cGVvZiB4ID09PSAnc3RyaW5nJykgewogICAgaWYodi5sZW5ndGggPT09IDEpIHJldHVybiB4OwogICAgbGV0IHQ7CiAgICBsZXQgcCA9IDA7CiAgICBmb3IobGV0IGkgPSAwOyBpIDwgeC5sZW5ndGggLSAxOyBpKyspIHsKICAgICAgaWYoeFtpXSA9PSAnJScpIHsKICAgICAgICBsZXQgZiA9ICcnOwogICAgICAgIHdoaWxlKCdzanhkT29pZmMlJy5pbmRleE9mKHhbaSArIDFdKSA9PSAtMSkgewogICAgICAgICAgZiArPSB4W2kgKyAxXTsKICAgICAgICAgICsraTsKICAgICAgICB9CiAgICAgICAgLy9jb25zb2xlLmxvZygncCcsIHAsIGAnJHtzbGljZSh4LCBwLCBpKX0nYCk7CiAgICAgICAgaWYocCA8IGkpIHMgKz0gc2xpY2UoeCwgcCwgaSk7CiAgICAgICAgcCA9IGkgKyAxOwogICAgICAgIC8vY29uc29sZS5sb2coJ2knLCBpKTsKICAgICAgICBjb25zdCBjID0gU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0LmNhbGwoeCwgKytpKTsKICAgICAgICAvL2NvbnNvbGUubG9nKCdzJywgYCcke3N9J2ApOwogICAgICAgIC8vY29uc29sZS5sb2coJ2MnLCBjLCB4W2ldKTsKICAgICAgICBpZihhICsgMSAhPT0gdi5sZW5ndGgpIHsKICAgICAgICAgIHN3aXRjaCAoYykgewogICAgICAgICAgICBjYXNlIDExNTogLy8gJXMKICAgICAgICAgICAgICBjb25zdCB5ID0gdlsrK2FdOwogICAgICAgICAgICAgIGlmKHR5cGVvZiB5ID09PSAnbnVtYmVyJykgdCA9IGZvcm1hdE51bWJlcih5KTsKICAgICAgICAgICAgICBlbHNlIGlmKHR5cGVvZiB5ID09PSAnYmlnaW50JykgdCA9IGAke3l9bmA7CiAgICAgICAgICAgICAgZWxzZSBpZih0eXBlb2YgeSAhPT0gJ29iamVjdCcgfHwgeSA9PT0gbnVsbCB8fCAhaGFzQnVpbHRJbih5LCAndG9TdHJpbmcnKSkgdCA9IFN0cmluZyh5KTsKICAgICAgICAgICAgICBlbHNlIHQgPSBpbnNwZWN0KHksIHsgLi4ubywgY29tcGFjdDogMywgY29sb3JzOiBmYWxzZSwgZGVwdGg6IDAgfSk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMTA2OiAvLyAlagogICAgICAgICAgICAgIHQgPSBzdHJpbmdpZnkodlsrK2FdKTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAxMjA6IC8vICV4CiAgICAgICAgICAgIGNhc2UgMTAwOiAvLyAlZAogICAgICAgICAgICAgIGNvbnN0IG4gPSB2WysrYV07CiAgICAgICAgICAgICAgaWYodHlwZW9mIG4gPT09ICdiaWdpbnQnKSB0ID0gYCR7bn1uYDsKICAgICAgICAgICAgICBlbHNlIGlmKHR5cGVvZiBuID09PSAnc3ltYm9sJykgdCA9ICdOYU4nOwogICAgICAgICAgICAgIGVsc2UgdCA9IGZvcm1hdE51bWJlcihjID09IDEyMCA/IE51bWJlcihuKS50b1N0cmluZygxNikgOiBOdW1iZXIobikpOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDc5OiAvLyAlTwogICAgICAgICAgICAgIHQgPSBpbnNwZWN0KHZbKythXSwgbyk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMTExOiAvLyAlbwogICAgICAgICAgICAgIHQgPSAvKnZbKythXSsnJyA/PyAqLyBpbnNwZWN0KHZbKythXSwgewogICAgICAgICAgICAgICAgLi4ubywKICAgICAgICAgICAgICAgIHNob3dIaWRkZW46IHRydWUsCiAgICAgICAgICAgICAgICBzaG93UHJveHk6IHRydWUsCiAgICAgICAgICAgICAgICBkZXB0aDogMSwKICAgICAgICAgICAgICAgIHByb3RvQ2hhaW46IGZhbHNlCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMTA1OiAvLyAlaQogICAgICAgICAgICAgIGNvbnN0IGsgPSB2WysrYV07CiAgICAgICAgICAgICAgaWYodHlwZW9mIGsgPT09ICdiaWdpbnQnKSB0ID0gYCR7a31gOwogICAgICAgICAgICAgIGVsc2UgaWYodHlwZW9mIGsgPT09ICdzeW1ib2wnKSB0ID0gJ05hTic7CiAgICAgICAgICAgICAgZWxzZSB0ID0gZm9ybWF0TnVtYmVyKHBhcnNlSW50KGspKTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAxMDI6IC8vICVmCiAgICAgICAgICAgICAgY29uc3QgZCA9IHZbKythXTsKICAgICAgICAgICAgICBpZih0eXBlb2YgZCA9PT0gJ3N5bWJvbCcpIHQgPSAnTmFOJzsKICAgICAgICAgICAgICBlbHNlIHQgPSBmb3JtYXROdW1iZXIocGFyc2VGbG9hdChkKSk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgOTk6IC8vICVjCiAgICAgICAgICAgICAgYSArPSAxOwogICAgICAgICAgICAgIHQgPSAnJzsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAzNzogLy8gJSUKICAgICAgICAgICAgICBzICs9IHNsaWNlKHgsIHAsIGkpOwogICAgICAgICAgICAgIHAgPSBpICsgMTsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmKHAgIT09IGkgLSAxKSBzICs9IHNsaWNlKHgsIHAsIGkgLSAxKTsKICAgICAgICAgIGxldCBwYWQgPSBwYXJzZUludChmKTsKCiAgICAgICAgICBpZihNYXRoLmFicyhwYWQpID4gMCkgdCA9IHRbJ3BhZCcgKyAocGFkIDwgMCA/ICdFbmQnIDogJ1N0YXJ0JyldKE1hdGguYWJzKHBhZCksIC9eLT8wLy50ZXN0KGYpID8gJzAnIDogJyAnKTsKCiAgICAgICAgICBzICs9IHQ7CiAgICAgICAgICBwID0gaSArIDE7CiAgICAgICAgfSBlbHNlIGlmKGMgPT09IDM3KSB7CiAgICAgICAgICBzICs9IHNsaWNlKHgsIHAsIGkpOwogICAgICAgICAgcCA9IGkgKyAxOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgaWYocCAhPT0gMCkgewogICAgICBhKys7CiAgICAgIGogPSAnICc7CiAgICAgIGlmKHAgPCB4Lmxlbmd0aCkgcyArPSBzbGljZSh4LCBwKTsKICAgIH0KICB9CiAgd2hpbGUoYSA8IHYubGVuZ3RoKSB7CiAgICBjb25zdCB5ID0gdlthXTsKICAgIHMgKz0gajsKICAgIHMgKz0gdHlwZW9mIHkgIT09ICdzdHJpbmcnID8gaW5zcGVjdCh5LCBvKSA6IHk7CiAgICBqID0gJyAnOwogICAgYSsrOwogIH0KICByZXR1cm4gczsKfQoKZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7CiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSBleHBlY3RlZCA9IHRydWU7CgogIGlmKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHJldHVybjsKCiAgaWYoYWN0dWFsICE9PSBudWxsICYmIGV4cGVjdGVkICE9PSBudWxsICYmIHR5cGVvZiBhY3R1YWwgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkID09ICdvYmplY3QnICYmIGFjdHVhbC50b1N0cmluZygpID09PSBleHBlY3RlZC50b1N0cmluZygpKSByZXR1cm47CgogIHRocm93IEVycm9yKCdhc3NlcnRpb24gZmFpbGVkOiBnb3QgfCcgKyBhY3R1YWwgKyAnfCcgKyAnLCBleHBlY3RlZCB8JyArIGV4cGVjdGVkICsgJ3wnICsgKG1lc3NhZ2UgPyAnICgnICsgbWVzc2FnZSArICcpJyA6ICcnKSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiBzZXRJbnRlcnZhbChjYWxsYmFjaywgbXMpIHsKICBsZXQgbWFwID0gKHNldEludGVydmFsLm1hcCA/Pz0gbmV3IE1hcCgpKTsKICBsZXQgaWQgPSAoc2V0SW50ZXJ2YWwuaWQgPSAoc2V0SW50ZXJ2YWwuaWQgPz8gMCkgKyAxKTsKICBsZXQgb2JqID0geyBjYWxsYmFjaywgbXMgfTsKICBtYXAuc2V0KGlkLCBvYmopOwoKICBmdW5jdGlvbiBzdGFydCgpIHsKICAgIG9iai5pZCA9IG9zLnNldFRpbWVvdXQoKCkgPT4gewogICAgICBzdGFydCgpOwogICAgICBjYWxsYmFjaygpOwogICAgfSwgb2JqLm1zKTsKICB9CgogIHN0YXJ0KCk7CiAgcmV0dXJuIGlkOwp9CgpleHBvcnQgZnVuY3Rpb24gY2xlYXJJbnRlcnZhbChpZCkgewogIGxldCBtYXAgPSAoc2V0SW50ZXJ2YWwubWFwID8/PSBuZXcgTWFwKCkpOwoKICBsZXQgb2JqID0gbWFwLmdldChpZCk7CgogIGlmKG9iaikgb3MuY2xlYXJUaW1lb3V0KG9iai5pZCk7Cn0KCmV4cG9ydCBmdW5jdGlvbiBtZW1vaXplKGZuKSB7CiAgbGV0IGNhY2hlID0ge307CiAgcmV0dXJuIChuLCAuLi5yZXN0KSA9PiB7CiAgICBpZihuIGluIGNhY2hlKSByZXR1cm4gY2FjaGVbbl07CiAgICByZXR1cm4gKGNhY2hlW25dID0gZm4obiwgLi4ucmVzdCkpOwogIH07Cn0KCmV4cG9ydCBmdW5jdGlvbiBvbmNlKGZuLCB0aGlzQXJnLCBtZW1vRm4pIHsKICBsZXQgcmV0LAogICAgcmFuID0gZmFsc2U7CgogIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7CiAgICBpZighcmFuKSB7CiAgICAgIHJhbiA9IHRydWU7CiAgICAgIHJldCA9IGZuLmFwcGx5KHRoaXNBcmcgfHwgdGhpcywgYXJncyk7CiAgICB9IGVsc2UgaWYodHlwZW9mIG1lbW9GbiA9PSAnZnVuY3Rpb24nKSB7CiAgICAgIHJldCA9IG1lbW9GbihyZXQpOwogICAgfQogICAgcmV0dXJuIHJldDsKICB9Owp9CgpleHBvcnQgZnVuY3Rpb24gd2FpdEZvcihtcykgewogIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IG9zLnNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGRlZmluZShvYmosIC4uLmFyZ3MpIHsKICBmb3IobGV0IHByb3BzIG9mIGFyZ3MpIHsKICAgIGxldCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocHJvcHMpOwogICAgZm9yKGxldCBwcm9wIGluIGRlc2MpIHsKICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gZGVzY1twcm9wXTsKICAgICAgaWYodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIGRlc2NbcHJvcF0ud3JpdGFibGUgPSBmYWxzZTsKICAgIH0KICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwgZGVzYyk7CiAgfQogIHJldHVybiBvYmo7Cn0KCmV4cG9ydCBmdW5jdGlvbiB3ZWFrQXNzaWduKG9iaiwgLi4uYXJncykgewogIGxldCBkZXNjID0ge307CiAgZm9yKGxldCBvdGhlciBvZiBhcmdzKSB7CiAgICBsZXQgb3RoZXJEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3RoZXIpOwogICAgZm9yKGxldCBrZXkgaW4gb3RoZXJEZXNjKSBpZighKGtleSBpbiBvYmopICYmIGRlc2Nba2V5XSA9PT0gdW5kZWZpbmVkICYmIG90aGVyRGVzY1trZXldICE9PSB1bmRlZmluZWQpIGRlc2Nba2V5XSA9IG90aGVyRGVzY1trZXldOwogIH0KICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCBkZXNjKTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGdldENvbnN0cnVjdG9yQ2hhaW4ob2JqKSB7CiAgbGV0IHJldCA9IFtdOwogIGxldCBjaGFpbiA9IGdldFByb3RvdHlwZUNoYWluKG9iaik7CiAgaWYob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3RvciAhPSBjaGFpblswXS5jb25zdHJ1Y3RvcikgY2hhaW4udW5zaGlmdChvYmopOwogIGZvcihsZXQgcHJvdG8gb2YgY2hhaW4pIHJldC5wdXNoKHByb3RvLmNvbnN0cnVjdG9yKTsKICByZXR1cm4gcmV0Owp9CgpleHBvcnQgZnVuY3Rpb24gaGFzUHJvdG90eXBlKG9iaiwgcHJvdG8pIHsKICByZXR1cm4gZ2V0UHJvdG90eXBlQ2hhaW4ob2JqKS5pbmRleE9mKHByb3RvKSAhPSAtMTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcihzZXEsIHByZWQsIHRoaXNBcmcpIHsKICBpZihpc09iamVjdChwcmVkKSAmJiBwcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7CiAgICBsZXQgcmUgPSBwcmVkOwogICAgcHJlZCA9IChlbCwgaSkgPT4gcmUudGVzdChlbCk7CiAgfQogIGxldCByID0gW10sCiAgICBpID0gMDsKICBmb3IobGV0IGVsIG9mIHNlcSkgewogICAgaWYocHJlZC5jYWxsKHRoaXNBcmcsIGVsLCBpKyssIHNlcSkpIHIucHVzaChlbCk7CiAgfQogIHJldHVybiByOwp9Cgpjb25zdCBBTlNJX0JBQ0tHUk9VTkRfT0ZGU0VUID0gMTA7Cgpjb25zdCB3cmFwQW5zaTE2ID0KICAob2Zmc2V0ID0gMCkgPT4KICBjb2RlID0+CiAgICBgXHUwMDFCWyR7Y29kZSArIG9mZnNldH1tYDsKCmNvbnN0IHdyYXBBbnNpMjU2ID0KICAob2Zmc2V0ID0gMCkgPT4KICBjb2RlID0+CiAgICBgXHUwMDFCWyR7MzggKyBvZmZzZXR9OzU7JHtjb2RlfW1gOwoKY29uc3Qgd3JhcEFuc2kxNm0gPQogIChvZmZzZXQgPSAwKSA9PgogIChyZWQsIGdyZWVuLCBibHVlKSA9PgogICAgYFx1MDAxQlskezM4ICsgb2Zmc2V0fTsyOyR7cmVkfTske2dyZWVufTske2JsdWV9bWA7CgpmdW5jdGlvbiBnZXRBbnNpU3R5bGVzKCkgewogIGNvbnN0IGNvZGVzID0gbmV3IE1hcCgpOwogIGNvbnN0IHN0eWxlcyA9IHsKICAgIG1vZGlmaWVyOiB7CiAgICAgIHJlc2V0OiBbMCwgMF0sCiAgICAgIC8vIDIxIGlzbid0IHdpZGVseSBzdXBwb3J0ZWQgYW5kIDIyIGRvZXMgdGhlIHNhbWUgdGhpbmcKICAgICAgYm9sZDogWzEsIDIyXSwKICAgICAgZGltOiBbMiwgMjJdLAogICAgICBpdGFsaWM6IFszLCAyM10sCiAgICAgIHVuZGVybGluZTogWzQsIDI0XSwKICAgICAgb3ZlcmxpbmU6IFs1MywgNTVdLAogICAgICBpbnZlcnNlOiBbNywgMjddLAogICAgICBoaWRkZW46IFs4LCAyOF0sCiAgICAgIHN0cmlrZXRocm91Z2g6IFs5LCAyOV0KICAgIH0sCiAgICBjb2xvcjogewogICAgICBibGFjazogWzMwLCAzOV0sCiAgICAgIHJlZDogWzMxLCAzOV0sCiAgICAgIGdyZWVuOiBbMzIsIDM5XSwKICAgICAgeWVsbG93OiBbMzMsIDM5XSwKICAgICAgYmx1ZTogWzM0LCAzOV0sCiAgICAgIG1hZ2VudGE6IFszNSwgMzldLAogICAgICBjeWFuOiBbMzYsIDM5XSwKICAgICAgd2hpdGU6IFszNywgMzldLAoKICAgICAgLy8gQnJpZ2h0IGNvbG9yCiAgICAgIGJsYWNrQnJpZ2h0OiBbOTAsIDM5XSwKICAgICAgcmVkQnJpZ2h0OiBbOTEsIDM5XSwKICAgICAgZ3JlZW5CcmlnaHQ6IFs5MiwgMzldLAogICAgICB5ZWxsb3dCcmlnaHQ6IFs5MywgMzldLAogICAgICBibHVlQnJpZ2h0OiBbOTQsIDM5XSwKICAgICAgbWFnZW50YUJyaWdodDogWzk1LCAzOV0sCiAgICAgIGN5YW5CcmlnaHQ6IFs5NiwgMzldLAogICAgICB3aGl0ZUJyaWdodDogWzk3LCAzOV0KICAgIH0sCiAgICBiZ0NvbG9yOiB7CiAgICAgIGJnQmxhY2s6IFs0MCwgNDldLAogICAgICBiZ1JlZDogWzQxLCA0OV0sCiAgICAgIGJnR3JlZW46IFs0MiwgNDldLAogICAgICBiZ1llbGxvdzogWzQzLCA0OV0sCiAgICAgIGJnQmx1ZTogWzQ0LCA0OV0sCiAgICAgIGJnTWFnZW50YTogWzQ1LCA0OV0sCiAgICAgIGJnQ3lhbjogWzQ2LCA0OV0sCiAgICAgIGJnV2hpdGU6IFs0NywgNDldLAoKICAgICAgLy8gQnJpZ2h0IGNvbG9yCiAgICAgIGJnQmxhY2tCcmlnaHQ6IFsxMDAsIDQ5XSwKICAgICAgYmdSZWRCcmlnaHQ6IFsxMDEsIDQ5XSwKICAgICAgYmdHcmVlbkJyaWdodDogWzEwMiwgNDldLAogICAgICBiZ1llbGxvd0JyaWdodDogWzEwMywgNDldLAogICAgICBiZ0JsdWVCcmlnaHQ6IFsxMDQsIDQ5XSwKICAgICAgYmdNYWdlbnRhQnJpZ2h0OiBbMTA1LCA0OV0sCiAgICAgIGJnQ3lhbkJyaWdodDogWzEwNiwgNDldLAogICAgICBiZ1doaXRlQnJpZ2h0OiBbMTA3LCA0OV0KICAgIH0KICB9OwoKICAvLyBBbGlhcyBicmlnaHQgYmxhY2sgYXMgZ3JheSAoYW5kIGdyZXkpCiAgc3R5bGVzLmNvbG9yLmdyYXkgPSBzdHlsZXMuY29sb3IuYmxhY2tCcmlnaHQ7CiAgc3R5bGVzLmJnQ29sb3IuYmdHcmF5ID0gc3R5bGVzLmJnQ29sb3IuYmdCbGFja0JyaWdodDsKICBzdHlsZXMuY29sb3IuZ3JleSA9IHN0eWxlcy5jb2xvci5ibGFja0JyaWdodDsKICBzdHlsZXMuYmdDb2xvci5iZ0dyZXkgPSBzdHlsZXMuYmdDb2xvci5iZ0JsYWNrQnJpZ2h0OwoKICBmb3IoY29uc3QgW2dyb3VwTmFtZSwgZ3JvdXBdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlcykpIHsKICAgIGZvcihjb25zdCBbc3R5bGVOYW1lLCBzdHlsZV0gb2YgT2JqZWN0LmVudHJpZXMoZ3JvdXApKSB7CiAgICAgIHN0eWxlc1tzdHlsZU5hbWVdID0gewogICAgICAgIG9wZW46IGBcdTAwMUJbJHtzdHlsZVswXX1tYCwKICAgICAgICBjbG9zZTogYFx1MDAxQlske3N0eWxlWzFdfW1gCiAgICAgIH07CgogICAgICBncm91cFtzdHlsZU5hbWVdID0gc3R5bGVzW3N0eWxlTmFtZV07CgogICAgICBjb2Rlcy5zZXQoc3R5bGVbMF0sIHN0eWxlWzFdKTsKICAgIH0KCiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCBncm91cE5hbWUsIHsKICAgICAgdmFsdWU6IGdyb3VwLAogICAgICBlbnVtZXJhYmxlOiBmYWxzZQogICAgfSk7CiAgfQoKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCAnY29kZXMnLCB7CiAgICB2YWx1ZTogY29kZXMsCiAgICBlbnVtZXJhYmxlOiBmYWxzZQogIH0pOwoKICBzdHlsZXMuY29sb3IuY2xvc2UgPSAnXHUwMDFCWzM5bSc7CiAgc3R5bGVzLmJnQ29sb3IuY2xvc2UgPSAnXHUwMDFCWzQ5bSc7CgogIHN0eWxlcy5jb2xvci5hbnNpID0gd3JhcEFuc2kxNigpOwogIHN0eWxlcy5jb2xvci5hbnNpMjU2ID0gd3JhcEFuc2kyNTYoKTsKICBzdHlsZXMuY29sb3IuYW5zaTE2bSA9IHdyYXBBbnNpMTZtKCk7CiAgc3R5bGVzLmJnQ29sb3IuYW5zaSA9IHdyYXBBbnNpMTYoQU5TSV9CQUNLR1JPVU5EX09GRlNFVCk7CiAgc3R5bGVzLmJnQ29sb3IuYW5zaTI1NiA9IHdyYXBBbnNpMjU2KEFOU0lfQkFDS0dST1VORF9PRkZTRVQpOwogIHN0eWxlcy5iZ0NvbG9yLmFuc2kxNm0gPSB3cmFwQW5zaTE2bShBTlNJX0JBQ0tHUk9VTkRfT0ZGU0VUKTsKCiAgLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vUWl4LS9jb2xvci1jb252ZXJ0L2Jsb2IvM2YwZTBkNGU5MmUyMzU3OTZjY2IxN2Y2ZTg1YzcyMDk0YTY1MWY0OS9jb252ZXJzaW9ucy5qcwogIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHN0eWxlcywgewogICAgcmdiVG9BbnNpMjU2OiB7CiAgICAgIHZhbHVlOiAocmVkLCBncmVlbiwgYmx1ZSkgPT4gewogICAgICAgIC8vIFdlIHVzZSB0aGUgZXh0ZW5kZWQgZ3JleXNjYWxlIHBhbGV0dGUgaGVyZSwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mCiAgICAgICAgLy8gYmxhY2sgYW5kIHdoaXRlLiBub3JtYWwgcGFsZXR0ZSBvbmx5IGhhcyA0IGdyZXlzY2FsZSBzaGFkZXMuCiAgICAgICAgaWYocmVkID09PSBncmVlbiAmJiBncmVlbiA9PT0gYmx1ZSkgewogICAgICAgICAgaWYocmVkIDwgOCkgewogICAgICAgICAgICByZXR1cm4gMTY7CiAgICAgICAgICB9CgogICAgICAgICAgaWYocmVkID4gMjQ4KSB7CiAgICAgICAgICAgIHJldHVybiAyMzE7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKChyZWQgLSA4KSAvIDI0NykgKiAyNCkgKyAyMzI7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGMgPSBbcmVkLCBncmVlbiwgYmx1ZV0ubWFwKGMgPT4gKGMgLyAyNTUpICogNSk7CiAgICAgICAgcmV0dXJuIDE2ICsgMzYgKiBjWzBdICsgNiAqIGNbMV0gKyBjWzJdOwogICAgICB9LAogICAgICBlbnVtZXJhYmxlOiBmYWxzZQogICAgfSwKICAgIGhleFRvUmdiOiB7CiAgICAgIHZhbHVlOiBoZXggPT4gewogICAgICAgIGNvbnN0IG1hdGNoZXMgPSAvKD88Y29sb3JTdHJpbmc+W2EtZlxkXXs2fXxbYS1mXGRdezN9KS9pLmV4ZWMoaGV4LnRvU3RyaW5nKDE2KSk7CiAgICAgICAgaWYoIW1hdGNoZXMpIHsKICAgICAgICAgIHJldHVybiBbMCwgMCwgMF07CiAgICAgICAgfQoKICAgICAgICBsZXQgeyBjb2xvclN0cmluZyB9ID0gbWF0Y2hlcy5ncm91cHM7CgogICAgICAgIGlmKGNvbG9yU3RyaW5nLmxlbmd0aCA9PT0gMykgewogICAgICAgICAgY29sb3JTdHJpbmcgPSBjb2xvclN0cmluZwogICAgICAgICAgICAuc3BsaXQoJycpCiAgICAgICAgICAgIC5tYXAoY2hhcmFjdGVyID0+IGNoYXJhY3RlciArIGNoYXJhY3RlcikKICAgICAgICAgICAgLmpvaW4oJycpOwogICAgICAgIH0KCiAgICAgICAgY29uc3QgaW50ZWdlciA9IE51bWJlci5wYXJzZUludChjb2xvclN0cmluZywgMTYpOwoKICAgICAgICByZXR1cm4gWyhpbnRlZ2VyID4+IDE2KSAmIDB4ZmYsIChpbnRlZ2VyID4+IDgpICYgMHhmZiwgaW50ZWdlciAmIDB4ZmZdOwogICAgICB9LAogICAgICBlbnVtZXJhYmxlOiBmYWxzZQogICAgfSwKICAgIGhleFRvQW5zaTI1NjogewogICAgICB2YWx1ZTogaGV4ID0+IHN0eWxlcy5yZ2JUb0Fuc2kyNTYoLi4uc3R5bGVzLmhleFRvUmdiKGhleCkpLAogICAgICBlbnVtZXJhYmxlOiBmYWxzZQogICAgfSwKICAgIGFuc2kyNTZUb0Fuc2k6IHsKICAgICAgdmFsdWU6IGNvZGUgPT4gewogICAgICAgIGlmKGNvZGUgPCA4KSB7CiAgICAgICAgICByZXR1cm4gMzAgKyBjb2RlOwogICAgICAgIH0KCiAgICAgICAgaWYoY29kZSA8IDE2KSB7CiAgICAgICAgICByZXR1cm4gOTAgKyAoY29kZSAtIDgpOwogICAgICAgIH0KCiAgICAgICAgbGV0IHJlZDsKICAgICAgICBsZXQgZ3JlZW47CiAgICAgICAgbGV0IGJsdWU7CgogICAgICAgIGlmKGNvZGUgPj0gMjMyKSB7CiAgICAgICAgICByZWQgPSAoKGNvZGUgLSAyMzIpICogMTAgKyA4KSAvIDI1NTsKICAgICAgICAgIGdyZWVuID0gcmVkOwogICAgICAgICAgYmx1ZSA9IHJlZDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29kZSAtPSAxNjsKCiAgICAgICAgICBjb25zdCByZW1haW5kZXIgPSBjb2RlICUgMzY7CgogICAgICAgICAgcmVkID0gTWF0aC5mbG9vcihjb2RlIC8gMzYpICogMC4yOwogICAgICAgICAgZ3JlZW4gPSBNYXRoLmZsb29yKHJlbWFpbmRlciAvIDYpICogMC4yOwogICAgICAgICAgYmx1ZSA9IChyZW1haW5kZXIgJSA2KSAqIDAuMjsKICAgICAgICB9CgogICAgICAgIGNvbnN0IHZhbHVlID0gTWF0aC5tYXgocmVkLCBncmVlbiwgYmx1ZSkgKiAyOwoKICAgICAgICBpZih2YWx1ZSA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIDMwOwogICAgICAgIH0KCiAgICAgICAgbGV0IHJlc3VsdCA9IDMwICsgKChNYXRoLnJvdW5kKGJsdWUpIDw8IDIpIHwgKE1hdGgucm91bmQoZ3JlZW4pIDw8IDEpIHwgTWF0aC5yb3VuZChyZWQpKTsKCiAgICAgICAgaWYodmFsdWUgPT09IDIpIHsKICAgICAgICAgIHJlc3VsdCArPSA2MDsKICAgICAgICB9CgogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH0sCiAgICAgIGVudW1lcmFibGU6IGZhbHNlCiAgICB9LAogICAgcmdiVG9BbnNpOiB7CiAgICAgIHZhbHVlOiAocmVkLCBncmVlbiwgYmx1ZSkgPT4gc3R5bGVzLmFuc2kyNTZUb0Fuc2koc3R5bGVzLnJnYlRvQW5zaTI1NihyZWQsIGdyZWVuLCBibHVlKSksCiAgICAgIGVudW1lcmFibGU6IGZhbHNlCiAgICB9LAogICAgaGV4VG9BbnNpOiB7CiAgICAgIHZhbHVlOiBoZXggPT4gc3R5bGVzLmFuc2kyNTZUb0Fuc2koc3R5bGVzLmhleFRvQW5zaTI1NihoZXgpKSwKICAgICAgZW51bWVyYWJsZTogZmFsc2UKICAgIH0KICB9KTsKCiAgcmV0dXJuIHN0eWxlczsKfQoKZXhwb3J0IGZ1bmN0aW9uIHJhbmRJbnQoLi4uYXJncykgewogIGxldCByYW5nZSA9IGFyZ3Muc3BsaWNlKDAsIDIpOwogIGxldCBybmQgPSBhcmdzLnNoaWZ0KCk7CiAgaWYocmFuZ2UubGVuZ3RoIDwgMikgcmFuZ2UudW5zaGlmdCgwKTsKICByZXR1cm4gTWF0aC5yb3VuZChtaXNjLnJhbmQocmFuZ2VbMV0gLSByYW5nZVswXSArIDEpICsgcmFuZ2VbMF0pOwp9CgpleHBvcnQgY29uc3QgYW5zaVN0eWxlcyA9IGdldEFuc2lTdHlsZXMoKTsKCmNvbnN0IGluc3BlY3RNZXRob2QgPSBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpOwoKdXRpbC5pbnNwZWN0ID0gaW5zcGVjdDsKdXRpbC5mb3JtYXQgPSBmb3JtYXQ7CnV0aWwuZm9ybWF0V2l0aE9wdGlvbnMgPSBmb3JtYXRXaXRoT3B0aW9uczsKdXRpbC50eXBlcyA9IHR5cGVzOwp1dGlsLmFzc2VydCA9IGFzc2VydDsKdXRpbC5oYXNCdWlsdEluID0gaGFzQnVpbHRJbjsKdXRpbC50b1N0cmluZyA9IHRvU3RyaW5nOwp1dGlsLnRvQXJyYXlCdWZmZXIgPSB0b0FycmF5QnVmZmVyOwp1dGlsLnNldEludGVydmFsID0gc2V0SW50ZXJ2YWw7CnV0aWwuY2xlYXJJbnRlcnZhbCA9IGNsZWFySW50ZXJ2YWw7CnV0aWwubWVtb2l6ZSA9IG1lbW9pemU7CnV0aWwub25jZSA9IG9uY2U7CnV0aWwuZGVmaW5lID0gZGVmaW5lOwp1dGlsLndlYWtBc3NpZ24gPSB3ZWFrQXNzaWduOwp1dGlsLkFycmF5RXh0ZW5zaW9ucyA9IEFycmF5RXh0ZW5zaW9uczsKdXRpbC5leHRlbmRBcnJheSA9IChwcm90byA9IEFycmF5LnByb3RvdHlwZSwgZGVmID0gdXRpbC5kZWZpbmUpID0+IGRlZihwcm90bywgQXJyYXlFeHRlbnNpb25zKTsKdXRpbC5leHRlbmRHZW5lcmF0b3IgPSAocHJvdG8gPSBHZW5lcmF0b3JQcm90b3R5cGUsIGRlZiA9IHV0aWwuZGVmaW5lKSA9PiBkZWYocHJvdG8sIEdlbmVyYXRvckV4dGVuc2lvbnMpOwp1dGlsLmVycm9ycyA9IGVycm9yczsKdXRpbC5nZXRQcm90b3R5cGVDaGFpbiA9IGdldFByb3RvdHlwZUNoYWluOwp1dGlsLmdldENvbnN0cnVjdG9yQ2hhaW4gPSBnZXRDb25zdHJ1Y3RvckNoYWluOwp1dGlsLmhhc1Byb3RvdHlwZSA9IGhhc1Byb3RvdHlwZTsKdXRpbC5hbnNpU3R5bGVzID0gYW5zaVN0eWxlczsKdXRpbC5yYW5kSW50ID0gcmFuZEludDsKCk9iamVjdC5hc3NpZ24odXRpbCwgewogIFtpbnNwZWN0TWV0aG9kXSgpIHsKICAgIGxldCBvYmogPSB7IC4uLnV0aWwgfTsKICAgIGRlbGV0ZSBvYmpbaW5zcGVjdE1ldGhvZF07CiAgICByZXR1cm4gaW5zcGVjdChvYmosIHsgY3VzdG9tSW5zcGVjdDogZmFsc2UgfSk7CiAgfQp9KTsKCmV4cG9ydCB7IGV4dGVuZEFycmF5LCBBcnJheUV4dGVuc2lvbnMgfSBmcm9tICcuL2V4dGVuZEFycmF5LmpzJzsKZXhwb3J0IHsgU3lzY2FsbEVycm9yIH0gZnJvbSAnc3lzY2FsbGVycm9yJzsKZXhwb3J0IHsgYXJyYXlUb0JpdGZpZWxkLCBhdG9iLCBhdG9tVG9TdHJpbmcsIGF0b21Ub1ZhbHVlLCBiaXRmaWVsZFRvQXJyYXksIGJ0b2EsIGNvbXBpbGVTY3JpcHQsIGNvbmNhdEFycmF5QnVmZmVyLCBkdXBBcnJheUJ1ZmZlciwgZXZhbEJpbmFyeSwgZ2V0Qnl0ZUNvZGUsIGdldENsYXNzQXRvbSwgZ2V0Q2xhc3NDb25zdHJ1Y3RvciwgZ2V0Q2xhc3NDb3VudCwgZ2V0Q2xhc3NJRCwgZ2V0Q2xhc3NOYW1lLCBnZXRDbGFzc1Byb3RvLCBnZXRDb21tYW5kTGluZSwgZ2V0Q3VycmVudFdvcmtpbmdEaXJlY3RvcnksIGdldEV4ZWN1dGFibGUsIGdldEZpbGVEZXNjcmlwdG9yLCBnZXRPcENvZGVzLCBnZXRQZXJmb3JtYW5jZUNvdW50ZXIsIGdldFByb2NNYXBzLCBnZXRQcm9jTW91bnRzLCBnZXRQcm9jU3RhdCwgZ2V0UHJvdG90eXBlQ2hhaW4sIGdldFJvb3REaXJlY3RvcnksIGdldGVnaWQsIGdldGV1aWQsIGdldGdpZCwgZ2V0cGlkLCBnZXRwcGlkLCBnZXRzaWQsIGdldHVpZCwgaHJ0aW1lLCByZWFkT2JqZWN0LCByZXNpemVBcnJheUJ1ZmZlcixzZWFyY2hBcnJheUJ1ZmZlciwgc2V0ZWdpZCwgc2V0ZXVpZCwgc2V0Z2lkLCBzZXR1aWQsIHRvQXJyYXlCdWZmZXIsIHRvUG9pbnRlciwgdG9TdHJpbmcsIHVuYW1lLCB2YWx1ZVB0ciwgdmFsdWVUYWcsIHZhbHVlVG9BdG9tLCB2YWx1ZVR5cGUsIHdyaXRlT2JqZWN0IH0gZnJvbSAnbWlzYyc7CmV4cG9ydCB7IGluc3BlY3QgfSBmcm9tICdpbnNwZWN0JzsKAAAAAAAAAABVUQAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAACcUAAAAAAAAJxQAAAAAAAAAAAAAAAA8L8"
				],
				[
					69,
					1,
					"revert",
					null,
					"AwAAAAAAAAAAAAAAAAAAAAAAAABVUQAAaW1wb3J0IGluc3BlY3QgZnJvbSAnaW5zcGVjdCc7CmltcG9ydCB7IFN5c2NhbGxFcnJvciB9IGZyb20gJ3N5c2NhbGxlcnJvcic7CmltcG9ydCB7IGFycmF5VG9CaXRmaWVsZCwgYXRvYiwgYXRvbVRvU3RyaW5nLCBhdG9tVG9WYWx1ZSwgYml0ZmllbGRUb0FycmF5LCBidG9hLCBjb21waWxlU2NyaXB0LCBjb25jYXRBcnJheUJ1ZmZlciwgZHVwQXJyYXlCdWZmZXIsIGV2YWxCaW5hcnksIGdldEJ5dGVDb2RlLCBnZXRDbGFzc0F0b20sIGdldENsYXNzQ29uc3RydWN0b3IsIGdldENsYXNzQ291bnQsIGdldENsYXNzSUQsIGdldENsYXNzTmFtZSwgZ2V0Q2xhc3NQcm90bywgZ2V0Q29tbWFuZExpbmUsIGdldEN1cnJlbnRXb3JraW5nRGlyZWN0b3J5LCBnZXRFeGVjdXRhYmxlLCBnZXRGaWxlRGVzY3JpcHRvciwgZ2V0T3BDb2RlcywgZ2V0UGVyZm9ybWFuY2VDb3VudGVyLCBnZXRQcm9jTWFwcywgZ2V0UHJvY01vdW50cywgZ2V0UHJvY1N0YXQsIGdldFByb3RvdHlwZUNoYWluLCBnZXRSb290RGlyZWN0b3J5LCBnZXRlZ2lkLCBnZXRldWlkLCBnZXRnaWQsIGdldHBpZCwgZ2V0cHBpZCwgZ2V0c2lkLCBnZXR1aWQsIGhydGltZSwgcmVhZE9iamVjdCwgcmVzaXplQXJyYXlCdWZmZXIsIHNldGVnaWQsIHNldGV1aWQsIHNldGdpZCwgc2V0dWlkLCB0b0FycmF5QnVmZmVyLCB0b1BvaW50ZXIsIHRvU3RyaW5nLCB1bmFtZSwgdmFsdWVQdHIsIHZhbHVlVGFnLCB2YWx1ZVRvQXRvbSwgdmFsdWVUeXBlLCB3cml0ZU9iamVjdCwgcmFuZCwgcmFuZGksIHJhbmRmLCBzcmFuZCB9IGZyb20gJ21pc2MnOwppbXBvcnQgeyBleHRlbmRBcnJheSwgQXJyYXlFeHRlbnNpb25zIH0gZnJvbSAnLi9leHRlbmRBcnJheS5qcyc7CmltcG9ydCB7IGV4dGVuZEdlbmVyYXRvciwgR2VuZXJhdG9yRXh0ZW5zaW9ucywgR2VuZXJhdG9yUHJvdG90eXBlLCBHZW5lcmF0b3JDb25zdHJ1Y3RvciB9IGZyb20gJy4vZXh0ZW5kR2VuZXJhdG9yLmpzJzsKaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnOwoKY29uc3Qgc2xpY2UgPSAoeCwgcywgZSkgPT4gU3RyaW5nLnByb3RvdHlwZS5zbGljZS5jYWxsKHgsIHMsIGUpOwpjb25zdCBzdHJpbmdpZnkgPSB2ID0+IGAke3Z9YDsKY29uc3QgcHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsKY29uc3QgZm9ybWF0TnVtYmVyID0gbiA9PiAobiA9PT0gLTAgPyAnLTAnIDogYCR7bn1gKTsKY29uc3QgaXNOYXRpdmUgPSBmbiA9PiAvXFtuYXRpdmVcc2NvZGVcXS8udGVzdChzdHJpbmdpZnkoZm4pKTsKCmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHV0aWwoKSB7CiAgcmV0dXJuIHV0aWw7Cn0KCnV0aWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdXRpbDsKCmNvbnN0IEFzeW5jRnVuY3Rpb24gPSBhc3luYyBmdW5jdGlvbiB4KCkge30uY29uc3RydWN0b3I7CmNvbnN0IEdlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24qICgpIHt9LmNvbnN0cnVjdG9yOwpjb25zdCBBc3luY0dlbmVyYXRvckZ1bmN0aW9uID0gYXN5bmMgZnVuY3Rpb24qICgpIHt9LmNvbnN0cnVjdG9yOwpjb25zdCBUeXBlZEFycmF5ID0gcHJvdG9PZihwcm90b09mKG5ldyBVaW50MTZBcnJheSgxMCkpKS5jb25zdHJ1Y3RvcjsKCmNvbnN0IFNldEl0ZXJhdG9yUHJvdG90eXBlID0gcHJvdG9PZihuZXcgU2V0KCkudmFsdWVzKCkpOwpjb25zdCBNYXBJdGVyYXRvclByb3RvdHlwZSA9IHByb3RvT2YobmV3IE1hcCgpLmVudHJpZXMoKSk7CmNvbnN0IEdlbmVyYXRvclByb3RvdHlwZSA9IHByb3RvT2YoKGZ1bmN0aW9uKiAoKSB7fSkoKSk7CgpleHBvcnQgY29uc3QgZXJyb3JzID0gWwogIG51bGwsCiAgJ0VQRVJNJywKICAnRU5PRU5UJywKICAnRVNSQ0gnLAogICdFSU5UUicsCiAgJ0VJTycsCiAgJ0VOWElPJywKICAnRTJCSUcnLAogICdFTk9FWEVDJywKICAnRUJBREYnLAogICdFQ0hJTEQnLAogICdFQUdBSU4nLAogICdFTk9NRU0nLAogICdFQUNDRVMnLAogICdFRkFVTFQnLAogICdFTk9UQkxLJywKICAnRUJVU1knLAogICdFRVhJU1QnLAogICdFWERFVicsCiAgJ0VOT0RFVicsCiAgJ0VOT1RESVInLAogICdFSVNESVInLAogICdFSU5WQUwnLAogICdFTkZJTEUnLAogICdFTUZJTEUnLAogICdFTk9UVFknLAogICdFVFhUQlNZJywKICAnRUZCSUcnLAogICdFTk9TUEMnLAogICdFU1BJUEUnLAogICdFUk9GUycsCiAgJ0VNTElOSycsCiAgJ0VQSVBFJywKICAnRURPTScsCiAgJ0VSQU5HRScsCiAgJ0VERUFETEsnLAogICdFTkFNRVRPT0xPTkcnLAogICdFTk9MQ0snLAogICdFTk9TWVMnLAogICdFTk9URU1QVFknLAogIG51bGwsCiAgbnVsbCwKICAnRU5PTVNHJywKICAnRUlEUk0nLAogICdFQ0hSTkcnLAogICdFTDJOU1lOQycsCiAgJ0VMM0hMVCcsCiAgJ0VMM1JTVCcsCiAgJ0VMTlJORycsCiAgJ0VVTkFUQ0gnLAogICdFTk9DU0knLAogICdFTDJITFQnLAogICdFQkFERScsCiAgJ0VCQURSJywKICAnRVhGVUxMJywKICAnRU5PQU5PJywKICAnRUJBRFJRQycsCiAgbnVsbCwKICAnJywKICAnRUJGT05UJywKICAnRU5PU1RSJywKICAnRU5PREFUQScsCiAgJ0VUSU1FJywKICAnRU5PU1InLAogICdFTk9ORVQnLAogICdFTk9QS0cnLAogICdFUkVNT1RFJywKICAnRU5PTElOSycsCiAgJ0VBRFYnLAogICdFU1JNTlQnLAogICdFQ09NTScsCiAgJ0VQUk9UTycsCiAgJ0VNVUxUSUhPUCcsCiAgJ0VET1RET1QnLAogICdFQkFETVNHJywKICAnRU9WRVJGTE9XJywKICAnRU5PVFVOSVEnLAogICdFQkFERkQnLAogICdFUkVNQ0hHJywKICAnRUxJQkFDQycsCiAgJ0VMSUJCQUQnLAogICdFTElCU0NOJywKICAnRUxJQk1BWCcsCiAgJ0VMSUJFWEVDJywKICAnRUlMU0VRJywKICAnRVJFU1RBUlQnLAogICdFU1RSUElQRScsCiAgJ0VVU0VSUycsCiAgJ0VOT1RTT0NLJywKICAnRURFU1RBRERSUkVRJywKICAnRU1TR1NJWkUnLAogICdFUFJPVE9UWVBFJywKICAnRU5PUFJPVE9PUFQnLAogICdFUFJPVE9OT1NVUFBPUlQnLAogICdFU09DS1ROT1NVUFBPUlQnLAogICdFT1BOT1RTVVBQJywKICAnRVBGTk9TVVBQT1JUJywKICAnRUFGTk9TVVBQT1JUJywKICAnRUFERFJJTlVTRScsCiAgJ0VBRERSTk9UQVZBSUwnLAogICdFTkVURE9XTicsCiAgJ0VORVRVTlJFQUNIJywKICAnRU5FVFJFU0VUJywKICAnRUNPTk5BQk9SVEVEJywKICAnRUNPTk5SRVNFVCcsCiAgJ0VOT0JVRlMnLAogICdFSVNDT05OJywKICAnRU5PVENPTk4nLAogICdFU0hVVERPV04nLAogICdFVE9PTUFOWVJFRlMnLAogICdFVElNRURPVVQnLAogICdFQ09OTlJFRlVTRUQnLAogICdFSE9TVERPV04nLAogICdFSE9TVFVOUkVBQ0gnLAogICdFQUxSRUFEWScsCiAgJ0VJTlBST0dSRVNTJywKICAnRVNUQUxFJywKICAnRVVDTEVBTicsCiAgJ0VOT1ROQU0nLAogICdFTkFWQUlMJywKICAnRUlTTkFNJywKICAnRVJFTU9URUlPJywKICAnRURRVU9UJywKICAnRU5PTUVESVVNJywKICAnRU1FRElVTVRZUEUnLAogICdFQ0FOQ0VMRUQnLAogICdFTk9LRVknLAogICdFS0VZRVhQSVJFRCcsCiAgJ0VLRVlSRVZPS0VEJywKICAnRUtFWVJFSkVDVEVEJywKICAnRU9XTkVSREVBRCcsCiAgJ0VOT1RSRUNPVkVSQUJMRScsCiAgJ0VSRktJTEwnCl07CgpleHBvcnQgY29uc3QgdHlwZXMgPSB7CiAgaXNBbnlBcnJheUJ1ZmZlcih2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgKHYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCB2IGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpOwogIH0sCiAgaXNBcnJheUJ1ZmZlcih2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyOwogIH0sCiAgaXNCaWdJbnQ2NEFycmF5KHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgQmlnSW50NjRBcnJheTsKICB9LAogIGlzQmlnVWludDY0QXJyYXkodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBCaWdVaW50NjRBcnJheTsKICB9LAogIGlzRGF0ZSh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIERhdGU7CiAgfSwKICBpc0Zsb2F0MzJBcnJheSh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheTsKICB9LAogIGlzRmxvYXQ2NEFycmF5KHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5OwogIH0sCiAgaXNJbnQ4QXJyYXkodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBJbnQ4QXJyYXk7CiAgfSwKICBpc0ludDE2QXJyYXkodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBJbnQxNkFycmF5OwogIH0sCiAgaXNJbnQzMkFycmF5KHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgSW50MzJBcnJheTsKICB9LAogIGlzTWFwKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgTWFwOwogIH0sCiAgaXNQcm9taXNlKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgUHJvbWlzZTsKICB9LAogIGlzUHJveHkodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBQcm94eTsKICB9LAogIGlzUmVnRXhwKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgUmVnRXhwOwogIH0sCiAgaXNTZXQodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBTZXQ7CiAgfSwKICBpc1NoYXJlZEFycmF5QnVmZmVyKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXI7CiAgfSwKICBpc1VpbnQ4QXJyYXkodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBVaW50OEFycmF5OwogIH0sCiAgaXNVaW50OENsYW1wZWRBcnJheSh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5OwogIH0sCiAgaXNVaW50MTZBcnJheSh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIFVpbnQxNkFycmF5OwogIH0sCiAgaXNVaW50MzJBcnJheSh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIFVpbnQzMkFycmF5OwogIH0sCiAgaXNXZWFrTWFwKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgV2Vha01hcDsKICB9LAogIGlzV2Vha1NldCh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIFdlYWtTZXQ7CiAgfSwKICBpc0RhdGFWaWV3KHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgRGF0YVZpZXc7CiAgfSwKICBpc0Jvb2xlYW5PYmplY3QodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBCb29sZWFuOwogIH0sCiAgaXNBc3luY0Z1bmN0aW9uKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgQXN5bmNGdW5jdGlvbjsKICB9LAogIGlzR2VuZXJhdG9yRnVuY3Rpb24odikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBHZW5lcmF0b3JGdW5jdGlvbjsKICB9LAogIGlzQXN5bmNHZW5lcmF0b3JGdW5jdGlvbih2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIEFzeW5jR2VuZXJhdG9yRnVuY3Rpb247CiAgfSwKICBpc051bWJlck9iamVjdCh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIE51bWJlcjsKICB9LAogIGlzQmlnSW50T2JqZWN0KHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgQmlnSW50OwogIH0sCiAgaXNTeW1ib2xPYmplY3QodikgewogICAgcmV0dXJuIHYgJiYgdiBpbnN0YW5jZW9mIFN5bWJvbDsKICB9LAogIGlzTmF0aXZlRXJyb3IodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBFcnJvciAmJiBpc05hdGl2ZSh2LmNvbnN0cnVjdG9yKTsKICB9LAogIGlzTWFwSXRlcmF0b3IodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHByb3RvT2YodikgPT0gTWFwSXRlcmF0b3JQcm90b3R5cGU7CiAgfSwKICBpc1NldEl0ZXJhdG9yKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiBwcm90b09mKHYpID09IFNldEl0ZXJhdG9yUHJvdG90eXBlOwogIH0sCiAgaXNTdHJpbmdPYmplY3QodikgewogICAgcmV0dXJuIGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBTdHJpbmc7CiAgfSwKICBpc0FycmF5QnVmZmVyVmlldyh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KHYpOwogIH0sCiAgaXNBcmd1bWVudHNPYmplY3QodikgewogICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJzsKICB9LAoKICAvKiBpc0V4dGVybmFsKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgRXh0ZXJuYWw7CiAgfSwqLwoKICBpc0JveGVkUHJpbWl0aXZlKHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiBbTnVtYmVyLCBTdHJpbmcsIEJvb2xlYW4sIEJpZ0ludCwgU3ltYm9sXS5zb21lKGN0b3IgPT4gdiBpbnN0YW5jZW9mIGN0b3IpOwogIH0sCgogIGlzR2VuZXJhdG9yT2JqZWN0KHYpIHsKICAgIHJldHVybiBpc09iamVjdCh2KSAmJiBwcm90b09mKHYpID09IEdlbmVyYXRvclByb3RvdHlwZTsKICB9LAogIGlzVHlwZWRBcnJheSh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdiBpbnN0YW5jZW9mIFR5cGVkQXJyYXk7CiAgfSwKICBpc01vZHVsZU5hbWVzcGFjZU9iamVjdCh2KSB7CiAgICByZXR1cm4gaXNPYmplY3QodikgJiYgdltTeW1ib2wudG9TdHJpbmdUYWddID09ICdNb2R1bGUnOwogIH0KfTsKCmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2KSB7CiAgcmV0dXJuIHYgIT0gbnVsbCAmJiB7IGZ1bmN0aW9uOiB0cnVlLCBvYmplY3Q6IHRydWUgfVt0eXBlb2Ygdl07Cn0KCmV4cG9ydCBmdW5jdGlvbiBoYXNCdWlsdEluKG8sIG0pIHsKICByZXR1cm4gaXNOYXRpdmUocHJvdG9PZihvKVttXSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoLi4uYXJncykgewogIHJldHVybiBmb3JtYXRXaXRoT3B0aW9uc0ludGVybmFsKHsgaGlkZUtleXM6IFsnY29uc3RydWN0b3InXSB9LCBhcmdzKTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdpdGhPcHRpb25zKG9wdHMsIC4uLmFyZ3MpIHsKICBpZighaXNPYmplY3Qob3B0cykpIHRocm93IG5ldyBUeXBlRXJyb3IoYG9wdGlvbnMgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdGApOwogIHJldHVybiBmb3JtYXRXaXRoT3B0aW9uc0ludGVybmFsKG9wdHMsIGFyZ3MpOwp9CgpmdW5jdGlvbiBmb3JtYXRXaXRoT3B0aW9uc0ludGVybmFsKG8sIHYpIHsKICBjb25zdCB4ID0gdlswXTsKICBsZXQgYSA9IDA7CiAgbGV0IHMgPSAnJzsKICBsZXQgaiA9ICcnOwogIGlmKHR5cGVvZiB4ID09PSAnc3RyaW5nJykgewogICAgaWYodi5sZW5ndGggPT09IDEpIHJldHVybiB4OwogICAgbGV0IHQ7CiAgICBsZXQgcCA9IDA7CiAgICBmb3IobGV0IGkgPSAwOyBpIDwgeC5sZW5ndGggLSAxOyBpKyspIHsKICAgICAgaWYoeFtpXSA9PSAnJScpIHsKICAgICAgICBsZXQgZiA9ICcnOwogICAgICAgIHdoaWxlKCdzanhkT29pZmMlJy5pbmRleE9mKHhbaSArIDFdKSA9PSAtMSkgewogICAgICAgICAgZiArPSB4W2kgKyAxXTsKICAgICAgICAgICsraTsKICAgICAgICB9CiAgICAgICAgLy9jb25zb2xlLmxvZygncCcsIHAsIGAnJHtzbGljZSh4LCBwLCBpKX0nYCk7CiAgICAgICAgaWYocCA8IGkpIHMgKz0gc2xpY2UoeCwgcCwgaSk7CiAgICAgICAgcCA9IGkgKyAxOwogICAgICAgIC8vY29uc29sZS5sb2coJ2knLCBpKTsKICAgICAgICBjb25zdCBjID0gU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0LmNhbGwoeCwgKytpKTsKICAgICAgICAvL2NvbnNvbGUubG9nKCdzJywgYCcke3N9J2ApOwogICAgICAgIC8vY29uc29sZS5sb2coJ2MnLCBjLCB4W2ldKTsKICAgICAgICBpZihhICsgMSAhPT0gdi5sZW5ndGgpIHsKICAgICAgICAgIHN3aXRjaCAoYykgewogICAgICAgICAgICBjYXNlIDExNTogLy8gJXMKICAgICAgICAgICAgICBjb25zdCB5ID0gdlsrK2FdOwogICAgICAgICAgICAgIGlmKHR5cGVvZiB5ID09PSAnbnVtYmVyJykgdCA9IGZvcm1hdE51bWJlcih5KTsKICAgICAgICAgICAgICBlbHNlIGlmKHR5cGVvZiB5ID09PSAnYmlnaW50JykgdCA9IGAke3l9bmA7CiAgICAgICAgICAgICAgZWxzZSBpZih0eXBlb2YgeSAhPT0gJ29iamVjdCcgfHwgeSA9PT0gbnVsbCB8fCAhaGFzQnVpbHRJbih5LCAndG9TdHJpbmcnKSkgdCA9IFN0cmluZyh5KTsKICAgICAgICAgICAgICBlbHNlIHQgPSBpbnNwZWN0KHksIHsgLi4ubywgY29tcGFjdDogMywgY29sb3JzOiBmYWxzZSwgZGVwdGg6IDAgfSk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMTA2OiAvLyAlagogICAgICAgICAgICAgIHQgPSBzdHJpbmdpZnkodlsrK2FdKTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAxMjA6IC8vICV4CiAgICAgICAgICAgIGNhc2UgMTAwOiAvLyAlZAogICAgICAgICAgICAgIGNvbnN0IG4gPSB2WysrYV07CiAgICAgICAgICAgICAgaWYodHlwZW9mIG4gPT09ICdiaWdpbnQnKSB0ID0gYCR7bn1uYDsKICAgICAgICAgICAgICBlbHNlIGlmKHR5cGVvZiBuID09PSAnc3ltYm9sJykgdCA9ICdOYU4nOwogICAgICAgICAgICAgIGVsc2UgdCA9IGZvcm1hdE51bWJlcihjID09IDEyMCA/IE51bWJlcihuKS50b1N0cmluZygxNikgOiBOdW1iZXIobikpOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDc5OiAvLyAlTwogICAgICAgICAgICAgIHQgPSBpbnNwZWN0KHZbKythXSwgbyk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMTExOiAvLyAlbwogICAgICAgICAgICAgIHQgPSAvKnZbKythXSsnJyA/PyAqLyBpbnNwZWN0KHZbKythXSwgewogICAgICAgICAgICAgICAgLi4ubywKICAgICAgICAgICAgICAgIHNob3dIaWRkZW46IHRydWUsCiAgICAgICAgICAgICAgICBzaG93UHJveHk6IHRydWUsCiAgICAgICAgICAgICAgICBkZXB0aDogMSwKICAgICAgICAgICAgICAgIHByb3RvQ2hhaW46IGZhbHNlCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMTA1OiAvLyAlaQogICAgICAgICAgICAgIGNvbnN0IGsgPSB2WysrYV07CiAgICAgICAgICAgICAgaWYodHlwZW9mIGsgPT09ICdiaWdpbnQnKSB0ID0gYCR7a31gOwogICAgICAgICAgICAgIGVsc2UgaWYodHlwZW9mIGsgPT09ICdzeW1ib2wnKSB0ID0gJ05hTic7CiAgICAgICAgICAgICAgZWxzZSB0ID0gZm9ybWF0TnVtYmVyKHBhcnNlSW50KGspKTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAxMDI6IC8vICVmCiAgICAgICAgICAgICAgY29uc3QgZCA9IHZbKythXTsKICAgICAgICAgICAgICBpZih0eXBlb2YgZCA9PT0gJ3N5bWJvbCcpIHQgPSAnTmFOJzsKICAgICAgICAgICAgICBlbHNlIHQgPSBmb3JtYXROdW1iZXIocGFyc2VGbG9hdChkKSk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgOTk6IC8vICVjCiAgICAgICAgICAgICAgYSArPSAxOwogICAgICAgICAgICAgIHQgPSAnJzsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAzNzogLy8gJSUKICAgICAgICAgICAgICBzICs9IHNsaWNlKHgsIHAsIGkpOwogICAgICAgICAgICAgIHAgPSBpICsgMTsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmKHAgIT09IGkgLSAxKSBzICs9IHNsaWNlKHgsIHAsIGkgLSAxKTsKICAgICAgICAgIGxldCBwYWQgPSBwYXJzZUludChmKTsKCiAgICAgICAgICBpZihNYXRoLmFicyhwYWQpID4gMCkgdCA9IHRbJ3BhZCcgKyAocGFkIDwgMCA/ICdFbmQnIDogJ1N0YXJ0JyldKE1hdGguYWJzKHBhZCksIC9eLT8wLy50ZXN0KGYpID8gJzAnIDogJyAnKTsKCiAgICAgICAgICBzICs9IHQ7CiAgICAgICAgICBwID0gaSArIDE7CiAgICAgICAgfSBlbHNlIGlmKGMgPT09IDM3KSB7CiAgICAgICAgICBzICs9IHNsaWNlKHgsIHAsIGkpOwogICAgICAgICAgcCA9IGkgKyAxOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgaWYocCAhPT0gMCkgewogICAgICBhKys7CiAgICAgIGogPSAnICc7CiAgICAgIGlmKHAgPCB4Lmxlbmd0aCkgcyArPSBzbGljZSh4LCBwKTsKICAgIH0KICB9CiAgd2hpbGUoYSA8IHYubGVuZ3RoKSB7CiAgICBjb25zdCB5ID0gdlthXTsKICAgIHMgKz0gajsKICAgIHMgKz0gdHlwZW9mIHkgIT09ICdzdHJpbmcnID8gaW5zcGVjdCh5LCBvKSA6IHk7CiAgICBqID0gJyAnOwogICAgYSsrOwogIH0KICByZXR1cm4gczsKfQoKZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7CiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSBleHBlY3RlZCA9IHRydWU7CgogIGlmKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHJldHVybjsKCiAgaWYoYWN0dWFsICE9PSBudWxsICYmIGV4cGVjdGVkICE9PSBudWxsICYmIHR5cGVvZiBhY3R1YWwgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkID09ICdvYmplY3QnICYmIGFjdHVhbC50b1N0cmluZygpID09PSBleHBlY3RlZC50b1N0cmluZygpKSByZXR1cm47CgogIHRocm93IEVycm9yKCdhc3NlcnRpb24gZmFpbGVkOiBnb3QgfCcgKyBhY3R1YWwgKyAnfCcgKyAnLCBleHBlY3RlZCB8JyArIGV4cGVjdGVkICsgJ3wnICsgKG1lc3NhZ2UgPyAnICgnICsgbWVzc2FnZSArICcpJyA6ICcnKSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiBzZXRJbnRlcnZhbChjYWxsYmFjaywgbXMpIHsKICBsZXQgbWFwID0gKHNldEludGVydmFsLm1hcCA/Pz0gbmV3IE1hcCgpKTsKICBsZXQgaWQgPSAoc2V0SW50ZXJ2YWwuaWQgPSAoc2V0SW50ZXJ2YWwuaWQgPz8gMCkgKyAxKTsKICBsZXQgb2JqID0geyBjYWxsYmFjaywgbXMgfTsKICBtYXAuc2V0KGlkLCBvYmopOwoKICBmdW5jdGlvbiBzdGFydCgpIHsKICAgIG9iai5pZCA9IG9zLnNldFRpbWVvdXQoKCkgPT4gewogICAgICBzdGFydCgpOwogICAgICBjYWxsYmFjaygpOwogICAgfSwgb2JqLm1zKTsKICB9CgogIHN0YXJ0KCk7CiAgcmV0dXJuIGlkOwp9CgpleHBvcnQgZnVuY3Rpb24gY2xlYXJJbnRlcnZhbChpZCkgewogIGxldCBtYXAgPSAoc2V0SW50ZXJ2YWwubWFwID8/PSBuZXcgTWFwKCkpOwoKICBsZXQgb2JqID0gbWFwLmdldChpZCk7CgogIGlmKG9iaikgb3MuY2xlYXJUaW1lb3V0KG9iai5pZCk7Cn0KCmV4cG9ydCBmdW5jdGlvbiBtZW1vaXplKGZuKSB7CiAgbGV0IGNhY2hlID0ge307CiAgcmV0dXJuIChuLCAuLi5yZXN0KSA9PiB7CiAgICBpZihuIGluIGNhY2hlKSByZXR1cm4gY2FjaGVbbl07CiAgICByZXR1cm4gKGNhY2hlW25dID0gZm4obiwgLi4ucmVzdCkpOwogIH07Cn0KCmV4cG9ydCBmdW5jdGlvbiBvbmNlKGZuLCB0aGlzQXJnLCBtZW1vRm4pIHsKICBsZXQgcmV0LAogICAgcmFuID0gZmFsc2U7CgogIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7CiAgICBpZighcmFuKSB7CiAgICAgIHJhbiA9IHRydWU7CiAgICAgIHJldCA9IGZuLmFwcGx5KHRoaXNBcmcgfHwgdGhpcywgYXJncyk7CiAgICB9IGVsc2UgaWYodHlwZW9mIG1lbW9GbiA9PSAnZnVuY3Rpb24nKSB7CiAgICAgIHJldCA9IG1lbW9GbihyZXQpOwogICAgfQogICAgcmV0dXJuIHJldDsKICB9Owp9CgpleHBvcnQgZnVuY3Rpb24gd2FpdEZvcihtcykgewogIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IG9zLnNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGRlZmluZShvYmosIC4uLmFyZ3MpIHsKICBmb3IobGV0IHByb3BzIG9mIGFyZ3MpIHsKICAgIGxldCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocHJvcHMpOwogICAgZm9yKGxldCBwcm9wIGluIGRlc2MpIHsKICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gZGVzY1twcm9wXTsKICAgICAgaWYodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIGRlc2NbcHJvcF0ud3JpdGFibGUgPSBmYWxzZTsKICAgIH0KICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwgZGVzYyk7CiAgfQogIHJldHVybiBvYmo7Cn0KCmV4cG9ydCBmdW5jdGlvbiB3ZWFrQXNzaWduKG9iaiwgLi4uYXJncykgewogIGxldCBkZXNjID0ge307CiAgZm9yKGxldCBvdGhlciBvZiBhcmdzKSB7CiAgICBsZXQgb3RoZXJEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3RoZXIpOwogICAgZm9yKGxldCBrZXkgaW4gb3RoZXJEZXNjKSBpZighKGtleSBpbiBvYmopICYmIGRlc2Nba2V5XSA9PT0gdW5kZWZpbmVkICYmIG90aGVyRGVzY1trZXldICE9PSB1bmRlZmluZWQpIGRlc2Nba2V5XSA9IG90aGVyRGVzY1trZXldOwogIH0KICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCBkZXNjKTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGdldENvbnN0cnVjdG9yQ2hhaW4ob2JqKSB7CiAgbGV0IHJldCA9IFtdOwogIGxldCBjaGFpbiA9IGdldFByb3RvdHlwZUNoYWluKG9iaik7CiAgaWYob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3RvciAhPSBjaGFpblswXS5jb25zdHJ1Y3RvcikgY2hhaW4udW5zaGlmdChvYmopOwogIGZvcihsZXQgcHJvdG8gb2YgY2hhaW4pIHJldC5wdXNoKHByb3RvLmNvbnN0cnVjdG9yKTsKICByZXR1cm4gcmV0Owp9CgpleHBvcnQgZnVuY3Rpb24gaGFzUHJvdG90eXBlKG9iaiwgcHJvdG8pIHsKICByZXR1cm4gZ2V0UHJvdG90eXBlQ2hhaW4ob2JqKS5pbmRleE9mKHByb3RvKSAhPSAtMTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcihzZXEsIHByZWQsIHRoaXNBcmcpIHsKICBpZihpc09iamVjdChwcmVkKSAmJiBwcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7CiAgICBsZXQgcmUgPSBwcmVkOwogICAgcHJlZCA9IChlbCwgaSkgPT4gcmUudGVzdChlbCk7CiAgfQogIGxldCByID0gW10sCiAgICBpID0gMDsKICBmb3IobGV0IGVsIG9mIHNlcSkgewogICAgaWYocHJlZC5jYWxsKHRoaXNBcmcsIGVsLCBpKyssIHNlcSkpIHIucHVzaChlbCk7CiAgfQogIHJldHVybiByOwp9Cgpjb25zdCBBTlNJX0JBQ0tHUk9VTkRfT0ZGU0VUID0gMTA7Cgpjb25zdCB3cmFwQW5zaTE2ID0KICAob2Zmc2V0ID0gMCkgPT4KICBjb2RlID0+CiAgICBgXHUwMDFCWyR7Y29kZSArIG9mZnNldH1tYDsKCmNvbnN0IHdyYXBBbnNpMjU2ID0KICAob2Zmc2V0ID0gMCkgPT4KICBjb2RlID0+CiAgICBgXHUwMDFCWyR7MzggKyBvZmZzZXR9OzU7JHtjb2RlfW1gOwoKY29uc3Qgd3JhcEFuc2kxNm0gPQogIChvZmZzZXQgPSAwKSA9PgogIChyZWQsIGdyZWVuLCBibHVlKSA9PgogICAgYFx1MDAxQlskezM4ICsgb2Zmc2V0fTsyOyR7cmVkfTske2dyZWVufTske2JsdWV9bWA7CgpmdW5jdGlvbiBnZXRBbnNpU3R5bGVzKCkgewogIGNvbnN0IGNvZGVzID0gbmV3IE1hcCgpOwogIGNvbnN0IHN0eWxlcyA9IHsKICAgIG1vZGlmaWVyOiB7CiAgICAgIHJlc2V0OiBbMCwgMF0sCiAgICAgIC8vIDIxIGlzbid0IHdpZGVseSBzdXBwb3J0ZWQgYW5kIDIyIGRvZXMgdGhlIHNhbWUgdGhpbmcKICAgICAgYm9sZDogWzEsIDIyXSwKICAgICAgZGltOiBbMiwgMjJdLAogICAgICBpdGFsaWM6IFszLCAyM10sCiAgICAgIHVuZGVybGluZTogWzQsIDI0XSwKICAgICAgb3ZlcmxpbmU6IFs1MywgNTVdLAogICAgICBpbnZlcnNlOiBbNywgMjddLAogICAgICBoaWRkZW46IFs4LCAyOF0sCiAgICAgIHN0cmlrZXRocm91Z2g6IFs5LCAyOV0KICAgIH0sCiAgICBjb2xvcjogewogICAgICBibGFjazogWzMwLCAzOV0sCiAgICAgIHJlZDogWzMxLCAzOV0sCiAgICAgIGdyZWVuOiBbMzIsIDM5XSwKICAgICAgeWVsbG93OiBbMzMsIDM5XSwKICAgICAgYmx1ZTogWzM0LCAzOV0sCiAgICAgIG1hZ2VudGE6IFszNSwgMzldLAogICAgICBjeWFuOiBbMzYsIDM5XSwKICAgICAgd2hpdGU6IFszNywgMzldLAoKICAgICAgLy8gQnJpZ2h0IGNvbG9yCiAgICAgIGJsYWNrQnJpZ2h0OiBbOTAsIDM5XSwKICAgICAgcmVkQnJpZ2h0OiBbOTEsIDM5XSwKICAgICAgZ3JlZW5CcmlnaHQ6IFs5MiwgMzldLAogICAgICB5ZWxsb3dCcmlnaHQ6IFs5MywgMzldLAogICAgICBibHVlQnJpZ2h0OiBbOTQsIDM5XSwKICAgICAgbWFnZW50YUJyaWdodDogWzk1LCAzOV0sCiAgICAgIGN5YW5CcmlnaHQ6IFs5NiwgMzldLAogICAgICB3aGl0ZUJyaWdodDogWzk3LCAzOV0KICAgIH0sCiAgICBiZ0NvbG9yOiB7CiAgICAgIGJnQmxhY2s6IFs0MCwgNDldLAogICAgICBiZ1JlZDogWzQxLCA0OV0sCiAgICAgIGJnR3JlZW46IFs0MiwgNDldLAogICAgICBiZ1llbGxvdzogWzQzLCA0OV0sCiAgICAgIGJnQmx1ZTogWzQ0LCA0OV0sCiAgICAgIGJnTWFnZW50YTogWzQ1LCA0OV0sCiAgICAgIGJnQ3lhbjogWzQ2LCA0OV0sCiAgICAgIGJnV2hpdGU6IFs0NywgNDldLAoKICAgICAgLy8gQnJpZ2h0IGNvbG9yCiAgICAgIGJnQmxhY2tCcmlnaHQ6IFsxMDAsIDQ5XSwKICAgICAgYmdSZWRCcmlnaHQ6IFsxMDEsIDQ5XSwKICAgICAgYmdHcmVlbkJyaWdodDogWzEwMiwgNDldLAogICAgICBiZ1llbGxvd0JyaWdodDogWzEwMywgNDldLAogICAgICBiZ0JsdWVCcmlnaHQ6IFsxMDQsIDQ5XSwKICAgICAgYmdNYWdlbnRhQnJpZ2h0OiBbMTA1LCA0OV0sCiAgICAgIGJnQ3lhbkJyaWdodDogWzEwNiwgNDldLAogICAgICBiZ1doaXRlQnJpZ2h0OiBbMTA3LCA0OV0KICAgIH0KICB9OwoKICAvLyBBbGlhcyBicmlnaHQgYmxhY2sgYXMgZ3JheSAoYW5kIGdyZXkpCiAgc3R5bGVzLmNvbG9yLmdyYXkgPSBzdHlsZXMuY29sb3IuYmxhY2tCcmlnaHQ7CiAgc3R5bGVzLmJnQ29sb3IuYmdHcmF5ID0gc3R5bGVzLmJnQ29sb3IuYmdCbGFja0JyaWdodDsKICBzdHlsZXMuY29sb3IuZ3JleSA9IHN0eWxlcy5jb2xvci5ibGFja0JyaWdodDsKICBzdHlsZXMuYmdDb2xvci5iZ0dyZXkgPSBzdHlsZXMuYmdDb2xvci5iZ0JsYWNrQnJpZ2h0OwoKICBmb3IoY29uc3QgW2dyb3VwTmFtZSwgZ3JvdXBdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlcykpIHsKICAgIGZvcihjb25zdCBbc3R5bGVOYW1lLCBzdHlsZV0gb2YgT2JqZWN0LmVudHJpZXMoZ3JvdXApKSB7CiAgICAgIHN0eWxlc1tzdHlsZU5hbWVdID0gewogICAgICAgIG9wZW46IGBcdTAwMUJbJHtzdHlsZVswXX1tYCwKICAgICAgICBjbG9zZTogYFx1MDAxQlske3N0eWxlWzFdfW1gCiAgICAgIH07CgogICAgICBncm91cFtzdHlsZU5hbWVdID0gc3R5bGVzW3N0eWxlTmFtZV07CgogICAgICBjb2Rlcy5zZXQoc3R5bGVbMF0sIHN0eWxlWzFdKTsKICAgIH0KCiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCBncm91cE5hbWUsIHsKICAgICAgdmFsdWU6IGdyb3VwLAogICAgICBlbnVtZXJhYmxlOiBmYWxzZQogICAgfSk7CiAgfQoKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCAnY29kZXMnLCB7CiAgICB2YWx1ZTogY29kZXMsCiAgICBlbnVtZXJhYmxlOiBmYWxzZQogIH0pOwoKICBzdHlsZXMuY29sb3IuY2xvc2UgPSAnXHUwMDFCWzM5bSc7CiAgc3R5bGVzLmJnQ29sb3IuY2xvc2UgPSAnXHUwMDFCWzQ5bSc7CgogIHN0eWxlcy5jb2xvci5hbnNpID0gd3JhcEFuc2kxNigpOwogIHN0eWxlcy5jb2xvci5hbnNpMjU2ID0gd3JhcEFuc2kyNTYoKTsKICBzdHlsZXMuY29sb3IuYW5zaTE2bSA9IHdyYXBBbnNpMTZtKCk7CiAgc3R5bGVzLmJnQ29sb3IuYW5zaSA9IHdyYXBBbnNpMTYoQU5TSV9CQUNLR1JPVU5EX09GRlNFVCk7CiAgc3R5bGVzLmJnQ29sb3IuYW5zaTI1NiA9IHdyYXBBbnNpMjU2KEFOU0lfQkFDS0dST1VORF9PRkZTRVQpOwogIHN0eWxlcy5iZ0NvbG9yLmFuc2kxNm0gPSB3cmFwQW5zaTE2bShBTlNJX0JBQ0tHUk9VTkRfT0ZGU0VUKTsKCiAgLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vUWl4LS9jb2xvci1jb252ZXJ0L2Jsb2IvM2YwZTBkNGU5MmUyMzU3OTZjY2IxN2Y2ZTg1YzcyMDk0YTY1MWY0OS9jb252ZXJzaW9ucy5qcwogIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHN0eWxlcywgewogICAgcmdiVG9BbnNpMjU2OiB7CiAgICAgIHZhbHVlOiAocmVkLCBncmVlbiwgYmx1ZSkgPT4gewogICAgICAgIC8vIFdlIHVzZSB0aGUgZXh0ZW5kZWQgZ3JleXNjYWxlIHBhbGV0dGUgaGVyZSwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mCiAgICAgICAgLy8gYmxhY2sgYW5kIHdoaXRlLiBub3JtYWwgcGFsZXR0ZSBvbmx5IGhhcyA0IGdyZXlzY2FsZSBzaGFkZXMuCiAgICAgICAgaWYocmVkID09PSBncmVlbiAmJiBncmVlbiA9PT0gYmx1ZSkgewogICAgICAgICAgaWYocmVkIDwgOCkgewogICAgICAgICAgICByZXR1cm4gMTY7CiAgICAgICAgICB9CgogICAgICAgICAgaWYocmVkID4gMjQ4KSB7CiAgICAgICAgICAgIHJldHVybiAyMzE7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKChyZWQgLSA4KSAvIDI0NykgKiAyNCkgKyAyMzI7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGMgPSBbcmVkLCBncmVlbiwgYmx1ZV0ubWFwKGMgPT4gKGMgLyAyNTUpICogNSk7CiAgICAgICAgcmV0dXJuIDE2ICsgMzYgKiBjWzBdICsgNiAqIGNbMV0gKyBjWzJdOwogICAgICB9LAogICAgICBlbnVtZXJhYmxlOiBmYWxzZQogICAgfSwKICAgIGhleFRvUmdiOiB7CiAgICAgIHZhbHVlOiBoZXggPT4gewogICAgICAgIGNvbnN0IG1hdGNoZXMgPSAvKD88Y29sb3JTdHJpbmc+W2EtZlxkXXs2fXxbYS1mXGRdezN9KS9pLmV4ZWMoaGV4LnRvU3RyaW5nKDE2KSk7CiAgICAgICAgaWYoIW1hdGNoZXMpIHsKICAgICAgICAgIHJldHVybiBbMCwgMCwgMF07CiAgICAgICAgfQoKICAgICAgICBsZXQgeyBjb2xvclN0cmluZyB9ID0gbWF0Y2hlcy5ncm91cHM7CgogICAgICAgIGlmKGNvbG9yU3RyaW5nLmxlbmd0aCA9PT0gMykgewogICAgICAgICAgY29sb3JTdHJpbmcgPSBjb2xvclN0cmluZwogICAgICAgICAgICAuc3BsaXQoJycpCiAgICAgICAgICAgIC5tYXAoY2hhcmFjdGVyID0+IGNoYXJhY3RlciArIGNoYXJhY3RlcikKICAgICAgICAgICAgLmpvaW4oJycpOwogICAgICAgIH0KCiAgICAgICAgY29uc3QgaW50ZWdlciA9IE51bWJlci5wYXJzZUludChjb2xvclN0cmluZywgMTYpOwoKICAgICAgICByZXR1cm4gWyhpbnRlZ2VyID4+IDE2KSAmIDB4ZmYsIChpbnRlZ2VyID4+IDgpICYgMHhmZiwgaW50ZWdlciAmIDB4ZmZdOwogICAgICB9LAogICAgICBlbnVtZXJhYmxlOiBmYWxzZQogICAgfSwKICAgIGhleFRvQW5zaTI1NjogewogICAgICB2YWx1ZTogaGV4ID0+IHN0eWxlcy5yZ2JUb0Fuc2kyNTYoLi4uc3R5bGVzLmhleFRvUmdiKGhleCkpLAogICAgICBlbnVtZXJhYmxlOiBmYWxzZQogICAgfSwKICAgIGFuc2kyNTZUb0Fuc2k6IHsKICAgICAgdmFsdWU6IGNvZGUgPT4gewogICAgICAgIGlmKGNvZGUgPCA4KSB7CiAgICAgICAgICByZXR1cm4gMzAgKyBjb2RlOwogICAgICAgIH0KCiAgICAgICAgaWYoY29kZSA8IDE2KSB7CiAgICAgICAgICByZXR1cm4gOTAgKyAoY29kZSAtIDgpOwogICAgICAgIH0KCiAgICAgICAgbGV0IHJlZDsKICAgICAgICBsZXQgZ3JlZW47CiAgICAgICAgbGV0IGJsdWU7CgogICAgICAgIGlmKGNvZGUgPj0gMjMyKSB7CiAgICAgICAgICByZWQgPSAoKGNvZGUgLSAyMzIpICogMTAgKyA4KSAvIDI1NTsKICAgICAgICAgIGdyZWVuID0gcmVkOwogICAgICAgICAgYmx1ZSA9IHJlZDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29kZSAtPSAxNjsKCiAgICAgICAgICBjb25zdCByZW1haW5kZXIgPSBjb2RlICUgMzY7CgogICAgICAgICAgcmVkID0gTWF0aC5mbG9vcihjb2RlIC8gMzYpICogMC4yOwogICAgICAgICAgZ3JlZW4gPSBNYXRoLmZsb29yKHJlbWFpbmRlciAvIDYpICogMC4yOwogICAgICAgICAgYmx1ZSA9IChyZW1haW5kZXIgJSA2KSAqIDAuMjsKICAgICAgICB9CgogICAgICAgIGNvbnN0IHZhbHVlID0gTWF0aC5tYXgocmVkLCBncmVlbiwgYmx1ZSkgKiAyOwoKICAgICAgICBpZih2YWx1ZSA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIDMwOwogICAgICAgIH0KCiAgICAgICAgbGV0IHJlc3VsdCA9IDMwICsgKChNYXRoLnJvdW5kKGJsdWUpIDw8IDIpIHwgKE1hdGgucm91bmQoZ3JlZW4pIDw8IDEpIHwgTWF0aC5yb3VuZChyZWQpKTsKCiAgICAgICAgaWYodmFsdWUgPT09IDIpIHsKICAgICAgICAgIHJlc3VsdCArPSA2MDsKICAgICAgICB9CgogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH0sCiAgICAgIGVudW1lcmFibGU6IGZhbHNlCiAgICB9LAogICAgcmdiVG9BbnNpOiB7CiAgICAgIHZhbHVlOiAocmVkLCBncmVlbiwgYmx1ZSkgPT4gc3R5bGVzLmFuc2kyNTZUb0Fuc2koc3R5bGVzLnJnYlRvQW5zaTI1NihyZWQsIGdyZWVuLCBibHVlKSksCiAgICAgIGVudW1lcmFibGU6IGZhbHNlCiAgICB9LAogICAgaGV4VG9BbnNpOiB7CiAgICAgIHZhbHVlOiBoZXggPT4gc3R5bGVzLmFuc2kyNTZUb0Fuc2koc3R5bGVzLmhleFRvQW5zaTI1NihoZXgpKSwKICAgICAgZW51bWVyYWJsZTogZmFsc2UKICAgIH0KICB9KTsKCiAgcmV0dXJuIHN0eWxlczsKfQoKZXhwb3J0IGZ1bmN0aW9uIHJhbmRJbnQoLi4uYXJncykgewogIGxldCByYW5nZSA9IGFyZ3Muc3BsaWNlKDAsIDIpOwogIGxldCBybmQgPSBhcmdzLnNoaWZ0KCk7CiAgaWYocmFuZ2UubGVuZ3RoIDwgMikgcmFuZ2UudW5zaGlmdCgwKTsKICByZXR1cm4gTWF0aC5yb3VuZChtaXNjLnJhbmQocmFuZ2VbMV0gLSByYW5nZVswXSArIDEpICsgcmFuZ2VbMF0pOwp9CgpleHBvcnQgY29uc3QgYW5zaVN0eWxlcyA9IGdldEFuc2lTdHlsZXMoKTsKCmNvbnN0IGluc3BlY3RNZXRob2QgPSBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpOwoKdXRpbC5pbnNwZWN0ID0gaW5zcGVjdDsKdXRpbC5mb3JtYXQgPSBmb3JtYXQ7CnV0aWwuZm9ybWF0V2l0aE9wdGlvbnMgPSBmb3JtYXRXaXRoT3B0aW9uczsKdXRpbC50eXBlcyA9IHR5cGVzOwp1dGlsLmFzc2VydCA9IGFzc2VydDsKdXRpbC5oYXNCdWlsdEluID0gaGFzQnVpbHRJbjsKdXRpbC50b1N0cmluZyA9IHRvU3RyaW5nOwp1dGlsLnRvQXJyYXlCdWZmZXIgPSB0b0FycmF5QnVmZmVyOwp1dGlsLnNldEludGVydmFsID0gc2V0SW50ZXJ2YWw7CnV0aWwuY2xlYXJJbnRlcnZhbCA9IGNsZWFySW50ZXJ2YWw7CnV0aWwubWVtb2l6ZSA9IG1lbW9pemU7CnV0aWwub25jZSA9IG9uY2U7CnV0aWwuZGVmaW5lID0gZGVmaW5lOwp1dGlsLndlYWtBc3NpZ24gPSB3ZWFrQXNzaWduOwp1dGlsLkFycmF5RXh0ZW5zaW9ucyA9IEFycmF5RXh0ZW5zaW9uczsKdXRpbC5leHRlbmRBcnJheSA9IChwcm90byA9IEFycmF5LnByb3RvdHlwZSwgZGVmID0gdXRpbC5kZWZpbmUpID0+IGRlZihwcm90bywgQXJyYXlFeHRlbnNpb25zKTsKdXRpbC5leHRlbmRHZW5lcmF0b3IgPSAocHJvdG8gPSBHZW5lcmF0b3JQcm90b3R5cGUsIGRlZiA9IHV0aWwuZGVmaW5lKSA9PiBkZWYocHJvdG8sIEdlbmVyYXRvckV4dGVuc2lvbnMpOwp1dGlsLmVycm9ycyA9IGVycm9yczsKdXRpbC5nZXRQcm90b3R5cGVDaGFpbiA9IGdldFByb3RvdHlwZUNoYWluOwp1dGlsLmdldENvbnN0cnVjdG9yQ2hhaW4gPSBnZXRDb25zdHJ1Y3RvckNoYWluOwp1dGlsLmhhc1Byb3RvdHlwZSA9IGhhc1Byb3RvdHlwZTsKdXRpbC5hbnNpU3R5bGVzID0gYW5zaVN0eWxlczsKdXRpbC5yYW5kSW50ID0gcmFuZEludDsKCk9iamVjdC5hc3NpZ24odXRpbCwgewogIFtpbnNwZWN0TWV0aG9kXSgpIHsKICAgIGxldCBvYmogPSB7IC4uLnV0aWwgfTsKICAgIGRlbGV0ZSBvYmpbaW5zcGVjdE1ldGhvZF07CiAgICByZXR1cm4gaW5zcGVjdChvYmosIHsgY3VzdG9tSW5zcGVjdDogZmFsc2UgfSk7CiAgfQp9KTsKCmV4cG9ydCB7IGV4dGVuZEFycmF5LCBBcnJheUV4dGVuc2lvbnMgfSBmcm9tICcuL2V4dGVuZEFycmF5LmpzJzsKZXhwb3J0IHsgU3lzY2FsbEVycm9yIH0gZnJvbSAnc3lzY2FsbGVycm9yJzsKZXhwb3J0IHsgYXJyYXlUb0JpdGZpZWxkLCBhdG9iLCBhdG9tVG9TdHJpbmcsIGF0b21Ub1ZhbHVlLCBiaXRmaWVsZFRvQXJyYXksIGJ0b2EsIGNvbXBpbGVTY3JpcHQsIGNvbmNhdEFycmF5QnVmZmVyLCBkdXBBcnJheUJ1ZmZlciwgZXZhbEJpbmFyeSwgZ2V0Qnl0ZUNvZGUsIGdldENsYXNzQXRvbSwgZ2V0Q2xhc3NDb25zdHJ1Y3RvciwgZ2V0Q2xhc3NDb3VudCwgZ2V0Q2xhc3NJRCwgZ2V0Q2xhc3NOYW1lLCBnZXRDbGFzc1Byb3RvLCBnZXRDb21tYW5kTGluZSwgZ2V0Q3VycmVudFdvcmtpbmdEaXJlY3RvcnksIGdldEV4ZWN1dGFibGUsIGdldEZpbGVEZXNjcmlwdG9yLCBnZXRPcENvZGVzLCBnZXRQZXJmb3JtYW5jZUNvdW50ZXIsIGdldFByb2NNYXBzLCBnZXRQcm9jTW91bnRzLCBnZXRQcm9jU3RhdCwgZ2V0UHJvdG90eXBlQ2hhaW4sIGdldFJvb3REaXJlY3RvcnksIGdldGVnaWQsIGdldGV1aWQsIGdldGdpZCwgZ2V0cGlkLCBnZXRwcGlkLCBnZXRzaWQsIGdldHVpZCwgaHJ0aW1lLCByZWFkT2JqZWN0LCByZXNpemVBcnJheUJ1ZmZlciwgc2VhcmNoQXJyYXlCdWZmZXIsIHNldGVnaWQsIHNldGV1aWQsIHNldGdpZCwgc2V0dWlkLCB0b0FycmF5QnVmZmVyLCB0b1BvaW50ZXIsIHRvU3RyaW5nLCB1bmFtZSwgdmFsdWVQdHIsIHZhbHVlVGFnLCB2YWx1ZVRvQXRvbSwgdmFsdWVUeXBlLCB3cml0ZU9iamVjdCB9IGZyb20gJ21pc2MnOwpleHBvcnQgeyBpbnNwZWN0IH0gZnJvbSAnaW5zcGVjdCc7CgAAAAAAAAAAVVEAAAAAAAAAAAAAAAAAAAAAAABVUQAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAVUAAAAAAAABVQAAAAAAAAAAAAAAAA8L8"
				]
			]
		},
		{
			"file": "/home/roman/Projects/plot-cv/quickjs/quickjs.h",
			"settings":
			{
				"buffer_size": 42482,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
			]
		},
		{
			"file": "utils.h",
			"settings":
			{
				"buffer_size": 28549,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					1,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAXfAAAI2lmbmRlZiBVVElMU19ICiNkZWZpbmUgVVRJTFNfSAoKI2luY2x1ZGUgInF1aWNranMuaCIKI2luY2x1ZGUgInF1aWNranMtaW50ZXJuYWwuaCIKI2luY2x1ZGUgImN1dGlscy5oIgojaW5jbHVkZSA8c3RyaW5nLmg+CiNpbmNsdWRlIDxtYXRoLmg+CiNpbmNsdWRlIDxzdHJpbmcuaD4KI2luY2x1ZGUgPHN0ZGxpYi5oPgojaW5jbHVkZSA8YXNzZXJ0Lmg+CiNpZmRlZiBIQVZFX1RIUkVBRFNfSAojaW5jbHVkZSA8dGhyZWFkcy5oPgojZW5kaWYKCiNpZm5kZWYgb2Zmc2V0b2YKI2RlZmluZSBvZmZzZXRvZih0eXBlLCBmaWVsZCkgKChzaXplX3QpICYgKCh0eXBlKikwKS0+ZmllbGQpCiNlbmRpZgoKI2lmbmRlZiBpbnJhbmdlCiNkZWZpbmUgaW5yYW5nZSh2YWx1ZSwgbWluLCBtYXgpICgodmFsdWUpID49IChtaW4pICYmICh2YWx1ZSkgPD0gKG1heCkpCiNlbmRpZgoKI2RlZmluZSB0cmltX2RvdHNsYXNoKHN0cikgKCFzdHJuY21wKChzdHIpLCAiLi8iLCAyKSA/IChzdHIpICsgMiA6IChzdHIpKQoKI2lmbmRlZiB0aHJlYWRfbG9jYWwKI2lmZGVmIF9UaHJlYWRfbG9jYWwKI2RlZmluZSB0aHJlYWRfbG9jYWwgX1RocmVhZF9sb2NhbAojZWxpZiBkZWZpbmVkKF9fR05VQ19fKSB8fCBkZWZpbmVkKF9fSU5URUxfQ09NUElMRVIpIHx8IGRlZmluZWQoX19TVU5QUk9fQ0MpIHx8IGRlZmluZWQoX19JQk1DUFBfXykKI2RlZmluZSB0aHJlYWRfbG9jYWwgX190aHJlYWQKI2VsaWYgZGVmaW5lZChfV0lOMzIpCiNkZWZpbmUgdGhyZWFkX2xvY2FsIF9fZGVjbHNwZWModGhyZWFkKQojZWxzZQojZXJyb3IgTm8gVExTIGltcGxlbWVudGF0aW9uIGZvdW5kLgojZW5kaWYKI2VuZGlmCgp0eXBlZGVmIGVudW0gcHJlY2VkZW5jZSB7CiAgUFJFQ0VERU5DRV9DT01NQV9TRVFVRU5DRSA9IDEsCiAgUFJFQ0VERU5DRV9ZSUVMRCwKICBQUkVDRURFTkNFX0FTU0lHTk1FTlQsCiAgUFJFQ0VERU5DRV9URVJOQVJZLAogIFBSRUNFREVOQ0VfTlVMTElTSF9DT0FMRVNDSU5HLAogIFBSRUNFREVOQ0VfTE9HSUNBTF9PUiwKICBQUkVDRURFTkNFX0xPR0lDQUxfQU5ELAogIFBSRUNFREVOQ0VfQklUV0lTRV9PUiwKICBQUkVDRURFTkNFX0JJVFdJU0VfWE9SLAogIFBSRUNFREVOQ0VfQklUV0lTRV9BTkQsCiAgUFJFQ0VERU5DRV9FUVVBTElUWSwKICBQUkVDRURFTkNFX0xFU1NfR1JFQVRFUl9JTiwKICBQUkVDRURFTkNFX0JJVFdJU0VfU0hJRlQsCiAgUFJFQ0VERU5DRV9BRERJVElWRSwKICBQUkVDRURFTkNFX01VTFRJUExJQ0FUSVZFLAogIFBSRUNFREVOQ0VfRVhQT05FTlRJQVRJT04sCiAgUFJFQ0VERU5DRV9VTkFSWSwKICBQUkVDRURFTkNFX1BPU1RGSVgsCiAgUFJFQ0VERU5DRV9ORVcsCiAgUFJFQ0VERU5DRV9NRU1CRVJfQUNDRVNTLAogIFBSRUNFREVOQ0VfR1JPVVBJTkcsCn0gSlNQcmVjZWRlbmNlOwoKI2RlZmluZSBKU19DR0VUU0VUX0VOVU1FUkFCTEVfREVGKHByb3BfbmFtZSwgZmdldHRlciwgZnNldHRlciwgbWFnaWNfbnVtKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgLm5hbWUgPSBwcm9wX25hbWUsIC5wcm9wX2ZsYWdzID0gSlNfUFJPUF9FTlVNRVJBQkxFIHwgSlNfUFJPUF9DT05GSUdVUkFCTEUsIC5kZWZfdHlwZSA9IEpTX0RFRl9DR0VUU0VUX01BR0lDLCAubWFnaWMgPSBtYWdpY19udW0sIC51ID0geyAgICAgICAgIFwKICAgICAgLmdldHNldCA9IHsuZ2V0ID0gey5nZXR0ZXJfbWFnaWMgPSBmZ2V0dGVyfSwgLnNldCA9IHsuc2V0dGVyX21hZ2ljID0gZnNldHRlcn19ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIH0KCiNkZWZpbmUgSlNfQ0dFVFNFVF9NQUdJQ19GTEFHU19ERUYocHJvcF9uYW1lLCBmZ2V0dGVyLCBmc2V0dGVyLCBtYWdpY19udW0sIGZsYWdzKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgIC5uYW1lID0gcHJvcF9uYW1lLCAucHJvcF9mbGFncyA9IGZsYWdzLCAuZGVmX3R5cGUgPSBKU19ERUZfQ0dFVFNFVF9NQUdJQywgLm1hZ2ljID0gbWFnaWNfbnVtLCAudSA9IHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICAgIC5nZXRzZXQgPSB7LmdldCA9IHsuZ2V0dGVyX21hZ2ljID0gZmdldHRlcn0sIC5zZXQgPSB7LnNldHRlcl9tYWdpYyA9IGZzZXR0ZXJ9fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICB9CgojZGVmaW5lIEpTX0NGVU5DX0RFRl9GTEFHUyhwcm9wX25hbWUsIGxlbmd0aCwgZnVuYzEsIGZsYWdzKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICAubmFtZSA9IHByb3BfbmFtZSwgLnByb3BfZmxhZ3MgPSBmbGFncywgLmRlZl90eXBlID0gSlNfREVGX0NGVU5DLCAubWFnaWMgPSAwLCAudSA9IHsuZnVuYyA9IHtsZW5ndGgsIEpTX0NGVU5DX2dlbmVyaWMsIHsuZ2VuZXJpYyA9IGZ1bmMxfX0gfSAgICAgXAogIH0KCiNkZWZpbmUgSlNfQ09OU1RBTlQobmFtZSkgSlNfUFJPUF9JTlQzMl9ERUYoI25hbWUsIG5hbWUsIEpTX1BST1BfQ09ORklHVVJBQkxFKQoKI2lmIGRlZmluZWQoX1dJTjMyKSB8fCBkZWZpbmVkKF9fTUlOR1czMl9fKQojZGVmaW5lIFZJU0lCTEUgX19kZWNsc3BlYyhkbGxleHBvcnQpCiNkZWZpbmUgSElEREVOCiNlbHNlCiNkZWZpbmUgVklTSUJMRSBfX2F0dHJpYnV0ZV9fKCh2aXNpYmlsaXR5KCJkZWZhdWx0IikpKQojZGVmaW5lIEhJRERFTiBfX2F0dHJpYnV0ZV9fKCh2aXNpYmlsaXR5KCJoaWRkZW4iKSkpCiNlbmRpZgoKI2lmbmRlZiBNQVhfTlVNCiNkZWZpbmUgTUFYX05VTShhLCBiKSAoKGEpID4gKGIpID8gKGEpIDogKGIpKQojZW5kaWYKI2lmbmRlZiBNSU5fTlVNCiNkZWZpbmUgTUlOX05VTShhLCBiKSAoKGEpIDwgKGIpID8gKGEpIDogKGIpKQojZW5kaWYKCiNkZWZpbmUgSlNfSXNNb2R1bGUodmFsdWUpIChKU19WQUxVRV9HRVRfVEFHKCh2YWx1ZSkpID09IEpTX1RBR19NT0RVTEUpCgpleHRlcm4gVklTSUJMRSBjb25zdCBjaGFyKiBqc19kZWZhdWx0X21vZHVsZV9wYXRoOwoKdHlwZWRlZiBzdHJ1Y3QgewogIEJPT0wgZG9uZTsKICBKU1ZhbHVlIHZhbHVlOwp9IEl0ZXJhdG9yVmFsdWU7Cgp0eXBlZGVmIHN0cnVjdCB7CiAgaW50IGM7CiAgY29uc3QgY2hhcioqIHY7Cn0gQXJndW1lbnRzOwoKc3RhdGljIGlubGluZSBBcmd1bWVudHMKYXJndW1lbnRzX25ldyhpbnQgYXJnYywgY29uc3QgY2hhciogYXJndltdKSB7CiAgQXJndW1lbnRzIGFyZ3M7CiAgYXJncy5jID0gYXJnYzsKICBhcmdzLnYgPSBhcmd2OwogIHJldHVybiBhcmdzOwp9CgpzdGF0aWMgaW5saW5lIGNvbnN0IGNoYXIqCmFyZ3VtZW50c19zaGlmdChBcmd1bWVudHMqIGFyZ3MpIHsKICBjb25zdCBjaGFyKiByZXQgPSAwOwogIGlmKGFyZ3MtPmMgPiAwKSB7CiAgICByZXQgPSBhcmdzLT52WzBdOwogICAgYXJncy0+Yy0tOwogICAgYXJncy0+disrOwogIH0KICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW5saW5lIGNvbnN0IGNoYXIqCmFyZ3VtZW50c19hdChBcmd1bWVudHMqIGFyZ3MsIGludCBpKSB7CiAgcmV0dXJuIGkgPj0gMCAmJiBpIDwgYXJncy0+YyA/IGFyZ3MtPnZbaV0gOiAwOwp9CgpzdGF0aWMgaW5saW5lIHVpbnQzMl90CmFyZ3VtZW50c19zaGlmdG4oQXJndW1lbnRzKiBhcmdzLCB1aW50MzJfdCBuKSB7CiAgdWludDMyX3QgaSA9IDA7CgogIHdoaWxlKG4gPiAwKSB7CiAgICBpZighYXJndW1lbnRzX3NoaWZ0KGFyZ3MpKQogICAgICBicmVhazsKICAgIGkrKzsKICAgIG4tLTsKICB9CiAgcmV0dXJuIGk7Cn0KCnR5cGVkZWYgc3RydWN0IHsKICBpbnQgYzsKICBKU1ZhbHVlQ29uc3QqIHY7Cn0gSlNBcmd1bWVudHM7CgpzdGF0aWMgaW5saW5lIEpTQXJndW1lbnRzCmpzX2FyZ3VtZW50c19uZXcoaW50IGFyZ2MsIEpTVmFsdWVDb25zdCogYXJndikgewogIEpTQXJndW1lbnRzIGFyZ3M7CiAgYXJncy5jID0gYXJnYzsKICBhcmdzLnYgPSBhcmd2OwogIHJldHVybiBhcmdzOwp9CgpzdGF0aWMgaW5saW5lIEpTVmFsdWVDb25zdApqc19hcmd1bWVudHNfc2hpZnQoSlNBcmd1bWVudHMqIGFyZ3MpIHsKICBKU1ZhbHVlIHJldCA9IEpTX0VYQ0VQVElPTjsKICBpZihhcmdzLT5jID4gMCkgewogICAgcmV0ID0gYXJncy0+dlswXTsKICAgIGFyZ3MtPmMtLTsKICAgIGFyZ3MtPnYrKzsKICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBKU1ZhbHVlQ29uc3QKanNfYXJndW1lbnRzX2F0KEpTQXJndW1lbnRzKiBhcmdzLCBpbnQgaSkgewogIHJldHVybiBpID49IDAgJiYgaSA8IGFyZ3MtPmMgPyBhcmdzLT52W2ldIDogSlNfVU5ERUZJTkVEOwp9CgpzdGF0aWMgaW5saW5lIHVpbnQzMl90CmpzX2FyZ3VtZW50c19zaGlmdG4oSlNBcmd1bWVudHMqIGFyZ3MsIHVpbnQzMl90IG4pIHsKICB1aW50MzJfdCBpID0gMDsKCiAgd2hpbGUobiA+IDApIHsKICAgIGlmKEpTX0lzRXhjZXB0aW9uKGpzX2FyZ3VtZW50c19zaGlmdChhcmdzKSkpCiAgICAgIGJyZWFrOwogICAgaSsrOwogICAgbi0tOwogIH0KICByZXR1cm4gaTsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKbWluX3NpemUoc2l6ZV90IGEsIHNpemVfdCBiKSB7CiAgaWYoYSA8IGIpCiAgICByZXR1cm4gYTsKICBlbHNlCiAgICByZXR1cm4gYjsKfQoKc3RhdGljIGlubGluZSB1aW50NjRfdAphYnNfaW50NjQoaW50NjRfdCBhKSB7CiAgcmV0dXJuIGEgPCAwID8gLWEgOiBhOwp9CgpzdGF0aWMgaW5saW5lIHVpbnQzMl90CmFic19pbnQzMihpbnQzMl90IGkpIHsKICByZXR1cm4gaSA8IDAgPyAtaSA6IGk7Cn0KCnN0YXRpYyBpbmxpbmUgaW50MzJfdApzaWduX2ludDMyKHVpbnQzMl90IGkpIHsKICByZXR1cm4gKGkgJiAweDgwMDAwMDAwKSA/IC0xIDogMTsKfQoKc3RhdGljIGlubGluZSBpbnQzMl90Cm1vZF9pbnQzMihpbnQzMl90IGEsIGludDMyX3QgYikgewogIGludDMyX3QgYyA9IGEgJSBiOwogIHJldHVybiAoYyA8IDApID8gYyArIGIgOiBjOwp9CgojZGVmaW5lIENPTE9SX1JFRCAiXHgxYlszMW0iCiNkZWZpbmUgQ09MT1JfR1JFRU4gIlx4MWJbMzJtIgojZGVmaW5lIENPTE9SX1lFTExPVyAiXHgxYlszM20iCiNkZWZpbmUgQ09MT1JfQkxVRSAiXHgxYlszNG0iCiNkZWZpbmUgQ09MT1JfTUFHRU5UQSAiXHgxYlszNW0iCiNkZWZpbmUgQ09MT1JfTUFSSU5FICJceDFiWzM2bSIKI2RlZmluZSBDT0xPUl9MSUdIVEdSQVkgIlx4MWJbMzdtIgojZGVmaW5lIENPTE9SX0dSQVkgIlx4MWJbMTszMG0iCiNkZWZpbmUgQ09MT1JfTk9ORSAiXHgxYlttIgoKI2RlZmluZSBDT0xPUl9MSUdIVFJFRCAiXHgxYlsxOzMxbSIKCiNkZWZpbmUgQ09MT1JfTElHSFRHUkVFTiAiXHgxYlsxOzMybSIKI2RlZmluZSBDT0xPUl9MSUdIVFlFTExPVyAiXHgxYlsxOzMzbSIKI2RlZmluZSBDT0xPUl9MSUdIVEJMVUUgIlx4MWJbMTszNG0iCiNkZWZpbmUgQ09MT1JfTElHSFRNQUdFTlRBICJceDFiWzE7MzVtIgojZGVmaW5lIENPTE9SX0xJR0hUTUFSSU5FICJceDFiWzE7MzZtIgojZGVmaW5lIENPTE9SX1dISVRFICJceDFiWzE7MzdtIgoKdWludDY0X3QgdGltZV91cyh2b2lkKTsKCmludDY0X3QgYXJyYXlfc2VhcmNoKHZvaWQqIGEsIHNpemVfdCBtLCBzaXplX3QgZWxzeiwgdm9pZCogbmVlZGxlKTsKI2RlZmluZSBhcnJheV9jb250YWlucyhhLCBtLCBlbHN6LCBuZWVkbGUpIChhcnJheV9zZWFyY2goKGEpLCAobSksIChlbHN6KSwgKG5lZWRsZSkpICE9IC0xKQoKc3RhdGljIGlubGluZSB2b2lkCmpzX2RidWZfaW5pdF9ydChKU1J1bnRpbWUqIHJ0LCBEeW5CdWYqIHMpIHsKICBkYnVmX2luaXQyKHMsIHJ0LCAoRHluQnVmUmVhbGxvY0Z1bmMqKWpzX3JlYWxsb2NfcnQpOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQKanNfZGJ1Zl9pbml0KEpTQ29udGV4dCogY3R4LCBEeW5CdWYqIHMpIHsKICBkYnVmX2luaXQyKHMsIGN0eCwgKER5bkJ1ZlJlYWxsb2NGdW5jKilqc19yZWFsbG9jKTsKfQoKdHlwZWRlZiBzdHJ1Y3QgewogIGNoYXIqIHNvdXJjZTsKICBzaXplX3QgbGVuOwogIGludCBmbGFnczsKfSBSZWdFeHA7CgppbnQgcmVnZXhwX2ZsYWdzX3Rvc3RyaW5nKGludCwgY2hhciopOwppbnQgcmVnZXhwX2ZsYWdzX2Zyb21zdHJpbmcoY29uc3QgY2hhciopOwpSZWdFeHAgcmVnZXhwX2Zyb21fYXJndihpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSwgSlNDb250ZXh0KiBjdHgpOwpSZWdFeHAgcmVnZXhwX2Zyb21fZGJ1ZihEeW5CdWYqIGRidWYsIGludCBmbGFncyk7CnVpbnQ4X3QqIHJlZ2V4cF9jb21waWxlKFJlZ0V4cCByZSwgSlNDb250ZXh0KiBjdHgpOwpKU1ZhbHVlIHJlZ2V4cF90b192YWx1ZShSZWdFeHAgcmUsIEpTQ29udGV4dCogY3R4KTsKCnN0YXRpYyBpbmxpbmUgdm9pZApyZWdleHBfZnJlZV9ydChSZWdFeHAgcmUsIEpTUnVudGltZSogcnQpIHsKICBqc19mcmVlX3J0KHJ0LCByZS5zb3VyY2UpOwp9CnN0YXRpYyBpbmxpbmUgdm9pZApyZWdleHBfZnJlZShSZWdFeHAgcmUsIEpTQ29udGV4dCogY3R4KSB7CiAgcmVnZXhwX2ZyZWVfcnQocmUsIEpTX0dldFJ1bnRpbWUoY3R4KSk7Cn0KCkpTVmFsdWUganNfZ2xvYmFsX2dldChKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogcHJvcCk7CgpzdGF0aWMgaW5saW5lIEpTVmFsdWUKanNfZ2xvYmFsX25ldyhKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogY2xhc3NfbmFtZSwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10pIHsKICBKU1ZhbHVlIGN0b3IgPSBqc19nbG9iYWxfZ2V0KGN0eCwgY2xhc3NfbmFtZSk7CiAgSlNWYWx1ZSBvYmogPSBKU19DYWxsQ29uc3RydWN0b3IoY3R4LCBjdG9yLCBhcmdjLCBhcmd2KTsKICBKU19GcmVlVmFsdWUoY3R4LCBjdG9yKTsKICByZXR1cm4gb2JqOwp9CgpKU1ZhbHVlIGpzX2dsb2JhbF9wcm90b3R5cGUoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIGNsYXNzX25hbWUpOwoKZW51bSB2YWx1ZV90eXBlcyB7CiAgRkxBR19VTkRFRklORUQgPSAwLAogIEZMQUdfTlVMTCwgICAgICAgIC8vIDEKICBGTEFHX0JPT0wsICAgICAgICAvLyAyCiAgRkxBR19JTlQsICAgICAgICAgLy8gMwogIEZMQUdfT0JKRUNULCAgICAgIC8vIDQKICBGTEFHX1NUUklORywgICAgICAvLyA1CiAgRkxBR19TWU1CT0wsICAgICAgLy8gNgogIEZMQUdfQklHX0ZMT0FULCAgIC8vIDcKICBGTEFHX0JJR19JTlQsICAgICAvLyA4CiAgRkxBR19CSUdfREVDSU1BTCwgLy8gOQogIEZMQUdfRkxPQVQ2NCwgICAgIC8vIDEwCiAgRkxBR19OQU4sICAgICAgICAgLy8gMTEKICBGTEFHX0ZVTkNUSU9OLCAgICAvLyAxMgogIEZMQUdfQVJSQVksICAgICAgIC8vIDEzCiAgRkxBR19NT0RVTEUsCiAgRkxBR19GVU5DVElPTl9CWVRFQ09ERSwKICBGTEFHX1VOSU5JVElBTElaRUQsCiAgRkxBR19DQVRDSF9PRkZTRVQsCiAgRkxBR19FWENFUFRJT04KCn07CgplbnVtIHZhbHVlX21hc2sgewogIFRZUEVfVU5ERUZJTkVEID0gKDEgPDwgRkxBR19VTkRFRklORUQpLAogIFRZUEVfTlVMTCA9ICgxIDw8IEZMQUdfTlVMTCksCiAgVFlQRV9CT09MID0gKDEgPDwgRkxBR19CT09MKSwKICBUWVBFX0lOVCA9ICgxIDw8IEZMQUdfSU5UKSwKICBUWVBFX09CSkVDVCA9ICgxIDw8IEZMQUdfT0JKRUNUKSwKICBUWVBFX1NUUklORyA9ICgxIDw8IEZMQUdfU1RSSU5HKSwKICBUWVBFX1NZTUJPTCA9ICgxIDw8IEZMQUdfU1lNQk9MKSwKICBUWVBFX0JJR19GTE9BVCA9ICgxIDw8IEZMQUdfQklHX0ZMT0FUKSwKICBUWVBFX0JJR19JTlQgPSAoMSA8PCBGTEFHX0JJR19JTlQpLAogIFRZUEVfQklHX0RFQ0lNQUwgPSAoMSA8PCBGTEFHX0JJR19ERUNJTUFMKSwKICBUWVBFX0ZMT0FUNjQgPSAoMSA8PCBGTEFHX0ZMT0FUNjQpLAogIFRZUEVfTkFOID0gKDEgPDwgRkxBR19OQU4pLAogIFRZUEVfTlVNQkVSID0gKFRZUEVfSU5UIHwgVFlQRV9CSUdfRkxPQVQgfCBUWVBFX0JJR19JTlQgfCBUWVBFX0JJR19ERUNJTUFMIHwgVFlQRV9GTE9BVDY0KSwKICBUWVBFX1BSSU1JVElWRSA9CiAgICAgIChUWVBFX1VOREVGSU5FRCB8IFRZUEVfTlVMTCB8IFRZUEVfQk9PTCB8IFRZUEVfSU5UIHwgVFlQRV9TVFJJTkcgfCBUWVBFX1NZTUJPTCB8IFRZUEVfQklHX0ZMT0FUIHwgVFlQRV9CSUdfSU5UIHwgVFlQRV9CSUdfREVDSU1BTCB8IFRZUEVfTkFOKSwKICBUWVBFX0FMTCA9IChUWVBFX1BSSU1JVElWRSB8IFRZUEVfT0JKRUNUKSwKICBUWVBFX0ZVTkNUSU9OID0gKDEgPDwgRkxBR19GVU5DVElPTiksCiAgVFlQRV9BUlJBWSA9ICgxIDw8IEZMQUdfQVJSQVkpLAp9OwoKaW50MzJfdCBqc192YWx1ZV90eXBlX2ZsYWcoSlNWYWx1ZUNvbnN0IHZhbHVlKTsKaW50MzJfdCBqc192YWx1ZV90eXBlX2dldChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKCnN0YXRpYyBpbmxpbmUgaW50MzJfdApqc192YWx1ZV90eXBlMmZsYWcodWludDMyX3QgdHlwZSkgewogIGludDMyX3QgZmxhZzsKICBmb3IoZmxhZyA9IDA7ICh0eXBlID4+PSAxKTsgZmxhZysrKSB7fQogIHJldHVybiBmbGFnOwp9CgplbnVtIHZhbHVlX21hc2sganNfdmFsdWVfdHlwZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKCnN0YXRpYyBpbmxpbmUgY29uc3QgY2hhciogY29uc3QqCmpzX3ZhbHVlX3R5cGVzKCkgewogIHJldHVybiAoY29uc3QgY2hhciogY29uc3RbXSl7CiAgICAgICJVTkRFRklORUQiLCAgICAgIk5VTEwiLCAgICAgICAgICJCT09MIiwgICAgICAiSU5UIiwgIk9CSkVDVCIsICAgIlNUUklORyIsICJTWU1CT0wiLCAiQklHX0ZMT0FUIiwKICAgICAgIkJJR19JTlQiLCAgICAgICAiQklHX0RFQ0lNQUwiLCAgIkZMT0FUNjQiLCAgICJOQU4iLCAiRlVOQ1RJT04iLCAiQVJSQVkiLCAgIk1PRFVMRSIsICJGVU5DVElPTl9CWVRFQ09ERSIsCiAgICAgICJVTklOSVRJQUxJWkVEIiwgIkNBVENIX09GRlNFVCIsICJFWENFUFRJT04iLCAwLAogIH07Cn0KCnN0YXRpYyBpbmxpbmUgY29uc3QgY2hhcioKanNfdmFsdWVfdHlwZW9mKEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIGludDMyX3QgZmxhZyA9IGpzX3ZhbHVlX3R5cGVfZmxhZyh2YWx1ZSk7CiAgcmV0dXJuICgoY29uc3QgY2hhciogY29uc3RbXSl7CiAgICAgICJ1bmRlZmluZWQiLCAgICAgIm9iamVjdCIsICAgICAgICJib29sZWFuIiwgICAibnVtYmVyIiwgIm9iamVjdCIsICAgInN0cmluZyIsICJzeW1ib2wiLCAiYmlnZmxvYXQiLAogICAgICAiYmlnaW50IiwgICAgICAgICJiaWdkZWNpbWFsIiwgICAibnVtYmVyIiwgICAgIm51bWJlciIsICJmdW5jdGlvbiIsICJvYmplY3QiLCAibW9kdWxlIiwgImZ1bmN0aW9uX2J5dGVjb2RlIiwKICAgICAgInVuaW5pdGlhbGl6ZWQiLCAiY2F0Y2hfb2Zmc2V0IiwgImV4Y2VwdGlvbiIsIDAsCiAgfSlbZmxhZ107Cn0KCmNvbnN0IGNoYXIqIGpzX3ZhbHVlX3R5cGVfbmFtZShpbnQzMl90IHR5cGUpOwoKY29uc3QgY2hhcioganNfdmFsdWVfdHlwZXN0cihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKCi8qVklTSUJMRSB2b2lkKiBqc192YWx1ZV9wdHIoSlNWYWx1ZUNvbnN0IHYpOwpWSVNJQkxFIEpTT2JqZWN0KiBqc192YWx1ZV9vYmooSlNWYWx1ZUNvbnN0IHYpOwpWSVNJQkxFIGludDMyX3QganNfdmFsdWVfdGFnKEpTVmFsdWVDb25zdCB2KTsKKi8KCnN0YXRpYyBpbmxpbmUgdm9pZCoKanNfdmFsdWVfcHRyKEpTVmFsdWVDb25zdCB2KSB7CiAgcmV0dXJuIEpTX1ZBTFVFX0dFVF9QVFIodik7Cn0KCnN0YXRpYyBpbmxpbmUgSlNPYmplY3QqCmpzX3ZhbHVlX29iaihKU1ZhbHVlQ29uc3QgdikgewogIHJldHVybiBKU19Jc09iamVjdCh2KSA/IEpTX1ZBTFVFX0dFVF9PQkoodikgOiAwOwp9CgpzdGF0aWMgaW5saW5lIGludApqc192YWx1ZV90YWcoSlNWYWx1ZUNvbnN0IHYpIHsKICByZXR1cm4gSlNfVkFMVUVfR0VUX1RBRyh2KTsKfQoKQk9PTCBqc192YWx1ZV9oYXNfcmVmX2NvdW50KEpTVmFsdWVDb25zdCB2KTsKCnZvaWQganNfdmFsdWVfZnJlZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZSB2KTsKdm9pZCBqc192YWx1ZV9mcmVlX3J0KEpTUnVudGltZSogcnQsIEpTVmFsdWUgdik7CgpCT09MIGpzX3ZhbHVlX2VxdWFscyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IGEsIEpTVmFsdWVDb25zdCBiKTsKdm9pZCBqc192YWx1ZV9wcmludChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKSlNWYWx1ZSBqc192YWx1ZV9jbG9uZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHBlKTsKSlNWYWx1ZSoganNfdmFsdWVzX2R1cChKU0NvbnRleHQqIGN0eCwgaW50IG52YWx1ZXMsIEpTVmFsdWVDb25zdCogdmFsdWVzKTsKdm9pZCBqc192YWx1ZXNfZnJlZShKU1J1bnRpbWUqIHJ0LCBpbnQgbnZhbHVlcywgSlNWYWx1ZUNvbnN0KiB2YWx1ZXMpOwpKU1ZhbHVlIGpzX3ZhbHVlc190b2FycmF5KEpTQ29udGV4dCogY3R4LCBpbnQgbnZhbHVlcywgSlNWYWx1ZUNvbnN0KiB2YWx1ZXMpOwp2b2lkIGpzX3ZhbHVlX2Z3cml0ZShKU0NvbnRleHQqLCBKU1ZhbHVlLCBGSUxFKiBmKTsKdm9pZCBqc192YWx1ZV9kdW1wKEpTQ29udGV4dCosIEpTVmFsdWUsIER5bkJ1ZiogZGIpOwoKLy8jaW5jbHVkZSAiYnVmZmVyLXV0aWxzLmgiCgpjaGFyKiBqc19jc3RyaW5nX2R1cChKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogc3RyKTsKY2hhcioganNfY3N0cmluZ19wdHIoSlNWYWx1ZUNvbnN0IHYpOwpKU1ZhbHVlQ29uc3QganNfY3N0cmluZ192YWx1ZShjb25zdCBjaGFyKiBwdHIpOwp2b2lkIGpzX2NzdHJpbmdfZHVtcChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlLCBEeW5CdWYqIGRiKTsKCnN0YXRpYyBpbmxpbmUgY29uc3QgY2hhcioKanNfY3N0cmluZ19uZXcoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIHN0cikgewogIEpTVmFsdWUgdiA9IEpTX05ld1N0cmluZyhjdHgsIHN0cik7CiAgY29uc3QgY2hhciogcyA9IEpTX1RvQ1N0cmluZyhjdHgsIHYpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHYpOwogIHJldHVybiBzOwp9CnN0YXRpYyBpbmxpbmUgY29uc3QgY2hhcioKanNfY3N0cmluZ19uZXdsZW4oSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIHN0ciwgc2l6ZV90IGxlbikgewogIEpTVmFsdWUgdiA9IEpTX05ld1N0cmluZ0xlbihjdHgsIHN0ciwgbGVuKTsKICBjb25zdCBjaGFyKiBzID0gSlNfVG9DU3RyaW5nKGN0eCwgdik7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdik7CiAgcmV0dXJuIHM7Cn0KCnN0YXRpYyBpbmxpbmUgdm9pZApqc19jc3RyaW5nX2ZyZWUoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIHB0cikgewogIGlmKCFwdHIpCiAgICByZXR1cm47CgogIEpTX0ZyZWVWYWx1ZShjdHgsIEpTX01LUFRSKEpTX1RBR19TVFJJTkcsICh2b2lkKikocHRyIC0gb2Zmc2V0b2YoSlNTdHJpbmcsIHUpKSkpOwp9CgpzdGF0aWMgaW5saW5lIGludDY0X3QKanNfdG9pbnQ2NChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgaW50NjRfdCByZXQgPSAwOwogIEpTX1RvSW50NjQoY3R4LCAmcmV0LCB2YWx1ZSk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBjaGFyKgpqc190b3N0cmluZ2xlbihKU0NvbnRleHQqIGN0eCwgc2l6ZV90KiBsZW5wLCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBzaXplX3QgbGVuOwogIGNvbnN0IGNoYXIqIGNzdHI7CiAgY2hhciogcmV0ID0gMDsKICBpZigoY3N0ciA9IEpTX1RvQ1N0cmluZ0xlbihjdHgsICZsZW4sIHZhbHVlKSkpIHsKICAgIHJldCA9IGpzX3N0cm5kdXAoY3R4LCBjc3RyLCBsZW4pOwogICAgaWYobGVucCkKICAgICAgKmxlbnAgPSBsZW47CiAgICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBjc3RyKTsKICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBjaGFyKgpqc190b3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgcmV0dXJuIGpzX3Rvc3RyaW5nbGVuKGN0eCwgMCwgdmFsdWUpOwp9CgpzdGF0aWMgaW5saW5lIHdjaGFyX3QqCmpzX3Rvd3N0cmluZ2xlbihKU0NvbnRleHQqIGN0eCwgc2l6ZV90KiBsZW5wLCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBzaXplX3QgaSwgbGVuOwogIGNvbnN0IGNoYXIqIGNzdHI7CiAgd2NoYXJfdCogcmV0ID0gMDsKICBpZigoY3N0ciA9IEpTX1RvQ1N0cmluZ0xlbihjdHgsICZsZW4sIHZhbHVlKSkpIHsKICAgIHJldCA9IGpzX21hbGxvY3ooY3R4LCBzaXplb2Yod2NoYXJfdCkgKiAobGVuICsgMSkpOwogICAgY29uc3QgdWludDhfdCAqcHRyID0gKGNvbnN0IHVpbnQ4X3QqKWNzdHIsICplbmQgPSAoY29uc3QgdWludDhfdCopY3N0ciArIGxlbjsKCiAgICBmb3IoaSA9IDA7IHB0ciA8IGVuZDspIHsgcmV0W2krK10gPSB1bmljb2RlX2Zyb21fdXRmOChwdHIsIGVuZCAtIHB0ciwgJnB0cik7IH0KCiAgICBpZihsZW5wKQogICAgICAqbGVucCA9IGk7CiAgfQogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgd2NoYXJfdCoKanNfdG93c3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICByZXR1cm4ganNfdG93c3RyaW5nbGVuKGN0eCwgMCwgdmFsdWUpOwp9CgpzdGF0aWMgaW5saW5lIEpTVmFsdWUKanNfdmFsdWVfdG9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIGNsYXNzX25hbWUsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIEpTQXRvbSBhdG9tOwogIEpTVmFsdWUgcHJvdG8sIHRvc3RyaW5nLCBzdHI7CiAgcHJvdG8gPSBqc19nbG9iYWxfcHJvdG90eXBlKGN0eCwgY2xhc3NfbmFtZSk7CiAgYXRvbSA9IEpTX05ld0F0b20oY3R4LCAidG9TdHJpbmciKTsKICB0b3N0cmluZyA9IEpTX0dldFByb3BlcnR5KGN0eCwgcHJvdG8sIGF0b20pOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHByb3RvKTsKICBKU19GcmVlQXRvbShjdHgsIGF0b20pOwogIHN0ciA9IEpTX0NhbGwoY3R4LCB0b3N0cmluZywgdmFsdWUsIDAsIDApOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHRvc3RyaW5nKTsKICByZXR1cm4gc3RyOwp9CgppbnQganNfdmFsdWVfdG9zaXplKEpTQ29udGV4dCogY3R4LCBzaXplX3QqIHN6LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwoKc3RhdGljIGlubGluZSBkb3VibGUKanNfdmFsdWVfdG9kb3VibGVfZnJlZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgZG91YmxlIHJldCA9IDA7CiAgSlNfVG9GbG9hdDY0KGN0eCwgJnJldCwgdmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW5saW5lIGludDY0X3QKanNfdmFsdWVfdG9pbnQ2NF9mcmVlKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBpbnQ2NF90IHJldCA9IDA7CiAgSlNfVG9JbnQ2NChjdHgsICZyZXQsIHZhbHVlKTsKICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBCT09MCmpzX3ZhbHVlX3RvYm9vbF9mcmVlKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBCT09MIHJldCA9IEpTX1RvQm9vbChjdHgsIHZhbHVlKTsKICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBKU0F0b20KanNfdmFsdWVfdG9hdG9tX2ZyZWUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIEpTQXRvbSBhdG9tID0gSlNfVmFsdWVUb0F0b20oY3R4LCB2YWx1ZSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIHJldHVybiBhdG9tOwp9CgpKU1ZhbHVlIGpzX3ZhbHVlX2Zyb21fY2hhcihKU0NvbnRleHQqIGN0eCwgaW50IGMpOwpzdGF0aWMgaW5saW5lIGludApqc192YWx1ZV9jbXBzdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSwgY29uc3QgY2hhciogb3RoZXIpIHsKICBjb25zdCBjaGFyKiBzdHIgPSBKU19Ub0NTdHJpbmcoY3R4LCB2YWx1ZSk7CiAgaW50IHJldCA9IHN0cmNtcChzdHIsIG90aGVyKTsKICBKU19GcmVlQ1N0cmluZyhjdHgsIHN0cik7CiAgcmV0dXJuIHJldDsKfQoKI2RlZmluZSBKU19WQUxVRV9GUkVFKGN0eCwgdmFsdWUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgSlNfRnJlZVZhbHVlKChjdHgpLCAodmFsdWUpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgICh2YWx1ZSkgPSBKU19VTkRFRklORUQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgfSB3aGlsZSgwKTsKI2RlZmluZSBKU19WQUxVRV9GUkVFX1JUKGN0eCwgdmFsdWUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgSlNfRnJlZVZhbHVlUlQoKGN0eCksICh2YWx1ZSkpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgICh2YWx1ZSkgPSBKU19VTkRFRklORUQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgfSB3aGlsZSgwKTsKCiNpZiAwCiNkZWZpbmUganNfb2JqZWN0X3RtcG1hcmtfc2V0KHZhbHVlKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIGRvIHsgKCh1aW50OF90KilKU19WQUxVRV9HRVRfT0JKKCh2YWx1ZSkpKVs1XSB8PSAweDQwOyB9IHdoaWxlKDApOwojZGVmaW5lIGpzX29iamVjdF90bXBtYXJrX2NsZWFyKHZhbHVlKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICBkbyB7ICgodWludDhfdCopSlNfVkFMVUVfR0VUX09CSigodmFsdWUpKSlbNV0gJj0gfjB4NDA7IH0gd2hpbGUoMCk7CiNkZWZpbmUganNfb2JqZWN0X3RtcG1hcmtfaXNzZXQodmFsdWUpICgoKHVpbnQ4X3QqKUpTX1ZBTFVFX0dFVF9PQkooKHZhbHVlKSkpWzVdICYgMHg0MCkKI2Vsc2UKI2RlZmluZSBqc19vYmplY3RfdG1wbWFya19zZXQodmFsdWUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgZG8geyBKU19WQUxVRV9HRVRfT0JKKCh2YWx1ZSkpLT50bXBfbWFyayB8PSAweDQwOyB9IHdoaWxlKDApOwojZGVmaW5lIGpzX29iamVjdF90bXBtYXJrX2NsZWFyKHZhbHVlKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICBkbyB7IEpTX1ZBTFVFX0dFVF9PQkooKHZhbHVlKSktPnRtcF9tYXJrICY9IH4weDQwOyB9IHdoaWxlKDApOwojZGVmaW5lIGpzX29iamVjdF90bXBtYXJrX2lzc2V0KHZhbHVlKSAoSlNfVkFMVUVfR0VUX09CSigodmFsdWUpKS0+dG1wX21hcmsgJiAweDQwKQojZW5kaWYKCiNkZWZpbmUganNfcnVudGltZV9leGNlcHRpb25fc2V0KHJ0LCB2YWx1ZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIGRvIHsgKihKU1ZhbHVlKikoKHVpbnQ4X3QqKShydCkgKyAyMTYpID0gdmFsdWU7IH0gd2hpbGUoMCk7CiNkZWZpbmUganNfcnVudGltZV9leGNlcHRpb25fZ2V0KHJ0KSAoKihKU1ZhbHVlKikoKHVpbnQ4X3QqKShydCkgKyAyMTYpKQojZGVmaW5lIGpzX3J1bnRpbWVfZXhjZXB0aW9uX2NsZWFyKHJ0KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICBpZighSlNfSXNOdWxsKGpzX3J1bnRpbWVfZXhjZXB0aW9uX2dldChydCkpKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgICBKU19GcmVlVmFsdWVSVCgocnQpLCBqc19ydW50aW1lX2V4Y2VwdGlvbl9nZXQocnQpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgIGpzX3J1bnRpbWVfZXhjZXB0aW9uX3NldChydCwgSlNfTlVMTCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgfSB3aGlsZSgwKQoKdm9pZCBqc19wcm9wZXJ0eWVudW1zX2ZyZWUoSlNDb250ZXh0KiBjdHgsIEpTUHJvcGVydHlFbnVtKiBwcm9wcywgc2l6ZV90IGxlbik7CgpzdGF0aWMgaW5saW5lIHZvaWQKanNfcHJvcGVydHlkZXNjcmlwdG9yX2ZyZWUoSlNDb250ZXh0KiBjdHgsIEpTUHJvcGVydHlEZXNjcmlwdG9yKiBkZXNjKSB7CiAgSlNfRnJlZVZhbHVlKGN0eCwgZGVzYy0+dmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGRlc2MtPmdldHRlcik7CiAgSlNfRnJlZVZhbHVlKGN0eCwgZGVzYy0+c2V0dGVyKTsKfQoKSlNWYWx1ZSBqc19zeW1ib2xfY3RvcihKU0NvbnRleHQqIGN0eCk7CgpKU1ZhbHVlIGpzX3N5bWJvbF9pbnZva2Vfc3RhdGljKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBuYW1lLCBKU1ZhbHVlQ29uc3QgYXJnKTsKCkpTVmFsdWUganNfc3ltYm9sX3RvX3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHN5bSk7Cgpjb25zdCBjaGFyKiBqc19zeW1ib2xfdG9fY3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHN5bSk7CgpKU1ZhbHVlIGpzX3N5bWJvbF9zdGF0aWNfdmFsdWUoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIG5hbWUpOwpKU0F0b20ganNfc3ltYm9sX3N0YXRpY19hdG9tKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBuYW1lKTsKQk9PTCBqc19pc19pdGVyYWJsZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaik7CkJPT0wganNfaXNfaXRlcmF0b3IoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmopOwpKU1ZhbHVlIGpzX2l0ZXJhdG9yX21ldGhvZChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaik7CkpTVmFsdWUganNfaXRlcmF0b3JfbmV3KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqKTsKSlNWYWx1ZSBqc19pdGVyYXRvcl9uZXh0KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBCT09MKiBkb25lX3ApOwpKU1ZhbHVlIGpzX3N5bWJvbF9mb3IoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIHN5bV9mb3IpOwpKU0F0b20ganNfc3ltYm9sX2Zvcl9hdG9tKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBzeW1fZm9yKTsKCkpTVmFsdWUganNfc3ltYm9sX29wZXJhdG9yc2V0X3ZhbHVlKEpTQ29udGV4dCogY3R4KTsKCkpTQXRvbSBqc19zeW1ib2xfb3BlcmF0b3JzZXRfYXRvbShKU0NvbnRleHQqIGN0eCk7CgpKU1ZhbHVlIGpzX29wZXJhdG9yc19jcmVhdGUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWUqIHRoaXNfb2JqKTsKCnN0YXRpYyBpbmxpbmUgaW50NjRfdApqc19pbnQ2NF9kZWZhdWx0KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUsIGludDY0X3QgaSkgewogIGlmKEpTX0lzTnVtYmVyKHZhbHVlKSkKICAgIEpTX1RvSW50NjQoY3R4LCAmaSwgdmFsdWUpOwogIHJldHVybiBpOwp9CgpKU1ZhbHVlIGpzX251bWJlcl9uZXcoSlNDb250ZXh0KiBjdHgsIGludDMyX3Qgbik7CgpzdGF0aWMgaW5saW5lIEpTVmFsdWUKanNfbmV3X2Jvb2xfb3JfbnVtYmVyKEpTQ29udGV4dCogY3R4LCBpbnQzMl90IG4pIHsKICBpZihuID09IDApCiAgICByZXR1cm4gSlNfTmV3Qm9vbChjdHgsIEZBTFNFKTsKICByZXR1cm4ganNfbnVtYmVyX25ldyhjdHgsIG4pOwp9CgojZGVmaW5lIEpTX0FUT01fVEFHX0lOVCAoMVUgPDwgMzEpCiNkZWZpbmUgSlNfQVRPTV9NQVhfSU5UIChKU19BVE9NX1RBR19JTlQgLSAxKQoKI2RlZmluZSBqc19hdG9tX2lzaW50KGkpICgoSlNBdG9tKSgoaSkmSlNfQVRPTV9UQUdfSU5UKSkKI2RlZmluZSBqc19hdG9tX2Zyb21pbnQoaSkgKChKU0F0b20pKChpKSZKU19BVE9NX01BWF9JTlQpIHwgSlNfQVRPTV9UQUdfSU5UKQojZGVmaW5lIGpzX2F0b21fdG9pbnQoaSkgKHVuc2lnbmVkIGludCkoKChKU0F0b20pKGkpICYgKH4oSlNfQVRPTV9UQUdfSU5UKSkpKQoKaW50IGpzX2F0b21fdG9pbnQ2NChKU0NvbnRleHQqIGN0eCwgaW50NjRfdCogaSwgSlNBdG9tIGF0b20pOwppbnQzMl90IGpzX2F0b21fdG9pbnQzMihKU0NvbnRleHQqIGN0eCwgSlNBdG9tIGF0b20pOwoKc3RhdGljIGlubGluZSBKU1ZhbHVlCmpzX2F0b21fdG92YWx1ZShKU0NvbnRleHQqIGN0eCwgSlNBdG9tIGF0b20pIHsKICBpZihqc19hdG9tX2lzaW50KGF0b20pKQogICAgcmV0dXJuIEpTX01LVkFMKEpTX1RBR19JTlQsIGpzX2F0b21fdG9pbnQoYXRvbSkpOwoKICByZXR1cm4gSlNfQXRvbVRvVmFsdWUoY3R4LCBhdG9tKTsKfQoKdW5zaWduZWQgaW50IGpzX2F0b21fdG9iaW5hcnkoSlNBdG9tIGF0b20pOwpjb25zdCBjaGFyKiBqc19hdG9tX3RvX2NzdHJpbmdsZW4oSlNDb250ZXh0KiBjdHgsIHNpemVfdCogbGVuLCBKU0F0b20gYXRvbSk7CnZvaWQganNfYXRvbV9kdW1wKEpTQ29udGV4dCogY3R4LCBKU0F0b20gYXRvbSwgRHluQnVmKiBkYiwgQk9PTCBjb2xvcik7CkJPT0wganNfYXRvbV9pc19pbmRleChKU0NvbnRleHQqIGN0eCwgaW50NjRfdCogcHZhbCwgSlNBdG9tIGF0b20pOwpCT09MIGpzX2F0b21faXNfbGVuZ3RoKEpTQ29udGV4dCogY3R4LCBKU0F0b20gYXRvbSk7Cgpjb25zdCBjaGFyKiBqc19vYmplY3RfdG9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CmNvbnN0IGNoYXIqIGpzX2Z1bmN0aW9uX25hbWUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CmNvbnN0IGNoYXIqIGpzX2Z1bmN0aW9uX3Rvc3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwpCT09MIGpzX2Z1bmN0aW9uX2lzbmF0aXZlKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwppbnQganNfZnVuY3Rpb25fYXJnYyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKCmNoYXIqIGpzX29iamVjdF9jbGFzc25hbWUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CmludCBqc19vYmplY3RfaXMoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSwgY29uc3QgY2hhciogY21wKTsKSlNWYWx1ZSBqc19vYmplY3RfY29uc3RydWN0KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgY3Rvcik7CkpTVmFsdWUganNfb2JqZWN0X2Vycm9yKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBtZXNzYWdlKTsKSlNWYWx1ZSBqc19vYmplY3Rfc3RhY2soSlNDb250ZXh0KiBjdHgpOwpKU1ZhbHVlIGpzX29iamVjdF9uZXcoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIGNsYXNzX25hbWUsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKTsKCnN0YXRpYyBpbmxpbmUgQk9PTApqc19vYmplY3Rfc2FtZShKU1ZhbHVlQ29uc3QgYSwgSlNWYWx1ZUNvbnN0IGIpIHsKICBKU09iamVjdCAqYW9iaiwgKmJvYmo7CiAgaWYoIUpTX0lzT2JqZWN0KGEpIHx8ICFKU19Jc09iamVjdChiKSkKICAgIHJldHVybiBGQUxTRTsKCiAgYW9iaiA9IEpTX1ZBTFVFX0dFVF9PQkooYSk7CiAgYm9iaiA9IEpTX1ZBTFVFX0dFVF9PQkooYik7CiAgcmV0dXJuIGFvYmogPT0gYm9iajsKfQoKc3RhdGljIGlubGluZSBKU0NsYXNzSUQKanNfZ2V0X2NsYXNzaWQoSlNWYWx1ZSB2KSB7CiAgSlNPYmplY3QqIHA7CiAgLyogaWYoSlNfVkFMVUVfR0VUX1RBRyh2KSAhPSBKU19UQUdfT0JKRUNUKQogICAgIHJldHVybiAwOyovCiAgcCA9IEpTX1ZBTFVFX0dFVF9PQkoodik7CiAgYXNzZXJ0KHAgIT0gMCk7CiAgcmV0dXJuIHAtPmNsYXNzX2lkOwp9CgpCT09MIGpzX2hhc19wcm9wZXJ0eXN0cihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgY29uc3QgY2hhciogc3RyKTsKQk9PTCBqc19nZXRfcHJvcGVydHlzdHJfYm9vbChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgY29uc3QgY2hhciogc3RyKTsKdm9pZCBqc19zZXRfcHJvcGVydHlpbnRfc3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCB1aW50MzJfdCBpLCBjb25zdCBjaGFyKiBzdHIpOwp2b2lkIGpzX3NldF9wcm9wZXJ0eWludF9pbnQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIHVpbnQzMl90IGksIGludDMyX3QgdmFsdWUpOwp2b2lkIGpzX3NldF9wcm9wZXJ0eXN0cl9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3AsIGNvbnN0IGNoYXIqIHN0cik7CnZvaWQganNfc2V0X3Byb3BlcnR5c3RyX3N0cmluZ2xlbihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgY29uc3QgY2hhciogcHJvcCwgY29uc3QgY2hhciogc3RyLCBzaXplX3QgbGVuKTsKY29uc3QgY2hhcioganNfZ2V0X3Byb3BlcnR5aW50X2NzdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIHVpbnQzMl90IGkpOwppbnQzMl90IGpzX2dldF9wcm9wZXJ0eWludF9pbnQzMihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgdWludDMyX3QgaSk7CmNvbnN0IGNoYXIqIGpzX2dldF9wcm9wZXJ0eXN0cl9jc3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBjb25zdCBjaGFyKiBwcm9wKTsKY29uc3QgY2hhcioganNfZ2V0X3Byb3BlcnR5c3RyX2NzdHJpbmdsZW4oSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3AsIHNpemVfdCogbGVucCk7CmNoYXIqIGpzX2dldF9wcm9wZXJ0eXN0cl9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3ApOwpjaGFyKiBqc19nZXRfcHJvcGVydHlzdHJfc3RyaW5nbGVuKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBjb25zdCBjaGFyKiBwcm9wLCBzaXplX3QqIGxlbnApOwppbnQzMl90IGpzX2dldF9wcm9wZXJ0eXN0cl9pbnQzMihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgY29uc3QgY2hhciogcHJvcCk7CnVpbnQ2NF90IGpzX2dldF9wcm9wZXJ0eXN0cl91aW50NjQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3ApOwppbnQganNfZ2V0X3Byb3BlcnR5ZGVzY3JpcHRvcihKU0NvbnRleHQqIGN0eCwgSlNQcm9wZXJ0eURlc2NyaXB0b3IqIGRlc2MsIEpTVmFsdWVDb25zdCBvYmosIEpTQXRvbSBwcm9wKTsKCnN0YXRpYyBpbmxpbmUgdm9pZApqc19zZXRfaW5zcGVjdF9tZXRob2QoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIEpTQ0Z1bmN0aW9uKiBmdW5jKSB7CiAgSlNBdG9tIGluc3BlY3Rfc3ltYm9sID0ganNfc3ltYm9sX2Zvcl9hdG9tKGN0eCwgInF1aWNranMuaW5zcGVjdC5jdXN0b20iKTsKICBKU19EZWZpbmVQcm9wZXJ0eVZhbHVlKGN0eCwgb2JqLCBpbnNwZWN0X3N5bWJvbCwgSlNfTmV3Q0Z1bmN0aW9uKGN0eCwgZnVuYywgImluc3BlY3QiLCAxKSwgSlNfUFJPUF9DT05GSUdVUkFCTEUgfCBKU19QUk9QX1dSSVRBQkxFKTsKICBKU19GcmVlQXRvbShjdHgsIGluc3BlY3Rfc3ltYm9sKTsKfQoKc3RhdGljIGlubGluZSB2b2lkCmpzX3NldF90b3N0cmluZ3RhZ192YWx1ZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgSlNWYWx1ZSB2YWx1ZSkgewogIEpTQXRvbSB0b3N0cmluZ190YWcgPSBqc19zeW1ib2xfc3RhdGljX2F0b20oY3R4LCAidG9TdHJpbmdUYWciKTsKICBKU19EZWZpbmVQcm9wZXJ0eVZhbHVlKGN0eCwgb2JqLCB0b3N0cmluZ190YWcsIHZhbHVlLCBKU19QUk9QX0NPTkZJR1VSQUJMRSB8IEpTX1BST1BfV1JJVEFCTEUpOwogIEpTX0ZyZWVBdG9tKGN0eCwgdG9zdHJpbmdfdGFnKTsKfQoKc3RhdGljIGlubGluZSB2b2lkCmpzX3NldF90b3N0cmluZ3RhZ19zdHIoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHN0cikgewogIGpzX3NldF90b3N0cmluZ3RhZ192YWx1ZShjdHgsIG9iaiwgSlNfTmV3U3RyaW5nKGN0eCwgc3RyKSk7Cn0KCkpTQ2xhc3NJRCBqc19jbGFzc19pZChKU0NvbnRleHQqIGN0eCwgaW50IGlkKTsKSlNDbGFzc0lEIGpzX2NsYXNzX25ld2lkKHZvaWQpOwpKU0NsYXNzKiBqc19jbGFzc19nZXQoSlNDb250ZXh0KiBjdHgsIEpTQ2xhc3NJRCBpZCk7CkpTQXRvbSBqc19jbGFzc19hdG9tKEpTQ29udGV4dCogY3R4LCBKU0NsYXNzSUQgaWQpOwpjb25zdCBjaGFyKiBqc19jbGFzc19uYW1lKEpTQ29udGV4dCogY3R4LCBKU0NsYXNzSUQgaWQpOwoKc3RhdGljIGlubGluZSBCT09MCmpzX29iamVjdF9pc2NsYXNzKEpTVmFsdWUgb2JqLCBpbnQzMl90IGNsYXNzX2lkKSB7CiAgcmV0dXJuIEpTX0dldE9wYXF1ZShvYmosIGNsYXNzX2lkKSAhPSAwOwp9CgpzdGF0aWMgaW5saW5lIEJPT0wKanNfdmFsdWVfaXNjbGFzcyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZSBvYmosIGludCBpZCkgewogIGludDMyX3QgY2xhc3NfaWQgPSBqc19jbGFzc19pZChjdHgsIGlkKTsKICByZXR1cm4ganNfb2JqZWN0X2lzY2xhc3Mob2JqLCBjbGFzc19pZCk7Cn0KCkJPT0wganNfaXNfYXJyYXlidWZmZXIoSlNDb250ZXh0KiwgSlNWYWx1ZUNvbnN0KTsKQk9PTCBqc19pc19zaGFyZWRhcnJheWJ1ZmZlcihKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QpOwpCT09MIGpzX2lzX21hcChKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QpOwpCT09MIGpzX2lzX3NldChKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QpOwpCT09MIGpzX2lzX2dlbmVyYXRvcihKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QpOwpCT09MIGpzX2lzX3JlZ2V4cChKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QpOwpCT09MIGpzX2lzX3Byb21pc2UoSlNDb250ZXh0KiwgSlNWYWx1ZUNvbnN0KTsKQk9PTCBqc19pc19kYXRhdmlldyhKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QpOwoKc3RhdGljIGlubGluZSBCT09MCmpzX2lzX251bGxfb3JfdW5kZWZpbmVkKEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIHJldHVybiBKU19Jc1VuZGVmaW5lZCh2YWx1ZSkgfHwgSlNfSXNOdWxsKHZhbHVlKTsKfQoKc3RhdGljIGlubGluZSBCT09MCmpzX2lzX2ZhbHNpc2goSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgc3dpdGNoKEpTX1ZBTFVFX0dFVF9UQUcodmFsdWUpKSB7CiAgICBjYXNlIEpTX1RBR19OVUxMOiByZXR1cm4gVFJVRTsKICAgIGNhc2UgSlNfVEFHX1VOREVGSU5FRDogcmV0dXJuIFRSVUU7CiAgICBjYXNlIEpTX1RBR19JTlQ6IHJldHVybiBKU19WQUxVRV9HRVRfSU5UKHZhbHVlKSA9PSAwOwogICAgY2FzZSBKU19UQUdfQk9PTDogcmV0dXJuICFKU19WQUxVRV9HRVRfQk9PTCh2YWx1ZSk7CiAgICBjYXNlIEpTX1RBR19GTE9BVDY0OiByZXR1cm4gSlNfVkFMVUVfR0VUX0ZMT0FUNjQodmFsdWUpID09IDA7CiAgICBkZWZhdWx0OiByZXR1cm4gRkFMU0U7CiAgfQp9CgpzdGF0aWMgaW5saW5lIEJPT0wKanNfaXNfdHJ1aXNoKEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIHJldHVybiAhanNfaXNfZmFsc2lzaCh2YWx1ZSk7Cn0KCnN0YXRpYyBpbmxpbmUgQk9PTApqc19pc19udWxsaXNoKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBpbnQ2NF90IGkgPSAtMTsKCiAgaWYoSlNfSXNVbmRlZmluZWQodmFsdWUpIHx8IEpTX0lzTnVsbCh2YWx1ZSkpCiAgICByZXR1cm4gVFJVRTsKICBKU19Ub0ludDY0KGN0eCwgJmksIHZhbHVlKTsKICByZXR1cm4gaSA9PSAwOwp9CgpKU1ZhbHVlIGpzX3R5cGVkYXJyYXlfcHJvdG90eXBlKEpTQ29udGV4dCogY3R4KTsKSlNWYWx1ZSBqc190eXBlZGFycmF5X2NvbnN0cnVjdG9yKEpTQ29udGV4dCogY3R4KTsKCnN0YXRpYyBpbmxpbmUgQk9PTApqc19pc19iYXNpY19hcnJheShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgSlNWYWx1ZSBjdG9yID0ganNfZ2xvYmFsX2dldChjdHgsICJBcnJheSIpOwogIEJPT0wgcmV0ID0gSlNfSXNJbnN0YW5jZU9mKGN0eCwgdmFsdWUsIGN0b3IpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGN0b3IpOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgQk9PTApqc19pc190eXBlZGFycmF5KEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIGlmKEpTX0lzT2JqZWN0KHZhbHVlKSkgewogICAgSlNDbGFzc0lEIGlkID0ganNfZ2V0X2NsYXNzaWQodmFsdWUpOwogICAgcmV0dXJuIGlkID49IEpTX0NMQVNTX1VJTlQ4Q19BUlJBWSAmJiBpZCA8PSBKU19DTEFTU19GTE9BVDY0X0FSUkFZOwogIH0KICByZXR1cm4gRkFMU0U7Cn0KCnN0YXRpYyBpbmxpbmUgQk9PTApqc19pc19hcnJheShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgcmV0dXJuIEpTX0lzQXJyYXkoY3R4LCB2YWx1ZSkgfHwganNfaXNfdHlwZWRhcnJheSh2YWx1ZSk7Cn0KCkJPT0wganNfaXNfaW5wdXQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CgppbnQganNfcHJvcGVudW1fY21wKGNvbnN0IHZvaWQqIGEsIGNvbnN0IHZvaWQqIGIsIHZvaWQqIHB0cik7CkJPT0wganNfb2JqZWN0X2VxdWFscyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IGEsIEpTVmFsdWVDb25zdCBiKTsKaW50NjRfdCBqc19hcnJheV9sZW5ndGgoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBhcnJheSk7CnZvaWQganNfYXJyYXlfY2xlYXIoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBhcnJheSk7CgpzaXplX3QganNfc3Rydl9sZW5ndGgoY2hhcioqIHN0cnYpOwoKY2hhcioqIGpzX3N0cnZfZHVwKEpTQ29udGV4dCogY3R4LCBjaGFyKiogc3Rydik7Cgp2b2lkIGpzX3N0cnZfZnJlZV9uKEpTQ29udGV4dCosIGludCwgY2hhciogYXJndltdKTsKdm9pZCBqc19zdHJ2X2ZyZWUoSlNDb250ZXh0KiBjdHgsIGNoYXIqKiBzdHJ2KTsKdm9pZCBqc19zdHJ2X2ZyZWVfcnQoSlNSdW50aW1lKiBydCwgY2hhcioqIHN0cnYpOwpKU1ZhbHVlIGpzX3N0cnZfdG9fYXJyYXkoSlNDb250ZXh0KiBjdHgsIGNoYXIqKiBzdHJ2KTsKSlNWYWx1ZSBqc19pbnR2X3RvX2FycmF5KEpTQ29udGV4dCogY3R4LCBpbnQqIGludHYpOwpjaGFyKioganNfYXJyYXlfdG9fYXJndihKU0NvbnRleHQqIGN0eCwgaW50KiBhcmdjcCwgSlNWYWx1ZUNvbnN0IGFycmF5KTsKaW50IGpzX2FycmF5X2NvcHlzKEpTQ29udGV4dCosIEpTVmFsdWVDb25zdCwgaW50IG4sIGNoYXIqKiBzdHJhKTsKaW50IGpzX3N0cnZfY29weXMoSlNDb250ZXh0KiwgaW50LCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbiwgY2hhcioqIHN0cmEpOwoKSlNWYWx1ZSBqc19pbnZva2UoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX29iaiwgY29uc3QgY2hhciogbWV0aG9kLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSk7CgpzdGF0aWMgaW5saW5lIHNpemVfdApqc19hcnJheWJ1ZmZlcl9sZW5ndGgoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBidWZmZXIpIHsKICB1aW50OF90KiBwdHI7CiAgc2l6ZV90IGxlbjsKCiAgaWYoSlNfR2V0QXJyYXlCdWZmZXIoY3R4LCAmbGVuLCBidWZmZXIpKQogICAgcmV0dXJuIGxlbjsKICByZXR1cm4gMDsKfQoKaW50NjRfdCBqc19hcnJheWJ1ZmZlcl9ieXRlbGVuZ3RoKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwoKc3RhdGljIGlubGluZSBpbnQKanNfZmluZF9jZnVuY3Rpb25fZW50cnkoY29uc3QgSlNDRnVuY3Rpb25MaXN0RW50cnkqIGVudHJpZXMsIHNpemVfdCBuX2VudHJpZXMsIGNvbnN0IGNoYXIqIG5hbWUsIGludCBkZWZfdHlwZSkgewogIHNpemVfdCBpOwogIGZvcihpID0gMDsgaSA8IG5fZW50cmllczsgaSsrKQogICAgaWYoZW50cmllc1tpXS5kZWZfdHlwZSA9PSBkZWZfdHlwZSAmJiAhc3RyY21wKGVudHJpZXNbaV0ubmFtZSwgbmFtZSkpCiAgICAgIHJldHVybiBpOwogIHJldHVybiAtMTsKfQoKc3RhdGljIGlubGluZSBpbnQKanNfZmluZF9jZnVuY3Rpb25fYXRvbShKU0NvbnRleHQqIGN0eCwgY29uc3QgSlNDRnVuY3Rpb25MaXN0RW50cnkqIGVudHJpZXMsIHNpemVfdCBuX2VudHJpZXMsIEpTQXRvbSBhdG9tLCBpbnQgZGVmX3R5cGUpIHsKICBjb25zdCBjaGFyKiBuYW1lID0gSlNfQXRvbVRvQ1N0cmluZyhjdHgsIGF0b20pOwogIGludCBpOwogIGkgPSBqc19maW5kX2NmdW5jdGlvbl9lbnRyeShlbnRyaWVzLCBuX2VudHJpZXMsIG5hbWUsIGRlZl90eXBlKTsKICBKU19GcmVlQ1N0cmluZyhjdHgsIG5hbWUpOwogIHJldHVybiBpOwp9CgpKU1ZhbHVlIGpzX2RhdGVfbmV3KEpTQ29udGV4dCosIEpTVmFsdWUgYXJnKTsKSlNWYWx1ZSBqc19kYXRlX2Zyb21fbXMoSlNDb250ZXh0KiwgaW50NjRfdCBtcyk7CkpTVmFsdWUganNfZGF0ZV9mcm9tX3RpbWVfbnMoSlNDb250ZXh0KiwgdGltZV90IHQsIGxvbmcgbnMpOwpKU1ZhbHVlIGpzX2RhdGVfZnJvbV90aW1lc3BlYyhKU0NvbnRleHQqLCBjb25zdCBzdHJ1Y3QgdGltZXNwZWMgdHMpOwppbnQ2NF90IGpzX2RhdGVfZ2V0dGltZShKU0NvbnRleHQqLCBKU1ZhbHVlIGFyZyk7CmludDY0X3QganNfZGF0ZV90aW1lKEpTQ29udGV4dCosIEpTVmFsdWUgYXJnKTsKc3RydWN0IHRpbWVzcGVjIGpzX2RhdGVfdGltZXNwZWMoSlNDb250ZXh0KiwgSlNWYWx1ZSBhcmcpOwoKdm9pZCBqc19hcnJheWJ1ZmZlcl9mcmVldmFsdWUoSlNSdW50aW1lKiwgdm9pZCogb3BhcXVlLCB2b2lkKiBwdHIpOwpKU1ZhbHVlIGpzX2FycmF5YnVmZmVyX2Zyb212YWx1ZShKU0NvbnRleHQqLCAgIHZvaWQqIHgsIHNpemVfdCBuLCBKU1ZhbHVlIHZhbCk7CgpKU1ZhbHVlIGpzX21hcF9uZXcoSlNDb250ZXh0KiwgSlNWYWx1ZUNvbnN0KTsKCnR5cGVkZWYgdW5pb24gaW1wb3J0X2RpcmVjdGl2ZSB7CiAgc3RydWN0IHsKICAgIGNvbnN0IGNoYXIqIHBhdGg7IC8qKjwgTW9kdWxlIHBhdGggKi8KICAgIGNvbnN0IGNoYXIqIHNwZWM7IC8qKjwgSW1wb3J0IHNwZWNpZmllcihzKSAqLwogICAgY29uc3QgY2hhciogcHJvcDsgLyoqPCBpZiAhPSAwICYmICpwcm9wLCBucyArPSAiLiIgKyBwcm9wICovCiAgICBjb25zdCBjaGFyKiB2YXI7ICAvKio8IEdsb2JhbCB2YXJpYWJsZSBuYW1lICovCiAgICBjb25zdCBjaGFyKiBuczsgICAvKio8IE5hbWVzcGFjZSB2YXJpYWJsZSAqLwogIH07CiAgY29uc3QgY2hhciogYXJnc1s1XTsKfSBJbXBvcnREaXJlY3RpdmU7CgpKU1ZhbHVlIG1vZHVsZV9uYW1lKEpTQ29udGV4dCosIEpTTW9kdWxlRGVmKik7CmNoYXIqIG1vZHVsZV9uYW1lc3RyKEpTQ29udGV4dCosIEpTTW9kdWxlRGVmKik7CkpTVmFsdWUgbW9kdWxlX2Z1bmMoSlNDb250ZXh0KiwgSlNNb2R1bGVEZWYqKTsKSlNWYWx1ZSBtb2R1bGVfbnMoSlNDb250ZXh0KiwgSlNNb2R1bGVEZWYqKTsKdm9pZCBnZXRfbW9kdWxlX2V4cG9ydHMoSlNDb250ZXh0KiwgSlNNb2R1bGVEZWYqLCBCT09MIHJlbmFtZV9kZWZhdWx0LCBKU1ZhbHVlQ29uc3QgZXhwb3J0cyk7CkpTVmFsdWUgbW9kdWxlX2V4cG9ydHMoSlNDb250ZXh0KiwgSlNNb2R1bGVEZWYqKTsKc3RydWN0IGxpc3RfaGVhZCoganNfbW9kdWxlc19saXN0KEpTQ29udGV4dCopOwpKU1ZhbHVlIGpzX21vZHVsZXNfYXJyYXkoSlNDb250ZXh0KiwgSlNWYWx1ZUNvbnN0LCBpbnQgbWFnaWMpOwpKU1ZhbHVlIGpzX21vZHVsZXNfZW50cmllcyhKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QsIGludCBtYWdpYyk7CkpTVmFsdWUganNfbW9kdWxlc19tYXAoSlNDb250ZXh0KiwgSlNWYWx1ZUNvbnN0LCBpbnQgbWFnaWMpOwpKU1ZhbHVlIGpzX21vZHVsZXNfb2JqZWN0KEpTQ29udGV4dCosIEpTVmFsdWVDb25zdCwgaW50IG1hZ2ljKTsKSlNWYWx1ZSBtb2R1bGVfdmFsdWUoSlNDb250ZXh0KiwgSlNNb2R1bGVEZWYqKTsKSlNWYWx1ZSBtb2R1bGVfZW50cnkoSlNDb250ZXh0KiwgSlNNb2R1bGVEZWYqKTsKSlNWYWx1ZSBtb2R1bGVfb2JqZWN0KEpTQ29udGV4dCosIEpTTW9kdWxlRGVmKik7CmNoYXIqIGpzX21vZHVsZV9zZWFyY2goSlNDb250ZXh0KiwgIGNvbnN0IGNoYXIqIHBhdGgsIGNvbnN0IGNoYXIqKTsKY2hhcioganNfbW9kdWxlX3NlYXJjaF9leHQoSlNDb250ZXh0KiwgY29uc3QgY2hhciogcGF0aCwgY29uc3QgY2hhciosIGNvbnN0IGNoYXIqIGV4dCk7CmNoYXIqIGpzX21vZHVsZV9ub3JtYWxpemUoSlNDb250ZXh0KiwgY29uc3QgY2hhciosIGNvbnN0IGNoYXIqIG5hbWUsIHZvaWQqIG9wYXF1ZSk7CkpTTW9kdWxlRGVmKiBqc19tb2R1bGVfZGVmKEpTQ29udGV4dCosIEpTVmFsdWVDb25zdCk7CkpTTW9kdWxlRGVmKiBqc19tb2R1bGVfZmluZChKU0NvbnRleHQqLCBjb25zdCBjaGFyKik7CkpTVmFsdWUganNfaW1wb3J0X2V2YWwoSlNDb250ZXh0KiwgSW1wb3J0RGlyZWN0aXZlKTsKSlNNb2R1bGVEZWYqIGpzX21vZHVsZV9pbXBvcnRfZGVmYXVsdChKU0NvbnRleHQqLCBjb25zdCBjaGFyKiwgY29uc3QgY2hhciogdmFyKTsKSlNNb2R1bGVEZWYqIGpzX21vZHVsZV9pbXBvcnRfbmFtZXNwYWNlKEpTQ29udGV4dCosIGNvbnN0IGNoYXIqLCBjb25zdCBjaGFyKiBucyk7CkpTVmFsdWUganNfbW9kdWxlX2ltcG9ydChKU0NvbnRleHQqLCBjb25zdCBjaGFyKiwgY29uc3QgY2hhciogbnMsIGNvbnN0IGNoYXIqIHZhciwgY29uc3QgY2hhciogcHJvcCk7CkpTTW9kdWxlRGVmKiBqc19tb2R1bGVfbG9hZGVyX3NvKEpTQ29udGV4dCosIGNvbnN0IGNoYXIqKTsKCkpTVmFsdWUganNfZXZhbF9tb2R1bGUoSlNDb250ZXh0KiwgSlNWYWx1ZSwgQk9PTCBsb2FkX29ubHkpOwpKU1ZhbHVlIGpzX2V2YWxfYmluYXJ5KEpTQ29udGV4dCosIGNvbnN0IHVpbnQ4X3QqLCBzaXplX3QgYnVmX2xlbiwgQk9PTCBsb2FkX29ubHkpOwpKU1ZhbHVlIGpzX2V2YWxfYnVmKEpTQ29udGV4dCosIGNvbnN0IHZvaWQqLCBpbnQgYnVmX2xlbiwgY29uc3QgY2hhciogZmlsZW5hbWUsIGludCBldmFsX2ZsYWdzKTsKaW50IGpzX2V2YWxfc3RyKEpTQ29udGV4dCosIGNvbnN0IGNoYXIqLCBjb25zdCBjaGFyKiBmaWxlLCBpbnQgZmxhZ3MpOwoKaW50NjRfdCBqc190aW1lX21zKHZvaWQpOwppbnQganNfaW50ZXJydXB0X2hhbmRsZXIoSlNSdW50aW1lKiwgdm9pZCopOwoKdm9pZCBqc190aW1lcl91bmxpbmsoSlNSdW50aW1lKiwgSlNPU1RpbWVyKik7CnZvaWQganNfdGltZXJfZnJlZShKU1J1bnRpbWUqLCBKU09TVGltZXIqKTsKCnZvaWQganNfY2FsbF9oYW5kbGVyKEpTQ29udGV4dCosIEpTVmFsdWUpOwoKdm9pZCoganNfc2FiX2FsbG9jKHZvaWQqLCBzaXplX3QpOwp2b2lkIGpzX3NhYl9mcmVlKHZvaWQqLCB2b2lkKik7CnZvaWQganNfc2FiX2R1cCh2b2lkKiwgdm9pZCopOwoKSlNXb3JrZXJNZXNzYWdlUGlwZSoganNfbmV3X21lc3NhZ2VfcGlwZSh2b2lkKTsKSlNXb3JrZXJNZXNzYWdlUGlwZSoganNfZHVwX21lc3NhZ2VfcGlwZShKU1dvcmtlck1lc3NhZ2VQaXBlKik7Cgp2b2lkIGpzX2ZyZWVfbWVzc2FnZShKU1dvcmtlck1lc3NhZ2UqKTsKdm9pZCBqc19mcmVlX21lc3NhZ2VfcGlwZShKU1dvcmtlck1lc3NhZ2VQaXBlKik7Cgp2b2lkIGpzX2Vycm9yX2R1bXAoSlNDb250ZXh0KiwgSlNWYWx1ZSwgRHluQnVmKiBkYik7CmNoYXIqIGpzX2Vycm9yX3Rvc3RyaW5nKEpTQ29udGV4dCosIEpTVmFsdWUpOwp2b2lkIGpzX2Vycm9yX3ByaW50KEpTQ29udGV4dCosIEpTVmFsdWUpOwoKI2VuZGlmIC8qIGRlZmluZWQoVVRJTFNfSCkgKi8KAAAAAAAAAAAXfAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAFXEAAAAAAAAXcQAAAAAAAAAAAAAAAPC/"
				],
				[
					2,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAXfAAAI2lmbmRlZiBVVElMU19ICiNkZWZpbmUgVVRJTFNfSAoKI2luY2x1ZGUgInF1aWNranMuaCIKI2luY2x1ZGUgInF1aWNranMtaW50ZXJuYWwuaCIKI2luY2x1ZGUgImN1dGlscy5oIgojaW5jbHVkZSA8c3RyaW5nLmg+CiNpbmNsdWRlIDxtYXRoLmg+CiNpbmNsdWRlIDxzdHJpbmcuaD4KI2luY2x1ZGUgPHN0ZGxpYi5oPgojaW5jbHVkZSA8YXNzZXJ0Lmg+CiNpZmRlZiBIQVZFX1RIUkVBRFNfSAojaW5jbHVkZSA8dGhyZWFkcy5oPgojZW5kaWYKCiNpZm5kZWYgb2Zmc2V0b2YKI2RlZmluZSBvZmZzZXRvZih0eXBlLCBmaWVsZCkgKChzaXplX3QpICYgKCh0eXBlKikwKS0+ZmllbGQpCiNlbmRpZgoKI2lmbmRlZiBpbnJhbmdlCiNkZWZpbmUgaW5yYW5nZSh2YWx1ZSwgbWluLCBtYXgpICgodmFsdWUpID49IChtaW4pICYmICh2YWx1ZSkgPD0gKG1heCkpCiNlbmRpZgoKI2RlZmluZSB0cmltX2RvdHNsYXNoKHN0cikgKCFzdHJuY21wKChzdHIpLCAiLi8iLCAyKSA/IChzdHIpICsgMiA6IChzdHIpKQoKI2lmbmRlZiB0aHJlYWRfbG9jYWwKI2lmZGVmIF9UaHJlYWRfbG9jYWwKI2RlZmluZSB0aHJlYWRfbG9jYWwgX1RocmVhZF9sb2NhbAojZWxpZiBkZWZpbmVkKF9fR05VQ19fKSB8fCBkZWZpbmVkKF9fSU5URUxfQ09NUElMRVIpIHx8IGRlZmluZWQoX19TVU5QUk9fQ0MpIHx8IGRlZmluZWQoX19JQk1DUFBfXykKI2RlZmluZSB0aHJlYWRfbG9jYWwgX190aHJlYWQKI2VsaWYgZGVmaW5lZChfV0lOMzIpCiNkZWZpbmUgdGhyZWFkX2xvY2FsIF9fZGVjbHNwZWModGhyZWFkKQojZWxzZQojZXJyb3IgTm8gVExTIGltcGxlbWVudGF0aW9uIGZvdW5kLgojZW5kaWYKI2VuZGlmCgp0eXBlZGVmIGVudW0gcHJlY2VkZW5jZSB7CiAgUFJFQ0VERU5DRV9DT01NQV9TRVFVRU5DRSA9IDEsCiAgUFJFQ0VERU5DRV9ZSUVMRCwKICBQUkVDRURFTkNFX0FTU0lHTk1FTlQsCiAgUFJFQ0VERU5DRV9URVJOQVJZLAogIFBSRUNFREVOQ0VfTlVMTElTSF9DT0FMRVNDSU5HLAogIFBSRUNFREVOQ0VfTE9HSUNBTF9PUiwKICBQUkVDRURFTkNFX0xPR0lDQUxfQU5ELAogIFBSRUNFREVOQ0VfQklUV0lTRV9PUiwKICBQUkVDRURFTkNFX0JJVFdJU0VfWE9SLAogIFBSRUNFREVOQ0VfQklUV0lTRV9BTkQsCiAgUFJFQ0VERU5DRV9FUVVBTElUWSwKICBQUkVDRURFTkNFX0xFU1NfR1JFQVRFUl9JTiwKICBQUkVDRURFTkNFX0JJVFdJU0VfU0hJRlQsCiAgUFJFQ0VERU5DRV9BRERJVElWRSwKICBQUkVDRURFTkNFX01VTFRJUExJQ0FUSVZFLAogIFBSRUNFREVOQ0VfRVhQT05FTlRJQVRJT04sCiAgUFJFQ0VERU5DRV9VTkFSWSwKICBQUkVDRURFTkNFX1BPU1RGSVgsCiAgUFJFQ0VERU5DRV9ORVcsCiAgUFJFQ0VERU5DRV9NRU1CRVJfQUNDRVNTLAogIFBSRUNFREVOQ0VfR1JPVVBJTkcsCn0gSlNQcmVjZWRlbmNlOwoKI2RlZmluZSBKU19DR0VUU0VUX0VOVU1FUkFCTEVfREVGKHByb3BfbmFtZSwgZmdldHRlciwgZnNldHRlciwgbWFnaWNfbnVtKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgLm5hbWUgPSBwcm9wX25hbWUsIC5wcm9wX2ZsYWdzID0gSlNfUFJPUF9FTlVNRVJBQkxFIHwgSlNfUFJPUF9DT05GSUdVUkFCTEUsIC5kZWZfdHlwZSA9IEpTX0RFRl9DR0VUU0VUX01BR0lDLCAubWFnaWMgPSBtYWdpY19udW0sIC51ID0geyAgICAgICAgIFwKICAgICAgLmdldHNldCA9IHsuZ2V0ID0gey5nZXR0ZXJfbWFnaWMgPSBmZ2V0dGVyfSwgLnNldCA9IHsuc2V0dGVyX21hZ2ljID0gZnNldHRlcn19ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIH0KCiNkZWZpbmUgSlNfQ0dFVFNFVF9NQUdJQ19GTEFHU19ERUYocHJvcF9uYW1lLCBmZ2V0dGVyLCBmc2V0dGVyLCBtYWdpY19udW0sIGZsYWdzKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgIC5uYW1lID0gcHJvcF9uYW1lLCAucHJvcF9mbGFncyA9IGZsYWdzLCAuZGVmX3R5cGUgPSBKU19ERUZfQ0dFVFNFVF9NQUdJQywgLm1hZ2ljID0gbWFnaWNfbnVtLCAudSA9IHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICAgIC5nZXRzZXQgPSB7LmdldCA9IHsuZ2V0dGVyX21hZ2ljID0gZmdldHRlcn0sIC5zZXQgPSB7LnNldHRlcl9tYWdpYyA9IGZzZXR0ZXJ9fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICB9CgojZGVmaW5lIEpTX0NGVU5DX0RFRl9GTEFHUyhwcm9wX25hbWUsIGxlbmd0aCwgZnVuYzEsIGZsYWdzKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICAubmFtZSA9IHByb3BfbmFtZSwgLnByb3BfZmxhZ3MgPSBmbGFncywgLmRlZl90eXBlID0gSlNfREVGX0NGVU5DLCAubWFnaWMgPSAwLCAudSA9IHsuZnVuYyA9IHtsZW5ndGgsIEpTX0NGVU5DX2dlbmVyaWMsIHsuZ2VuZXJpYyA9IGZ1bmMxfX0gfSAgICAgXAogIH0KCiNkZWZpbmUgSlNfQ09OU1RBTlQobmFtZSkgSlNfUFJPUF9JTlQzMl9ERUYoI25hbWUsIG5hbWUsIEpTX1BST1BfQ09ORklHVVJBQkxFKQoKI2lmIGRlZmluZWQoX1dJTjMyKSB8fCBkZWZpbmVkKF9fTUlOR1czMl9fKQojZGVmaW5lIFZJU0lCTEUgX19kZWNsc3BlYyhkbGxleHBvcnQpCiNkZWZpbmUgSElEREVOCiNlbHNlCiNkZWZpbmUgVklTSUJMRSBfX2F0dHJpYnV0ZV9fKCh2aXNpYmlsaXR5KCJkZWZhdWx0IikpKQojZGVmaW5lIEhJRERFTiBfX2F0dHJpYnV0ZV9fKCh2aXNpYmlsaXR5KCJoaWRkZW4iKSkpCiNlbmRpZgoKI2lmbmRlZiBNQVhfTlVNCiNkZWZpbmUgTUFYX05VTShhLCBiKSAoKGEpID4gKGIpID8gKGEpIDogKGIpKQojZW5kaWYKI2lmbmRlZiBNSU5fTlVNCiNkZWZpbmUgTUlOX05VTShhLCBiKSAoKGEpIDwgKGIpID8gKGEpIDogKGIpKQojZW5kaWYKCiNkZWZpbmUgSlNfSXNNb2R1bGUodmFsdWUpIChKU19WQUxVRV9HRVRfVEFHKCh2YWx1ZSkpID09IEpTX1RBR19NT0RVTEUpCgpleHRlcm4gVklTSUJMRSBjb25zdCBjaGFyKiBqc19kZWZhdWx0X21vZHVsZV9wYXRoOwoKdHlwZWRlZiBzdHJ1Y3QgewogIEJPT0wgZG9uZTsKICBKU1ZhbHVlIHZhbHVlOwp9IEl0ZXJhdG9yVmFsdWU7Cgp0eXBlZGVmIHN0cnVjdCB7CiAgaW50IGM7CiAgY29uc3QgY2hhcioqIHY7Cn0gQXJndW1lbnRzOwoKc3RhdGljIGlubGluZSBBcmd1bWVudHMKYXJndW1lbnRzX25ldyhpbnQgYXJnYywgY29uc3QgY2hhciogYXJndltdKSB7CiAgQXJndW1lbnRzIGFyZ3M7CiAgYXJncy5jID0gYXJnYzsKICBhcmdzLnYgPSBhcmd2OwogIHJldHVybiBhcmdzOwp9CgpzdGF0aWMgaW5saW5lIGNvbnN0IGNoYXIqCmFyZ3VtZW50c19zaGlmdChBcmd1bWVudHMqIGFyZ3MpIHsKICBjb25zdCBjaGFyKiByZXQgPSAwOwogIGlmKGFyZ3MtPmMgPiAwKSB7CiAgICByZXQgPSBhcmdzLT52WzBdOwogICAgYXJncy0+Yy0tOwogICAgYXJncy0+disrOwogIH0KICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW5saW5lIGNvbnN0IGNoYXIqCmFyZ3VtZW50c19hdChBcmd1bWVudHMqIGFyZ3MsIGludCBpKSB7CiAgcmV0dXJuIGkgPj0gMCAmJiBpIDwgYXJncy0+YyA/IGFyZ3MtPnZbaV0gOiAwOwp9CgpzdGF0aWMgaW5saW5lIHVpbnQzMl90CmFyZ3VtZW50c19zaGlmdG4oQXJndW1lbnRzKiBhcmdzLCB1aW50MzJfdCBuKSB7CiAgdWludDMyX3QgaSA9IDA7CgogIHdoaWxlKG4gPiAwKSB7CiAgICBpZighYXJndW1lbnRzX3NoaWZ0KGFyZ3MpKQogICAgICBicmVhazsKICAgIGkrKzsKICAgIG4tLTsKICB9CiAgcmV0dXJuIGk7Cn0KCnR5cGVkZWYgc3RydWN0IHsKICBpbnQgYzsKICBKU1ZhbHVlQ29uc3QqIHY7Cn0gSlNBcmd1bWVudHM7CgpzdGF0aWMgaW5saW5lIEpTQXJndW1lbnRzCmpzX2FyZ3VtZW50c19uZXcoaW50IGFyZ2MsIEpTVmFsdWVDb25zdCogYXJndikgewogIEpTQXJndW1lbnRzIGFyZ3M7CiAgYXJncy5jID0gYXJnYzsKICBhcmdzLnYgPSBhcmd2OwogIHJldHVybiBhcmdzOwp9CgpzdGF0aWMgaW5saW5lIEpTVmFsdWVDb25zdApqc19hcmd1bWVudHNfc2hpZnQoSlNBcmd1bWVudHMqIGFyZ3MpIHsKICBKU1ZhbHVlIHJldCA9IEpTX0VYQ0VQVElPTjsKICBpZihhcmdzLT5jID4gMCkgewogICAgcmV0ID0gYXJncy0+dlswXTsKICAgIGFyZ3MtPmMtLTsKICAgIGFyZ3MtPnYrKzsKICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBKU1ZhbHVlQ29uc3QKanNfYXJndW1lbnRzX2F0KEpTQXJndW1lbnRzKiBhcmdzLCBpbnQgaSkgewogIHJldHVybiBpID49IDAgJiYgaSA8IGFyZ3MtPmMgPyBhcmdzLT52W2ldIDogSlNfVU5ERUZJTkVEOwp9CgpzdGF0aWMgaW5saW5lIHVpbnQzMl90CmpzX2FyZ3VtZW50c19zaGlmdG4oSlNBcmd1bWVudHMqIGFyZ3MsIHVpbnQzMl90IG4pIHsKICB1aW50MzJfdCBpID0gMDsKCiAgd2hpbGUobiA+IDApIHsKICAgIGlmKEpTX0lzRXhjZXB0aW9uKGpzX2FyZ3VtZW50c19zaGlmdChhcmdzKSkpCiAgICAgIGJyZWFrOwogICAgaSsrOwogICAgbi0tOwogIH0KICByZXR1cm4gaTsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKbWluX3NpemUoc2l6ZV90IGEsIHNpemVfdCBiKSB7CiAgaWYoYSA8IGIpCiAgICByZXR1cm4gYTsKICBlbHNlCiAgICByZXR1cm4gYjsKfQoKc3RhdGljIGlubGluZSB1aW50NjRfdAphYnNfaW50NjQoaW50NjRfdCBhKSB7CiAgcmV0dXJuIGEgPCAwID8gLWEgOiBhOwp9CgpzdGF0aWMgaW5saW5lIHVpbnQzMl90CmFic19pbnQzMihpbnQzMl90IGkpIHsKICByZXR1cm4gaSA8IDAgPyAtaSA6IGk7Cn0KCnN0YXRpYyBpbmxpbmUgaW50MzJfdApzaWduX2ludDMyKHVpbnQzMl90IGkpIHsKICByZXR1cm4gKGkgJiAweDgwMDAwMDAwKSA/IC0xIDogMTsKfQoKc3RhdGljIGlubGluZSBpbnQzMl90Cm1vZF9pbnQzMihpbnQzMl90IGEsIGludDMyX3QgYikgewogIGludDMyX3QgYyA9IGEgJSBiOwogIHJldHVybiAoYyA8IDApID8gYyArIGIgOiBjOwp9CgojZGVmaW5lIENPTE9SX1JFRCAiXHgxYlszMW0iCiNkZWZpbmUgQ09MT1JfR1JFRU4gIlx4MWJbMzJtIgojZGVmaW5lIENPTE9SX1lFTExPVyAiXHgxYlszM20iCiNkZWZpbmUgQ09MT1JfQkxVRSAiXHgxYlszNG0iCiNkZWZpbmUgQ09MT1JfTUFHRU5UQSAiXHgxYlszNW0iCiNkZWZpbmUgQ09MT1JfTUFSSU5FICJceDFiWzM2bSIKI2RlZmluZSBDT0xPUl9MSUdIVEdSQVkgIlx4MWJbMzdtIgojZGVmaW5lIENPTE9SX0dSQVkgIlx4MWJbMTszMG0iCiNkZWZpbmUgQ09MT1JfTk9ORSAiXHgxYlttIgoKI2RlZmluZSBDT0xPUl9MSUdIVFJFRCAiXHgxYlsxOzMxbSIKCiNkZWZpbmUgQ09MT1JfTElHSFRHUkVFTiAiXHgxYlsxOzMybSIKI2RlZmluZSBDT0xPUl9MSUdIVFlFTExPVyAiXHgxYlsxOzMzbSIKI2RlZmluZSBDT0xPUl9MSUdIVEJMVUUgIlx4MWJbMTszNG0iCiNkZWZpbmUgQ09MT1JfTElHSFRNQUdFTlRBICJceDFiWzE7MzVtIgojZGVmaW5lIENPTE9SX0xJR0hUTUFSSU5FICJceDFiWzE7MzZtIgojZGVmaW5lIENPTE9SX1dISVRFICJceDFiWzE7MzdtIgoKdWludDY0X3QgdGltZV91cyh2b2lkKTsKCmludDY0X3QgYXJyYXlfc2VhcmNoKHZvaWQqIGEsIHNpemVfdCBtLCBzaXplX3QgZWxzeiwgdm9pZCogbmVlZGxlKTsKI2RlZmluZSBhcnJheV9jb250YWlucyhhLCBtLCBlbHN6LCBuZWVkbGUpIChhcnJheV9zZWFyY2goKGEpLCAobSksIChlbHN6KSwgKG5lZWRsZSkpICE9IC0xKQoKc3RhdGljIGlubGluZSB2b2lkCmpzX2RidWZfaW5pdF9ydChKU1J1bnRpbWUqIHJ0LCBEeW5CdWYqIHMpIHsKICBkYnVmX2luaXQyKHMsIHJ0LCAoRHluQnVmUmVhbGxvY0Z1bmMqKWpzX3JlYWxsb2NfcnQpOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQKanNfZGJ1Zl9pbml0KEpTQ29udGV4dCogY3R4LCBEeW5CdWYqIHMpIHsKICBkYnVmX2luaXQyKHMsIGN0eCwgKER5bkJ1ZlJlYWxsb2NGdW5jKilqc19yZWFsbG9jKTsKfQoKdHlwZWRlZiBzdHJ1Y3QgewogIGNoYXIqIHNvdXJjZTsKICBzaXplX3QgbGVuOwogIGludCBmbGFnczsKfSBSZWdFeHA7CgppbnQgcmVnZXhwX2ZsYWdzX3Rvc3RyaW5nKGludCwgY2hhciopOwppbnQgcmVnZXhwX2ZsYWdzX2Zyb21zdHJpbmcoY29uc3QgY2hhciopOwpSZWdFeHAgcmVnZXhwX2Zyb21fYXJndihpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSwgSlNDb250ZXh0KiBjdHgpOwpSZWdFeHAgcmVnZXhwX2Zyb21fZGJ1ZihEeW5CdWYqIGRidWYsIGludCBmbGFncyk7CnVpbnQ4X3QqIHJlZ2V4cF9jb21waWxlKFJlZ0V4cCByZSwgSlNDb250ZXh0KiBjdHgpOwpKU1ZhbHVlIHJlZ2V4cF90b192YWx1ZShSZWdFeHAgcmUsIEpTQ29udGV4dCogY3R4KTsKCnN0YXRpYyBpbmxpbmUgdm9pZApyZWdleHBfZnJlZV9ydChSZWdFeHAgcmUsIEpTUnVudGltZSogcnQpIHsKICBqc19mcmVlX3J0KHJ0LCByZS5zb3VyY2UpOwp9CnN0YXRpYyBpbmxpbmUgdm9pZApyZWdleHBfZnJlZShSZWdFeHAgcmUsIEpTQ29udGV4dCogY3R4KSB7CiAgcmVnZXhwX2ZyZWVfcnQocmUsIEpTX0dldFJ1bnRpbWUoY3R4KSk7Cn0KCkpTVmFsdWUganNfZ2xvYmFsX2dldChKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogcHJvcCk7CgpzdGF0aWMgaW5saW5lIEpTVmFsdWUKanNfZ2xvYmFsX25ldyhKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogY2xhc3NfbmFtZSwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10pIHsKICBKU1ZhbHVlIGN0b3IgPSBqc19nbG9iYWxfZ2V0KGN0eCwgY2xhc3NfbmFtZSk7CiAgSlNWYWx1ZSBvYmogPSBKU19DYWxsQ29uc3RydWN0b3IoY3R4LCBjdG9yLCBhcmdjLCBhcmd2KTsKICBKU19GcmVlVmFsdWUoY3R4LCBjdG9yKTsKICByZXR1cm4gb2JqOwp9CgpKU1ZhbHVlIGpzX2dsb2JhbF9wcm90b3R5cGUoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIGNsYXNzX25hbWUpOwoKZW51bSB2YWx1ZV90eXBlcyB7CiAgRkxBR19VTkRFRklORUQgPSAwLAogIEZMQUdfTlVMTCwgICAgICAgIC8vIDEKICBGTEFHX0JPT0wsICAgICAgICAvLyAyCiAgRkxBR19JTlQsICAgICAgICAgLy8gMwogIEZMQUdfT0JKRUNULCAgICAgIC8vIDQKICBGTEFHX1NUUklORywgICAgICAvLyA1CiAgRkxBR19TWU1CT0wsICAgICAgLy8gNgogIEZMQUdfQklHX0ZMT0FULCAgIC8vIDcKICBGTEFHX0JJR19JTlQsICAgICAvLyA4CiAgRkxBR19CSUdfREVDSU1BTCwgLy8gOQogIEZMQUdfRkxPQVQ2NCwgICAgIC8vIDEwCiAgRkxBR19OQU4sICAgICAgICAgLy8gMTEKICBGTEFHX0ZVTkNUSU9OLCAgICAvLyAxMgogIEZMQUdfQVJSQVksICAgICAgIC8vIDEzCiAgRkxBR19NT0RVTEUsCiAgRkxBR19GVU5DVElPTl9CWVRFQ09ERSwKICBGTEFHX1VOSU5JVElBTElaRUQsCiAgRkxBR19DQVRDSF9PRkZTRVQsCiAgRkxBR19FWENFUFRJT04KCn07CgplbnVtIHZhbHVlX21hc2sgewogIFRZUEVfVU5ERUZJTkVEID0gKDEgPDwgRkxBR19VTkRFRklORUQpLAogIFRZUEVfTlVMTCA9ICgxIDw8IEZMQUdfTlVMTCksCiAgVFlQRV9CT09MID0gKDEgPDwgRkxBR19CT09MKSwKICBUWVBFX0lOVCA9ICgxIDw8IEZMQUdfSU5UKSwKICBUWVBFX09CSkVDVCA9ICgxIDw8IEZMQUdfT0JKRUNUKSwKICBUWVBFX1NUUklORyA9ICgxIDw8IEZMQUdfU1RSSU5HKSwKICBUWVBFX1NZTUJPTCA9ICgxIDw8IEZMQUdfU1lNQk9MKSwKICBUWVBFX0JJR19GTE9BVCA9ICgxIDw8IEZMQUdfQklHX0ZMT0FUKSwKICBUWVBFX0JJR19JTlQgPSAoMSA8PCBGTEFHX0JJR19JTlQpLAogIFRZUEVfQklHX0RFQ0lNQUwgPSAoMSA8PCBGTEFHX0JJR19ERUNJTUFMKSwKICBUWVBFX0ZMT0FUNjQgPSAoMSA8PCBGTEFHX0ZMT0FUNjQpLAogIFRZUEVfTkFOID0gKDEgPDwgRkxBR19OQU4pLAogIFRZUEVfTlVNQkVSID0gKFRZUEVfSU5UIHwgVFlQRV9CSUdfRkxPQVQgfCBUWVBFX0JJR19JTlQgfCBUWVBFX0JJR19ERUNJTUFMIHwgVFlQRV9GTE9BVDY0KSwKICBUWVBFX1BSSU1JVElWRSA9CiAgICAgIChUWVBFX1VOREVGSU5FRCB8IFRZUEVfTlVMTCB8IFRZUEVfQk9PTCB8IFRZUEVfSU5UIHwgVFlQRV9TVFJJTkcgfCBUWVBFX1NZTUJPTCB8IFRZUEVfQklHX0ZMT0FUIHwgVFlQRV9CSUdfSU5UIHwgVFlQRV9CSUdfREVDSU1BTCB8IFRZUEVfTkFOKSwKICBUWVBFX0FMTCA9IChUWVBFX1BSSU1JVElWRSB8IFRZUEVfT0JKRUNUKSwKICBUWVBFX0ZVTkNUSU9OID0gKDEgPDwgRkxBR19GVU5DVElPTiksCiAgVFlQRV9BUlJBWSA9ICgxIDw8IEZMQUdfQVJSQVkpLAp9OwoKaW50MzJfdCBqc192YWx1ZV90eXBlX2ZsYWcoSlNWYWx1ZUNvbnN0IHZhbHVlKTsKaW50MzJfdCBqc192YWx1ZV90eXBlX2dldChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKCnN0YXRpYyBpbmxpbmUgaW50MzJfdApqc192YWx1ZV90eXBlMmZsYWcodWludDMyX3QgdHlwZSkgewogIGludDMyX3QgZmxhZzsKICBmb3IoZmxhZyA9IDA7ICh0eXBlID4+PSAxKTsgZmxhZysrKSB7fQogIHJldHVybiBmbGFnOwp9CgplbnVtIHZhbHVlX21hc2sganNfdmFsdWVfdHlwZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKCnN0YXRpYyBpbmxpbmUgY29uc3QgY2hhciogY29uc3QqCmpzX3ZhbHVlX3R5cGVzKCkgewogIHJldHVybiAoY29uc3QgY2hhciogY29uc3RbXSl7CiAgICAgICJVTkRFRklORUQiLCAgICAgIk5VTEwiLCAgICAgICAgICJCT09MIiwgICAgICAiSU5UIiwgIk9CSkVDVCIsICAgIlNUUklORyIsICJTWU1CT0wiLCAiQklHX0ZMT0FUIiwKICAgICAgIkJJR19JTlQiLCAgICAgICAiQklHX0RFQ0lNQUwiLCAgIkZMT0FUNjQiLCAgICJOQU4iLCAiRlVOQ1RJT04iLCAiQVJSQVkiLCAgIk1PRFVMRSIsICJGVU5DVElPTl9CWVRFQ09ERSIsCiAgICAgICJVTklOSVRJQUxJWkVEIiwgIkNBVENIX09GRlNFVCIsICJFWENFUFRJT04iLCAwLAogIH07Cn0KCnN0YXRpYyBpbmxpbmUgY29uc3QgY2hhcioKanNfdmFsdWVfdHlwZW9mKEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIGludDMyX3QgZmxhZyA9IGpzX3ZhbHVlX3R5cGVfZmxhZyh2YWx1ZSk7CiAgcmV0dXJuICgoY29uc3QgY2hhciogY29uc3RbXSl7CiAgICAgICJ1bmRlZmluZWQiLCAgICAgIm9iamVjdCIsICAgICAgICJib29sZWFuIiwgICAibnVtYmVyIiwgIm9iamVjdCIsICAgInN0cmluZyIsICJzeW1ib2wiLCAiYmlnZmxvYXQiLAogICAgICAiYmlnaW50IiwgICAgICAgICJiaWdkZWNpbWFsIiwgICAibnVtYmVyIiwgICAgIm51bWJlciIsICJmdW5jdGlvbiIsICJvYmplY3QiLCAibW9kdWxlIiwgImZ1bmN0aW9uX2J5dGVjb2RlIiwKICAgICAgInVuaW5pdGlhbGl6ZWQiLCAiY2F0Y2hfb2Zmc2V0IiwgImV4Y2VwdGlvbiIsIDAsCiAgfSlbZmxhZ107Cn0KCmNvbnN0IGNoYXIqIGpzX3ZhbHVlX3R5cGVfbmFtZShpbnQzMl90IHR5cGUpOwoKY29uc3QgY2hhcioganNfdmFsdWVfdHlwZXN0cihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKCi8qVklTSUJMRSB2b2lkKiBqc192YWx1ZV9wdHIoSlNWYWx1ZUNvbnN0IHYpOwpWSVNJQkxFIEpTT2JqZWN0KiBqc192YWx1ZV9vYmooSlNWYWx1ZUNvbnN0IHYpOwpWSVNJQkxFIGludDMyX3QganNfdmFsdWVfdGFnKEpTVmFsdWVDb25zdCB2KTsKKi8KCnN0YXRpYyBpbmxpbmUgdm9pZCoKanNfdmFsdWVfcHRyKEpTVmFsdWVDb25zdCB2KSB7CiAgcmV0dXJuIEpTX1ZBTFVFX0dFVF9QVFIodik7Cn0KCnN0YXRpYyBpbmxpbmUgSlNPYmplY3QqCmpzX3ZhbHVlX29iaihKU1ZhbHVlQ29uc3QgdikgewogIHJldHVybiBKU19Jc09iamVjdCh2KSA/IEpTX1ZBTFVFX0dFVF9PQkoodikgOiAwOwp9CgpzdGF0aWMgaW5saW5lIGludApqc192YWx1ZV90YWcoSlNWYWx1ZUNvbnN0IHYpIHsKICByZXR1cm4gSlNfVkFMVUVfR0VUX1RBRyh2KTsKfQoKQk9PTCBqc192YWx1ZV9oYXNfcmVmX2NvdW50KEpTVmFsdWVDb25zdCB2KTsKCnZvaWQganNfdmFsdWVfZnJlZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZSB2KTsKdm9pZCBqc192YWx1ZV9mcmVlX3J0KEpTUnVudGltZSogcnQsIEpTVmFsdWUgdik7CgpCT09MIGpzX3ZhbHVlX2VxdWFscyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IGEsIEpTVmFsdWVDb25zdCBiKTsKdm9pZCBqc192YWx1ZV9wcmludChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKSlNWYWx1ZSBqc192YWx1ZV9jbG9uZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHBlKTsKSlNWYWx1ZSoganNfdmFsdWVzX2R1cChKU0NvbnRleHQqIGN0eCwgaW50IG52YWx1ZXMsIEpTVmFsdWVDb25zdCogdmFsdWVzKTsKdm9pZCBqc192YWx1ZXNfZnJlZShKU1J1bnRpbWUqIHJ0LCBpbnQgbnZhbHVlcywgSlNWYWx1ZUNvbnN0KiB2YWx1ZXMpOwpKU1ZhbHVlIGpzX3ZhbHVlc190b2FycmF5KEpTQ29udGV4dCogY3R4LCBpbnQgbnZhbHVlcywgSlNWYWx1ZUNvbnN0KiB2YWx1ZXMpOwp2b2lkIGpzX3ZhbHVlX2Z3cml0ZShKU0NvbnRleHQqLCBKU1ZhbHVlLCBGSUxFKiBmKTsKdm9pZCBqc192YWx1ZV9kdW1wKEpTQ29udGV4dCosIEpTVmFsdWUsIER5bkJ1ZiogZGIpOwoKLy8jaW5jbHVkZSAiYnVmZmVyLXV0aWxzLmgiCgpjaGFyKiBqc19jc3RyaW5nX2R1cChKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogc3RyKTsKY2hhcioganNfY3N0cmluZ19wdHIoSlNWYWx1ZUNvbnN0IHYpOwpKU1ZhbHVlQ29uc3QganNfY3N0cmluZ192YWx1ZShjb25zdCBjaGFyKiBwdHIpOwp2b2lkIGpzX2NzdHJpbmdfZHVtcChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlLCBEeW5CdWYqIGRiKTsKCnN0YXRpYyBpbmxpbmUgY29uc3QgY2hhcioKanNfY3N0cmluZ19uZXcoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIHN0cikgewogIEpTVmFsdWUgdiA9IEpTX05ld1N0cmluZyhjdHgsIHN0cik7CiAgY29uc3QgY2hhciogcyA9IEpTX1RvQ1N0cmluZyhjdHgsIHYpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHYpOwogIHJldHVybiBzOwp9CnN0YXRpYyBpbmxpbmUgY29uc3QgY2hhcioKanNfY3N0cmluZ19uZXdsZW4oSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIHN0ciwgc2l6ZV90IGxlbikgewogIEpTVmFsdWUgdiA9IEpTX05ld1N0cmluZ0xlbihjdHgsIHN0ciwgbGVuKTsKICBjb25zdCBjaGFyKiBzID0gSlNfVG9DU3RyaW5nKGN0eCwgdik7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdik7CiAgcmV0dXJuIHM7Cn0KCnN0YXRpYyBpbmxpbmUgdm9pZApqc19jc3RyaW5nX2ZyZWUoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIHB0cikgewogIGlmKCFwdHIpCiAgICByZXR1cm47CgogIEpTX0ZyZWVWYWx1ZShjdHgsIEpTX01LUFRSKEpTX1RBR19TVFJJTkcsICh2b2lkKikocHRyIC0gb2Zmc2V0b2YoSlNTdHJpbmcsIHUpKSkpOwp9CgpzdGF0aWMgaW5saW5lIGludDY0X3QKanNfdG9pbnQ2NChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgaW50NjRfdCByZXQgPSAwOwogIEpTX1RvSW50NjQoY3R4LCAmcmV0LCB2YWx1ZSk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBjaGFyKgpqc190b3N0cmluZ2xlbihKU0NvbnRleHQqIGN0eCwgc2l6ZV90KiBsZW5wLCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBzaXplX3QgbGVuOwogIGNvbnN0IGNoYXIqIGNzdHI7CiAgY2hhciogcmV0ID0gMDsKICBpZigoY3N0ciA9IEpTX1RvQ1N0cmluZ0xlbihjdHgsICZsZW4sIHZhbHVlKSkpIHsKICAgIHJldCA9IGpzX3N0cm5kdXAoY3R4LCBjc3RyLCBsZW4pOwogICAgaWYobGVucCkKICAgICAgKmxlbnAgPSBsZW47CiAgICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBjc3RyKTsKICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBjaGFyKgpqc190b3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgcmV0dXJuIGpzX3Rvc3RyaW5nbGVuKGN0eCwgMCwgdmFsdWUpOwp9CgpzdGF0aWMgaW5saW5lIHdjaGFyX3QqCmpzX3Rvd3N0cmluZ2xlbihKU0NvbnRleHQqIGN0eCwgc2l6ZV90KiBsZW5wLCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBzaXplX3QgaSwgbGVuOwogIGNvbnN0IGNoYXIqIGNzdHI7CiAgd2NoYXJfdCogcmV0ID0gMDsKICBpZigoY3N0ciA9IEpTX1RvQ1N0cmluZ0xlbihjdHgsICZsZW4sIHZhbHVlKSkpIHsKICAgIHJldCA9IGpzX21hbGxvY3ooY3R4LCBzaXplb2Yod2NoYXJfdCkgKiAobGVuICsgMSkpOwogICAgY29uc3QgdWludDhfdCAqcHRyID0gKGNvbnN0IHVpbnQ4X3QqKWNzdHIsICplbmQgPSAoY29uc3QgdWludDhfdCopY3N0ciArIGxlbjsKCiAgICBmb3IoaSA9IDA7IHB0ciA8IGVuZDspIHsgcmV0W2krK10gPSB1bmljb2RlX2Zyb21fdXRmOChwdHIsIGVuZCAtIHB0ciwgJnB0cik7IH0KCiAgICBpZihsZW5wKQogICAgICAqbGVucCA9IGk7CiAgfQogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgd2NoYXJfdCoKanNfdG93c3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICByZXR1cm4ganNfdG93c3RyaW5nbGVuKGN0eCwgMCwgdmFsdWUpOwp9CgpzdGF0aWMgaW5saW5lIEpTVmFsdWUKanNfdmFsdWVfdG9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIGNsYXNzX25hbWUsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIEpTQXRvbSBhdG9tOwogIEpTVmFsdWUgcHJvdG8sIHRvc3RyaW5nLCBzdHI7CiAgcHJvdG8gPSBqc19nbG9iYWxfcHJvdG90eXBlKGN0eCwgY2xhc3NfbmFtZSk7CiAgYXRvbSA9IEpTX05ld0F0b20oY3R4LCAidG9TdHJpbmciKTsKICB0b3N0cmluZyA9IEpTX0dldFByb3BlcnR5KGN0eCwgcHJvdG8sIGF0b20pOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHByb3RvKTsKICBKU19GcmVlQXRvbShjdHgsIGF0b20pOwogIHN0ciA9IEpTX0NhbGwoY3R4LCB0b3N0cmluZywgdmFsdWUsIDAsIDApOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHRvc3RyaW5nKTsKICByZXR1cm4gc3RyOwp9CgppbnQganNfdmFsdWVfdG9zaXplKEpTQ29udGV4dCogY3R4LCBzaXplX3QqIHN6LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwoKc3RhdGljIGlubGluZSBkb3VibGUKanNfdmFsdWVfdG9kb3VibGVfZnJlZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgZG91YmxlIHJldCA9IDA7CiAgSlNfVG9GbG9hdDY0KGN0eCwgJnJldCwgdmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW5saW5lIGludDY0X3QKanNfdmFsdWVfdG9pbnQ2NF9mcmVlKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBpbnQ2NF90IHJldCA9IDA7CiAgSlNfVG9JbnQ2NChjdHgsICZyZXQsIHZhbHVlKTsKICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBCT09MCmpzX3ZhbHVlX3RvYm9vbF9mcmVlKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBCT09MIHJldCA9IEpTX1RvQm9vbChjdHgsIHZhbHVlKTsKICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBKU0F0b20KanNfdmFsdWVfdG9hdG9tX2ZyZWUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIEpTQXRvbSBhdG9tID0gSlNfVmFsdWVUb0F0b20oY3R4LCB2YWx1ZSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIHJldHVybiBhdG9tOwp9CgpKU1ZhbHVlIGpzX3ZhbHVlX2Zyb21fY2hhcihKU0NvbnRleHQqIGN0eCwgaW50IGMpOwpzdGF0aWMgaW5saW5lIGludApqc192YWx1ZV9jbXBzdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSwgY29uc3QgY2hhciogb3RoZXIpIHsKICBjb25zdCBjaGFyKiBzdHIgPSBKU19Ub0NTdHJpbmcoY3R4LCB2YWx1ZSk7CiAgaW50IHJldCA9IHN0cmNtcChzdHIsIG90aGVyKTsKICBKU19GcmVlQ1N0cmluZyhjdHgsIHN0cik7CiAgcmV0dXJuIHJldDsKfQoKI2RlZmluZSBKU19WQUxVRV9GUkVFKGN0eCwgdmFsdWUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgSlNfRnJlZVZhbHVlKChjdHgpLCAodmFsdWUpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgICh2YWx1ZSkgPSBKU19VTkRFRklORUQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgfSB3aGlsZSgwKTsKI2RlZmluZSBKU19WQUxVRV9GUkVFX1JUKGN0eCwgdmFsdWUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgSlNfRnJlZVZhbHVlUlQoKGN0eCksICh2YWx1ZSkpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgICh2YWx1ZSkgPSBKU19VTkRFRklORUQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgfSB3aGlsZSgwKTsKCiNpZiAwCiNkZWZpbmUganNfb2JqZWN0X3RtcG1hcmtfc2V0KHZhbHVlKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIGRvIHsgKCh1aW50OF90KilKU19WQUxVRV9HRVRfT0JKKCh2YWx1ZSkpKVs1XSB8PSAweDQwOyB9IHdoaWxlKDApOwojZGVmaW5lIGpzX29iamVjdF90bXBtYXJrX2NsZWFyKHZhbHVlKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICBkbyB7ICgodWludDhfdCopSlNfVkFMVUVfR0VUX09CSigodmFsdWUpKSlbNV0gJj0gfjB4NDA7IH0gd2hpbGUoMCk7CiNkZWZpbmUganNfb2JqZWN0X3RtcG1hcmtfaXNzZXQodmFsdWUpICgoKHVpbnQ4X3QqKUpTX1ZBTFVFX0dFVF9PQkooKHZhbHVlKSkpWzVdICYgMHg0MCkKI2Vsc2UKI2RlZmluZSBqc19vYmplY3RfdG1wbWFya19zZXQodmFsdWUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgZG8geyBKU19WQUxVRV9HRVRfT0JKKCh2YWx1ZSkpLT50bXBfbWFyayB8PSAweDQwOyB9IHdoaWxlKDApOwojZGVmaW5lIGpzX29iamVjdF90bXBtYXJrX2NsZWFyKHZhbHVlKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICBkbyB7IEpTX1ZBTFVFX0dFVF9PQkooKHZhbHVlKSktPnRtcF9tYXJrICY9IH4weDQwOyB9IHdoaWxlKDApOwojZGVmaW5lIGpzX29iamVjdF90bXBtYXJrX2lzc2V0KHZhbHVlKSAoSlNfVkFMVUVfR0VUX09CSigodmFsdWUpKS0+dG1wX21hcmsgJiAweDQwKQojZW5kaWYKCiNkZWZpbmUganNfcnVudGltZV9leGNlcHRpb25fc2V0KHJ0LCB2YWx1ZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIGRvIHsgKihKU1ZhbHVlKikoKHVpbnQ4X3QqKShydCkgKyAyMTYpID0gdmFsdWU7IH0gd2hpbGUoMCk7CiNkZWZpbmUganNfcnVudGltZV9leGNlcHRpb25fZ2V0KHJ0KSAoKihKU1ZhbHVlKikoKHVpbnQ4X3QqKShydCkgKyAyMTYpKQojZGVmaW5lIGpzX3J1bnRpbWVfZXhjZXB0aW9uX2NsZWFyKHJ0KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICBpZighSlNfSXNOdWxsKGpzX3J1bnRpbWVfZXhjZXB0aW9uX2dldChydCkpKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgICBKU19GcmVlVmFsdWVSVCgocnQpLCBqc19ydW50aW1lX2V4Y2VwdGlvbl9nZXQocnQpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgIGpzX3J1bnRpbWVfZXhjZXB0aW9uX3NldChydCwgSlNfTlVMTCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgfSB3aGlsZSgwKQoKdm9pZCBqc19wcm9wZXJ0eWVudW1zX2ZyZWUoSlNDb250ZXh0KiBjdHgsIEpTUHJvcGVydHlFbnVtKiBwcm9wcywgc2l6ZV90IGxlbik7CgpzdGF0aWMgaW5saW5lIHZvaWQKanNfcHJvcGVydHlkZXNjcmlwdG9yX2ZyZWUoSlNDb250ZXh0KiBjdHgsIEpTUHJvcGVydHlEZXNjcmlwdG9yKiBkZXNjKSB7CiAgSlNfRnJlZVZhbHVlKGN0eCwgZGVzYy0+dmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGRlc2MtPmdldHRlcik7CiAgSlNfRnJlZVZhbHVlKGN0eCwgZGVzYy0+c2V0dGVyKTsKfQoKSlNWYWx1ZSBqc19zeW1ib2xfY3RvcihKU0NvbnRleHQqIGN0eCk7CgpKU1ZhbHVlIGpzX3N5bWJvbF9pbnZva2Vfc3RhdGljKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBuYW1lLCBKU1ZhbHVlQ29uc3QgYXJnKTsKCkpTVmFsdWUganNfc3ltYm9sX3RvX3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHN5bSk7Cgpjb25zdCBjaGFyKiBqc19zeW1ib2xfdG9fY3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHN5bSk7CgpKU1ZhbHVlIGpzX3N5bWJvbF9zdGF0aWNfdmFsdWUoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIG5hbWUpOwpKU0F0b20ganNfc3ltYm9sX3N0YXRpY19hdG9tKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBuYW1lKTsKQk9PTCBqc19pc19pdGVyYWJsZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaik7CkJPT0wganNfaXNfaXRlcmF0b3IoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmopOwpKU1ZhbHVlIGpzX2l0ZXJhdG9yX21ldGhvZChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaik7CkpTVmFsdWUganNfaXRlcmF0b3JfbmV3KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqKTsKSlNWYWx1ZSBqc19pdGVyYXRvcl9uZXh0KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBCT09MKiBkb25lX3ApOwpKU1ZhbHVlIGpzX3N5bWJvbF9mb3IoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIHN5bV9mb3IpOwpKU0F0b20ganNfc3ltYm9sX2Zvcl9hdG9tKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBzeW1fZm9yKTsKCkpTVmFsdWUganNfc3ltYm9sX29wZXJhdG9yc2V0X3ZhbHVlKEpTQ29udGV4dCogY3R4KTsKCkpTQXRvbSBqc19zeW1ib2xfb3BlcmF0b3JzZXRfYXRvbShKU0NvbnRleHQqIGN0eCk7CgpKU1ZhbHVlIGpzX29wZXJhdG9yc19jcmVhdGUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWUqIHRoaXNfb2JqKTsKCnN0YXRpYyBpbmxpbmUgaW50NjRfdApqc19pbnQ2NF9kZWZhdWx0KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUsIGludDY0X3QgaSkgewogIGlmKEpTX0lzTnVtYmVyKHZhbHVlKSkKICAgIEpTX1RvSW50NjQoY3R4LCAmaSwgdmFsdWUpOwogIHJldHVybiBpOwp9CgpKU1ZhbHVlIGpzX251bWJlcl9uZXcoSlNDb250ZXh0KiBjdHgsIGludDMyX3Qgbik7CgpzdGF0aWMgaW5saW5lIEpTVmFsdWUKanNfbmV3X2Jvb2xfb3JfbnVtYmVyKEpTQ29udGV4dCogY3R4LCBpbnQzMl90IG4pIHsKICBpZihuID09IDApCiAgICByZXR1cm4gSlNfTmV3Qm9vbChjdHgsIEZBTFNFKTsKICByZXR1cm4ganNfbnVtYmVyX25ldyhjdHgsIG4pOwp9CgojZGVmaW5lIEpTX0FUT01fVEFHX0lOVCAoMVUgPDwgMzEpCiNkZWZpbmUgSlNfQVRPTV9NQVhfSU5UIChKU19BVE9NX1RBR19JTlQgLSAxKQoKI2RlZmluZSBqc19hdG9tX2lzaW50KGkpICgoSlNBdG9tKSgoaSkmSlNfQVRPTV9UQUdfSU5UKSkKI2RlZmluZSBqc19hdG9tX2Zyb21pbnQoaSkgKChKU0F0b20pKChpKSZKU19BVE9NX01BWF9JTlQpIHwgSlNfQVRPTV9UQUdfSU5UKQojZGVmaW5lIGpzX2F0b21fdG9pbnQoaSkgKHVuc2lnbmVkIGludCkoKChKU0F0b20pKGkpICYgKH4oSlNfQVRPTV9UQUdfSU5UKSkpKQoKaW50IGpzX2F0b21fdG9pbnQ2NChKU0NvbnRleHQqIGN0eCwgaW50NjRfdCogaSwgSlNBdG9tIGF0b20pOwppbnQzMl90IGpzX2F0b21fdG9pbnQzMihKU0NvbnRleHQqIGN0eCwgSlNBdG9tIGF0b20pOwoKc3RhdGljIGlubGluZSBKU1ZhbHVlCmpzX2F0b21fdG92YWx1ZShKU0NvbnRleHQqIGN0eCwgSlNBdG9tIGF0b20pIHsKICBpZihqc19hdG9tX2lzaW50KGF0b20pKQogICAgcmV0dXJuIEpTX01LVkFMKEpTX1RBR19JTlQsIGpzX2F0b21fdG9pbnQoYXRvbSkpOwoKICByZXR1cm4gSlNfQXRvbVRvVmFsdWUoY3R4LCBhdG9tKTsKfQoKdW5zaWduZWQgaW50IGpzX2F0b21fdG9iaW5hcnkoSlNBdG9tIGF0b20pOwpjb25zdCBjaGFyKiBqc19hdG9tX3RvX2NzdHJpbmdsZW4oSlNDb250ZXh0KiBjdHgsIHNpemVfdCogbGVuLCBKU0F0b20gYXRvbSk7CnZvaWQganNfYXRvbV9kdW1wKEpTQ29udGV4dCogY3R4LCBKU0F0b20gYXRvbSwgRHluQnVmKiBkYiwgQk9PTCBjb2xvcik7CkJPT0wganNfYXRvbV9pc19pbmRleChKU0NvbnRleHQqIGN0eCwgaW50NjRfdCogcHZhbCwgSlNBdG9tIGF0b20pOwpCT09MIGpzX2F0b21faXNfbGVuZ3RoKEpTQ29udGV4dCogY3R4LCBKU0F0b20gYXRvbSk7Cgpjb25zdCBjaGFyKiBqc19vYmplY3RfdG9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CmNvbnN0IGNoYXIqIGpzX2Z1bmN0aW9uX25hbWUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CmNvbnN0IGNoYXIqIGpzX2Z1bmN0aW9uX3Rvc3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwpCT09MIGpzX2Z1bmN0aW9uX2lzbmF0aXZlKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwppbnQganNfZnVuY3Rpb25fYXJnYyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKCmNoYXIqIGpzX29iamVjdF9jbGFzc25hbWUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CmludCBqc19vYmplY3RfaXMoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSwgY29uc3QgY2hhciogY21wKTsKSlNWYWx1ZSBqc19vYmplY3RfY29uc3RydWN0KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgY3Rvcik7CkpTVmFsdWUganNfb2JqZWN0X2Vycm9yKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBtZXNzYWdlKTsKSlNWYWx1ZSBqc19vYmplY3Rfc3RhY2soSlNDb250ZXh0KiBjdHgpOwpKU1ZhbHVlIGpzX29iamVjdF9uZXcoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIGNsYXNzX25hbWUsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKTsKCnN0YXRpYyBpbmxpbmUgQk9PTApqc19vYmplY3Rfc2FtZShKU1ZhbHVlQ29uc3QgYSwgSlNWYWx1ZUNvbnN0IGIpIHsKICBKU09iamVjdCAqYW9iaiwgKmJvYmo7CiAgaWYoIUpTX0lzT2JqZWN0KGEpIHx8ICFKU19Jc09iamVjdChiKSkKICAgIHJldHVybiBGQUxTRTsKCiAgYW9iaiA9IEpTX1ZBTFVFX0dFVF9PQkooYSk7CiAgYm9iaiA9IEpTX1ZBTFVFX0dFVF9PQkooYik7CiAgcmV0dXJuIGFvYmogPT0gYm9iajsKfQoKc3RhdGljIGlubGluZSBKU0NsYXNzSUQKanNfZ2V0X2NsYXNzaWQoSlNWYWx1ZSB2KSB7CiAgSlNPYmplY3QqIHA7CiAgLyogaWYoSlNfVkFMVUVfR0VUX1RBRyh2KSAhPSBKU19UQUdfT0JKRUNUKQogICAgIHJldHVybiAwOyovCiAgcCA9IEpTX1ZBTFVFX0dFVF9PQkoodik7CiAgYXNzZXJ0KHAgIT0gMCk7CiAgcmV0dXJuIHAtPmNsYXNzX2lkOwp9CgpCT09MIGpzX2hhc19wcm9wZXJ0eXN0cihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgY29uc3QgY2hhciogc3RyKTsKQk9PTCBqc19nZXRfcHJvcGVydHlzdHJfYm9vbChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgY29uc3QgY2hhciogc3RyKTsKdm9pZCBqc19zZXRfcHJvcGVydHlpbnRfc3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCB1aW50MzJfdCBpLCBjb25zdCBjaGFyKiBzdHIpOwp2b2lkIGpzX3NldF9wcm9wZXJ0eWludF9pbnQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIHVpbnQzMl90IGksIGludDMyX3QgdmFsdWUpOwp2b2lkIGpzX3NldF9wcm9wZXJ0eXN0cl9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3AsIGNvbnN0IGNoYXIqIHN0cik7CnZvaWQganNfc2V0X3Byb3BlcnR5c3RyX3N0cmluZ2xlbihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgY29uc3QgY2hhciogcHJvcCwgY29uc3QgY2hhciogc3RyLCBzaXplX3QgbGVuKTsKY29uc3QgY2hhcioganNfZ2V0X3Byb3BlcnR5aW50X2NzdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIHVpbnQzMl90IGkpOwppbnQzMl90IGpzX2dldF9wcm9wZXJ0eWludF9pbnQzMihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgdWludDMyX3QgaSk7CmNvbnN0IGNoYXIqIGpzX2dldF9wcm9wZXJ0eXN0cl9jc3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBjb25zdCBjaGFyKiBwcm9wKTsKY29uc3QgY2hhcioganNfZ2V0X3Byb3BlcnR5c3RyX2NzdHJpbmdsZW4oSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3AsIHNpemVfdCogbGVucCk7CmNoYXIqIGpzX2dldF9wcm9wZXJ0eXN0cl9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3ApOwpjaGFyKiBqc19nZXRfcHJvcGVydHlzdHJfc3RyaW5nbGVuKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBjb25zdCBjaGFyKiBwcm9wLCBzaXplX3QqIGxlbnApOwppbnQzMl90IGpzX2dldF9wcm9wZXJ0eXN0cl9pbnQzMihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgY29uc3QgY2hhciogcHJvcCk7CnVpbnQ2NF90IGpzX2dldF9wcm9wZXJ0eXN0cl91aW50NjQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3ApOwppbnQganNfZ2V0X3Byb3BlcnR5ZGVzY3JpcHRvcihKU0NvbnRleHQqIGN0eCwgSlNQcm9wZXJ0eURlc2NyaXB0b3IqIGRlc2MsIEpTVmFsdWVDb25zdCBvYmosIEpTQXRvbSBwcm9wKTsKCnN0YXRpYyBpbmxpbmUgdm9pZApqc19zZXRfaW5zcGVjdF9tZXRob2QoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIEpTQ0Z1bmN0aW9uKiBmdW5jKSB7CiAgSlNBdG9tIGluc3BlY3Rfc3ltYm9sID0ganNfc3ltYm9sX2Zvcl9hdG9tKGN0eCwgInF1aWNranMuaW5zcGVjdC5jdXN0b20iKTsKICBKU19EZWZpbmVQcm9wZXJ0eVZhbHVlKGN0eCwgb2JqLCBpbnNwZWN0X3N5bWJvbCwgSlNfTmV3Q0Z1bmN0aW9uKGN0eCwgZnVuYywgImluc3BlY3QiLCAxKSwgSlNfUFJPUF9DT05GSUdVUkFCTEUgfCBKU19QUk9QX1dSSVRBQkxFKTsKICBKU19GcmVlQXRvbShjdHgsIGluc3BlY3Rfc3ltYm9sKTsKfQoKc3RhdGljIGlubGluZSB2b2lkCmpzX3NldF90b3N0cmluZ3RhZ192YWx1ZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgSlNWYWx1ZSB2YWx1ZSkgewogIEpTQXRvbSB0b3N0cmluZ190YWcgPSBqc19zeW1ib2xfc3RhdGljX2F0b20oY3R4LCAidG9TdHJpbmdUYWciKTsKICBKU19EZWZpbmVQcm9wZXJ0eVZhbHVlKGN0eCwgb2JqLCB0b3N0cmluZ190YWcsIHZhbHVlLCBKU19QUk9QX0NPTkZJR1VSQUJMRSB8IEpTX1BST1BfV1JJVEFCTEUpOwogIEpTX0ZyZWVBdG9tKGN0eCwgdG9zdHJpbmdfdGFnKTsKfQoKc3RhdGljIGlubGluZSB2b2lkCmpzX3NldF90b3N0cmluZ3RhZ19zdHIoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHN0cikgewogIGpzX3NldF90b3N0cmluZ3RhZ192YWx1ZShjdHgsIG9iaiwgSlNfTmV3U3RyaW5nKGN0eCwgc3RyKSk7Cn0KCkpTQ2xhc3NJRCBqc19jbGFzc19pZChKU0NvbnRleHQqIGN0eCwgaW50IGlkKTsKSlNDbGFzc0lEIGpzX2NsYXNzX25ld2lkKHZvaWQpOwpKU0NsYXNzKiBqc19jbGFzc19nZXQoSlNDb250ZXh0KiBjdHgsIEpTQ2xhc3NJRCBpZCk7CkpTQXRvbSBqc19jbGFzc19hdG9tKEpTQ29udGV4dCogY3R4LCBKU0NsYXNzSUQgaWQpOwpjb25zdCBjaGFyKiBqc19jbGFzc19uYW1lKEpTQ29udGV4dCogY3R4LCBKU0NsYXNzSUQgaWQpOwoKc3RhdGljIGlubGluZSBCT09MCmpzX29iamVjdF9pc2NsYXNzKEpTVmFsdWUgb2JqLCBpbnQzMl90IGNsYXNzX2lkKSB7CiAgcmV0dXJuIEpTX0dldE9wYXF1ZShvYmosIGNsYXNzX2lkKSAhPSAwOwp9CgpzdGF0aWMgaW5saW5lIEJPT0wKanNfdmFsdWVfaXNjbGFzcyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZSBvYmosIGludCBpZCkgewogIGludDMyX3QgY2xhc3NfaWQgPSBqc19jbGFzc19pZChjdHgsIGlkKTsKICByZXR1cm4ganNfb2JqZWN0X2lzY2xhc3Mob2JqLCBjbGFzc19pZCk7Cn0KCkJPT0wganNfaXNfYXJyYXlidWZmZXIoSlNDb250ZXh0KiwgSlNWYWx1ZUNvbnN0KTsKQk9PTCBqc19pc19zaGFyZWRhcnJheWJ1ZmZlcihKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QpOwpCT09MIGpzX2lzX21hcChKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QpOwpCT09MIGpzX2lzX3NldChKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QpOwpCT09MIGpzX2lzX2dlbmVyYXRvcihKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QpOwpCT09MIGpzX2lzX3JlZ2V4cChKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QpOwpCT09MIGpzX2lzX3Byb21pc2UoSlNDb250ZXh0KiwgSlNWYWx1ZUNvbnN0KTsKQk9PTCBqc19pc19kYXRhdmlldyhKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QpOwoKc3RhdGljIGlubGluZSBCT09MCmpzX2lzX251bGxfb3JfdW5kZWZpbmVkKEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIHJldHVybiBKU19Jc1VuZGVmaW5lZCh2YWx1ZSkgfHwgSlNfSXNOdWxsKHZhbHVlKTsKfQoKc3RhdGljIGlubGluZSBCT09MCmpzX2lzX2ZhbHNpc2goSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgc3dpdGNoKEpTX1ZBTFVFX0dFVF9UQUcodmFsdWUpKSB7CiAgICBjYXNlIEpTX1RBR19OVUxMOiByZXR1cm4gVFJVRTsKICAgIGNhc2UgSlNfVEFHX1VOREVGSU5FRDogcmV0dXJuIFRSVUU7CiAgICBjYXNlIEpTX1RBR19JTlQ6IHJldHVybiBKU19WQUxVRV9HRVRfSU5UKHZhbHVlKSA9PSAwOwogICAgY2FzZSBKU19UQUdfQk9PTDogcmV0dXJuICFKU19WQUxVRV9HRVRfQk9PTCh2YWx1ZSk7CiAgICBjYXNlIEpTX1RBR19GTE9BVDY0OiByZXR1cm4gSlNfVkFMVUVfR0VUX0ZMT0FUNjQodmFsdWUpID09IDA7CiAgICBkZWZhdWx0OiByZXR1cm4gRkFMU0U7CiAgfQp9CgpzdGF0aWMgaW5saW5lIEJPT0wKanNfaXNfdHJ1aXNoKEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIHJldHVybiAhanNfaXNfZmFsc2lzaCh2YWx1ZSk7Cn0KCnN0YXRpYyBpbmxpbmUgQk9PTApqc19pc19udWxsaXNoKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBpbnQ2NF90IGkgPSAtMTsKCiAgaWYoSlNfSXNVbmRlZmluZWQodmFsdWUpIHx8IEpTX0lzTnVsbCh2YWx1ZSkpCiAgICByZXR1cm4gVFJVRTsKICBKU19Ub0ludDY0KGN0eCwgJmksIHZhbHVlKTsKICByZXR1cm4gaSA9PSAwOwp9CgpKU1ZhbHVlIGpzX3R5cGVkYXJyYXlfcHJvdG90eXBlKEpTQ29udGV4dCogY3R4KTsKSlNWYWx1ZSBqc190eXBlZGFycmF5X2NvbnN0cnVjdG9yKEpTQ29udGV4dCogY3R4KTsKCnN0YXRpYyBpbmxpbmUgQk9PTApqc19pc19iYXNpY19hcnJheShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgSlNWYWx1ZSBjdG9yID0ganNfZ2xvYmFsX2dldChjdHgsICJBcnJheSIpOwogIEJPT0wgcmV0ID0gSlNfSXNJbnN0YW5jZU9mKGN0eCwgdmFsdWUsIGN0b3IpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGN0b3IpOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgQk9PTApqc19pc190eXBlZGFycmF5KEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIGlmKEpTX0lzT2JqZWN0KHZhbHVlKSkgewogICAgSlNDbGFzc0lEIGlkID0ganNfZ2V0X2NsYXNzaWQodmFsdWUpOwogICAgcmV0dXJuIGlkID49IEpTX0NMQVNTX1VJTlQ4Q19BUlJBWSAmJiBpZCA8PSBKU19DTEFTU19GTE9BVDY0X0FSUkFZOwogIH0KICByZXR1cm4gRkFMU0U7Cn0KCnN0YXRpYyBpbmxpbmUgQk9PTApqc19pc19hcnJheShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgcmV0dXJuIEpTX0lzQXJyYXkoY3R4LCB2YWx1ZSkgfHwganNfaXNfdHlwZWRhcnJheSh2YWx1ZSk7Cn0KCkJPT0wganNfaXNfaW5wdXQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CgppbnQganNfcHJvcGVudW1fY21wKGNvbnN0IHZvaWQqIGEsIGNvbnN0IHZvaWQqIGIsIHZvaWQqIHB0cik7CkJPT0wganNfb2JqZWN0X2VxdWFscyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IGEsIEpTVmFsdWVDb25zdCBiKTsKaW50NjRfdCBqc19hcnJheV9sZW5ndGgoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBhcnJheSk7CnZvaWQganNfYXJyYXlfY2xlYXIoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBhcnJheSk7CgpzaXplX3QganNfc3Rydl9sZW5ndGgoY2hhcioqIHN0cnYpOwoKY2hhcioqIGpzX3N0cnZfZHVwKEpTQ29udGV4dCogY3R4LCBjaGFyKiogc3Rydik7Cgp2b2lkIGpzX3N0cnZfZnJlZV9uKEpTQ29udGV4dCosIGludCwgY2hhciogYXJndltdKTsKdm9pZCBqc19zdHJ2X2ZyZWUoSlNDb250ZXh0KiBjdHgsIGNoYXIqKiBzdHJ2KTsKdm9pZCBqc19zdHJ2X2ZyZWVfcnQoSlNSdW50aW1lKiBydCwgY2hhcioqIHN0cnYpOwpKU1ZhbHVlIGpzX3N0cnZfdG9fYXJyYXkoSlNDb250ZXh0KiBjdHgsIGNoYXIqKiBzdHJ2KTsKSlNWYWx1ZSBqc19pbnR2X3RvX2FycmF5KEpTQ29udGV4dCogY3R4LCBpbnQqIGludHYpOwpjaGFyKioganNfYXJyYXlfdG9fYXJndihKU0NvbnRleHQqIGN0eCwgaW50KiBhcmdjcCwgSlNWYWx1ZUNvbnN0IGFycmF5KTsKaW50IGpzX2FycmF5X2NvcHlzKEpTQ29udGV4dCosIEpTVmFsdWVDb25zdCwgaW50IG4sIGNoYXIqKiBzdHJhKTsKaW50IGpzX3N0cnZfY29weXMoSlNDb250ZXh0KiwgaW50LCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbiwgY2hhcioqIHN0cmEpOwoKSlNWYWx1ZSBqc19pbnZva2UoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX29iaiwgY29uc3QgY2hhciogbWV0aG9kLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSk7CgpzdGF0aWMgaW5saW5lIHNpemVfdApqc19hcnJheWJ1ZmZlcl9sZW5ndGgoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBidWZmZXIpIHsKICB1aW50OF90KiBwdHI7CiAgc2l6ZV90IGxlbjsKCiAgaWYoSlNfR2V0QXJyYXlCdWZmZXIoY3R4LCAmbGVuLCBidWZmZXIpKQogICAgcmV0dXJuIGxlbjsKICByZXR1cm4gMDsKfQoKaW50NjRfdCBqc19hcnJheWJ1ZmZlcl9ieXRlbGVuZ3RoKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwoKc3RhdGljIGlubGluZSBpbnQKanNfZmluZF9jZnVuY3Rpb25fZW50cnkoY29uc3QgSlNDRnVuY3Rpb25MaXN0RW50cnkqIGVudHJpZXMsIHNpemVfdCBuX2VudHJpZXMsIGNvbnN0IGNoYXIqIG5hbWUsIGludCBkZWZfdHlwZSkgewogIHNpemVfdCBpOwogIGZvcihpID0gMDsgaSA8IG5fZW50cmllczsgaSsrKQogICAgaWYoZW50cmllc1tpXS5kZWZfdHlwZSA9PSBkZWZfdHlwZSAmJiAhc3RyY21wKGVudHJpZXNbaV0ubmFtZSwgbmFtZSkpCiAgICAgIHJldHVybiBpOwogIHJldHVybiAtMTsKfQoKc3RhdGljIGlubGluZSBpbnQKanNfZmluZF9jZnVuY3Rpb25fYXRvbShKU0NvbnRleHQqIGN0eCwgY29uc3QgSlNDRnVuY3Rpb25MaXN0RW50cnkqIGVudHJpZXMsIHNpemVfdCBuX2VudHJpZXMsIEpTQXRvbSBhdG9tLCBpbnQgZGVmX3R5cGUpIHsKICBjb25zdCBjaGFyKiBuYW1lID0gSlNfQXRvbVRvQ1N0cmluZyhjdHgsIGF0b20pOwogIGludCBpOwogIGkgPSBqc19maW5kX2NmdW5jdGlvbl9lbnRyeShlbnRyaWVzLCBuX2VudHJpZXMsIG5hbWUsIGRlZl90eXBlKTsKICBKU19GcmVlQ1N0cmluZyhjdHgsIG5hbWUpOwogIHJldHVybiBpOwp9CgpKU1ZhbHVlIGpzX2RhdGVfbmV3KEpTQ29udGV4dCosIEpTVmFsdWUgYXJnKTsKSlNWYWx1ZSBqc19kYXRlX2Zyb21fbXMoSlNDb250ZXh0KiwgaW50NjRfdCBtcyk7CkpTVmFsdWUganNfZGF0ZV9mcm9tX3RpbWVfbnMoSlNDb250ZXh0KiwgdGltZV90IHQsIGxvbmcgbnMpOwpKU1ZhbHVlIGpzX2RhdGVfZnJvbV90aW1lc3BlYyhKU0NvbnRleHQqLCBjb25zdCBzdHJ1Y3QgdGltZXNwZWMgdHMpOwppbnQ2NF90IGpzX2RhdGVfZ2V0dGltZShKU0NvbnRleHQqLCBKU1ZhbHVlIGFyZyk7CmludDY0X3QganNfZGF0ZV90aW1lKEpTQ29udGV4dCosIEpTVmFsdWUgYXJnKTsKc3RydWN0IHRpbWVzcGVjIGpzX2RhdGVfdGltZXNwZWMoSlNDb250ZXh0KiwgSlNWYWx1ZSBhcmcpOwoKdm9pZCBqc19hcnJheWJ1ZmZlcl9mcmVldmFsdWUoSlNSdW50aW1lKiwgdm9pZCogb3BhcXVlLCB2b2lkKiBwdHIpOwpKU1ZhbHVlIGpzX2FycmF5YnVmZmVyX2Zyb212YWx1ZShKU0NvbnRleHQqLCAgIHZvaWQqIHgsIHNpemVfdCBuLCBKU1ZhbHVlIHZhbCk7CgpKU1ZhbHVlIGpzX21hcF9uZXcoSlNDb250ZXh0KiwgSlNWYWx1ZUNvbnN0KTsKCnR5cGVkZWYgdW5pb24gaW1wb3J0X2RpcmVjdGl2ZSB7CiAgc3RydWN0IHsKICAgIGNvbnN0IGNoYXIqIHBhdGg7IC8qKjwgTW9kdWxlIHBhdGggKi8KICAgIGNvbnN0IGNoYXIqIHNwZWM7IC8qKjwgSW1wb3J0IHNwZWNpZmllcihzKSAqLwogICAgY29uc3QgY2hhciogcHJvcDsgLyoqPCBpZiAhPSAwICYmICpwcm9wLCBucyArPSAiLiIgKyBwcm9wICovCiAgICBjb25zdCBjaGFyKiB2YXI7ICAvKio8IEdsb2JhbCB2YXJpYWJsZSBuYW1lICovCiAgICBjb25zdCBjaGFyKiBuczsgICAvKio8IE5hbWVzcGFjZSB2YXJpYWJsZSAqLwogIH07CiAgY29uc3QgY2hhciogYXJnc1s1XTsKfSBJbXBvcnREaXJlY3RpdmU7CgpKU1ZhbHVlIG1vZHVsZV9uYW1lKEpTQ29udGV4dCosIEpTTW9kdWxlRGVmKik7CmNoYXIqIG1vZHVsZV9uYW1lc3RyKEpTQ29udGV4dCosIEpTTW9kdWxlRGVmKik7CkpTVmFsdWUgbW9kdWxlX2Z1bmMoSlNDb250ZXh0KiwgSlNNb2R1bGVEZWYqKTsKSlNWYWx1ZSBtb2R1bGVfbnMoSlNDb250ZXh0KiwgSlNNb2R1bGVEZWYqKTsKdm9pZCBnZXRfbW9kdWxlX2V4cG9ydHMoSlNDb250ZXh0KiwgSlNNb2R1bGVEZWYqLCBCT09MIHJlbmFtZV9kZWZhdWx0LCBKU1ZhbHVlQ29uc3QgZXhwb3J0cyk7CkpTVmFsdWUgbW9kdWxlX2V4cG9ydHMoSlNDb250ZXh0KiwgSlNNb2R1bGVEZWYqKTsKc3RydWN0IGxpc3RfaGVhZCoganNfbW9kdWxlc19saXN0KEpTQ29udGV4dCopOwpKU1ZhbHVlIGpzX21vZHVsZXNfYXJyYXkoSlNDb250ZXh0KiwgSlNWYWx1ZUNvbnN0LCBpbnQgbWFnaWMpOwpKU1ZhbHVlIGpzX21vZHVsZXNfZW50cmllcyhKU0NvbnRleHQqLCBKU1ZhbHVlQ29uc3QsIGludCBtYWdpYyk7CkpTVmFsdWUganNfbW9kdWxlc19tYXAoSlNDb250ZXh0KiwgSlNWYWx1ZUNvbnN0LCBpbnQgbWFnaWMpOwpKU1ZhbHVlIGpzX21vZHVsZXNfb2JqZWN0KEpTQ29udGV4dCosIEpTVmFsdWVDb25zdCwgaW50IG1hZ2ljKTsKSlNWYWx1ZSBtb2R1bGVfdmFsdWUoSlNDb250ZXh0KiwgSlNNb2R1bGVEZWYqKTsKSlNWYWx1ZSBtb2R1bGVfZW50cnkoSlNDb250ZXh0KiwgSlNNb2R1bGVEZWYqKTsKSlNWYWx1ZSBtb2R1bGVfb2JqZWN0KEpTQ29udGV4dCosIEpTTW9kdWxlRGVmKik7CmNoYXIqIGpzX21vZHVsZV9zZWFyY2goSlNDb250ZXh0KiwgIGNvbnN0IGNoYXIqIHBhdGgsIGNvbnN0IGNoYXIqKTsKY2hhcioganNfbW9kdWxlX3NlYXJjaF9leHQoSlNDb250ZXh0KiwgY29uc3QgY2hhciogcGF0aCwgY29uc3QgY2hhciosIGNvbnN0IGNoYXIqIGV4dCk7CmNoYXIqIGpzX21vZHVsZV9ub3JtYWxpemUoSlNDb250ZXh0KiwgY29uc3QgY2hhciosIGNvbnN0IGNoYXIqIG5hbWUsIHZvaWQqIG9wYXF1ZSk7CkpTTW9kdWxlRGVmKiBqc19tb2R1bGVfZGVmKEpTQ29udGV4dCosIEpTVmFsdWVDb25zdCk7CkpTTW9kdWxlRGVmKiBqc19tb2R1bGVfZmluZChKU0NvbnRleHQqLCBjb25zdCBjaGFyKik7CkpTVmFsdWUganNfaW1wb3J0X2V2YWwoSlNDb250ZXh0KiwgSW1wb3J0RGlyZWN0aXZlKTsKSlNNb2R1bGVEZWYqIGpzX21vZHVsZV9pbXBvcnRfZGVmYXVsdChKU0NvbnRleHQqLCBjb25zdCBjaGFyKiwgY29uc3QgY2hhciogdmFyKTsKSlNNb2R1bGVEZWYqIGpzX21vZHVsZV9pbXBvcnRfbmFtZXNwYWNlKEpTQ29udGV4dCosIGNvbnN0IGNoYXIqLCBjb25zdCBjaGFyKiBucyk7CkpTVmFsdWUganNfbW9kdWxlX2ltcG9ydChKU0NvbnRleHQqLCBjb25zdCBjaGFyKiwgY29uc3QgY2hhciogbnMsIGNvbnN0IGNoYXIqIHZhciwgY29uc3QgY2hhciogcHJvcCk7CkpTTW9kdWxlRGVmKiBqc19tb2R1bGVfbG9hZGVyX3NvKEpTQ29udGV4dCosIGNvbnN0IGNoYXIqKTsKCkpTVmFsdWUganNfZXZhbF9tb2R1bGUoSlNDb250ZXh0KiwgSlNWYWx1ZSwgQk9PTCBsb2FkX29ubHkpOwpKU1ZhbHVlIGpzX2V2YWxfYmluYXJ5KEpTQ29udGV4dCosIGNvbnN0IHVpbnQ4X3QqLCBzaXplX3QgYnVmX2xlbiwgQk9PTCBsb2FkX29ubHkpOwpKU1ZhbHVlIGpzX2V2YWxfYnVmKEpTQ29udGV4dCosIGNvbnN0IHZvaWQqLCBpbnQgYnVmX2xlbiwgY29uc3QgY2hhciogZmlsZW5hbWUsIGludCBldmFsX2ZsYWdzKTsKaW50IGpzX2V2YWxfc3RyKEpTQ29udGV4dCosIGNvbnN0IGNoYXIqLCBjb25zdCBjaGFyKiBmaWxlLCBpbnQgZmxhZ3MpOwoKaW50NjRfdCBqc190aW1lX21zKHZvaWQpOwppbnQganNfaW50ZXJydXB0X2hhbmRsZXIoSlNSdW50aW1lKiwgdm9pZCopOwoKdm9pZCBqc190aW1lcl91bmxpbmsoSlNSdW50aW1lKiwgSlNPU1RpbWVyKik7CnZvaWQganNfdGltZXJfZnJlZShKU1J1bnRpbWUqLCBKU09TVGltZXIqKTsKCnZvaWQganNfY2FsbF9oYW5kbGVyKEpTQ29udGV4dCosIEpTVmFsdWUpOwoKdm9pZCoganNfc2FiX2FsbG9jKHZvaWQqLCBzaXplX3QpOwp2b2lkIGpzX3NhYl9mcmVlKHZvaWQqLCB2b2lkKik7CnZvaWQganNfc2FiX2R1cCh2b2lkKiwgdm9pZCopOwoKSlNXb3JrZXJNZXNzYWdlUGlwZSoganNfbmV3X21lc3NhZ2VfcGlwZSh2b2lkKTsKSlNXb3JrZXJNZXNzYWdlUGlwZSoganNfZHVwX21lc3NhZ2VfcGlwZShKU1dvcmtlck1lc3NhZ2VQaXBlKik7Cgp2b2lkIGpzX2ZyZWVfbWVzc2FnZShKU1dvcmtlck1lc3NhZ2UqKTsKdm9pZCBqc19mcmVlX21lc3NhZ2VfcGlwZShKU1dvcmtlck1lc3NhZ2VQaXBlKik7Cgp2b2lkIGpzX2Vycm9yX2R1bXAoSlNDb250ZXh0KiwgSlNWYWx1ZSwgRHluQnVmKiBkYik7CmNoYXIqIGpzX2Vycm9yX3Rvc3RyaW5nKEpTQ29udGV4dCosIEpTVmFsdWUpOwp2b2lkIGpzX2Vycm9yX3ByaW50KEpTQ29udGV4dCosIEpTVmFsdWUpOwoKI2VuZGlmIC8qIGRlZmluZWQoVVRJTFNfSCkgKi8KAAAAAAAAAACFbwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAFXEAAAAAAAAXcQAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"contents": "Searching 792 files for \"struct\" (regex, case sensitive)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/property-enumeration.h:\n    6  #include \"utils.h\"\n    7  \n    8: typedef struct PropertyEnumeration {\n    9    JSValue obj;\n   10    uint32_t idx;\n   ..\n   14  } PropertyEnumeration;\n   15  \n   16: typedef struct {\n   17    int32_t a, b;\n   18  } IndexTuple;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/vector.h:\n   16  typedef union Vector {\n   17    DynBuf dbuf;\n   18:   struct {\n   19      char* data;\n   20      size_t size;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/ringbuffer.h:\n    5  \n    6  typedef union ringbuffer {\n    7:   struct {\n    8      uint8_t* data;\n    9      size_t size, capacity;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-pointer.c:\n  152  \n  153  static JSValue\n  154: js_pointer_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n  155    JSValue proto;\n  156    /* using new_target to get the prototype is necessary when the\n  ...\n  514    JS_SetClassProto(ctx, js_pointer_class_id, pointer_proto);\n  515  \n  516:   pointer_ctor = JS_NewCFunction2(ctx, js_pointer_constructor, \"Pointer\", 1, JS_CFUNC_constructor, 0);\n  517  \n  518:   JS_SetConstructor(ctx, pointer_ctor, pointer_proto);\n  519    JS_SetPropertyFunctionList(ctx, pointer_ctor, js_pointer_static_funcs, countof(js_pointer_static_funcs));\n  520  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-deep.c:\n   12  thread_local JSValue deep_functions = {JS_TAG_UNDEFINED}, deep_iterator_proto = {JS_TAG_UNDEFINED}, deep_iterator_ctor = {JS_TAG_UNDEFINED};\n   13  \n   14: typedef struct DeepIterator {\n   15    JSValue root;\n   16    Vector frames;\n   ..\n  183  \n  184  static JSValue\n  185: js_deep_iterator_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n  186    JSValue obj = JS_UNDEFINED;\n  187    JSValue proto;\n  ...\n  635  static JSValue\n  636  js_deep_iterate(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst argv[]) {\n  637:   return js_deep_iterator_constructor(ctx, deep_iterator_ctor, argc, argv);\n  638  }\n  639  \n  ...\n  706    JS_SetClassProto(ctx, js_deep_iterator_class_id, deep_iterator_proto);\n  707  \n  708:   deep_iterator_ctor = JS_NewCFunction2(ctx, js_deep_iterator_constructor, \"DeepIterator\", 1, JS_CFUNC_constructor, 0);\n  709  \n  710:   JS_SetConstructor(ctx, deep_iterator_ctor, deep_iterator_proto);\n  711  \n  712    deep_functions = JS_NewObject(ctx);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-location.c:\n  193  \n  194  JSValue\n  195: js_location_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n  196    JSValue obj = JS_UNDEFINED;\n  197    JSValue proto;\n  ...\n  353      JS_NewClass(JS_GetRuntime(ctx), js_location_class_id, &js_location_class);\n  354  \n  355:     location_ctor = JS_NewCFunction2(ctx, js_location_constructor, \"Location\", 1, JS_CFUNC_constructor, 0);\n  356      location_proto = JS_NewObject(ctx);\n  357  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-misc.c:\n   34  };\n   35  \n   36: typedef struct pcg_state_setseq_64 {\n   37    uint64_t state, inc;\n   38  } pcg32_random_t;\n   ..\n  275  static JSValue\n  276  js_misc_getperformancecounter(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst argv[]) {\n  277:   struct timespec ts;\n  278  \n  279    clock_gettime(CLOCK_MONOTONIC, &ts);\n  ...\n  388  static JSValue\n  389  js_misc_hrtime(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst argv[]) {\n  390:   struct timespec ts;\n  391    JSValue ret;\n  392  \n  ...\n  453  static JSValue\n  454  js_misc_uname(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst argv[]) {\n  455:   struct utsname un;\n  456    JSValue ret = JS_UNDEFINED;\n  457  \n  ...\n  874          JSValue proto = JS_GetClassProto(ctx, class_id);\n  875          if(JS_IsObject(proto))\n  876:           ret = JS_GetPropertyStr(ctx, proto, \"constructor\");\n  877          JS_FreeValue(ctx, proto);\n  878        }\n  ...\n 1109      case IS_BOOL: r = JS_IsBool(arg); break;\n 1110      case IS_CFUNCTION: r = JS_GetClassID(arg) == JS_CLASS_C_FUNCTION; break;\n 1111:     case IS_CONSTRUCTOR: r = JS_IsConstructor(ctx, arg); break;\n 1112      case IS_EMPTYSTRING: r = JS_VALUE_GET_TAG(arg) == JS_TAG_STRING && JS_VALUE_GET_STRING(arg)->len == 0; break;\n 1113      case IS_ERROR: r = JS_IsError(ctx, arg); break;\n ....\n 1195      JS_CFUNC_MAGIC_DEF(\"getClassCount\", 1, js_misc_classid, GET_CLASS_COUNT),\n 1196      JS_CFUNC_MAGIC_DEF(\"getClassProto\", 1, js_misc_classid, GET_CLASS_PROTO),\n 1197:     JS_CFUNC_MAGIC_DEF(\"getClassConstructor\", 1, js_misc_classid, GET_CLASS_CONSTRUCTOR),\n 1198      JS_CFUNC_MAGIC_DEF(\"rand\", 0, js_misc_random, RANDOM_RAND),\n 1199      JS_CFUNC_MAGIC_DEF(\"randi\", 0, js_misc_random, RANDOM_RANDI),\n ....\n 1209      JS_CFUNC_MAGIC_DEF(\"isBool\", 1, js_misc_is, IS_BOOL),\n 1210      JS_CFUNC_MAGIC_DEF(\"isCFunction\", 1, js_misc_is, IS_CFUNCTION),\n 1211:     JS_CFUNC_MAGIC_DEF(\"isConstructor\", 1, js_misc_is, IS_CONSTRUCTOR),\n 1212      JS_CFUNC_MAGIC_DEF(\"isEmptyString\", 1, js_misc_is, IS_EMPTYSTRING),\n 1213      JS_CFUNC_MAGIC_DEF(\"isError\", 1, js_misc_is, IS_ERROR),\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pointer.h:\n    6  #include <stdint.h>\n    7  \n    8: typedef struct Pointer {\n    9    size_t n;\n   10    JSAtom* atoms;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-xml.c:\n   23  static int chars[256] = {0};\n   24  \n   25: typedef struct {\n   26    uint32_t idx;\n   27    JSValue obj;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/utils.h:\n  100  extern VISIBLE const char* js_default_module_path;\n  101  \n  102: typedef struct {\n  103    BOOL done;\n  104    JSValue value;\n  105  } IteratorValue;\n  106  \n  107: typedef struct {\n  108    int c;\n  109    const char** v;\n  ...\n  147  }\n  148  \n  149: typedef struct {\n  150    int c;\n  151    JSValueConst* v;\n  ...\n  252  }\n  253  \n  254: typedef struct {\n  255    char* source;\n  256    size_t len;\n  ...\n  279  js_global_new(JSContext* ctx, const char* class_name, int argc, JSValueConst argv[]) {\n  280    JSValue ctor = js_global_get(ctx, class_name);\n  281:   JSValue obj = JS_CallConstructor(ctx, ctor, argc, argv);\n  282    JS_FreeValue(ctx, ctor);\n  283    return obj;\n  ...\n  648  char* js_object_classname(JSContext* ctx, JSValueConst value);\n  649  int js_object_is(JSContext* ctx, JSValueConst value, const char* cmp);\n  650: JSValue js_object_construct(JSContext* ctx, JSValueConst ctor);\n  651  JSValue js_object_error(JSContext* ctx, const char* message);\n  652  JSValue js_object_stack(JSContext* ctx);\n  ...\n  768  \n  769  JSValue js_typedarray_prototype(JSContext* ctx);\n  770: JSValue js_typedarray_constructor(JSContext* ctx);\n  771  \n  772  static inline BOOL\n  ...\n  847  JSValue js_date_from_ms(JSContext*, int64_t ms);\n  848  JSValue js_date_from_time_ns(JSContext*, time_t t, long ns);\n  849: JSValue js_date_from_timespec(JSContext*, const struct timespec ts);\n  850  int64_t js_date_gettime(JSContext*, JSValue arg);\n  851  int64_t js_date_time(JSContext*, JSValue arg);\n  852: struct timespec js_date_timespec(JSContext*, JSValue arg);\n  853  \n  854  void js_arraybuffer_freevalue(JSRuntime*, void* opaque, void* ptr);\n  ...\n  858  \n  859  typedef union import_directive {\n  860:   struct {\n  861      const char* path; /**< Module path */\n  862      const char* spec; /**< Import specifier(s) */\n  ...\n  874  void get_module_exports(JSContext*, JSModuleDef*, BOOL rename_default, JSValueConst exports);\n  875  JSValue module_exports(JSContext*, JSModuleDef*);\n  876: struct list_head* js_modules_list(JSContext*);\n  877  JSValue js_modules_array(JSContext*, JSValueConst, int magic);\n  878  JSValue js_modules_entries(JSContext*, JSValueConst, int magic);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-archive.c:\n   60  };\n   61  \n   62: static JSValue js_archiveentry_wrap_proto(JSContext* ctx, JSValueConst proto, struct archive_entry* ent);\n   63: static JSValue js_archiveentry_wrap(JSContext* ctx, struct archive_entry* ent);\n   64  \n   65: struct ArchiveInstance {\n   66    JSValue archive;\n   67  };\n   68: struct ArchiveEntryRef {\n   69    JSContext* ctx;\n   70    JSValueConst callback, args[2];\n   ..\n   73  static void\n   74  js_archive_free_buffer(JSRuntime* rt, void* opaque, void* ptr) {\n   75:   struct ArchiveInstance* ainst = opaque;\n   76    JS_FreeValueRT(rt, ainst->archive);\n   77    js_free_rt(rt, ainst);\n   ..\n   80  static void\n   81  js_archive_progress_callback(void* opaque) {\n   82:   struct ArchiveEntryRef* aeref = opaque;\n   83  \n   84    JSValue ret = JS_Call(aeref->ctx, aeref->callback, JS_UNDEFINED, 2, aeref->args);\n   ..\n   86  }\n   87  \n   88: struct archive*\n   89  js_archive_data(JSContext* ctx, JSValueConst value) {\n   90:   struct archive* ar;\n   91    ar = JS_GetOpaque2(ctx, value, js_archive_class_id);\n   92    return ar;\n   ..\n   94  \n   95  static JSValue\n   96: js_archive_wrap_proto(JSContext* ctx, JSValueConst proto, struct archive* ar) {\n   97    JSValue obj;\n   98  \n   ..\n  117  \n  118  static JSValue\n  119: js_archive_wrap(JSContext* ctx, struct archive* ar) {\n  120    return js_archive_wrap_proto(ctx, archive_proto, ar);\n  121  }\n  ...\n  123  static JSValue\n  124  js_archive_functions(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst argv[], int magic) {\n  125:   struct archive* ar = 0;\n  126    JSValue proto = JS_GetPropertyStr(ctx, this_val, \"prototype\");\n  127    JSValue ret = JS_UNDEFINED;\n  ...\n  181  static JSValue\n  182  js_archive_getter(JSContext* ctx, JSValueConst this_val, int magic) {\n  183:   struct archive* ar;\n  184    JSValue ret = JS_UNDEFINED;\n  185  \n  ...\n  212  static JSValue\n  213  js_archive_setter(JSContext* ctx, JSValueConst this_val, JSValueConst value, int magic) {\n  214:   struct archive* ar;\n  215    JSValue ret = JS_UNDEFINED;\n  216  \n  ...\n  223  \n  224  static JSValue\n  225: js_archive_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n  226    JSValue obj = JS_UNDEFINED;\n  227    JSValue proto;\n  ...\n  243  js_archive_next(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst argv[], BOOL* pdone, int magic) {\n  244    JSValue ret = JS_UNDEFINED;\n  245:   struct archive* ar;\n  246:   struct archive_entry* ent;\n  247    int result;\n  248  \n  ...\n  273  js_archive_read(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst argv[]) {\n  274    JSValue ret = JS_UNDEFINED;\n  275:   struct archive* ar;\n  276    uint8_t* ptr;\n  277    size_t len;\n  ...\n  288      switch(archive_read_data_block(ar, &data, &size, &offset)) {\n  289        case ARCHIVE_OK: {\n  290:         struct ArchiveInstance* abuf = js_malloc(ctx, sizeof(struct ArchiveInstance));\n  291          abuf->archive = JS_DupValue(ctx, this_val);\n  292          ret = JS_NewArrayBuffer(ctx, data, size, js_archive_free_buffer, abuf, FALSE);\n  ...\n  333  js_archive_seek(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst argv[]) {\n  334    JSValue ret = JS_UNDEFINED;\n  335:   struct archive* ar;\n  336    int64_t offset = 0;\n  337    int32_t whence = 0;\n  ...\n  350  js_archive_extract(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst argv[]) {\n  351    JSValue ret = JS_UNDEFINED;\n  352:   struct archive* ar;\n  353:   struct archive_entry* ent;\n  354    int32_t flags;\n  355:   struct ArchiveEntryRef* aeref = 0;\n  356  \n  357    if(!(ar = js_archive_data(ctx, this_val)))\n  ...\n  365  \n  366    if(argc >= 3) {\n  367:     if(!(aeref = js_malloc(ctx, sizeof(struct ArchiveEntryRef))))\n  368        return JS_ThrowOutOfMemory(ctx);\n  369      aeref->ctx = ctx;\n  ...\n  388  js_archive_filterbytes(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst argv[]) {\n  389    JSValue ret = JS_UNDEFINED;\n  390:   struct archive* ar;\n  391    int32_t index = -1;\n  392  \n  ...\n  405  js_archive_close(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst argv[]) {\n  406    JSValue ret = JS_UNDEFINED;\n  407:   struct archive* ar;\n  408  \n  409    if(!(ar = js_archive_data(ctx, this_val)))\n  ...\n  427  static void\n  428  js_archive_finalizer(JSRuntime* rt, JSValue val) {\n  429:   struct archive* ar = JS_GetOpaque(val, js_archive_class_id);\n  430    if(ar) {\n  431      archive_free(ar);\n  ...\n  736  };\n  737  \n  738: struct archive_entry*\n  739  js_archiveentry_data(JSContext* ctx, JSValueConst value) {\n  740:   struct archive_entry* ent;\n  741    ent = JS_GetOpaque2(ctx, value, js_archiveentry_class_id);\n  742    return ent;\n  ...\n  744  \n  745  static JSValue\n  746: js_archiveentry_wrap_proto(JSContext* ctx, JSValueConst proto, struct archive_entry* ent) {\n  747    JSValue obj;\n  748  \n  ...\n  768  \n  769  static JSValue\n  770: js_archiveentry_wrap(JSContext* ctx, struct archive_entry* ent) {\n  771    return js_archiveentry_wrap_proto(ctx, archiveentry_proto, ent);\n  772  }\n  ...\n  774  static JSValue\n  775  js_archiveentry_getter(JSContext* ctx, JSValueConst this_val, int magic) {\n  776:   struct archive_entry* ent;\n  777    JSValue ret = JS_UNDEFINED;\n  778  \n  ...\n  908  static JSValue\n  909  js_archiveentry_setter(JSContext* ctx, JSValueConst this_val, JSValueConst value, int magic) {\n  910:   struct archive_entry* ent;\n  911    JSValue ret = JS_UNDEFINED;\n  912  \n  ...\n  919          archive_entry_unset_atime(ent);\n  920        } else {\n  921:         struct timespec ts = js_date_timespec(ctx, value);\n  922          archive_entry_set_atime(ent, ts.tv_sec, ts.tv_nsec);\n  923        }\n  ...\n  928          archive_entry_unset_ctime(ent);\n  929        } else {\n  930:         struct timespec ts = js_date_timespec(ctx, value);\n  931          archive_entry_set_ctime(ent, ts.tv_sec, ts.tv_nsec);\n  932        }\n  ...\n  937          archive_entry_unset_mtime(ent);\n  938        } else {\n  939:         struct timespec ts = js_date_timespec(ctx, value);\n  940          archive_entry_set_mtime(ent, ts.tv_sec, ts.tv_nsec);\n  941        }\n  ...\n  946          archive_entry_unset_birthtime(ent);\n  947        } else {\n  948:         struct timespec ts = js_date_timespec(ctx, value);\n  949          archive_entry_set_birthtime(ent, ts.tv_sec, ts.tv_nsec);\n  950        }\n  ...\n 1122  \n 1123  static JSValue\n 1124: js_archiveentry_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n 1125    JSValue obj = JS_UNDEFINED;\n 1126  \n ....\n 1140  static void\n 1141  js_archiveentry_finalizer(JSRuntime* rt, JSValue val) {\n 1142:   struct archive_entry* ent = JS_GetOpaque(val, js_archiveentry_class_id);\n 1143    if(ent) {\n 1144      archive_entry_free(ent);\n ....\n 1189      JS_NewClass(JS_GetRuntime(ctx), js_archive_class_id, &js_archive_class);\n 1190  \n 1191:     archive_ctor = JS_NewCFunction2(ctx, js_archive_constructor, \"Archive\", 1, JS_CFUNC_constructor, 0);\n 1192      archive_proto = JS_NewObject(ctx);\n 1193  \n ....\n 1199      JS_NewClass(JS_GetRuntime(ctx), js_archiveentry_class_id, &js_archiveentry_class);\n 1200  \n 1201:     archiveentry_ctor = JS_NewCFunction2(ctx, js_archiveentry_constructor, \"ArchiveEntry\", 1, JS_CFUNC_constructor, 0);\n 1202      archiveentry_proto = JS_NewObject(ctx);\n 1203  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/child-process.c:\n   11  #include <errno.h>\n   12  \n   13: static struct list_head child_process_list = LIST_HEAD_INIT(child_process_list);\n   14  \n   15  void\n   ..\n   19  ChildProcess*\n   20  child_process_get(int pid) {\n   21:   struct list_head* el;\n   22    list_for_each(el, &child_process_list) {\n   23      ChildProcess* cp = list_entry(el, ChildProcess, link);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/gpio.h:\n    5  #include <stdint.h>\n    6  \n    7: struct gpio {\n    8    int fd;\n    9    uint32_t* map;\n   ..\n   11  };\n   12  \n   13: bool gpio_open(struct gpio*);\n   14: void gpio_close(struct gpio*);\n   15: void gpio_init_pin(struct gpio*, const uint8_t pin, const bool output);\n   16: void gpio_set_pin(struct gpio*, const uint8_t pin, const bool value);\n   17: bool gpio_get_pin(struct gpio*, const uint8_t pin);\n   18  \n   19  #endif // GPIO_H\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-stringdecoder.c:\n   81  \n   82  static JSValue\n   83: js_stringdecoder_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n   84    JSValue obj = JS_UNDEFINED;\n   85    JSValue proto;\n   ..\n  209      JS_NewClass(JS_GetRuntime(ctx), js_stringdecoder_class_id, &js_stringdecoder_class);\n  210  \n  211:     stringdecoder_ctor = JS_NewCFunction2(ctx, js_stringdecoder_constructor, \"StringDecoder\", 1, JS_CFUNC_constructor, 0);\n  212      stringdecoder_proto = JS_NewObject(ctx);\n  213  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/child-process.h:\n    7  #include <stdint.h>\n    8  \n    9: typedef struct ChildProcess {\n   10    char* file;\n   11    char* cwd;\n   ..\n   19    int num_fds;\n   20    int *child_fds, *parent_fds;\n   21:   struct list_head link;\n   22  } ChildProcess;\n   23  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/buffer-utils.h:\n   98  }\n   99  \n  100: struct memory_block;\n  101: struct pointer_range;\n  102: struct offset_length;\n  103  \n  104: typedef struct memory_block {\n  105    uint8_t* base;\n  106    size_t size;\n  ...\n  123  }\n  124  \n  125: typedef struct pointer_range {\n  126    uint8_t *start, *end;\n  127  } PointerRange;\n  ...\n  137  }\n  138  \n  139: typedef struct offset_length {\n  140    int64_t offset, length;\n  141  } OffsetLength;\n  ...\n  196  \n  197  static inline MemoryBlock\n  198: block_range(const MemoryBlock* mb, struct offset_length* range) {\n  199    MemoryBlock ret;\n  200    ret.base = mb->base + range->offset;\n  ...\n  203  }\n  204  \n  205: typedef struct InputBuffer {\n  206    uint8_t* data;\n  207    size_t pos, size;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/utils.c:\n   42  uint64_t\n   43  time_us(void) {\n   44:   struct timespec ts;\n   45    clock_gettime(CLOCK_MONOTONIC, &ts);\n   46    return (uint64_t)ts.tv_sec * 1000000 + (ts.tv_nsec / 1000);\n   ..\n   50  uint64_t\n   51  time_us(void) {\n   52:   struct timeval tv;\n   53    gettimeofday(&tv, 0);\n   54    return (int64_t)tv.tv_sec * 1000000 + tv.tv_usec;\n   ..\n  142    JSValueConst args[2] = {JS_NewStringLen(ctx, re.source, re.len), JS_NewStringLen(ctx, flagstr, flaglen)};\n  143    JSValue regex, ctor = js_global_get(ctx, \"RegExp\");\n  144:   regex = JS_CallConstructor(ctx, ctor, 2, args);\n  145    JS_FreeValue(ctx, args[0]);\n  146    JS_FreeValue(ctx, args[1]);\n  ...\n  416  \n  417  JSValue\n  418: js_object_constructor(JSContext* ctx, JSValueConst value) {\n  419    JSValue ctor = JS_UNDEFINED;\n  420    if(JS_IsObject(value))\n  421:     ctor = JS_GetPropertyStr(ctx, value, \"constructor\");\n  422    return ctor;\n  423  }\n  ...\n  429    char* name = 0;\n  430    int namelen;\n  431:   ctor = js_object_constructor(ctx, value);\n  432    if(!JS_IsFunction(ctx, ctor)) {\n  433      proto = JS_GetPrototype(ctx, value);\n  434:     ctor = js_object_constructor(ctx, proto);\n  435    }\n  436    if((str = JS_ToCString(ctx, ctor))) {\n  ...\n  488  \n  489  JSValue\n  490: js_object_construct(JSContext* ctx, JSValueConst ctor) {\n  491    JSValueConst args[] = {JS_UNDEFINED};\n  492:   return JS_CallConstructor(ctx, ctor, 0, args);\n  493  }\n  494  \n  ...\n  512  js_object_new(JSContext* ctx, const char* class_name, int argc, JSValueConst argv[]) {\n  513    JSValue ctor = js_global_get(ctx, class_name);\n  514:   JSValue obj = JS_CallConstructor(ctx, ctor, argc, argv);\n  515    JS_FreeValue(ctx, ctor);\n  516    return obj;\n  ...\n 1276  js_map_new(JSContext* ctx, JSValueConst entries) {\n 1277    JSValue map, ctor = js_global_get(ctx, \"Map\");\n 1278:   map = JS_CallConstructor(ctx, ctor, 1, &entries);\n 1279    JS_FreeValue(ctx, ctor);\n 1280    return map;\n ....\n 1363  }\n 1364  \n 1365: struct list_head*\n 1366  js_modules_list(JSContext* ctx) {\n 1367    return &ctx->loaded_modules;\n ....\n 1370  JSValue\n 1371  js_modules_array(JSContext* ctx, JSValueConst this_val, int magic) {\n 1372:   struct list_head* el;\n 1373    JSValue ret = JS_NewArray(ctx);\n 1374    uint32_t i = 0;\n ....\n 1388  JSValue\n 1389  js_modules_entries(JSContext* ctx, JSValueConst this_val, int magic) {\n 1390:   struct list_head* el;\n 1391    JSValue ret = JS_NewArray(ctx);\n 1392    uint32_t i = 0;\n ....\n 1416  JSValue\n 1417  js_modules_object(JSContext* ctx, JSValueConst this_val, int magic) {\n 1418:   struct list_head* it;\n 1419    JSValue obj = JS_NewObject(ctx);\n 1420    list_for_each(it, &ctx->loaded_modules) {\n ....\n 1488    char* file = 0;\n 1489    size_t i, j;\n 1490:   struct stat st;\n 1491  \n 1492      for(p = path; *p; p = q) {\n ....\n 1565  JSModuleDef*\n 1566  js_module_find(JSContext* ctx, const char* name) {\n 1567:   struct list_head* el;\n 1568    size_t namelen = strlen(name);\n 1569    list_for_each(el, &ctx->loaded_modules) {\n ....\n 1816  \n 1817  JSValue\n 1818: js_typedarray_constructor(JSContext* ctx) {\n 1819    JSValue typedarr_proto = js_typedarray_prototype(ctx);\n 1820:   JSValue typedarr_ctor = JS_GetPropertyStr(ctx, typedarr_proto, \"constructor\");\n 1821    JS_FreeValue(ctx, typedarr_proto);\n 1822    return typedarr_ctor;\n ....\n 1868  js_date_new(JSContext* ctx, JSValueConst arg) {\n 1869    JSValue ctor = js_global_get(ctx, \"Date\");\n 1870:   JSValue ret = JS_CallConstructor(ctx, ctor, 1, &arg);\n 1871    JS_FreeValue(ctx, ctor);\n 1872    return ret;\n ....\n 1887  \n 1888  JSValue\n 1889: js_date_from_timespec(JSContext* ctx, const struct timespec ts) {\n 1890    return js_date_from_time_ns(ctx, ts.tv_sec, ts.tv_nsec);\n 1891  }\n ....\n 1913  }\n 1914  \n 1915: struct timespec\n 1916  js_date_timespec(JSContext* ctx, JSValue arg) {\n 1917:   struct timespec ts;\n 1918    int64_t r = js_date_time(ctx, arg);\n 1919    ts.tv_sec = r / 1000ull;\n ....\n 2013  int64_t\n 2014  js_time_ms(void) {\n 2015:   struct timespec ts;\n 2016    clock_gettime(CLOCK_MONOTONIC, &ts);\n 2017    return (uint64_t)ts.tv_sec * 1000 + (ts.tv_nsec / 1000000);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/virtual-properties.h:\n    6  #include \"utils.h\"\n    7  \n    8: struct VProps;\n    9  \n   10: typedef BOOL has_function_t(struct VProps*, JSContext*, JSValueConst);\n   11: typedef BOOL delete_function_t(struct VProps*, JSContext*, JSValueConst);\n   12: typedef JSValue get_function_t(struct VProps*, JSContext*, JSValueConst);\n   13: typedef int set_function_t(struct VProps*, JSContext*, JSValueConst, JSValue);\n   14: typedef void destroy_function_t(struct VProps*, JSContext*);\n   15  \n   16: typedef struct VProps {\n   17    JSValue this_obj;\n   18    has_function_t* has;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-archive.h:\n    2  #define QUICKJS_ARCHIVE_H\n    3  \n    4: struct archive;\n    5  \n    6  #include <quickjs.h>\n    7  #include <cutils.h>\n    8  \n    9: struct archive* js_archive_data(JSContext*, JSValue value);\n   10: struct archive_entry* js_archiveentry_data(JSContext*, JSValue value);\n   11  int js_archive_init(JSContext*, JSModuleDef* m);\n   12  JSModuleDef* js_init_module_archive(JSContext*, const char* module_name);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lexer.h:\n    7  #include <string.h>\n    8  \n    9: typedef struct {\n   10    char* name;\n   11    char* expr;\n   ..\n   31  };\n   32  \n   33: typedef struct {\n   34    enum lexer_mode mode;\n   35    size_t start, byte_length;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-lexer.h:\n    5  #include \"list.h\"\n    6  \n    7: typedef struct {\n    8    Location loc;\n    9    const char* line;\n   ..\n   11  } SyntaxError;\n   12  \n   13: typedef struct {\n   14    int id;\n   15    char* lexeme;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/virtual-properties.c:\n    2  #include \"utils.h\"\n    3  \n    4: struct MapAdapter {\n    5    JSAtom has, delete, get, set;\n    6  };\n    .\n    8  static BOOL\n    9  map_has(VirtualProperties* vp, JSContext* ctx, JSValueConst prop) {\n   10:   struct MapAdapter* adapter = vp->opaque;\n   11    JSValue ret;\n   12    ret = JS_Invoke(ctx, vp->this_obj, adapter->has, 1, &prop);\n   ..\n   16  static BOOL\n   17  map_delete(VirtualProperties* vp, JSContext* ctx, JSValueConst prop) {\n   18:   struct MapAdapter* adapter = vp->opaque;\n   19    JSValue ret;\n   20    ret = JS_Invoke(ctx, vp->this_obj, adapter->delete, 1, &prop);\n   ..\n   24  static JSValue\n   25  map_get(VirtualProperties* vp, JSContext* ctx, JSValueConst prop) {\n   26:   struct MapAdapter* adapter = vp->opaque;\n   27    return JS_Invoke(ctx, vp->this_obj, adapter->get, 1, &prop);\n   28  }\n   ..\n   30  static int\n   31  map_set(VirtualProperties* vp, JSContext* ctx, JSValueConst prop, JSValue value) {\n   32:   struct MapAdapter* adapter = vp->opaque;\n   33    int32_t r = -1;\n   34    JSValueConst args[2] = {prop, value};\n   ..\n   41  static void\n   42  map_finalizer(VirtualProperties* vp, JSContext* ctx) {\n   43:   struct MapAdapter* adapter = vp->opaque;\n   44    JS_FreeAtom(ctx, adapter->has);\n   45    JS_FreeAtom(ctx, adapter->delete);\n   ..\n   53  virtual_properties_map(JSContext* ctx, JSValueConst map) {\n   54    JSValue map_prototype, map_obj;\n   55:   struct MapAdapter* adapter = js_mallocz(ctx, sizeof(struct MapAdapter));\n   56    map_obj = JS_DupValue(ctx, map);\n   57  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/predicate.h:\n   37  };\n   38  \n   39: typedef struct {\n   40    int flags;\n   41  } TypePredicate;\n   42  \n   43: typedef struct {\n   44    char* set;\n   45    size_t len;\n   ..\n   47  } CharsetPredicate;\n   48  \n   49: typedef struct {\n   50    char* str;\n   51    size_t len;\n   52  } StringPredicate;\n   53  \n   54: typedef struct {\n   55    JSValue predicate;\n   56  } UnaryPredicate;\n   57  \n   58: typedef struct {\n   59    JSValueConst left, right;\n   60  } BinaryPredicate;\n   61  \n   62: typedef struct {\n   63    size_t npredicates;\n   64    JSValue* predicates;\n   65  } BooleanPredicate;\n   66  \n   67: typedef struct {\n   68    RegExp expr;\n   69    uint8_t* bytecode;\n   70  } RegExpPredicate;\n   71  \n   72: typedef struct {\n   73    JSAtom atom;\n   74    JSValue predicate;\n   75  } PropertyPredicate;\n   76  \n   77: typedef struct {\n   78    JSValue object;\n   79  } MemberPredicate;\n   80  \n   81: typedef struct {\n   82    int n;\n   83    JSValue predicate;\n   84  } ShiftPredicate;\n   85  \n   86: typedef struct {\n   87    JSValue func, this_val;\n   88    int arity;\n   89  } FunctionPredicate;\n   90  \n   91: typedef struct Predicate {\n   92    enum predicate_id id;\n   93    union {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-gpio.c:\n   15  };\n   16  \n   17: struct gpio*\n   18  js_gpio_data(JSContext* ctx, JSValueConst value) {\n   19:   struct gpio* gpio;\n   20    gpio = JS_GetOpaque2(ctx, value, js_gpio_class_id);\n   21    return gpio;\n   ..\n   23  \n   24  static JSValue\n   25: js_gpio_wrap_proto(JSContext* ctx, JSValueConst proto, struct gpio* gpio) {\n   26    JSValue obj;\n   27  \n   ..\n   46  \n   47  static JSValue\n   48: js_gpio_wrap(JSContext* ctx, struct gpio* gpio) {\n   49    return js_gpio_wrap_proto(ctx, gpio_proto, gpio);\n   50  }\n   ..\n   52  static JSValue\n   53  js_gpio_functions(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst argv[], int magic) {\n   54:   struct gpio* gpio;\n   55    JSValue ret = JS_UNDEFINED;\n   56  \n   ..\n   89  static JSValue\n   90  js_gpio_getter(JSContext* ctx, JSValueConst this_val, int magic) {\n   91:   struct gpio* gpio;\n   92    JSValue ret = JS_UNDEFINED;\n   93  \n   ..\n  101  static JSValue\n  102  js_gpio_setter(JSContext* ctx, JSValueConst this_val, JSValueConst value, int magic) {\n  103:   struct gpio* gpio;\n  104    JSValue ret = JS_UNDEFINED;\n  105  \n  ...\n  112  \n  113  static JSValue\n  114: js_gpio_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n  115:   struct gpio* gpio;\n  116    JSValue obj = JS_UNDEFINED, proto = JS_UNDEFINED;\n  117  \n  118:   if(!(gpio = js_mallocz(ctx, sizeof(struct gpio))))\n  119      return JS_EXCEPTION;\n  120  \n  ...\n  142  static void\n  143  js_gpio_finalizer(JSRuntime* rt, JSValue val) {\n  144:   struct gpio* gpio = JS_GetOpaque(val, js_gpio_class_id);\n  145    if(gpio) {\n  146      gpio_close(gpio);\n  ...\n  175      JS_NewClass(JS_GetRuntime(ctx), js_gpio_class_id, &js_gpio_class);\n  176  \n  177:     gpio_ctor = JS_NewCFunction2(ctx, js_gpio_constructor, \"GPIO\", 1, JS_CFUNC_constructor, 0);\n  178      gpio_proto = JS_NewObject(ctx);\n  179  \n  180      JS_SetPropertyFunctionList(ctx, gpio_proto, js_gpio_funcs, countof(js_gpio_funcs));\n  181      JS_SetPropertyFunctionList(ctx, gpio_ctor, js_gpio_static_funcs, countof(js_gpio_static_funcs));\n  182:     JS_SetConstructor(ctx, gpio_ctor, gpio_proto);\n  183      // JS_SetClassProto(ctx, js_gpio_class_id, gpio_proto);\n  184    }\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/path.c:\n  191  int\n  192  path_exists(const char* p) {\n  193:   struct stat st;\n  194    int r;\n  195    return ((r = lstat(p, &st)) == 0);\n  ...\n  211  path_find(const char* path, const char* name, DynBuf* db) {\n  212    DIR* dir;\n  213:   struct dirent* entry;\n  214    int ret = 0;\n  215  \n  ...\n  397  int\n  398  path_is_directory(const char* p) {\n  399:   struct stat st;\n  400    int r;\n  401    if((r = lstat(p, &st) == 0)) {\n  ...\n  408  int\n  409  path_is_symlink(const char* p) {\n  410:   struct stat st;\n  411    int r;\n  412    if((r = lstat(p, &st) == 0)) {\n  ...\n  420  path_normalize(const char* path, DynBuf* db, int symbolic) {\n  421    size_t n;\n  422:   struct stat st;\n  423    int ret = 1;\n  424    char sep, buf[PATH_MAX + 1];\n  425:   int (*stat_fn)(const char*, struct stat*) = stat;\n  426    if(symbolic)\n  427      stat_fn = lstat;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-blob.c:\n  112  \n  113  static JSValue\n  114: js_blob_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n  115    JSValue obj = JS_UNDEFINED;\n  116    JSValue proto;\n  ...\n  287      JS_NewClass(JS_GetRuntime(ctx), js_blob_class_id, &js_blob_class);\n  288  \n  289:     blob_ctor = JS_NewCFunction2(ctx, js_blob_constructor, \"Blob\", 1, JS_CFUNC_constructor, 0);\n  290      blob_proto = JS_NewObject(ctx);\n  291  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/gpio.c:\n   51  \n   52  bool\n   53: gpio_open(struct gpio* gpio) {\n   54  \n   55    const char* dbg = getenv(\"DEBUG\");\n   ..\n   76  \n   77  void\n   78: gpio_close(struct gpio* gpio) {\n   79    munmap(gpio->map, MAP_SIZE);\n   80    close(gpio->fd);\n   ..\n   82  \n   83  void\n   84: gpio_init_pin(struct gpio* gpio, const uint8_t pin, const bool output) {\n   85    *(gpio->map + fsel[pin]) &= ~(1 << fsel_shift[pin]);\n   86    *(gpio->map + fsel[pin]) |= (output << fsel_shift[pin]);\n   ..\n   91  \n   92  void\n   93: gpio_set_pin(struct gpio* gpio, const uint8_t pin, const bool value) {\n   94    if(value) {\n   95      *(gpio->map + set[pin]) &= ~(1 << set_shift[pin]);\n   ..\n  105  \n  106  bool\n  107: gpio_get_pin(struct gpio* gpio, const uint8_t pin) {\n  108    const bool value = *(gpio->map + lvl[pin]) & (1 << lvl_shift[pin]);\n  109  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-gpio.h:\n    2  #define QUICKJS_GPIO_H\n    3  \n    4: struct gpio;\n    5  \n    6  #include <quickjs.h>\n    7  #include <cutils.h>\n    8  \n    9: struct gpio* js_gpio_data(JSContext*, JSValue value);\n   10  int js_gpio_init(JSContext*, JSModuleDef* m);\n   11  JSModuleDef* js_init_module_gpio(JSContext*, const char* module_name);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-inspect.c:\n   29         : 0)\n   30  \n   31: typedef struct {\n   32    int colors : 1;\n   33    int show_hidden : 1;\n   ..\n   46  } inspect_options_t;\n   47  \n   48: struct prop_key;\n   49  \n   50: typedef struct prop_key {\n   51:   struct list_head link;\n   52    const char* name;\n   53    JSAtom atom;\n   ..\n   81  #ifdef HAVE_TERMIOS_H\n   82    {\n   83:     struct winsize w = {.ws_col = -1, .ws_row = -1};\n   84  \n   85      if(stdout_isatty)\n   ..\n 1008  js_inspect_stacktrace_value(JSContext* ctx) {\n 1009    JSRuntime* rt = JS_GetRuntime(ctx);\n 1010:   struct JSStackFrame* frame;\n 1011    JSValue ret = JS_UNDEFINED;\n 1012    if((frame = rt->current_stack_frame)) {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-blob.h:\n    7  \n    8  typedef union blob {\n    9:   struct {\n   10      uint8_t* data;\n   11      size_t size, capacity;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-sockets.c:\n  157  \n  158  static JSValue\n  159: js_sockaddr_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n  160    JSValue proto, obj = JS_UNDEFINED;\n  161    SockAddr* a;\n  ...\n  358  \n  359  static BOOL\n  360: timeval_read(JSContext* ctx, JSValueConst arg, struct timeval* tv) {\n  361    if(JS_IsNumber(arg)) {\n  362      double msecs = 0;\n  ...\n  381      size_t len;\n  382      if((data = JS_GetArrayBuffer(ctx, &len, arg))) {\n  383:       if(len >= sizeof(struct timeval)) {\n  384:         memcpy(tv, data, sizeof(struct timeval));\n  385          return TRUE;\n  386        }\n  ...\n  391  \n  392  static BOOL\n  393: timeval_write(JSContext* ctx, const struct timeval* tv, JSValueConst arg) {\n  394    if(JS_IsNumber(arg)) {\n  395      return FALSE;\n  ...\n  403      size_t len;\n  404      if((data = JS_GetArrayBuffer(ctx, &len, arg))) {\n  405:       if(len >= sizeof(struct timeval)) {\n  406:         memcpy(data, tv, sizeof(struct timeval));\n  407          return TRUE;\n  408        }\n  ...\n  469  \n  470  static BOOL\n  471: pollfd_read(JSContext* ctx, JSValueConst arg, struct pollfd* pfd) {\n  472    if(js_is_array(ctx, arg) && js_array_length(ctx, arg) >= 2) {\n  473      pfd->fd = js_get_propertyint_int32(ctx, arg, 0);\n  ...\n  488      size_t len;\n  489      if((data = JS_GetArrayBuffer(ctx, &len, arg))) {\n  490:       if(len >= sizeof(struct pollfd)) {\n  491:         memcpy(pfd, data, MIN_NUM(len, sizeof(struct pollfd)));\n  492          return TRUE;\n  493        }\n  ...\n  498  \n  499  static BOOL\n  500: pollfd_write(JSContext* ctx, const struct pollfd* pfd, JSValueConst arg) {\n  501    if(js_is_array(ctx, arg)) {\n  502      js_array_clear(ctx, arg);\n  ...\n  514      size_t len;\n  515      if((data = JS_GetArrayBuffer(ctx, &len, arg))) {\n  516:       if(len >= sizeof(struct pollfd)) {\n  517:         memcpy(data, pfd, MIN_NUM(len, sizeof(struct pollfd)));\n  518          return TRUE;\n  519        }\n  ...\n  593    fd_set *rset = 0, *wset = 0, *eset = 0;\n  594    int ret;\n  595:   struct timeval tv = {0, 0}, *timeout = 0;\n  596    JS_ToIndex(ctx, &n, argv[0]);\n  597    FD_ZERO(&rfds);\n  ...\n  633    uint32_t nfds = 0;\n  634    int32_t timeout = -1;\n  635:   struct pollfd* pfds;\n  636    BOOL is_array = js_is_array(ctx, argv[0]), is_arraybuffer = js_is_arraybuffer(ctx, argv[0]);\n  637  \n  ...\n  644        nfds = js_array_length(ctx, argv[0]);\n  645      else if(is_arraybuffer)\n  646:       nfds = js_arraybuffer_bytelength(ctx, argv[0]) / sizeof(struct pollfd);\n  647    }\n  648    assert(nfds);\n  649:   pfds = alloca(sizeof(struct pollfd) * nfds);\n  650  \n  651    if(is_array) {\n  ...\n  663      size_t len;\n  664      if((data = JS_GetArrayBuffer(ctx, &len, argv[0]))) {\n  665:       if(len > 0 && (len % sizeof(struct pollfd)) == 0) {\n  666:         memcpy(pfds, data, MIN_NUM(len, sizeof(struct pollfd) * nfds));\n  667        } else {\n  668          return JS_ThrowInternalError(ctx, \"pfds[] length = %zu\", len);\n  ...\n  686      size_t len;\n  687      if((data = JS_GetArrayBuffer(ctx, &len, argv[0]))) {\n  688:       if(len > 0 && (len % sizeof(struct pollfd)) == 0) {\n  689:         memcpy(data, pfds, MIN_NUM(len, sizeof(struct pollfd) * nfds));\n  690        } else {\n  691          return JS_ThrowInternalError(ctx, \"pfds[] length = %zu\", len);\n  ...\n  803        SockAddr* a = sockaddr_new(ctx);\n  804        socklen_t len = sizeof(SockAddr);\n  805:       JS_SOCKETCALL_RETURN(SYSCALL_GETSOCKNAME, sock, getsockname(sock.fd, (struct sockaddr*)a, &len), js_sockaddr_wrap(ctx, a), JS_NULL);\n  806        break;\n  807      }\n  ...\n  809        SockAddr* a = sockaddr_new(ctx);\n  810        socklen_t len = sizeof(SockAddr);\n  811:       JS_SOCKETCALL_RETURN(SYSCALL_GETPEERNAME, sock, getpeername(sock.fd, (struct sockaddr*)a, &len), js_sockaddr_wrap(ctx, a), JS_NULL);\n  812        break;\n  813      }\n  ...\n  889      }\n  890      case SOCKET_BIND: {\n  891:       JS_SOCKETCALL(SYSCALL_BIND, sock, bind(sock.fd, (struct sockaddr*)a, sockaddr_size(a)));\n  892        break;\n  893      }\n  894      case SOCKET_ACCEPT: {\n  895        socklen_t addrlen = sizeof(SockAddr);\n  896:       JS_SOCKETCALL(SYSCALL_ACCEPT, sock, accept(sock.fd, (struct sockaddr*)a, &addrlen));\n  897        break;\n  898      }\n  899      case SOCKET_CONNECT: {\n  900:       JS_SOCKETCALL(SYSCALL_CONNECT, sock, connect(sock.fd, (struct sockaddr*)a, sockaddr_size(a)));\n  901        break;\n  902      }\n  ...\n 1038  \n 1039  static JSValue\n 1040: js_socket_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n 1041    JSValue obj = JS_UNDEFINED;\n 1042    JSValue proto;\n ....\n 1752      JS_NewClass(JS_GetRuntime(ctx), js_sockaddr_class_id, &js_sockaddr_class);\n 1753  \n 1754:     sockaddr_ctor = JS_NewCFunction2(ctx, js_sockaddr_constructor, \"SockAddr\", 1, JS_CFUNC_constructor, 0);\n 1755      sockaddr_proto = JS_NewObject(ctx);\n 1756  \n ....\n 1763      JS_NewClass(JS_GetRuntime(ctx), js_socket_class_id, &js_socket_class);\n 1764  \n 1765:     socket_ctor = JS_NewCFunction2(ctx, js_socket_constructor, \"Socket\", 1, JS_CFUNC_constructor, 0);\n 1766      socket_proto = JS_NewObject(ctx);\n 1767  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/property-enumeration.c:\n  158  \n  159  /*static void\n  160:  property_enumeration_pointer(Vector* vec, JSContext* ctx, struct Pointer* ptr)\n  161   { pointer_fromarray(ptr, ctx, property_enumeration_path(vec,ctx));\n  162   }*/\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-syscallerror.c:\n   92  \n   93  static JSValue\n   94: js_syscallerror_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n   95    SyscallError* err;\n   96    JSValue obj = JS_UNDEFINED, proto = JS_UNDEFINED, st = JS_UNDEFINED;\n   ..\n  407      JS_NewClassID(&js_syscallerror_class_id);\n  408      JS_NewClass(JS_GetRuntime(ctx), js_syscallerror_class_id, &js_syscallerror_class);\n  409:     syscallerror_ctor = JS_NewCFunction2(ctx, js_syscallerror_constructor, \"SyscallError\", 1, JS_CFUNC_constructor, 0);\n  410  \n  411      syscallerror_proto = JS_NewObjectProto(ctx, error);\n  ...\n  416      JS_SetClassProto(ctx, js_syscallerror_class_id, syscallerror_proto);\n  417  \n  418:     JS_SetConstructor(ctx, syscallerror_ctor, syscallerror_proto);\n  419  \n  420      //  js_set_inspect_method(ctx, syscallerror_proto, js_syscallerror_inspect);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-stringdecoder.h:\n    7  typedef enum string_encoding { UNKNOWN = 0, UTF8, UTF16 } StringEncoding;\n    8  \n    9: typedef struct string_decoder {\n   10    RingBuffer buffer;\n   11    StringEncoding encoding;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-repeater.c:\n   62  \n   63  static JSValue\n   64: js_repeater_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n   65    JSValue proto;\n   66    /* using new_target to get the prototype is necessary when the\n   ..\n  140    JS_SetClassProto(ctx, js_repeater_class_id, repeater_proto);\n  141  \n  142:   repeater_ctor = JS_NewCFunction2(ctx, js_repeater_constructor, \"Repeater\", 1, JS_CFUNC_constructor, 0);\n  143  \n  144:   JS_SetConstructor(ctx, repeater_ctor, repeater_proto);\n  145    JS_SetPropertyFunctionList(ctx, repeater_ctor, js_repeater_static_funcs, countof(js_repeater_static_funcs));\n  146  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-predicate.c:\n   89  \n   90  static JSValue\n   91: js_predicate_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n   92    Predicate* pr;\n   93    JSValue obj = JS_UNDEFINED, proto = JS_UNDEFINED;\n   ..\n  671      }\n  672      case PREDICATE_INSTANCEOF: {\n  673:       JS_DefinePropertyValueStr(ctx, obj, \"constructor\", JS_DupValue(ctx, pr->unary.predicate), JS_PROP_ENUMERABLE);\n  674        break;\n  675      }\n  ...\n  834    JS_SetClassProto(ctx, js_predicate_class_id, predicate_proto);\n  835  \n  836:   predicate_ctor = JS_NewCFunction2(ctx, js_predicate_constructor, \"Predicate\", 1, JS_CFUNC_constructor, 0);\n  837  \n  838:   JS_SetConstructor(ctx, predicate_ctor, predicate_proto);\n  839    JS_SetPropertyFunctionList(ctx, predicate_ctor, js_predicate_funcs, countof(js_predicate_funcs));\n  840    JS_SetPropertyFunctionList(ctx, predicate_ctor, js_predicate_ids, countof(js_predicate_ids));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-internal.h:\n  102  typedef enum OPCodeEnum OPCodeEnum;\n  103  \n  104: typedef struct JSString JSString;\n  105: typedef struct JSString JSAtomStruct;\n  106: typedef struct JSShape JSShape;\n  107  \n  108  typedef enum {\n  ...\n  115  /* function pointers are used for numeric operations so that it is\n  116     possible to remove some numeric types */\n  117: typedef struct {\n  118    JSValue (*to_string)(JSContext* ctx, JSValueConst val);\n  119    JSValue (*from_string)(JSContext* ctx, const char* buf, int radix, int flags, slimb_t* pexponent);\n  ...\n  127  #endif\n  128  \n  129: typedef struct JSRuntime {\n  130    JSMallocFunctions mf;\n  131    JSMallocState malloc_state;\n  ...\n  140    int class_count;\n  141    JSClass* class_array;\n  142:   struct list_head context_list;\n  143:   struct list_head gc_obj_list;\n  144:   struct list_head gc_zero_ref_count_list;\n  145:   struct list_head tmp_obj_list;\n  146    JSGCPhaseEnum gc_phase : 8;\n  147    size_t malloc_gc_threshold;\n  148  #ifdef DUMP_LEAKS\n  149:   struct list_head string_list;\n  150  #endif\n  151    uintptr_t stack_size;\n  ...\n  154    JSValue current_exception;\n  155    BOOL in_out_of_memory : 8;\n  156:   struct JSStackFrame* current_stack_frame;\n  157    JSInterruptHandler* interrupt_handler;\n  158    void* interrupt_opaque;\n  159    JSHostPromiseRejectionTracker* host_promise_rejection_tracker;\n  160    void* host_promise_rejection_tracker_opaque;\n  161:   struct list_head job_list;\n  162    JSModuleNormalizeFunc* module_normalize_func;\n  163    JSModuleLoaderFunc* module_loader_func;\n  ...\n  179  } JSRuntime;\n  180  \n  181: struct JSClass {\n  182    uint32_t class_id; /* 0 means free entry */\n  183    JSAtom class_name;\n  ...\n  193  #define JS_MODE_MATH (1 << 2)\n  194  \n  195: typedef struct JSStackFrame {\n  196:   struct JSStackFrame* prev_frame;\n  197    JSValue cur_func;\n  198    JSValue* arg_buf;              /* arguments */\n  199    JSValue* var_buf;              /* variables */\n  200:   struct list_head var_ref_list; /* list of JSVarRef.link */\n  201:   const uint8_t* cur_pc;         /* bytecode functions : PC of the instruction after the call */\n  202    int arg_count;\n  203    int js_mode; /* 0 or JS_MODE_MATH for C functions */\n  ...\n  216  } JSGCObjectTypeEnum;\n  217  \n  218: struct JSGCObjectHeader {\n  219    int ref_count;\n  220    JSGCObjectTypeEnum gc_obj_type : 4;\n  ...\n  222    uint8_t dummy1;\n  223    uint16_t dummy2;\n  224:   struct list_head link;\n  225  };\n  226  \n  227: typedef struct JSVarRef {\n  228    union {\n  229      JSGCObjectHeader header;\n  230:     struct {\n  231        int __gc_ref_count;\n  232        uint8_t __gc_mark;\n  ...\n  245  } JSVarRef;\n  246  \n  247: typedef struct JSFloatEnv {\n  248    uintptr_t prec;\n  249    uint32_t flags;\n  ...\n  252  \n  253  #ifdef CONFIG_BIGNUM\n  254: /* the same structure is used for big integers and big floats. Big\n  255     integers are never infinite or NaNs */\n  256: typedef struct JSBigFloat {\n  257    JSRefCountHeader header; /* must come first, 32-bit */\n  258    bf_t num;\n  259  } JSBigFloat;\n  260  \n  261: typedef struct JSBigDecimal {\n  262    JSRefCountHeader header; /* must come first, 32-bit */\n  263    bfdec_t num;\n  ...\n  275  #define JS_INTERRUPT_COUNTER_INIT 10000\n  276  \n  277: struct JSContext {\n  278    JSGCObjectHeader header; /* must come first */\n  279    JSRuntime* rt;\n  280:   struct list_head link;\n  281  \n  282    uint16_t binary_object_count;\n  ...\n  312    BOOL is_error_property_enabled;\n  313  \n  314:   struct list_head loaded_modules; /* list of JSModuleDef.link */\n  315  \n  316    /* if NULL, RegExp compilation is not supported */\n  ...\n  322  };\n  323  \n  324: struct JSString {\n  325    JSRefCountHeader header;\n  326    uint32_t len : 31;\n  ...\n  330    uint32_t hash_next;\n  331  #ifdef DUMP_LEAKS\n  332:   struct list_head link;\n  333  #endif\n  334    union {\n  ...\n  338  };\n  339  \n  340: typedef struct JSClosureVar {\n  341    uint8_t is_local : 1;\n  342    uint8_t is_arg : 1;\n  ...\n  351  } JSClosureVar;\n  352  \n  353: typedef struct JSVarScope {\n  354    int parent; /* index into fd->scopes of the enclosing scope */\n  355    int first;  /* index into fd->vars of the last variable in this scope */\n  ...\n  371  } JSVarKindEnum;\n  372  \n  373: /* XXX: could use a different structure in bytecode functions to save\n  374     memory */\n  375: typedef struct JSVarDef {\n  376    JSAtom var_name;\n  377    /* index into fd->scopes of this variable lexical scope */\n  ...\n  407  } JSFunctionKindEnum;\n  408  \n  409: typedef struct JSFunctionBytecode {\n  410    JSGCObjectHeader header; /* must come first */\n  411    uint8_t js_mode;\n  412    uint8_t has_prototype : 1; /* true if a prototype field is necessary */\n  413    uint8_t has_simple_parameter_list : 1;\n  414:   uint8_t is_derived_class_constructor : 1;\n  415    /* true if home_object needs to be initialized */\n  416    uint8_t need_home_object : 1;\n  ...\n  438    int cpool_count;\n  439    int closure_var_count;\n  440:   struct {\n  441:     /* debug info, move to separate structure to save memory? */\n  442      JSAtom filename;\n  443      int line_num;\n  ...\n  448    } debug;\n  449  #ifdef CONFIG_DEBUGGER\n  450:   struct JSDebuggerFunctionInfo debugger;\n  451  #endif\n  452  } JSFunctionBytecode;\n  453  \n  454: typedef struct JSProperty {\n  455    union {\n  456      JSValue value;      /* JS_PROP_NORMAL */\n  457:     struct {            /* JS_PROP_GETSET */\n  458        JSObject* getter; /* NULL if undefined */\n  459        JSObject* setter; /* NULL if undefined */\n  460      } getset;\n  461      JSVarRef* var_ref; /* JS_PROP_VARREF */\n  462:     struct {           /* JS_PROP_AUTOINIT */\n  463        /* in order to use only 2 pointers, we compress the realm\n  464           and the init function pointer */\n  ...\n  474  #define JS_ARRAY_INITIAL_SIZE 2\n  475  \n  476: typedef struct JSShapeProperty {\n  477    uint32_t hash_next : 26; /* 0 if last in list */\n  478    uint32_t flags : 6;      /* JS_PROP_XXX */\n  ...\n  480  } JSShapeProperty;\n  481  \n  482: struct JSShape {\n  483    /* hash table of size hash_mask + 1 before the start of the\n  484:      structure (see prop_hash_end()). */\n  485    JSGCObjectHeader header;\n  486    /* true if the shape is inserted in the shape hash table. If not,\n  ...\n  501  };\n  502  \n  503: typedef struct JSRegExp {\n  504    JSString* pattern;\n  505    JSString* bytecode; /* also contains the flags */\n  506  } JSRegExp;\n  507  \n  508: typedef struct JSProxyData {\n  509    JSValue target;\n  510    JSValue handler;\n  ...\n  513  } JSProxyData;\n  514  \n  515: typedef struct JSArrayBuffer {\n  516    int byte_length; /* 0 if detached */\n  517    uint8_t detached;\n  518    uint8_t shared; /* if shared, the array buffer cannot be detached */\n  519    uint8_t* data;  /* NULL if detached */\n  520:   struct list_head array_list;\n  521    void* opaque;\n  522    JSFreeArrayBufferDataFunc* free_func;\n  523  } JSArrayBuffer;\n  524  \n  525: typedef struct JSTypedArray {\n  526:   struct list_head link; /* link to arraybuffer */\n  527    JSObject* obj;         /* back pointer to the TypedArray/DataView object */\n  528    JSObject* buffer;      /* based array buffer */\n  ...\n  531  } JSTypedArray;\n  532  \n  533: typedef struct JSAsyncFunctionState {\n  534    JSValue this_val; /* 'this' generator argument */\n  535    int argc;         /* number of function arguments */\n  ...\n  540  /* XXX: could use an object instead to avoid the\n  541     JS_TAG_ASYNC_FUNCTION tag for the GC */\n  542: typedef struct JSAsyncFunctionData {\n  543    JSGCObjectHeader header; /* must come first */\n  544    JSValue resolving_funcs[2];\n  ...\n  547  } JSAsyncFunctionData;\n  548  \n  549: struct JSObject {\n  550    union {\n  551      JSGCObjectHeader header;\n  552:     struct {\n  553        int __gc_ref_count; /* corresponds to header.ref_count */\n  554        uint8_t __gc_mark;  /* corresponds to header.mark/gc_obj_type */\n  ...\n  560                                             JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS and typed\n  561                                             arrays) */\n  562:       uint8_t is_constructor : 1;       /* TRUE if object is a constructor function */\n  563        uint8_t is_uncatchable_error : 1; /* if TRUE, error is not catchable */\n  564        uint8_t tmp_mark : 1;             /* used in JS_WriteObjectRec() */\n  ...\n  571    JSProperty* prop; /* array of properties */\n  572    /* byte offsets: 24/40 */\n  573:   struct JSMapRecord* first_weak_ref; /* XXX: use a bit and an external hash table? */\n  574    /* byte offsets: 28/48 */\n  575    union {\n  576      void* opaque;\n  577:     struct JSBoundFunction* bound_function;               /* JS_CLASS_BOUND_FUNCTION */\n  578:     struct JSCFunctionDataRecord* c_function_data_record; /* JS_CLASS_C_FUNCTION_DATA */\n  579:     struct JSForInIterator* for_in_iterator;              /* JS_CLASS_FOR_IN_ITERATOR */\n  580:     struct JSArrayBuffer* array_buffer;                   /* JS_CLASS_ARRAY_BUFFER, JS_CLASS_SHARED_ARRAY_BUFFER */\n  581:     struct JSTypedArray* typed_array;                     /* JS_CLASS_UINT8C_ARRAY..JS_CLASS_DATAVIEW */\n  582  #ifdef CONFIG_BIGNUM\n  583:     struct JSFloatEnv* float_env;           /* JS_CLASS_FLOAT_ENV */\n  584:     struct JSOperatorSetData* operator_set; /* JS_CLASS_OPERATOR_SET */\n  585  #endif\n  586:     struct JSMapState* map_state;                                      /* JS_CLASS_MAP..JS_CLASS_WEAKSET */\n  587:     struct JSMapIteratorData* map_iterator_data;                       /* JS_CLASS_MAP_ITERATOR, JS_CLASS_SET_ITERATOR */\n  588:     struct JSArrayIteratorData* array_iterator_data;                   /* JS_CLASS_ARRAY_ITERATOR,\n  589                                                                            JS_CLASS_STRING_ITERATOR */\n  590:     struct JSRegExpStringIteratorData* regexp_string_iterator_data;    /* JS_CLASS_REGEXP_STRING_ITERATOR */\n  591:     struct JSGeneratorData* generator_data;                            /* JS_CLASS_GENERATOR */\n  592:     struct JSProxyData* proxy_data;                                    /* JS_CLASS_PROXY */\n  593:     struct JSPromiseData* promise_data;                                /* JS_CLASS_PROMISE */\n  594:     struct JSPromiseFunctionData* promise_function_data;               /* JS_CLASS_PROMISE_RESOLVE_FUNCTION,\n  595                                                                            JS_CLASS_PROMISE_REJECT_FUNCTION */\n  596:     struct JSAsyncFunctionData* async_function_data;                   /* JS_CLASS_ASYNC_FUNCTION_RESOLVE,\n  597                                                                            JS_CLASS_ASYNC_FUNCTION_REJECT */\n  598:     struct JSAsyncFromSyncIteratorData* async_from_sync_iterator_data; /* JS_CLASS_ASYNC_FROM_SYNC_ITERATOR */\n  599:     struct JSAsyncGeneratorData* async_generator_data;                 /* JS_CLASS_ASYNC_GENERATOR */\n  600:     struct {                                                           /* JS_CLASS_BYTECODE_FUNCTION: 12/24 bytes */\n  601        /* also used by JS_CLASS_GENERATOR_FUNCTION, JS_CLASS_ASYNC_FUNCTION and\n  602         * JS_CLASS_ASYNC_GENERATOR_FUNCTION */\n  603:       struct JSFunctionBytecode* function_bytecode;\n  604        JSVarRef** var_refs;\n  605        JSObject* home_object; /* for 'super' access */\n  606      } func;\n  607:     struct { /* JS_CLASS_C_FUNCTION: 12/20 bytes */\n  608        JSContext* realm;\n  609        JSCFunctionType c_function;\n  ...\n  613      } cfunc;\n  614      /* array part for fast arrays and typed arrays */\n  615:     struct { /* JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS,\n  616                  JS_CLASS_UINT8C_ARRAY..JS_CLASS_FLOAT64_ARRAY */\n  617        union {\n  618          uint32_t size;                    /* JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS */\n  619:         struct JSTypedArray* typed_array; /* JS_CLASS_UINT8C_ARRAY..JS_CLASS_FLOAT64_ARRAY */\n  620        } u1;\n  621        union {\n  ...\n  680  #define JS_ATOM_MAX ((1U << 30) - 1)\n  681  \n  682: typedef struct StringBuffer {\n  683    JSContext* ctx;\n  684    JSString* str;\n  ...\n  689  } StringBuffer;\n  690  \n  691: typedef struct JSCFunctionDataRecord {\n  692    JSCFunctionData* func;\n  693    uint8_t length;\n  ...\n  697  } JSCFunctionDataRecord;\n  698  \n  699: typedef struct JSCClosureRecord {\n  700    JSCClosure* func;\n  701    uint16_t length;\n  ...\n  705  } JSCClosureRecord;\n  706  \n  707: typedef struct JSMemoryUsage_helper {\n  708    double memory_used_count;\n  709    double str_count;\n  ...\n  724  } JSGeneratorStateEnum;\n  725  \n  726: typedef struct JSGeneratorData {\n  727    JSGeneratorStateEnum state;\n  728    JSAsyncFunctionState func_state;\n  ...\n  738  } JSAsyncGeneratorStateEnum;\n  739  \n  740: typedef struct JSAsyncGeneratorRequest {\n  741:   struct list_head link;\n  742    /* completion */\n  743    int completion_type; /* GEN_MAGIC_x */\n  ...\n  748  } JSAsyncGeneratorRequest;\n  749  \n  750: typedef struct JSAsyncGeneratorData {\n  751    JSObject* generator; /* back pointer to the object (const) */\n  752    JSAsyncGeneratorStateEnum state;\n  753    JSAsyncFunctionState func_state;\n  754:   struct list_head queue; /* list of JSAsyncGeneratorRequest.link */\n  755  } JSAsyncGeneratorData;\n  756  \n  ...\n  761  } JSPromiseStateEnum;\n  762  \n  763: typedef struct JSPromiseData {\n  764    JSPromiseStateEnum promise_state;\n  765    /* 0=fulfill, 1=reject, list of JSPromiseReactionData.link */\n  766:   struct list_head promise_reactions[2];\n  767    BOOL is_handled; /* Note: only useful to debug */\n  768    JSValue promise_result;\n  769  } JSPromiseData;\n  770  \n  771: typedef struct JSPromiseFunctionDataResolved {\n  772    int ref_count;\n  773    BOOL already_resolved;\n  774  } JSPromiseFunctionDataResolved;\n  775  \n  776: typedef struct JSPromiseFunctionData {\n  777    JSValue promise;\n  778    JSPromiseFunctionDataResolved* presolved;\n  779  } JSPromiseFunctionData;\n  780  \n  781: typedef struct JSPromiseReactionData {\n  782:   struct list_head link; /* not used in promise_reaction_job */\n  783    JSValue resolving_funcs[2];\n  784    JSValue handler;\n  785  } JSPromiseReactionData;\n  786  \n  787: typedef struct JSBoundFunction {\n  788    JSValue func_obj;\n  789    JSValue this_val;\n  ...\n  798  } JSIteratorKindEnum;\n  799  \n  800: typedef struct JSForInIterator {\n  801    JSValue obj;\n  802    BOOL is_array;\n  ...\n  833  } JSOverloadableOperatorEnum;\n  834  \n  835: typedef struct {\n  836    uint32_t operator_index;\n  837    JSObject* ops[JS_OVOP_BINARY_COUNT]; /* self operators */\n  838  } JSBinaryOperatorDefEntry;\n  839  \n  840: typedef struct {\n  841    int count;\n  842    JSBinaryOperatorDefEntry* tab;\n  843  } JSBinaryOperatorDef;\n  844  \n  845: typedef struct {\n  846    uint32_t operator_counter;\n  847    BOOL is_primitive; /* OperatorSet for a primitive type */\n  ...\n  852  } JSOperatorSetData;\n  853  \n  854: typedef struct JSReqModuleEntry {\n  855    JSAtom module_name;\n  856    JSModuleDef* module; /* used using resolution */\n  ...\n  862  } JSExportTypeEnum;\n  863  \n  864: typedef struct JSExportEntry {\n  865    union {\n  866:     struct {\n  867        int var_idx;       /* closure variable index */\n  868        JSVarRef* var_ref; /* if != NULL, reference to the variable */\n  ...\n  876  } JSExportEntry;\n  877  \n  878: typedef struct JSStarExportEntry {\n  879    int req_module_idx; /* in req_module_entries */\n  880  } JSStarExportEntry;\n  881  \n  882: typedef struct JSImportEntry {\n  883    int var_idx; /* closure variable index */\n  884    JSAtom import_name;\n  ...\n  886  } JSImportEntry;\n  887  \n  888: struct JSModuleDef {\n  889    JSRefCountHeader header; /* must come first, 32-bit */\n  890    JSAtom module_name;\n  891:   struct list_head link;\n  892  \n  893    JSReqModuleEntry* req_module_entries;\n  ...\n  922  };\n  923  \n  924: typedef struct JSJobEntry {\n  925:   struct list_head link;\n  926    JSContext* ctx;\n  927    JSJobFunc* job_func;\n  ...\n  932  /* Set/Map/WeakSet/WeakMap */\n  933  \n  934: typedef struct JSMapRecord {\n  935    int ref_count; /* used during enumeration to avoid freeing the record */\n  936    BOOL empty;    /* TRUE if the record is deleted */\n  937:   struct JSMapState* map;\n  938:   struct JSMapRecord* next_weak_ref;\n  939:   struct list_head link;\n  940:   struct list_head hash_link;\n  941    JSValue key;\n  942    JSValue value;\n  943  } JSMapRecord;\n  944  \n  945: typedef struct JSMapState {\n  946    BOOL is_weak;             /* TRUE if WeakSet/WeakMap */\n  947:   struct list_head records; /* list of JSMapRecord.link */\n  948    uint32_t record_count;\n  949:   struct list_head* hash_table;\n  950    uint32_t hash_size;              /* must be a power of two */\n  951    uint32_t record_count_threshold; /* count at which a hash table resize is needed */\n  ...\n  955  #define MAGIC_WEAK (1 << 1)\n  956  \n  957: typedef struct JSMapIteratorData {\n  958    JSValue obj;\n  959    JSIteratorKindEnum kind;\n  ...\n  961  } JSMapIteratorData;\n  962  \n  963: typedef struct JSOpCode {\n  964    uint8_t size; /* in bytes */\n  965    /* the opcodes remove n_pop items from the top of the stack, then\n  ...\n  983  extern const JSOpCode js_opcodes[OP_COUNT + (OP_TEMP_END - OP_TEMP_START)];\n  984  \n  985: typedef struct JSParsePos {\n  986    int last_line_num;\n  987    int line_num;\n  ...\n  990  } JSParsePos;\n  991  \n  992: typedef struct JSResolveEntry {\n  993    JSModuleDef* module;\n  994    JSAtom name;\n  995  } JSResolveEntry;\n  996  \n  997: typedef struct JSResolveState {\n  998    JSResolveEntry* array;\n  999    int size;\n ....\n 1007  } ExportedNameEntryEnum;\n 1008  \n 1009: typedef struct ExportedNameEntry {\n 1010    JSAtom export_name;\n 1011    ExportedNameEntryEnum export_type;\n ....\n 1017  } ExportedNameEntry;\n 1018  \n 1019: typedef struct GetExportNamesState {\n 1020    JSModuleDef** modules;\n 1021    int modules_size;\n ....\n 1027  } GetExportNamesState;\n 1028  \n 1029: typedef struct CodeContext {\n 1030    const uint8_t* bc_buf; /* code buffer */\n 1031    int bc_len;            /* length of the code buffer */\n ....\n 1039  } CodeContext;\n 1040  \n 1041: typedef struct StackSizeState {\n 1042    int bc_len;\n 1043    int stack_len_max;\n ....\n 1048  } StackSizeState;\n 1049  \n 1050: typedef struct {\n 1051    JSObject* obj;\n 1052    uint32_t hash_next; /* -1 if no next entry */\n ....\n 1054  \n 1055  /* XXX: reuse it to optimize weak references */\n 1056: typedef struct {\n 1057    JSObjectListEntry* object_tab;\n 1058    int object_count;\n ....\n 1098  #endif\n 1099  \n 1100: typedef struct BCWriterState {\n 1101    JSContext* ctx;\n 1102    DynBuf dbuf;\n ....\n 1118  } BCWriterState;\n 1119  \n 1120: typedef struct BCReaderState {\n 1121    JSContext* ctx;\n 1122    const uint8_t *buf_start, *ptr, *buf_end;\n ....\n 1140  } BCReaderState;\n 1141  \n 1142: typedef struct {\n 1143:   struct list_head link;\n 1144    int fd;\n 1145    JSValue rw_func[2];\n ....\n 1147  } JSOSRWHandler;\n 1148  \n 1149: typedef struct {\n 1150:   struct list_head link;\n 1151    int sig_num;\n 1152    JSValue func;\n 1153  } JSOSSignalHandler;\n 1154  \n 1155: typedef struct {\n 1156:   struct list_head link;\n 1157    BOOL has_object;\n 1158    int64_t timeout;\n ....\n 1160  } JSOSTimer;\n 1161  \n 1162: typedef struct {\n 1163:   struct list_head link;\n 1164    uint8_t* data;\n 1165    size_t data_len;\n ....\n 1169  } JSWorkerMessage;\n 1170  \n 1171: typedef struct {\n 1172    int ref_count;\n 1173  #ifdef USE_WORKER\n 1174    pthread_mutex_t mutex;\n 1175  #endif\n 1176:   struct list_head msg_queue; /* list of JSWorkerMessage.link */\n 1177    int read_fd;\n 1178    int write_fd;\n ....\n 1180  } JSWorkerMessagePipe;\n 1181  \n 1182: typedef struct {\n 1183:   struct list_head link;\n 1184    JSWorkerMessagePipe* recv_pipe;\n 1185    JSValue on_message_func;\n 1186  } JSWorkerMessageHandler;\n 1187  \n 1188: typedef struct JSThreadState {\n 1189:   struct list_head os_rw_handlers;     /* list of JSOSRWHandler.link */\n 1190:   struct list_head os_signal_handlers; /* list JSOSSignalHandler.link */\n 1191:   struct list_head os_timers;          /* list of JSOSTimer.link */\n 1192:   struct list_head port_list;          /* list of JSWorkerMessageHandler.link */\n 1193    int eval_script_recurse;             /* only used in the main thread */\n 1194    /* not used in the main thread */\n ....\n 1196  } JSThreadState;\n 1197  \n 1198: typedef struct {\n 1199    int ref_count;\n 1200    uint64_t buf[0];\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-tree-walker.c:\n   39  };\n   40  \n   41: typedef struct {\n   42    Vector frames;\n   43    uint32_t tag_mask;\n   ..\n   72  \n   73  static JSValue\n   74: js_tree_walker_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n   75    TreeWalker* w;\n   76    PropertyEnumeration* it = 0;\n   ..\n  321  \n  322  static JSValue\n  323: js_tree_iterator_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n  324    TreeWalker* w;\n  325    PropertyEnumeration* it = 0;\n  ...\n  483    JS_SetClassProto(ctx, js_tree_walker_class_id, tree_walker_proto);\n  484  \n  485:   tree_walker_ctor = JS_NewCFunction2(ctx, js_tree_walker_constructor, \"TreeWalker\", 1, JS_CFUNC_constructor, 0);\n  486  \n  487:   JS_SetConstructor(ctx, tree_walker_ctor, tree_walker_proto);\n  488    JS_SetPropertyFunctionList(ctx, tree_walker_ctor, js_tree_walker_static_funcs, countof(js_tree_walker_static_funcs));\n  489  \n  ...\n  495    JS_SetClassProto(ctx, js_tree_iterator_class_id, tree_iterator_proto);\n  496  \n  497:   tree_iterator_ctor = JS_NewCFunction2(ctx, js_tree_iterator_constructor, \"TreeIterator\", 1, JS_CFUNC_constructor, 0);\n  498  \n  499:   JS_SetConstructor(ctx, tree_iterator_ctor, tree_iterator_proto);\n  500    JS_SetPropertyFunctionList(ctx, tree_iterator_ctor, js_tree_walker_static_funcs, countof(js_tree_walker_static_funcs));\n  501  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-child-process.c:\n   44  \n   45  static JSValue\n   46: js_child_process_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n   47    ChildProcess* cp;\n   48    JSValue obj = JS_UNDEFINED, proto = JS_UNDEFINED;\n   ..\n  365    JS_SetClassProto(ctx, js_child_process_class_id, child_process_proto);\n  366  \n  367:   child_process_ctor = JS_NewCFunction2(ctx, js_child_process_constructor, \"ChildProcess\", 1, JS_CFUNC_constructor, 0);\n  368  \n  369:   JS_SetConstructor(ctx, child_process_ctor, child_process_proto);\n  370    JS_SetPropertyFunctionList(ctx, child_process_ctor, js_child_process_funcs, countof(js_child_process_funcs));\n  371    js_set_inspect_method(ctx, child_process_proto, js_child_process_inspect);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/path.h:\n   40  #define path_isname(p) ((p)[str_chr((p), '/')] != '\\0')\n   41  \n   42: typedef struct {\n   43    size_t sz1, sz2;\n   44  } SizePair;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/location.h:\n    4  #include \"utils.h\"\n    5  \n    6: typedef struct Location {\n    7    char* file;\n    8    uint32_t line;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-lexer.c:\n   45  };\n   46  \n   47: typedef struct {\n   48    JSValue action;\n   49    BOOL skip;\n   ..\n  117  \n  118  static JSValue\n  119: js_syntaxerror_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n  120    SyntaxError* err;\n  121    JSValue obj = JS_UNDEFINED;\n  ...\n  314  \n  315  JSValue\n  316: js_token_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n  317    Token* tok;\n  318    JSValue obj = JS_UNDEFINED;\n  ...\n  774  \n  775  JSValue\n  776: js_lexer_constructor(JSContext* ctx, JSValueConst new_target, int argc, JSValueConst argv[]) {\n  777    JSValue proto, ret;\n  778    Lexer* lex;\n  ...\n 1248    ctor = js_global_get(ctx, \"Int32Array\");\n 1249  \n 1250:   ret = JS_CallConstructor(ctx, ctor, 1, &buf);\n 1251  \n 1252    JS_FreeValue(ctx, ctor);\n ....\n 1486    JS_SetClassProto(ctx, js_syntaxerror_class_id, syntaxerror_proto);\n 1487  \n 1488:   syntaxerror_ctor = JS_NewCFunction2(ctx, js_syntaxerror_constructor, \"SyntaxError\", 1, JS_CFUNC_constructor, 0);\n 1489  \n 1490:   JS_SetConstructor(ctx, syntaxerror_ctor, syntaxerror_proto);\n 1491  \n 1492    JS_NewClassID(&js_token_class_id);\n ....\n 1497    JS_SetClassProto(ctx, js_token_class_id, token_proto);\n 1498  \n 1499:   token_ctor = JS_NewCFunction2(ctx, js_token_constructor, \"Token\", 1, JS_CFUNC_constructor, 0);\n 1500  \n 1501:   JS_SetConstructor(ctx, token_ctor, token_proto);\n 1502    JS_SetPropertyFunctionList(ctx, token_ctor, js_token_static_funcs, countof(js_token_static_funcs));\n 1503  \n ....\n 1513    js_set_inspect_method(ctx, lexer_proto, js_lexer_inspect);\n 1514  \n 1515:   lexer_ctor = JS_NewCFunction2(ctx, js_lexer_constructor, \"Lexer\", 1, JS_CFUNC_constructor, 0);\n 1516  \n 1517:   JS_SetConstructor(ctx, lexer_ctor, lexer_proto);\n 1518    JS_SetPropertyFunctionList(ctx, lexer_ctor, js_lexer_static_funcs, countof(js_lexer_static_funcs));\n 1519  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-sockets.h:\n   10  typedef union {\n   11    uint16_t family;\n   12:   struct sockaddr s;\n   13:   struct sockaddr_in sai;\n   14:   struct sockaddr_in6 sai6;\n   15  } SockAddr;\n   16  \n   17  union __attribute__((packed)) socket_state {\n   18:   struct {\n   19      uint16_t fd;\n   20      unsigned error : 12;\n   ..\n   88  sockaddr_size(const SockAddr* sa) {\n   89    switch(sa->family) {\n   90:     case AF_INET: return sizeof(struct sockaddr_in);\n   91:     case AF_INET6: return sizeof(struct sockaddr_in6);\n   92    }\n   93    return 0;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/qjsm.c:\n   42  #include \"buffer-utils.h\"\n   43  \n   44: typedef struct pollhandler {\n   45:   struct pollfd pf;\n   46:   void (*handler)(void* opaque, struct pollfd*);\n   47    void* opaque;\n   48:   struct list_head link;\n   49  } pollhandler_t;\n   50  \n   51  thread_local uint64_t jsm_pending_signals = 0;\n   52: struct list_head pollhandlers;\n   53  \n   54  void js_std_set_module_loader_func(JSModuleLoaderFunc* func);\n   ..\n   89    JSValue error = rt->current_exception;*/\n   90    /*printf(\"qjsm: current_exception 0x%08x\\n\", offsetof(JSRuntime, current_exception));\n   91:   printf(\"qjsm: sizeof(struct list_head) 0x%08x\\n\", sizeof(struct list_head));*/\n   92  \n   93    js_error_print(ctx, JS_GetException(ctx));\n   ..\n  295  #endif\n  296  \n  297: struct trace_malloc_data {\n  298    uint8_t* base;\n  299  };\n  ...\n  312  \n  313  static inline unsigned long long\n  314: jsm_trace_malloc_ptr_offset(uint8_t* ptr, struct trace_malloc_data* dp) {\n  315    return ptr - dp->base;\n  316  }\n  ...\n  371  \n  372  static void\n  373: jsm_trace_malloc_init(struct trace_malloc_data* s) {\n  374    free(s->base = malloc(8));\n  375  }\n  ...\n  646    JSRuntime* rt;\n  647    JSContext* ctx;\n  648:   struct trace_malloc_data trace_data = {0};\n  649    int optind;\n  650    char* expr = 0;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-location.h:\n   15  Location js_location_from(JSContext*, JSValue this_val);\n   16  JSValue js_location_toprimitive(JSContext*, JSValue this_val, int argc, JSValue* argv);\n   17: JSValue js_location_constructor(JSContext*, JSValue new_target, int argc, JSValue* argv);\n   18  void js_location_finalizer(JSRuntime*, JSValue val);\n   19  int js_location_init(JSContext*, JSModuleDef* m);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-syscallerror.h:\n    7  extern /*thread_local*/ JSValue syscallerror_proto, syscallerror_ctor;\n    8  \n    9: typedef struct {\n   10    char* syscall;\n   11    int number;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/iteration.h:\n    7  #include <assert.h>\n    8  \n    9: typedef struct Iteration {\n   10    JSValue iter, next, data;\n   11    BOOL done;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/CMakeLists.txt:\n 1416  \n 1417  CHECK_C_SOURCE_COMPILES(\n 1418:   \"#include <sys/types.h>\\n#include <sys/mount.h>\\nint main(void) { struct vfsconf v; return sizeof(v);}\"\n 1419    HAVE_STRUCT_VFSCONF)\n 1420  \n 1421  CHECK_C_SOURCE_COMPILES(\n 1422:   \"#include <sys/types.h>\\n#include <sys/mount.h>\\nint main(void) { struct xvfsconf v; return sizeof(v);}\"\n 1423    HAVE_STRUCT_XVFSCONF)\n 1424  \n 1425  CHECK_C_SOURCE_COMPILES(\n 1426:   \"#include <sys/types.h>\\n#include <sys/mount.h>\\nint main(void) { struct statfs s; return sizeof(s);}\"\n 1427    HAVE_STRUCT_STATFS)\n 1428  \n ....\n 1430  # older 2-argument version.\n 1431  CHECK_C_SOURCE_COMPILES(\n 1432:   \"#include <dirent.h>\\nint main() {DIR *d = opendir(\\\".\\\"); struct dirent e,*r; return readdir_r(d,&e,&r);}\"\n 1433    HAVE_READDIR_R)\n 1434  \n ....\n 1494  \n 1495  #\n 1496: # Check struct members\n 1497  #\n 1498: # Check for tm_gmtoff in struct tm\n 1499: CHECK_STRUCT_HAS_MEMBER(\"struct tm\" tm_gmtoff\n 1500      \"time.h\" HAVE_STRUCT_TM_TM_GMTOFF)\n 1501: CHECK_STRUCT_HAS_MEMBER(\"struct tm\" __tm_gmtoff\n 1502      \"time.h\" HAVE_STRUCT_TM___TM_GMTOFF)\n 1503  \n 1504  IF(HAVE_STRUCT_STATFS)\n 1505: # Check for f_namemax in struct statfs\n 1506: CHECK_STRUCT_HAS_MEMBER(\"struct statfs\" f_namemax\n 1507      \"sys/param.h;sys/mount.h\" HAVE_STRUCT_STATFS_F_NAMEMAX)\n 1508: # Check for f_iosize in struct statfs\n 1509: CHECK_STRUCT_HAS_MEMBER(\"struct statfs\" f_iosize\n 1510      \"sys/param.h;sys/mount.h\" HAVE_STRUCT_STATFS_F_IOSIZE)\n 1511  ENDIF(HAVE_STRUCT_STATFS)\n 1512  \n 1513: # Check for birthtime in struct stat\n 1514: CHECK_STRUCT_HAS_MEMBER(\"struct stat\" st_birthtime\n 1515      \"sys/types.h;sys/stat.h\" HAVE_STRUCT_STAT_ST_BIRTHTIME)\n 1516  \n 1517: # Check for high-resolution timestamps in struct stat\n 1518: CHECK_STRUCT_HAS_MEMBER(\"struct stat\" st_birthtimespec.tv_nsec\n 1519      \"sys/types.h;sys/stat.h\" HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC)\n 1520: CHECK_STRUCT_HAS_MEMBER(\"struct stat\" st_mtimespec.tv_nsec\n 1521      \"sys/types.h;sys/stat.h\" HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC)\n 1522: CHECK_STRUCT_HAS_MEMBER(\"struct stat\" st_mtim.tv_nsec\n 1523      \"sys/types.h;sys/stat.h\" HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC)\n 1524: CHECK_STRUCT_HAS_MEMBER(\"struct stat\" st_mtime_n\n 1525      \"sys/types.h;sys/stat.h\" HAVE_STRUCT_STAT_ST_MTIME_N)\n 1526: CHECK_STRUCT_HAS_MEMBER(\"struct stat\" st_umtime\n 1527      \"sys/types.h;sys/stat.h\" HAVE_STRUCT_STAT_ST_UMTIME)\n 1528: CHECK_STRUCT_HAS_MEMBER(\"struct stat\" st_mtime_usec\n 1529      \"sys/types.h;sys/stat.h\" HAVE_STRUCT_STAT_ST_MTIME_USEC)\n 1530: # Check for block size support in struct stat\n 1531: CHECK_STRUCT_HAS_MEMBER(\"struct stat\" st_blksize\n 1532      \"sys/types.h;sys/stat.h\" HAVE_STRUCT_STAT_ST_BLKSIZE)\n 1533: # Check for st_flags in struct stat (BSD fflags)\n 1534: CHECK_STRUCT_HAS_MEMBER(\"struct stat\" st_flags\n 1535      \"sys/types.h;sys/stat.h\" HAVE_STRUCT_STAT_ST_FLAGS)\n 1536  \n 1537  IF(HAVE_SYS_STATVFS_H)\n 1538:   CHECK_STRUCT_HAS_MEMBER(\"struct statvfs\" f_iosize\n 1539      \"sys/types.h;sys/statvfs.h\" HAVE_STRUCT_STATVFS_F_IOSIZE)\n 1540  ENDIF()\n ....\n 1542  #\n 1543  #\n 1544: CHECK_STRUCT_HAS_MEMBER(\"struct tm\" tm_sec\n 1545      \"sys/types.h;sys/time.h;time.h\" TIME_WITH_SYS_TIME)\n 1546  \n ....\n 1944    ENDIF(HAVE_LIBRICHACL)\n 1945  \n 1946:   CHECK_STRUCT_HAS_MEMBER(\"struct richace\" e_type \"sys/richacl.h\"\n 1947      HAVE_STRUCT_RICHACE)\n 1948:   CHECK_STRUCT_HAS_MEMBER(\"struct richacl\" a_flags \"sys/richacl.h\"\n 1949      HAVE_STRUCT_RICHACL)\n 1950  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/contrib/archivetest.c:\n  105  int main(int argc, char *argv[])\n  106  {\n  107: \tstruct archive *a;\n  108: \tstruct archive_entry *entry;\n  109  \tchar *filename;\n  110  \tconst char *p;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/contrib/android/config/windows_host.h:\n  709  #define HAVE_STRRCHR 1\n  710  \n  711: /* Define to 1 if `f_namemax' is a member of `struct statfs'. */\n  712  /* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */\n  713  \n  714: /* Define to 1 if `f_iosize' is a member of `struct statvfs'. */\n  715  /* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */\n  716  \n  717: /* Define to 1 if `st_birthtime' is a member of `struct stat'. */\n  718  /* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */\n  719  \n  720: /* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */\n  721  /* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */\n  722  \n  723: /* Define to 1 if `st_blksize' is a member of `struct stat'. */\n  724  /* #undef HAVE_STRUCT_STAT_ST_BLKSIZE */\n  725  \n  726: /* Define to 1 if `st_flags' is a member of `struct stat'. */\n  727  /* #undef HAVE_STRUCT_STAT_ST_FLAGS */\n  728  \n  729: /* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */\n  730  /* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */\n  731  \n  732: /* Define to 1 if `st_mtime_n' is a member of `struct stat'. */\n  733  /* #undef HAVE_STRUCT_STAT_ST_MTIME_N */\n  734  \n  735: /* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */\n  736  /* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */\n  737  \n  738: /* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */\n  739  /* #undef HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC */\n  740  \n  741: /* Define to 1 if `st_umtime' is a member of `struct stat'. */\n  742  /* #undef HAVE_STRUCT_STAT_ST_UMTIME */\n  743  \n  744: /* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */\n  745  /* #undef HAVE_STRUCT_TM_TM_GMTOFF */\n  746  \n  747: /* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */\n  748  /* #undef HAVE_STRUCT_TM___TM_GMTOFF */\n  749  \n  ...\n 1000  /* #undef const */\n 1001  \n 1002: /* Define to match typeof st_gid field of struct stat if <sys/types.h> doesn't\n 1003     define. */\n 1004  #define gid_t short\n ....\n 1032  /* #undef size_t */\n 1033  \n 1034: /* Define to match typeof st_uid field of struct stat if <sys/types.h> doesn't\n 1035     define. */\n 1036  #define uid_t short\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/contrib/shar/shar.c:\n   61  \n   62  /*\n   63:  * Initialize archive structure and create a shar archive.\n   64   */\n   65: static struct archive *\n   66  shar_create(void)\n   67  {\n   68: \tstruct archive *a;\n   69  \n   70  \tif ((a = archive_write_new()) == NULL)\n   ..\n   90   */\n   91  static int\n   92: shar_write_entry_data(struct archive *a, const int fd)\n   93  {\n   94  \tssize_t bytes_read, bytes_written;\n   ..\n  116   */\n  117  static int\n  118: shar_write_entry(struct archive *a, const char *pathname, const char *accpath,\n  119:     const struct stat *st)\n  120  {\n  121: \tstruct archive_entry *entry;\n  122  \tint fd = -1;\n  123  \tint ret = ARCHIVE_OK;\n  ...\n  175   */\n  176  static int\n  177: shar_write_path(struct archive *a, const char *pathname)\n  178  {\n  179: \tstruct stat st;\n  180  \n  181  \tassert(a != NULL);\n  ...\n  195   */\n  196  static int\n  197: shar_write_tree(struct archive *a, const char *pathname)\n  198  {\n  199: \tstruct tree *t;\n  200: \tconst struct stat *lst, *st;\n  201  \tint error = 0;\n  202  \tint tree_ret;\n  ...\n  251  shar_write(char **fn, size_t nfn)\n  252  {\n  253: \tstruct archive *a;\n  254  \tsize_t i;\n  255  \tint error = 0;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/contrib/shar/tree.c:\n   76   */\n   77  \n   78: struct tree_entry {\n   79: \tstruct tree_entry *next;\n   80: \tstruct tree_entry *parent;\n   81  \tchar *name;\n   82  \tsize_t dirname_length;\n   ..\n   96   * Local data for this package.\n   97   */\n   98: struct tree {\n   99: \tstruct tree_entry\t*stack;\n  100: \tstruct tree_entry\t*current;\n  101  \tDIR\t*d;\n  102  \tint\t initialDirFd;\n  ...\n  115  \tint\t maxOpenCount;\n  116  \n  117: \tstruct stat\tlst;\n  118: \tstruct stat\tst;\n  119  };\n  120  \n  ...\n  135  #include <stdio.h>\n  136  void\n  137: tree_dump(struct tree *t, FILE *out)\n  138  {\n  139: \tstruct tree_entry *te;\n  140  \n  141  \tfprintf(out, \"\\tdepth: %d\\n\", t->depth);\n  ...\n  156   */\n  157  static void\n  158: tree_push(struct tree *t, const char *path)\n  159  {\n  160: \tstruct tree_entry *te;\n  161  \n  162  \tte = malloc(sizeof(*te));\n  ...\n  174   */\n  175  static void\n  176: tree_append(struct tree *t, const char *name, size_t name_length)\n  177  {\n  178  \tchar *p;\n  ...\n  206   * Open a directory tree for traversal.\n  207   */\n  208: struct tree *\n  209  tree_open(const char *path)\n  210  {\n  211: \tstruct tree *t;\n  212  \n  213  \tt = malloc(sizeof(*t));\n  ...\n  229   */\n  230  static void\n  231: tree_ascend(struct tree *t)\n  232  {\n  233: \tstruct tree_entry *te;\n  234  \n  235  \tte = t->stack;\n  ...\n  248   */\n  249  static void\n  250: tree_pop(struct tree *t)\n  251  {\n  252: \tstruct tree_entry *te;\n  253  \n  254  \tt->buff[t->dirname_length] = '\\0';\n  ...\n  270   */\n  271  int\n  272: tree_next(struct tree *t)\n  273  {\n  274: \tstruct dirent *de = NULL;\n  275  \n  276  \t/* Handle the startup case by returning the initial entry. */\n  ...\n  355   */\n  356  int\n  357: tree_errno(struct tree *t)\n  358  {\n  359  \treturn (t->tree_errno);\n  ...\n  365   */\n  366  void\n  367: tree_descend(struct tree *t)\n  368  {\n  369  \tif (t->visit_type != TREE_REGULAR)\n  ...\n  382   * Get the stat() data for the entry just returned from tree_next().\n  383   */\n  384: const struct stat *\n  385: tree_current_stat(struct tree *t)\n  386  {\n  387  \tif (!(t->flags & hasStat)) {\n  ...\n  396   * Get the lstat() data for the entry just returned from tree_next().\n  397   */\n  398: const struct stat *\n  399: tree_current_lstat(struct tree *t)\n  400  {\n  401  \tif (!(t->flags & hasLstat)) {\n  ...\n  411   */\n  412  int\n  413: tree_current_is_dir(struct tree *t)\n  414  {\n  415: \tconst struct stat *st;\n  416  \n  417  \t/*\n  ...\n  447   */\n  448  int\n  449: tree_current_is_physical_dir(struct tree *t)\n  450  {\n  451: \tconst struct stat *st;\n  452  \n  453  \t/*\n  ...\n  478   */\n  479  int\n  480: tree_current_is_physical_link(struct tree *t)\n  481  {\n  482: \tconst struct stat *st = tree_current_lstat(t);\n  483  \tif (st == NULL)\n  484  \t\treturn 0;\n  ...\n  490   */\n  491  const char *\n  492: tree_current_access_path(struct tree *t)\n  493  {\n  494  \treturn (t->basename);\n  ...\n  499   */\n  500  const char *\n  501: tree_current_path(struct tree *t)\n  502  {\n  503  \treturn (t->buff);\n  ...\n  508   */\n  509  size_t\n  510: tree_current_pathlen(struct tree *t)\n  511  {\n  512  \treturn (t->path_length);\n  ...\n  517   */\n  518  int\n  519: tree_current_depth(struct tree *t)\n  520  {\n  521  \treturn (t->depth);\n  ...\n  526   */\n  527  void\n  528: tree_close(struct tree *t)\n  529  {\n  530  \t/* Release anything remaining in the stack. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/contrib/shar/tree.h:\n   47  #include <stdio.h>\n   48  \n   49: struct tree;\n   50  \n   51  /* Initiate/terminate a tree traversal. */\n   52: struct tree *tree_open(const char * /* pathname */);\n   53: void tree_close(struct tree *);\n   54  \n   55  /*\n   ..\n   69  #define\tTREE_POSTASCENT\t3\n   70  #define\tTREE_ERROR_DIR\t-1\n   71: int tree_next(struct tree *);\n   72  \n   73: int tree_errno(struct tree *);\n   74  \n   75  /*\n   ..\n   80   * traversal.\n   81   */\n   82: void tree_descend(struct tree *);\n   83  \n   84  /*\n   ..\n   86   */\n   87  \n   88: int tree_current_depth(struct tree *);\n   89  /*\n   90   * The current full pathname, length of the full pathname,\n   ..\n   93   * almost never the same as the full current path.\n   94   */\n   95: const char *tree_current_path(struct tree *);\n   96: size_t tree_current_pathlen(struct tree *);\n   97: const char *tree_current_access_path(struct tree *);\n   98  /*\n   99   * Request the lstat() or stat() data for the current path.  Since the\n  ...\n  102   * than make a redundant stat() or lstat() call of your own.\n  103   */\n  104: const struct stat *tree_current_stat(struct tree *);\n  105: const struct stat *tree_current_lstat(struct tree *);\n  106  /* The following tests may use mechanisms much faster than stat()/lstat(). */\n  107  /* \"is_physical_dir\" is equivalent to S_ISDIR(tree_current_lstat()->st_mode) */\n  108: int tree_current_is_physical_dir(struct tree *);\n  109  /* \"is_physical_link\" is equivalent to S_ISLNK(tree_current_lstat()->st_mode) */\n  110: int tree_current_is_physical_link(struct tree *);\n  111  /* \"is_dir\" is equivalent to S_ISDIR(tree_current_stat()->st_mode) */\n  112: int tree_current_is_dir(struct tree *);\n  113  \n  114  /* For testing/debugging: Dump the internal status to the given filehandle. */\n  115: void tree_dump(struct tree *, FILE *);\n  116  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/contrib/shar/tree_config.h:\n   63  #else\n   64  /* Just leaving this macro replacement empty leads to a dangling semicolon. */\n   65: #define\t__FBSDID(a)     struct _undefined_hack\n   66  #endif\n   67  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_mtree.c:\n   83  #define\tMAX_LINE_LEN\t\t(1024 * 1024)\n   84  \n   85: struct mtree_option {\n   86: \tstruct mtree_option *next;\n   87  \tchar *value;\n   88  };\n   89  \n   90: struct mtree_entry {\n   91: \tstruct archive_rb_node rbnode;\n   92: \tstruct mtree_entry *next_dup;\n   93: \tstruct mtree_entry *next;\n   94: \tstruct mtree_option *options;\n   95  \tchar *name;\n   96  \tchar full;\n   ..\n   98  };\n   99  \n  100: struct mtree {\n  101: \tstruct archive_string\t line;\n  102  \tsize_t\t\t\t buffsize;\n  103  \tchar\t\t\t*buff;\n  ...\n  106  \tint\t\t\t archive_format;\n  107  \tconst char\t\t*archive_format_name;\n  108: \tstruct mtree_entry\t*entries;\n  109: \tstruct mtree_entry\t*this_entry;\n  110: \tstruct archive_rb_tree\t entry_rbtree;\n  111: \tstruct archive_string\t current_dir;\n  112: \tstruct archive_string\t contents_name;\n  113  \n  114: \tstruct archive_entry_linkresolver *resolver;\n  115: \tstruct archive_rb_tree rbtree;\n  116  \n  117  \tint64_t\t\t\t cur_size;\n  ...\n  120  \n  121  static int\tbid_keycmp(const char *, const char *, ssize_t);\n  122: static int\tcleanup(struct archive_read *);\n  123: static int\tdetect_form(struct archive_read *, int *);\n  124: static int\tmtree_bid(struct archive_read *, int);\n  125: static int\tparse_file(struct archive_read *, struct archive_entry *,\n  126: \t\t    struct mtree *, struct mtree_entry *, int *);\n  127: static void\tparse_escapes(char *, struct mtree_entry *);\n  128: static int\tparse_line(struct archive_read *, struct archive_entry *,\n  129: \t\t    struct mtree *, struct mtree_entry *, int *);\n  130: static int\tparse_keyword(struct archive_read *, struct mtree *,\n  131: \t\t    struct archive_entry *, struct mtree_option *, int *);\n  132: static int\tread_data(struct archive_read *a,\n  133  \t\t    const void **buff, size_t *size, int64_t *offset);\n  134: static ssize_t\treadline(struct archive_read *, struct mtree *, char **, ssize_t);\n  135: static int\tskip(struct archive_read *a);\n  136: static int\tread_header(struct archive_read *,\n  137: \t\t    struct archive_entry *);\n  138  static int64_t\tmtree_atol(char **, int base);\n  139  #ifndef HAVE_STRNLEN\n  ...\n  210  \n  211  static int\n  212: archive_read_format_mtree_options(struct archive_read *a,\n  213      const char *key, const char *val)\n  214  {\n  215: \tstruct mtree *mtree;\n  216  \n  217: \tmtree = (struct mtree *)(a->format->data);\n  218  \tif (strcmp(key, \"checkfs\")  == 0) {\n  219  \t\t/* Allows to read information missing from the mtree from the file system */\n  ...\n  233  \n  234  static void\n  235: free_options(struct mtree_option *head)\n  236  {\n  237: \tstruct mtree_option *next;\n  238  \n  239  \tfor (; head != NULL; head = next) {\n  ...\n  245  \n  246  static int\n  247: mtree_cmp_node(const struct archive_rb_node *n1,\n  248:     const struct archive_rb_node *n2)\n  249  {\n  250: \tconst struct mtree_entry *e1 = (const struct mtree_entry *)n1;\n  251: \tconst struct mtree_entry *e2 = (const struct mtree_entry *)n2;\n  252  \n  253  \treturn (strcmp(e1->name, e2->name));\n  ...\n  255  \n  256  static int\n  257: mtree_cmp_key(const struct archive_rb_node *n, const void *key)\n  258  {\n  259: \tconst struct mtree_entry *e = (const struct mtree_entry *)n;\n  260  \n  261  \treturn (strcmp(e->name, key));\n  ...\n  263  \n  264  int\n  265: archive_read_support_format_mtree(struct archive *_a)\n  266  {\n  267: \tstatic const struct archive_rb_tree_ops rb_ops = {\n  268  \t\tmtree_cmp_node, mtree_cmp_key,\n  269  \t};\n  270: \tstruct archive_read *a = (struct archive_read *)_a;\n  271: \tstruct mtree *mtree;\n  272  \tint r;\n  273  \n  ...\n  275  \t    ARCHIVE_STATE_NEW, \"archive_read_support_format_mtree\");\n  276  \n  277: \tmtree = (struct mtree *)calloc(1, sizeof(*mtree));\n  278  \tif (mtree == NULL) {\n  279  \t\tarchive_set_error(&a->archive, ENOMEM,\n  ...\n  295  \n  296  static int\n  297: cleanup(struct archive_read *a)\n  298  {\n  299: \tstruct mtree *mtree;\n  300: \tstruct mtree_entry *p, *q;\n  301  \n  302: \tmtree = (struct mtree *)(a->format->data);\n  303  \n  304  \tp = mtree->entries;\n  ...\n  365   */\n  366  static ssize_t\n  367: next_line(struct archive_read *a,\n  368      const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n  369  {\n  ...\n  667  \n  668  static int\n  669: mtree_bid(struct archive_read *a, int best_bid)\n  670  {\n  671  \tconst char *signature = \"#mtree\";\n  ...\n  689  \n  690  static int\n  691: detect_form(struct archive_read *a, int *is_form_d)\n  692  {\n  693  \tconst char *p;\n  ...\n  814   */\n  815  static int\n  816: add_option(struct archive_read *a, struct mtree_option **global,\n  817      const char *value, size_t len)\n  818  {\n  819: \tstruct mtree_option *opt;\n  820  \n  821  \tif ((opt = malloc(sizeof(*opt))) == NULL) {\n  ...\n  836  \n  837  static void\n  838: remove_option(struct mtree_option **global, const char *value, size_t len)\n  839  {\n  840: \tstruct mtree_option *iter, *last;\n  841  \n  842  \tlast = NULL;\n  ...\n  859  \n  860  static int\n  861: process_global_set(struct archive_read *a,\n  862:     struct mtree_option **global, const char *line)\n  863  {\n  864  \tconst char *next, *eq;\n  ...\n  888  \n  889  static int\n  890: process_global_unset(struct archive_read *a,\n  891:     struct mtree_option **global, const char *line)\n  892  {\n  893  \tconst char *next;\n  ...\n  920  \n  921  static int\n  922: process_add_entry(struct archive_read *a, struct mtree *mtree,\n  923:     struct mtree_option **global, const char *line, ssize_t line_len,\n  924:     struct mtree_entry **last_entry, int is_form_d)\n  925  {\n  926: \tstruct mtree_entry *entry;\n  927: \tstruct mtree_option *iter;\n  928  \tconst char *next, *eq, *name, *end;\n  929  \tsize_t name_len, len;\n  ...\n  995  \tif (entry->full) {\n  996  \t\tif (!__archive_rb_tree_insert_node(&mtree->rbtree, &entry->rbnode)) {\n  997: \t\t\tstruct mtree_entry *alt;\n  998: \t\t\talt = (struct mtree_entry *)__archive_rb_tree_find_node(\n  999  \t\t\t    &mtree->rbtree, entry->name);\n 1000  \t\t\twhile (alt->next_dup)\n ....\n 1034  \n 1035  static int\n 1036: read_mtree(struct archive_read *a, struct mtree *mtree)\n 1037  {\n 1038  \tssize_t len;\n 1039  \tuintmax_t counter;\n 1040  \tchar *p, *s;\n 1041: \tstruct mtree_option *global;\n 1042: \tstruct mtree_entry *last_entry;\n 1043  \tint r, is_form_d;\n 1044  \n ....\n 1113   */\n 1114  static int\n 1115: read_header(struct archive_read *a, struct archive_entry *entry)\n 1116  {\n 1117: \tstruct mtree *mtree;\n 1118  \tchar *p;\n 1119  \tint r, use_next;\n 1120  \n 1121: \tmtree = (struct mtree *)(a->format->data);\n 1122  \n 1123  \tif (mtree->fd >= 0) {\n ....\n 1174   */\n 1175  static int\n 1176: parse_file(struct archive_read *a, struct archive_entry *entry,\n 1177:     struct mtree *mtree, struct mtree_entry *mentry, int *use_next)\n 1178  {\n 1179  \tconst char *path;\n 1180: \tstruct stat st_storage, *st;\n 1181: \tstruct mtree_entry *mp;\n 1182: \tstruct archive_entry *sparse_entry;\n 1183  \tint r = ARCHIVE_OK, r1, parsed_kws;\n 1184  \n ....\n 1206  \t\t * tricky subject.)\n 1207  \t\t */\n 1208: \t\tmp = (struct mtree_entry *)__archive_rb_tree_find_node(\n 1209  \t\t    &mtree->rbtree, mentry->name);\n 1210  \t\tfor (; mp; mp = mp->next_dup) {\n ....\n 1219  \t} else {\n 1220  \t\t/*\n 1221: \t\t * Relative entries require us to construct\n 1222  \t\t * the full path and possibly update the\n 1223  \t\t * current directory.\n ....\n 1406   */\n 1407  static int\n 1408: parse_line(struct archive_read *a, struct archive_entry *entry,\n 1409:     struct mtree *mtree, struct mtree_entry *mp, int *parsed_kws)\n 1410  {\n 1411: \tstruct mtree_option *iter;\n 1412  \tint r = ARCHIVE_OK, r1;\n 1413  \n ....\n 1449  \n 1450  static int\n 1451: parse_device(dev_t *pdev, struct archive *a, char *val)\n 1452  {\n 1453  #define MAX_PACK_ARGS 3\n ....\n 1522  \n 1523  static int\n 1524: parse_digest(struct archive_read *a, struct archive_entry *entry,\n 1525      const char *digest, int type)\n 1526  {\n ....\n 1587   */\n 1588  static int\n 1589: parse_keyword(struct archive_read *a, struct mtree *mtree,\n 1590:     struct archive_entry *entry, struct mtree_option *opt, int *parsed_kws)\n 1591  {\n 1592  \tchar *val, *key;\n ....\n 1860  \n 1861  static int\n 1862: read_data(struct archive_read *a, const void **buff, size_t *size,\n 1863      int64_t *offset)\n 1864  {\n 1865  \tsize_t bytes_to_read;\n 1866  \tssize_t bytes_read;\n 1867: \tstruct mtree *mtree;\n 1868  \n 1869: \tmtree = (struct mtree *)(a->format->data);\n 1870  \tif (mtree->fd < 0) {\n 1871  \t\t*buff = NULL;\n ....\n 1906  /* Skip does nothing except possibly close the contents file. */\n 1907  static int\n 1908: skip(struct archive_read *a)\n 1909  {\n 1910: \tstruct mtree *mtree;\n 1911  \n 1912: \tmtree = (struct mtree *)(a->format->data);\n 1913  \tif (mtree->fd >= 0) {\n 1914  \t\tclose(mtree->fd);\n ....\n 1923   */\n 1924  static void\n 1925: parse_escapes(char *src, struct mtree_entry *mentry)\n 1926  {\n 1927  \tchar *dest = src;\n ....\n 2070   */\n 2071  static ssize_t\n 2072: readline(struct archive_read *a, struct mtree *mtree, char **start,\n 2073      ssize_t limit)\n 2074  {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_windows.c:\n   83  #endif\n   84  \n   85: struct ustat {\n   86  \tint64_t\t\tst_atime;\n   87  \tuint32_t\tst_atime_nsec;\n   ..\n  106  #define INOSIZE (8*sizeof(ino_t)) /* 32 */\n  107  static __inline ino_t\n  108: getino(struct ustat *ub)\n  109  {\n  110  \tULARGE_INTEGER ino64;\n  ...\n  455   */\n  456  static int\n  457: __hstat(HANDLE handle, struct ustat *st)\n  458  {\n  459  \tBY_HANDLE_FILE_INFORMATION info;\n  ...\n  552  \n  553  static void\n  554: copy_stat(struct stat *st, struct ustat *us)\n  555  {\n  556  \tst->st_atime = us->st_atime;\n  ...\n  573   */\n  574  int\n  575: __la_fstat(int fd, struct stat *st)\n  576  {\n  577: \tstruct ustat u;\n  578  \tint ret;\n  579  \n  ...\n  595  /* This can exceed MAX_PATH limitation. */\n  596  int\n  597: __la_stat(const char *path, struct stat *st)\n  598  {\n  599  \tHANDLE handle;\n  600: \tstruct ustat u;\n  601  \tint ret;\n  602  \n  ...\n  684   */\n  685  static int\n  686: replace_pathseparator(struct archive_wstring *ws, const wchar_t *wp)\n  687  {\n  688  \twchar_t *w;\n  ...\n  705  \n  706  static int\n  707: fix_pathseparator(struct archive_entry *entry)\n  708  {\n  709: \tstruct archive_wstring ws;\n  710  \tconst wchar_t *wp;\n  711  \tint ret = ARCHIVE_OK;\n  ...\n  746  }\n  747  \n  748: struct archive_entry *\n  749: __la_win_entry_in_posix_pathseparator(struct archive_entry *entry)\n  750  {\n  751: \tstruct archive_entry *entry_main;\n  752  \tconst wchar_t *wp;\n  753  \tint has_backslash = 0;\n  ...\n  829  */\n  830  \n  831: static const struct {\n  832  \tDWORD\t\twinerr;\n  833  \tint\t\tdoserr;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read.c:\n   56  #define minimum(a, b) (a < b ? a : b)\n   57  \n   58: static int\tchoose_filters(struct archive_read *);\n   59: static int\tchoose_format(struct archive_read *);\n   60: static int\tclose_filters(struct archive_read *);\n   61: static struct archive_vtable *archive_read_vtable(void);\n   62: static int64_t\t_archive_filter_bytes(struct archive *, int);\n   63: static int\t_archive_filter_code(struct archive *, int);\n   64: static const char *_archive_filter_name(struct archive *, int);\n   65: static int  _archive_filter_count(struct archive *);\n   66: static int\t_archive_read_close(struct archive *);\n   67: static int\t_archive_read_data_block(struct archive *,\n   68  \t\t    const void **, size_t *, int64_t *);\n   69: static int\t_archive_read_free(struct archive *);\n   70: static int\t_archive_read_next_header(struct archive *,\n   71: \t\t    struct archive_entry **);\n   72: static int\t_archive_read_next_header2(struct archive *,\n   73: \t\t    struct archive_entry *);\n   74: static int64_t  advance_file_pointer(struct archive_read_filter *, int64_t);\n   75  \n   76: static struct archive_vtable *\n   77  archive_read_vtable(void)\n   78  {\n   79: \tstatic struct archive_vtable av;\n   80  \tstatic int inited = 0;\n   81  \n   ..\n   96  \n   97  /*\n   98:  * Allocate, initialize and return a struct archive object.\n   99   */\n  100: struct archive *\n  101  archive_read_new(void)\n  102  {\n  103: \tstruct archive_read *a;\n  104  \n  105: \ta = (struct archive_read *)calloc(1, sizeof(*a));\n  106  \tif (a == NULL)\n  107  \t\treturn (NULL);\n  ...\n  121   */\n  122  void\n  123: archive_read_extract_set_skip_file(struct archive *_a, la_int64_t d,\n  124      la_int64_t i)\n  125  {\n  126: \tstruct archive_read *a = (struct archive_read *)_a;\n  127  \n  128  \tif (ARCHIVE_OK != __archive_check_magic(_a, ARCHIVE_READ_MAGIC,\n  ...\n  138   */\n  139  int\n  140: archive_read_open(struct archive *a, void *client_data,\n  141      archive_open_callback *client_opener, archive_read_callback *client_reader,\n  142      archive_close_callback *client_closer)\n  ...\n  153  \n  154  int\n  155: archive_read_open2(struct archive *a, void *client_data,\n  156      archive_open_callback *client_opener,\n  157      archive_read_callback *client_reader,\n  ...\n  170  \n  171  static ssize_t\n  172: client_read_proxy(struct archive_read_filter *self, const void **buff)\n  173  {\n  174  \tssize_t r;\n  ...\n  179  \n  180  static int64_t\n  181: client_skip_proxy(struct archive_read_filter *self, int64_t request)\n  182  {\n  183  \tif (request < 0)\n  ...\n  229  \n  230  static int64_t\n  231: client_seek_proxy(struct archive_read_filter *self, int64_t offset, int whence)\n  232  {\n  233  \t/* DO NOT use the skipper here!  If we transparently handled\n  ...\n  246  \n  247  static int\n  248: client_close_proxy(struct archive_read_filter *self)\n  249  {\n  250  \tint r = ARCHIVE_OK, r2;\n  ...\n  256  \t{\n  257  \t\tr2 = (self->archive->client.closer)\n  258: \t\t\t((struct archive *)self->archive,\n  259  \t\t\t\tself->archive->client.dataset[i].data);\n  260  \t\tif (r > r2)\n  ...\n  265  \n  266  static int\n  267: client_open_proxy(struct archive_read_filter *self)\n  268  {\n  269    int r = ARCHIVE_OK;\n  270  \tif (self->archive->client.opener != NULL)\n  271  \t\tr = (self->archive->client.opener)(\n  272: \t\t    (struct archive *)self->archive, self->data);\n  273  \treturn (r);\n  274  }\n  275  \n  276  static int\n  277: client_switch_proxy(struct archive_read_filter *self, unsigned int iindex)\n  278  {\n  279    int r1 = ARCHIVE_OK, r2 = ARCHIVE_OK;\n  ...\n  289  \t{\n  290  \t\tr1 = r2 = (self->archive->client.switcher)\n  291: \t\t\t((struct archive *)self->archive, self->data, data2);\n  292  \t\tself->data = data2;\n  293  \t}\n  ...\n  297  \t\tif (self->archive->client.closer != NULL)\n  298  \t\t\tr1 = (self->archive->client.closer)\n  299: \t\t\t\t((struct archive *)self->archive, self->data);\n  300  \t\tself->data = data2;\n  301  \t\tif (self->archive->client.opener != NULL)\n  302  \t\t\tr2 = (self->archive->client.opener)\n  303: \t\t\t\t((struct archive *)self->archive, self->data);\n  304  \t}\n  305  \treturn (r1 < r2) ? r1 : r2;\n  ...\n  307  \n  308  int\n  309: archive_read_set_open_callback(struct archive *_a,\n  310      archive_open_callback *client_opener)\n  311  {\n  312: \tstruct archive_read *a = (struct archive_read *)_a;\n  313  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,\n  314  \t    \"archive_read_set_open_callback\");\n  ...\n  318  \n  319  int\n  320: archive_read_set_read_callback(struct archive *_a,\n  321      archive_read_callback *client_reader)\n  322  {\n  323: \tstruct archive_read *a = (struct archive_read *)_a;\n  324  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,\n  325  \t    \"archive_read_set_read_callback\");\n  ...\n  329  \n  330  int\n  331: archive_read_set_skip_callback(struct archive *_a,\n  332      archive_skip_callback *client_skipper)\n  333  {\n  334: \tstruct archive_read *a = (struct archive_read *)_a;\n  335  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,\n  336  \t    \"archive_read_set_skip_callback\");\n  ...\n  340  \n  341  int\n  342: archive_read_set_seek_callback(struct archive *_a,\n  343      archive_seek_callback *client_seeker)\n  344  {\n  345: \tstruct archive_read *a = (struct archive_read *)_a;\n  346  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,\n  347  \t    \"archive_read_set_seek_callback\");\n  ...\n  351  \n  352  int\n  353: archive_read_set_close_callback(struct archive *_a,\n  354      archive_close_callback *client_closer)\n  355  {\n  356: \tstruct archive_read *a = (struct archive_read *)_a;\n  357  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,\n  358  \t    \"archive_read_set_close_callback\");\n  ...\n  362  \n  363  int\n  364: archive_read_set_switch_callback(struct archive *_a,\n  365      archive_switch_callback *client_switcher)\n  366  {\n  367: \tstruct archive_read *a = (struct archive_read *)_a;\n  368  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,\n  369  \t    \"archive_read_set_switch_callback\");\n  ...\n  373  \n  374  int\n  375: archive_read_set_callback_data(struct archive *_a, void *client_data)\n  376  {\n  377  \treturn archive_read_set_callback_data2(_a, client_data, 0);\n  ...\n  379  \n  380  int\n  381: archive_read_set_callback_data2(struct archive *_a, void *client_data,\n  382      unsigned int iindex)\n  383  {\n  384: \tstruct archive_read *a = (struct archive_read *)_a;\n  385  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,\n  386  \t    \"archive_read_set_callback_data2\");\n  ...\n  388  \tif (a->client.nodes == 0)\n  389  \t{\n  390: \t\ta->client.dataset = (struct archive_read_data_node *)\n  391  \t\t    calloc(1, sizeof(*a->client.dataset));\n  392  \t\tif (a->client.dataset == NULL)\n  ...\n  412  \n  413  int\n  414: archive_read_add_callback_data(struct archive *_a, void *client_data,\n  415      unsigned int iindex)\n  416  {\n  417: \tstruct archive_read *a = (struct archive_read *)_a;\n  418  \tvoid *p;\n  419  \tunsigned int i;\n  ...\n  433  \t\treturn ARCHIVE_FATAL;\n  434  \t}\n  435: \ta->client.dataset = (struct archive_read_data_node *)p;\n  436  \tfor (i = a->client.nodes - 1; i > iindex; i--) {\n  437  \t\ta->client.dataset[i].data = a->client.dataset[i-1].data;\n  ...\n  446  \n  447  int\n  448: archive_read_append_callback_data(struct archive *_a, void *client_data)\n  449  {\n  450: \tstruct archive_read *a = (struct archive_read *)_a;\n  451  \treturn archive_read_add_callback_data(_a, client_data, a->client.nodes);\n  452  }\n  453  \n  454  int\n  455: archive_read_prepend_callback_data(struct archive *_a, void *client_data)\n  456  {\n  457  \treturn archive_read_add_callback_data(_a, client_data, 0);\n  ...\n  459  \n  460  int\n  461: archive_read_open1(struct archive *_a)\n  462  {\n  463: \tstruct archive_read *a = (struct archive_read *)_a;\n  464: \tstruct archive_read_filter *filter, *tmp;\n  465  \tint slot, e = ARCHIVE_OK;\n  466  \tunsigned int i;\n  ...\n  555  \n  556  static int\n  557: choose_filters(struct archive_read *a)\n  558  {\n  559  \tint number_bidders, i, bid, best_bid, number_filters;\n  560: \tstruct archive_read_filter_bidder *bidder, *best_bidder;\n  561: \tstruct archive_read_filter *filter;\n  562  \tssize_t avail;\n  563  \tint r;\n  ...\n  594  \n  595  \t\tfilter\n  596: \t\t    = (struct archive_read_filter *)calloc(1, sizeof(*filter));\n  597  \t\tif (filter == NULL)\n  598  \t\t\treturn (ARCHIVE_FATAL);\n  ...\n  613  \n  614  int\n  615: __archive_read_header(struct archive_read *a, struct archive_entry *entry)\n  616  {\n  617  \tif (a->filter->read_header)\n  ...\n  625   */\n  626  static int\n  627: _archive_read_next_header2(struct archive *_a, struct archive_entry *entry)\n  628  {\n  629: \tstruct archive_read *a = (struct archive_read *)_a;\n  630  \tint r1 = ARCHIVE_OK, r2;\n  631  \n  ...\n  689  \n  690  static int\n  691: _archive_read_next_header(struct archive *_a, struct archive_entry **entryp)\n  692  {\n  693  \tint ret;\n  694: \tstruct archive_read *a = (struct archive_read *)_a;\n  695  \t*entryp = NULL;\n  696  \tret = _archive_read_next_header2(_a, a->entry);\n  ...\n  704   */\n  705  static int\n  706: choose_format(struct archive_read *a)\n  707  {\n  708  \tint slots;\n  ...\n  759   */\n  760  la_int64_t\n  761: archive_read_header_position(struct archive *_a)\n  762  {\n  763: \tstruct archive_read *a = (struct archive_read *)_a;\n  764  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n  765  \t    ARCHIVE_STATE_ANY, \"archive_read_header_position\");\n  ...\n  786   */\n  787  int\n  788: archive_read_has_encrypted_entries(struct archive *_a)\n  789  {\n  790: \tstruct archive_read *a = (struct archive_read *)_a;\n  791  \tint format_supports_encryption = archive_read_format_capabilities(_a)\n  792  \t\t\t& (ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA | ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA);\n  ...\n  811   */\n  812  int\n  813: archive_read_format_capabilities(struct archive *_a)\n  814  {\n  815: \tstruct archive_read *a = (struct archive_read *)_a;\n  816  \tif (a && a->format && a->format->format_capabilties) {\n  817  \t\treturn (a->format->format_capabilties)(a);\n  ...\n  832   */\n  833  la_ssize_t\n  834: archive_read_data(struct archive *_a, void *buff, size_t s)\n  835  {\n  836: \tstruct archive *a = (struct archive *)_a;\n  837  \tchar\t*dest;\n  838  \tconst void *read_buf;\n  ...\n  913   * Reset the read_data_* variables, used for starting a new entry.\n  914   */\n  915: void __archive_reset_read_data(struct archive * a)\n  916  {\n  917  \ta->read_data_output_offset = 0;\n  ...\n  929   */\n  930  int\n  931: archive_read_data_skip(struct archive *_a)\n  932  {\n  933: \tstruct archive_read *a = (struct archive_read *)_a;\n  934  \tint r;\n  935  \tconst void *buff;\n  ...\n  957  \n  958  la_int64_t\n  959: archive_seek_data(struct archive *_a, int64_t offset, int whence)\n  960  {\n  961: \tstruct archive_read *a = (struct archive_read *)_a;\n  962  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_DATA,\n  963  \t    \"archive_seek_data_block\");\n  ...\n  982   */\n  983  static int\n  984: _archive_read_data_block(struct archive *_a,\n  985      const void **buff, size_t *size, int64_t *offset)\n  986  {\n  987: \tstruct archive_read *a = (struct archive_read *)_a;\n  988  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_DATA,\n  989  \t    \"archive_read_data_block\");\n  ...\n 1000  \n 1001  static int\n 1002: close_filters(struct archive_read *a)\n 1003  {\n 1004: \tstruct archive_read_filter *f = a->filter;\n 1005  \tint r = ARCHIVE_OK;\n 1006  \t/* Close each filter in the pipeline. */\n 1007  \twhile (f != NULL) {\n 1008: \t\tstruct archive_read_filter *t = f->upstream;\n 1009  \t\tif (!f->closed && f->close != NULL) {\n 1010  \t\t\tint r1 = (f->close)(f);\n ....\n 1021  \n 1022  void\n 1023: __archive_read_free_filters(struct archive_read *a)\n 1024  {\n 1025  \t/* Make sure filters are closed and their buffers are freed */\n ....\n 1027  \n 1028  \twhile (a->filter != NULL) {\n 1029: \t\tstruct archive_read_filter *t = a->filter->upstream;\n 1030  \t\tfree(a->filter);\n 1031  \t\ta->filter = t;\n ....\n 1037   */\n 1038  static int\n 1039: _archive_filter_count(struct archive *_a)\n 1040  {\n 1041: \tstruct archive_read *a = (struct archive_read *)_a;\n 1042: \tstruct archive_read_filter *p = a->filter;\n 1043  \tint count = 0;\n 1044  \twhile(p) {\n ....\n 1053   */\n 1054  static int\n 1055: _archive_read_close(struct archive *_a)\n 1056  {\n 1057: \tstruct archive_read *a = (struct archive_read *)_a;\n 1058  \tint r = ARCHIVE_OK, r1 = ARCHIVE_OK;\n 1059  \n ....\n 1079   */\n 1080  static int\n 1081: _archive_read_free(struct archive *_a)\n 1082  {\n 1083: \tstruct archive_read *a = (struct archive_read *)_a;\n 1084: \tstruct archive_read_passphrase *p;\n 1085  \tint i, n;\n 1086  \tint slots;\n ....\n 1123  \tp = a->passphrases.first;\n 1124  \twhile (p != NULL) {\n 1125: \t\tstruct archive_read_passphrase *np = p->next;\n 1126  \n 1127  \t\t/* A passphrase should be cleaned. */\n ....\n 1141  }\n 1142  \n 1143: static struct archive_read_filter *\n 1144: get_filter(struct archive *_a, int n)\n 1145  {\n 1146: \tstruct archive_read *a = (struct archive_read *)_a;\n 1147: \tstruct archive_read_filter *f = a->filter;\n 1148  \t/* We use n == -1 for 'the last filter', which is always the\n 1149  \t * client proxy. */\n 1150  \tif (n == -1 && f != NULL) {\n 1151: \t\tstruct archive_read_filter *last = f;\n 1152  \t\tf = f->upstream;\n 1153  \t\twhile (f != NULL) {\n ....\n 1167  \n 1168  static int\n 1169: _archive_filter_code(struct archive *_a, int n)\n 1170  {\n 1171: \tstruct archive_read_filter *f = get_filter(_a, n);\n 1172  \treturn f == NULL ? -1 : f->code;\n 1173  }\n 1174  \n 1175  static const char *\n 1176: _archive_filter_name(struct archive *_a, int n)\n 1177  {\n 1178: \tstruct archive_read_filter *f = get_filter(_a, n);\n 1179  \treturn f != NULL ? f->name : NULL;\n 1180  }\n 1181  \n 1182  static int64_t\n 1183: _archive_filter_bytes(struct archive *_a, int n)\n 1184  {\n 1185: \tstruct archive_read_filter *f = get_filter(_a, n);\n 1186  \treturn f == NULL ? -1 : f->position;\n 1187  }\n ....\n 1192   */\n 1193  int\n 1194: __archive_read_register_format(struct archive_read *a,\n 1195      void *format_data,\n 1196      const char *name,\n 1197:     int (*bid)(struct archive_read *, int),\n 1198:     int (*options)(struct archive_read *, const char *, const char *),\n 1199:     int (*read_header)(struct archive_read *, struct archive_entry *),\n 1200:     int (*read_data)(struct archive_read *, const void **, size_t *, int64_t *),\n 1201:     int (*read_data_skip)(struct archive_read *),\n 1202:     int64_t (*seek_data)(struct archive_read *, int64_t, int),\n 1203:     int (*cleanup)(struct archive_read *),\n 1204:     int (*format_capabilities)(struct archive_read *),\n 1205:     int (*has_encrypted_entries)(struct archive_read *))\n 1206  {\n 1207  \tint i, number_slots;\n ....\n 1242   */\n 1243  int\n 1244: __archive_read_get_bidder(struct archive_read *a,\n 1245:     struct archive_read_filter_bidder **bidder)\n 1246  {\n 1247  \tint i, number_slots;\n ....\n 1314   */\n 1315  const void *\n 1316: __archive_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)\n 1317  {\n 1318  \treturn (__archive_read_filter_ahead(a->filter, min, avail));\n ....\n 1320  \n 1321  const void *\n 1322: __archive_read_filter_ahead(struct archive_read_filter *filter,\n 1323      size_t min, ssize_t *avail)\n 1324  {\n ....\n 1494   */\n 1495  int64_t\n 1496: __archive_read_consume(struct archive_read *a, int64_t request)\n 1497  {\n 1498  \treturn (__archive_read_filter_consume(a->filter, request));\n ....\n 1500  \n 1501  int64_t\n 1502: __archive_read_filter_consume(struct archive_read_filter * filter,\n 1503      int64_t request)\n 1504  {\n ....\n 1530   */\n 1531  static int64_t\n 1532: advance_file_pointer(struct archive_read_filter *filter, int64_t request)\n 1533  {\n 1534  \tint64_t bytes_skipped, total_bytes_skipped = 0;\n ....\n 1617   */\n 1618  int64_t\n 1619: __archive_read_seek(struct archive_read *a, int64_t offset, int whence)\n 1620  {\n 1621  \treturn __archive_read_filter_seek(a->filter, offset, whence);\n ....\n 1623  \n 1624  int64_t\n 1625: __archive_read_filter_seek(struct archive_read_filter *filter, int64_t offset,\n 1626      int whence)\n 1627  {\n 1628: \tstruct archive_read_client *client;\n 1629  \tint64_t r;\n 1630  \tunsigned int cursor;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_passphrase.c:\n   33  \n   34  int\n   35: archive_write_set_passphrase(struct archive *_a, const char *p)\n   36  {\n   37: \tstruct archive_write *a = (struct archive_write *)_a;\n   38  \n   39  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC, ARCHIVE_STATE_NEW,\n   ..\n   57  \n   58  int\n   59: archive_write_set_passphrase_callback(struct archive *_a, void *client_data,\n   60      archive_passphrase_callback *cb)\n   61  {\n   62: \tstruct archive_write *a = (struct archive_write *)_a;\n   63  \n   64  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC, ARCHIVE_STATE_NEW,\n   ..\n   72  \n   73  const char *\n   74: __archive_write_get_passphrase(struct archive_write *a)\n   75  {\n   76  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_zstd.c:\n   56  #if HAVE_ZSTD_H && HAVE_LIBZSTD\n   57  \n   58: struct private_data {\n   59  \tZSTD_DStream\t*dstream;\n   60  \tunsigned char\t*out_block;\n   ..\n   66  \n   67  /* Zstd Filter. */\n   68: static ssize_t\tzstd_filter_read(struct archive_read_filter *, const void**);\n   69: static int\tzstd_filter_close(struct archive_read_filter *);\n   70  #endif\n   71  \n   ..\n   76   * is available.\n   77   */\n   78: static int\tzstd_bidder_bid(struct archive_read_filter_bidder *,\n   79: \t\t    struct archive_read_filter *);\n   80: static int\tzstd_bidder_init(struct archive_read_filter *);\n   81  \n   82  int\n   83: archive_read_support_filter_zstd(struct archive *_a)\n   84  {\n   85: \tstruct archive_read *a = (struct archive_read *)_a;\n   86: \tstruct archive_read_filter_bidder *bidder;\n   87  \n   88  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n   ..\n  111   */\n  112  static int\n  113: zstd_bidder_bid(struct archive_read_filter_bidder *self,\n  114:     struct archive_read_filter *filter)\n  115  {\n  116  \tconst unsigned char *buffer;\n  ...\n  146   */\n  147  static int\n  148: zstd_bidder_init(struct archive_read_filter *self)\n  149  {\n  150  \tint r;\n  ...\n  165   */\n  166  static int\n  167: zstd_bidder_init(struct archive_read_filter *self)\n  168  {\n  169: \tstruct private_data *state;\n  170  \tconst size_t out_block_size = ZSTD_DStreamOutSize();\n  171  \tvoid *out_block;\n  ...\n  175  \tself->name = \"zstd\";\n  176  \n  177: \tstate = (struct private_data *)calloc(sizeof(*state), 1);\n  178  \tout_block = (unsigned char *)malloc(out_block_size);\n  179  \tdstream = ZSTD_createDStream();\n  ...\n  204  \n  205  static ssize_t\n  206: zstd_filter_read(struct archive_read_filter *self, const void **p)\n  207  {\n  208: \tstruct private_data *state;\n  209  \tsize_t decompressed;\n  210  \tssize_t avail_in;\n  ...\n  212  \tZSTD_inBuffer in;\n  213  \n  214: \tstate = (struct private_data *)self->data;\n  215  \n  216  \tout = (ZSTD_outBuffer) { state->out_block, state->out_block_size, 0 };\n  ...\n  281   */\n  282  static int\n  283: zstd_filter_close(struct archive_read_filter *self)\n  284  {\n  285: \tstruct private_data *state;\n  286  \n  287: \tstate = (struct private_data *)self->data;\n  288  \n  289  \tZSTD_freeDStream(state->dstream);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_uu.c:\n   44  #define UUENCODE_BID_MAX_READ 128*1024 /* in bytes */\n   45  \n   46: struct uudecode {\n   47  \tint64_t\t\t total;\n   48  \tunsigned char\t*in_buff;\n   ..\n   60  };\n   61  \n   62: static int\tuudecode_bidder_bid(struct archive_read_filter_bidder *,\n   63: \t\t    struct archive_read_filter *filter);\n   64: static int\tuudecode_bidder_init(struct archive_read_filter *);\n   65  \n   66: static ssize_t\tuudecode_filter_read(struct archive_read_filter *,\n   67  \t\t    const void **);\n   68: static int\tuudecode_filter_close(struct archive_read_filter *);\n   69  \n   70  #if ARCHIVE_VERSION_NUMBER < 4000000\n   71  /* Deprecated; remove in libarchive 4.0 */\n   72  int\n   73: archive_read_support_compression_uu(struct archive *a)\n   74  {\n   75  \treturn archive_read_support_filter_uu(a);\n   ..\n   78  \n   79  int\n   80: archive_read_support_filter_uu(struct archive *_a)\n   81  {\n   82: \tstruct archive_read *a = (struct archive_read *)_a;\n   83: \tstruct archive_read_filter_bidder *bidder;\n   84  \n   85  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n   ..\n  209  \n  210  static ssize_t\n  211: bid_get_line(struct archive_read_filter *filter,\n  212      const unsigned char **b, ssize_t *avail, ssize_t *ravail,\n  213      ssize_t *nl, size_t* nbytes_read)\n  ...\n  260  \n  261  static int\n  262: uudecode_bidder_bid(struct archive_read_filter_bidder *self,\n  263:     struct archive_read_filter *filter)\n  264  {\n  265  \tconst unsigned char *b;\n  ...\n  359  \n  360  static int\n  361: uudecode_bidder_init(struct archive_read_filter *self)\n  362  {\n  363: \tstruct uudecode   *uudecode;\n  364  \tvoid *out_buff;\n  365  \tvoid *in_buff;\n  ...\n  371  \tself->close = uudecode_filter_close;\n  372  \n  373: \tuudecode = (struct uudecode *)calloc(sizeof(*uudecode), 1);\n  374  \tout_buff = malloc(OUT_BUFF_SIZE);\n  375  \tin_buff = malloc(IN_BUFF_SIZE);\n  ...\n  394  \n  395  static int\n  396: ensure_in_buff_size(struct archive_read_filter *self,\n  397:     struct uudecode *uudecode, size_t size)\n  398  {\n  399  \n  ...\n  434  \n  435  static ssize_t\n  436: uudecode_filter_read(struct archive_read_filter *self, const void **buff)\n  437  {\n  438: \tstruct uudecode *uudecode;\n  439  \tconst unsigned char *b, *d;\n  440  \tunsigned char *out;\n  ...\n  444  \tssize_t len, llen, nl;\n  445  \n  446: \tuudecode = (struct uudecode *)self->data;\n  447  \n  448  read_more:\n  ...\n  672  \n  673  static int\n  674: uudecode_filter_close(struct archive_read_filter *self)\n  675  {\n  676: \tstruct uudecode *uudecode;\n  677  \n  678: \tuudecode = (struct uudecode *)self->data;\n  679  \tfree(uudecode->in_buff);\n  680  \tfree(uudecode->out_buff);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_open_memory.c:\n   41   */\n   42  \n   43: struct read_memory_data {\n   44  \tconst unsigned char\t*start;\n   45  \tconst unsigned char\t*p;\n   ..\n   48  };\n   49  \n   50: static int\tmemory_read_close(struct archive *, void *);\n   51: static int\tmemory_read_open(struct archive *, void *);\n   52: static int64_t\tmemory_read_seek(struct archive *, void *, int64_t offset, int whence);\n   53: static int64_t\tmemory_read_skip(struct archive *, void *, int64_t request);\n   54: static ssize_t\tmemory_read(struct archive *, void *, const void **buff);\n   55  \n   56  int\n   57: archive_read_open_memory(struct archive *a, const void *buff, size_t size)\n   58  {\n   59  \treturn archive_read_open_memory2(a, buff, size, size);\n   ..\n   66   */\n   67  int\n   68: archive_read_open_memory2(struct archive *a, const void *buff,\n   69      size_t size, size_t read_size)\n   70  {\n   71: \tstruct read_memory_data *mine;\n   72  \n   73: \tmine = (struct read_memory_data *)calloc(1, sizeof(*mine));\n   74  \tif (mine == NULL) {\n   75  \t\tarchive_set_error(a, ENOMEM, \"No memory\");\n   ..\n   92   */\n   93  static int\n   94: memory_read_open(struct archive *a, void *client_data)\n   95  {\n   96  \t(void)a; /* UNUSED */\n   ..\n  107   */\n  108  static ssize_t\n  109: memory_read(struct archive *a, void *client_data, const void **buff)\n  110  {\n  111: \tstruct read_memory_data *mine = (struct read_memory_data *)client_data;\n  112  \tssize_t size;\n  113  \n  ...\n  127   */\n  128  static int64_t\n  129: memory_read_skip(struct archive *a, void *client_data, int64_t skip)\n  130  {\n  131: \tstruct read_memory_data *mine = (struct read_memory_data *)client_data;\n  132  \n  133  \t(void)a; /* UNUSED */\n  ...\n  145   */\n  146  static int64_t\n  147: memory_read_seek(struct archive *a, void *client_data, int64_t offset, int whence)\n  148  {\n  149: \tstruct read_memory_data *mine = (struct read_memory_data *)client_data;\n  150  \n  151  \t(void)a; /* UNUSED */\n  ...\n  178   */\n  179  static int\n  180: memory_read_close(struct archive *a, void *client_data)\n  181  {\n  182: \tstruct read_memory_data *mine = (struct read_memory_data *)client_data;\n  183  \t(void)a; /* UNUSED */\n  184  \tfree(mine);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_private.h:\n   68  #define\tARCHIVE_STATE_ANY\t(0xFFFFU & ~ARCHIVE_STATE_FATAL)\n   69  \n   70: struct archive_vtable {\n   71: \tint\t(*archive_close)(struct archive *);\n   72: \tint\t(*archive_free)(struct archive *);\n   73: \tint\t(*archive_write_header)(struct archive *,\n   74: \t    struct archive_entry *);\n   75: \tint\t(*archive_write_finish_entry)(struct archive *);\n   76: \tssize_t\t(*archive_write_data)(struct archive *,\n   77  \t    const void *, size_t);\n   78: \tssize_t\t(*archive_write_data_block)(struct archive *,\n   79  \t    const void *, size_t, int64_t);\n   80  \n   81: \tint\t(*archive_read_next_header)(struct archive *,\n   82: \t    struct archive_entry **);\n   83: \tint\t(*archive_read_next_header2)(struct archive *,\n   84: \t    struct archive_entry *);\n   85: \tint\t(*archive_read_data_block)(struct archive *,\n   86  \t    const void **, size_t *, int64_t *);\n   87  \n   88: \tint\t(*archive_filter_count)(struct archive *);\n   89: \tint64_t (*archive_filter_bytes)(struct archive *, int);\n   90: \tint\t(*archive_filter_code)(struct archive *, int);\n   91: \tconst char * (*archive_filter_name)(struct archive *, int);\n   92  };\n   93  \n   94: struct archive_string_conv;\n   95  \n   96: struct archive {\n   97  \t/*\n   98  \t * The magic/state values are used to sanity-check the\n   ..\n  108  \t * archive object.\n  109  \t */\n  110: \tstruct archive_vtable *vtable;\n  111  \n  112  \tint\t\t  archive_format;\n  ...\n  121  \tint\t\t  archive_error_number;\n  122  \tconst char\t *error;\n  123: \tstruct archive_string\terror_string;\n  124  \n  125  \tchar *current_code;\n  126  \tunsigned current_codepage; /* Current ACP(ANSI CodePage). */\n  127  \tunsigned current_oemcp; /* Current OEMCP(OEM CodePage). */\n  128: \tstruct archive_string_conv *sconv;\n  129  \n  130  \t/*\n  ...\n  147  \n  148  /* Check magic value and state; return(ARCHIVE_FATAL) if it isn't valid. */\n  149: int\t__archive_check_magic(struct archive *, unsigned int magic,\n  150  \t    unsigned int state, const char *func);\n  151  #define\tarchive_check_magic(a, expected_magic, allowed_states, function_name) \\\n  ...\n  167  #endif\n  168  \n  169: int\t__archive_clean(struct archive *);\n  170  \n  171: void __archive_reset_read_data(struct archive *);\n  172  \n  173  #define\terr_combine(a,b)\t((a) < (b) ? (a) : (b))\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_ar.c:\n   50  #include \"archive_read_private.h\"\n   51  \n   52: struct ar {\n   53  \tint64_t\t entry_bytes_remaining;\n   54  \t/* unconsumed is purely to track data we've gotten from readahead,\n   ..\n   65  \n   66  /*\n   67:  * Define structure of the \"ar\" header.\n   68   */\n   69  #define AR_name_offset 0\n   ..\n   82  #define AR_fmag_size 2\n   83  \n   84: static int\tarchive_read_format_ar_bid(struct archive_read *a, int);\n   85: static int\tarchive_read_format_ar_cleanup(struct archive_read *a);\n   86: static int\tarchive_read_format_ar_read_data(struct archive_read *a,\n   87  \t\t    const void **buff, size_t *size, int64_t *offset);\n   88: static int\tarchive_read_format_ar_skip(struct archive_read *a);\n   89: static int\tarchive_read_format_ar_read_header(struct archive_read *a,\n   90: \t\t    struct archive_entry *e);\n   91  static uint64_t\tar_atol8(const char *p, unsigned char_cnt);\n   92  static uint64_t\tar_atol10(const char *p, unsigned char_cnt);\n   93: static int\tar_parse_gnu_filename_table(struct archive_read *a);\n   94: static int\tar_parse_common_header(struct ar *ar, struct archive_entry *,\n   95  \t\t    const char *h);\n   96  \n   97  int\n   98: archive_read_support_format_ar(struct archive *_a)\n   99  {\n  100: \tstruct archive_read *a = (struct archive_read *)_a;\n  101: \tstruct ar *ar;\n  102  \tint r;\n  103  \n  ...\n  105  \t    ARCHIVE_STATE_NEW, \"archive_read_support_format_ar\");\n  106  \n  107: \tar = (struct ar *)calloc(1, sizeof(*ar));\n  108  \tif (ar == NULL) {\n  109  \t\tarchive_set_error(&a->archive, ENOMEM,\n  ...\n  134  \n  135  static int\n  136: archive_read_format_ar_cleanup(struct archive_read *a)\n  137  {\n  138: \tstruct ar *ar;\n  139  \n  140: \tar = (struct ar *)(a->format->data);\n  141  \tfree(ar->strtab);\n  142  \tfree(ar);\n  ...\n  146  \n  147  static int\n  148: archive_read_format_ar_bid(struct archive_read *a, int best_bid)\n  149  {\n  150  \tconst void *h;\n  ...\n  165  \n  166  static int\n  167: _ar_read_header(struct archive_read *a, struct archive_entry *entry,\n  168: \tstruct ar *ar, const char *h, size_t *unconsumed)\n  169  {\n  170  \tchar filename[AR_name_size + 1];\n  ...\n  418  \n  419  static int\n  420: archive_read_format_ar_read_header(struct archive_read *a,\n  421:     struct archive_entry *entry)\n  422  {\n  423: \tstruct ar *ar = (struct ar*)(a->format->data);\n  424  \tsize_t unconsumed;\n  425  \tconst void *header_data;\n  ...\n  454  \n  455  static int\n  456: ar_parse_common_header(struct ar *ar, struct archive_entry *entry,\n  457      const char *h)\n  458  {\n  ...\n  479  \n  480  static int\n  481: archive_read_format_ar_read_data(struct archive_read *a,\n  482      const void **buff, size_t *size, int64_t *offset)\n  483  {\n  484  \tssize_t bytes_read;\n  485: \tstruct ar *ar;\n  486  \n  487: \tar = (struct ar *)(a->format->data);\n  488  \n  489  \tif (ar->entry_bytes_unconsumed) {\n  ...\n  529  \n  530  static int\n  531: archive_read_format_ar_skip(struct archive_read *a)\n  532  {\n  533  \tint64_t bytes_skipped;\n  534: \tstruct ar* ar;\n  535  \n  536: \tar = (struct ar *)(a->format->data);\n  537  \n  538  \tbytes_skipped = __archive_read_consume(a,\n  ...\n  550  \n  551  static int\n  552: ar_parse_gnu_filename_table(struct archive_read *a)\n  553  {\n  554: \tstruct ar *ar;\n  555  \tchar *p;\n  556  \tsize_t size;\n  557  \n  558: \tar = (struct ar*)(a->format->data);\n  559  \tsize = ar->strtab_size;\n  560  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_blake2.h:\n   48    };\n   49  \n   50:   typedef struct blake2s_state__\n   51    {\n   52      uint32_t h[8];\n   ..\n   59    } blake2s_state;\n   60  \n   61:   typedef struct blake2b_state__\n   62    {\n   63      uint64_t h[8];\n   ..\n   70    } blake2b_state;\n   71  \n   72:   typedef struct blake2sp_state__\n   73    {\n   74      blake2s_state S[8][1];\n   ..\n   79    } blake2sp_state;\n   80  \n   81:   typedef struct blake2bp_state__\n   82    {\n   83      blake2b_state S[4][1];\n   ..\n   88    } blake2bp_state;\n   89  \n   90:   BLAKE2_PACKED(struct blake2s_param__\n   91    {\n   92      uint8_t  digest_length; /* 1 */\n   ..\n  104    });\n  105  \n  106:   typedef struct blake2s_param__ blake2s_param;\n  107  \n  108:   BLAKE2_PACKED(struct blake2b_param__\n  109    {\n  110      uint8_t  digest_length; /* 1 */\n  ...\n  122    });\n  123  \n  124:   typedef struct blake2b_param__ blake2b_param;\n  125  \n  126:   typedef struct blake2xs_state__\n  127    {\n  128      blake2s_state S[1];\n  ...\n  130    } blake2xs_state;\n  131  \n  132:   typedef struct blake2xb_state__\n  133    {\n  134      blake2b_state S[1];\n  ...\n  136    } blake2xb_state;\n  137  \n  138:   /* Padded structs result in a compile-time error */\n  139    enum {\n  140      BLAKE2_DUMMY_1 = 1/(sizeof(blake2s_param) == BLAKE2S_OUTBYTES),\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_by_code.c:\n   31  \n   32  int\n   33: archive_read_support_filter_by_code(struct archive *a, int filter_code)\n   34  {\n   35  \tarchive_check_magic(a, ARCHIVE_READ_MAGIC,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_pack_dev.c:\n  288  \t\t/* list of formats and pack functions */\n  289  \t\t/* this list must be sorted lexically */\n  290: static const struct format {\n  291  \tconst char\t*name;\n  292  \tpack_t\t\t*pack;\n  ...\n  314  {\n  315  \tconst char\t\t*name;\n  316: \tconst struct format\t*format;\n  317  \n  318  \tname = key;\n  ...\n  326  pack_find(const char *name)\n  327  {\n  328: \tstruct format\t*format;\n  329  \n  330  \tformat = bsearch(name, formats,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_cpio.c:\n  163  \n  164  \n  165: struct links_entry {\n  166:         struct links_entry      *next;\n  167:         struct links_entry      *previous;\n  168          unsigned int             links;\n  169          dev_t                    dev;\n  ...\n  173  \n  174  #define\tCPIO_MAGIC   0x13141516\n  175: struct cpio {\n  176  \tint\t\t\t  magic;\n  177: \tint\t\t\t(*read_header)(struct archive_read *, struct cpio *,\n  178: \t\t\t\t     struct archive_entry *, size_t *, size_t *);\n  179: \tstruct links_entry\t *links_head;\n  180  \tint64_t\t\t\t  entry_bytes_remaining;\n  181  \tint64_t\t\t\t  entry_bytes_unconsumed;\n  ...\n  183  \tint64_t\t\t\t  entry_padding;\n  184  \n  185: \tstruct archive_string_conv *opt_sconv;\n  186: \tstruct archive_string_conv *sconv_default;\n  187  \tint\t\t\t  init_default_conversion;\n  188  \n  ...\n  192  static int64_t\tatol16(const char *, unsigned);\n  193  static int64_t\tatol8(const char *, unsigned);\n  194: static int\tarchive_read_format_cpio_bid(struct archive_read *, int);\n  195: static int\tarchive_read_format_cpio_options(struct archive_read *,\n  196  \t\t    const char *, const char *);\n  197: static int\tarchive_read_format_cpio_cleanup(struct archive_read *);\n  198: static int\tarchive_read_format_cpio_read_data(struct archive_read *,\n  199  \t\t    const void **, size_t *, int64_t *);\n  200: static int\tarchive_read_format_cpio_read_header(struct archive_read *,\n  201: \t\t    struct archive_entry *);\n  202: static int\tarchive_read_format_cpio_skip(struct archive_read *);\n  203  static int64_t\tbe4(const unsigned char *);\n  204: static int\tfind_odc_header(struct archive_read *);\n  205: static int\tfind_newc_header(struct archive_read *);\n  206: static int\theader_bin_be(struct archive_read *, struct cpio *,\n  207: \t\t    struct archive_entry *, size_t *, size_t *);\n  208: static int\theader_bin_le(struct archive_read *, struct cpio *,\n  209: \t\t    struct archive_entry *, size_t *, size_t *);\n  210: static int\theader_newc(struct archive_read *, struct cpio *,\n  211: \t\t    struct archive_entry *, size_t *, size_t *);\n  212: static int\theader_odc(struct archive_read *, struct cpio *,\n  213: \t\t    struct archive_entry *, size_t *, size_t *);\n  214: static int\theader_afiol(struct archive_read *, struct cpio *,\n  215: \t\t    struct archive_entry *, size_t *, size_t *);\n  216  static int\tis_octal(const char *, size_t);\n  217  static int\tis_hex(const char *, size_t);\n  218  static int64_t\tle4(const unsigned char *);\n  219: static int\trecord_hardlink(struct archive_read *a,\n  220: \t\t    struct cpio *cpio, struct archive_entry *entry);\n  221  \n  222  int\n  223: archive_read_support_format_cpio(struct archive *_a)\n  224  {\n  225: \tstruct archive_read *a = (struct archive_read *)_a;\n  226: \tstruct cpio *cpio;\n  227  \tint r;\n  228  \n  ...\n  230  \t    ARCHIVE_STATE_NEW, \"archive_read_support_format_cpio\");\n  231  \n  232: \tcpio = (struct cpio *)calloc(1, sizeof(*cpio));\n  233  \tif (cpio == NULL) {\n  234  \t\tarchive_set_error(&a->archive, ENOMEM, \"Can't allocate cpio data\");\n  ...\n  257  \n  258  static int\n  259: archive_read_format_cpio_bid(struct archive_read *a, int best_bid)\n  260  {\n  261  \tconst unsigned char *p;\n  262: \tstruct cpio *cpio;\n  263  \tint bid;\n  264  \n  265  \t(void)best_bid; /* UNUSED */\n  266  \n  267: \tcpio = (struct cpio *)(a->format->data);\n  268  \n  269  \tif ((p = __archive_read_ahead(a, 6, NULL)) == NULL)\n  ...\n  321  \n  322  static int\n  323: archive_read_format_cpio_options(struct archive_read *a,\n  324      const char *key, const char *val)\n  325  {\n  326: \tstruct cpio *cpio;\n  327  \tint ret = ARCHIVE_FAILED;\n  328  \n  329: \tcpio = (struct cpio *)(a->format->data);\n  330  \tif (strcmp(key, \"compat-2x\")  == 0) {\n  331  \t\t/* Handle filenames as libarchive 2.x */\n  ...\n  359  \n  360  static int\n  361: archive_read_format_cpio_read_header(struct archive_read *a,\n  362:     struct archive_entry *entry)\n  363  {\n  364: \tstruct cpio *cpio;\n  365  \tconst void *h, *hl;\n  366: \tstruct archive_string_conv *sconv;\n  367  \tsize_t namelength;\n  368  \tsize_t name_pad;\n  369  \tint r;\n  370  \n  371: \tcpio = (struct cpio *)(a->format->data);\n  372  \tsconv = cpio->opt_sconv;\n  373  \tif (sconv == NULL) {\n  ...\n  457  \n  458  static int\n  459: archive_read_format_cpio_read_data(struct archive_read *a,\n  460      const void **buff, size_t *size, int64_t *offset)\n  461  {\n  462  \tssize_t bytes_read;\n  463: \tstruct cpio *cpio;\n  464  \n  465: \tcpio = (struct cpio *)(a->format->data);\n  466  \n  467  \tif (cpio->entry_bytes_unconsumed) {\n  ...\n  496  \n  497  static int\n  498: archive_read_format_cpio_skip(struct archive_read *a)\n  499  {\n  500: \tstruct cpio *cpio = (struct cpio *)(a->format->data);\n  501  \tint64_t to_skip = cpio->entry_bytes_remaining + cpio->entry_padding +\n  502  \t\tcpio->entry_bytes_unconsumed;\n  ...\n  531  \n  532  static int\n  533: find_newc_header(struct archive_read *a)\n  534  {\n  535  \tconst void *h;\n  ...\n  591  \n  592  static int\n  593: header_newc(struct archive_read *a, struct cpio *cpio,\n  594:     struct archive_entry *entry, size_t *namelength, size_t *name_pad)\n  595  {\n  596  \tconst void *h;\n  ...\n  700  \n  701  static int\n  702: find_odc_header(struct archive_read *a)\n  703  {\n  704  \tconst void *h;\n  ...\n  766  \n  767  static int\n  768: header_odc(struct archive_read *a, struct cpio *cpio,\n  769:     struct archive_entry *entry, size_t *namelength, size_t *name_pad)\n  770  {\n  771  \tconst void *h;\n  ...\n  833   */\n  834  static int\n  835: header_afiol(struct archive_read *a, struct cpio *cpio,\n  836:     struct archive_entry *entry, size_t *namelength, size_t *name_pad)\n  837  {\n  838  \tconst void *h;\n  ...\n  875  \n  876  static int\n  877: header_bin_le(struct archive_read *a, struct cpio *cpio,\n  878:     struct archive_entry *entry, size_t *namelength, size_t *name_pad)\n  879  {\n  880  \tconst void *h;\n  ...\n  920  \n  921  static int\n  922: header_bin_be(struct archive_read *a, struct cpio *cpio,\n  923:     struct archive_entry *entry, size_t *namelength, size_t *name_pad)\n  924  {\n  925  \tconst void *h;\n  ...\n  965  \n  966  static int\n  967: archive_read_format_cpio_cleanup(struct archive_read *a)\n  968  {\n  969: \tstruct cpio *cpio;\n  970  \n  971: \tcpio = (struct cpio *)(a->format->data);\n  972          /* Free inode->name map */\n  973          while (cpio->links_head != NULL) {\n  974:                 struct links_entry *lp = cpio->links_head->next;\n  975  \n  976                  free(cpio->links_head->name);\n  ...\n 1044  \n 1045  static int\n 1046: record_hardlink(struct archive_read *a,\n 1047:     struct cpio *cpio, struct archive_entry *entry)\n 1048  {\n 1049: \tstruct links_entry      *le;\n 1050  \tdev_t dev;\n 1051  \tint64_t ino;\n ....\n 1080  \t}\n 1081  \n 1082: \tle = (struct links_entry *)malloc(sizeof(struct links_entry));\n 1083  \tif (le == NULL) {\n 1084  \t\tarchive_set_error(&a->archive,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_none.c:\n   33  /* Deprecated; remove in libarchive 4.0 */\n   34  int\n   35: archive_read_support_compression_none(struct archive *a)\n   36  {\n   37  \treturn archive_read_support_filter_none(a);\n   ..\n   44   */\n   45  int\n   46: archive_read_support_filter_none(struct archive *a)\n   47  {\n   48  \tarchive_check_magic(a, ARCHIVE_READ_MAGIC,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_disk_posix.c:\n  170  #endif\n  171  \n  172: struct fixup_entry {\n  173: \tstruct fixup_entry\t*next;\n  174: \tstruct archive_acl\t acl;\n  175  \tmode_t\t\t\t mode;\n  176  \tint64_t\t\t\t atime;\n  ...\n  218  #define\tTODO_HFS_COMPRESSION\tARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED\n  219  \n  220: struct archive_write_disk {\n  221: \tstruct archive\tarchive;\n  222  \n  223  \tmode_t\t\t\t user_umask;\n  224: \tstruct fixup_entry\t*fixup_list;\n  225: \tstruct fixup_entry\t*current_fixup;\n  226  \tint64_t\t\t\t user_uid;\n  227  \tint\t\t\t skip_file_set;\n  ...\n  240  \t * Full path of last file to satisfy symlink checks.\n  241  \t */\n  242: \tstruct archive_string\tpath_safe;\n  243  \n  244  \t/*\n  ...\n  247  \t * pst is null.\n  248  \t */\n  249: \tstruct stat\t\t st;\n  250: \tstruct stat\t\t*pst;\n  251  \n  252  \t/* Information about the object being restored right now. */\n  253: \tstruct archive_entry\t*entry; /* Entry being extracted. */\n  254  \tchar\t\t\t*name; /* Name of entry, possibly edited. */\n  255: \tstruct archive_string\t _name_data; /* backing store for 'name' */\n  256  \tchar\t\t\t*tmpname; /* Temporary name * */\n  257: \tstruct archive_string\t _tmpname_data; /* backing store for 'tmpname' */\n  258  \t/* Tasks remaining for this object. */\n  259  \tint\t\t\t todo;\n  ...\n  357  \n  358  static int\tla_opendirat(int, const char *);\n  359: static int\tla_mktemp(struct archive_write_disk *);\n  360: static void\tfsobj_error(int *, struct archive_string *, int, const char *,\n  361  \t\t    const char *);\n  362: static int\tcheck_symlinks_fsobj(char *, int *, struct archive_string *,\n  363  \t\t    int, int);\n  364: static int\tcheck_symlinks(struct archive_write_disk *);\n  365: static int\tcreate_filesystem_object(struct archive_write_disk *);\n  366: static struct fixup_entry *current_fixup(struct archive_write_disk *,\n  367  \t\t    const char *pathname);\n  368  #if defined(HAVE_FCHDIR) && defined(PATH_MAX)\n  369: static void\tedit_deep_directories(struct archive_write_disk *ad);\n  370  #endif\n  371: static int\tcleanup_pathname_fsobj(char *, int *, struct archive_string *,\n  372  \t\t    int);\n  373: static int\tcleanup_pathname(struct archive_write_disk *);\n  374: static int\tcreate_dir(struct archive_write_disk *, char *);\n  375: static int\tcreate_parent_dir(struct archive_write_disk *, char *);\n  376: static ssize_t\thfs_write_data_block(struct archive_write_disk *,\n  377  \t\t    const char *, size_t);\n  378: static int\tfixup_appledouble(struct archive_write_disk *, const char *);\n  379: static int\tolder(struct stat *, struct archive_entry *);\n  380: static int\trestore_entry(struct archive_write_disk *);\n  381: static int\tset_mac_metadata(struct archive_write_disk *, const char *,\n  382  \t\t\t\t const void *, size_t);\n  383: static int\tset_xattrs(struct archive_write_disk *);\n  384: static int\tclear_nochange_fflags(struct archive_write_disk *);\n  385: static int\tset_fflags(struct archive_write_disk *);\n  386: static int\tset_fflags_platform(struct archive_write_disk *, int fd,\n  387  \t\t    const char *name, mode_t mode,\n  388  \t\t    unsigned long fflags_set, unsigned long fflags_clear);\n  389: static int\tset_ownership(struct archive_write_disk *);\n  390: static int\tset_mode(struct archive_write_disk *, int mode);\n  391  static int\tset_time(int, int, const char *, time_t, long, time_t, long);\n  392: static int\tset_times(struct archive_write_disk *, int, int, const char *,\n  393  \t\t    time_t, long, time_t, long, time_t, long, time_t, long);\n  394: static int\tset_times_from_entry(struct archive_write_disk *);\n  395: static struct fixup_entry *sort_dir_list(struct fixup_entry *p);\n  396: static ssize_t\twrite_data_block(struct archive_write_disk *,\n  397  \t\t    const char *, size_t);\n  398  \n  399: static struct archive_vtable *archive_write_disk_vtable(void);\n  400  \n  401: static int\t_archive_write_disk_close(struct archive *);\n  402: static int\t_archive_write_disk_free(struct archive *);\n  403: static int\t_archive_write_disk_header(struct archive *,\n  404: \t\t    struct archive_entry *);\n  405: static int64_t\t_archive_write_disk_filter_bytes(struct archive *, int);\n  406: static int\t_archive_write_disk_finish_entry(struct archive *);\n  407: static ssize_t\t_archive_write_disk_data(struct archive *, const void *,\n  408  \t\t    size_t);\n  409: static ssize_t\t_archive_write_disk_data_block(struct archive *, const void *,\n  410  \t\t    size_t, int64_t);\n  411  \n  412  static int\n  413: la_mktemp(struct archive_write_disk *a)\n  414  {\n  415  \tint oerrno, fd;\n  ...\n  466  \n  467  static int\n  468: lazy_stat(struct archive_write_disk *a)\n  469  {\n  470  \tif (a->pst != NULL) {\n  ...\n  490  }\n  491  \n  492: static struct archive_vtable *\n  493  archive_write_disk_vtable(void)\n  494  {\n  495: \tstatic struct archive_vtable av;\n  496  \tstatic int inited = 0;\n  497  \n  ...\n  511  \n  512  static int64_t\n  513: _archive_write_disk_filter_bytes(struct archive *_a, int n)\n  514  {\n  515: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n  516  \t(void)n; /* UNUSED */\n  517  \tif (n == -1 || n == 0)\n  ...\n  522  \n  523  int\n  524: archive_write_disk_set_options(struct archive *_a, int flags)\n  525  {\n  526: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n  527  \n  528  \ta->flags = flags;\n  ...\n  543   */\n  544  static int\n  545: _archive_write_disk_header(struct archive *_a, struct archive_entry *entry)\n  546  {\n  547: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n  548: \tstruct fixup_entry *fe;\n  549  \tconst char *linkname;\n  550  \tint ret, r;\n  ...\n  912  \n  913  int\n  914: archive_write_disk_set_skip_file(struct archive *_a, la_int64_t d, la_int64_t i)\n  915  {\n  916: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n  917  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n  918  \t    ARCHIVE_STATE_ANY, \"archive_write_disk_set_skip_file\");\n  ...\n  924  \n  925  static ssize_t\n  926: write_data_block(struct archive_write_disk *a, const char *buff, size_t size)\n  927  {\n  928  \tuint64_t start_size = size;\n  ...\n 1018   */\n 1019  static int\n 1020: hfs_set_compressed_fflag(struct archive_write_disk *a)\n 1021  {\n 1022  \tint r;\n ....\n 1057   */\n 1058  static int\n 1059: hfs_write_decmpfs(struct archive_write_disk *a)\n 1060  {\n 1061  \tint r;\n ....\n 1114   */\n 1115  static int\n 1116: hfs_write_resource_fork(struct archive_write_disk *a, unsigned char *buff,\n 1117      size_t bytes, uint32_t position)\n 1118  {\n ....\n 1134  \n 1135  static int\n 1136: hfs_write_compressed_data(struct archive_write_disk *a, size_t bytes_compressed)\n 1137  {\n 1138  \tint ret;\n ....\n 1146  \n 1147  static int\n 1148: hfs_write_resource_fork_header(struct archive_write_disk *a)\n 1149  {\n 1150  \tunsigned char *buff;\n ....\n 1189  \n 1190  static int\n 1191: hfs_reset_compressor(struct archive_write_disk *a)\n 1192  {\n 1193  \tint ret;\n ....\n 1209  \n 1210  static int\n 1211: hfs_decompress(struct archive_write_disk *a)\n 1212  {\n 1213  \tuint32_t *block_info;\n ....\n 1270  \n 1271  static int\n 1272: hfs_drive_compressor(struct archive_write_disk *a, const char *buff,\n 1273      size_t size)\n 1274  {\n ....\n 1421  \n 1422  static ssize_t\n 1423: hfs_write_decmpfs_block(struct archive_write_disk *a, const char *buff,\n 1424      size_t size)\n 1425  {\n ....\n 1547  \n 1548  static ssize_t\n 1549: hfs_write_data_block(struct archive_write_disk *a, const char *buff,\n 1550      size_t size)\n 1551  {\n ....\n 1612  #else\n 1613  static ssize_t\n 1614: hfs_write_data_block(struct archive_write_disk *a, const char *buff,\n 1615      size_t size)\n 1616  {\n ....\n 1620  \n 1621  static ssize_t\n 1622: _archive_write_disk_data_block(struct archive *_a,\n 1623      const void *buff, size_t size, int64_t offset)\n 1624  {\n 1625: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1626  \tssize_t r;\n 1627  \n ....\n 1650  \n 1651  static ssize_t\n 1652: _archive_write_disk_data(struct archive *_a, const void *buff, size_t size)\n 1653  {\n 1654: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1655  \n 1656  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n ....\n 1663  \n 1664  static int\n 1665: _archive_write_disk_finish_entry(struct archive *_a)\n 1666  {\n 1667: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1668  \tint ret = ARCHIVE_OK;\n 1669  \n ....\n 1884  \n 1885  int\n 1886: archive_write_disk_set_group_lookup(struct archive *_a,\n 1887      void *private_data,\n 1888      la_int64_t (*lookup_gid)(void *private, const char *gname, la_int64_t gid),\n 1889      void (*cleanup_gid)(void *private))\n 1890  {\n 1891: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1892  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n 1893  \t    ARCHIVE_STATE_ANY, \"archive_write_disk_set_group_lookup\");\n ....\n 1903  \n 1904  int\n 1905: archive_write_disk_set_user_lookup(struct archive *_a,\n 1906      void *private_data,\n 1907      int64_t (*lookup_uid)(void *private, const char *uname, int64_t uid),\n 1908      void (*cleanup_uid)(void *private))\n 1909  {\n 1910: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1911  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n 1912  \t    ARCHIVE_STATE_ANY, \"archive_write_disk_set_user_lookup\");\n ....\n 1922  \n 1923  int64_t\n 1924: archive_write_disk_gid(struct archive *_a, const char *name, la_int64_t id)\n 1925  {\n 1926:        struct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1927         archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n 1928             ARCHIVE_STATE_ANY, \"archive_write_disk_gid\");\n ....\n 1933   \n 1934  int64_t\n 1935: archive_write_disk_uid(struct archive *_a, const char *name, la_int64_t id)\n 1936  {\n 1937: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1938  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n 1939  \t    ARCHIVE_STATE_ANY, \"archive_write_disk_uid\");\n ....\n 1946   * Create a new archive_write_disk object and initialize it with global state.\n 1947   */\n 1948: struct archive *\n 1949  archive_write_disk_new(void)\n 1950  {\n 1951: \tstruct archive_write_disk *a;\n 1952  \n 1953: \ta = (struct archive_write_disk *)calloc(1, sizeof(*a));\n 1954  \tif (a == NULL)\n 1955  \t\treturn (NULL);\n ....\n 1985  #if defined(HAVE_FCHDIR) && defined(PATH_MAX)\n 1986  static void\n 1987: edit_deep_directories(struct archive_write_disk *a)\n 1988  {\n 1989  \tint ret;\n ....\n 2029   */\n 2030  static int\n 2031: restore_entry(struct archive_write_disk *a)\n 2032  {\n 2033  \tint ret = ARCHIVE_OK, en;\n ....\n 2222   */\n 2223  static int\n 2224: create_filesystem_object(struct archive_write_disk *a)\n 2225  {\n 2226  \t/* Create the entry. */\n ....\n 2230  \t/* these for check_symlinks_fsobj */\n 2231  \tchar *linkname_copy;\t/* non-const copy of linkname */\n 2232: \tstruct stat st;\n 2233: \tstruct archive_string error_string;\n 2234  \tint error_number;\n 2235  \n ....\n 2280  \t\t/*\n 2281  \t\t * Unlinking and linking here is really not atomic,\n 2282: \t\t * but doing it right, would require us to construct\n 2283  \t\t * an mktemplink() function, and then use rename(2).\n 2284  \t\t */\n ....\n 2330  \t\t/*\n 2331  \t\t * Unlinking and linking here is really not atomic,\n 2332: \t\t * but doing it right, would require us to construct\n 2333  \t\t * an mktempsymlink() function, and then use rename(2).\n 2334  \t\t */\n ....\n 2458   */\n 2459  static int\n 2460: _archive_write_disk_close(struct archive *_a)\n 2461  {\n 2462: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n 2463: \tstruct fixup_entry *next, *p;\n 2464: \tstruct stat st;\n 2465  \tchar *c;\n 2466  \tint fd, ret;\n ....\n 2564  \n 2565  static int\n 2566: _archive_write_disk_free(struct archive *_a)\n 2567  {\n 2568: \tstruct archive_write_disk *a;\n 2569  \tint ret;\n 2570  \tif (_a == NULL)\n ....\n 2572  \tarchive_check_magic(_a, ARCHIVE_WRITE_DISK_MAGIC,\n 2573  \t    ARCHIVE_STATE_ANY | ARCHIVE_STATE_FATAL, \"archive_write_disk_free\");\n 2574: \ta = (struct archive_write_disk *)_a;\n 2575  \tret = _archive_write_disk_close(&a->archive);\n 2576  \tarchive_write_disk_set_group_lookup(&a->archive, NULL, NULL, NULL);\n ....\n 2609   * particular, we want to restore dir timestamps depth-first.\n 2610   */\n 2611: static struct fixup_entry *\n 2612: sort_dir_list(struct fixup_entry *p)\n 2613  {\n 2614: \tstruct fixup_entry *a, *b, *t;\n 2615  \n 2616  \tif (p == NULL)\n ....\n 2674   *\n 2675   * TODO: Reduce the memory requirements for this list by using a tree\n 2676:  * structure rather than a simple list of names.\n 2677   */\n 2678: static struct fixup_entry *\n 2679: new_fixup(struct archive_write_disk *a, const char *pathname)\n 2680  {\n 2681: \tstruct fixup_entry *fe;\n 2682  \n 2683: \tfe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));\n 2684  \tif (fe == NULL) {\n 2685  \t\tarchive_set_error(&a->archive, ENOMEM,\n ....\n 2695  \n 2696  /*\n 2697:  * Returns a fixup structure for the current entry.\n 2698   */\n 2699: static struct fixup_entry *\n 2700: current_fixup(struct archive_write_disk *a, const char *pathname)\n 2701  {\n 2702  \tif (a->current_fixup == NULL)\n ....\n 2707  /* Error helper for new *_fsobj functions */\n 2708  static void\n 2709: fsobj_error(int *a_eno, struct archive_string *a_estr,\n 2710      int err, const char *errstr, const char *path)\n 2711  {\n ....\n 2726   */\n 2727  static int\n 2728: check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,\n 2729      int flags, int checking_linkname)\n 2730  {\n ....\n 2745  \tchar c;\n 2746  \tint r;\n 2747: \tstruct stat st;\n 2748  \tint chdir_fd;\n 2749  #if defined(HAVE_OPENAT) && defined(HAVE_FSTATAT) && defined(HAVE_UNLINKAT)\n ....\n 3039   */\n 3040  static int\n 3041: check_symlinks(struct archive_write_disk *a)\n 3042  {\n 3043: \tstruct archive_string error_string;\n 3044  \tint error_number;\n 3045  \tint rc;\n ....\n 3130   */\n 3131  static int\n 3132: cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,\n 3133      int flags)\n 3134  {\n ....\n 3228  \n 3229  static int\n 3230: cleanup_pathname(struct archive_write_disk *a)\n 3231  {\n 3232: \tstruct archive_string error_string;\n 3233  \tint error_number;\n 3234  \tint rc;\n ....\n 3249   */\n 3250  static int\n 3251: create_parent_dir(struct archive_write_disk *a, char *path)\n 3252  {\n 3253  \tchar *slash;\n ....\n 3272   */\n 3273  static int\n 3274: create_dir(struct archive_write_disk *a, char *path)\n 3275  {\n 3276: \tstruct stat st;\n 3277: \tstruct fixup_entry *le;\n 3278  \tchar *slash, *base;\n 3279  \tmode_t mode_final, mode;\n ....\n 3382   */\n 3383  static int\n 3384: set_ownership(struct archive_write_disk *a)\n 3385  {\n 3386  #if !defined(__CYGWIN__) && !defined(__linux__)\n ....\n 3444  \t * on fds and symlinks.\n 3445  \t */\n 3446: \tstruct timespec ts[2];\n 3447  \t(void)mode; /* UNUSED */\n 3448  \tts[0].tv_sec = atime;\n ....\n 3461  \t * in POSIX.\n 3462  \t */\n 3463: \tstruct timeval times[2];\n 3464  \n 3465  \ttimes[0].tv_sec = atime;\n ....\n 3488  \t * does not support fds or symlinks.\n 3489  \t */\n 3490: \tstruct utimbuf times;\n 3491  \t(void)fd; /* UNUSED */\n 3492  \t(void)name; /* UNUSED */\n ....\n 3519      time_t ctime, long ctime_nsec)\n 3520  {\n 3521: \tstruct attr_timbuf tstamp;\n 3522  \ttstamp.atime.tv_sec = atime;\n 3523  \ttstamp.mtime.tv_sec = mtime;\n ....\n 3537  \n 3538  static int\n 3539: set_times(struct archive_write_disk *a,\n 3540      int fd, int mode, const char *name,\n 3541      time_t atime, long atime_nanos,\n ....\n 3567  #ifdef HAVE_STRUCT_STAT_ST_BIRTHTIME\n 3568  \t/*\n 3569: \t * If you have struct stat.st_birthtime, we assume BSD\n 3570  \t * birthtime semantics, in which {f,l,}utimes() updates\n 3571  \t * birthtime to earliest mtime.  So we set the time twice,\n ....\n 3595  \n 3596  static int\n 3597: set_times_from_entry(struct archive_write_disk *a)\n 3598  {\n 3599  \ttime_t atime, birthtime, mtime, cctime;\n ....\n 3637  \n 3638  static int\n 3639: set_mode(struct archive_write_disk *a, int mode)\n 3640  {\n 3641  \tint r = ARCHIVE_OK;\n ....\n 3752  \n 3753  static int\n 3754: set_fflags(struct archive_write_disk *a)\n 3755  {\n 3756: \tstruct fixup_entry *le;\n 3757  \tunsigned long\tset, clear;\n 3758  \tint\t\tr;\n ....\n 3828  \n 3829  static int\n 3830: clear_nochange_fflags(struct archive_write_disk *a)\n 3831  {\n 3832  \tmode_t\t\tmode = archive_entry_mode(a->entry);\n ....\n 3862   */\n 3863  static int\n 3864: set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n 3865      mode_t mode, unsigned long set, unsigned long clear)\n 3866  {\n ....\n 3937   */\n 3938  static int\n 3939: set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n 3940      mode_t mode, unsigned long set, unsigned long clear)\n 3941  {\n ....\n 4041   */\n 4042  static int\n 4043: set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n 4044      mode_t mode, unsigned long set, unsigned long clear)\n 4045  {\n ....\n 4058  /* Default is to simply drop Mac extended metadata. */\n 4059  static int\n 4060: set_mac_metadata(struct archive_write_disk *a, const char *pathname,\n 4061  \t\t const void *metadata, size_t metadata_size)\n 4062  {\n ....\n 4069  \n 4070  static int\n 4071: fixup_appledouble(struct archive_write_disk *a, const char *pathname)\n 4072  {\n 4073  \t(void)a; /* UNUSED */\n ....\n 4084  #if defined(HAVE_SYS_XATTR_H)\n 4085  static int\n 4086: copy_xattrs(struct archive_write_disk *a, int tmpfd, int dffd)\n 4087  {\n 4088  \tssize_t xattr_size;\n ....\n 4156  \n 4157  static int\n 4158: copy_acls(struct archive_write_disk *a, int tmpfd, int dffd)\n 4159  {\n 4160  #ifndef HAVE_SYS_ACL_H\n ....\n 4192  \n 4193  static int\n 4194: create_tempdatafork(struct archive_write_disk *a, const char *pathname)\n 4195  {\n 4196: \tstruct archive_string tmpdatafork;\n 4197  \tint tmpfd;\n 4198  \n ....\n 4220  \n 4221  static int\n 4222: copy_metadata(struct archive_write_disk *a, const char *metadata,\n 4223      const char *datafork, int datafork_compressed)\n 4224  {\n ....\n 4265  \n 4266  static int\n 4267: set_mac_metadata(struct archive_write_disk *a, const char *pathname,\n 4268  \t\t const void *metadata, size_t metadata_size)\n 4269  {\n 4270: \tstruct archive_string tmp;\n 4271  \tssize_t written;\n 4272  \tint fd;\n ....\n 4312  \n 4313  static int\n 4314: fixup_appledouble(struct archive_write_disk *a, const char *pathname)\n 4315  {\n 4316  \tchar buff[8];\n 4317: \tstruct stat st;\n 4318  \tconst char *p;\n 4319: \tstruct archive_string datafork;\n 4320  \tint fd = -1, ret = ARCHIVE_OK;\n 4321  \n ....\n 4390   */\n 4391  static int\n 4392: set_xattrs(struct archive_write_disk *a)\n 4393  {\n 4394: \tstruct archive_entry *entry = a->entry;\n 4395: \tstruct archive_string errlist;\n 4396  \tint ret = ARCHIVE_OK;\n 4397  \tint i = archive_entry_xattr_reset(entry);\n ....\n 4480   */\n 4481  static int\n 4482: set_xattrs(struct archive_write_disk *a)\n 4483  {\n 4484: \tstruct archive_entry *entry = a->entry;\n 4485: \tstruct archive_string errlist;\n 4486  \tint ret = ARCHIVE_OK;\n 4487  \tint i = archive_entry_xattr_reset(entry);\n ....\n 4582   */\n 4583  static int\n 4584: set_xattrs(struct archive_write_disk *a)\n 4585  {\n 4586  \tstatic int warning_done = 0;\n ....\n 4603   */\n 4604  static int\n 4605: older(struct stat *st, struct archive_entry *entry)\n 4606  {\n 4607  \t/* First, test the seconds and return if we have a definite answer. */\n ....\n 4642  #ifndef ARCHIVE_ACL_SUPPORT\n 4643  int\n 4644: archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n 4645:     struct archive_acl *abstract_acl, __LA_MODE_T mode)\n 4646  {\n 4647  \t(void)a; /* UNUSED */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_entry_copy_bhfi.c:\n   52  \n   53  void\n   54: archive_entry_copy_bhfi(struct archive_entry *entry,\n   55  \t\t\tBY_HANDLE_FILE_INFORMATION *bhfi)\n   56  {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_shar.c:\n   45  #include \"archive_write_set_format_private.h\"\n   46  \n   47: struct shar {\n   48  \tint\t\t\t dump;\n   49  \tint\t\t\t end_of_line;\n   50: \tstruct archive_entry\t*entry;\n   51  \tint\t\t\t has_data;\n   52  \tchar\t\t\t*last_dir;\n   ..\n   57  \n   58  \tint\t\t\t wrote_header;\n   59: \tstruct archive_string\t work;\n   60: \tstruct archive_string\t quoted_name;\n   61  };\n   62  \n   63: static int\tarchive_write_shar_close(struct archive_write *);\n   64: static int\tarchive_write_shar_free(struct archive_write *);\n   65: static int\tarchive_write_shar_header(struct archive_write *,\n   66: \t\t    struct archive_entry *);\n   67: static ssize_t\tarchive_write_shar_data_sed(struct archive_write *,\n   68  \t\t    const void * buff, size_t);\n   69: static ssize_t\tarchive_write_shar_data_uuencode(struct archive_write *,\n   70  \t\t    const void * buff, size_t);\n   71: static int\tarchive_write_shar_finish_entry(struct archive_write *);\n   72  \n   73  /*\n   ..\n   76   */\n   77  static void\n   78: shar_quote(struct archive_string *buf, const char *str, int in_shell)\n   79  {\n   80  \tstatic const char meta[] = \"\\n \\t'`\\\";&<>()|*?{}[]\\\\$!#^~\";\n   ..\n  103   */\n  104  int\n  105: archive_write_set_format_shar(struct archive *_a)\n  106  {\n  107: \tstruct archive_write *a = (struct archive_write *)_a;\n  108: \tstruct shar *shar;\n  109  \n  110  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n  ...\n  115  \t\t(a->format_free)(a);\n  116  \n  117: \tshar = (struct shar *)calloc(1, sizeof(*shar));\n  118  \tif (shar == NULL) {\n  119  \t\tarchive_set_error(&a->archive, ENOMEM, \"Can't allocate shar data\");\n  ...\n  141   */\n  142  int\n  143: archive_write_set_format_shar_dump(struct archive *_a)\n  144  {\n  145: \tstruct archive_write *a = (struct archive_write *)_a;\n  146: \tstruct shar *shar;\n  147  \n  148  \tarchive_write_set_format_shar(&a->archive);\n  149: \tshar = (struct shar *)a->format_data;\n  150  \tshar->dump = 1;\n  151  \ta->format_write_data = archive_write_shar_data_uuencode;\n  ...\n  156  \n  157  static int\n  158: archive_write_shar_header(struct archive_write *a, struct archive_entry *entry)\n  159  {\n  160  \tconst char *linkname;\n  161  \tconst char *name;\n  162  \tchar *p, *pp;\n  163: \tstruct shar *shar;\n  164  \n  165: \tshar = (struct shar *)a->format_data;\n  166  \tif (!shar->wrote_header) {\n  167  \t\tarchive_strcat(&shar->work, \"#!/bin/sh\\n\");\n  ...\n  327  \n  328  static ssize_t\n  329: archive_write_shar_data_sed(struct archive_write *a, const void *buff, size_t n)\n  330  {\n  331  \tstatic const size_t ensured = 65533;\n  332: \tstruct shar *shar;\n  333  \tconst char *src;\n  334  \tchar *buf, *buf_end;\n  ...\n  336  \tsize_t written = n;\n  337  \n  338: \tshar = (struct shar *)a->format_data;\n  339  \tif (!shar->has_data || n == 0)\n  340  \t\treturn (0);\n  ...\n  409  \n  410  static int\n  411: _uuencode_line(struct archive_write *a, struct shar *shar, const char *inbuf, size_t len)\n  412  {\n  413  \tchar *buf;\n  ...\n  458  \n  459  static ssize_t\n  460: archive_write_shar_data_uuencode(struct archive_write *a, const void *buff,\n  461      size_t length)\n  462  {\n  463: \tstruct shar *shar;\n  464  \tconst char *src;\n  465  \tsize_t n;\n  466  \tint ret;\n  467  \n  468: \tshar = (struct shar *)a->format_data;\n  469  \tif (!shar->has_data)\n  470  \t\treturn (ARCHIVE_OK);\n  ...\n  508  \n  509  static int\n  510: archive_write_shar_finish_entry(struct archive_write *a)\n  511  {\n  512  \tconst char *g, *p, *u;\n  513: \tstruct shar *shar;\n  514  \tint ret;\n  515  \n  516: \tshar = (struct shar *)a->format_data;\n  517  \tif (shar->entry == NULL)\n  518  \t\treturn (0);\n  ...\n  586  \n  587  static int\n  588: archive_write_shar_close(struct archive_write *a)\n  589  {\n  590: \tstruct shar *shar;\n  591  \tint ret;\n  592  \n  ...\n  596  \t */\n  597  \n  598: \tshar = (struct shar *)a->format_data;\n  599  \n  600  \t/*\n  ...\n  624  \n  625  static int\n  626: archive_write_shar_free(struct archive_write *a)\n  627  {\n  628: \tstruct shar *shar;\n  629  \n  630: \tshar = (struct shar *)a->format_data;\n  631  \tif (shar == NULL)\n  632  \t\treturn (ARCHIVE_OK);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_ppmd8_private.h:\n   13  #define PPMD8_MAX_ORDER 16\n   14  \n   15: struct CPpmd8_Context_;\n   16  \n   17  typedef\n   18    #ifdef PPMD_32BIT\n   19:     struct CPpmd8_Context_ *\n   20    #else\n   21      UInt32\n   ..\n   25  #pragma pack(push, 1)\n   26  \n   27: typedef struct CPpmd8_Context_\n   28  {\n   29    Byte NumStats;\n   ..\n   51  };\n   52  \n   53: typedef struct\n   54  {\n   55    CPpmd8_Context *MinContext, *MaxContext;\n   ..\n   84  } CPpmd8;\n   85  \n   86: void Ppmd8_Construct(CPpmd8 *p);\n   87  Bool Ppmd8_Alloc(CPpmd8 *p, UInt32 size);\n   88  void Ppmd8_Free(CPpmd8 *p);\n   ..\n  130  void Ppmd8_EncodeSymbol(CPpmd8 *p, int symbol); /* symbol = -1 means EndMarker */\n  131  \n  132: typedef struct\n  133  {\n  134    /* Base Functions */\n  135:   void (*Ppmd8_Construct)(CPpmd8 *p);\n  136    Bool (*Ppmd8_Alloc)(CPpmd8 *p, UInt32 size);\n  137    void (*Ppmd8_Free)(CPpmd8 *p);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_disk_entry_from_file.c:\n  102  #endif\n  103  \n  104: static int setup_mac_metadata(struct archive_read_disk *,\n  105:     struct archive_entry *, int *fd);\n  106  #ifdef ARCHIVE_XATTR_FREEBSD\n  107: static int setup_xattrs_namespace(struct archive_read_disk *,\n  108:     struct archive_entry *, int *, int);\n  109  #endif\n  110: static int setup_xattrs(struct archive_read_disk *,\n  111:     struct archive_entry *, int *fd);\n  112: static int setup_sparse(struct archive_read_disk *,\n  113:     struct archive_entry *, int *fd);\n  114  #if defined(HAVE_LINUX_FIEMAP_H)\n  115: static int setup_sparse_fiemap(struct archive_read_disk *,\n  116:     struct archive_entry *, int *fd);\n  117  #endif\n  118  \n  119  #if !ARCHIVE_ACL_SUPPORT\n  120  int\n  121: archive_read_disk_entry_setup_acls(struct archive_read_disk *a,\n  122:     struct archive_entry *entry, int *fd)\n  123  {\n  124  \t(void)a;      /* UNUSED */\n  ...\n  135   */\n  136  const char *\n  137: archive_read_disk_entry_setup_path(struct archive_read_disk *a,\n  138:     struct archive_entry *entry, int *fd)\n  139  {\n  140  \tconst char *path;\n  ...\n  157  \n  158  int\n  159: archive_read_disk_entry_from_file(struct archive *_a,\n  160:     struct archive_entry *entry,\n  161      int fd,\n  162:     const struct stat *st)\n  163  {\n  164: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  165  \tconst char *path, *name;\n  166: \tstruct stat s;\n  167  \tint initial_fd = fd;\n  168  \tint r, r1;\n  ...\n  329   */\n  330  static int\n  331: setup_mac_metadata(struct archive_read_disk *a,\n  332:     struct archive_entry *entry, int *fd)\n  333  {\n  334  \tint tempfd = -1;\n  335  \tint copyfile_flags = COPYFILE_NOFOLLOW | COPYFILE_ACL | COPYFILE_XATTR;\n  336: \tstruct stat copyfile_stat;\n  337  \tint ret = ARCHIVE_OK;\n  338  \tvoid *buff = NULL;\n  339  \tint have_attrs;\n  340  \tconst char *name, *tempdir;\n  341: \tstruct archive_string tempfile;\n  342  \n  343  \t(void)fd; /* UNUSED */\n  ...\n  421   */\n  422  static int\n  423: setup_mac_metadata(struct archive_read_disk *a,\n  424:     struct archive_entry *entry, int *fd)\n  425  {\n  426  \t(void)a; /* UNUSED */\n  ...\n  446  \n  447  static int\n  448: setup_xattr(struct archive_read_disk *a,\n  449:     struct archive_entry *entry, const char *name, int fd, const char *accpath)\n  450  {\n  451  \tssize_t size;\n  ...\n  530  \n  531  static int\n  532: setup_xattrs(struct archive_read_disk *a,\n  533:     struct archive_entry *entry, int *fd)\n  534  {\n  535  \tchar *list, *p;\n  ...\n  655   */\n  656  static int\n  657: setup_xattr(struct archive_read_disk *a, struct archive_entry *entry,\n  658      int namespace, const char *name, const char *fullname, int fd,\n  659      const char *path);\n  660  \n  661  static int\n  662: setup_xattr(struct archive_read_disk *a, struct archive_entry *entry,\n  663      int namespace, const char *name, const char *fullname, int fd,\n  664      const char *accpath)\n  ...\n  706  \n  707  static int\n  708: setup_xattrs_namespace(struct archive_read_disk *a,\n  709:     struct archive_entry *entry, int *fd, int namespace)\n  710  {\n  711  \tchar buff[512];\n  ...\n  789  \n  790  static int\n  791: setup_xattrs(struct archive_read_disk *a,\n  792:     struct archive_entry *entry, int *fd)\n  793  {\n  794  \tint namespaces[2];\n  ...\n  819   */\n  820  static int\n  821: setup_xattrs(struct archive_read_disk *a,\n  822:     struct archive_entry *entry, int *fd)\n  823  {\n  824  \t(void)a;     /* UNUSED */\n  ...\n  848  \n  849  static int\n  850: setup_sparse_fiemap(struct archive_read_disk *a,\n  851:     struct archive_entry *entry, int *fd)\n  852  {\n  853  \tchar buff[4096];\n  854: \tstruct fiemap *fm;\n  855: \tstruct fiemap_extent *fe;\n  856  \tint64_t size;\n  857  \tint count, do_fiemap, iters;\n  ...\n  885  \tmemset(buff, 0, sizeof(buff));\n  886  \tcount = (sizeof(buff) - sizeof(*fm))/sizeof(*fe);\n  887: \tfm = (struct fiemap *)buff;\n  888  \tfm->fm_start = 0;\n  889  \tfm->fm_length = ~0ULL;;\n  ...\n  941  #if !defined(SEEK_HOLE) || !defined(SEEK_DATA)\n  942  static int\n  943: setup_sparse(struct archive_read_disk *a,\n  944:     struct archive_entry *entry, int *fd)\n  945  {\n  946  \treturn setup_sparse_fiemap(a, entry, fd);\n  ...\n  956  \n  957  static int\n  958: setup_sparse(struct archive_read_disk *a,\n  959:     struct archive_entry *entry, int *fd)\n  960  {\n  961  \tint64_t size;\n  ...\n 1070   */\n 1071  static int\n 1072: setup_sparse(struct archive_read_disk *a,\n 1073:     struct archive_entry *entry, int *fd)\n 1074  {\n 1075  \t(void)a;     /* UNUSED */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_ppmd7_private.h:\n   22  #define PPMD7_MAX_MEM_SIZE (0xFFFFFFFFu - 12 * 3)\n   23  \n   24: struct CPpmd7_Context_;\n   25  \n   26  typedef\n   27    #ifdef PPMD_32BIT\n   28:     struct CPpmd7_Context_ *\n   29    #else\n   30      UInt32\n   ..\n   32    CPpmd7_Context_Ref;\n   33  \n   34: typedef struct CPpmd7_Context_\n   35  {\n   36    UInt16 NumStats;\n   ..\n   42  #define Ppmd7Context_OneState(p) ((CPpmd_State *)&(p)->SummFreq)\n   43  \n   44: typedef struct\n   45  {\n   46    CPpmd7_Context *MinContext, *MaxContext;\n   ..\n   64  /* ---------- Decode ---------- */\n   65  \n   66: typedef struct\n   67  {\n   68    UInt32 (*GetThreshold)(void *p, UInt32 total);\n   ..\n   71  } IPpmd7_RangeDec;\n   72  \n   73: typedef struct\n   74  {\n   75    IPpmd7_RangeDec p;\n   ..\n   83  /* ---------- Encode ---------- */\n   84  \n   85: typedef struct\n   86  {\n   87    UInt64 Low;\n   ..\n   92  } CPpmd7z_RangeEnc;\n   93  \n   94: typedef struct\n   95  {\n   96    /* Base Functions */\n   97:   void (*Ppmd7_Construct)(CPpmd7 *p);\n   98    Bool (*Ppmd7_Alloc)(CPpmd7 *p, UInt32 size);\n   99    void (*Ppmd7_Free)(CPpmd7 *p);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/filter_fork_posix.c:\n   83  \tint r;\n   84  #endif\n   85: \tstruct archive_cmdline *cmdline;\n   86  \n   87  \tcmdline = __archive_cmdline_allocate();\n   ..\n  202  {\n  203  #if defined(HAVE_POLL) && (defined(HAVE_POLL_H) || defined(HAVE_SYS_POLL_H))\n  204: \tstruct pollfd fds[2];\n  205  \tint idx;\n  206  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_hmac_private.h:\n   56  #include <bcrypt.h>\n   57  \n   58: typedef struct {\n   59  \tBCRYPT_ALG_HANDLE\thAlg;\n   60  \tBCRYPT_HASH_HANDLE\thHash;\n   ..\n   72  #include <nettle/hmac.h>\n   73  \n   74: typedef\tstruct hmac_sha1_ctx archive_hmac_sha1_ctx;\n   75  \n   76  #elif defined(HAVE_LIBCRYPTO)\n   ..\n   97  \n   98  \n   99: struct archive_hmac {\n  100  \t/* HMAC */\n  101  \tint (*__hmac_sha1_init)(archive_hmac_sha1_ctx *, const uint8_t *,\n  ...\n  107  };\n  108  \n  109: extern const struct archive_hmac __archive_hmac;\n  110  #endif /* ARCHIVE_HMAC_PRIVATE_H_INCLUDED */\n  111  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_string_sprintf.c:\n   52   */\n   53  static void\n   54: append_uint(struct archive_string *as, uintmax_t d, unsigned base)\n   55  {\n   56  \tstatic const char digits[] = \"0123456789abcdef\";\n   ..\n   61  \n   62  static void\n   63: append_int(struct archive_string *as, intmax_t d, unsigned base)\n   64  {\n   65  \tuintmax_t ud;\n   ..\n   75  \n   76  void\n   77: archive_string_sprintf(struct archive_string *as, const char *fmt, ...)\n   78  {\n   79  \tva_list ap;\n   ..\n   89   */\n   90  void\n   91: archive_string_vsprintf(struct archive_string *as, const char *fmt,\n   92      va_list ap)\n   93  {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_all.c:\n   31  \n   32  int\n   33: archive_read_support_format_all(struct archive *a)\n   34  {\n   35  \tarchive_check_magic(a, ARCHIVE_READ_MAGIC,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_ar.c:\n   45  #include \"archive_write_set_format_private.h\"\n   46  \n   47: struct ar_w {\n   48  \tuint64_t\t entry_bytes_remaining;\n   49  \tuint64_t\t entry_padding;\n   ..\n   55  \n   56  /*\n   57:  * Define structure of the \"ar\" header.\n   58   */\n   59  #define AR_name_offset 0\n   ..\n   72  #define AR_fmag_size 2\n   73  \n   74: static int\t\t archive_write_set_format_ar(struct archive_write *);\n   75: static int\t\t archive_write_ar_header(struct archive_write *,\n   76: \t\t\t     struct archive_entry *);\n   77: static ssize_t\t\t archive_write_ar_data(struct archive_write *,\n   78  \t\t\t     const void *buff, size_t s);\n   79: static int\t\t archive_write_ar_free(struct archive_write *);\n   80: static int\t\t archive_write_ar_close(struct archive_write *);\n   81: static int\t\t archive_write_ar_finish_entry(struct archive_write *);\n   82  static const char\t*ar_basename(const char *path);\n   83  static int\t\t format_octal(int64_t v, char *p, int s);\n   ..\n   85  \n   86  int\n   87: archive_write_set_format_ar_bsd(struct archive *_a)\n   88  {\n   89: \tstruct archive_write *a = (struct archive_write *)_a;\n   90  \tint r;\n   91  \n   ..\n  101  \n  102  int\n  103: archive_write_set_format_ar_svr4(struct archive *_a)\n  104  {\n  105: \tstruct archive_write *a = (struct archive_write *)_a;\n  106  \tint r;\n  107  \n  ...\n  120   */\n  121  static int\n  122: archive_write_set_format_ar(struct archive_write *a)\n  123  {\n  124: \tstruct ar_w *ar;\n  125  \n  126  \t/* If someone else was already registered, unregister them. */\n  ...\n  128  \t\t(a->format_free)(a);\n  129  \n  130: \tar = (struct ar_w *)calloc(1, sizeof(*ar));\n  131  \tif (ar == NULL) {\n  132  \t\tarchive_set_error(&a->archive, ENOMEM, \"Can't allocate ar data\");\n  ...\n  145  \n  146  static int\n  147: archive_write_ar_header(struct archive_write *a, struct archive_entry *entry)\n  148  {\n  149  \tint ret, append_fn;\n  150  \tchar buff[60];\n  151  \tchar *ss, *se;\n  152: \tstruct ar_w *ar;\n  153  \tconst char *pathname;\n  154  \tconst char *filename;\n  ...\n  156  \n  157  \tappend_fn = 0;\n  158: \tar = (struct ar_w *)a->format_data;\n  159  \tar->is_strtab = 0;\n  160  \tfilename = NULL;\n  ...\n  365  \n  366  static ssize_t\n  367: archive_write_ar_data(struct archive_write *a, const void *buff, size_t s)\n  368  {\n  369: \tstruct ar_w *ar;\n  370  \tint ret;\n  371  \n  372: \tar = (struct ar_w *)a->format_data;\n  373  \tif (s > ar->entry_bytes_remaining)\n  374  \t\ts = (size_t)ar->entry_bytes_remaining;\n  ...\n  401  \n  402  static int\n  403: archive_write_ar_free(struct archive_write *a)\n  404  {\n  405: \tstruct ar_w *ar;\n  406  \n  407: \tar = (struct ar_w *)a->format_data;\n  408  \n  409  \tif (ar == NULL)\n  ...\n  421  \n  422  static int\n  423: archive_write_ar_close(struct archive_write *a)\n  424  {\n  425: \tstruct ar_w *ar;\n  426  \tint ret;\n  427  \n  ...\n  430  \t * the ar global header now to make it a valid ar archive.\n  431  \t */\n  432: \tar = (struct ar_w *)a->format_data;\n  433  \tif (!ar->wrote_global_header) {\n  434  \t\tar->wrote_global_header = 1;\n  ...\n  441  \n  442  static int\n  443: archive_write_ar_finish_entry(struct archive_write *a)\n  444  {\n  445: \tstruct ar_w *ar;\n  446  \tint ret;\n  447  \n  448: \tar = (struct ar_w *)a->format_data;\n  449  \n  450  \tif (ar->entry_bytes_remaining != 0) {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_acl.c:\n   50  #endif\n   51  \n   52: static int\tacl_special(struct archive_acl *acl,\n   53  \t\t    int type, int permset, int tag);\n   54: static struct archive_acl_entry *acl_new_entry(struct archive_acl *acl,\n   55  \t\t    int type, int permset, int tag, int id);\n   56: static int\tarchive_acl_add_entry_len_l(struct archive_acl *acl,\n   57  \t\t    int type, int permset, int tag, int id, const char *name,\n   58: \t\t    size_t len, struct archive_string_conv *sc);\n   59: static int\tarchive_acl_text_want_type(struct archive_acl *acl, int flags);\n   60: static ssize_t\tarchive_acl_text_len(struct archive_acl *acl, int want_type,\n   61: \t\t    int flags, int wide, struct archive *a,\n   62: \t\t    struct archive_string_conv *sc);\n   63  static int\tisint_w(const wchar_t *start, const wchar_t *end, int *result);\n   64  static int\tismode_w(const wchar_t *start, const wchar_t *end, int *result);\n   ..\n   84  static void\tappend_id(char **p, int id);\n   85  \n   86: static const struct {\n   87  \tconst int perm;\n   88  \tconst char c;\n   ..\n  111      sizeof(nfsv4_acl_perm_map[0]));\n  112  \n  113: static const struct {\n  114  \tconst int perm;\n  115  \tconst char c;\n  ...\n  129  \n  130  void\n  131: archive_acl_clear(struct archive_acl *acl)\n  132  {\n  133: \tstruct archive_acl_entry *ap;\n  134  \n  135  \twhile (acl->acl_head != NULL) {\n  ...\n  149  \n  150  void\n  151: archive_acl_copy(struct archive_acl *dest, struct archive_acl *src)\n  152  {\n  153: \tstruct archive_acl_entry *ap, *ap2;\n  154  \n  155  \tarchive_acl_clear(dest);\n  ...\n  167  \n  168  int\n  169: archive_acl_add_entry(struct archive_acl *acl,\n  170      int type, int permset, int tag, int id, const char *name)\n  171  {\n  172: \tstruct archive_acl_entry *ap;\n  173  \n  174  \tif (acl_special(acl, type, permset, tag) == 0)\n  ...\n  187  \n  188  int\n  189: archive_acl_add_entry_w_len(struct archive_acl *acl,\n  190      int type, int permset, int tag, int id, const wchar_t *name, size_t len)\n  191  {\n  192: \tstruct archive_acl_entry *ap;\n  193  \n  194  \tif (acl_special(acl, type, permset, tag) == 0)\n  ...\n  207  \n  208  static int\n  209: archive_acl_add_entry_len_l(struct archive_acl *acl,\n  210      int type, int permset, int tag, int id, const char *name, size_t len,\n  211:     struct archive_string_conv *sc)\n  212  {\n  213: \tstruct archive_acl_entry *ap;\n  214  \tint r;\n  215  \n  ...\n  237  /*\n  238   * If this ACL entry is part of the standard POSIX permissions set,\n  239:  * store the permissions in the stat structure and return zero.\n  240   */\n  241  static int\n  242: acl_special(struct archive_acl *acl, int type, int permset, int tag)\n  243  {\n  244  \tif (type == ARCHIVE_ENTRY_ACL_TYPE_ACCESS\n  ...\n  266   * name.\n  267   */\n  268: static struct archive_acl_entry *\n  269: acl_new_entry(struct archive_acl *acl,\n  270      int type, int permset, int tag, int id)\n  271  {\n  272: \tstruct archive_acl_entry *ap, *aq;\n  273  \n  274  \t/* Type argument must be a valid NFS4 or POSIX.1e type.\n  ...\n  348  \n  349  \t/* Add a new entry to the end of the list. */\n  350: \tap = (struct archive_acl_entry *)calloc(1, sizeof(*ap));\n  351  \tif (ap == NULL)\n  352  \t\treturn (NULL);\n  ...\n  367   */\n  368  int\n  369: archive_acl_count(struct archive_acl *acl, int want_type)\n  370  {\n  371  \tint count;\n  372: \tstruct archive_acl_entry *ap;\n  373  \n  374  \tcount = 0;\n  ...\n  389   */\n  390  int\n  391: archive_acl_types(struct archive_acl *acl)\n  392  {\n  393  \treturn (acl->acl_types);\n  ...\n  400   */\n  401  int\n  402: archive_acl_reset(struct archive_acl *acl, int want_type)\n  403  {\n  404  \tint count, cutoff;\n  ...\n  430   */\n  431  int\n  432: archive_acl_next(struct archive *a, struct archive_acl *acl, int want_type,\n  433      int *type, int *permset, int *tag, int *id, const char **name)\n  434  {\n  ...\n  499   */\n  500  static int\n  501: archive_acl_text_want_type(struct archive_acl *acl, int flags)\n  502  {\n  503  \tint want_type;\n  ...\n  531   */\n  532  static ssize_t\n  533: archive_acl_text_len(struct archive_acl *acl, int want_type, int flags,\n  534:     int wide, struct archive *a, struct archive_string_conv *sc) {\n  535: \tstruct archive_acl_entry *ap;\n  536  \tconst char *name;\n  537  \tconst wchar_t *wname;\n  ...\n  662   */\n  663  wchar_t *\n  664: archive_acl_to_text_w(struct archive_acl *acl, ssize_t *text_len, int flags,\n  665:     struct archive *a)\n  666  {\n  667  \tint count;\n  ...\n  671  \tconst wchar_t *prefix;\n  672  \twchar_t separator;\n  673: \tstruct archive_acl_entry *ap;\n  674  \tint id, r, want_type;\n  675  \twchar_t *wp, *ws;\n  ...\n  895   */\n  896  char *\n  897: archive_acl_to_text_l(struct archive_acl *acl, ssize_t *text_len, int flags,\n  898:     struct archive_string_conv *sc)\n  899  {\n  900  \tint count;\n  ...\n  904  \tconst char *prefix;\n  905  \tchar separator;\n  906: \tstruct archive_acl_entry *ap;\n  907  \tint id, r, want_type;\n  908  \tchar *p, *s;\n  ...\n 1135   */\n 1136  int\n 1137: archive_acl_from_text_w(struct archive_acl *acl, const wchar_t *text,\n 1138      int want_type)\n 1139  {\n 1140: \tstruct {\n 1141  \t\tconst wchar_t *start;\n 1142  \t\tconst wchar_t *end;\n ....\n 1619   */\n 1620  int\n 1621: archive_acl_from_text_l(struct archive_acl *acl, const char *text,\n 1622:     int want_type, struct archive_string_conv *sc)\n 1623  {\n 1624: \tstruct {\n 1625  \t\tconst char *start;\n 1626  \t\tconst char *end;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_string.c:\n   79  #define max(a, b)       ((a)>(b)?(a):(b))\n   80  \n   81: struct archive_string_conv {\n   82: \tstruct archive_string_conv\t*next;\n   83  \tchar\t\t\t\t*from_charset;\n   84  \tchar\t\t\t\t*to_charset;\n   ..\n  119  #endif\n  120  \t/* A temporary buffer for normalization. */\n  121: \tstruct archive_string\t\t utftmp;\n  122: \tint (*converter[2])(struct archive_string *, const void *, size_t,\n  123: \t    struct archive_string_conv *);\n  124  \tint\t\t\t\t nconverter;\n  125  };\n  ...\n  137  static const char utf8_replacement_char[] = {0xef, 0xbf, 0xbd};\n  138  \n  139: static struct archive_string_conv *find_sconv_object(struct archive *,\n  140  \tconst char *, const char *);\n  141: static void add_sconv_object(struct archive *, struct archive_string_conv *);\n  142: static struct archive_string_conv *create_sconv_object(const char *,\n  143  \tconst char *, unsigned, int);\n  144: static void free_sconv_object(struct archive_string_conv *);\n  145: static struct archive_string_conv *get_sconv_object(struct archive *,\n  146  \tconst char *, const char *, int);\n  147  static unsigned make_codepage_from_charset(const char *);\n  ...\n  152  #if defined(_WIN32) && !defined(__CYGWIN__)\n  153  static int archive_wstring_append_from_mbs_in_codepage(\n  154:     struct archive_wstring *, const char *, size_t,\n  155:     struct archive_string_conv *);\n  156: static int archive_string_append_from_wcs_in_codepage(struct archive_string *,\n  157:     const wchar_t *, size_t, struct archive_string_conv *);\n  158  static int is_big_endian(void);\n  159: static int strncat_in_codepage(struct archive_string *, const void *,\n  160:     size_t, struct archive_string_conv *);\n  161: static int win_strncat_from_utf16be(struct archive_string *, const void *,\n  162:     size_t, struct archive_string_conv *);\n  163: static int win_strncat_from_utf16le(struct archive_string *, const void *,\n  164:     size_t, struct archive_string_conv *);\n  165: static int win_strncat_to_utf16be(struct archive_string *, const void *,\n  166:     size_t, struct archive_string_conv *);\n  167: static int win_strncat_to_utf16le(struct archive_string *, const void *,\n  168:     size_t, struct archive_string_conv *);\n  169  #endif\n  170: static int best_effort_strncat_from_utf16be(struct archive_string *,\n  171:     const void *, size_t, struct archive_string_conv *);\n  172: static int best_effort_strncat_from_utf16le(struct archive_string *,\n  173:     const void *, size_t, struct archive_string_conv *);\n  174: static int best_effort_strncat_to_utf16be(struct archive_string *,\n  175:     const void *, size_t, struct archive_string_conv *);\n  176: static int best_effort_strncat_to_utf16le(struct archive_string *,\n  177:     const void *, size_t, struct archive_string_conv *);\n  178  #if defined(HAVE_ICONV)\n  179: static int iconv_strncat_in_locale(struct archive_string *, const void *,\n  180:     size_t, struct archive_string_conv *);\n  181  #endif\n  182: static int best_effort_strncat_in_locale(struct archive_string *,\n  183:     const void *, size_t, struct archive_string_conv *);\n  184  static int _utf8_to_unicode(uint32_t *, const char *, size_t);\n  185  static int utf8_to_unicode(uint32_t *, const char *, size_t);\n  ...\n  190  static size_t unicode_to_utf16be(char *, size_t, uint32_t);\n  191  static size_t unicode_to_utf16le(char *, size_t, uint32_t);\n  192: static int strncat_from_utf8_libarchive2(struct archive_string *,\n  193:     const void *, size_t, struct archive_string_conv *);\n  194: static int strncat_from_utf8_to_utf8(struct archive_string *, const void *,\n  195:     size_t, struct archive_string_conv *);\n  196: static int archive_string_normalize_C(struct archive_string *, const void *,\n  197:     size_t, struct archive_string_conv *);\n  198: static int archive_string_normalize_D(struct archive_string *, const void *,\n  199:     size_t, struct archive_string_conv *);\n  200: static int archive_string_append_unicode(struct archive_string *,\n  201:     const void *, size_t, struct archive_string_conv *);\n  202  \n  203: static struct archive_string *\n  204: archive_string_append(struct archive_string *as, const char *p, size_t s)\n  205  {\n  206  \tif (archive_string_ensure(as, as->length + s + 1) == NULL)\n  ...\n  213  }\n  214  \n  215: static struct archive_wstring *\n  216: archive_wstring_append(struct archive_wstring *as, const wchar_t *p, size_t s)\n  217  {\n  218  \tif (archive_wstring_ensure(as, as->length + s + 1) == NULL)\n  ...\n  225  }\n  226  \n  227: struct archive_string *\n  228: archive_array_append(struct archive_string *as, const char *p, size_t s)\n  229  {\n  230  \treturn archive_string_append(as, p, s);\n  ...\n  232  \n  233  void\n  234: archive_string_concat(struct archive_string *dest, struct archive_string *src)\n  235  {\n  236  \tif (archive_string_append(dest, src->s, src->length) == NULL)\n  ...\n  239  \n  240  void\n  241: archive_wstring_concat(struct archive_wstring *dest,\n  242:     struct archive_wstring *src)\n  243  {\n  244  \tif (archive_wstring_append(dest, src->s, src->length) == NULL)\n  ...\n  247  \n  248  void\n  249: archive_string_free(struct archive_string *as)\n  250  {\n  251  \tas->length = 0;\n  ...\n  256  \n  257  void\n  258: archive_wstring_free(struct archive_wstring *as)\n  259  {\n  260  \tas->length = 0;\n  ...\n  264  }\n  265  \n  266: struct archive_wstring *\n  267: archive_wstring_ensure(struct archive_wstring *as, size_t s)\n  268  {\n  269: \treturn (struct archive_wstring *)\n  270: \t\tarchive_string_ensure((struct archive_string *)as,\n  271  \t\t\t\t\ts * sizeof(wchar_t));\n  272  }\n  273  \n  274  /* Returns NULL on any allocation failure. */\n  275: struct archive_string *\n  276: archive_string_ensure(struct archive_string *as, size_t s)\n  277  {\n  278  \tchar *p;\n  ...\n  335   * such an optimization might not help).\n  336   */\n  337: struct archive_string *\n  338: archive_strncat(struct archive_string *as, const void *_p, size_t n)\n  339  {\n  340  \tsize_t s;\n  ...\n  355  }\n  356  \n  357: struct archive_wstring *\n  358: archive_wstrncat(struct archive_wstring *as, const wchar_t *p, size_t n)\n  359  {\n  360  \tsize_t s;\n  ...\n  373  }\n  374  \n  375: struct archive_string *\n  376: archive_strcat(struct archive_string *as, const void *p)\n  377  {\n  378  \t/* strcat is just strncat without an effective limit. \n  ...\n  385  }\n  386  \n  387: struct archive_wstring *\n  388: archive_wstrcat(struct archive_wstring *as, const wchar_t *p)\n  389  {\n  390  \t/* Ditto. */\n  ...\n  392  }\n  393  \n  394: struct archive_string *\n  395: archive_strappend_char(struct archive_string *as, char c)\n  396  {\n  397  \tif ((as = archive_string_append(as, &c, 1)) == NULL)\n  ...\n  400  }\n  401  \n  402: struct archive_wstring *\n  403: archive_wstrappend_wchar(struct archive_wstring *as, wchar_t c)\n  404  {\n  405  \tif ((as = archive_wstring_append(as, &c, 1)) == NULL)\n  ...\n  442   */\n  443  int\n  444: archive_wstring_append_from_mbs(struct archive_wstring *dest,\n  445      const char *p, size_t len)\n  446  {\n  ...\n  449  \n  450  static int\n  451: archive_wstring_append_from_mbs_in_codepage(struct archive_wstring *dest,\n  452:     const char *s, size_t length, struct archive_string_conv *sc)\n  453  {\n  454  \tint count, ret = 0;\n  ...\n  484  \t\t * to UTF-16 as wchar_t.\n  485  \t\t */\n  486: \t\tstruct archive_string u16;\n  487  \t\tint saved_flag = sc->flag;/* save current flag. */\n  488  \n  ...\n  586   */\n  587  int\n  588: archive_wstring_append_from_mbs(struct archive_wstring *dest,\n  589      const char *p, size_t len)\n  590  {\n  ...\n  668   */\n  669  int\n  670: archive_string_append_from_wcs(struct archive_string *as,\n  671      const wchar_t *w, size_t len)\n  672  {\n  ...\n  675  \n  676  static int\n  677: archive_string_append_from_wcs_in_codepage(struct archive_string *as,\n  678:     const wchar_t *ws, size_t len, struct archive_string_conv *sc)\n  679  {\n  680  \tBOOL defchar_used, *dp;\n  ...\n  773   */\n  774  int\n  775: archive_string_append_from_wcs(struct archive_string *as,\n  776      const wchar_t *w, size_t len)\n  777  {\n  ...\n  847   */\n  848  int\n  849: archive_string_append_from_wcs(struct archive_string *as,\n  850      const wchar_t *w, size_t len)\n  851  {\n  ...\n  864   * Return NULL if not found.\n  865   */\n  866: static struct archive_string_conv *\n  867: find_sconv_object(struct archive *a, const char *fc, const char *tc)\n  868  {\n  869: \tstruct archive_string_conv *sc; \n  870  \n  871  \tif (a == NULL)\n  ...\n  884   */\n  885  static void\n  886: add_sconv_object(struct archive *a, struct archive_string_conv *sc)\n  887  {\n  888: \tstruct archive_string_conv **psc; \n  889  \n  890  \t/* Add a new sconv to sconv list. */\n  ...\n  896  \n  897  static void\n  898: add_converter(struct archive_string_conv *sc, int (*converter)\n  899:     (struct archive_string *, const void *, size_t,\n  900:      struct archive_string_conv *))\n  901  {\n  902  \tif (sc == NULL || sc->nconverter >= 2)\n  ...\n  906  \n  907  static void\n  908: setup_converter(struct archive_string_conv *sc)\n  909  {\n  910  \n  ...\n 1124   * Create a string conversion object.\n 1125   */\n 1126: static struct archive_string_conv *\n 1127  create_sconv_object(const char *fc, const char *tc,\n 1128      unsigned current_codepage, int flag)\n 1129  {\n 1130: \tstruct archive_string_conv *sc; \n 1131  \n 1132  \tsc = calloc(1, sizeof(*sc));\n ....\n 1310   */\n 1311  static void\n 1312: free_sconv_object(struct archive_string_conv *sc)\n 1313  {\n 1314  \tfree(sc->from_charset);\n ....\n 1347   * Note: This translation code may be insufficient.\n 1348   */\n 1349: static struct charset {\n 1350  \tconst char *name;\n 1351  \tunsigned cp;\n ....\n 1535   * Translation table between Locale Name and ACP/OEMCP.\n 1536   */\n 1537: static struct {\n 1538  \tunsigned acp;\n 1539  \tunsigned ocp;\n ....\n 1638   * Return a string conversion object.\n 1639   */\n 1640: static struct archive_string_conv *\n 1641: get_sconv_object(struct archive *a, const char *fc, const char *tc, int flag)\n 1642  {\n 1643: \tstruct archive_string_conv *sc;\n 1644  \tunsigned current_codepage;\n 1645  \n ....\n 1694  \n 1695  static const char *\n 1696: get_current_charset(struct archive *a)\n 1697  {\n 1698  \tconst char *cur_charset;\n ....\n 1719   * might fail when non-ASCII code is found.\n 1720   */\n 1721: struct archive_string_conv *\n 1722: archive_string_conversion_to_charset(struct archive *a, const char *charset,\n 1723      int best_effort)\n 1724  {\n ....\n 1730  }\n 1731  \n 1732: struct archive_string_conv *\n 1733: archive_string_conversion_from_charset(struct archive *a, const char *charset,\n 1734      int best_effort)\n 1735  {\n ....\n 1751   */\n 1752  #if defined(_WIN32) && !defined(__CYGWIN__)\n 1753: struct archive_string_conv *\n 1754: archive_string_default_conversion_for_read(struct archive *a)\n 1755  {\n 1756  \tconst char *cur_charset = get_current_charset(a);\n ....\n 1772  }\n 1773  \n 1774: struct archive_string_conv *\n 1775: archive_string_default_conversion_for_write(struct archive *a)\n 1776  {\n 1777  \tconst char *cur_charset = get_current_charset(a);\n ....\n 1793  }\n 1794  #else\n 1795: struct archive_string_conv *\n 1796: archive_string_default_conversion_for_read(struct archive *a)\n 1797  {\n 1798  \t(void)a; /* UNUSED */\n ....\n 1800  }\n 1801  \n 1802: struct archive_string_conv *\n 1803: archive_string_default_conversion_for_write(struct archive *a)\n 1804  {\n 1805  \t(void)a; /* UNUSED */\n ....\n 1812   */\n 1813  void\n 1814: archive_string_conversion_free(struct archive *a)\n 1815  {\n 1816: \tstruct archive_string_conv *sc; \n 1817: \tstruct archive_string_conv *sc_next; \n 1818  \n 1819  \tfor (sc = a->sconv; sc != NULL; sc = sc_next) {\n ....\n 1830   */\n 1831  const char *\n 1832: archive_string_conversion_charset_name(struct archive_string_conv *sc)\n 1833  {\n 1834  \tif (sc->flag & SCONV_TO_CHARSET)\n ....\n 1842   */\n 1843  void\n 1844: archive_string_conversion_set_opt(struct archive_string_conv *sc, int opt)\n 1845  {\n 1846  \tswitch (opt) {\n ....\n 1949  \n 1950  int\n 1951: archive_strncpy_l(struct archive_string *as, const void *_p, size_t n,\n 1952:     struct archive_string_conv *sc)\n 1953  {\n 1954  \tas->length = 0;\n ....\n 1957  \n 1958  int\n 1959: archive_strncat_l(struct archive_string *as, const void *_p, size_t n,\n 1960:     struct archive_string_conv *sc)\n 1961  {\n 1962  \tconst void *s;\n ....\n 2019   */\n 2020  static int\n 2021: iconv_strncat_in_locale(struct archive_string *as, const void *_p,\n 2022:     size_t length, struct archive_string_conv *sc)\n 2023  {\n 2024  \tICONV_CONST char *itp;\n ....\n 2121   */\n 2122  static int\n 2123: strncat_in_codepage(struct archive_string *as,\n 2124:     const void *_p, size_t length, struct archive_string_conv *sc)\n 2125  {\n 2126  \tconst char *s = (const char *)_p;\n 2127: \tstruct archive_wstring aws;\n 2128  \tsize_t l;\n 2129  \tint r, saved_flag;\n ....\n 2154   */\n 2155  static int\n 2156: invalid_mbs(const void *_p, size_t n, struct archive_string_conv *sc)\n 2157  {\n 2158  \tconst char *p = (const char *)_p;\n ....\n 2181   */\n 2182  static int\n 2183: invalid_mbs(const void *_p, size_t n, struct archive_string_conv *sc)\n 2184  {\n 2185  \tconst char *p = (const char *)_p;\n ....\n 2223   */\n 2224  static int\n 2225: best_effort_strncat_in_locale(struct archive_string *as, const void *_p,\n 2226:     size_t length, struct archive_string_conv *sc)\n 2227  {\n 2228  \tsize_t remaining;\n ....\n 2640   */\n 2641  static int\n 2642: strncat_from_utf8_to_utf8(struct archive_string *as, const void *_p,\n 2643:     size_t len, struct archive_string_conv *sc)\n 2644  {\n 2645  \tconst char *s;\n ....\n 2714  \n 2715  static int\n 2716: archive_string_append_unicode(struct archive_string *as, const void *_p,\n 2717:     size_t len, struct archive_string_conv *sc)\n 2718  {\n 2719  \tconst char *s;\n ....\n 2929   */\n 2930  static int\n 2931: archive_string_normalize_C(struct archive_string *as, const void *_p,\n 2932:     size_t len, struct archive_string_conv *sc)\n 2933  {\n 2934  \tconst char *s = (const char *)_p;\n ....\n 3236   */\n 3237  static int\n 3238: archive_string_normalize_D(struct archive_string *as, const void *_p,\n 3239:     size_t len, struct archive_string_conv *sc)\n 3240  {\n 3241  \tconst char *s = (const char *)_p;\n ....\n 3303  \t\tuint32_t cp1, cp2;\n 3304  \t\tint SIndex;\n 3305: \t\tstruct {\n 3306  \t\t\tuint32_t uc;\n 3307  \t\t\tint ccc;\n ....\n 3417   */\n 3418  static int\n 3419: strncat_from_utf8_libarchive2(struct archive_string *as,\n 3420:     const void *_p, size_t len, struct archive_string_conv *sc)\n 3421  {\n 3422  \tconst char *s;\n ....\n 3502   */\n 3503  static int\n 3504: win_strncat_from_utf16(struct archive_string *as, const void *_p, size_t bytes,\n 3505:     struct archive_string_conv *sc, int be)\n 3506  {\n 3507: \tstruct archive_string tmp;\n 3508  \tconst char *u16;\n 3509  \tint ll;\n ....\n 3600  \n 3601  static int\n 3602: win_strncat_from_utf16be(struct archive_string *as, const void *_p,\n 3603:     size_t bytes, struct archive_string_conv *sc)\n 3604  {\n 3605  \treturn (win_strncat_from_utf16(as, _p, bytes, sc, 1));\n ....\n 3607  \n 3608  static int\n 3609: win_strncat_from_utf16le(struct archive_string *as, const void *_p,\n 3610:     size_t bytes, struct archive_string_conv *sc)\n 3611  {\n 3612  \treturn (win_strncat_from_utf16(as, _p, bytes, sc, 0));\n ....\n 3626   */\n 3627  static int\n 3628: win_strncat_to_utf16(struct archive_string *as16, const void *_p,\n 3629:     size_t length, struct archive_string_conv *sc, int bigendian)\n 3630  {\n 3631  \tconst char *s = (const char *)_p;\n ....\n 3704  \n 3705  static int\n 3706: win_strncat_to_utf16be(struct archive_string *as16, const void *_p,\n 3707:     size_t length, struct archive_string_conv *sc)\n 3708  {\n 3709  \treturn (win_strncat_to_utf16(as16, _p, length, sc, 1));\n ....\n 3711  \n 3712  static int\n 3713: win_strncat_to_utf16le(struct archive_string *as16, const void *_p,\n 3714:     size_t length, struct archive_string_conv *sc)\n 3715  {\n 3716  \treturn (win_strncat_to_utf16(as16, _p, length, sc, 0));\n ....\n 3731   */\n 3732  static int\n 3733: best_effort_strncat_from_utf16(struct archive_string *as, const void *_p,\n 3734:     size_t bytes, struct archive_string_conv *sc, int be)\n 3735  {\n 3736  \tconst char *utf16 = (const char *)_p;\n ....\n 3771  \n 3772  static int\n 3773: best_effort_strncat_from_utf16be(struct archive_string *as, const void *_p,\n 3774:     size_t bytes, struct archive_string_conv *sc)\n 3775  {\n 3776  \treturn (best_effort_strncat_from_utf16(as, _p, bytes, sc, 1));\n ....\n 3778  \n 3779  static int\n 3780: best_effort_strncat_from_utf16le(struct archive_string *as, const void *_p,\n 3781:     size_t bytes, struct archive_string_conv *sc)\n 3782  {\n 3783  \treturn (best_effort_strncat_from_utf16(as, _p, bytes, sc, 0));\n ....\n 3789   */\n 3790  static int\n 3791: best_effort_strncat_to_utf16(struct archive_string *as16, const void *_p,\n 3792:     size_t length, struct archive_string_conv *sc, int bigendian)\n 3793  {\n 3794  \tconst char *s = (const char *)_p;\n ....\n 3831  \n 3832  static int\n 3833: best_effort_strncat_to_utf16be(struct archive_string *as16, const void *_p,\n 3834:     size_t length, struct archive_string_conv *sc)\n 3835  {\n 3836  \treturn (best_effort_strncat_to_utf16(as16, _p, length, sc, 1));\n ....\n 3838  \n 3839  static int\n 3840: best_effort_strncat_to_utf16le(struct archive_string *as16, const void *_p,\n 3841:     size_t length, struct archive_string_conv *sc)\n 3842  {\n 3843  \treturn (best_effort_strncat_to_utf16(as16, _p, length, sc, 0));\n ....\n 3850  \n 3851  void\n 3852: archive_mstring_clean(struct archive_mstring *aes)\n 3853  {\n 3854  \tarchive_wstring_free(&(aes->aes_wcs));\n ....\n 3860  \n 3861  void\n 3862: archive_mstring_copy(struct archive_mstring *dest, struct archive_mstring *src)\n 3863  {\n 3864  \tdest->aes_set = src->aes_set;\n ....\n 3869  \n 3870  int\n 3871: archive_mstring_get_utf8(struct archive *a, struct archive_mstring *aes,\n 3872    const char **p)\n 3873  {\n 3874: \tstruct archive_string_conv *sc;\n 3875  \tint r;\n 3876  \n ....\n 3906  \n 3907  int\n 3908: archive_mstring_get_mbs(struct archive *a, struct archive_mstring *aes,\n 3909      const char **p)\n 3910  {\n 3911: \tstruct archive_string_conv *sc;\n 3912  \tint r, ret = 0;\n 3913  \n ....\n 3953  \n 3954  int\n 3955: archive_mstring_get_wcs(struct archive *a, struct archive_mstring *aes,\n 3956      const wchar_t **wp)\n 3957  {\n ....\n 3986  \n 3987  int\n 3988: archive_mstring_get_mbs_l(struct archive *a, struct archive_mstring *aes,\n 3989:     const char **p, size_t *length, struct archive_string_conv *sc)\n 3990  {\n 3991  \tint r, ret = 0;\n ....\n 4045  \n 4046  int\n 4047: archive_mstring_copy_mbs(struct archive_mstring *aes, const char *mbs)\n 4048  {\n 4049  \tif (mbs == NULL) {\n ....\n 4055  \n 4056  int\n 4057: archive_mstring_copy_mbs_len(struct archive_mstring *aes, const char *mbs,\n 4058      size_t len)\n 4059  {\n ....\n 4070  \n 4071  int\n 4072: archive_mstring_copy_wcs(struct archive_mstring *aes, const wchar_t *wcs)\n 4073  {\n 4074  \treturn archive_mstring_copy_wcs_len(aes, wcs,\n ....\n 4077  \n 4078  int\n 4079: archive_mstring_copy_utf8(struct archive_mstring *aes, const char *utf8)\n 4080  {\n 4081    if (utf8 == NULL) {\n ....\n 4091  \n 4092  int\n 4093: archive_mstring_copy_wcs_len(struct archive_mstring *aes, const wchar_t *wcs,\n 4094      size_t len)\n 4095  {\n ....\n 4106  \n 4107  int\n 4108: archive_mstring_copy_mbs_len_l(struct archive_mstring *aes,\n 4109:     const char *mbs, size_t len, struct archive_string_conv *sc)\n 4110  {\n 4111  \tint r;\n ....\n 4199   */\n 4200  int\n 4201: archive_mstring_update_utf8(struct archive *a, struct archive_mstring *aes,\n 4202      const char *utf8)\n 4203  {\n 4204: \tstruct archive_string_conv *sc;\n 4205  \tint r;\n 4206  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_version_details.c:\n   57  archive_version_details(void)\n   58  {\n   59: \tstatic struct archive_string str;\n   60  \tstatic int init = 0;\n   61  \tconst char *zlib = archive_zlib_version();\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_lzop.c:\n   71  \n   72  #if defined(HAVE_LZO_LZOCONF_H) && defined(HAVE_LZO_LZO1X_H)\n   73: struct read_lzop {\n   74  \tunsigned char\t*out_block;\n   75  \tsize_t\t\t out_block_size;\n   ..\n   94  #define MAX_BLOCK_SIZE\t\t(64 * 1024 * 1024)\n   95  \n   96: static ssize_t  lzop_filter_read(struct archive_read_filter *, const void **);\n   97: static int\tlzop_filter_close(struct archive_read_filter *);\n   98  #endif\n   99  \n  100: static int lzop_bidder_bid(struct archive_read_filter_bidder *,\n  101:     struct archive_read_filter *);\n  102: static int lzop_bidder_init(struct archive_read_filter *);\n  103  \n  104  int\n  105: archive_read_support_filter_lzop(struct archive *_a)\n  106  {\n  107: \tstruct archive_read *a = (struct archive_read *)_a;\n  108: \tstruct archive_read_filter_bidder *reader;\n  109  \n  110  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n  ...\n  134   */\n  135  static int\n  136: lzop_bidder_bid(struct archive_read_filter_bidder *self,\n  137:     struct archive_read_filter *filter)\n  138  {\n  139  \tconst unsigned char *p;\n  ...\n  159   */\n  160  static int\n  161: lzop_bidder_init(struct archive_read_filter *self)\n  162  {\n  163  \tint r;\n  ...\n  176   */\n  177  static int\n  178: lzop_bidder_init(struct archive_read_filter *self)\n  179  {\n  180: \tstruct read_lzop *state;\n  181  \n  182  \tself->code = ARCHIVE_FILTER_LZOP;\n  183  \tself->name = \"lzop\";\n  184  \n  185: \tstate = (struct read_lzop *)calloc(sizeof(*state), 1);\n  186  \tif (state == NULL) {\n  187  \t\tarchive_set_error(&self->archive->archive, ENOMEM,\n  ...\n  199  \n  200  static int\n  201: consume_header(struct archive_read_filter *self)\n  202  {\n  203: \tstruct read_lzop *state = (struct read_lzop *)self->data;\n  204  \tconst unsigned char *p, *_p;\n  205  \tunsigned checksum, flags, len, method, version;\n  ...\n  305  \n  306  static int\n  307: consume_block_info(struct archive_read_filter *self)\n  308  {\n  309: \tstruct read_lzop *state = (struct read_lzop *)self->data;\n  310  \tconst unsigned char *p;\n  311  \tunsigned flags = state->flags;\n  ...\n  357  \n  358  static ssize_t\n  359: lzop_filter_read(struct archive_read_filter *self, const void **p)\n  360  {\n  361: \tstruct read_lzop *state = (struct read_lzop *)self->data;\n  362  \tconst void *b;\n  363  \tlzo_uint out_size;\n  ...\n  483   */\n  484  static int\n  485: lzop_filter_close(struct archive_read_filter *self)\n  486  {\n  487: \tstruct read_lzop *state = (struct read_lzop *)self->data;\n  488  \n  489  \tfree(state->out_block);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_private.h:\n   39  #include \"archive_private.h\"\n   40  \n   41: struct archive_read;\n   42: struct archive_read_filter_bidder;\n   43: struct archive_read_filter;\n   44  \n   45  /*\n   ..\n   51   *   * The bidders can use archive_read_filter_ahead() to peek ahead\n   52   *     at the incoming data to compose their bids.\n   53:  *   * The bid manager creates a new filter structure for the winning\n   54   *     bidder and gives the winning bidder a chance to initialize it.\n   55   *   * The new filter becomes the new top filter and we repeat the\n   ..\n   58   * we perform a similar dance with the registered format handlers.\n   59   */\n   60: struct archive_read_filter_bidder {\n   61  \t/* Configuration data for the bidder. */\n   62  \tvoid *data;\n   ..\n   64  \tconst char *name;\n   65  \t/* Taste the upstream filter to see if we handle this. */\n   66: \tint (*bid)(struct archive_read_filter_bidder *,\n   67: \t    struct archive_read_filter *);\n   68  \t/* Initialize a newly-created filter. */\n   69: \tint (*init)(struct archive_read_filter *);\n   70  \t/* Set an option for the filter bidder. */\n   71: \tint (*options)(struct archive_read_filter_bidder *,\n   72  \t    const char *key, const char *value);\n   73  \t/* Release the bidder's configuration data. */\n   74: \tint (*free)(struct archive_read_filter_bidder *);\n   75  };\n   76  \n   77  /*\n   78:  * This structure is allocated within the archive_read core\n   79   * and initialized by archive_read and the init() method of the\n   80   * corresponding bidder above.\n   81   */\n   82: struct archive_read_filter {\n   83  \tint64_t position;\n   84  \t/* Essentially all filters will need these values, so\n   85  \t * just declare them here. */\n   86: \tstruct archive_read_filter_bidder *bidder; /* My bidder. */\n   87: \tstruct archive_read_filter *upstream; /* Who I read from. */\n   88: \tstruct archive_read *archive; /* Associated archive. */\n   89  \t/* Open a block for reading */\n   90: \tint (*open)(struct archive_read_filter *self);\n   91  \t/* Return next block. */\n   92: \tssize_t (*read)(struct archive_read_filter *, const void **);\n   93  \t/* Skip forward this many bytes. */\n   94: \tint64_t (*skip)(struct archive_read_filter *self, int64_t request);\n   95  \t/* Seek to an absolute location. */\n   96: \tint64_t (*seek)(struct archive_read_filter *self, int64_t offset, int whence);\n   97  \t/* Close (just this filter) and free(self). */\n   98: \tint (*close)(struct archive_read_filter *self);\n   99  \t/* Function that handles switching from reading one block to the next/prev */\n  100: \tint (*sswitch)(struct archive_read_filter *self, unsigned int iindex);\n  101  \t/* Read any header metadata if available. */\n  102: \tint (*read_header)(struct archive_read_filter *self, struct archive_entry *entry);\n  103  \t/* My private data. */\n  104  \tvoid *data;\n  ...\n  129   * so should be deferred at least until libarchive 3.0.\n  130   */\n  131: struct archive_read_data_node {\n  132  \tint64_t begin_position;\n  133  \tint64_t total_size;\n  134  \tvoid *data;\n  135  };\n  136: struct archive_read_client {\n  137  \tarchive_open_callback\t*opener;\n  138  \tarchive_read_callback\t*reader;\n  ...\n  144  \tunsigned int cursor;\n  145  \tint64_t position;\n  146: \tstruct archive_read_data_node *dataset;\n  147  };\n  148: struct archive_read_passphrase {\n  149  \tchar\t*passphrase;\n  150: \tstruct archive_read_passphrase *next;\n  151  };\n  152  \n  153: struct archive_read_extract {\n  154: \tstruct archive *ad; /* archive_write_disk object */\n  155  \n  156  \t/* Progress function invoked during extract. */\n  ...\n  159  };\n  160  \n  161: struct archive_read {\n  162: \tstruct archive\tarchive;\n  163  \n  164: \tstruct archive_entry\t*entry;\n  165  \n  166  \t/* Dev/ino of the archive being read/written. */\n  ...\n  170  \n  171  \t/* Callbacks to open/read/write/close client archive streams. */\n  172: \tstruct archive_read_client client;\n  173  \n  174  \t/* Registered filter bidders. */\n  175: \tstruct archive_read_filter_bidder bidders[16];\n  176  \n  177  \t/* Last filter in chain */\n  178: \tstruct archive_read_filter *filter;\n  179  \n  180  \t/* Whether to bypass filter bidding process */\n  ...\n  196  \t */\n  197  \n  198: \tstruct archive_format_descriptor {\n  199  \t\tvoid\t *data;\n  200  \t\tconst char *name;\n  201: \t\tint\t(*bid)(struct archive_read *, int best_bid);\n  202: \t\tint\t(*options)(struct archive_read *, const char *key,\n  203  \t\t    const char *value);\n  204: \t\tint\t(*read_header)(struct archive_read *, struct archive_entry *);\n  205: \t\tint\t(*read_data)(struct archive_read *, const void **, size_t *, int64_t *);\n  206: \t\tint\t(*read_data_skip)(struct archive_read *);\n  207: \t\tint64_t\t(*seek_data)(struct archive_read *, int64_t, int);\n  208: \t\tint\t(*cleanup)(struct archive_read *);\n  209: \t\tint\t(*format_capabilties)(struct archive_read *);\n  210: \t\tint\t(*has_encrypted_entries)(struct archive_read *);\n  211  \t}\tformats[16];\n  212: \tstruct archive_format_descriptor\t*format; /* Active format. */\n  213  \n  214  \t/*\n  215  \t * Various information needed by archive_extract.\n  216  \t */\n  217: \tstruct archive_read_extract\t\t*extract;\n  218: \tint\t\t\t(*cleanup_archive_extract)(struct archive_read *);\n  219  \n  220  \t/*\n  221  \t * Decryption passphrase.\n  222  \t */\n  223: \tstruct {\n  224: \t\tstruct archive_read_passphrase *first;\n  225: \t\tstruct archive_read_passphrase **last;\n  226  \t\tint candidate;\n  227  \t\tarchive_passphrase_callback *callback;\n  ...\n  230  };\n  231  \n  232: int\t__archive_read_register_format(struct archive_read *a,\n  233  \t\tvoid *format_data,\n  234  \t\tconst char *name,\n  235: \t\tint (*bid)(struct archive_read *, int),\n  236: \t\tint (*options)(struct archive_read *, const char *, const char *),\n  237: \t\tint (*read_header)(struct archive_read *, struct archive_entry *),\n  238: \t\tint (*read_data)(struct archive_read *, const void **, size_t *, int64_t *),\n  239: \t\tint (*read_data_skip)(struct archive_read *),\n  240: \t\tint64_t (*seek_data)(struct archive_read *, int64_t, int),\n  241: \t\tint (*cleanup)(struct archive_read *),\n  242: \t\tint (*format_capabilities)(struct archive_read *),\n  243: \t\tint (*has_encrypted_entries)(struct archive_read *));\n  244  \n  245: int __archive_read_get_bidder(struct archive_read *a,\n  246:     struct archive_read_filter_bidder **bidder);\n  247  \n  248: const void *__archive_read_ahead(struct archive_read *, size_t, ssize_t *);\n  249: const void *__archive_read_filter_ahead(struct archive_read_filter *,\n  250      size_t, ssize_t *);\n  251: int64_t\t__archive_read_seek(struct archive_read*, int64_t, int);\n  252: int64_t\t__archive_read_filter_seek(struct archive_read_filter *, int64_t, int);\n  253: int64_t\t__archive_read_consume(struct archive_read *, int64_t);\n  254: int64_t\t__archive_read_filter_consume(struct archive_read_filter *, int64_t);\n  255: int __archive_read_header(struct archive_read *, struct archive_entry *);\n  256: int __archive_read_program(struct archive_read_filter *, const char *);\n  257: void __archive_read_free_filters(struct archive_read *);\n  258: struct archive_read_extract *__archive_read_get_extract(struct archive_read *);\n  259  \n  260  \n  ...\n  262   * Get a decryption passphrase.\n  263   */\n  264: void __archive_read_reset_passphrase(struct archive_read *a);\n  265: const char * __archive_read_next_passphrase(struct archive_read *a);\n  266  #endif\n  267  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter_uuencode.c:\n   45  #define LBYTES 45\n   46  \n   47: struct private_uuencode {\n   48  \tint\t\t\tmode;\n   49: \tstruct archive_string\tname;\n   50: \tstruct archive_string\tencoded_buff;\n   51  \tsize_t\t\t\tbs;\n   52  \tsize_t\t\t\thold_len;\n   ..\n   54  };\n   55  \n   56: static int archive_filter_uuencode_options(struct archive_write_filter *,\n   57      const char *, const char *);\n   58: static int archive_filter_uuencode_open(struct archive_write_filter *);\n   59: static int archive_filter_uuencode_write(struct archive_write_filter *,\n   60      const void *, size_t);\n   61: static int archive_filter_uuencode_close(struct archive_write_filter *);\n   62: static int archive_filter_uuencode_free(struct archive_write_filter *);\n   63: static void uu_encode(struct archive_string *, const unsigned char *, size_t);\n   64  static int64_t atol8(const char *, size_t);\n   65  \n   ..\n   68   */\n   69  int\n   70: archive_write_add_filter_uuencode(struct archive *_a)\n   71  {\n   72: \tstruct archive_write *a = (struct archive_write *)_a;\n   73: \tstruct archive_write_filter *f = __archive_write_allocate_filter(_a);\n   74: \tstruct private_uuencode *state;\n   75  \n   76  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n   77  \t    ARCHIVE_STATE_NEW, \"archive_write_add_filter_uu\");\n   78  \n   79: \tstate = (struct private_uuencode *)calloc(1, sizeof(*state));\n   80  \tif (state == NULL) {\n   81  \t\tarchive_set_error(f->archive, ENOMEM,\n   ..\n  102   */\n  103  static int\n  104: archive_filter_uuencode_options(struct archive_write_filter *f, const char *key,\n  105      const char *value)\n  106  {\n  107: \tstruct private_uuencode *state = (struct private_uuencode *)f->data;\n  108  \n  109  \tif (strcmp(key, \"mode\") == 0) {\n  ...\n  135   */\n  136  static int\n  137: archive_filter_uuencode_open(struct archive_write_filter *f)\n  138  {\n  139: \tstruct private_uuencode *state = (struct private_uuencode *)f->data;\n  140  \tsize_t bs = 65536, bpb;\n  141  \n  ...\n  165  \n  166  static void\n  167: uu_encode(struct archive_string *as, const unsigned char *p, size_t len)\n  168  {\n  169  \tint c;\n  ...\n  204   */\n  205  static int\n  206: archive_filter_uuencode_write(struct archive_write_filter *f, const void *buff,\n  207      size_t length)\n  208  {\n  209: \tstruct private_uuencode *state = (struct private_uuencode *)f->data;\n  210  \tconst unsigned char *p = buff;\n  211  \tint ret = ARCHIVE_OK;\n  ...\n  250   */\n  251  static int\n  252: archive_filter_uuencode_close(struct archive_write_filter *f)\n  253  {\n  254: \tstruct private_uuencode *state = (struct private_uuencode *)f->data;\n  255  \n  256  \t/* Flush remaining bytes. */\n  ...\n  265  \n  266  static int\n  267: archive_filter_uuencode_free(struct archive_write_filter *f)\n  268  {\n  269: \tstruct private_uuencode *state = (struct private_uuencode *)f->data;\n  270  \n  271  \tarchive_string_free(&state->name);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_entry_sparse.c:\n   38  \n   39  void\n   40: archive_entry_sparse_clear(struct archive_entry *entry)\n   41  {\n   42: \tstruct ae_sparse *sp;\n   43  \n   44  \twhile (entry->sparse_head != NULL) {\n   ..\n   51  \n   52  void\n   53: archive_entry_sparse_add_entry(struct archive_entry *entry,\n   54  \tla_int64_t offset, la_int64_t length)\n   55  {\n   56: \tstruct ae_sparse *sp;\n   57  \n   58  \tif (offset < 0 || length < 0)\n   ..\n   78  \t}\n   79  \n   80: \tif ((sp = (struct ae_sparse *)malloc(sizeof(*sp))) == NULL)\n   81  \t\t/* XXX Error XXX */\n   82  \t\treturn;\n   ..\n  101   */\n  102  int\n  103: archive_entry_sparse_count(struct archive_entry *entry)\n  104  {\n  105: \tstruct ae_sparse *sp;\n  106  \tint count = 0;\n  107  \n  ...\n  127  \n  128  int\n  129: archive_entry_sparse_reset(struct archive_entry * entry)\n  130  {\n  131  \tentry->sparse_p = entry->sparse_head;\n  ...\n  135  \n  136  int\n  137: archive_entry_sparse_next(struct archive_entry * entry,\n  138  \tla_int64_t *offset, la_int64_t *length)\n  139  {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter_lzop.c:\n   57  \tMETHOD_LZO1X_999 = 3\n   58  };\n   59: struct write_lzop {\n   60  \tint compression_level;\n   61  #if defined(HAVE_LZO_LZOCONF_H) && defined(HAVE_LZO_LZO1X_H)\n   ..\n   71  \tchar\t\t header_written;\n   72  #else\n   73: \tstruct archive_write_program_data *pdata;\n   74  #endif\n   75  };\n   76  \n   77: static int archive_write_lzop_open(struct archive_write_filter *);\n   78: static int archive_write_lzop_options(struct archive_write_filter *,\n   79  \t\t    const char *, const char *);\n   80: static int archive_write_lzop_write(struct archive_write_filter *,\n   81  \t\t    const void *, size_t);\n   82: static int archive_write_lzop_close(struct archive_write_filter *);\n   83: static int archive_write_lzop_free(struct archive_write_filter *);\n   84  \n   85  #if defined(HAVE_LZO_LZOCONF_H) && defined(HAVE_LZO_LZO1X_H)\n   ..\n  135  \n  136  int\n  137: archive_write_add_filter_lzop(struct archive *_a)\n  138  {\n  139: \tstruct archive_write_filter *f = __archive_write_allocate_filter(_a);\n  140: \tstruct write_lzop *data;\n  141  \n  142  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n  ...\n  190  \n  191  static int\n  192: archive_write_lzop_free(struct archive_write_filter *f)\n  193  {\n  194: \tstruct write_lzop *data = (struct write_lzop *)f->data;\n  195  \n  196  #if defined(HAVE_LZO_LZOCONF_H) && defined(HAVE_LZO_LZO1X_H)\n  ...\n  206  \n  207  static int\n  208: archive_write_lzop_options(struct archive_write_filter *f, const char *key,\n  209      const char *value)\n  210  {\n  211: \tstruct write_lzop *data = (struct write_lzop *)f->data;\n  212  \n  213  \tif (strcmp(key, \"compression-level\") == 0) {\n  ...\n  226  #if defined(HAVE_LZO_LZOCONF_H) && defined(HAVE_LZO_LZO1X_H)\n  227  static int\n  228: archive_write_lzop_open(struct archive_write_filter *f)\n  229  {\n  230: \tstruct write_lzop *data = (struct write_lzop *)f->data;\n  231  \n  232  \tswitch (data->compression_level) {\n  ...\n  285  \n  286  static int\n  287: make_header(struct archive_write_filter *f)\n  288  {\n  289: \tstruct write_lzop *data = (struct write_lzop *)f->data;\n  290  \tint64_t t;\n  291  \tuint32_t checksum;\n  ...\n  314  \n  315  static int\n  316: drive_compressor(struct archive_write_filter *f)\n  317  {\n  318: \tstruct write_lzop *data = (struct write_lzop *)f->data;\n  319  \tunsigned char *p;\n  320  \tconst int block_info_bytes = 12;\n  ...\n  388  \n  389  static int\n  390: archive_write_lzop_write(struct archive_write_filter *f,\n  391      const void *buff, size_t length)\n  392  {\n  393: \tstruct write_lzop *data = (struct write_lzop *)f->data;\n  394  \tconst char *p = buff;\n  395  \tint r;\n  ...\n  421  \n  422  static int\n  423: archive_write_lzop_close(struct archive_write_filter *f)\n  424  {\n  425: \tstruct write_lzop *data = (struct write_lzop *)f->data;\n  426  \tconst uint32_t endmark = 0;\n  427  \tint r;\n  ...\n  440  #else\n  441  static int\n  442: archive_write_lzop_open(struct archive_write_filter *f)\n  443  {\n  444: \tstruct write_lzop *data = (struct write_lzop *)f->data;\n  445: \tstruct archive_string as;\n  446  \tint r;\n  447  \n  ...\n  461  \n  462  static int\n  463: archive_write_lzop_write(struct archive_write_filter *f,\n  464      const void *buff, size_t length)\n  465  {\n  466: \tstruct write_lzop *data = (struct write_lzop *)f->data;\n  467  \n  468  \treturn __archive_write_program_write(f, data->pdata, buff, length);\n  ...\n  470  \n  471  static int\n  472: archive_write_lzop_close(struct archive_write_filter *f)\n  473  {\n  474: \tstruct write_lzop *data = (struct write_lzop *)f->data;\n  475  \n  476  \treturn __archive_write_program_close(f, data->pdata);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter_by_name.c:\n   44  /* A table that maps names to functions. */\n   45  static const\n   46: struct { const char *name; int (*setter)(struct archive *); } names[] =\n   47  {\n   48  \t{ \"b64encode\",\t\tarchive_write_add_filter_b64encode },\n   ..\n   63  \n   64  int\n   65: archive_write_add_filter_by_name(struct archive *a, const char *name)\n   66  {\n   67  \tint i;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_lz4.c:\n   56  \n   57  #if defined(HAVE_LIBLZ4)\n   58: struct private_data {\n   59  \tenum {  SELECT_STREAM,\n   60  \t\tREAD_DEFAULT_STREAM,\n   ..\n   63  \t\tREAD_LEGACY_BLOCK,\n   64  \t}\t\tstage;\n   65: \tstruct {\n   66  \t\tunsigned block_independence:1;\n   67  \t\tunsigned block_checksum:3;\n   ..\n   88  \n   89  /* Lz4 filter */\n   90: static ssize_t\tlz4_filter_read(struct archive_read_filter *, const void **);\n   91: static int\tlz4_filter_close(struct archive_read_filter *);\n   92  #endif\n   93  \n   ..\n   98   * if liblz4 is unavailable.\n   99   */\n  100: static int\tlz4_reader_bid(struct archive_read_filter_bidder *, struct archive_read_filter *);\n  101: static int\tlz4_reader_init(struct archive_read_filter *);\n  102: static int\tlz4_reader_free(struct archive_read_filter_bidder *);\n  103  #if defined(HAVE_LIBLZ4)\n  104: static ssize_t  lz4_filter_read_default_stream(struct archive_read_filter *,\n  105  \t\t    const void **);\n  106: static ssize_t  lz4_filter_read_legacy_stream(struct archive_read_filter *,\n  107  \t\t    const void **);\n  108  #endif\n  109  \n  110  int\n  111: archive_read_support_filter_lz4(struct archive *_a)\n  112  {\n  113: \tstruct archive_read *a = (struct archive_read *)_a;\n  114: \tstruct archive_read_filter_bidder *reader;\n  115  \n  116  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n  ...\n  136  \n  137  static int\n  138: lz4_reader_free(struct archive_read_filter_bidder *self){\n  139  \t(void)self; /* UNUSED */\n  140  \treturn (ARCHIVE_OK);\n  ...\n  149   */\n  150  static int\n  151: lz4_reader_bid(struct archive_read_filter_bidder *self,\n  152:     struct archive_read_filter *filter)\n  153  {\n  154  \tconst unsigned char *buffer;\n  ...\n  203   */\n  204  static int\n  205: lz4_reader_init(struct archive_read_filter *self)\n  206  {\n  207  \tint r;\n  ...\n  223   */\n  224  static int\n  225: lz4_reader_init(struct archive_read_filter *self)\n  226  {\n  227: \tstruct private_data *state;\n  228  \n  229  \tself->code = ARCHIVE_FILTER_LZ4;\n  230  \tself->name = \"lz4\";\n  231  \n  232: \tstate = (struct private_data *)calloc(sizeof(*state), 1);\n  233  \tif (state == NULL) {\n  234  \t\tarchive_set_error(&self->archive->archive, ENOMEM,\n  ...\n  247  \n  248  static int\n  249: lz4_allocate_out_block(struct archive_read_filter *self)\n  250  {\n  251: \tstruct private_data *state = (struct private_data *)self->data;\n  252  \tsize_t out_block_size = state->flags.block_maximum_size;\n  253  \tvoid *out_block;\n  ...\n  272  \n  273  static int\n  274: lz4_allocate_out_block_for_legacy(struct archive_read_filter *self)\n  275  {\n  276: \tstruct private_data *state = (struct private_data *)self->data;\n  277  \tsize_t out_block_size = LEGACY_BLOCK_SIZE;\n  278  \tvoid *out_block;\n  ...\n  296   */\n  297  static ssize_t\n  298: lz4_filter_read(struct archive_read_filter *self, const void **p)\n  299  {\n  300: \tstruct private_data *state = (struct private_data *)self->data;\n  301  \tssize_t ret;\n  302  \n  ...\n  378  \n  379  static int\n  380: lz4_filter_read_descriptor(struct archive_read_filter *self)\n  381  {\n  382: \tstruct private_data *state = (struct private_data *)self->data;\n  383  \tconst char *read_buf;\n  384  \tssize_t bytes_remaining;\n  ...\n  477  \n  478  static ssize_t\n  479: lz4_filter_read_data_block(struct archive_read_filter *self, const void **p)\n  480  {\n  481: \tstruct private_data *state = (struct private_data *)self->data;\n  482  \tssize_t compressed_size;\n  483  \tconst char *read_buf;\n  ...\n  619  \n  620  static ssize_t\n  621: lz4_filter_read_default_stream(struct archive_read_filter *self, const void **p)\n  622  {\n  623: \tstruct private_data *state = (struct private_data *)self->data;\n  624  \tconst char *read_buf;\n  625  \tssize_t bytes_remaining;\n  ...\n  672  \n  673  static ssize_t\n  674: lz4_filter_read_legacy_stream(struct archive_read_filter *self, const void **p)\n  675  {\n  676: \tstruct private_data *state = (struct private_data *)self->data;\n  677  \tuint32_t compressed;\n  678  \tconst char *read_buf;\n  ...\n  728   */\n  729  static int\n  730: lz4_filter_close(struct archive_read_filter *self)\n  731  {\n  732: \tstruct private_data *state;\n  733  \tint ret = ARCHIVE_OK;\n  734  \n  735: \tstate = (struct private_data *)self->data;\n  736  \tfree(state->xxh32_state);\n  737  \tfree(state->out_block);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_open_file.c:\n   48  #include \"archive.h\"\n   49  \n   50: struct write_FILE_data {\n   51  \tFILE\t\t*f;\n   52  };\n   53  \n   54: static int\tfile_free(struct archive *, void *);\n   55: static int\tfile_open(struct archive *, void *);\n   56: static ssize_t\tfile_write(struct archive *, void *, const void *buff, size_t);\n   57  \n   58  int\n   59: archive_write_open_FILE(struct archive *a, FILE *f)\n   60  {\n   61: \tstruct write_FILE_data *mine;\n   62  \n   63: \tmine = (struct write_FILE_data *)malloc(sizeof(*mine));\n   64  \tif (mine == NULL) {\n   65  \t\tarchive_set_error(a, ENOMEM, \"No memory\");\n   ..\n   72  \n   73  static int\n   74: file_open(struct archive *a, void *client_data)\n   75  {\n   76  \t(void)a; /* UNUSED */\n   ..\n   81  \n   82  static ssize_t\n   83: file_write(struct archive *a, void *client_data, const void *buff, size_t length)\n   84  {\n   85: \tstruct write_FILE_data\t*mine;\n   86  \tsize_t\tbytesWritten;\n   87  \n   ..\n  100  \n  101  static int\n  102: file_free(struct archive *a, void *client_data)\n  103  {\n  104: \tstruct write_FILE_data\t*mine = client_data;\n  105  \n  106  \t(void)a; /* UNUSED */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_private.h:\n   44  #define\tARCHIVE_WRITE_FILTER_STATE_FATAL\t0x8000U\n   45  \n   46: struct archive_write;\n   47  \n   48: struct archive_write_filter {\n   49  \tint64_t bytes_written;\n   50: \tstruct archive *archive; /* Associated archive. */\n   51: \tstruct archive_write_filter *next_filter; /* Who I write to. */\n   52: \tint\t(*options)(struct archive_write_filter *,\n   53  \t    const char *key, const char *value);\n   54: \tint\t(*open)(struct archive_write_filter *);\n   55: \tint\t(*write)(struct archive_write_filter *, const void *, size_t);\n   56: \tint\t(*close)(struct archive_write_filter *);\n   57: \tint\t(*free)(struct archive_write_filter *);\n   58  \tvoid\t *data;\n   59  \tconst char *name;\n   ..\n   65  \n   66  #if ARCHIVE_VERSION < 4000000\n   67: void __archive_write_filters_free(struct archive *);\n   68  #endif\n   69  \n   70: struct archive_write_filter *__archive_write_allocate_filter(struct archive *);\n   71  \n   72: int __archive_write_output(struct archive_write *, const void *, size_t);\n   73: int __archive_write_nulls(struct archive_write *, size_t);\n   74: int __archive_write_filter(struct archive_write_filter *, const void *, size_t);\n   75  \n   76: struct archive_write {\n   77: \tstruct archive\tarchive;\n   78  \n   79  \t/* Dev/ino of the archive being written. */\n   ..\n  105  \t * First and last write filters in the pipeline.\n  106  \t */\n  107: \tstruct archive_write_filter *filter_first;\n  108: \tstruct archive_write_filter *filter_last;\n  109  \n  110  \t/*\n  ...\n  114  \tvoid\t *format_data;\n  115  \tconst char *format_name;\n  116: \tint\t(*format_init)(struct archive_write *);\n  117: \tint\t(*format_options)(struct archive_write *,\n  118  \t\t    const char *key, const char *value);\n  119: \tint\t(*format_finish_entry)(struct archive_write *);\n  120: \tint \t(*format_write_header)(struct archive_write *,\n  121: \t\t    struct archive_entry *);\n  122: \tssize_t\t(*format_write_data)(struct archive_write *,\n  123  \t\t    const void *buff, size_t);\n  124: \tint\t(*format_close)(struct archive_write *);\n  125: \tint\t(*format_free)(struct archive_write *);\n  126  \n  127  \n  ...\n  145   */\n  146  int\n  147: __archive_write_format_header_ustar(struct archive_write *, char buff[512],\n  148:     struct archive_entry *, int tartype, int strict,\n  149:     struct archive_string_conv *);\n  150  \n  151: struct archive_write_program_data;\n  152: struct archive_write_program_data * __archive_write_program_allocate(const char *program_name);\n  153: int\t__archive_write_program_free(struct archive_write_program_data *);\n  154: int\t__archive_write_program_open(struct archive_write_filter *,\n  155: \t    struct archive_write_program_data *, const char *);\n  156: int\t__archive_write_program_close(struct archive_write_filter *,\n  157: \t    struct archive_write_program_data *);\n  158: int\t__archive_write_program_write(struct archive_write_filter *,\n  159: \t    struct archive_write_program_data *, const void *, size_t);\n  160  \n  161  /*\n  162   * Get a encryption passphrase.\n  163   */\n  164: const char * __archive_write_get_passphrase(struct archive_write *a);\n  165  #endif\n  166  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_program.c:\n   63  /* Deprecated; remove in libarchive 4.0 */\n   64  int\n   65: archive_read_support_compression_program(struct archive *a, const char *cmd)\n   66  {\n   67  \treturn archive_read_support_filter_program(a, cmd);\n   ..\n   69  \n   70  int\n   71: archive_read_support_compression_program_signature(struct archive *a,\n   72      const char *cmd, const void *signature, size_t signature_len)\n   73  {\n   ..\n   78  \n   79  int\n   80: archive_read_support_filter_program(struct archive *a, const char *cmd)\n   81  {\n   82  \treturn (archive_read_support_filter_program_signature(a, cmd, NULL, 0));\n   ..\n   88   * bid twice in the same pipeline.\n   89   */\n   90: struct program_bidder {\n   91  \tchar *description;\n   92  \tchar *cmd;\n   ..\n   96  };\n   97  \n   98: static int\tprogram_bidder_bid(struct archive_read_filter_bidder *,\n   99: \t\t    struct archive_read_filter *upstream);\n  100: static int\tprogram_bidder_init(struct archive_read_filter *);\n  101: static int\tprogram_bidder_free(struct archive_read_filter_bidder *);\n  102  \n  103  /*\n  104   * The actual filter needs to track input and output data.\n  105   */\n  106: struct program_filter {\n  107: \tstruct archive_string description;\n  108  #if defined(_WIN32) && !defined(__CYGWIN__)\n  109  \tHANDLE\t\t child;\n  ...\n  119  };\n  120  \n  121: static ssize_t\tprogram_filter_read(struct archive_read_filter *,\n  122  \t\t    const void **);\n  123: static int\tprogram_filter_close(struct archive_read_filter *);\n  124: static void\tfree_state(struct program_bidder *);\n  125  \n  126  static int\n  127: set_bidder_signature(struct archive_read_filter_bidder *bidder,\n  128:     struct program_bidder *state, const void *signature, size_t signature_len)\n  129  {\n  130  \n  ...\n  147  \n  148  int\n  149: archive_read_support_filter_program_signature(struct archive *_a,\n  150      const char *cmd, const void *signature, size_t signature_len)\n  151  {\n  152: \tstruct archive_read *a = (struct archive_read *)_a;\n  153: \tstruct archive_read_filter_bidder *bidder;\n  154: \tstruct program_bidder *state;\n  155  \n  156  \t/*\n  ...\n  163  \t * Allocate our private state.\n  164  \t */\n  165: \tstate = (struct program_bidder *)calloc(1, sizeof (*state));\n  166  \tif (state == NULL)\n  167  \t\tgoto memerr;\n  ...\n  178  \n  179  static int\n  180: program_bidder_free(struct archive_read_filter_bidder *self)\n  181  {\n  182: \tstruct program_bidder *state = (struct program_bidder *)self->data;\n  183  \n  184  \tfree_state(state);\n  ...\n  187  \n  188  static void\n  189: free_state(struct program_bidder *state)\n  190  {\n  191  \n  ...\n  204   */\n  205  static int\n  206: program_bidder_bid(struct archive_read_filter_bidder *self,\n  207:     struct archive_read_filter *upstream)\n  208  {\n  209: \tstruct program_bidder *state = self->data;\n  210  \tconst char *p;\n  211  \n  ...\n  237   */\n  238  static int\n  239: child_stop(struct archive_read_filter *self, struct program_filter *state)\n  240  {\n  241  \t/* Close our side of the I/O with the child. */\n  ...\n  305   */\n  306  static ssize_t\n  307: child_read(struct archive_read_filter *self, char *buf, size_t buf_len)\n  308  {\n  309: \tstruct program_filter *state = self->data;\n  310  \tssize_t ret, requested, avail;\n  311  \tconst char *p;\n  ...\n  395  \n  396  int\n  397: __archive_read_program(struct archive_read_filter *self, const char *cmd)\n  398  {\n  399: \tstruct program_filter\t*state;\n  400  \tstatic const size_t out_buf_len = 65536;\n  401  \tchar *out_buf;\n  ...\n  405  \n  406  \tl = strlen(prefix) + strlen(cmd) + 1;\n  407: \tstate = (struct program_filter *)calloc(1, sizeof(*state));\n  408  \tout_buf = (char *)malloc(out_buf_len);\n  409  \tif (state == NULL || out_buf == NULL ||\n  ...\n  449  \n  450  static int\n  451: program_bidder_init(struct archive_read_filter *self)\n  452  {\n  453: \tstruct program_bidder   *bidder_state;\n  454  \n  455: \tbidder_state = (struct program_bidder *)self->bidder->data;\n  456  \treturn (__archive_read_program(self, bidder_state->cmd));\n  457  }\n  458  \n  459  static ssize_t\n  460: program_filter_read(struct archive_read_filter *self, const void **buff)\n  461  {\n  462: \tstruct program_filter *state;\n  463  \tssize_t bytes;\n  464  \tsize_t total;\n  465  \tchar *p;\n  466  \n  467: \tstate = (struct program_filter *)self->data;\n  468  \n  469  \ttotal = 0;\n  ...\n  487  \n  488  static int\n  489: program_filter_close(struct archive_read_filter *self)\n  490  {\n  491: \tstruct program_filter\t*state;\n  492  \tint e;\n  493  \n  494: \tstate = (struct program_filter *)self->data;\n  495  \te = child_stop(self, state);\n  496  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_entry_private.h:\n   36  #include \"archive_string.h\"\n   37  \n   38: struct ae_xattr {\n   39: \tstruct ae_xattr *next;\n   40  \n   41  \tchar\t*name;\n   ..\n   44  };\n   45  \n   46: struct ae_sparse {\n   47: \tstruct ae_sparse *next;\n   48  \n   49  \tint64_t\t offset;\n   ..\n   51  };\n   52  \n   53: struct ae_digest {\n   54  \tunsigned char md5[16];\n   55  \tunsigned char rmd160[20];\n   ..\n   63   * Description of an archive entry.\n   64   *\n   65:  * Basically, this is a \"struct stat\" with a few text fields added in.\n   66   *\n   67   * TODO: Add \"comment\", \"charset\", and possibly other entries\n   ..\n   80   * TODO: Design a good API for handling sparse files.\n   81   */\n   82: struct archive_entry {\n   83: \tstruct archive *archive;\n   84  \n   85  \t/*\n   ..\n   93  \n   94  \t/*\n   95: \t * We have a \"struct aest\" for holding file metadata rather than just\n   96: \t * a \"struct stat\" because on some platforms the \"struct stat\" has\n   97  \t * fields which are too narrow to hold the range of possible values;\n   98  \t * we don't want to lose information if we read an archive and write\n   99  \t * out another (e.g., in \"tar -cf new.tar @old.tar\").\n  100  \t *\n  101: \t * The \"stat\" pointer points to some form of platform-specific struct\n  102: \t * stat; it is declared as a void * rather than a struct stat * as\n  103: \t * some platforms have multiple varieties of stat structures.\n  104  \t */\n  105  \tvoid *stat;\n  106  \tint  stat_valid; /* Set to 0 whenever a field in aest changes. */\n  107  \n  108: \tstruct aest {\n  109  \t\tint64_t\t\taest_atime;\n  110  \t\tuint32_t\taest_atime_nsec;\n  ...\n  152  \t * Use aes here so that we get transparent mbs<->wcs conversions.\n  153  \t */\n  154: \tstruct archive_mstring ae_fflags_text;\t/* Text fflags per fflagstostr(3) */\n  155  \tunsigned long ae_fflags_set;\t\t/* Bitmap fflags */\n  156  \tunsigned long ae_fflags_clear;\n  157: \tstruct archive_mstring ae_gname;\t\t/* Name of owning group */\n  158: \tstruct archive_mstring ae_hardlink;\t/* Name of target for hardlink */\n  159: \tstruct archive_mstring ae_pathname;\t/* Name of entry */\n  160: \tstruct archive_mstring ae_symlink;\t\t/* symlink contents */\n  161: \tstruct archive_mstring ae_uname;\t\t/* Name of owner */\n  162  \n  163  \t/* Not used within libarchive; useful for some clients. */\n  164: \tstruct archive_mstring ae_sourcepath;\t/* Path this entry is sourced from. */\n  165  \n  166  #define AE_ENCRYPTION_NONE 0\n  ...\n  173  \n  174  \t/* Digest support. */\n  175: \tstruct ae_digest digest;\n  176  \n  177  \t/* ACL support. */\n  178: \tstruct archive_acl    acl;\n  179  \n  180  \t/* extattr support. */\n  181: \tstruct ae_xattr *xattr_head;\n  182: \tstruct ae_xattr *xattr_p;\n  183  \n  184  \t/* sparse support. */\n  185: \tstruct ae_sparse *sparse_head;\n  186: \tstruct ae_sparse *sparse_tail;\n  187: \tstruct ae_sparse *sparse_p;\n  188  \n  189  \t/* Miscellaneous. */\n  ...\n  195  \n  196  int\n  197: archive_entry_set_digest(struct archive_entry *entry, int type,\n  198      const unsigned char *digest);\n  199  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_string.h:\n   56   */\n   57  \n   58: struct archive_string {\n   59  \tchar\t*s;  /* Pointer to the storage */\n   60  \tsize_t\t length; /* Length of 's' in characters */\n   ..\n   62  };\n   63  \n   64: struct archive_wstring {\n   65  \twchar_t\t*s;  /* Pointer to the storage */\n   66  \tsize_t\t length; /* Length of 's' in characters */\n   ..\n   68  };\n   69  \n   70: struct archive_string_conv;\n   71  \n   72  /* Initialize an archive_string object on the stack or elsewhere. */\n   ..\n   75  \n   76  /* Append a C char to an archive_string, resizing as necessary. */\n   77: struct archive_string *\n   78: archive_strappend_char(struct archive_string *, char);\n   79  \n   80  /* Ditto for a wchar_t and an archive_wstring. */\n   81: struct archive_wstring *\n   82: archive_wstrappend_wchar(struct archive_wstring *, wchar_t);\n   83  \n   84  /* Append a raw array to an archive_string, resizing as necessary */\n   85: struct archive_string *\n   86: archive_array_append(struct archive_string *, const char *, size_t);\n   87  \n   88  /* Convert a Unicode string to current locale and append the result. */\n   89  /* Returns -1 if conversion fails. */\n   90  int\n   91: archive_string_append_from_wcs(struct archive_string *, const wchar_t *, size_t);\n   92  \n   93  \n   ..\n   95   * Return NULL and set a error message if the conversion is not supported\n   96   * on the platform. */\n   97: struct archive_string_conv *\n   98: archive_string_conversion_to_charset(struct archive *, const char *, int);\n   99: struct archive_string_conv *\n  100: archive_string_conversion_from_charset(struct archive *, const char *, int);\n  101  /* Create the default string conversion object for reading/writing an archive.\n  102   * Return NULL if the conversion is unneeded.\n  103   * Note: On non Windows platform this always returns NULL.\n  104   */\n  105: struct archive_string_conv *\n  106: archive_string_default_conversion_for_read(struct archive *);\n  107: struct archive_string_conv *\n  108: archive_string_default_conversion_for_write(struct archive *);\n  109  /* Dispose of a string conversion object. */\n  110  void\n  111: archive_string_conversion_free(struct archive *);\n  112  const char *\n  113: archive_string_conversion_charset_name(struct archive_string_conv *);\n  114  void\n  115: archive_string_conversion_set_opt(struct archive_string_conv *, int);\n  116  #define SCONV_SET_OPT_UTF8_LIBARCHIVE2X\t1\n  117  #define SCONV_SET_OPT_NORMALIZATION_C\t2\n  ...\n  122   * Return -1 if conversion fails. */\n  123  int\n  124: archive_strncpy_l(struct archive_string *, const void *, size_t,\n  125:     struct archive_string_conv *);\n  126  \n  127  /* Copy one archive_string to another in locale conversion.\n  128   * Return -1 if conversion fails. */\n  129  int\n  130: archive_strncat_l(struct archive_string *, const void *, size_t,\n  131:     struct archive_string_conv *);\n  132  \n  133  \n  ...\n  139  \n  140  /* Concatenate one archive_string to another */\n  141: void archive_string_concat(struct archive_string *dest, struct archive_string *src);\n  142: void archive_wstring_concat(struct archive_wstring *dest, struct archive_wstring *src);\n  143  \n  144  /* Ensure that the underlying buffer is at least as large as the request. */\n  145: struct archive_string *\n  146: archive_string_ensure(struct archive_string *, size_t);\n  147: struct archive_wstring *\n  148: archive_wstring_ensure(struct archive_wstring *, size_t);\n  149  \n  150  /* Append C string, which may lack trailing \\0. */\n  ...\n  153   * Declaring it \"char *\" as with some of the other functions just\n  154   * leads to a lot of extra casts. */\n  155: struct archive_string *\n  156: archive_strncat(struct archive_string *, const void *, size_t);\n  157: struct archive_wstring *\n  158: archive_wstrncat(struct archive_wstring *, const wchar_t *, size_t);\n  159  \n  160  /* Append a C string to an archive_string, resizing as necessary. */\n  161: struct archive_string *\n  162: archive_strcat(struct archive_string *, const void *);\n  163: struct archive_wstring *\n  164: archive_wstrcat(struct archive_wstring *, const wchar_t *);\n  165  \n  166  /* Copy a C string to an archive_string, resizing as necessary. */\n  ...\n  186  \n  187  /* Release any allocated storage resources. */\n  188: void\tarchive_string_free(struct archive_string *);\n  189: void\tarchive_wstring_free(struct archive_wstring *);\n  190  \n  191  /* Like 'vsprintf', but resizes the underlying string as necessary. */\n  192  /* Note: This only implements a small subset of standard printf functionality. */\n  193: void\tarchive_string_vsprintf(struct archive_string *, const char *,\n  194  \t    va_list) __LA_PRINTF(2, 0);\n  195: void\tarchive_string_sprintf(struct archive_string *, const char *, ...)\n  196  \t    __LA_PRINTF(2, 3);\n  197  \n  198  /* Translates from MBS to Unicode. */\n  199  /* Returns non-zero if conversion failed in any way. */\n  200: int archive_wstring_append_from_mbs(struct archive_wstring *dest,\n  201      const char *, size_t);\n  202  \n  ...\n  207   * will attempt to transparently convert.\n  208   */\n  209: struct archive_mstring {\n  210: \tstruct archive_string aes_mbs;\n  211: \tstruct archive_string aes_utf8;\n  212: \tstruct archive_wstring aes_wcs;\n  213: \tstruct archive_string aes_mbs_in_locale;\n  214  \t/* Bitmap of which of the above are valid.  Because we're lazy\n  215  \t * about malloc-ing and reusing the underlying storage, we\n  ...\n  222  };\n  223  \n  224: void\tarchive_mstring_clean(struct archive_mstring *);\n  225: void\tarchive_mstring_copy(struct archive_mstring *dest, struct archive_mstring *src);\n  226: int archive_mstring_get_mbs(struct archive *, struct archive_mstring *, const char **);\n  227: int archive_mstring_get_utf8(struct archive *, struct archive_mstring *, const char **);\n  228: int archive_mstring_get_wcs(struct archive *, struct archive_mstring *, const wchar_t **);\n  229: int\tarchive_mstring_get_mbs_l(struct archive *, struct archive_mstring *, const char **,\n  230: \t    size_t *, struct archive_string_conv *);\n  231: int\tarchive_mstring_copy_mbs(struct archive_mstring *, const char *mbs);\n  232: int\tarchive_mstring_copy_mbs_len(struct archive_mstring *, const char *mbs,\n  233  \t    size_t);\n  234: int\tarchive_mstring_copy_utf8(struct archive_mstring *, const char *utf8);\n  235: int\tarchive_mstring_copy_wcs(struct archive_mstring *, const wchar_t *wcs);\n  236: int\tarchive_mstring_copy_wcs_len(struct archive_mstring *,\n  237  \t    const wchar_t *wcs, size_t);\n  238: int\tarchive_mstring_copy_mbs_len_l(struct archive_mstring *,\n  239: \t    const char *mbs, size_t, struct archive_string_conv *);\n  240: int     archive_mstring_update_utf8(struct archive *, struct archive_mstring *aes, const char *utf8);\n  241  \n  242  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_hmac.c:\n  298  #endif\n  299  \n  300: const struct archive_hmac __archive_hmac = {\n  301  \t&__hmac_sha1_init,\n  302  \t&__hmac_sha1_update,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_by_code.c:\n   35  \n   36  int\n   37: archive_read_support_format_by_code(struct archive *a, int format_code)\n   38  {\n   39  \tarchive_check_magic(a, ARCHIVE_READ_MAGIC,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_digest_private.h:\n  167  #include <windows.h>\n  168  #include <wincrypt.h>\n  169: typedef struct {\n  170    int   valid;\n  171    HCRYPTPROV  cryptProv;\n  ...\n  184  typedef mbedtls_md5_context archive_md5_ctx;\n  185  #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)\n  186: typedef struct md5_ctx archive_md5_ctx;\n  187  #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)\n  188  typedef EVP_MD_CTX *archive_md5_ctx;\n  ...\n  200  typedef mbedtls_ripemd160_context archive_rmd160_ctx;\n  201  #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)\n  202: typedef struct ripemd160_ctx archive_rmd160_ctx;\n  203  #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)\n  204  typedef EVP_MD_CTX *archive_rmd160_ctx;\n  ...\n  216  typedef mbedtls_sha1_context archive_sha1_ctx;\n  217  #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)\n  218: typedef struct sha1_ctx archive_sha1_ctx;\n  219  #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)\n  220  typedef EVP_MD_CTX *archive_sha1_ctx;\n  ...\n  238  typedef mbedtls_sha256_context archive_sha256_ctx;\n  239  #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)\n  240: typedef struct sha256_ctx archive_sha256_ctx;\n  241  #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)\n  242  typedef EVP_MD_CTX *archive_sha256_ctx;\n  ...\n  258  typedef mbedtls_sha512_context archive_sha384_ctx;\n  259  #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)\n  260: typedef struct sha384_ctx archive_sha384_ctx;\n  261  #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)\n  262  typedef EVP_MD_CTX *archive_sha384_ctx;\n  ...\n  280  typedef mbedtls_sha512_context archive_sha512_ctx;\n  281  #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)\n  282: typedef struct sha512_ctx archive_sha512_ctx;\n  283  #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)\n  284  typedef EVP_MD_CTX *archive_sha512_ctx;\n  ...\n  389  \n  390  /* Minimal interface to digest functionality for internal use in libarchive */\n  391: struct archive_digest\n  392  {\n  393    /* Message Digest */\n  ...\n  412  };\n  413  \n  414: extern const struct archive_digest __archive_digest;\n  415  \n  416  #endif\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_rar5.c:\n   89  #define MAX_NAME_IN_BYTES (4 * MAX_NAME_IN_CHARS)\n   90  \n   91: struct file_header {\n   92  \tssize_t bytes_remaining;\n   93  \tssize_t unpacked_size;\n   ..\n  160  };\n  161  \n  162: struct filter_info {\n  163  \tint type;\n  164  \tint channels;\n  ...\n  170  };\n  171  \n  172: struct data_ready {\n  173  \tchar used;\n  174  \tconst uint8_t* buf;\n  ...\n  177  };\n  178  \n  179: struct cdeque {\n  180  \tuint16_t beg_pos;\n  181  \tuint16_t end_pos;\n  ...\n  185  };\n  186  \n  187: struct decode_table {\n  188  \tuint32_t size;\n  189  \tint32_t decode_len[16];\n  ...\n  195  };\n  196  \n  197: struct comp_state {\n  198  \t/* Flag used to specify if unpacker needs to reinitialize the\n  199  \t   uncompression context. */\n  ...\n  240  \n  241  #define HUFF_BC 20\n  242: \tstruct decode_table bd;      /* huffman bit lengths */\n  243  #define HUFF_NC 306\n  244: \tstruct decode_table ld;      /* literals */\n  245  #define HUFF_DC 64\n  246: \tstruct decode_table dd;      /* distances */\n  247  #define HUFF_LDC 16\n  248: \tstruct decode_table ldd;     /* lower bits of distances */\n  249  #define HUFF_RC 44\n  250: \tstruct decode_table rd;      /* repeating distances */\n  251  #define HUFF_TABLE_SIZE (HUFF_NC + HUFF_DC + HUFF_RC + HUFF_LDC)\n  252  \n  253  \t/* Circular deque for storing filters. */\n  254: \tstruct cdeque filters;\n  255  \tint64_t last_block_start;    /* Used for sanity checking. */\n  256  \tssize_t last_block_length;   /* Used for sanity checking. */\n  ...\n  260  \n  261  \t/* Data buffer stack. */\n  262: \tstruct data_ready dready[2];\n  263  };\n  264  \n  265  /* Bit reader state. */\n  266: struct bit_reader {\n  267  \tint8_t bit_addr;    /* Current bit pointer inside current byte. */\n  268  \tint in_addr;        /* Current byte pointer. */\n  269  };\n  270  \n  271: /* RARv5 block header structure. Use bf_* functions to get values from\n  272   * block_flags_u8 field. I.e. bf_byte_count, etc. */\n  273: struct compressed_block_header {\n  274  \t/* block_flags_u8 contain fields encoded in little-endian bitfield:\n  275  \t *\n  ...\n  283  };\n  284  \n  285: /* RARv5 main header structure. */\n  286: struct main_header {\n  287  \t/* Does the archive contain solid streams? */\n  288  \tuint8_t solid : 1;\n  ...\n  296  };\n  297  \n  298: struct generic_header {\n  299  \tuint8_t split_after : 1;\n  300  \tuint8_t split_before : 1;\n  ...\n  304  };\n  305  \n  306: struct multivolume {\n  307  \tunsigned int expected_vol_no;\n  308  \tuint8_t* push_buf;\n  309  };\n  310  \n  311: /* Main context structure. */\n  312: struct rar5 {\n  313  \tint header_initialized;\n  314  \n  ...\n  342  \tuint64_t rr_offset;\n  343  \n  344: \t/* Various context variables grouped to different structures. */\n  345: \tstruct generic_header generic;\n  346: \tstruct main_header main;\n  347: \tstruct comp_state cstate;\n  348: \tstruct file_header file;\n  349: \tstruct bit_reader bits;\n  350: \tstruct multivolume vol;\n  351  \n  352  \t/* The header of currently processed RARv5 block. Used in main\n  353  \t * decompression logic loop. */\n  354: \tstruct compressed_block_header last_block_hdr;\n  355  };\n  356  \n  ...\n  358  \n  359  static void rar5_signature(char *buf);\n  360: static int verify_global_checksums(struct archive_read* a);\n  361: static int rar5_read_data_skip(struct archive_read *a);\n  362: static int push_data_ready(struct archive_read* a, struct rar5* rar,\n  363  \tconst uint8_t* buf, size_t size, int64_t offset);\n  364  \n  ...\n  369  \n  370  /* Clears the contents of this circular deque. */\n  371: static void cdeque_clear(struct cdeque* d) {\n  372  \td->size = 0;\n  373  \td->beg_pos = 0;\n  ...\n  378   * 64, 256, etc. When the user will add another item above current capacity,\n  379   * the circular deque will overwrite the oldest entry. */\n  380: static int cdeque_init(struct cdeque* d, int max_capacity_power_of_2) {\n  381  \tif(d == NULL || max_capacity_power_of_2 == 0)\n  382  \t\treturn CDE_PARAM;\n  ...\n  395  \n  396  /* Return the current size (not capacity) of circular deque `d`. */\n  397: static size_t cdeque_size(struct cdeque* d) {\n  398  \treturn d->size;\n  399  }\n  ...\n  402   * doesn't perform any bounds checking. If you need bounds checking, use\n  403   * `cdeque_front()` function instead. */\n  404: static void cdeque_front_fast(struct cdeque* d, void** value) {\n  405  \t*value = (void*) d->arr[d->beg_pos];\n  406  }\n  ...\n  408  /* Returns the first element of current circular deque. This function\n  409   * performs bounds checking. */\n  410: static int cdeque_front(struct cdeque* d, void** value) {\n  411  \tif(d->size > 0) {\n  412  \t\tcdeque_front_fast(d, value);\n  ...\n  418  /* Pushes a new element into the end of this circular deque object. If current\n  419   * size will exceed capacity, the oldest element will be overwritten. */\n  420: static int cdeque_push_back(struct cdeque* d, void* item) {\n  421  \tif(d == NULL)\n  422  \t\treturn CDE_PARAM;\n  ...\n  434  /* Pops a front element of this circular deque object and returns its value.\n  435   * This function doesn't perform any bounds checking. */\n  436: static void cdeque_pop_front_fast(struct cdeque* d, void** value) {\n  437  \t*value = (void*) d->arr[d->beg_pos];\n  438  \td->beg_pos = (d->beg_pos + 1) & d->cap_mask;\n  ...\n  442  /* Pops a front element of this circular deque object and returns its value.\n  443   * This function performs bounds checking. */\n  444: static int cdeque_pop_front(struct cdeque* d, void** value) {\n  445  \tif(!d || !value)\n  446  \t\treturn CDE_PARAM;\n  ...\n  454  \n  455  /* Convenience function to cast filter_info** to void **. */\n  456: static void** cdeque_filter_p(struct filter_info** f) {\n  457  \treturn (void**) (size_t) f;\n  458  }\n  459  \n  460  /* Convenience function to cast filter_info* to void *. */\n  461: static void* cdeque_filter(struct filter_info* f) {\n  462  \treturn (void**) (size_t) f;\n  463  }\n  ...\n  466   * collection buffer, but doesn't deallocate the memory of any pointer passed\n  467   * to this deque as a value. */\n  468: static void cdeque_free(struct cdeque* d) {\n  469  \tif(!d)\n  470  \t\treturn;\n  ...\n  482  \n  483  static inline\n  484: uint8_t bf_bit_size(const struct compressed_block_header* hdr) {\n  485  \treturn hdr->block_flags_u8 & 7;\n  486  }\n  487  \n  488  static inline\n  489: uint8_t bf_byte_count(const struct compressed_block_header* hdr) {\n  490  \treturn (hdr->block_flags_u8 >> 3) & 7;\n  491  }\n  492  \n  493  static inline\n  494: uint8_t bf_is_table_present(const struct compressed_block_header* hdr) {\n  495  \treturn (hdr->block_flags_u8 >> 7) & 1;\n  496  }\n  497  \n  498: static inline struct rar5* get_context(struct archive_read* a) {\n  499: \treturn (struct rar5*) a->format->data;\n  500  }\n  501  \n  ...\n  515  }\n  516  \n  517: static uint32_t read_filter_data(struct rar5* rar, uint32_t offset) {\n  518  \tuint8_t linear_buf[4];\n  519  \tcircular_memcpy(linear_buf, rar->cstate.window_buf,\n  ...\n  522  }\n  523  \n  524: static void write_filter_data(struct rar5* rar, uint32_t offset,\n  525      uint32_t value)\n  526  {\n  ...\n  529  \n  530  /* Allocates a new filter descriptor and adds it to the filter array. */\n  531: static struct filter_info* add_new_filter(struct rar5* rar) {\n  532: \tstruct filter_info* f =\n  533: \t\t(struct filter_info*) calloc(1, sizeof(struct filter_info));\n  534  \n  535  \tif(!f) {\n  ...\n  541  }\n  542  \n  543: static int run_delta_filter(struct rar5* rar, struct filter_info* flt) {\n  544  \tint i;\n  545  \tssize_t dest_pos, src_pos = 0;\n  ...\n  566  }\n  567  \n  568: static int run_e8e9_filter(struct rar5* rar, struct filter_info* flt,\n  569  \t\tint extended)\n  570  {\n  ...\n  615  }\n  616  \n  617: static int run_arm_filter(struct rar5* rar, struct filter_info* flt) {\n  618  \tssize_t i = 0;\n  619  \tuint32_t offset;\n  ...\n  630  \n  631  \t\tif(*b == 0xEB) {\n  632: \t\t\t/* 0xEB = ARM's BL (branch + link) instruction. */\n  633  \t\t\toffset = read_filter_data(rar,\n  634  \t\t\t    (rar->cstate.solid_offset + flt->block_start + i) &\n  ...\n  644  }\n  645  \n  646: static int run_filter(struct archive_read* a, struct filter_info* flt) {\n  647  \tint ret;\n  648: \tstruct rar5* rar = get_context(a);\n  649  \n  650  \tfree(rar->cstate.filtered_buf);\n  ...\n  702   * that are specified here. These arguments are pushed to the FIFO stack here,\n  703   * and popped from the stack by the `use_data` function. */\n  704: static void push_data(struct archive_read* a, struct rar5* rar,\n  705      const uint8_t* buf, int64_t idx_begin, int64_t idx_end)\n  706  {\n  ...\n  746  /* Convenience function that submits the data to the user. It uses the\n  747   * unpack window buffer as a source location. */\n  748: static void push_window_data(struct archive_read* a, struct rar5* rar,\n  749      int64_t idx_begin, int64_t idx_end)\n  750  {\n  ...\n  752  }\n  753  \n  754: static int apply_filters(struct archive_read* a) {\n  755: \tstruct filter_info* flt;\n  756: \tstruct rar5* rar = get_context(a);\n  757  \tint ret;\n  758  \n  ...\n  804  }\n  805  \n  806: static void dist_cache_push(struct rar5* rar, int value) {\n  807  \tint* q = rar->cstate.dist_cache;\n  808  \n  ...\n  813  }\n  814  \n  815: static int dist_cache_touch(struct rar5* rar, int idx) {\n  816  \tint* q = rar->cstate.dist_cache;\n  817  \tint i, dist = q[idx];\n  ...\n  824  }\n  825  \n  826: static void free_filters(struct rar5* rar) {\n  827: \tstruct cdeque* d = &rar->cstate.filters;\n  828  \n  829  \t/* Free any remaining filters. All filters should be naturally\n  ...\n  835  \t * expression. */\n  836  \twhile(cdeque_size(d) > 0) {\n  837: \t\tstruct filter_info* f = NULL;\n  838  \n  839  \t\t/* Pop_front will also decrease the collection's size. */\n  ...\n  849  }\n  850  \n  851: static void reset_file_context(struct rar5* rar) {\n  852  \tmemset(&rar->file, 0, sizeof(rar->file));\n  853  \tblake2sp_init(&rar->file.b2state, 32);\n  ...\n  869  }\n  870  \n  871: static inline int get_archive_read(struct archive* a,\n  872:     struct archive_read** ar)\n  873  {\n  874: \t*ar = (struct archive_read*) a;\n  875  \tarchive_check_magic(a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,\n  876  \t    \"archive_read_support_format_rar5\");\n  ...\n  879  }\n  880  \n  881: static int read_ahead(struct archive_read* a, size_t how_many,\n  882      const uint8_t** ptr)\n  883  {\n  ...\n  894  }\n  895  \n  896: static int consume(struct archive_read* a, int64_t how_many) {\n  897  \tint ret;\n  898  \n  ...\n  921   */\n  922  \n  923: static int read_var(struct archive_read* a, uint64_t* pvalue,\n  924      uint64_t* pvalue_len)\n  925  {\n  ...\n  992  }\n  993  \n  994: static int read_var_sized(struct archive_read* a, size_t* pvalue,\n  995      size_t* pvalue_len)\n  996  {\n  ...\n 1013  }\n 1014  \n 1015: static int read_bits_32(struct rar5* rar, const uint8_t* p, uint32_t* value) {\n 1016  \tuint32_t bits = ((uint32_t) p[rar->bits.in_addr]) << 24;\n 1017  \tbits |= p[rar->bits.in_addr + 1] << 16;\n ....\n 1024  }\n 1025  \n 1026: static int read_bits_16(struct rar5* rar, const uint8_t* p, uint16_t* value) {\n 1027  \tint bits = (int) ((uint32_t) p[rar->bits.in_addr]) << 16;\n 1028  \tbits |= (int) p[rar->bits.in_addr + 1] << 8;\n ....\n 1033  }\n 1034  \n 1035: static void skip_bits(struct rar5* rar, int bits) {\n 1036  \tconst int new_bits = rar->bits.bit_addr + bits;\n 1037  \trar->bits.in_addr += new_bits >> 3;\n ....\n 1040  \n 1041  /* n = up to 16 */\n 1042: static int read_consume_bits(struct rar5* rar, const uint8_t* p, int n,\n 1043      int* value)\n 1044  {\n ....\n 1067  }\n 1068  \n 1069: static int read_u32(struct archive_read* a, uint32_t* pvalue) {\n 1070  \tconst uint8_t* p;\n 1071  \tif(!read_ahead(a, 4, &p))\n ....\n 1076  }\n 1077  \n 1078: static int read_u64(struct archive_read* a, uint64_t* pvalue) {\n 1079  \tconst uint8_t* p;\n 1080  \tif(!read_ahead(a, 8, &p))\n ....\n 1085  }\n 1086  \n 1087: static int bid_standard(struct archive_read* a) {\n 1088  \tconst uint8_t* p;\n 1089  \tchar signature[sizeof(rar5_signature_xor)];\n ....\n 1100  }\n 1101  \n 1102: static int rar5_bid(struct archive_read* a, int best_bid) {\n 1103  \tint my_bid;\n 1104  \n ....\n 1114  }\n 1115  \n 1116: static int rar5_options(struct archive_read *a, const char *key,\n 1117      const char *val) {\n 1118  \t(void) a;\n ....\n 1127  }\n 1128  \n 1129: static void init_header(struct archive_read* a) {\n 1130  \ta->archive.archive_format = ARCHIVE_FORMAT_RAR_V5;\n 1131  \ta->archive.archive_format_name = \"RAR5\";\n 1132  }\n 1133  \n 1134: static void init_window_mask(struct rar5* rar) {\n 1135  \tif (rar->cstate.window_size)\n 1136  \t\trar->cstate.window_mask = rar->cstate.window_size - 1;\n ....\n 1149  };\n 1150  \n 1151: static int process_main_locator_extra_block(struct archive_read* a,\n 1152:     struct rar5* rar)\n 1153  {\n 1154  \tuint64_t locator_flags;\n ....\n 1181  }\n 1182  \n 1183: static int parse_file_extra_hash(struct archive_read* a, struct rar5* rar,\n 1184      ssize_t* extra_data_size)\n 1185  {\n ....\n 1231  }\n 1232  \n 1233: static int parse_htime_item(struct archive_read* a, char unix_time,\n 1234      uint64_t* where, ssize_t* extra_data_size)\n 1235  {\n ....\n 1253  }\n 1254  \n 1255: static int parse_file_extra_version(struct archive_read* a,\n 1256:     struct archive_entry* e, ssize_t* extra_data_size)\n 1257  {\n 1258  \tsize_t flags = 0;\n 1259  \tsize_t version = 0;\n 1260  \tsize_t value_len = 0;\n 1261: \tstruct archive_string version_string;\n 1262: \tstruct archive_string name_utf8_string;\n 1263  \tconst char* cur_filename;\n 1264  \n ....\n 1307  }\n 1308  \n 1309: static int parse_file_extra_htime(struct archive_read* a,\n 1310:     struct archive_entry* e, struct rar5* rar, ssize_t* extra_data_size)\n 1311  {\n 1312  \tchar unix_time = 0;\n ....\n 1360  }\n 1361  \n 1362: static int parse_file_extra_redir(struct archive_read* a,\n 1363:     struct archive_entry* e, struct rar5* rar, ssize_t* extra_data_size)\n 1364  {\n 1365  \tuint64_t value_size = 0;\n ....\n 1431  }\n 1432  \n 1433: static int parse_file_extra_owner(struct archive_read* a,\n 1434:     struct archive_entry* e, ssize_t* extra_data_size)\n 1435  {\n 1436  \tuint64_t flags = 0;\n ....\n 1511  }\n 1512  \n 1513: static int process_head_file_extra(struct archive_read* a,\n 1514:     struct archive_entry* e, struct rar5* rar, ssize_t extra_data_size)\n 1515  {\n 1516  \tsize_t extra_field_size;\n ....\n 1575  }\n 1576  \n 1577: static int process_head_file(struct archive_read* a, struct rar5* rar,\n 1578:     struct archive_entry* entry, size_t block_flags)\n 1579  {\n 1580  \tssize_t extra_data_size = 0;\n ....\n 1876  }\n 1877  \n 1878: static int process_head_service(struct archive_read* a, struct rar5* rar,\n 1879:     struct archive_entry* entry, size_t block_flags)\n 1880  {\n 1881  \t/* Process this SERVICE block the same way as FILE blocks. */\n ....\n 1897  }\n 1898  \n 1899: static int process_head_main(struct archive_read* a, struct rar5* rar,\n 1900:     struct archive_entry* entry, size_t block_flags)\n 1901  {\n 1902  \tint ret;\n ....\n 2005  }\n 2006  \n 2007: static int skip_unprocessed_bytes(struct archive_read* a) {\n 2008: \tstruct rar5* rar = get_context(a);\n 2009  \tint ret;\n 2010  \n ....\n 2039  }\n 2040  \n 2041: static int scan_for_signature(struct archive_read* a);\n 2042  \n 2043  /* Base block processing function. A 'base block' is a RARv5 header block\n ....\n 2054   * <magic><MAIN><FILE><FILE><FILE><SERVICE><ENDARC>\n 2055   *\n 2056:  * The structure above could describe an archive file with 3 files in it,\n 2057   * one service \"QuickOpen\" block (that is ignored by this parser), and an\n 2058   * end of file base block marker.\n ....\n 2086   */\n 2087  \n 2088: static int process_base_block(struct archive_read* a,\n 2089:     struct archive_entry* entry)\n 2090  {\n 2091  \tconst size_t SMALLEST_RAR5_BLOCK_SIZE = 3;\n 2092  \n 2093: \tstruct rar5* rar = get_context(a);\n 2094  \tuint32_t hdr_crc, computed_crc;\n 2095  \tsize_t raw_hdr_size = 0, hdr_size_len, hdr_size;\n ....\n 2250  }\n 2251  \n 2252: static int skip_base_block(struct archive_read* a) {\n 2253  \tint ret;\n 2254: \tstruct rar5* rar = get_context(a);\n 2255  \n 2256: \t/* Create a new local archive_entry structure that will be operated on\n 2257  \t * by header reader; operations on this archive_entry will be discarded.\n 2258  \t */\n 2259: \tstruct archive_entry* entry = archive_entry_new();\n 2260  \tret = process_base_block(a, entry);\n 2261  \n 2262: \t/* Discard operations on this archive_entry structure. */\n 2263  \tarchive_entry_free(entry);\n 2264  \tif(ret == ARCHIVE_FATAL)\n ....\n 2274  }\n 2275  \n 2276: static int rar5_read_header(struct archive_read *a,\n 2277:     struct archive_entry *entry)\n 2278  {\n 2279: \tstruct rar5* rar = get_context(a);\n 2280  \tint ret;\n 2281  \n ....\n 2301  }\n 2302  \n 2303: static void init_unpack(struct rar5* rar) {\n 2304  \trar->file.calculated_crc32 = 0;\n 2305  \tinit_window_mask(rar);\n ....\n 2326  }\n 2327  \n 2328: static void update_crc(struct rar5* rar, const uint8_t* p, size_t to_read) {\n 2329      int verify_crc;\n 2330  \n ....\n 2357  \n 2358  static int create_decode_tables(uint8_t* bit_length,\n 2359:     struct decode_table* table, int size)\n 2360  {\n 2361  \tint code, upper_limit = 0, i, lc[16];\n ....\n 2423  }\n 2424  \n 2425: static int decode_number(struct archive_read* a, struct decode_table* table,\n 2426      const uint8_t* p, uint16_t* num)\n 2427  {\n ....\n 2429  \tuint16_t bitfield;\n 2430  \tuint32_t pos;\n 2431: \tstruct rar5* rar = get_context(a);\n 2432  \n 2433  \tif(ARCHIVE_OK != read_bits_16(rar, p, &bitfield)) {\n ....\n 2467  \n 2468  /* Reads and parses Huffman tables from the beginning of the block. */\n 2469: static int parse_tables(struct archive_read* a, struct rar5* rar,\n 2470      const uint8_t* p)\n 2471  {\n ....\n 2648  /* Parses the block header, verifies its CRC byte, and saves the header\n 2649   * fields inside the `hdr` pointer. */\n 2650: static int parse_block_header(struct archive_read* a, const uint8_t* p,\n 2651:     ssize_t* block_size, struct compressed_block_header* hdr)\n 2652  {\n 2653  \tuint8_t calculated_cksum;\n 2654: \tmemcpy(hdr, p, sizeof(struct compressed_block_header));\n 2655  \n 2656  \tif(bf_byte_count(hdr) > 2) {\n ....\n 2708  \n 2709  /* Convenience function used during filter processing. */\n 2710: static int parse_filter_data(struct rar5* rar, const uint8_t* p,\n 2711      uint32_t* filter_data)\n 2712  {\n ....\n 2737  \n 2738  /* Function is used during sanity checking. */\n 2739: static int is_valid_filter_block_start(struct rar5* rar,\n 2740      uint32_t start)\n 2741  {\n ....\n 2761  /* The function will create a new filter, read its parameters from the input\n 2762   * stream and add it to the filter collection. */\n 2763: static int parse_filter(struct archive_read* ar, const uint8_t* p) {\n 2764  \tuint32_t block_start, block_length;\n 2765  \tuint16_t filter_type;\n 2766: \tstruct filter_info* filt = NULL;\n 2767: \tstruct rar5* rar = get_context(ar);\n 2768  \n 2769  \t/* Read the parameters from the input stream. */\n ....\n 2824  }\n 2825  \n 2826: static int decode_code_length(struct rar5* rar, const uint8_t* p,\n 2827      uint16_t code)\n 2828  {\n ....\n 2848  }\n 2849  \n 2850: static int copy_string(struct archive_read* a, int len, int dist) {\n 2851: \tstruct rar5* rar = get_context(a);\n 2852  \tconst uint64_t cmask = rar->cstate.window_mask;\n 2853  \tconst uint64_t write_ptr = rar->cstate.write_ptr +\n ....\n 2876  }\n 2877  \n 2878: static int do_uncompress_block(struct archive_read* a, const uint8_t* p) {\n 2879: \tstruct rar5* rar = get_context(a);\n 2880  \tuint16_t num;\n 2881  \tint ret;\n 2882  \n 2883  \tconst uint64_t cmask = rar->cstate.window_mask;\n 2884: \tconst struct compressed_block_header* hdr = &rar->last_block_hdr;\n 2885  \tconst uint8_t bit_size = 1 + bf_bit_size(hdr);\n 2886  \n ....\n 3091  \n 3092  /* Binary search for the RARv5 signature. */\n 3093: static int scan_for_signature(struct archive_read* a) {\n 3094  \tconst uint8_t* p;\n 3095  \tconst int chunk_size = 512;\n ....\n 3138  /* This function will switch the multivolume archive file to another file,\n 3139   * i.e. from part03 to part 04. */\n 3140: static int advance_multivolume(struct archive_read* a) {\n 3141  \tint lret;\n 3142: \tstruct rar5* rar = get_context(a);\n 3143  \n 3144  \t/* A small state machine that will skip unnecessary data, needed to\n ....\n 3213   * a chunk of memory containing the whole block, and the stream pointer\n 3214   * is advanced to the next block in the second multivolume archive file. */\n 3215: static int merge_block(struct archive_read* a, ssize_t block_size,\n 3216      const uint8_t** p)\n 3217  {\n 3218: \tstruct rar5* rar = get_context(a);\n 3219  \tssize_t cur_block_size, partial_offset = 0;\n 3220  \tconst uint8_t* lp;\n ....\n 3320  }\n 3321  \n 3322: static int process_block(struct archive_read* a) {\n 3323  \tconst uint8_t* p;\n 3324: \tstruct rar5* rar = get_context(a);\n 3325  \tint ret;\n 3326  \n ....\n 3349  \t\t * the header is not constant (block size can be stored either\n 3350  \t\t * in 1 or 2 bytes), that's why block size is left out from the\n 3351: \t\t * `compressed_block_header` structure and returned by\n 3352  \t\t * `parse_block_header` as the second argument. */\n 3353  \n ....\n 3360  \t\t/* Skip block header. Next data is huffman tables,\n 3361  \t\t * if present. */\n 3362: \t\tto_skip = sizeof(struct compressed_block_header) +\n 3363  \t\t\tbf_byte_count(&rar->last_block_hdr) + 1;\n 3364  \n ....\n 3386  \t\t\t *\n 3387  \t\t\t * Note that `merge_block` will update the `rar`\n 3388: \t\t\t * context structure quite extensively. */\n 3389  \n 3390  \t\t\tret = merge_block(a, block_size, &p);\n ....\n 3469   * Returns ARCHIVE_OK when those arguments can be used, ARCHIVE_RETRY\n 3470   * when there is no data on the stack. */\n 3471: static int use_data(struct rar5* rar, const void** buf, size_t* size,\n 3472      int64_t* offset)\n 3473  {\n ....\n 3475  \n 3476  \tfor(i = 0; i < rar5_countof(rar->cstate.dready); i++) {\n 3477: \t\tstruct data_ready *d = &rar->cstate.dready[i];\n 3478  \n 3479  \t\tif(d->used) {\n ....\n 3493   * FIFO stack. Those values will be popped from this stack by the `use_data`\n 3494   * function. */\n 3495: static int push_data_ready(struct archive_read* a, struct rar5* rar,\n 3496      const uint8_t* buf, size_t size, int64_t offset)\n 3497  {\n ....\n 3515  \n 3516  \tfor(i = 0; i < rar5_countof(rar->cstate.dready); i++) {\n 3517: \t\tstruct data_ready* d = &rar->cstate.dready[i];\n 3518  \t\tif(!d->used) {\n 3519  \t\t\td->used = 1;\n ....\n 3552   *\n 3553   * The <header> is a block header, that is parsed in parse_block_header().\n 3554:  * It's a \"compressed_block_header\" structure, containing metadata needed\n 3555   * to know when we should stop looking for more <block_n> blocks.\n 3556   *\n ....\n 3586   * */\n 3587  \n 3588: static int do_uncompress_file(struct archive_read* a) {\n 3589: \tstruct rar5* rar = get_context(a);\n 3590  \tint ret;\n 3591  \tint64_t max_end_pos;\n ....\n 3639  \t\t/* Check if we can write something before hitting first\n 3640  \t\t * filter. */\n 3641: \t\tstruct filter_info* flt;\n 3642  \n 3643  \t\t/* Get the block_start offset from the first filter. */\n ....\n 3685  }\n 3686  \n 3687: static int uncompress_file(struct archive_read* a) {\n 3688  \tint ret;\n 3689  \n ....\n 3699  \n 3700  \n 3701: static int do_unstore_file(struct archive_read* a,\n 3702:     struct rar5* rar, const void** buf, size_t* size, int64_t* offset)\n 3703  {\n 3704  \tsize_t to_read;\n ....\n 3747  }\n 3748  \n 3749: static int do_unpack(struct archive_read* a, struct rar5* rar,\n 3750      const void** buf, size_t* size, int64_t* offset)\n 3751  {\n ....\n 3788  }\n 3789  \n 3790: static int verify_checksums(struct archive_read* a) {\n 3791  \tint verify_crc;\n 3792: \tstruct rar5* rar = get_context(a);\n 3793  \n 3794  \t/* Check checksums only when actually unpacking the data. There's no\n ....\n 3886  }\n 3887  \n 3888: static int verify_global_checksums(struct archive_read* a) {\n 3889  \treturn verify_checksums(a);\n 3890  }\n ....\n 3902  }\n 3903  \n 3904: static int rar5_read_data(struct archive_read *a, const void **buff,\n 3905      size_t *size, int64_t *offset) {\n 3906  \tint ret;\n 3907: \tstruct rar5* rar = get_context(a);\n 3908  \n 3909  \tif (size)\n ....\n 3958  }\n 3959  \n 3960: static int rar5_read_data_skip(struct archive_read *a) {\n 3961: \tstruct rar5* rar = get_context(a);\n 3962  \n 3963  \tif(rar->main.solid) {\n ....\n 4009  }\n 4010  \n 4011: static int64_t rar5_seek_data(struct archive_read *a, int64_t offset,\n 4012      int whence)\n 4013  {\n ....\n 4021  }\n 4022  \n 4023: static int rar5_cleanup(struct archive_read *a) {\n 4024: \tstruct rar5* rar = get_context(a);\n 4025  \n 4026  \tfree(rar->cstate.window_buf);\n ....\n 4038  }\n 4039  \n 4040: static int rar5_capabilities(struct archive_read * a) {\n 4041  \t(void) a;\n 4042  \treturn 0;\n 4043  }\n 4044  \n 4045: static int rar5_has_encrypted_entries(struct archive_read *_a) {\n 4046  \t(void) _a;\n 4047  \n ....\n 4050  }\n 4051  \n 4052: static int rar5_init(struct rar5* rar) {\n 4053: \tmemset(rar, 0, sizeof(struct rar5));\n 4054  \n 4055  \tif(CDE_OK != cdeque_init(&rar->cstate.filters, 8192))\n ....\n 4059  }\n 4060  \n 4061: int archive_read_support_format_rar5(struct archive *_a) {\n 4062: \tstruct archive_read* ar;\n 4063  \tint ret;\n 4064: \tstruct rar5* rar;\n 4065  \n 4066  \tif(ARCHIVE_OK != (ret = get_archive_read(_a, &ar)))\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_rb.c:\n   47  #define\tRB_FLAG_MASK\t\t(RB_FLAG_POSITION|RB_FLAG_RED)\n   48  #define\tRB_FATHER(rb) \\\n   49:     ((struct archive_rb_node *)((rb)->rb_info & ~RB_FLAG_MASK))\n   50  #define\tRB_SET_FATHER(rb, father) \\\n   51      ((void)((rb)->rb_info = (uintptr_t)(father)|((rb)->rb_info & RB_FLAG_MASK)))\n   ..\n   82    } while (/*CONSTCOND*/ 0)\n   83  \n   84: static void __archive_rb_tree_insert_rebalance(struct archive_rb_tree *,\n   85:     struct archive_rb_node *);\n   86: static void __archive_rb_tree_removal_rebalance(struct archive_rb_tree *,\n   87:     struct archive_rb_node *, unsigned int);\n   88  \n   89  #define\tRB_SENTINEL_NODE\tNULL\n   ..\n   93  \n   94  void\n   95: __archive_rb_tree_init(struct archive_rb_tree *rbt,\n   96:     const struct archive_rb_tree_ops *ops)\n   97  {\n   98  \trbt->rbt_ops = ops;\n   99: \t*((struct archive_rb_node **)&rbt->rbt_root) = RB_SENTINEL_NODE;\n  100  }\n  101  \n  102: struct archive_rb_node *\n  103: __archive_rb_tree_find_node(struct archive_rb_tree *rbt, const void *key)\n  104  {\n  105  \tarchive_rbto_compare_key_fn compare_key = rbt->rbt_ops->rbto_compare_key;\n  106: \tstruct archive_rb_node *parent = rbt->rbt_root;\n  107  \n  108  \twhile (!RB_SENTINEL_P(parent)) {\n  ...\n  116  }\n  117   \n  118: struct archive_rb_node *\n  119: __archive_rb_tree_find_node_geq(struct archive_rb_tree *rbt, const void *key)\n  120  {\n  121  \tarchive_rbto_compare_key_fn compare_key = rbt->rbt_ops->rbto_compare_key;\n  122: \tstruct archive_rb_node *parent = rbt->rbt_root;\n  123: \tstruct archive_rb_node *last = NULL;\n  124  \n  125  \twhile (!RB_SENTINEL_P(parent)) {\n  ...\n  135  }\n  136   \n  137: struct archive_rb_node *\n  138: __archive_rb_tree_find_node_leq(struct archive_rb_tree *rbt, const void *key)\n  139  {\n  140  \tarchive_rbto_compare_key_fn compare_key = rbt->rbt_ops->rbto_compare_key;\n  141: \tstruct archive_rb_node *parent = rbt->rbt_root;\n  142: \tstruct archive_rb_node *last = NULL;\n  143  \n  144  \twhile (!RB_SENTINEL_P(parent)) {\n  ...\n  155  \f\n  156  int\n  157: __archive_rb_tree_insert_node(struct archive_rb_tree *rbt,\n  158:     struct archive_rb_node *self)\n  159  {\n  160  \tarchive_rbto_compare_nodes_fn compare_nodes = rbt->rbt_ops->rbto_compare_nodes;\n  161: \tstruct archive_rb_node *parent, *tmp;\n  162  \tunsigned int position;\n  163  \tint rebalance;\n  ...\n  166  \t/*\n  167  \t * This is a hack.  Because rbt->rbt_root is just a\n  168: \t * struct archive_rb_node *, just like rb_node->rb_nodes[RB_DIR_LEFT],\n  169  \t * we can use this fact to avoid a lot of tests for root and know\n  170  \t * that even at root, updating\n  ...\n  172  \t * update rbt->rbt_root.\n  173  \t */\n  174: \tparent = (struct archive_rb_node *)(void *)&rbt->rbt_root;\n  175  \tposition = RB_DIR_LEFT;\n  176  \n  ...\n  196  \tRB_SET_FATHER(self, parent);\n  197  \tRB_SET_POSITION(self, position);\n  198: \tif (parent == (struct archive_rb_node *)(void *)&rbt->rbt_root) {\n  199  \t\tRB_MARK_BLACK(self);\t\t/* root is always black */\n  200  \t\trebalance = F;\n  ...\n  230  static void\n  231  __archive_rb_tree_reparent_nodes(\n  232:     struct archive_rb_node *old_father, const unsigned int which)\n  233  {\n  234  \tconst unsigned int other = which ^ RB_DIR_OTHER;\n  235: \tstruct archive_rb_node * const grandpa = RB_FATHER(old_father);\n  236: \tstruct archive_rb_node * const old_child = old_father->rb_nodes[which];\n  237: \tstruct archive_rb_node * const new_father = old_child;\n  238: \tstruct archive_rb_node * const new_child = old_father;\n  239  \n  240  \tif (new_father == NULL)\n  ...\n  271  \f\n  272  static void\n  273: __archive_rb_tree_insert_rebalance(struct archive_rb_tree *rbt,\n  274:     struct archive_rb_node *self)\n  275  {\n  276: \tstruct archive_rb_node * father = RB_FATHER(self);\n  277: \tstruct archive_rb_node * grandpa;\n  278: \tstruct archive_rb_node * uncle;\n  279  \tunsigned int which;\n  280  \tunsigned int other;\n  ...\n  346  \f\n  347  static void\n  348: __archive_rb_tree_prune_node(struct archive_rb_tree *rbt,\n  349:     struct archive_rb_node *self, int rebalance)\n  350  {\n  351  \tconst unsigned int which = RB_POSITION(self);\n  352: \tstruct archive_rb_node *father = RB_FATHER(self);\n  353  \n  354  \t/*\n  ...\n  369   */\n  370  static void\n  371: __archive_rb_tree_swap_prune_and_rebalance(struct archive_rb_tree *rbt,\n  372:     struct archive_rb_node *self, struct archive_rb_node *standin)\n  373  {\n  374  \tconst unsigned int standin_which = RB_POSITION(standin);\n  375  \tunsigned int standin_other = standin_which ^ RB_DIR_OTHER;\n  376: \tstruct archive_rb_node *standin_son;\n  377: \tstruct archive_rb_node *standin_father = RB_FATHER(standin);\n  378  \tint rebalance = RB_BLACK_P(standin);\n  379  \n  ...\n  473  static void\n  474  __archive_rb_tree_prune_blackred_branch(\n  475:     struct archive_rb_node *self, unsigned int which)\n  476  {\n  477: \tstruct archive_rb_node *father = RB_FATHER(self);\n  478: \tstruct archive_rb_node *son = self->rb_nodes[which];\n  479  \n  480  \t/*\n  ...\n  490   */\n  491  void\n  492: __archive_rb_tree_remove_node(struct archive_rb_tree *rbt,\n  493:     struct archive_rb_node *self)\n  494  {\n  495: \tstruct archive_rb_node *standin;\n  496  \tunsigned int which;\n  497  \n  ...\n  547  \n  548  static void\n  549: __archive_rb_tree_removal_rebalance(struct archive_rb_tree *rbt,\n  550:     struct archive_rb_node *parent, unsigned int which)\n  551  {\n  552  \n  553  \twhile (RB_BLACK_P(parent->rb_nodes[which])) {\n  554  \t\tunsigned int other = which ^ RB_DIR_OTHER;\n  555: \t\tstruct archive_rb_node *brother = parent->rb_nodes[other];\n  556  \n  557  \t\tif (brother == NULL)\n  ...\n  672  }\n  673  \n  674: struct archive_rb_node *\n  675: __archive_rb_tree_iterate(struct archive_rb_tree *rbt,\n  676:     struct archive_rb_node *self, const unsigned int direction)\n  677  {\n  678  \tconst unsigned int other = direction ^ RB_DIR_OTHER;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_cryptor_private.h:\n   54  #define AES_MAX_KEY_SIZE kCCKeySizeAES256\n   55  \n   56: typedef struct {\n   57  \tCCCryptorRef\tctx;\n   58  \tuint8_t\t\tkey[AES_MAX_KEY_SIZE];\n   ..\n   73  #define AES_MAX_KEY_SIZE 32\n   74  #define AES_BLOCK_SIZE 16\n   75: typedef struct {\n   76  \tBCRYPT_ALG_HANDLE hAlg;\n   77  \tBCRYPT_KEY_HANDLE hKey;\n   ..\n   91  #define AES_BLOCK_SIZE 16\n   92  \n   93: typedef struct {\n   94  \tmbedtls_aes_context\tctx;\n   95  \tuint8_t\t\tkey[AES_MAX_KEY_SIZE];\n   ..\n  107  #include <nettle/version.h>\n  108  \n  109: typedef struct {\n  110  #if NETTLE_VERSION_MAJOR < 3\n  111: \tstruct aes_ctx\tctx;\n  112  #else\n  113  \tunion {\n  114: \t\tstruct aes128_ctx c128;\n  115: \t\tstruct aes192_ctx c192;\n  116: \t\tstruct aes256_ctx c256;\n  117  \t}\t\tctx;\n  118  #endif\n  ...\n  129  #define AES_MAX_KEY_SIZE 32\n  130  \n  131: typedef struct {\n  132  \tEVP_CIPHER_CTX\t*ctx;\n  133  \tconst EVP_CIPHER *type;\n  ...\n  167  /* Minimal interface to cryptographic functionality for internal use in\n  168   * libarchive */\n  169: struct archive_cryptor\n  170  {\n  171    /* PKCS5 PBKDF2 HMAC-SHA1 */\n  ...\n  184  };\n  185  \n  186: extern const struct archive_cryptor __archive_cryptor;\n  187  \n  188  #endif\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_warc.c:\n   51  #include \"archive_write_set_format_private.h\"\n   52  \n   53: struct warc_s {\n   54  \tunsigned int omit_warcinfo:1;\n   55  \n   ..\n   87  } warc_type_t;\n   88  \n   89: typedef struct {\n   90  \twarc_type_t type;\n   91  \tconst char *tgturi;\n   ..\n   97  } warc_essential_hdr_t;\n   98  \n   99: typedef struct {\n  100  \tunsigned int u[4U];\n  101  } warc_uuid_t;\n  102  \n  103: static int _warc_options(struct archive_write*, const char *key, const char *v);\n  104: static int _warc_header(struct archive_write *a, struct archive_entry *entry);\n  105: static ssize_t _warc_data(struct archive_write *a, const void *buf, size_t sz);\n  106: static int _warc_finish_entry(struct archive_write *a);\n  107: static int _warc_close(struct archive_write *a);\n  108: static int _warc_free(struct archive_write *a);\n  109  \n  110  /* private routines */\n  111: static ssize_t _popul_ehdr(struct archive_string *t, size_t z, warc_essential_hdr_t);\n  112  static int _gen_uuid(warc_uuid_t *tgt);\n  113  \n  ...\n  117   */\n  118  int\n  119: archive_write_set_format_warc(struct archive *_a)\n  120  {\n  121: \tstruct archive_write *a = (struct archive_write *)_a;\n  122: \tstruct warc_s *w;\n  123  \n  124  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n  ...\n  161  /* archive methods */\n  162  static int\n  163: _warc_options(struct archive_write *a, const char *key, const char *val)\n  164  {\n  165: \tstruct warc_s *w = a->format_data;\n  166  \n  167  \tif (strcmp(key, \"omit-warcinfo\") == 0) {\n  ...\n  180  \n  181  static int\n  182: _warc_header(struct archive_write *a, struct archive_entry *entry)\n  183  {\n  184: \tstruct warc_s *w = a->format_data;\n  185: \tstruct archive_string hdr;\n  186  #define MAX_HDR_SIZE 512\n  187  \n  ...\n  267  \n  268  static ssize_t\n  269: _warc_data(struct archive_write *a, const void *buf, size_t len)\n  270  {\n  271: \tstruct warc_s *w = a->format_data;\n  272  \n  273  \tif (w->typ == AE_IFREG) {\n  ...\n  289  \n  290  static int\n  291: _warc_finish_entry(struct archive_write *a)\n  292  {\n  293  \tstatic const char _eor[] = \"\\r\\n\\r\\n\";\n  294: \tstruct warc_s *w = a->format_data;\n  295  \n  296  \tif (w->typ == AE_IFREG) {\n  ...\n  307  \n  308  static int\n  309: _warc_close(struct archive_write *a)\n  310  {\n  311  \t(void)a; /* UNUSED */\n  ...\n  314  \n  315  static int\n  316: _warc_free(struct archive_write *a)\n  317  {\n  318: \tstruct warc_s *w = a->format_data;\n  319  \n  320  \tfree(w);\n  ...\n  326  /* private routines */\n  327  static void\n  328: xstrftime(struct archive_string *as, const char *fmt, time_t t)\n  329  {\n  330  /** like strftime(3) but for time_t objects */\n  331: \tstruct tm *rt;\n  332  #if defined(HAVE_GMTIME_R) || defined(HAVE__GMTIME64_S)\n  333: \tstruct tm timeHere;\n  334  #endif\n  335  #if defined(HAVE__GMTIME64_S)\n  ...\n  360  \n  361  static ssize_t\n  362: _popul_ehdr(struct archive_string *tgt, size_t tsz, warc_essential_hdr_t hdr)\n  363  {\n  364  \tstatic const char _ver[] = \"WARC/1.0\\r\\n\";\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_raw.c:\n   39  #include \"archive_read_private.h\"\n   40  \n   41: struct raw_info {\n   42  \tint64_t offset; /* Current position in the file. */\n   43  \tint64_t unconsumed;\n   ..\n   45  };\n   46  \n   47: static int\tarchive_read_format_raw_bid(struct archive_read *, int);\n   48: static int\tarchive_read_format_raw_cleanup(struct archive_read *);\n   49: static int\tarchive_read_format_raw_read_data(struct archive_read *,\n   50  \t\t    const void **, size_t *, int64_t *);\n   51: static int\tarchive_read_format_raw_read_data_skip(struct archive_read *);\n   52: static int\tarchive_read_format_raw_read_header(struct archive_read *,\n   53: \t\t    struct archive_entry *);\n   54  \n   55  int\n   56: archive_read_support_format_raw(struct archive *_a)\n   57  {\n   58: \tstruct raw_info *info;\n   59: \tstruct archive_read *a = (struct archive_read *)_a;\n   60  \tint r;\n   61  \n   ..\n   63  \t    ARCHIVE_STATE_NEW, \"archive_read_support_format_raw\");\n   64  \n   65: \tinfo = (struct raw_info *)calloc(1, sizeof(*info));\n   66  \tif (info == NULL) {\n   67  \t\tarchive_set_error(&a->archive, ENOMEM,\n   ..\n   95   */\n   96  static int\n   97: archive_read_format_raw_bid(struct archive_read *a, int best_bid)\n   98  {\n   99  \tif (best_bid < 1 && __archive_read_ahead(a, 1, NULL) != NULL)\n  ...\n  106   */\n  107  static int\n  108: archive_read_format_raw_read_header(struct archive_read *a,\n  109:     struct archive_entry *entry)\n  110  {\n  111: \tstruct raw_info *info;\n  112  \n  113: \tinfo = (struct raw_info *)(a->format->data);\n  114  \tif (info->end_of_file)\n  115  \t\treturn (ARCHIVE_EOF);\n  ...\n  127  \n  128  static int\n  129: archive_read_format_raw_read_data(struct archive_read *a,\n  130      const void **buff, size_t *size, int64_t *offset)\n  131  {\n  132: \tstruct raw_info *info;\n  133  \tssize_t avail;\n  134  \n  135: \tinfo = (struct raw_info *)(a->format->data);\n  136  \n  137  \t/* Consume the bytes we read last time. */\n  ...\n  168  \n  169  static int\n  170: archive_read_format_raw_read_data_skip(struct archive_read *a)\n  171  {\n  172: \tstruct raw_info *info = (struct raw_info *)(a->format->data);\n  173  \n  174  \t/* Consume the bytes we read last time. */\n  ...\n  182  \n  183  static int\n  184: archive_read_format_raw_cleanup(struct archive_read *a)\n  185  {\n  186: \tstruct raw_info *info;\n  187  \n  188: \tinfo = (struct raw_info *)(a->format->data);\n  189  \tfree(info);\n  190  \ta->format->data = NULL;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_entry_strmode.c:\n   38  \n   39  const char *\n   40: archive_entry_strmode(struct archive_entry *entry)\n   41  {\n   42  \tstatic const mode_t permbits[] =\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_entry.h:\n   68  #endif\n   69  \n   70: /* The la_ssize_t should match the type used in 'struct stat' */\n   71  #if !defined(__LA_SSIZE_T_DEFINED)\n   72  /* Older code relied on the __LA_SSIZE_T macro; after 4.0 we'll switch to the typedef exclusively. */\n   ..\n  141   * Description of an archive entry.\n  142   *\n  143:  * You can think of this as \"struct stat\" with some text fields added in.\n  144   *\n  145   * TODO: Add \"comment\", \"charset\", and possibly other entries that are\n  ...\n  154   * package-management attributes to each entry).\n  155   */\n  156: struct archive;\n  157: struct archive_entry;\n  158  \n  159  /*\n  ...\n  202   */\n  203  \n  204: __LA_DECL struct archive_entry\t*archive_entry_clear(struct archive_entry *);\n  205  /* The 'clone' function does a deep copy; all of the strings are copied too. */\n  206: __LA_DECL struct archive_entry\t*archive_entry_clone(struct archive_entry *);\n  207: __LA_DECL void\t\t\t archive_entry_free(struct archive_entry *);\n  208: __LA_DECL struct archive_entry\t*archive_entry_new(void);\n  209  \n  210  /*\n  ...\n  215   * default character-set conversion.\n  216   */\n  217: __LA_DECL struct archive_entry\t*archive_entry_new2(struct archive *);\n  218  \n  219  /*\n  ...\n  236   * This is usually what you want.\n  237   */\n  238: __LA_DECL time_t\t archive_entry_atime(struct archive_entry *);\n  239: __LA_DECL long\t\t archive_entry_atime_nsec(struct archive_entry *);\n  240: __LA_DECL int\t\t archive_entry_atime_is_set(struct archive_entry *);\n  241: __LA_DECL time_t\t archive_entry_birthtime(struct archive_entry *);\n  242: __LA_DECL long\t\t archive_entry_birthtime_nsec(struct archive_entry *);\n  243: __LA_DECL int\t\t archive_entry_birthtime_is_set(struct archive_entry *);\n  244: __LA_DECL time_t\t archive_entry_ctime(struct archive_entry *);\n  245: __LA_DECL long\t\t archive_entry_ctime_nsec(struct archive_entry *);\n  246: __LA_DECL int\t\t archive_entry_ctime_is_set(struct archive_entry *);\n  247: __LA_DECL dev_t\t\t archive_entry_dev(struct archive_entry *);\n  248: __LA_DECL int\t\t archive_entry_dev_is_set(struct archive_entry *);\n  249: __LA_DECL dev_t\t\t archive_entry_devmajor(struct archive_entry *);\n  250: __LA_DECL dev_t\t\t archive_entry_devminor(struct archive_entry *);\n  251: __LA_DECL __LA_MODE_T\t archive_entry_filetype(struct archive_entry *);\n  252: __LA_DECL void\t\t archive_entry_fflags(struct archive_entry *,\n  253  \t\t\t    unsigned long * /* set */,\n  254  \t\t\t    unsigned long * /* clear */);\n  255: __LA_DECL const char\t*archive_entry_fflags_text(struct archive_entry *);\n  256: __LA_DECL la_int64_t\t archive_entry_gid(struct archive_entry *);\n  257: __LA_DECL const char\t*archive_entry_gname(struct archive_entry *);\n  258: __LA_DECL const char\t*archive_entry_gname_utf8(struct archive_entry *);\n  259: __LA_DECL const wchar_t\t*archive_entry_gname_w(struct archive_entry *);\n  260: __LA_DECL const char\t*archive_entry_hardlink(struct archive_entry *);\n  261: __LA_DECL const char\t*archive_entry_hardlink_utf8(struct archive_entry *);\n  262: __LA_DECL const wchar_t\t*archive_entry_hardlink_w(struct archive_entry *);\n  263: __LA_DECL la_int64_t\t archive_entry_ino(struct archive_entry *);\n  264: __LA_DECL la_int64_t\t archive_entry_ino64(struct archive_entry *);\n  265: __LA_DECL int\t\t archive_entry_ino_is_set(struct archive_entry *);\n  266: __LA_DECL __LA_MODE_T\t archive_entry_mode(struct archive_entry *);\n  267: __LA_DECL time_t\t archive_entry_mtime(struct archive_entry *);\n  268: __LA_DECL long\t\t archive_entry_mtime_nsec(struct archive_entry *);\n  269: __LA_DECL int\t\t archive_entry_mtime_is_set(struct archive_entry *);\n  270: __LA_DECL unsigned int\t archive_entry_nlink(struct archive_entry *);\n  271: __LA_DECL const char\t*archive_entry_pathname(struct archive_entry *);\n  272: __LA_DECL const char\t*archive_entry_pathname_utf8(struct archive_entry *);\n  273: __LA_DECL const wchar_t\t*archive_entry_pathname_w(struct archive_entry *);\n  274: __LA_DECL __LA_MODE_T\t archive_entry_perm(struct archive_entry *);\n  275: __LA_DECL dev_t\t\t archive_entry_rdev(struct archive_entry *);\n  276: __LA_DECL dev_t\t\t archive_entry_rdevmajor(struct archive_entry *);\n  277: __LA_DECL dev_t\t\t archive_entry_rdevminor(struct archive_entry *);\n  278: __LA_DECL const char\t*archive_entry_sourcepath(struct archive_entry *);\n  279: __LA_DECL const wchar_t\t*archive_entry_sourcepath_w(struct archive_entry *);\n  280: __LA_DECL la_int64_t\t archive_entry_size(struct archive_entry *);\n  281: __LA_DECL int\t\t archive_entry_size_is_set(struct archive_entry *);\n  282: __LA_DECL const char\t*archive_entry_strmode(struct archive_entry *);\n  283: __LA_DECL const char\t*archive_entry_symlink(struct archive_entry *);\n  284: __LA_DECL const char\t*archive_entry_symlink_utf8(struct archive_entry *);\n  285: __LA_DECL int\t\t archive_entry_symlink_type(struct archive_entry *);\n  286: __LA_DECL const wchar_t\t*archive_entry_symlink_w(struct archive_entry *);\n  287: __LA_DECL la_int64_t\t archive_entry_uid(struct archive_entry *);\n  288: __LA_DECL const char\t*archive_entry_uname(struct archive_entry *);\n  289: __LA_DECL const char\t*archive_entry_uname_utf8(struct archive_entry *);\n  290: __LA_DECL const wchar_t\t*archive_entry_uname_w(struct archive_entry *);\n  291: __LA_DECL int archive_entry_is_data_encrypted(struct archive_entry *);\n  292: __LA_DECL int archive_entry_is_metadata_encrypted(struct archive_entry *);\n  293: __LA_DECL int archive_entry_is_encrypted(struct archive_entry *);\n  294  \n  295  /*\n  ...\n  302   */\n  303  \n  304: __LA_DECL void\tarchive_entry_set_atime(struct archive_entry *, time_t, long);\n  305: __LA_DECL void  archive_entry_unset_atime(struct archive_entry *);\n  306  #if defined(_WIN32) && !defined(__CYGWIN__)\n  307: __LA_DECL void archive_entry_copy_bhfi(struct archive_entry *, BY_HANDLE_FILE_INFORMATION *);\n  308  #endif\n  309: __LA_DECL void\tarchive_entry_set_birthtime(struct archive_entry *, time_t, long);\n  310: __LA_DECL void  archive_entry_unset_birthtime(struct archive_entry *);\n  311: __LA_DECL void\tarchive_entry_set_ctime(struct archive_entry *, time_t, long);\n  312: __LA_DECL void  archive_entry_unset_ctime(struct archive_entry *);\n  313: __LA_DECL void\tarchive_entry_set_dev(struct archive_entry *, dev_t);\n  314: __LA_DECL void\tarchive_entry_set_devmajor(struct archive_entry *, dev_t);\n  315: __LA_DECL void\tarchive_entry_set_devminor(struct archive_entry *, dev_t);\n  316: __LA_DECL void\tarchive_entry_set_filetype(struct archive_entry *, unsigned int);\n  317: __LA_DECL void\tarchive_entry_set_fflags(struct archive_entry *,\n  318  \t    unsigned long /* set */, unsigned long /* clear */);\n  319  /* Returns pointer to start of first invalid token, or NULL if none. */\n  320  /* Note that all recognized tokens are processed, regardless. */\n  321: __LA_DECL const char *archive_entry_copy_fflags_text(struct archive_entry *,\n  322  \t    const char *);\n  323: __LA_DECL const wchar_t *archive_entry_copy_fflags_text_w(struct archive_entry *,\n  324  \t    const wchar_t *);\n  325: __LA_DECL void\tarchive_entry_set_gid(struct archive_entry *, la_int64_t);\n  326: __LA_DECL void\tarchive_entry_set_gname(struct archive_entry *, const char *);\n  327: __LA_DECL void\tarchive_entry_set_gname_utf8(struct archive_entry *, const char *);\n  328: __LA_DECL void\tarchive_entry_copy_gname(struct archive_entry *, const char *);\n  329: __LA_DECL void\tarchive_entry_copy_gname_w(struct archive_entry *, const wchar_t *);\n  330: __LA_DECL int\tarchive_entry_update_gname_utf8(struct archive_entry *, const char *);\n  331: __LA_DECL void\tarchive_entry_set_hardlink(struct archive_entry *, const char *);\n  332: __LA_DECL void\tarchive_entry_set_hardlink_utf8(struct archive_entry *, const char *);\n  333: __LA_DECL void\tarchive_entry_copy_hardlink(struct archive_entry *, const char *);\n  334: __LA_DECL void\tarchive_entry_copy_hardlink_w(struct archive_entry *, const wchar_t *);\n  335: __LA_DECL int\tarchive_entry_update_hardlink_utf8(struct archive_entry *, const char *);\n  336: __LA_DECL void\tarchive_entry_set_ino(struct archive_entry *, la_int64_t);\n  337: __LA_DECL void\tarchive_entry_set_ino64(struct archive_entry *, la_int64_t);\n  338: __LA_DECL void\tarchive_entry_set_link(struct archive_entry *, const char *);\n  339: __LA_DECL void\tarchive_entry_set_link_utf8(struct archive_entry *, const char *);\n  340: __LA_DECL void\tarchive_entry_copy_link(struct archive_entry *, const char *);\n  341: __LA_DECL void\tarchive_entry_copy_link_w(struct archive_entry *, const wchar_t *);\n  342: __LA_DECL int\tarchive_entry_update_link_utf8(struct archive_entry *, const char *);\n  343: __LA_DECL void\tarchive_entry_set_mode(struct archive_entry *, __LA_MODE_T);\n  344: __LA_DECL void\tarchive_entry_set_mtime(struct archive_entry *, time_t, long);\n  345: __LA_DECL void  archive_entry_unset_mtime(struct archive_entry *);\n  346: __LA_DECL void\tarchive_entry_set_nlink(struct archive_entry *, unsigned int);\n  347: __LA_DECL void\tarchive_entry_set_pathname(struct archive_entry *, const char *);\n  348: __LA_DECL void\tarchive_entry_set_pathname_utf8(struct archive_entry *, const char *);\n  349: __LA_DECL void\tarchive_entry_copy_pathname(struct archive_entry *, const char *);\n  350: __LA_DECL void\tarchive_entry_copy_pathname_w(struct archive_entry *, const wchar_t *);\n  351: __LA_DECL int\tarchive_entry_update_pathname_utf8(struct archive_entry *, const char *);\n  352: __LA_DECL void\tarchive_entry_set_perm(struct archive_entry *, __LA_MODE_T);\n  353: __LA_DECL void\tarchive_entry_set_rdev(struct archive_entry *, dev_t);\n  354: __LA_DECL void\tarchive_entry_set_rdevmajor(struct archive_entry *, dev_t);\n  355: __LA_DECL void\tarchive_entry_set_rdevminor(struct archive_entry *, dev_t);\n  356: __LA_DECL void\tarchive_entry_set_size(struct archive_entry *, la_int64_t);\n  357: __LA_DECL void\tarchive_entry_unset_size(struct archive_entry *);\n  358: __LA_DECL void\tarchive_entry_copy_sourcepath(struct archive_entry *, const char *);\n  359: __LA_DECL void\tarchive_entry_copy_sourcepath_w(struct archive_entry *, const wchar_t *);\n  360: __LA_DECL void\tarchive_entry_set_symlink(struct archive_entry *, const char *);\n  361: __LA_DECL void\tarchive_entry_set_symlink_type(struct archive_entry *, int);\n  362: __LA_DECL void\tarchive_entry_set_symlink_utf8(struct archive_entry *, const char *);\n  363: __LA_DECL void\tarchive_entry_copy_symlink(struct archive_entry *, const char *);\n  364: __LA_DECL void\tarchive_entry_copy_symlink_w(struct archive_entry *, const wchar_t *);\n  365: __LA_DECL int\tarchive_entry_update_symlink_utf8(struct archive_entry *, const char *);\n  366: __LA_DECL void\tarchive_entry_set_uid(struct archive_entry *, la_int64_t);\n  367: __LA_DECL void\tarchive_entry_set_uname(struct archive_entry *, const char *);\n  368: __LA_DECL void\tarchive_entry_set_uname_utf8(struct archive_entry *, const char *);\n  369: __LA_DECL void\tarchive_entry_copy_uname(struct archive_entry *, const char *);\n  370: __LA_DECL void\tarchive_entry_copy_uname_w(struct archive_entry *, const wchar_t *);\n  371: __LA_DECL int\tarchive_entry_update_uname_utf8(struct archive_entry *, const char *);\n  372: __LA_DECL void\tarchive_entry_set_is_data_encrypted(struct archive_entry *, char is_encrypted);\n  373: __LA_DECL void\tarchive_entry_set_is_metadata_encrypted(struct archive_entry *, char is_encrypted);\n  374  /*\n  375:  * Routines to bulk copy fields to/from a platform-native \"struct\n  376:  * stat.\"  Libarchive used to just store a struct stat inside of each\n  377   * archive_entry object, but this created issues when trying to\n  378   * manipulate archives on systems different than the ones they were\n  ...\n  384   * archive_entry_stat32 or archive_entry_stat64 as appropriate.\n  385   */\n  386: __LA_DECL const struct stat\t*archive_entry_stat(struct archive_entry *);\n  387: __LA_DECL void\tarchive_entry_copy_stat(struct archive_entry *, const struct stat *);\n  388  \n  389  /*\n  ...\n  394   */\n  395  \n  396: __LA_DECL const void * archive_entry_mac_metadata(struct archive_entry *, size_t *);\n  397: __LA_DECL void archive_entry_copy_mac_metadata(struct archive_entry *, const void *, size_t);\n  398  \n  399  /*\n  ...\n  408  #define ARCHIVE_ENTRY_DIGEST_SHA512           0x00000006\n  409  \n  410: __LA_DECL const unsigned char * archive_entry_digest(struct archive_entry *, int /* type */);\n  411  \n  412  /*\n  ...\n  521   * default and access information in a single ACL list.\n  522   */\n  523: __LA_DECL void\t archive_entry_acl_clear(struct archive_entry *);\n  524: __LA_DECL int\t archive_entry_acl_add_entry(struct archive_entry *,\n  525  \t    int /* type */, int /* permset */, int /* tag */,\n  526  \t    int /* qual */, const char * /* name */);\n  527: __LA_DECL int\t archive_entry_acl_add_entry_w(struct archive_entry *,\n  528  \t    int /* type */, int /* permset */, int /* tag */,\n  529  \t    int /* qual */, const wchar_t * /* name */);\n  ...\n  534   * certain types of entries.\n  535   */\n  536: __LA_DECL int\t archive_entry_acl_reset(struct archive_entry *, int /* want_type */);\n  537: __LA_DECL int\t archive_entry_acl_next(struct archive_entry *, int /* want_type */,\n  538  \t    int * /* type */, int * /* permset */, int * /* tag */,\n  539  \t    int * /* qual */, const char ** /* name */);\n  540  \n  541  /*\n  542:  * Construct a text-format ACL.  The flags argument is a bitmask that\n  543   * can include any of the following:\n  544   *\n  ...\n  567  #define\tARCHIVE_ENTRY_ACL_STYLE_COMPACT\t\t0x00000010\n  568  \n  569: __LA_DECL wchar_t *archive_entry_acl_to_text_w(struct archive_entry *,\n  570  \t    la_ssize_t * /* len */, int /* flags */);\n  571: __LA_DECL char *archive_entry_acl_to_text(struct archive_entry *,\n  572  \t    la_ssize_t * /* len */, int /* flags */);\n  573: __LA_DECL int archive_entry_acl_from_text_w(struct archive_entry *,\n  574  \t    const wchar_t * /* wtext */, int /* type */);\n  575: __LA_DECL int archive_entry_acl_from_text(struct archive_entry *,\n  576  \t    const char * /* text */, int /* type */);\n  577  \n  ...\n  581  \n  582  /* Deprecated functions */\n  583: __LA_DECL const wchar_t\t*archive_entry_acl_text_w(struct archive_entry *,\n  584  \t\t    int /* flags */) __LA_DEPRECATED;\n  585: __LA_DECL const char *archive_entry_acl_text(struct archive_entry *,\n  586  \t\t    int /* flags */) __LA_DEPRECATED;\n  587  \n  588  /* Return bitmask of ACL types in an archive entry */\n  589: __LA_DECL int\t archive_entry_acl_types(struct archive_entry *);\n  590  \n  591  /* Return a count of entries matching 'want_type' */\n  592: __LA_DECL int\t archive_entry_acl_count(struct archive_entry *, int /* want_type */);\n  593  \n  594  /* Return an opaque ACL object. */\n  595  /* There's not yet anything clients can actually do with this... */\n  596: struct archive_acl;\n  597: __LA_DECL struct archive_acl *archive_entry_acl(struct archive_entry *);\n  598  \n  599  /*\n  ...\n  601   */\n  602  \n  603: __LA_DECL void\t archive_entry_xattr_clear(struct archive_entry *);\n  604: __LA_DECL void\t archive_entry_xattr_add_entry(struct archive_entry *,\n  605  \t    const char * /* name */, const void * /* value */,\n  606  \t    size_t /* size */);\n  ...\n  611   */\n  612  \n  613: __LA_DECL int\tarchive_entry_xattr_count(struct archive_entry *);\n  614: __LA_DECL int\tarchive_entry_xattr_reset(struct archive_entry *);\n  615: __LA_DECL int\tarchive_entry_xattr_next(struct archive_entry *,\n  616  \t    const char ** /* name */, const void ** /* value */, size_t *);\n  617  \n  ...\n  620   */\n  621  \n  622: __LA_DECL void\t archive_entry_sparse_clear(struct archive_entry *);\n  623: __LA_DECL void\t archive_entry_sparse_add_entry(struct archive_entry *,\n  624  \t    la_int64_t /* offset */, la_int64_t /* length */);\n  625  \n  ...\n  629   */\n  630  \n  631: __LA_DECL int\tarchive_entry_sparse_count(struct archive_entry *);\n  632: __LA_DECL int\tarchive_entry_sparse_reset(struct archive_entry *);\n  633: __LA_DECL int\tarchive_entry_sparse_next(struct archive_entry *,\n  634  \t    la_int64_t * /* offset */, la_int64_t * /* length */);\n  635  \n  ...\n  637   * Utility to match up hardlinks.\n  638   *\n  639:  * The 'struct archive_entry_linkresolver' is a cache of archive entries\n  640   * for files with multiple links.  Here's how to use it:\n  641   *   1. Create a lookup object with archive_entry_linkresolver_new()\n  ...\n  662   * body should not be written to the archive.  Pay attention!\n  663   */\n  664: struct archive_entry_linkresolver;\n  665  \n  666  /*\n  ...\n  704   */\n  705  \n  706: __LA_DECL struct archive_entry_linkresolver *archive_entry_linkresolver_new(void);\n  707  __LA_DECL void archive_entry_linkresolver_set_strategy(\n  708: \tstruct archive_entry_linkresolver *, int /* format_code */);\n  709: __LA_DECL void archive_entry_linkresolver_free(struct archive_entry_linkresolver *);\n  710: __LA_DECL void archive_entry_linkify(struct archive_entry_linkresolver *,\n  711:     struct archive_entry **, struct archive_entry **);\n  712: __LA_DECL struct archive_entry *archive_entry_partial_links(\n  713:     struct archive_entry_linkresolver *res, unsigned int *links);\n  714  #ifdef __cplusplus\n  715  }\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_disk_acl_darwin.c:\n   50  #include \"archive_write_disk_private.h\"\n   51  \n   52: typedef struct {\n   53  \tconst int a_perm;\t/* Libarchive permission or flag */\n   54  \tconst int p_perm;\t/* Platform permission or flag */\n   ..\n   91      (int)(sizeof(acl_nfs4_flag_map)/sizeof(acl_nfs4_flag_map[0]));\n   92  \n   93: static int translate_guid(struct archive *a, acl_entry_t acl_entry,\n   94      int *ae_id, int *ae_tag, const char **ae_name)\n   95  {\n   ..\n  122  \n  123  static void\n  124: add_trivial_nfs4_acl(struct archive_entry *entry)\n  125  {\n  126  \tmode_t mode;\n  ...\n  139  \t    ARCHIVE_ENTRY_ACL_WRITE_OWNER;\n  140  \n  141: \tstruct {\n  142  \t    const int type;\n  143  \t    const int tag;\n  ...\n  208  \n  209  static int\n  210: translate_acl(struct archive_read_disk *a,\n  211:     struct archive_entry *entry, acl_t acl)\n  212  {\n  213  \tacl_tag_t\t acl_tag;\n  ...\n  319  \n  320  static int\n  321: set_acl(struct archive *a, int fd, const char *name,\n  322:     struct archive_acl *abstract_acl,\n  323      int ae_requested_type, const char *tname)\n  324  {\n  ...\n  491  \n  492  int\n  493: archive_read_disk_entry_setup_acls(struct archive_read_disk *a,\n  494:     struct archive_entry *entry, int *fd)\n  495  {\n  496  \tconst char\t*accpath;\n  ...\n  543  \n  544  int\n  545: archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n  546:     struct archive_acl *abstract_acl, __LA_MODE_T mode)\n  547  {\n  548  \tint\t\tret = ARCHIVE_OK;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_raw.c:\n   33  #include \"archive_write_private.h\"\n   34  \n   35: static ssize_t\tarchive_write_raw_data(struct archive_write *,\n   36  \t\t    const void *buff, size_t s);\n   37: static int\tarchive_write_raw_free(struct archive_write *);\n   38: static int\tarchive_write_raw_header(struct archive_write *,\n   39: \t\t    struct archive_entry *);\n   40  \n   41: struct raw {\n   42          int entries_written;\n   43  };\n   ..\n   47   */\n   48  int\n   49: archive_write_set_format_raw(struct archive *_a)\n   50  {\n   51: \tstruct archive_write *a = (struct archive_write *)_a;\n   52: \tstruct raw *raw;\n   53  \n   54  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n   ..\n   59  \t\t(a->format_free)(a);\n   60  \n   61: \traw = (struct raw *)calloc(1, sizeof(*raw));\n   62  \tif (raw == NULL) {\n   63  \t\tarchive_set_error(&a->archive, ENOMEM, \"Can't allocate raw data\");\n   ..\n   81  \n   82  static int\n   83: archive_write_raw_header(struct archive_write *a, struct archive_entry *entry)\n   84  {\n   85: \tstruct raw *raw = (struct raw *)a->format_data;\n   86  \n   87  \tif (archive_entry_filetype(entry) != AE_IFREG) {\n   ..\n  103  \n  104  static ssize_t\n  105: archive_write_raw_data(struct archive_write *a, const void *buff, size_t s)\n  106  {\n  107  \tint ret;\n  ...\n  115  \n  116  static int\n  117: archive_write_raw_free(struct archive_write *a)\n  118  {\n  119: \tstruct raw *raw;\n  120  \n  121: \traw = (struct raw *)a->format_data;\n  122  \tfree(raw);\n  123  \ta->format_data = NULL;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_filter_by_ext.c:\n   44  /* A table that maps names to functions. */\n   45  static const\n   46: struct { const char *name; int (*format)(struct archive *); int (*filter)(struct archive *);  } names[] =\n   47  {\n   48  \t{ \".7z\",\tarchive_write_set_format_7zip,            archive_write_add_filter_none},\n   ..\n   98  \n   99  int\n  100: archive_write_set_format_filter_by_ext(struct archive *a, const char *filename)\n  101  {\n  102    int names_index = get_array_index(filename);\n  ...\n  117  \n  118  int\n  119: archive_write_set_format_filter_by_ext_def(struct archive *a, const char *filename, const char * def_ext)\n  120  {\n  121    int names_index = get_array_index(filename);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_disk_acl_freebsd.c:\n   49  #include \"archive_write_disk_private.h\"\n   50  \n   51: typedef struct {\n   52  \tconst int a_perm;\t/* Libarchive permission or flag */\n   53  \tconst int p_perm;\t/* Platform permission or flag */\n   ..\n  104  \n  105  static int\n  106: translate_acl(struct archive_read_disk *a,\n  107:     struct archive_entry *entry, acl_t acl, int default_entry_acl_type)\n  108  {\n  109  #if ARCHIVE_ACL_FREEBSD_NFS4\n  ...\n  319  \n  320  static int\n  321: set_acl(struct archive *a, int fd, const char *name,\n  322:     struct archive_acl *abstract_acl, __LA_MODE_T mode,\n  323      int ae_requested_type, const char *tname)\n  324  {\n  ...\n  571  \n  572  int\n  573: archive_read_disk_entry_setup_acls(struct archive_read_disk *a,\n  574:     struct archive_entry *entry, int *fd)\n  575  {\n  576  \tconst char\t*accpath;\n  ...\n  677  \n  678  int\n  679: archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n  680:     struct archive_acl *abstract_acl, __LA_MODE_T mode)\n  681  {\n  682  \tint\t\tret = ARCHIVE_OK;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_rpm.c:\n   38  #include \"archive_read_private.h\"\n   39  \n   40: struct rpm {\n   41  \tint64_t\t\t total_in;\n   42  \tsize_t\t\t hpos;\n   ..\n   56  #define RPM_LEAD_SIZE\t96\t/* Size of 'Lead' section. */\n   57  \n   58: static int\trpm_bidder_bid(struct archive_read_filter_bidder *,\n   59: \t\t    struct archive_read_filter *);\n   60: static int\trpm_bidder_init(struct archive_read_filter *);\n   61  \n   62: static ssize_t\trpm_filter_read(struct archive_read_filter *,\n   63  \t\t    const void **);\n   64: static int\trpm_filter_close(struct archive_read_filter *);\n   65  \n   66  #if ARCHIVE_VERSION_NUMBER < 4000000\n   67  /* Deprecated; remove in libarchive 4.0 */\n   68  int\n   69: archive_read_support_compression_rpm(struct archive *a)\n   70  {\n   71  \treturn archive_read_support_filter_rpm(a);\n   ..\n   74  \n   75  int\n   76: archive_read_support_filter_rpm(struct archive *_a)\n   77  {\n   78: \tstruct archive_read *a = (struct archive_read *)_a;\n   79: \tstruct archive_read_filter_bidder *bidder;\n   80  \n   81  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n   ..\n   95  \n   96  static int\n   97: rpm_bidder_bid(struct archive_read_filter_bidder *self,\n   98:     struct archive_read_filter *filter)\n   99  {\n  100  \tconst unsigned char *b;\n  ...\n  135  \n  136  static int\n  137: rpm_bidder_init(struct archive_read_filter *self)\n  138  {\n  139: \tstruct rpm   *rpm;\n  140  \n  141  \tself->code = ARCHIVE_FILTER_RPM;\n  ...\n  145  \tself->close = rpm_filter_close;\n  146  \n  147: \trpm = (struct rpm *)calloc(sizeof(*rpm), 1);\n  148  \tif (rpm == NULL) {\n  149  \t\tarchive_set_error(&self->archive->archive, ENOMEM,\n  ...\n  159  \n  160  static ssize_t\n  161: rpm_filter_read(struct archive_read_filter *self, const void **buff)\n  162  {\n  163: \tstruct rpm *rpm;\n  164  \tconst unsigned char *b;\n  165  \tssize_t avail_in, total;\n  ...\n  168  \tuint32_t bytes;\n  169  \n  170: \trpm = (struct rpm *)self->data;\n  171  \t*buff = NULL;\n  172  \ttotal = avail_in = 0;\n  ...\n  278  \n  279  static int\n  280: rpm_filter_close(struct archive_read_filter *self)\n  281  {\n  282: \tstruct rpm *rpm;\n  283  \n  284: \trpm = (struct rpm *)self->data;\n  285  \tfree(rpm);\n  286  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_xz.c:\n   53  #if HAVE_LZMA_H && HAVE_LIBLZMA\n   54  \n   55: struct private_data {\n   56  \tlzma_stream\t stream;\n   57  \tunsigned char\t*out_block;\n   ..\n   77  \n   78  /* Combined lzip/lzma/xz filter */\n   79: static ssize_t\txz_filter_read(struct archive_read_filter *, const void **);\n   80: static int\txz_filter_close(struct archive_read_filter *);\n   81: static int\txz_lzma_bidder_init(struct archive_read_filter *);\n   82  \n   83  #endif\n   ..\n   89   * compiled even if no lzma library is available.\n   90   */\n   91: static int\txz_bidder_bid(struct archive_read_filter_bidder *,\n   92: \t\t    struct archive_read_filter *);\n   93: static int\txz_bidder_init(struct archive_read_filter *);\n   94: static int\tlzma_bidder_bid(struct archive_read_filter_bidder *,\n   95: \t\t    struct archive_read_filter *);\n   96: static int\tlzma_bidder_init(struct archive_read_filter *);\n   97: static int\tlzip_has_member(struct archive_read_filter *);\n   98: static int\tlzip_bidder_bid(struct archive_read_filter_bidder *,\n   99: \t\t    struct archive_read_filter *);\n  100: static int\tlzip_bidder_init(struct archive_read_filter *);\n  101  \n  102  #if ARCHIVE_VERSION_NUMBER < 4000000\n  103  /* Deprecated; remove in libarchive 4.0 */\n  104  int\n  105: archive_read_support_compression_xz(struct archive *a)\n  106  {\n  107  \treturn archive_read_support_filter_xz(a);\n  ...\n  110  \n  111  int\n  112: archive_read_support_filter_xz(struct archive *_a)\n  113  {\n  114: \tstruct archive_read *a = (struct archive_read *)_a;\n  115: \tstruct archive_read_filter_bidder *bidder;\n  116  \n  117  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n  ...\n  138  #if ARCHIVE_VERSION_NUMBER < 4000000\n  139  int\n  140: archive_read_support_compression_lzma(struct archive *a)\n  141  {\n  142  \treturn archive_read_support_filter_lzma(a);\n  ...\n  145  \n  146  int\n  147: archive_read_support_filter_lzma(struct archive *_a)\n  148  {\n  149: \tstruct archive_read *a = (struct archive_read *)_a;\n  150: \tstruct archive_read_filter_bidder *bidder;\n  151  \n  152  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n  ...\n  174  #if ARCHIVE_VERSION_NUMBER < 4000000\n  175  int\n  176: archive_read_support_compression_lzip(struct archive *a)\n  177  {\n  178  \treturn archive_read_support_filter_lzip(a);\n  ...\n  181  \n  182  int\n  183: archive_read_support_filter_lzip(struct archive *_a)\n  184  {\n  185: \tstruct archive_read *a = (struct archive_read *)_a;\n  186: \tstruct archive_read_filter_bidder *bidder;\n  187  \n  188  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n  ...\n  211   */\n  212  static int\n  213: xz_bidder_bid(struct archive_read_filter_bidder *self,\n  214:     struct archive_read_filter *filter)\n  215  {\n  216  \tconst unsigned char *buffer;\n  ...\n  245   */\n  246  static int\n  247: lzma_bidder_bid(struct archive_read_filter_bidder *self,\n  248:     struct archive_read_filter *filter)\n  249  {\n  250  \tconst unsigned char *buffer;\n  ...\n  352  \n  353  static int\n  354: lzip_has_member(struct archive_read_filter *filter)\n  355  {\n  356  \tconst unsigned char *buffer;\n  ...\n  386  \n  387  static int\n  388: lzip_bidder_bid(struct archive_read_filter_bidder *self,\n  389:     struct archive_read_filter *filter)\n  390  {\n  391  \n  ...\n  400   */\n  401  static int\n  402: xz_bidder_init(struct archive_read_filter *self)\n  403  {\n  404  \tself->code = ARCHIVE_FILTER_XZ;\n  ...\n  408  \n  409  static int\n  410: lzma_bidder_init(struct archive_read_filter *self)\n  411  {\n  412  \tself->code = ARCHIVE_FILTER_LZMA;\n  ...\n  416  \n  417  static int\n  418: lzip_bidder_init(struct archive_read_filter *self)\n  419  {\n  420  \tself->code = ARCHIVE_FILTER_LZIP;\n  ...\n  427   */\n  428  static void\n  429: set_error(struct archive_read_filter *self, int ret)\n  430  {\n  431  \n  ...\n  475   */\n  476  static int\n  477: xz_lzma_bidder_init(struct archive_read_filter *self)\n  478  {\n  479  \tstatic const size_t out_block_size = 64 * 1024;\n  480  \tvoid *out_block;\n  481: \tstruct private_data *state;\n  482  \tint ret;\n  483  \n  484: \tstate = (struct private_data *)calloc(sizeof(*state), 1);\n  485  \tout_block = (unsigned char *)malloc(out_block_size);\n  486  \tif (state == NULL || out_block == NULL) {\n  ...\n  538  \n  539  static int\n  540: lzip_init(struct archive_read_filter *self)\n  541  {\n  542: \tstruct private_data *state;\n  543  \tconst unsigned char *h;\n  544  \tlzma_filter filters[2];\n  ...\n  548  \tint log2dic, ret;\n  549  \n  550: \tstate = (struct private_data *)self->data;\n  551  \th = __archive_read_filter_ahead(self->upstream, 6, &avail_in);\n  552  \tif (h == NULL)\n  ...\n  594  \n  595  static int\n  596: lzip_tail(struct archive_read_filter *self)\n  597  {\n  598: \tstruct private_data *state;\n  599  \tconst unsigned char *f;\n  600  \tssize_t avail_in;\n  601  \tint tail;\n  602  \n  603: \tstate = (struct private_data *)self->data;\n  604  \tif (state->lzip_ver == 0)\n  605  \t\ttail = 12;\n  ...\n  655   */\n  656  static ssize_t\n  657: xz_filter_read(struct archive_read_filter *self, const void **p)\n  658  {\n  659: \tstruct private_data *state;\n  660  \tsize_t decompressed;\n  661  \tssize_t avail_in;\n  662  \tint ret;\n  663  \n  664: \tstate = (struct private_data *)self->data;\n  665  \n  666  \t/* Empty our output buffer. */\n  ...\n  732   */\n  733  static int\n  734: xz_filter_close(struct archive_read_filter *self)\n  735  {\n  736: \tstruct private_data *state;\n  737  \n  738: \tstate = (struct private_data *)self->data;\n  739  \tlzma_end(&(state->stream));\n  740  \tfree(state->out_block);\n  ...\n  753   */\n  754  static int\n  755: lzma_bidder_init(struct archive_read_filter *self)\n  756  {\n  757  \tint r;\n  ...\n  767  \n  768  static int\n  769: xz_bidder_init(struct archive_read_filter *self)\n  770  {\n  771  \tint r;\n  ...\n  781  \n  782  static int\n  783: lzip_bidder_init(struct archive_read_filter *self)\n  784  {\n  785  \tint r;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_compress.c:\n   89   * of course), rather than relying on an external library.  I have\n   90   * made an effort to clarify and simplify the algorithm, so the\n   91:  * names and structure here don't exactly match those used by compress.\n   92   */\n   93  \n   94: struct private_data {\n   95  \t/* Input variables. */\n   96  \tconst unsigned char\t*next_in;\n   ..\n  132  };\n  133  \n  134: static int\tcompress_bidder_bid(struct archive_read_filter_bidder *, struct archive_read_filter *);\n  135: static int\tcompress_bidder_init(struct archive_read_filter *);\n  136: static int\tcompress_bidder_free(struct archive_read_filter_bidder *);\n  137  \n  138: static ssize_t\tcompress_filter_read(struct archive_read_filter *, const void **);\n  139: static int\tcompress_filter_close(struct archive_read_filter *);\n  140  \n  141: static int\tgetbits(struct archive_read_filter *, int n);\n  142: static int\tnext_code(struct archive_read_filter *);\n  143  \n  144  #if ARCHIVE_VERSION_NUMBER < 4000000\n  145  /* Deprecated; remove in libarchive 4.0 */\n  146  int\n  147: archive_read_support_compression_compress(struct archive *a)\n  148  {\n  149  \treturn archive_read_support_filter_compress(a);\n  ...\n  152  \n  153  int\n  154: archive_read_support_filter_compress(struct archive *_a)\n  155  {\n  156: \tstruct archive_read *a = (struct archive_read *)_a;\n  157: \tstruct archive_read_filter_bidder *bidder;\n  158  \n  159  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n  ...\n  177   */\n  178  static int\n  179: compress_bidder_bid(struct archive_read_filter_bidder *self,\n  180:     struct archive_read_filter *filter)\n  181  {\n  182  \tconst unsigned char *buffer;\n  ...\n  210   */\n  211  static int\n  212: compress_bidder_init(struct archive_read_filter *self)\n  213  {\n  214: \tstruct private_data *state;\n  215  \tstatic const size_t out_block_size = 64 * 1024;\n  216  \tvoid *out_block;\n  ...\n  220  \tself->name = \"compress (.Z)\";\n  221  \n  222: \tstate = (struct private_data *)calloc(sizeof(*state), 1);\n  223  \tout_block = malloc(out_block_size);\n  224  \tif (state == NULL || out_block == NULL) {\n  ...\n  276   */\n  277  static ssize_t\n  278: compress_filter_read(struct archive_read_filter *self, const void **pblock)\n  279  {\n  280: \tstruct private_data *state;\n  281  \tunsigned char *p, *start, *end;\n  282  \tint ret;\n  283  \n  284: \tstate = (struct private_data *)self->data;\n  285  \tif (state->end_of_stream) {\n  286  \t\t*pblock = NULL;\n  ...\n  310   */\n  311  static int\n  312: compress_bidder_free(struct archive_read_filter_bidder *self)\n  313  {\n  314  \tself->data = NULL;\n  ...\n  320   */\n  321  static int\n  322: compress_filter_close(struct archive_read_filter *self)\n  323  {\n  324: \tstruct private_data *state = (struct private_data *)self->data;\n  325  \n  326  \tfree(state->out_block);\n  ...\n  335   */\n  336  static int\n  337: next_code(struct archive_read_filter *self)\n  338  {\n  339: \tstruct private_data *state = (struct private_data *)self->data;\n  340  \tint code, newcode;\n  341  \n  ...\n  426   */\n  427  static int\n  428: getbits(struct archive_read_filter *self, int n)\n  429  {\n  430: \tstruct private_data *state = (struct private_data *)self->data;\n  431  \tint code;\n  432  \tssize_t ret;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_disk_private.h:\n   38  #include \"archive_entry.h\"\n   39  \n   40: struct archive_write_disk;\n   41  \n   42: int archive_write_disk_set_acls(struct archive *, int, const char *,\n   43:     struct archive_acl *, __LA_MODE_T);\n   44  \n   45  #endif\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_mtree.c:\n   49  \t(F_FLAGS | F_GID | F_GNAME | F_MODE | F_TYPE | F_UID | F_UNAME)\n   50  \n   51: struct attr_counter {\n   52: \tstruct attr_counter *prev;\n   53: \tstruct attr_counter *next;\n   54: \tstruct mtree_entry *m_entry;\n   55  \tint count;\n   56  };\n   57  \n   58: struct att_counter_set {\n   59: \tstruct attr_counter *uid_list;\n   60: \tstruct attr_counter *gid_list;\n   61: \tstruct attr_counter *mode_list;\n   62: \tstruct attr_counter *flags_list;\n   63  };\n   64  \n   65: struct mtree_chain {\n   66: \tstruct mtree_entry *first;\n   67: \tstruct mtree_entry **last;\n   68  };\n   69  \n   ..\n   71   * The Data only for a directory file.\n   72   */\n   73: struct dir_info {\n   74: \tstruct archive_rb_tree rbtree;\n   75: \tstruct mtree_chain children;\n   76: \tstruct mtree_entry *chnext;\n   77  \tint virtual;\n   78  };\n   ..\n   81   * The Data only for a regular file.\n   82   */\n   83: struct reg_info {\n   84  \tint compute_sum;\n   85  \tuint32_t crc;\n   86: \tstruct ae_digest digest;\n   87  };\n   88  \n   89: struct mtree_entry {\n   90: \tstruct archive_rb_node rbnode;\n   91: \tstruct mtree_entry *next;\n   92: \tstruct mtree_entry *parent;\n   93: \tstruct dir_info *dir_info;\n   94: \tstruct reg_info *reg_info;\n   95  \n   96: \tstruct archive_string parentdir;\n   97: \tstruct archive_string basename;\n   98: \tstruct archive_string pathname;\n   99: \tstruct archive_string symlink;\n  100: \tstruct archive_string uname;\n  101: \tstruct archive_string gname;\n  102: \tstruct archive_string fflags_text;\n  103  \tunsigned int nlink;\n  104  \tmode_t filetype;\n  ...\n  118  };\n  119  \n  120: struct mtree_writer {\n  121: \tstruct mtree_entry *mtree_entry;\n  122: \tstruct mtree_entry *root;\n  123: \tstruct mtree_entry *cur_dirent;\n  124: \tstruct archive_string cur_dirstr;\n  125: \tstruct mtree_chain file_list;\n  126  \n  127: \tstruct archive_string ebuf;\n  128: \tstruct archive_string buf;\n  129  \tint first;\n  130  \tuint64_t entry_bytes_remaining;\n  ...\n  133  \t * Set global value.\n  134  \t */\n  135: \tstruct {\n  136  \t\tint\t\tprocessing;\n  137  \t\tmode_t\t\ttype;\n  ...\n  143  \t\tunsigned long\tfflags_clear;\n  144  \t} set;\n  145: \tstruct att_counter_set\tacs;\n  146  \tint classic;\n  147  \tint depth;\n  ...\n  216  #define attr_counter_set_reset\tattr_counter_set_free\n  217  \n  218: static void attr_counter_free(struct attr_counter **);\n  219: static int attr_counter_inc(struct attr_counter **, struct attr_counter *,\n  220: \tstruct attr_counter *, struct mtree_entry *);\n  221: static struct attr_counter * attr_counter_new(struct mtree_entry *,\n  222: \tstruct attr_counter *);\n  223: static int attr_counter_set_collect(struct mtree_writer *,\n  224: \tstruct mtree_entry *);\n  225: static void attr_counter_set_free(struct mtree_writer *);\n  226: static int get_global_set_keys(struct mtree_writer *, struct mtree_entry *);\n  227: static int mtree_entry_add_child_tail(struct mtree_entry *,\n  228: \tstruct mtree_entry *);\n  229: static int mtree_entry_create_virtual_dir(struct archive_write *, const char *,\n  230: \tstruct mtree_entry **);\n  231: static int mtree_entry_cmp_node(const struct archive_rb_node *,\n  232: \tconst struct archive_rb_node *);\n  233: static int mtree_entry_cmp_key(const struct archive_rb_node *, const void *);\n  234: static int mtree_entry_exchange_same_entry(struct archive_write *,\n  235:     struct mtree_entry *, struct mtree_entry *);\n  236: static void mtree_entry_free(struct mtree_entry *);\n  237: static int mtree_entry_new(struct archive_write *, struct archive_entry *,\n  238: \tstruct mtree_entry **);\n  239: static void mtree_entry_register_free(struct mtree_writer *);\n  240: static void mtree_entry_register_init(struct mtree_writer *);\n  241: static int mtree_entry_setup_filenames(struct archive_write *,\n  242: \tstruct mtree_entry *, struct archive_entry *);\n  243: static int mtree_entry_tree_add(struct archive_write *, struct mtree_entry **);\n  244: static void sum_init(struct mtree_writer *);\n  245: static void sum_update(struct mtree_writer *, const void *, size_t);\n  246: static void sum_final(struct mtree_writer *, struct reg_info *);\n  247: static void sum_write(struct archive_string *, struct reg_info *);\n  248: static int write_mtree_entry(struct archive_write *, struct mtree_entry *);\n  249: static int write_dot_dot_entry(struct archive_write *, struct mtree_entry *);\n  250  \n  251  #define\tCOMPUTE_CRC(var, ch)\t(var) = (var) << 8 ^ crctab[(var) >> 24 ^ (ch)]\n  ...\n  331  \n  332  static void\n  333: mtree_quote(struct archive_string *s, const char *str)\n  334  {\n  335  \tconst char *start;\n  ...\n  359   */\n  360  static void\n  361: mtree_indent(struct mtree_writer *mtree)\n  362  {\n  363  \tint i, fn, nd, pd;\n  ...\n  435   */\n  436  static void\n  437: write_global(struct mtree_writer *mtree)\n  438  {\n  439: \tstruct archive_string setstr;\n  440: \tstruct archive_string unsetstr;\n  441: \tstruct att_counter_set *acs;\n  442  \tint keys, oldkeys, effkeys;\n  443  \n  ...\n  564  }\n  565  \n  566: static struct attr_counter *\n  567: attr_counter_new(struct mtree_entry *me, struct attr_counter *prev)\n  568  {\n  569: \tstruct attr_counter *ac;\n  570  \n  571  \tac = malloc(sizeof(*ac));\n  ...\n  580  \n  581  static void\n  582: attr_counter_free(struct attr_counter **top)\n  583  {\n  584: \tstruct attr_counter *ac, *tac;\n  585  \n  586  \tif (*top == NULL)\n  ...\n  596  \n  597  static int\n  598: attr_counter_inc(struct attr_counter **top, struct attr_counter *ac,\n  599:     struct attr_counter *last, struct mtree_entry *me)\n  600  {\n  601: \tstruct attr_counter *pac;\n  602  \n  603  \tif (ac != NULL) {\n  ...\n  637   */\n  638  static int\n  639: attr_counter_set_collect(struct mtree_writer *mtree, struct mtree_entry *me)\n  640  {\n  641: \tstruct attr_counter *ac, *last;\n  642: \tstruct att_counter_set *acs = &mtree->acs;\n  643  \tint keys = mtree->keys;\n  644  \n  ...\n  714  \n  715  static void\n  716: attr_counter_set_free(struct mtree_writer *mtree)\n  717  {\n  718: \tstruct att_counter_set *acs = &mtree->acs;\n  719  \n  720  \tattr_counter_free(&acs->uid_list);\n  ...\n  725  \n  726  static int\n  727: get_global_set_keys(struct mtree_writer *mtree, struct mtree_entry *me)\n  728  {\n  729  \tint keys;\n  ...\n  773  \n  774  static int\n  775: mtree_entry_new(struct archive_write *a, struct archive_entry *entry,\n  776:     struct mtree_entry **m_entry)\n  777  {\n  778: \tstruct mtree_entry *me;\n  779  \tconst char *s;\n  780  \tint r;\n  781: \tstatic const struct archive_rb_tree_ops rb_ops = {\n  782  \t\tmtree_entry_cmp_node, mtree_entry_cmp_key\n  783  \t};\n  ...\n  850  \n  851  static void\n  852: mtree_entry_free(struct mtree_entry *me)\n  853  {\n  854  \tarchive_string_free(&me->parentdir);\n  ...\n  865  \n  866  static int\n  867: archive_write_mtree_header(struct archive_write *a,\n  868:     struct archive_entry *entry)\n  869  {\n  870: \tstruct mtree_writer *mtree= a->format_data;\n  871: \tstruct mtree_entry *mtree_entry;\n  872  \tint r, r2;\n  873  \n  ...\n  905  \n  906  static int\n  907: write_mtree_entry(struct archive_write *a, struct mtree_entry *me)\n  908  {\n  909: \tstruct mtree_writer *mtree = a->format_data;\n  910: \tstruct archive_string *str;\n  911  \tint keys, ret;\n  912  \n  ...\n 1055  \n 1056  static int\n 1057: write_dot_dot_entry(struct archive_write *a, struct mtree_entry *n)\n 1058  {\n 1059: \tstruct mtree_writer *mtree = a->format_data;\n 1060  \tint ret;\n 1061  \n ....\n 1090   */\n 1091  static int\n 1092: write_mtree_entry_tree(struct archive_write *a)\n 1093  {\n 1094: \tstruct mtree_writer *mtree = a->format_data;\n 1095: \tstruct mtree_entry *np = mtree->root;\n 1096: \tstruct archive_rb_node *n;\n 1097  \tint ret;\n 1098  \n ....\n 1105  \t\t\tattr_counter_set_reset(mtree);\n 1106  \t\t\tARCHIVE_RB_TREE_FOREACH(n, &(np->dir_info->rbtree)) {\n 1107: \t\t\t\tstruct mtree_entry *e = (struct mtree_entry *)n;\n 1108  \t\t\t\tif (attr_counter_set_collect(mtree, e) < 0) {\n 1109  \t\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n ....\n 1131  \t\tmtree->depth++;\n 1132  \t\tARCHIVE_RB_TREE_FOREACH(n, &(np->dir_info->rbtree)) {\n 1133: \t\t\tstruct mtree_entry *e = (struct mtree_entry *)n;\n 1134  \n 1135  \t\t\tif (e->dir_info)\n ....\n 1191  \n 1192  static int\n 1193: archive_write_mtree_finish_entry(struct archive_write *a)\n 1194  {\n 1195: \tstruct mtree_writer *mtree = a->format_data;\n 1196: \tstruct mtree_entry *me;\n 1197  \n 1198  \tif ((me = mtree->mtree_entry) == NULL)\n ....\n 1207  \n 1208  static int\n 1209: archive_write_mtree_close(struct archive_write *a)\n 1210  {\n 1211: \tstruct mtree_writer *mtree= a->format_data;\n 1212  \tint ret;\n 1213  \n ....\n 1224  \n 1225  static ssize_t\n 1226: archive_write_mtree_data(struct archive_write *a, const void *buff, size_t n)\n 1227  {\n 1228: \tstruct mtree_writer *mtree= a->format_data;\n 1229  \n 1230  \tif (n > mtree->entry_bytes_remaining)\n ....\n 1243  \n 1244  static int\n 1245: archive_write_mtree_free(struct archive_write *a)\n 1246  {\n 1247: \tstruct mtree_writer *mtree= a->format_data;\n 1248  \n 1249  \tif (mtree == NULL)\n ....\n 1262  \n 1263  static int\n 1264: archive_write_mtree_options(struct archive_write *a, const char *key,\n 1265      const char *value)\n 1266  {\n 1267: \tstruct mtree_writer *mtree= a->format_data;\n 1268  \tint keybit = 0;\n 1269  \n ....\n 1374  \n 1375  static int\n 1376: archive_write_set_format_mtree_default(struct archive *_a, const char *fn)\n 1377  {\n 1378: \tstruct archive_write *a = (struct archive_write *)_a;\n 1379: \tstruct mtree_writer *mtree;\n 1380  \n 1381  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC, ARCHIVE_STATE_NEW, fn);\n ....\n 1414  \n 1415  int\n 1416: archive_write_set_format_mtree(struct archive *_a)\n 1417  {\n 1418  \treturn archive_write_set_format_mtree_default(_a,\n ....\n 1421  \n 1422  int\n 1423: archive_write_set_format_mtree_classic(struct archive *_a)\n 1424  {\n 1425  \tint r;\n ....\n 1428  \t\t\"archive_write_set_format_mtree_classic\");\n 1429  \tif (r == ARCHIVE_OK) {\n 1430: \t\tstruct archive_write *a = (struct archive_write *)_a;\n 1431: \t\tstruct mtree_writer *mtree;\n 1432  \n 1433: \t\tmtree = (struct mtree_writer *)a->format_data;\n 1434  \n 1435  \t\t/* Set to output a mtree archive in classic format. */\n ....\n 1443  \n 1444  static void\n 1445: sum_init(struct mtree_writer *mtree)\n 1446  {\n 1447  \n ....\n 1504  \n 1505  static void\n 1506: sum_update(struct mtree_writer *mtree, const void *buff, size_t n)\n 1507  {\n 1508  \tif (mtree->compute_sum & F_CKSUM) {\n ....\n 1544  \n 1545  static void\n 1546: sum_final(struct mtree_writer *mtree, struct reg_info *reg)\n 1547  {\n 1548  \n ....\n 1586      defined(ARCHIVE_HAS_SHA384) || defined(ARCHIVE_HAS_SHA512)\n 1587  static void\n 1588: strappend_bin(struct archive_string *s, const unsigned char *bin, int n)\n 1589  {\n 1590  \tstatic const char hex[] = \"0123456789abcdef\";\n ....\n 1599  \n 1600  static void\n 1601: sum_write(struct archive_string *str, struct reg_info *reg)\n 1602  {\n 1603  \n ....\n 1650  \n 1651  static int\n 1652: mtree_entry_cmp_node(const struct archive_rb_node *n1,\n 1653:     const struct archive_rb_node *n2)\n 1654  {\n 1655: \tconst struct mtree_entry *e1 = (const struct mtree_entry *)n1;\n 1656: \tconst struct mtree_entry *e2 = (const struct mtree_entry *)n2;\n 1657  \n 1658  \treturn (strcmp(e2->basename.s, e1->basename.s));\n ....\n 1660  \n 1661  static int\n 1662: mtree_entry_cmp_key(const struct archive_rb_node *n, const void *key)\n 1663  {\n 1664: \tconst struct mtree_entry *e = (const struct mtree_entry *)n;\n 1665  \n 1666  \treturn (strcmp((const char *)key, e->basename.s));\n ....\n 1708   */\n 1709  static int\n 1710: mtree_entry_setup_filenames(struct archive_write *a, struct mtree_entry *file,\n 1711:     struct archive_entry *entry)\n 1712  {\n 1713  \tconst char *pathname;\n ....\n 1723  \tif (cleanup_backslash_1(file->pathname.s) != 0) {\n 1724  \t\tconst wchar_t *wp = archive_entry_pathname_w(entry);\n 1725: \t\tstruct archive_wstring ws;\n 1726  \n 1727  \t\tif (wp != NULL) {\n ....\n 1838  \t */\n 1839  \tif (strcmp(p, \".\") != 0 && strncmp(p, \"./\", 2) != 0) {\n 1840: \t\tstruct archive_string as;\n 1841  \t\tarchive_string_init(&as);\n 1842  \t\tarchive_strcpy(&as, \"./\");\n ....\n 1875  \n 1876  static int\n 1877: mtree_entry_create_virtual_dir(struct archive_write *a, const char *pathname,\n 1878:     struct mtree_entry **m_entry)\n 1879  {\n 1880: \tstruct archive_entry *entry;\n 1881: \tstruct mtree_entry *file;\n 1882  \tint r;\n 1883  \n ....\n 1909  \n 1910  static void\n 1911: mtree_entry_register_add(struct mtree_writer *mtree, struct mtree_entry *file)\n 1912  {\n 1913          file->next = NULL;\n ....\n 1917  \n 1918  static void\n 1919: mtree_entry_register_init(struct mtree_writer *mtree)\n 1920  {\n 1921  \tmtree->file_list.first = NULL;\n ....\n 1924  \n 1925  static void\n 1926: mtree_entry_register_free(struct mtree_writer *mtree)\n 1927  {\n 1928: \tstruct mtree_entry *file, *file_next;\n 1929  \n 1930  \tfile = mtree->file_list.first;\n ....\n 1937  \n 1938  static int\n 1939: mtree_entry_add_child_tail(struct mtree_entry *parent,\n 1940:     struct mtree_entry *child)\n 1941  {\n 1942  \tchild->dir_info->chnext = NULL;\n ....\n 1949   * Find a entry from a parent entry with the name.\n 1950   */\n 1951: static struct mtree_entry *\n 1952: mtree_entry_find_child(struct mtree_entry *parent, const char *child_name)\n 1953  {\n 1954: \tstruct mtree_entry *np;\n 1955  \n 1956  \tif (parent == NULL)\n 1957  \t\treturn (NULL);\n 1958: \tnp = (struct mtree_entry *)__archive_rb_tree_find_node(\n 1959  \t    &(parent->dir_info->rbtree), child_name);\n 1960  \treturn (np);\n ....\n 1985   */\n 1986  static int\n 1987: mtree_entry_tree_add(struct archive_write *a, struct mtree_entry **filep)\n 1988  {\n 1989  #if defined(_WIN32) && !defined(__CYGWIN__)\n ....\n 1994  \tchar name[256];\n 1995  #endif\n 1996: \tstruct mtree_writer *mtree = (struct mtree_writer *)a->format_data;\n 1997: \tstruct mtree_entry *dent, *file, *np;\n 1998  \tconst char *fn, *p;\n 1999  \tint l, r;\n ....\n 2032  \t\tif (!__archive_rb_tree_insert_node(\n 2033  \t\t    &(mtree->cur_dirent->dir_info->rbtree),\n 2034: \t\t    (struct archive_rb_node *)file)) {\n 2035  \t\t\t/* There is the same name in the tree. */\n 2036: \t\t\tnp = (struct mtree_entry *)__archive_rb_tree_find_node(\n 2037  \t\t\t    &(mtree->cur_dirent->dir_info->rbtree),\n 2038  \t\t\t    file->basename.s);\n ....\n 2088  \t\t */\n 2089  \t\twhile (fn[0] != '\\0') {\n 2090: \t\t\tstruct mtree_entry *vp;\n 2091: \t\t\tstruct archive_string as;\n 2092  \n 2093  \t\t\tarchive_string_init(&as);\n ....\n 2108  \t\t\t\t__archive_rb_tree_insert_node(\n 2109  \t\t\t\t    &(dent->dir_info->rbtree),\n 2110: \t\t\t\t    (struct archive_rb_node *)vp);\n 2111  \t\t\t\tvp->parent = dent;\n 2112  \t\t\t}\n ....\n 2151  \t\tif (!__archive_rb_tree_insert_node(\n 2152  \t\t    &(dent->dir_info->rbtree),\n 2153: \t\t    (struct archive_rb_node *)file)) {\n 2154: \t\t\tnp = (struct mtree_entry *)__archive_rb_tree_find_node(\n 2155  \t\t\t    &(dent->dir_info->rbtree), file->basename.s);\n 2156  \t\t\tgoto same_entry;\n ....\n 2177  \n 2178  static int\n 2179: mtree_entry_exchange_same_entry(struct archive_write *a, struct mtree_entry *np,\n 2180:     struct mtree_entry *file)\n 2181  {\n 2182  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_lha.c:\n   64  #define PT_BITLEN_SIZE\t\t(3 + 16)\n   65  \n   66: struct lzh_dec {\n   67  \t/* Decoding status. */\n   68  \tint     \t\t state;\n   ..\n   87  \t * Bit stream reader.\n   88  \t */\n   89: \tstruct lzh_br {\n   90  #define CACHE_TYPE\t\tuint64_t\n   91  #define CACHE_BITS\t\t(8 * sizeof(CACHE_TYPE))\n   ..\n   99  \t * Huffman coding.\n  100  \t */\n  101: \tstruct huffman {\n  102  \t\tint\t\t len_size;\n  103  \t\tint\t\t len_avail;\n  ...\n  120  \t\tuint16_t\t*tbl;\n  121  \t\t/* Binary tree table for extra bits over the direct access. */\n  122: \t\tstruct htree_t {\n  123  \t\t\tuint16_t left;\n  124  \t\t\tuint16_t right;\n  ...\n  136  };\n  137  \n  138: struct lzh_stream {\n  139  \tconst unsigned char\t*next_in;\n  140  \tint\t\t\t avail_in;\n  ...\n  143  \tint\t\t\t avail_out;\n  144  \tint64_t\t\t\t total_out;\n  145: \tstruct lzh_dec\t\t*ds;\n  146  };\n  147  \n  148: struct lha {\n  149  \t/* entry_bytes_remaining is the number of bytes we expect.\t    */\n  150  \tint64_t                  entry_offset;\n  ...\n  172  \tint64_t\t\t\t uid;\n  173  \tint64_t\t\t\t gid;\n  174: \tstruct archive_string \t uname;\n  175: \tstruct archive_string \t gname;\n  176  \tuint16_t\t\t header_crc;\n  177  \tuint16_t\t\t crc;\n  178  \t/* dirname and filename could be in different codepages */\n  179: \tstruct archive_string_conv *sconv_dir;\n  180: \tstruct archive_string_conv *sconv_fname;\n  181: \tstruct archive_string_conv *opt_sconv;\n  182  \n  183: \tstruct archive_string \t dirname;\n  184: \tstruct archive_string \t filename;\n  185: \tstruct archive_wstring\t ws;\n  186  \n  187  \tunsigned char\t\t dos_attr;\n  ...\n  200  \tchar\t\t\t format_name[64];\n  201  \n  202: \tstruct lzh_stream\t strm;\n  203  };\n  204  \n  ...\n  211  #define H_SIZE\t\t22\t/* Minimum header size. */\n  212  \n  213: static int      archive_read_format_lha_bid(struct archive_read *, int);\n  214: static int      archive_read_format_lha_options(struct archive_read *,\n  215  \t\t    const char *, const char *);\n  216: static int\tarchive_read_format_lha_read_header(struct archive_read *,\n  217: \t\t    struct archive_entry *);\n  218: static int\tarchive_read_format_lha_read_data(struct archive_read *,\n  219  \t\t    const void **, size_t *, int64_t *);\n  220: static int\tarchive_read_format_lha_read_data_skip(struct archive_read *);\n  221: static int\tarchive_read_format_lha_cleanup(struct archive_read *);\n  222  \n  223: static void\tlha_replace_path_separator(struct lha *,\n  224: \t\t    struct archive_entry *);\n  225: static int\tlha_read_file_header_0(struct archive_read *, struct lha *);\n  226: static int\tlha_read_file_header_1(struct archive_read *, struct lha *);\n  227: static int\tlha_read_file_header_2(struct archive_read *, struct lha *);\n  228: static int\tlha_read_file_header_3(struct archive_read *, struct lha *);\n  229: static int\tlha_read_file_extended_header(struct archive_read *,\n  230: \t\t    struct lha *, uint16_t *, int, size_t, size_t *);\n  231  static size_t\tlha_check_header_format(const void *);\n  232: static int\tlha_skip_sfx(struct archive_read *);\n  233  static time_t\tlha_dos_time(const unsigned char *);\n  234  static time_t\tlha_win_time(uint64_t, long *);\n  235  static unsigned char\tlha_calcsum(unsigned char, const void *,\n  236  \t\t    int, size_t);\n  237: static int\tlha_parse_linkname(struct archive_wstring *,\n  238: \t\t    struct archive_wstring *);\n  239: static int\tlha_read_data_none(struct archive_read *, const void **,\n  240  \t\t    size_t *, int64_t *);\n  241: static int\tlha_read_data_lzh(struct archive_read *, const void **,\n  242  \t\t    size_t *, int64_t *);\n  243  static void\tlha_crc16_init(void);\n  244  static uint16_t lha_crc16(uint16_t, const void *, size_t);\n  245: static int\tlzh_decode_init(struct lzh_stream *, const char *);\n  246: static void\tlzh_decode_free(struct lzh_stream *);\n  247: static int\tlzh_decode(struct lzh_stream *, int);\n  248: static int\tlzh_br_fillup(struct lzh_stream *, struct lzh_br *);\n  249: static int\tlzh_huffman_init(struct huffman *, size_t, int);\n  250: static void\tlzh_huffman_free(struct huffman *);\n  251: static int\tlzh_read_pt_bitlen(struct lzh_stream *, int start, int end);\n  252: static int\tlzh_make_fake_table(struct huffman *, uint16_t);\n  253: static int\tlzh_make_huffman_table(struct huffman *);\n  254: static inline int lzh_decode_huffman(struct huffman *, unsigned);\n  255: static int\tlzh_decode_huffman_tree(struct huffman *, unsigned, int);\n  256  \n  257  \n  258  int\n  259: archive_read_support_format_lha(struct archive *_a)\n  260  {\n  261: \tstruct archive_read *a = (struct archive_read *)_a;\n  262: \tstruct lha *lha;\n  263  \tint r;\n  264  \n  ...\n  266  \t    ARCHIVE_STATE_NEW, \"archive_read_support_format_lha\");\n  267  \n  268: \tlha = (struct lha *)calloc(1, sizeof(*lha));\n  269  \tif (lha == NULL) {\n  270  \t\tarchive_set_error(&a->archive, ENOMEM,\n  ...\n  346  \n  347  static int\n  348: archive_read_format_lha_bid(struct archive_read *a, int best_bid)\n  349  {\n  350  \tconst char *p;\n  ...\n  391  \n  392  static int\n  393: archive_read_format_lha_options(struct archive_read *a,\n  394      const char *key, const char *val)\n  395  {\n  396: \tstruct lha *lha;\n  397  \tint ret = ARCHIVE_FAILED;\n  398  \n  399: \tlha = (struct lha *)(a->format->data);\n  400  \tif (strcmp(key, \"hdrcharset\")  == 0) {\n  401  \t\tif (val == NULL || val[0] == 0)\n  ...\n  421  \n  422  static int\n  423: lha_skip_sfx(struct archive_read *a)\n  424  {\n  425  \tconst void *h;\n  ...\n  465  \n  466  static int\n  467: truncated_error(struct archive_read *a)\n  468  {\n  469  \tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n  ...\n  473  \n  474  static int\n  475: archive_read_format_lha_read_header(struct archive_read *a,\n  476:     struct archive_entry *entry)\n  477  {\n  478: \tstruct archive_wstring linkname;\n  479: \tstruct archive_wstring pathname;\n  480: \tstruct lha *lha;\n  481  \tconst unsigned char *p;\n  482  \tconst char *signature;\n  483  \tint err;\n  484: \tstruct archive_mstring conv_buffer;\n  485  \tconst wchar_t *conv_buffer_p;\n  486  \n  ...\n  491  \t\ta->archive.archive_format_name = \"lha\";\n  492  \n  493: \tlha = (struct lha *)(a->format->data);\n  494  \tlha->decompress_init = 0;\n  495  \tlha->end_of_entry = 0;\n  ...\n  752   */\n  753  static void\n  754: lha_replace_path_separator(struct lha *lha, struct archive_entry *entry)\n  755  {\n  756  \tconst wchar_t *wp;\n  ...\n  808  #define H0_FIXED_SIZE\t\t24\n  809  static int\n  810: lha_read_file_header_0(struct archive_read *a, struct lha *lha)\n  811  {\n  812  \tconst unsigned char *p;\n  ...\n  902  #define H1_FIXED_SIZE\t\t27\n  903  static int\n  904: lha_read_file_header_1(struct archive_read *a, struct lha *lha)\n  905  {\n  906  \tconst unsigned char *p;\n  ...\n  998  #define H2_FIXED_SIZE\t\t24\n  999  static int\n 1000: lha_read_file_header_2(struct archive_read *a, struct lha *lha)\n 1001  {\n 1002  \tconst unsigned char *p;\n ....\n 1077  #define H3_FIXED_SIZE\t\t28\n 1078  static int\n 1079: lha_read_file_header_3(struct archive_read *a, struct lha *lha)\n 1080  {\n 1081  \tconst unsigned char *p;\n ....\n 1134   */\n 1135  static int\n 1136: lha_read_file_extended_header(struct archive_read *a, struct lha *lha,\n 1137      uint16_t *crc, int sizefield_length, size_t limitsize, size_t *total_size)\n 1138  {\n ....\n 1351  \t\t\t * hdrcharset option. */\n 1352  \t\t\tif (datasize == sizeof(uint32_t)) {\n 1353: \t\t\t\tstruct archive_string cp;\n 1354  \t\t\t\tconst char *charset;\n 1355  \n ....\n 1444  \n 1445  static int\n 1446: lha_end_of_entry(struct archive_read *a)\n 1447  {\n 1448: \tstruct lha *lha = (struct lha *)(a->format->data);\n 1449  \tint r = ARCHIVE_EOF;\n 1450  \n ....\n 1464  \n 1465  static int\n 1466: archive_read_format_lha_read_data(struct archive_read *a,\n 1467      const void **buff, size_t *size, int64_t *offset)\n 1468  {\n 1469: \tstruct lha *lha = (struct lha *)(a->format->data);\n 1470  \tint r;\n 1471  \n ....\n 1497   */\n 1498  static int\n 1499: lha_read_data_none(struct archive_read *a, const void **buff,\n 1500      size_t *size, int64_t *offset)\n 1501  {\n 1502: \tstruct lha *lha = (struct lha *)(a->format->data);\n 1503  \tssize_t bytes_avail;\n 1504  \n ....\n 1544   */\n 1545  static int\n 1546: lha_read_data_lzh(struct archive_read *a, const void **buff,\n 1547      size_t *size, int64_t *offset)\n 1548  {\n 1549: \tstruct lha *lha = (struct lha *)(a->format->data);\n 1550  \tssize_t bytes_avail;\n 1551  \tint r;\n ....\n 1636   */\n 1637  static int\n 1638: archive_read_format_lha_read_data_skip(struct archive_read *a)\n 1639  {\n 1640: \tstruct lha *lha;\n 1641  \tint64_t bytes_skipped;\n 1642  \n 1643: \tlha = (struct lha *)(a->format->data);\n 1644  \n 1645  \tif (lha->entry_unconsumed) {\n ....\n 1667  \n 1668  static int\n 1669: archive_read_format_lha_cleanup(struct archive_read *a)\n 1670  {\n 1671: \tstruct lha *lha = (struct lha *)(a->format->data);\n 1672  \n 1673  \tlzh_decode_free(&(lha->strm));\n ....\n 1693   */\n 1694  static int\n 1695: lha_parse_linkname(struct archive_wstring *linkname,\n 1696:     struct archive_wstring *pathname)\n 1697  {\n 1698  \twchar_t *\tlinkptr;\n ....\n 1717  {\n 1718  \tint msTime, msDate;\n 1719: \tstruct tm ts;\n 1720  \n 1721  \tmsTime = archive_le16dec(p);\n ....\n 1857   */\n 1858  static int\n 1859: lzh_decode_init(struct lzh_stream *strm, const char *method)\n 1860  {\n 1861: \tstruct lzh_dec *ds;\n 1862  \tint w_bits, w_size;\n 1863  \n ....\n 1921   */\n 1922  static void\n 1923: lzh_decode_free(struct lzh_stream *strm)\n 1924  {\n 1925  \n ....\n 1978   */\n 1979  static int\n 1980: lzh_br_fillup(struct lzh_stream *strm, struct lzh_br *br)\n 1981  {\n 1982  \tint n = CACHE_BITS - br->cache_avail;\n ....\n 2068   *    is dummy, not the file data.\n 2069   */\n 2070: static int\tlzh_read_blocks(struct lzh_stream *, int);\n 2071: static int\tlzh_decode_blocks(struct lzh_stream *, int);\n 2072  #define ST_RD_BLOCK\t\t0\n 2073  #define ST_RD_PT_1\t\t1\n ....\n 2085  \n 2086  static int\n 2087: lzh_decode(struct lzh_stream *strm, int last)\n 2088  {\n 2089: \tstruct lzh_dec *ds = strm->ds;\n 2090  \tint avail_in;\n 2091  \tint r;\n ....\n 2106  \n 2107  static void\n 2108: lzh_emit_window(struct lzh_stream *strm, size_t s)\n 2109  {\n 2110  \tstrm->ref_ptr = strm->ds->w_buff;\n ....\n 2114  \n 2115  static int\n 2116: lzh_read_blocks(struct lzh_stream *strm, int last)\n 2117  {\n 2118: \tstruct lzh_dec *ds = strm->ds;\n 2119: \tstruct lzh_br *br = &(ds->br);\n 2120  \tint c = 0, i;\n 2121  \tunsigned rbits;\n ....\n 2349  \n 2350  static int\n 2351: lzh_decode_blocks(struct lzh_stream *strm, int last)\n 2352  {\n 2353: \tstruct lzh_dec *ds = strm->ds;\n 2354: \tstruct lzh_br bre = ds->br;\n 2355: \tstruct huffman *lt = &(ds->lt);\n 2356: \tstruct huffman *pt = &(ds->pt);\n 2357  \tunsigned char *w_buff = ds->w_buff;\n 2358  \tunsigned char *lt_bitlen = lt->bitlen;\n ....\n 2539  \n 2540  static int\n 2541: lzh_huffman_init(struct huffman *hf, size_t len_size, int tbl_bits)\n 2542  {\n 2543  \tint bits;\n ....\n 2569  \n 2570  static void\n 2571: lzh_huffman_free(struct huffman *hf)\n 2572  {\n 2573  \tfree(hf->bitlen);\n ....\n 2643  };\n 2644  static int\n 2645: lzh_read_pt_bitlen(struct lzh_stream *strm, int start, int end)\n 2646  {\n 2647: \tstruct lzh_dec *ds = strm->ds;\n 2648: \tstruct lzh_br *br = &(ds->br);\n 2649  \tint c, i;\n 2650  \n ....\n 2681  \n 2682  static int\n 2683: lzh_make_fake_table(struct huffman *hf, uint16_t c)\n 2684  {\n 2685  \tif (c >= hf->len_size)\n ....\n 2696   */\n 2697  static int\n 2698: lzh_make_huffman_table(struct huffman *hf)\n 2699  {\n 2700  \tuint16_t *tbl;\n ....\n 2764  \t\tuint16_t bit;\n 2765  \t\tint extlen;\n 2766: \t\tstruct htree_t *ht;\n 2767  \n 2768  \t\tif (bitlen[i] == 0)\n ....\n 2877  \n 2878  static int\n 2879: lzh_decode_huffman_tree(struct huffman *hf, unsigned rbits, int c)\n 2880  {\n 2881: \tstruct htree_t *ht;\n 2882  \tint extlen;\n 2883  \n ....\n 2897  \n 2898  static inline int\n 2899: lzh_decode_huffman(struct huffman *hf, unsigned rbits)\n 2900  {\n 2901  \tint c;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_acl_private.h:\n   35  #include \"archive_string.h\"\n   36  \n   37: struct archive_acl_entry {\n   38: \tstruct archive_acl_entry *next;\n   39  \tint\ttype;\t\t\t/* E.g., access or default */\n   40  \tint\ttag;\t\t\t/* E.g., user/group/other/mask */\n   41  \tint\tpermset;\t\t/* r/w/x bits */\n   42  \tint\tid;\t\t\t/* uid/gid for user/group */\n   43: \tstruct archive_mstring name;\t\t/* uname/gname */\n   44  };\n   45  \n   46: struct archive_acl {\n   47  \tmode_t\t\tmode;\n   48: \tstruct archive_acl_entry\t*acl_head;\n   49: \tstruct archive_acl_entry\t*acl_p;\n   50  \tint\t\t acl_state;\t/* See acl_next for details. */\n   51  \twchar_t\t\t*acl_text_w;\n   ..\n   54  };\n   55  \n   56: void archive_acl_clear(struct archive_acl *);\n   57: void archive_acl_copy(struct archive_acl *, struct archive_acl *);\n   58: int archive_acl_count(struct archive_acl *, int);\n   59: int archive_acl_types(struct archive_acl *);\n   60: int archive_acl_reset(struct archive_acl *, int);\n   61: int archive_acl_next(struct archive *, struct archive_acl *, int,\n   62      int *, int *, int *, int *, const char **);\n   63  \n   64: int archive_acl_add_entry(struct archive_acl *, int, int, int, int, const char *);\n   65: int archive_acl_add_entry_w_len(struct archive_acl *,\n   66      int, int, int, int, const wchar_t *, size_t);\n   67: int archive_acl_add_entry_len(struct archive_acl *,\n   68      int, int, int, int, const char *, size_t);\n   69  \n   70: wchar_t *archive_acl_to_text_w(struct archive_acl *, ssize_t *, int,\n   71:     struct archive *);\n   72: char *archive_acl_to_text_l(struct archive_acl *, ssize_t *, int,\n   73:     struct archive_string_conv *);\n   74  \n   75  /*\n   76   * ACL text parser.\n   77   */\n   78: int archive_acl_from_text_w(struct archive_acl *, const wchar_t * /* wtext */,\n   79      int /* type */);\n   80: int archive_acl_from_text_l(struct archive_acl *, const char * /* text */,\n   81:     int /* type */, struct archive_string_conv *);\n   82  \n   83  #endif /* ARCHIVE_ENTRY_PRIVATE_H_INCLUDED */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_warc.c:\n   95  } warc_type_t;\n   96  \n   97: typedef struct {\n   98  \tsize_t len;\n   99  \tconst char *str;\n  100  } warc_string_t;\n  101  \n  102: typedef struct {\n  103  \tsize_t len;\n  104  \tchar *str;\n  105  } warc_strbuf_t;\n  106  \n  107: struct warc_s {\n  108  \t/* content length ahead */\n  109  \tsize_t cntlen;\n  ...\n  118  \tunsigned int pver;\n  119  \t/* stringified format name */\n  120: \tstruct archive_string sver;\n  121  };\n  122  \n  123: static int _warc_bid(struct archive_read *a, int);\n  124: static int _warc_cleanup(struct archive_read *a);\n  125: static int _warc_read(struct archive_read*, const void**, size_t*, int64_t*);\n  126: static int _warc_skip(struct archive_read *a);\n  127: static int _warc_rdhdr(struct archive_read *a, struct archive_entry *e);\n  128  \n  129  /* private routines */\n  ...\n  138  \n  139  int\n  140: archive_read_support_format_warc(struct archive *_a)\n  141  {\n  142: \tstruct archive_read *a = (struct archive_read *)_a;\n  143: \tstruct warc_s *w;\n  144  \tint r;\n  145  \n  ...\n  166  \n  167  static int\n  168: _warc_cleanup(struct archive_read *a)\n  169  {\n  170: \tstruct warc_s *w = a->format->data;\n  171  \n  172  \tif (w->pool.len > 0U) {\n  ...\n  180  \n  181  static int\n  182: _warc_bid(struct archive_read *a, int best_bid)\n  183  {\n  184  \tconst char *hdr;\n  ...\n  209  \n  210  static int\n  211: _warc_rdhdr(struct archive_read *a, struct archive_entry *entry)\n  212  {\n  213  #define HDR_PROBE_LEN\t\t(12U)\n  214: \tstruct warc_s *w = a->format->data;\n  215  \tunsigned int ver;\n  216  \tconst char *buf;\n  ...\n  387  \n  388  static int\n  389: _warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)\n  390  {\n  391: \tstruct warc_s *w = a->format->data;\n  392  \tconst char *rab;\n  393  \tssize_t nrd;\n  ...\n  429  \n  430  static int\n  431: _warc_skip(struct archive_read *a)\n  432  {\n  433: \tstruct warc_s *w = a->format->data;\n  434  \n  435  \t__archive_read_consume(a, w->cntlen + 4U/*\\r\\n\\r\\n separator*/);\n  ...\n  529  \n  530  static time_t\n  531: time_from_tm(struct tm *t)\n  532  {\n  533  #if HAVE_TIMEGM\n  ...\n  557  {\n  558  /** like strptime() but strictly for ISO 8601 Zulu strings */\n  559: \tstruct tm tm;\n  560  \ttime_t res = (time_t)-1;\n  561  \n  ...\n  597  \ttm.tm_mon--;\n  598  \n  599: \t/* now convert our custom tm struct to a unix stamp using UTC */\n  600  \tres = time_from_tm(&tm);\n  601  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/filter_fork_windows.c:\n   40  \tSTARTUPINFOA staInfo;\n   41  \tPROCESS_INFORMATION childInfo;\n   42: \tstruct archive_string cmdline;\n   43: \tstruct archive_string fullpath;\n   44: \tstruct archive_cmdline *acmd;\n   45  \tchar *arg0, *ext;\n   46  \tint i, l;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_data_into_fd.c:\n   47   */\n   48  static int\n   49: pad_to(struct archive *a, int fd, int can_lseek,\n   50      size_t nulls_size, const char *nulls,\n   51      int64_t target_offset, int64_t actual_offset)\n   ..\n   79  \n   80  int\n   81: archive_read_data_into_fd(struct archive *a, int fd)\n   82  {\n   83: \tstruct stat st;\n   84  \tint r, r2;\n   85  \tconst void *buff;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_disk_windows.c:\n   72   */\n   73  \n   74: struct restore_time {\n   75  \tconst wchar_t\t\t*full_path;\n   76  \tFILETIME\t\t lastWriteTime;\n   ..\n   79  };\n   80  \n   81: struct tree_entry {\n   82  \tint\t\t\t depth;\n   83: \tstruct tree_entry\t*next;\n   84: \tstruct tree_entry\t*parent;\n   85  \tsize_t\t\t\t full_path_dir_length;\n   86: \tstruct archive_wstring\t name;\n   87: \tstruct archive_wstring\t full_path;\n   88  \tsize_t\t\t\t dirname_length;\n   89  \tint64_t\t\t\t dev;\n   ..\n   92  \tint\t\t\t filesystem_id;\n   93  \t/* How to restore time of a directory. */\n   94: \tstruct restore_time\t restore_time;\n   95  };\n   96  \n   97: struct filesystem {\n   98  \tint64_t\t\tdev;\n   99  \tint\t\tsynthetic;\n  ...\n  125   * Local data for this package.\n  126   */\n  127: struct tree {\n  128: \tstruct tree_entry\t*stack;\n  129: \tstruct tree_entry\t*current;\n  130  \tHANDLE d;\n  131  \tWIN32_FIND_DATAW\t_findData;\n  ...\n  137  \n  138  \t/* A full path with \"\\\\?\\\" prefix. */\n  139: \tstruct archive_wstring\t full_path;\n  140  \tsize_t\t\t\t full_path_dir_length;\n  141  \t/* Dynamically-sized buffer for holding path */\n  142: \tstruct archive_wstring\t path;\n  143  \n  144  \t/* Last path element */\n  ...\n  153  \tint\t\t\t descend;\n  154  \t/* How to restore time of a file. */\n  155: \tstruct restore_time\trestore_time;\n  156  \n  157: \tstruct entry_sparse {\n  158  \t\tint64_t\t\t length;\n  159  \t\tint64_t\t\t offset;\n  ...\n  164  \tchar\t\t\t initial_symlink_mode;\n  165  \tchar\t\t\t symlink_mode;\n  166: \tstruct filesystem\t*current_filesystem;\n  167: \tstruct filesystem\t*filesystem_table;\n  168  \tint\t\t\t initial_filesystem_id;\n  169  \tint\t\t\t current_filesystem_id;\n  ...\n  182  \tint64_t\t\t\t ol_remaining_bytes;\n  183  \tint64_t\t\t\t ol_total;\n  184: \tstruct la_overlapped {\n  185  \t\tOVERLAPPED\t ol;\n  186: \t\tstruct archive * _a;\n  187  \t\tunsigned char\t*buff;\n  188  \t\tsize_t\t\t buff_size;\n  ...\n  208  \n  209  static int\n  210: tree_dir_next_windows(struct tree *t, const wchar_t *pattern);\n  211  \n  212  /* Initiate/terminate a tree traversal. */\n  213: static struct tree *tree_open(const wchar_t *, int, int);\n  214: static struct tree *tree_reopen(struct tree *, const wchar_t *, int);\n  215: static void tree_close(struct tree *);\n  216: static void tree_free(struct tree *);\n  217: static void tree_push(struct tree *, const wchar_t *, const wchar_t *,\n  218: \t\tint, int64_t, int64_t, struct restore_time *);\n  219  \n  220  /*\n  ...\n  242  #define\tTREE_ERROR_FATAL\t-2\n  243  \n  244: static int tree_next(struct tree *);\n  245  \n  246  /*\n  ...\n  255   *\n  256   */\n  257: static const wchar_t *tree_current_path(struct tree *);\n  258: static const wchar_t *tree_current_access_path(struct tree *);\n  259  \n  260  /*\n  ...\n  264   * than make a redundant stat() or lstat() call of your own.\n  265   */\n  266: static const BY_HANDLE_FILE_INFORMATION *tree_current_stat(struct tree *);\n  267: static const BY_HANDLE_FILE_INFORMATION *tree_current_lstat(struct tree *);\n  268  \n  269  /* The following functions use tricks to avoid a certain number of\n  270   * stat()/lstat() calls. */\n  271  /* \"is_physical_dir\" is equivalent to S_ISDIR(tree_current_lstat()->st_mode) */\n  272: static int tree_current_is_physical_dir(struct tree *);\n  273  /* \"is_physical_link\" is equivalent to S_ISLNK(tree_current_lstat()->st_mode) */\n  274: static int tree_current_is_physical_link(struct tree *);\n  275  /* Instead of archive_entry_copy_stat for BY_HANDLE_FILE_INFORMATION */\n  276: static void tree_archive_entry_copy_bhfi(struct archive_entry *,\n  277: \t\t    struct tree *, const BY_HANDLE_FILE_INFORMATION *);\n  278  /* \"is_dir\" is equivalent to S_ISDIR(tree_current_stat()->st_mode) */\n  279: static int tree_current_is_dir(struct tree *);\n  280: static int update_current_filesystem(struct archive_read_disk *a,\n  281  \t\t    int64_t dev);\n  282: static int setup_current_filesystem(struct archive_read_disk *);\n  283: static int tree_target_is_same_as_parent(struct tree *,\n  284  \t\t    const BY_HANDLE_FILE_INFORMATION *);\n  285  \n  286: static int\t_archive_read_disk_open_w(struct archive *, const wchar_t *);\n  287: static int\t_archive_read_free(struct archive *);\n  288: static int\t_archive_read_close(struct archive *);\n  289: static int\t_archive_read_data_block(struct archive *,\n  290  \t\t    const void **, size_t *, int64_t *);\n  291: static int\t_archive_read_next_header(struct archive *,\n  292: \t\t    struct archive_entry **);\n  293: static int\t_archive_read_next_header2(struct archive *,\n  294: \t\t    struct archive_entry *);\n  295  static const char *trivial_lookup_gname(void *, int64_t gid);\n  296  static const char *trivial_lookup_uname(void *, int64_t uid);\n  297: static int\tsetup_sparse(struct archive_read_disk *, struct archive_entry *);\n  298: static int\tclose_and_restore_time(HANDLE, struct tree *,\n  299: \t\t    struct restore_time *);\n  300: static int\tsetup_sparse_from_disk(struct archive_read_disk *,\n  301: \t\t    struct archive_entry *, HANDLE);\n  302  static int\tla_linkname_from_handle(HANDLE, wchar_t **, int *);\n  303  static int\tla_linkname_from_pathw(const wchar_t *, wchar_t **, int *);\n  304: static void\tentry_symlink_from_pathw(struct archive_entry *,\n  305  \t\t    const wchar_t *path);\n  306  \n  307: typedef struct _REPARSE_DATA_BUFFER {\n  308  \tULONG\tReparseTag;\n  309  \tUSHORT ReparseDataLength;\n  310  \tUSHORT\tReserved;\n  311  \tunion {\n  312: \t\tstruct {\n  313  \t\t\tUSHORT\tSubstituteNameOffset;\n  314  \t\t\tUSHORT\tSubstituteNameLength;\n  ...\n  318  \t\t\tWCHAR\tPathBuffer[1];\n  319  \t\t} SymbolicLinkReparseBuffer;\n  320: \t\tstruct {\n  321  \t\t\tUSHORT\tSubstituteNameOffset;\n  322  \t\t\tUSHORT\tSubstituteNameLength;\n  ...\n  325  \t\t\tWCHAR\tPathBuffer[1];\n  326  \t\t} MountPointReparseBuffer;\n  327: \t\tstruct {\n  328  \t\t\tUCHAR\tDataBuffer[1];\n  329  \t\t} GenericReparseBuffer;\n  ...\n  433  \n  434  static void\n  435: entry_symlink_from_pathw(struct archive_entry *entry, const wchar_t *path)\n  436  {\n  437  \twchar_t *linkname = NULL;\n  ...\n  450  }\n  451  \n  452: static struct archive_vtable *\n  453  archive_read_disk_vtable(void)\n  454  {\n  455: \tstatic struct archive_vtable av;\n  456  \tstatic int inited = 0;\n  457  \n  ...\n  468  \n  469  const char *\n  470: archive_read_disk_gname(struct archive *_a, la_int64_t gid)\n  471  {\n  472: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  473  \tif (ARCHIVE_OK != __archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n  474  \t\tARCHIVE_STATE_ANY, \"archive_read_disk_gname\"))\n  ...\n  480  \n  481  const char *\n  482: archive_read_disk_uname(struct archive *_a, la_int64_t uid)\n  483  {\n  484: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  485  \tif (ARCHIVE_OK != __archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n  486  \t\tARCHIVE_STATE_ANY, \"archive_read_disk_uname\"))\n  ...\n  492  \n  493  int\n  494: archive_read_disk_set_gname_lookup(struct archive *_a,\n  495      void *private_data,\n  496      const char * (*lookup_gname)(void *private, la_int64_t gid),\n  497      void (*cleanup_gname)(void *private))\n  498  {\n  499: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  500  \tarchive_check_magic(&a->archive, ARCHIVE_READ_DISK_MAGIC,\n  501  \t    ARCHIVE_STATE_ANY, \"archive_read_disk_set_gname_lookup\");\n  ...\n  511  \n  512  int\n  513: archive_read_disk_set_uname_lookup(struct archive *_a,\n  514      void *private_data,\n  515      const char * (*lookup_uname)(void *private, int64_t uid),\n  516      void (*cleanup_uname)(void *private))\n  517  {\n  518: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  519  \tarchive_check_magic(&a->archive, ARCHIVE_READ_DISK_MAGIC,\n  520  \t    ARCHIVE_STATE_ANY, \"archive_read_disk_set_uname_lookup\");\n  ...\n  532   * Create a new archive_read_disk object and initialize it with global state.\n  533   */\n  534: struct archive *\n  535  archive_read_disk_new(void)\n  536  {\n  537: \tstruct archive_read_disk *a;\n  538  \n  539: \ta = (struct archive_read_disk *)calloc(1, sizeof(*a));\n  540  \tif (a == NULL)\n  541  \t\treturn (NULL);\n  ...\n  551  \n  552  static int\n  553: _archive_read_free(struct archive *_a)\n  554  {\n  555: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  556  \tint r;\n  557  \n  ...\n  579  \n  580  static int\n  581: _archive_read_close(struct archive *_a)\n  582  {\n  583: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  584  \n  585  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n  ...\n  595  \n  596  static void\n  597: setup_symlink_mode(struct archive_read_disk *a, char symlink_mode, \n  598      int follow_symlinks)\n  599  {\n  ...\n  607  \n  608  int\n  609: archive_read_disk_set_symlink_logical(struct archive *_a)\n  610  {\n  611: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  612  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n  613  \t    ARCHIVE_STATE_ANY, \"archive_read_disk_set_symlink_logical\");\n  ...\n  617  \n  618  int\n  619: archive_read_disk_set_symlink_physical(struct archive *_a)\n  620  {\n  621: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  622  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n  623  \t    ARCHIVE_STATE_ANY, \"archive_read_disk_set_symlink_physical\");\n  ...\n  627  \n  628  int\n  629: archive_read_disk_set_symlink_hybrid(struct archive *_a)\n  630  {\n  631: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  632  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n  633  \t    ARCHIVE_STATE_ANY, \"archive_read_disk_set_symlink_hybrid\");\n  ...\n  637  \n  638  int\n  639: archive_read_disk_set_atime_restored(struct archive *_a)\n  640  {\n  641: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  642  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n  643  \t    ARCHIVE_STATE_ANY, \"archive_read_disk_restore_atime\");\n  ...\n  649  \n  650  int\n  651: archive_read_disk_set_behavior(struct archive *_a, int flags)\n  652  {\n  653: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  654  \tint r = ARCHIVE_OK;\n  655  \n  ...\n  690  \n  691  static int64_t\n  692: align_num_per_sector(struct tree *t, int64_t size)\n  693  {\n  694  \tint64_t surplus;\n  ...\n  701  \n  702  static int\n  703: start_next_async_read(struct archive_read_disk *a, struct tree *t)\n  704  {\n  705: \tstruct la_overlapped *olp;\n  706  \tDWORD buffbytes, rbytes;\n  707  \n  ...\n  793  \n  794  static void\n  795: cancel_async(struct tree *t)\n  796  {\n  797  \tif (t->ol_num_doing != t->ol_num_done) {\n  ...\n  802  \n  803  static int\n  804: _archive_read_data_block(struct archive *_a, const void **buff,\n  805      size_t *size, int64_t *offset)\n  806  {\n  807: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  808: \tstruct tree *t = a->tree;\n  809: \tstruct la_overlapped *olp;\n  810  \tDWORD bytes_transferred;\n  811  \tint r = ARCHIVE_FATAL;\n  ...\n  888  \n  889  static int\n  890: next_entry(struct archive_read_disk *a, struct tree *t,\n  891:     struct archive_entry *entry)\n  892  {\n  893  \tconst BY_HANDLE_FILE_INFORMATION *st;\n  ...\n 1099  \n 1100  static int\n 1101: _archive_read_next_header(struct archive *_a, struct archive_entry **entryp)\n 1102  {\n 1103         int ret;\n 1104:        struct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1105         *entryp = NULL;\n 1106         ret = _archive_read_next_header2(_a, a->entry);\n ....\n 1110  \n 1111  static int\n 1112: _archive_read_next_header2(struct archive *_a, struct archive_entry *entry)\n 1113  {\n 1114: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1115: \tstruct tree *t;\n 1116  \tint r;\n 1117  \n ....\n 1172  \n 1173  static int\n 1174: setup_sparse(struct archive_read_disk *a, struct archive_entry *entry)\n 1175  {\n 1176: \tstruct tree *t = a->tree;\n 1177  \tint64_t aligned, length, offset;\n 1178  \tint i;\n ....\n 1246  \n 1247  int\n 1248: archive_read_disk_set_matching(struct archive *_a, struct archive *_ma,\n 1249:     void (*_excluded_func)(struct archive *, void *, struct archive_entry *),\n 1250      void *_client_data)\n 1251  {\n 1252: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1253  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n 1254  \t    ARCHIVE_STATE_ANY, \"archive_read_disk_set_matching\");\n ....\n 1260  \n 1261  int\n 1262: archive_read_disk_set_metadata_filter_callback(struct archive *_a,\n 1263:     int (*_metadata_filter_func)(struct archive *, void *,\n 1264:     struct archive_entry *), void *_client_data)\n 1265  {\n 1266: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1267  \n 1268  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC, ARCHIVE_STATE_ANY,\n ....\n 1275  \n 1276  int\n 1277: archive_read_disk_can_descend(struct archive *_a)\n 1278  {\n 1279: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1280: \tstruct tree *t = a->tree;\n 1281  \n 1282  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n ....\n 1292   */\n 1293  int\n 1294: archive_read_disk_descend(struct archive *_a)\n 1295  {\n 1296: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1297: \tstruct tree *t = a->tree;\n 1298  \n 1299  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n ....\n 1322  \n 1323  int\n 1324: archive_read_disk_open(struct archive *_a, const char *pathname)\n 1325  {\n 1326: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1327: \tstruct archive_wstring wpath;\n 1328  \tint ret;\n 1329  \n ....\n 1353  \n 1354  int\n 1355: archive_read_disk_open_w(struct archive *_a, const wchar_t *pathname)\n 1356  {\n 1357: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1358  \n 1359  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n ....\n 1366  \n 1367  static int\n 1368: _archive_read_disk_open_w(struct archive *_a, const wchar_t *pathname)\n 1369  {\n 1370: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1371  \n 1372  \tif (a->tree != NULL)\n ....\n 1392   */\n 1393  int\n 1394: archive_read_disk_current_filesystem(struct archive *_a)\n 1395  {\n 1396: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1397  \n 1398  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC, ARCHIVE_STATE_DATA,\n ....\n 1403  \n 1404  static int\n 1405: update_current_filesystem(struct archive_read_disk *a, int64_t dev)\n 1406  {\n 1407: \tstruct tree *t = a->tree;\n 1408  \tint i, fid;\n 1409  \n ....\n 1437  \t\t\treturn (ARCHIVE_FATAL);\n 1438  \t\t}\n 1439: \t\tt->filesystem_table = (struct filesystem *)p;\n 1440  \t\tt->allocated_filesystem = (int)s;\n 1441  \t}\n ....\n 1452   */\n 1453  int\n 1454: archive_read_disk_current_filesystem_is_synthetic(struct archive *_a)\n 1455  {\n 1456: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1457  \n 1458  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC, ARCHIVE_STATE_DATA,\n ....\n 1467   */\n 1468  int\n 1469: archive_read_disk_current_filesystem_is_remote(struct archive *_a)\n 1470  {\n 1471: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1472  \n 1473  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC, ARCHIVE_STATE_DATA,\n ....\n 1482   */\n 1483  static wchar_t *\n 1484: safe_path_for_statfs(struct tree *t)\n 1485  {\n 1486  \tconst wchar_t *path;\n ....\n 1505   */\n 1506  static int\n 1507: setup_current_filesystem(struct archive_read_disk *a)\n 1508  {\n 1509: \tstruct tree *t = a->tree;\n 1510  \twchar_t vol[256];\n 1511  \twchar_t *path;\n ....\n 1547  \n 1548  static int\n 1549: close_and_restore_time(HANDLE h, struct tree *t, struct restore_time *rt)\n 1550  {\n 1551  \tHANDLE handle;\n ....\n 1585   */\n 1586  static void\n 1587: tree_push(struct tree *t, const wchar_t *path, const wchar_t *full_path,\n 1588:     int filesystem_id, int64_t dev, int64_t ino, struct restore_time *rt)\n 1589  {\n 1590: \tstruct tree_entry *te;\n 1591  \n 1592  \tte = calloc(1, sizeof(*te));\n ....\n 1618   */\n 1619  static void\n 1620: tree_append(struct tree *t, const wchar_t *name, size_t name_length)\n 1621  {\n 1622  \tsize_t size_needed;\n ....\n 1654   * Open a directory tree for traversal.\n 1655   */\n 1656: static struct tree *\n 1657  tree_open(const wchar_t *path, int symlink_mode, int restore_time)\n 1658  {\n 1659: \tstruct tree *t;\n 1660  \n 1661  \tt = calloc(1, sizeof(*t));\n ....\n 1667  }\n 1668  \n 1669: static struct tree *\n 1670: tree_reopen(struct tree *t, const wchar_t *path, int restore_time)\n 1671  {\n 1672: \tstruct archive_wstring ws;\n 1673  \twchar_t *pathname, *p, *base;\n 1674  \n ....\n 1769  \n 1770  static int\n 1771: tree_descent(struct tree *t)\n 1772  {\n 1773  \tt->dirname_length = archive_strlen(&t->path);\n ....\n 1781   */\n 1782  static int\n 1783: tree_ascend(struct tree *t)\n 1784  {\n 1785: \tstruct tree_entry *te;\n 1786  \n 1787  \tte = t->stack;\n ....\n 1795   */\n 1796  static void\n 1797: tree_pop(struct tree *t)\n 1798  {\n 1799: \tstruct tree_entry *te;\n 1800  \n 1801  \tt->full_path.s[t->full_path_dir_length] = L'\\0';\n ....\n 1821   */\n 1822  static int\n 1823: tree_next(struct tree *t)\n 1824  {\n 1825  \tint r;\n ....\n 1899  \n 1900  static int\n 1901: tree_dir_next_windows(struct tree *t, const wchar_t *pattern)\n 1902  {\n 1903  \tconst wchar_t *name;\n ....\n 1907  \tfor (;;) {\n 1908  \t\tif (pattern != NULL) {\n 1909: \t\t\tstruct archive_wstring pt;\n 1910  \n 1911  \t\t\tarchive_string_init(&pt);\n ....\n 1968  \n 1969  static void\n 1970: entry_copy_bhfi(struct archive_entry *entry, const wchar_t *path,\n 1971  \tconst WIN32_FIND_DATAW *findData,\n 1972  \tconst BY_HANDLE_FILE_INFORMATION *bhfi)\n ....\n 2037  \n 2038  static void\n 2039: tree_archive_entry_copy_bhfi(struct archive_entry *entry, struct tree *t,\n 2040  \tconst BY_HANDLE_FILE_INFORMATION *bhfi)\n 2041  {\n ....\n 2044  \n 2045  static int\n 2046: tree_current_file_information(struct tree *t, BY_HANDLE_FILE_INFORMATION *st,\n 2047   int sim_lstat)\n 2048  {\n ....\n 2069   */\n 2070  static const BY_HANDLE_FILE_INFORMATION *\n 2071: tree_current_stat(struct tree *t)\n 2072  {\n 2073  \tif (!(t->flags & hasStat)) {\n ....\n 2083   */\n 2084  static const BY_HANDLE_FILE_INFORMATION *\n 2085: tree_current_lstat(struct tree *t)\n 2086  {\n 2087  \tif (!(t->flags & hasLstat)) {\n ....\n 2097   */\n 2098  static int\n 2099: tree_current_is_dir(struct tree *t)\n 2100  {\n 2101  \tif (t->findData)\n ....\n 2111   */\n 2112  static int\n 2113: tree_current_is_physical_dir(struct tree *t)\n 2114  {\n 2115  \tif (tree_current_is_physical_link(t))\n ....\n 2122   */\n 2123  static int\n 2124: tree_current_is_physical_link(struct tree *t)\n 2125  {\n 2126  \tif (t->findData)\n ....\n 2136   */\n 2137  static int\n 2138: tree_target_is_same_as_parent(struct tree *t,\n 2139      const BY_HANDLE_FILE_INFORMATION *st)\n 2140  {\n 2141: \tstruct tree_entry *te;\n 2142  \tint64_t dev = bhfi_dev(st);\n 2143  \tint64_t ino = bhfi_ino(st);\n ....\n 2154   */\n 2155  static const wchar_t *\n 2156: tree_current_access_path(struct tree *t)\n 2157  {\n 2158  \treturn (t->full_path.s);\n ....\n 2163   */\n 2164  static const wchar_t *\n 2165: tree_current_path(struct tree *t)\n 2166  {\n 2167  \treturn (t->path.s);\n ....\n 2172   */\n 2173  static void\n 2174: tree_close(struct tree *t)\n 2175  {\n 2176  \n ....\n 2197   */\n 2198  static void\n 2199: tree_free(struct tree *t)\n 2200  {\n 2201  \tint i;\n ....\n 2220   */\n 2221  int\n 2222: archive_read_disk_entry_from_file(struct archive *_a,\n 2223:     struct archive_entry *entry, int fd, const struct stat *st)\n 2224  {\n 2225: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 2226  \tconst wchar_t *path;\n 2227  \tconst wchar_t *wname;\n ....\n 2384  #if defined(__MINGW32__) && !defined(FSCTL_QUERY_ALLOCATED_RANGES)\n 2385  #define FSCTL_QUERY_ALLOCATED_RANGES 0x940CF\n 2386: typedef struct {\n 2387  \tLARGE_INTEGER FileOffset;\n 2388  \tLARGE_INTEGER Length;\n ....\n 2391  \n 2392  static int\n 2393: setup_sparse_from_disk(struct archive_read_disk *a,\n 2394:     struct archive_entry *entry, HANDLE handle)\n 2395  {\n 2396  \tFILE_ALLOCATED_RANGE_BUFFER range, *outranges = NULL;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter_grzip.c:\n   38  #include \"archive_write_private.h\"\n   39  \n   40: struct write_grzip {\n   41: \tstruct archive_write_program_data *pdata;\n   42  };\n   43  \n   44: static int archive_write_grzip_open(struct archive_write_filter *);\n   45: static int archive_write_grzip_options(struct archive_write_filter *,\n   46  \t\t    const char *, const char *);\n   47: static int archive_write_grzip_write(struct archive_write_filter *,\n   48  \t\t    const void *, size_t);\n   49: static int archive_write_grzip_close(struct archive_write_filter *);\n   50: static int archive_write_grzip_free(struct archive_write_filter *);\n   51  \n   52  int\n   53: archive_write_add_filter_grzip(struct archive *_a)\n   54  {\n   55: \tstruct archive_write_filter *f = __archive_write_allocate_filter(_a);\n   56: \tstruct write_grzip *data;\n   57  \n   58  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n   ..\n   88  \n   89  static int\n   90: archive_write_grzip_options(struct archive_write_filter *f, const char *key,\n   91      const char *value)\n   92  {\n   ..\n  101  \n  102  static int\n  103: archive_write_grzip_open(struct archive_write_filter *f)\n  104  {\n  105: \tstruct write_grzip *data = (struct write_grzip *)f->data;\n  106  \n  107  \treturn __archive_write_program_open(f, data->pdata, \"grzip\");\n  ...\n  109  \n  110  static int\n  111: archive_write_grzip_write(struct archive_write_filter *f,\n  112      const void *buff, size_t length)\n  113  {\n  114: \tstruct write_grzip *data = (struct write_grzip *)f->data;\n  115  \n  116  \treturn __archive_write_program_write(f, data->pdata, buff, length);\n  ...\n  118  \n  119  static int\n  120: archive_write_grzip_close(struct archive_write_filter *f)\n  121  {\n  122: \tstruct write_grzip *data = (struct write_grzip *)f->data;\n  123  \n  124  \treturn __archive_write_program_close(f, data->pdata);\n  ...\n  126  \n  127  static int\n  128: archive_write_grzip_free(struct archive_write_filter *f)\n  129  {\n  130: \tstruct write_grzip *data = (struct write_grzip *)f->data;\n  131  \n  132  \t__archive_write_program_free(data->pdata);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_cmdline.c:\n   39  #include \"archive_string.h\"\n   40  \n   41: static int cmdline_set_path(struct archive_cmdline *, const char *);\n   42: static int cmdline_add_arg(struct archive_cmdline *, const char *);\n   43  \n   44  static ssize_t\n   45: extract_quotation(struct archive_string *as, const char *p)\n   46  {\n   47  \tconst char *s;\n   ..\n   67  \n   68  static ssize_t\n   69: get_argument(struct archive_string *as, const char *p)\n   70  {\n   71  \tconst char *s = p;\n   ..\n  107   */\n  108  int\n  109: __archive_cmdline_parse(struct archive_cmdline *data, const char *cmd)\n  110  {\n  111: \tstruct archive_string as;\n  112  \tconst char *p;\n  113  \tssize_t al;\n  ...\n  164   */\n  165  static int\n  166: cmdline_set_path(struct archive_cmdline *data, const char *path)\n  167  {\n  168  \tchar *newptr;\n  ...\n  180   */\n  181  static int\n  182: cmdline_add_arg(struct archive_cmdline *data, const char *arg)\n  183  {\n  184  \tchar **newargv;\n  ...\n  199  }\n  200  \n  201: struct archive_cmdline *\n  202  __archive_cmdline_allocate(void)\n  203  {\n  204: \treturn (struct archive_cmdline *)\n  205: \t\tcalloc(1, sizeof(struct archive_cmdline));\n  206  }\n  207  \n  ...\n  210   */\n  211  int\n  212: __archive_cmdline_free(struct archive_cmdline *data)\n  213  {\n  214  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter_bzip2.c:\n   49  #if ARCHIVE_VERSION_NUMBER < 4000000\n   50  int\n   51: archive_write_set_compression_bzip2(struct archive *a)\n   52  {\n   53  \t__archive_write_filters_free(a);\n   ..\n   56  #endif\n   57  \n   58: struct private_data {\n   59  \tint\t\t compression_level;\n   60  #if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n   ..\n   64  \tsize_t\t\t compressed_buffer_size;\n   65  #else\n   66: \tstruct archive_write_program_data *pdata;\n   67  #endif\n   68  };\n   69  \n   70: static int archive_compressor_bzip2_close(struct archive_write_filter *);\n   71: static int archive_compressor_bzip2_free(struct archive_write_filter *);\n   72: static int archive_compressor_bzip2_open(struct archive_write_filter *);\n   73: static int archive_compressor_bzip2_options(struct archive_write_filter *,\n   74  \t\t    const char *, const char *);\n   75: static int archive_compressor_bzip2_write(struct archive_write_filter *,\n   76  \t\t    const void *, size_t);\n   77  \n   ..\n   80   */\n   81  int\n   82: archive_write_add_filter_bzip2(struct archive *_a)\n   83  {\n   84: \tstruct archive_write *a = (struct archive_write *)_a;\n   85: \tstruct archive_write_filter *f = __archive_write_allocate_filter(_a);\n   86: \tstruct private_data *data;\n   87  \n   88  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n   ..\n  123   */\n  124  static int\n  125: archive_compressor_bzip2_options(struct archive_write_filter *f,\n  126      const char *key, const char *value)\n  127  {\n  128: \tstruct private_data *data = (struct private_data *)f->data;\n  129  \n  130  \tif (strcmp(key, \"compression-level\") == 0) {\n  ...\n  156  #define\tSET_NEXT_IN(st,src)\t\t\t\t\t\\\n  157  \t(st)->stream.next_in = (char *)(uintptr_t)(const void *)(src)\n  158: static int drive_compressor(struct archive_write_filter *,\n  159: \t\t    struct private_data *, int finishing);\n  160  \n  161  /*\n  ...\n  163   */\n  164  static int\n  165: archive_compressor_bzip2_open(struct archive_write_filter *f)\n  166  {\n  167: \tstruct private_data *data = (struct private_data *)f->data;\n  168  \tint ret;\n  169  \n  ...\n  235   */\n  236  static int\n  237: archive_compressor_bzip2_write(struct archive_write_filter *f,\n  238      const void *buff, size_t length)\n  239  {\n  240: \tstruct private_data *data = (struct private_data *)f->data;\n  241  \n  242  \t/* Update statistics */\n  ...\n  256   */\n  257  static int\n  258: archive_compressor_bzip2_close(struct archive_write_filter *f)\n  259  {\n  260: \tstruct private_data *data = (struct private_data *)f->data;\n  261  \tint ret;\n  262  \n  ...\n  282  \n  283  static int\n  284: archive_compressor_bzip2_free(struct archive_write_filter *f)\n  285  {\n  286: \tstruct private_data *data = (struct private_data *)f->data;\n  287  \tfree(data->compressed);\n  288  \tfree(data);\n  ...\n  299   */\n  300  static int\n  301: drive_compressor(struct archive_write_filter *f,\n  302:     struct private_data *data, int finishing)\n  303  {\n  304  \tint ret;\n  ...\n  351  \n  352  static int\n  353: archive_compressor_bzip2_open(struct archive_write_filter *f)\n  354  {\n  355: \tstruct private_data *data = (struct private_data *)f->data;\n  356: \tstruct archive_string as;\n  357  \tint r;\n  358  \n  ...\n  373  \n  374  static int\n  375: archive_compressor_bzip2_write(struct archive_write_filter *f, const void *buff,\n  376      size_t length)\n  377  {\n  378: \tstruct private_data *data = (struct private_data *)f->data;\n  379  \n  380  \treturn __archive_write_program_write(f, data->pdata, buff, length);\n  ...\n  382  \n  383  static int\n  384: archive_compressor_bzip2_close(struct archive_write_filter *f)\n  385  {\n  386: \tstruct private_data *data = (struct private_data *)f->data;\n  387  \n  388  \treturn __archive_write_program_close(f, data->pdata);\n  ...\n  390  \n  391  static int\n  392: archive_compressor_bzip2_free(struct archive_write_filter *f)\n  393  {\n  394: \tstruct private_data *data = (struct private_data *)f->data;\n  395  \n  396  \t__archive_write_program_free(data->pdata);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_ppmd7.c:\n   52  typedef CPpmd7_Context * CTX_PTR;\n   53  \n   54: struct CPpmd7_Node_;\n   55  \n   56  typedef\n   57    #ifdef PPMD_32BIT\n   58:     struct CPpmd7_Node_ *\n   59    #else\n   60      UInt32\n   ..\n   62    CPpmd7_Node_Ref;\n   63  \n   64: typedef struct CPpmd7_Node_\n   65  {\n   66    UInt16 Stamp; /* must be at offset 0 as CPpmd7_Context::NumStats. Stamp=0 means free */\n   ..\n   85  /* ----------- Base ----------- */\n   86  \n   87: static void Ppmd7_Construct(CPpmd7 *p)\n   88  {\n   89    unsigned i, k, m;\n   ..\n 1154  const IPpmd7 __archive_ppmd7_functions =\n 1155  {\n 1156:   &Ppmd7_Construct,\n 1157    &Ppmd7_Alloc,\n 1158    &Ppmd7_Free,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_set_options.c:\n   30  #include \"archive_options_private.h\"\n   31  \n   32: static int\tarchive_set_format_option(struct archive *a,\n   33  \t\t    const char *m, const char *o, const char *v);\n   34: static int\tarchive_set_filter_option(struct archive *a,\n   35  \t\t    const char *m, const char *o, const char *v);\n   36: static int\tarchive_set_option(struct archive *a,\n   37  \t\t    const char *m, const char *o, const char *v);\n   38  \n   39  int\n   40: archive_read_set_format_option(struct archive *a, const char *m, const char *o,\n   41      const char *v)\n   42  {\n   ..\n   47  \n   48  int\n   49: archive_read_set_filter_option(struct archive *a, const char *m, const char *o,\n   50      const char *v)\n   51  {\n   ..\n   56  \n   57  int\n   58: archive_read_set_option(struct archive *a, const char *m, const char *o,\n   59      const char *v)\n   60  {\n   ..\n   65  \n   66  int\n   67: archive_read_set_options(struct archive *a, const char *options)\n   68  {\n   69  \treturn _archive_set_options(a, options,\n   ..\n   73  \n   74  static int\n   75: archive_set_format_option(struct archive *_a, const char *m, const char *o,\n   76      const char *v)\n   77  {\n   78: \tstruct archive_read *a = (struct archive_read *)_a;\n   79  \tsize_t i;\n   80  \tint r, rv = ARCHIVE_WARN, matched_modules = 0;\n   81  \n   82  \tfor (i = 0; i < sizeof(a->formats)/sizeof(a->formats[0]); i++) {\n   83: \t\tstruct archive_format_descriptor *format = &a->formats[i];\n   84  \n   85  \t\tif (format->options == NULL || format->name == NULL)\n   ..\n  110  \n  111  static int\n  112: archive_set_filter_option(struct archive *_a, const char *m, const char *o,\n  113      const char *v)\n  114  {\n  115: \tstruct archive_read *a = (struct archive_read *)_a;\n  116: \tstruct archive_read_filter *filter;\n  117: \tstruct archive_read_filter_bidder *bidder;\n  118  \tint r, rv = ARCHIVE_WARN, matched_modules = 0;\n  119  \n  ...\n  147  \n  148  static int\n  149: archive_set_option(struct archive *a, const char *m, const char *o,\n  150      const char *v)\n  151  {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_virtual.c:\n   32  \n   33  int\n   34: archive_filter_code(struct archive *a, int n)\n   35  {\n   36  \treturn ((a->vtable->archive_filter_code)(a, n));\n   ..\n   38  \n   39  int\n   40: archive_filter_count(struct archive *a)\n   41  {\n   42  \treturn ((a->vtable->archive_filter_count)(a));\n   ..\n   44  \n   45  const char *\n   46: archive_filter_name(struct archive *a, int n)\n   47  {\n   48  \treturn ((a->vtable->archive_filter_name)(a, n));\n   ..\n   50  \n   51  la_int64_t\n   52: archive_filter_bytes(struct archive *a, int n)\n   53  {\n   54  \treturn ((a->vtable->archive_filter_bytes)(a, n));\n   ..\n   56  \n   57  int\n   58: archive_free(struct archive *a)\n   59  {\n   60  \tif (a == NULL)\n   ..\n   64  \n   65  int\n   66: archive_write_close(struct archive *a)\n   67  {\n   68  \treturn ((a->vtable->archive_close)(a));\n   ..\n   70  \n   71  int\n   72: archive_read_close(struct archive *a)\n   73  {\n   74  \treturn ((a->vtable->archive_close)(a));\n   ..\n   76  \n   77  int\n   78: archive_write_fail(struct archive *a)\n   79  {\n   80  \ta->state = ARCHIVE_STATE_FATAL;\n   ..\n   83  \n   84  int\n   85: archive_write_free(struct archive *a)\n   86  {\n   87  \treturn archive_free(a);\n   ..\n   91  /* For backwards compatibility; will be removed with libarchive 4.0. */\n   92  int\n   93: archive_write_finish(struct archive *a)\n   94  {\n   95  \treturn archive_write_free(a);\n   ..\n   98  \n   99  int\n  100: archive_read_free(struct archive *a)\n  101  {\n  102  \treturn archive_free(a);\n  ...\n  106  /* For backwards compatibility; will be removed with libarchive 4.0. */\n  107  int\n  108: archive_read_finish(struct archive *a)\n  109  {\n  110  \treturn archive_read_free(a);\n  ...\n  113  \n  114  int\n  115: archive_write_header(struct archive *a, struct archive_entry *entry)\n  116  {\n  117  \t++a->file_count;\n  ...\n  120  \n  121  int\n  122: archive_write_finish_entry(struct archive *a)\n  123  {\n  124  \treturn ((a->vtable->archive_write_finish_entry)(a));\n  ...\n  126  \n  127  la_ssize_t\n  128: archive_write_data(struct archive *a, const void *buff, size_t s)\n  129  {\n  130  \treturn ((a->vtable->archive_write_data)(a, buff, s));\n  ...\n  132  \n  133  la_ssize_t\n  134: archive_write_data_block(struct archive *a, const void *buff, size_t s,\n  135      la_int64_t o)\n  136  {\n  ...\n  145  \n  146  int\n  147: archive_read_next_header(struct archive *a, struct archive_entry **entry)\n  148  {\n  149  \treturn ((a->vtable->archive_read_next_header)(a, entry));\n  ...\n  151  \n  152  int\n  153: archive_read_next_header2(struct archive *a, struct archive_entry *entry)\n  154  {\n  155  \treturn ((a->vtable->archive_read_next_header2)(a, entry));\n  ...\n  157  \n  158  int\n  159: archive_read_data_block(struct archive *a,\n  160      const void **buff, size_t *s, la_int64_t *o)\n  161  {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_v7tar.c:\n   47  #include \"archive_write_set_format_private.h\"\n   48  \n   49: struct v7tar {\n   50  \tuint64_t\tentry_bytes_remaining;\n   51  \tuint64_t\tentry_padding;\n   52  \n   53: \tstruct archive_string_conv *opt_sconv;\n   54: \tstruct archive_string_conv *sconv_default;\n   55  \tint\tinit_default_conversion;\n   56  };\n   57  \n   58  /*\n   59:  * Define structure of POSIX 'v7tar' tar header.\n   60   */\n   61  #define\tV7TAR_name_offset 0\n   ..\n  124  };\n  125  \n  126: static ssize_t\tarchive_write_v7tar_data(struct archive_write *a, const void *buff,\n  127  \t\t    size_t s);\n  128: static int\tarchive_write_v7tar_free(struct archive_write *);\n  129: static int\tarchive_write_v7tar_close(struct archive_write *);\n  130: static int\tarchive_write_v7tar_finish_entry(struct archive_write *);\n  131: static int\tarchive_write_v7tar_header(struct archive_write *,\n  132: \t\t    struct archive_entry *entry);\n  133: static int\tarchive_write_v7tar_options(struct archive_write *,\n  134  \t\t    const char *, const char *);\n  135  static int\tformat_256(int64_t, char *, int);\n  136  static int\tformat_number(int64_t, char *, int size, int max, int strict);\n  137  static int\tformat_octal(int64_t, char *, int);\n  138: static int\tformat_header_v7tar(struct archive_write *, char h[512],\n  139: \t\t    struct archive_entry *, int, struct archive_string_conv *);\n  140  \n  141  /*\n  ...\n  143   */\n  144  int\n  145: archive_write_set_format_v7tar(struct archive *_a)\n  146  {\n  147: \tstruct archive_write *a = (struct archive_write *)_a;\n  148: \tstruct v7tar *v7tar;\n  149  \n  150  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n  ...\n  163  \t}\n  164  \n  165: \tv7tar = (struct v7tar *)calloc(1, sizeof(*v7tar));\n  166  \tif (v7tar == NULL) {\n  167  \t\tarchive_set_error(&a->archive, ENOMEM,\n  ...\n  183  \n  184  static int\n  185: archive_write_v7tar_options(struct archive_write *a, const char *key,\n  186      const char *val)\n  187  {\n  188: \tstruct v7tar *v7tar = (struct v7tar *)a->format_data;\n  189  \tint ret = ARCHIVE_FAILED;\n  190  \n  ...\n  212  \n  213  static int\n  214: archive_write_v7tar_header(struct archive_write *a, struct archive_entry *entry)\n  215  {\n  216  \tchar buff[512];\n  217  \tint ret, ret2;\n  218: \tstruct v7tar *v7tar;\n  219: \tstruct archive_entry *entry_main;\n  220: \tstruct archive_string_conv *sconv;\n  221  \n  222: \tv7tar = (struct v7tar *)a->format_data;\n  223  \n  224  \t/* Setup default string conversion. */\n  ...\n  259  \t\twp = archive_entry_pathname_w(entry);\n  260  \t\tif (wp != NULL && wp[wcslen(wp) -1] != L'/') {\n  261: \t\t\tstruct archive_wstring ws;\n  262  \n  263  \t\t\tarchive_string_init(&ws);\n  ...\n  287  \t\t */\n  288  \t\tif (p != NULL && p[0] != '\\0' && p[strlen(p) - 1] != '/') {\n  289: \t\t\tstruct archive_string as;\n  290  \n  291  \t\t\tarchive_string_init(&as);\n  ...\n  359   */\n  360  static int\n  361: format_header_v7tar(struct archive_write *a, char h[512],\n  362:     struct archive_entry *entry, int strict,\n  363:     struct archive_string_conv *sconv)\n  364  {\n  365  \tunsigned int checksum;\n  ...\n  593  \n  594  static int\n  595: archive_write_v7tar_close(struct archive_write *a)\n  596  {\n  597  \treturn (__archive_write_nulls(a, 512*2));\n  ...\n  599  \n  600  static int\n  601: archive_write_v7tar_free(struct archive_write *a)\n  602  {\n  603: \tstruct v7tar *v7tar;\n  604  \n  605: \tv7tar = (struct v7tar *)a->format_data;\n  606  \tfree(v7tar);\n  607  \ta->format_data = NULL;\n  ...\n  610  \n  611  static int\n  612: archive_write_v7tar_finish_entry(struct archive_write *a)\n  613  {\n  614: \tstruct v7tar *v7tar;\n  615  \tint ret;\n  616  \n  617: \tv7tar = (struct v7tar *)a->format_data;\n  618  \tret = __archive_write_nulls(a,\n  619  \t    (size_t)(v7tar->entry_bytes_remaining + v7tar->entry_padding));\n  ...\n  623  \n  624  static ssize_t\n  625: archive_write_v7tar_data(struct archive_write *a, const void *buff, size_t s)\n  626  {\n  627: \tstruct v7tar *v7tar;\n  628  \tint ret;\n  629  \n  630: \tv7tar = (struct v7tar *)a->format_data;\n  631  \tif (s > v7tar->entry_bytes_remaining)\n  632  \t\ts = (size_t)v7tar->entry_bytes_remaining;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_zip.c:\n   76  #endif\n   77  \n   78: struct zip_entry {\n   79: \tstruct archive_rb_node\tnode;\n   80: \tstruct zip_entry\t*next;\n   81  \tint64_t\t\t\tlocal_header_offset;\n   82  \tint64_t\t\t\tcompressed_size;\n   ..\n   84  \tint64_t\t\t\tgid;\n   85  \tint64_t\t\t\tuid;\n   86: \tstruct archive_string\trsrcname;\n   87  \ttime_t\t\t\tmtime;\n   88  \ttime_t\t\t\tatime;\n   ..\n   98  \t/* WinZip AES encryption extra field should be available\n   99  \t * when compression is 99. */\n  100: \tstruct {\n  101  \t\t/* Vendor version: AE-1 - 0x0001, AE-2 - 0x0002 */\n  102  \t\tunsigned\tvendor;\n  ...\n  111  };\n  112  \n  113: struct trad_enc_ctx {\n  114  \tuint32_t\tkeys[3];\n  115  };\n  ...\n  139  #define MAX_DERIVED_KEY_BUF_SIZE\t(AES_MAX_KEY_SIZE * 2 + 2)\n  140  \n  141: struct zip {\n  142  \t/* Structural information about the archive. */\n  143: \tstruct archive_string\tformat_name;\n  144  \tint64_t\t\t\tcentral_directory_offset;\n  145  \tint64_t\t\t\tcentral_directory_offset_adjusted;\n  ...\n  149  \n  150  \t/* List of entries (seekable Zip only) */\n  151: \tstruct zip_entry\t*zip_entries;\n  152: \tstruct archive_rb_tree\ttree;\n  153: \tstruct archive_rb_tree\ttree_rsrc;\n  154  \n  155  \t/* Bytes read but not yet consumed via __archive_read_consume() */\n  ...\n  157  \n  158  \t/* Information about entry we're currently reading. */\n  159: \tstruct zip_entry\t*entry;\n  160  \tint64_t\t\t\tentry_bytes_remaining;\n  161  \n  ...\n  198  \tchar\t\t\tppmd8_stream_failed;\n  199  \n  200: \tstruct archive_string_conv *sconv;\n  201: \tstruct archive_string_conv *sconv_default;\n  202: \tstruct archive_string_conv *sconv_utf8;\n  203  \tint\t\t\tinit_default_conversion;\n  204  \tint\t\t\tprocess_mac_extensions;\n  ...\n  222  \n  223  \t/* Traditional PKWARE decryption. */\n  224: \tstruct trad_enc_ctx\ttctx;\n  225  \tchar\t\t\ttctx_valid;\n  226  \n  ...\n  250  #ifdef HAVE_ZLIB_H\n  251  static int\n  252: zip_read_data_deflate(struct archive_read *a, const void **buff,\n  253  \tsize_t *size, int64_t *offset);\n  254  #endif\n  255  #if HAVE_LZMA_H && HAVE_LIBLZMA\n  256  static int\n  257: zip_read_data_zipx_lzma_alone(struct archive_read *a, const void **buff,\n  258  \tsize_t *size, int64_t *offset);\n  259  #endif\n  ...\n  266  ppmd_read(void* p) {\n  267  \t/* Get the handle to current decompression context. */\n  268: \tstruct archive_read *a = ((IByteIn*)p)->a;\n  269: \tstruct zip *zip = (struct zip*) a->format->data;\n  270  \tssize_t bytes_avail = 0;\n  271  \n  ...\n  293  \n  294  static void\n  295: trad_enc_update_keys(struct trad_enc_ctx *ctx, uint8_t c)\n  296  {\n  297  \tuint8_t t;\n  ...\n  306  \n  307  static uint8_t\n  308: trad_enc_decrypt_byte(struct trad_enc_ctx *ctx)\n  309  {\n  310  \tunsigned temp = ctx->keys[2] | 2;\n  ...\n  313  \n  314  static void\n  315: trad_enc_decrypt_update(struct trad_enc_ctx *ctx, const uint8_t *in,\n  316      size_t in_len, uint8_t *out, size_t out_len)\n  317  {\n  ...\n  328  \n  329  static int\n  330: trad_enc_init(struct trad_enc_ctx *ctx, const char *pw, size_t pw_len,\n  331      const uint8_t *key, size_t key_len, uint8_t *crcchk)\n  332  {\n  ...\n  411  }\n  412  \n  413: static const struct {\n  414  \tint id;\n  415  \tconst char * name;\n  ...\n  463  {\n  464  \tint msTime, msDate;\n  465: \tstruct tm ts;\n  466  \n  467  \tmsTime = (0xff & (unsigned)p[0]) + 256 * (0xff & (unsigned)p[1]);\n  ...\n  485   */\n  486  static int\n  487: process_extra(struct archive_read *a, struct archive_entry *entry,\n  488:      const char *p, size_t extra_length, struct zip_entry* zip_entry)\n  489  {\n  490  \tunsigned offset = 0;\n  491: \tstruct zip *zip = (struct zip *)(a->format->data);\n  492  \n  493  \tif (extra_length == 0) {\n  ...\n  916   */\n  917  static int\n  918: zip_read_local_file_header(struct archive_read *a, struct archive_entry *entry,\n  919:     struct zip *zip)\n  920  {\n  921  \tconst char *p;\n  ...\n  924  \tconst char *cp;\n  925  \tsize_t len, filename_length, extra_length;\n  926: \tstruct archive_string_conv *sconv;\n  927: \tstruct zip_entry *zip_entry = zip->entry;\n  928: \tstruct zip_entry zip_entry_central_dir;\n  929  \tint ret = ARCHIVE_OK;\n  930  \tchar version;\n  ...\n 1052  \t\tif (wcschr(wp, L'/') == NULL && wcschr(wp, L'\\\\') != NULL) {\n 1053  \t\t\tsize_t i;\n 1054: \t\t\tstruct archive_wstring s;\n 1055  \t\t\tarchive_string_init(&s);\n 1056  \t\t\tarchive_wstrcpy(&s, wp);\n ....\n 1095  \t\t\tlen = wcslen(wp);\n 1096  \t\t\tif (len > 0 && wp[len - 1] != L'/') {\n 1097: \t\t\t\tstruct archive_wstring s;\n 1098  \t\t\t\tarchive_string_init(&s);\n 1099  \t\t\t\tarchive_wstrcat(&s, wp);\n ....\n 1106  \t\t\tlen = (cp != NULL)?strlen(cp):0;\n 1107  \t\t\tif (len > 0 && cp[len - 1] != '/') {\n 1108: \t\t\t\tstruct archive_string s;\n 1109  \t\t\t\tarchive_string_init(&s);\n 1110  \t\t\t\tarchive_strcat(&s, cp);\n ....\n 1297  \n 1298  static int\n 1299: check_authentication_code(struct archive_read *a, const void *_p)\n 1300  {\n 1301: \tstruct zip *zip = (struct zip *)(a->format->data);\n 1302  \n 1303  \t/* Check authentication code. */\n ....\n 1358   */\n 1359  static int\n 1360: zip_read_data_none(struct archive_read *a, const void **_buff,\n 1361      size_t *size, int64_t *offset)\n 1362  {\n 1363: \tstruct zip *zip;\n 1364  \tconst char *buff;\n 1365  \tssize_t bytes_avail;\n ....\n 1368  \t(void)offset; /* UNUSED */\n 1369  \n 1370: \tzip = (struct zip *)(a->format->data);\n 1371  \n 1372  \tif (zip->entry->zip_flags & ZIP_LENGTH_AT_END) {\n ....\n 1500  \n 1501  static int\n 1502: consume_optional_marker(struct archive_read *a, struct zip *zip)\n 1503  {\n 1504  \tif (zip->end_of_entry && (zip->entry->zip_flags & ZIP_LENGTH_AT_END)) {\n ....\n 1545  #if HAVE_LZMA_H && HAVE_LIBLZMA\n 1546  static int\n 1547: zipx_xz_init(struct archive_read *a, struct zip *zip)\n 1548  {\n 1549  \tlzma_ret r;\n ....\n 1582  \n 1583  static int\n 1584: zipx_lzma_alone_init(struct archive_read *a, struct zip *zip)\n 1585  {\n 1586  \tlzma_ret r;\n ....\n 1589  #pragma pack(push)\n 1590  #pragma pack(1)\n 1591: \tstruct _alone_header {\n 1592  \t    uint8_t bytes[5];\n 1593  \t    uint64_t uncompressed_size;\n ....\n 1616  \t}\n 1617  \n 1618: \t/* Flag the cleanup function that we want our lzma-related structures\n 1619  \t * to be freed later. */\n 1620  \tzip->zipx_lzma_valid = 1;\n 1621  \n 1622  \t/* The \"lzma alone\" file format and the stream format inside ZIPx are\n 1623: \t * almost the same. Here's an example of a structure of \"lzma alone\"\n 1624  \t * format:\n 1625  \t *\n ....\n 1636  \t * The <data...> part is the actual lzma-compressed data stream.\n 1637  \t *\n 1638: \t * Now here's the structure of the stream inside the ZIPX file:\n 1639  \t *\n 1640  \t * $ cat stream_inside_zipx | xxd | head -n 1\n ....\n 1717  \n 1718  static int\n 1719: zip_read_data_zipx_xz(struct archive_read *a, const void **buff,\n 1720  \tsize_t *size, int64_t *offset)\n 1721  {\n 1722: \tstruct zip* zip = (struct zip *)(a->format->data);\n 1723  \tint ret;\n 1724  \tlzma_ret lz_ret;\n ....\n 1802  \n 1803  static int\n 1804: zip_read_data_zipx_lzma_alone(struct archive_read *a, const void **buff,\n 1805      size_t *size, int64_t *offset)\n 1806  {\n 1807: \tstruct zip* zip = (struct zip *)(a->format->data);\n 1808  \tint ret;\n 1809  \tlzma_ret lz_ret;\n ....\n 1918  \n 1919  static int\n 1920: zipx_ppmd8_init(struct archive_read *a, struct zip *zip)\n 1921  {\n 1922  \tconst void* p;\n ....\n 1933  \n 1934  \t/* Create a new decompression context. */\n 1935: \t__archive_ppmd8_functions.Ppmd8_Construct(&zip->ppmd8);\n 1936  \tzip->ppmd8_stream_failed = 0;\n 1937  \n ....\n 2016  \n 2017  static int\n 2018: zip_read_data_zipx_ppmd(struct archive_read *a, const void **buff,\n 2019      size_t *size, int64_t *offset)\n 2020  {\n 2021: \tstruct zip* zip = (struct zip *)(a->format->data);\n 2022  \tint ret;\n 2023  \tsize_t consumed_bytes = 0;\n ....\n 2094  #ifdef HAVE_BZLIB_H\n 2095  static int\n 2096: zipx_bzip2_init(struct archive_read *a, struct zip *zip)\n 2097  {\n 2098  \tint r;\n ....\n 2137  \n 2138  static int\n 2139: zip_read_data_zipx_bzip2(struct archive_read *a, const void **buff,\n 2140      size_t *size, int64_t *offset)\n 2141  {\n 2142: \tstruct zip *zip = (struct zip *)(a->format->data);\n 2143  \tssize_t bytes_avail = 0, in_bytes, to_consume;\n 2144  \tconst void *compressed_buff;\n ....\n 2241  #ifdef HAVE_ZLIB_H\n 2242  static int\n 2243: zip_deflate_init(struct archive_read *a, struct zip *zip)\n 2244  {\n 2245  \tint r;\n ....\n 2257  \t\t\treturn (ARCHIVE_FATAL);\n 2258  \t\t}\n 2259: \t\t/* Stream structure has been set up. */\n 2260  \t\tzip->stream_valid = 1;\n 2261  \t\t/* We've initialized decompression for this stream. */\n ....\n 2266  \n 2267  static int\n 2268: zip_read_data_deflate(struct archive_read *a, const void **buff,\n 2269      size_t *size, int64_t *offset)\n 2270  {\n 2271: \tstruct zip *zip;\n 2272  \tssize_t bytes_avail;\n 2273  \tconst void *compressed_buff, *sp;\n ....\n 2276  \t(void)offset; /* UNUSED */\n 2277  \n 2278: \tzip = (struct zip *)(a->format->data);\n 2279  \n 2280  \t/* If the buffer hasn't been allocated, allocate it now. */\n ....\n 2425  \n 2426  static int\n 2427: read_decryption_header(struct archive_read *a)\n 2428  {\n 2429: \tstruct zip *zip = (struct zip *)(a->format->data);\n 2430  \tconst char *p;\n 2431  \tunsigned int remaining_size;\n ....\n 2619  \n 2620  static int\n 2621: zip_alloc_decryption_buffer(struct archive_read *a)\n 2622  {\n 2623: \tstruct zip *zip = (struct zip *)(a->format->data);\n 2624  \tsize_t bs = 256 * 1024;\n 2625  \n ....\n 2638  \n 2639  static int\n 2640: init_traditional_PKWARE_decryption(struct archive_read *a)\n 2641  {\n 2642: \tstruct zip *zip = (struct zip *)(a->format->data);\n 2643  \tconst void *p;\n 2644  \tint retry;\n ....\n 2710  \n 2711  static int\n 2712: init_WinZip_AES_decryption(struct archive_read *a)\n 2713  {\n 2714: \tstruct zip *zip = (struct zip *)(a->format->data);\n 2715  \tconst void *p;\n 2716  \tconst uint8_t *pv;\n ....\n 2803  \n 2804  static int\n 2805: archive_read_format_zip_read_data(struct archive_read *a,\n 2806      const void **buff, size_t *size, int64_t *offset)\n 2807  {\n 2808  \tint r;\n 2809: \tstruct zip *zip = (struct zip *)(a->format->data);\n 2810  \n 2811  \tif (zip->has_encrypted_entries ==\n ....\n 2925  \n 2926  static int\n 2927: archive_read_format_zip_cleanup(struct archive_read *a)\n 2928  {\n 2929: \tstruct zip *zip;\n 2930: \tstruct zip_entry *zip_entry, *next_zip_entry;\n 2931  \n 2932: \tzip = (struct zip *)(a->format->data);\n 2933  \n 2934  #ifdef HAVE_ZLIB_H\n ....\n 2978  \n 2979  static int\n 2980: archive_read_format_zip_has_encrypted_entries(struct archive_read *_a)\n 2981  {\n 2982  \tif (_a && _a->format) {\n 2983: \t\tstruct zip * zip = (struct zip *)_a->format->data;\n 2984  \t\tif (zip) {\n 2985  \t\t\treturn zip->has_encrypted_entries;\n ....\n 2990  \n 2991  static int\n 2992: archive_read_format_zip_options(struct archive_read *a,\n 2993      const char *key, const char *val)\n 2994  {\n 2995: \tstruct zip *zip;\n 2996  \tint ret = ARCHIVE_FAILED;\n 2997  \n 2998: \tzip = (struct zip *)(a->format->data);\n 2999  \tif (strcmp(key, \"compat-2x\")  == 0) {\n 3000  \t\t/* Handle filenames as libarchive 2.x */\n ....\n 3039  \n 3040  int\n 3041: archive_read_support_format_zip(struct archive *a)\n 3042  {\n 3043  \tint r;\n ....\n 3056  \n 3057  static int\n 3058: archive_read_support_format_zip_capabilities_streamable(struct archive_read * a)\n 3059  {\n 3060  \t(void)a; /* UNUSED */\n ....\n 3064  \n 3065  static int\n 3066: archive_read_format_zip_streamable_bid(struct archive_read *a, int best_bid)\n 3067  {\n 3068  \tconst char *p;\n ....\n 3100  \n 3101  static int\n 3102: archive_read_format_zip_streamable_read_header(struct archive_read *a,\n 3103:     struct archive_entry *entry)\n 3104  {\n 3105: \tstruct zip *zip;\n 3106  \n 3107  \ta->archive.archive_format = ARCHIVE_FORMAT_ZIP;\n ....\n 3109  \t\ta->archive.archive_format_name = \"ZIP\";\n 3110  \n 3111: \tzip = (struct zip *)(a->format->data);\n 3112  \n 3113  \t/*\n ....\n 3122  \t\tzip->has_encrypted_entries = 0;\n 3123  \n 3124: \t/* Make sure we have a zip_entry structure to use. */\n 3125  \tif (zip->zip_entries == NULL) {\n 3126: \t\tzip->zip_entries = malloc(sizeof(struct zip_entry));\n 3127  \t\tif (zip->zip_entries == NULL) {\n 3128  \t\t\tarchive_set_error(&a->archive, ENOMEM,\n ....\n 3132  \t}\n 3133  \tzip->entry = zip->zip_entries;\n 3134: \tmemset(zip->entry, 0, sizeof(struct zip_entry));\n 3135  \n 3136  \tif (zip->cctx_valid)\n ....\n 3194  \n 3195  static int\n 3196: archive_read_format_zip_read_data_skip_streamable(struct archive_read *a)\n 3197  {\n 3198: \tstruct zip *zip;\n 3199  \tint64_t bytes_skipped;\n 3200  \n 3201: \tzip = (struct zip *)(a->format->data);\n 3202  \tbytes_skipped = __archive_read_consume(a, zip->unconsumed);\n 3203  \tzip->unconsumed = 0;\n ....\n 3286  \n 3287  int\n 3288: archive_read_support_format_zip_streamable(struct archive *_a)\n 3289  {\n 3290: \tstruct archive_read *a = (struct archive_read *)_a;\n 3291: \tstruct zip *zip;\n 3292  \tint r;\n 3293  \n ....\n 3295  \t    ARCHIVE_STATE_NEW, \"archive_read_support_format_zip\");\n 3296  \n 3297: \tzip = (struct zip *)calloc(1, sizeof(*zip));\n 3298  \tif (zip == NULL) {\n 3299  \t\tarchive_set_error(&a->archive, ENOMEM,\n ....\n 3337  \n 3338  static int\n 3339: archive_read_support_format_zip_capabilities_seekable(struct archive_read * a)\n 3340  {\n 3341  \t(void)a; /* UNUSED */\n ....\n 3354   */\n 3355  static int\n 3356: read_eocd(struct zip *zip, const char *p, int64_t current_offset)\n 3357  {\n 3358  \tuint16_t disk_num;\n ....\n 3394   */\n 3395  static int\n 3396: read_zip64_eocd(struct archive_read *a, struct zip *zip, const char *p)\n 3397  {\n 3398  \tint64_t eocd64_offset;\n ....\n 3439  \n 3440  static int\n 3441: archive_read_format_zip_seekable_bid(struct archive_read *a, int best_bid)\n 3442  {\n 3443: \tstruct zip *zip = (struct zip *)a->format->data;\n 3444  \tint64_t file_size, current_offset;\n 3445  \tconst char *p;\n ....\n 3497  \n 3498  static int\n 3499: cmp_node(const struct archive_rb_node *n1, const struct archive_rb_node *n2)\n 3500  {\n 3501: \tconst struct zip_entry *e1 = (const struct zip_entry *)n1;\n 3502: \tconst struct zip_entry *e2 = (const struct zip_entry *)n2;\n 3503  \n 3504  \tif (e1->local_header_offset > e2->local_header_offset)\n ....\n 3510  \n 3511  static int\n 3512: cmp_key(const struct archive_rb_node *n, const void *key)\n 3513  {\n 3514  \t/* This function won't be called */\n ....\n 3518  }\n 3519  \n 3520: static const struct archive_rb_tree_ops rb_ops = {\n 3521  \t&cmp_node, &cmp_key\n 3522  };\n 3523  \n 3524  static int\n 3525: rsrc_cmp_node(const struct archive_rb_node *n1,\n 3526:     const struct archive_rb_node *n2)\n 3527  {\n 3528: \tconst struct zip_entry *e1 = (const struct zip_entry *)n1;\n 3529: \tconst struct zip_entry *e2 = (const struct zip_entry *)n2;\n 3530  \n 3531  \treturn (strcmp(e2->rsrcname.s, e1->rsrcname.s));\n ....\n 3533  \n 3534  static int\n 3535: rsrc_cmp_key(const struct archive_rb_node *n, const void *key)\n 3536  {\n 3537: \tconst struct zip_entry *e = (const struct zip_entry *)n;\n 3538  \treturn (strcmp((const char *)key, e->rsrcname.s));\n 3539  }\n 3540  \n 3541: static const struct archive_rb_tree_ops rb_rsrc_ops = {\n 3542  \t&rsrc_cmp_node, &rsrc_cmp_key\n 3543  };\n ....\n 3559  \n 3560  static void\n 3561: expose_parent_dirs(struct zip *zip, const char *name, size_t name_length)\n 3562  {\n 3563: \tstruct archive_string str;\n 3564: \tstruct zip_entry *dir;\n 3565  \tchar *s;\n 3566  \n ....\n 3574  \t\t/* Transfer the parent directory from zip->tree_rsrc RB\n 3575  \t\t * tree to zip->tree RB tree to expose. */\n 3576: \t\tdir = (struct zip_entry *)\n 3577  \t\t    __archive_rb_tree_find_node(&zip->tree_rsrc, str.s);\n 3578  \t\tif (dir == NULL)\n ....\n 3586  \n 3587  static int\n 3588: slurp_central_directory(struct archive_read *a, struct archive_entry* entry,\n 3589:     struct zip *zip)\n 3590  {\n 3591  \tssize_t i;\n ....\n 3649  \tzip->central_directory_entries_total = 0;\n 3650  \twhile (1) {\n 3651: \t\tstruct zip_entry *zip_entry;\n 3652  \t\tsize_t filename_length, extra_length, comment_length;\n 3653  \t\tuint32_t external_attributes;\n ....\n 3667  \t\t\treturn ARCHIVE_FATAL;\n 3668  \n 3669: \t\tzip_entry = calloc(1, sizeof(struct zip_entry));\n 3670  \t\tif (zip_entry == NULL) {\n 3671  \t\t\tarchive_set_error(&a->archive, ENOMEM,\n ....\n 3802  \n 3803  static ssize_t\n 3804: zip_get_local_file_header_size(struct archive_read *a, size_t extra)\n 3805  {\n 3806  \tconst char *p;\n ....\n 3825  \n 3826  static int\n 3827: zip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,\n 3828:     struct zip_entry *rsrc)\n 3829  {\n 3830: \tstruct zip *zip = (struct zip *)a->format->data;\n 3831  \tunsigned char *metadata, *mp;\n 3832  \tint64_t offset = archive_filter_bytes(&a->archive, 0);\n ....\n 3976  \n 3977  static int\n 3978: archive_read_format_zip_seekable_read_header(struct archive_read *a,\n 3979: \tstruct archive_entry *entry)\n 3980  {\n 3981: \tstruct zip *zip = (struct zip *)a->format->data;\n 3982: \tstruct zip_entry *rsrc;\n 3983  \tint64_t offset;\n 3984  \tint r, ret = ARCHIVE_OK;\n ....\n 4006  \t\t * other entries in the archive file. */\n 4007  \t\tzip->entry =\n 4008: \t\t    (struct zip_entry *)ARCHIVE_RB_TREE_MIN(&zip->tree);\n 4009  \t} else if (zip->entry != NULL) {\n 4010  \t\t/* Get next entry in local header offset order. */\n 4011: \t\tzip->entry = (struct zip_entry *)__archive_rb_tree_iterate(\n 4012  \t\t    &zip->tree, &zip->entry->node, ARCHIVE_RB_DIR_RIGHT);\n 4013  \t}\n ....\n 4017  \n 4018  \tif (zip->entry->rsrcname.s)\n 4019: \t\trsrc = (struct zip_entry *)__archive_rb_tree_find_node(\n 4020  \t\t    &zip->tree_rsrc, zip->entry->rsrcname.s);\n 4021  \telse\n ....\n 4057   */\n 4058  static int\n 4059: archive_read_format_zip_read_data_skip_seekable(struct archive_read *a)\n 4060  {\n 4061: \tstruct zip *zip;\n 4062: \tzip = (struct zip *)(a->format->data);\n 4063  \n 4064  \tzip->unconsumed = 0;\n ....\n 4067  \n 4068  int\n 4069: archive_read_support_format_zip_seekable(struct archive *_a)\n 4070  {\n 4071: \tstruct archive_read *a = (struct archive_read *)_a;\n 4072: \tstruct zip *zip;\n 4073  \tint r;\n 4074  \n ....\n 4076  \t    ARCHIVE_STATE_NEW, \"archive_read_support_format_zip_seekable\");\n 4077  \n 4078: \tzip = (struct zip *)calloc(1, sizeof(*zip));\n 4079  \tif (zip == NULL) {\n 4080  \t\tarchive_set_error(&a->archive, ENOMEM,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_append_filter.c:\n   36  \n   37  int\n   38: archive_read_append_filter(struct archive *_a, int code)\n   39  {\n   40    int r1, r2, number_bidders, i;\n   41    char str[20];\n   42:   struct archive_read_filter_bidder *bidder;\n   43:   struct archive_read_filter *filter;\n   44:   struct archive_read *a = (struct archive_read *)_a;\n   45  \n   46    r2 = (ARCHIVE_OK);\n   ..\n  126  \n  127      filter\n  128:         = (struct archive_read_filter *)calloc(1, sizeof(*filter));\n  129      if (filter == NULL)\n  130      {\n  ...\n  148  \n  149  int\n  150: archive_read_append_filter_program(struct archive *_a, const char *cmd)\n  151  {\n  152    return (archive_read_append_filter_program_signature(_a, cmd, NULL, 0));\n  ...\n  154  \n  155  int\n  156: archive_read_append_filter_program_signature(struct archive *_a,\n  157    const char *cmd, const void *signature, size_t signature_len)\n  158  {\n  159    int r, number_bidders, i;\n  160:   struct archive_read_filter_bidder *bidder;\n  161:   struct archive_read_filter *filter;\n  162:   struct archive_read *a = (struct archive_read *)_a;\n  163  \n  164    if (archive_read_support_filter_program_signature(_a, cmd, signature,\n  ...\n  183  \n  184    filter\n  185:       = (struct archive_read_filter *)calloc(1, sizeof(*filter));\n  186    if (filter == NULL)\n  187    {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_cpio_odc.c:\n   46  #include \"archive_write_set_format_private.h\"\n   47  \n   48: static ssize_t\tarchive_write_odc_data(struct archive_write *,\n   49  \t\t    const void *buff, size_t s);\n   50: static int\tarchive_write_odc_close(struct archive_write *);\n   51: static int\tarchive_write_odc_free(struct archive_write *);\n   52: static int\tarchive_write_odc_finish_entry(struct archive_write *);\n   53: static int\tarchive_write_odc_header(struct archive_write *,\n   54: \t\t    struct archive_entry *);\n   55: static int\tarchive_write_odc_options(struct archive_write *,\n   56  \t\t    const char *, const char *);\n   57  static int\tformat_octal(int64_t, void *, int);\n   58  static int64_t\tformat_octal_recursive(int64_t, char *, int);\n   59: static int\twrite_header(struct archive_write *, struct archive_entry *);\n   60  \n   61: struct cpio {\n   62  \tuint64_t\t  entry_bytes_remaining;\n   63  \n   64  \tint64_t\t\t  ino_next;\n   65  \n   66: \tstruct\t\t { int64_t old; int new;} *ino_list;\n   67  \tsize_t\t\t  ino_list_size;\n   68  \tsize_t\t\t  ino_list_next;\n   69  \n   70: \tstruct archive_string_conv *opt_sconv;\n   71: \tstruct archive_string_conv *sconv_default;\n   72  \tint\t\t  init_default_conversion;\n   73  };\n   ..\n  100   */\n  101  int\n  102: archive_write_set_format_cpio_odc(struct archive *_a)\n  103  {\n  104: \tstruct archive_write *a = (struct archive_write *)_a;\n  105: \tstruct cpio *cpio;\n  106  \n  107  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n  ...\n  112  \t\t(a->format_free)(a);\n  113  \n  114: \tcpio = (struct cpio *)calloc(1, sizeof(*cpio));\n  115  \tif (cpio == NULL) {\n  116  \t\tarchive_set_error(&a->archive, ENOMEM, \"Can't allocate cpio data\");\n  ...\n  131  \n  132  static int\n  133: archive_write_odc_options(struct archive_write *a, const char *key,\n  134      const char *val)\n  135  {\n  136: \tstruct cpio *cpio = (struct cpio *)a->format_data;\n  137  \tint ret = ARCHIVE_FAILED;\n  138  \n  ...\n  174   */\n  175  static int\n  176: synthesize_ino_value(struct cpio *cpio, struct archive_entry *entry)\n  177  {\n  178  \tint64_t ino = archive_entry_ino64(entry);\n  ...\n  225  \n  226  \n  227: static struct archive_string_conv *\n  228: get_sconv(struct archive_write *a)\n  229  {\n  230: \tstruct cpio *cpio;\n  231: \tstruct archive_string_conv *sconv;\n  232  \n  233: \tcpio = (struct cpio *)a->format_data;\n  234  \tsconv = cpio->opt_sconv;\n  235  \tif (sconv == NULL) {\n  ...\n  246  \n  247  static int\n  248: archive_write_odc_header(struct archive_write *a, struct archive_entry *entry)\n  249  {\n  250  \tconst char *path;\n  ...\n  275  \n  276  static int\n  277: write_header(struct archive_write *a, struct archive_entry *entry)\n  278  {\n  279: \tstruct cpio *cpio;\n  280  \tconst char *p, *path;\n  281  \tint pathlength, ret, ret_final;\n  282  \tint64_t\tino;\n  283  \tchar h[76];\n  284: \tstruct archive_string_conv *sconv;\n  285: \tstruct archive_entry *entry_main;\n  286  \tsize_t len;\n  287  \n  288: \tcpio = (struct cpio *)a->format_data;\n  289  \tret_final = ARCHIVE_OK;\n  290  \tsconv = get_sconv(a);\n  ...\n  415  \n  416  static ssize_t\n  417: archive_write_odc_data(struct archive_write *a, const void *buff, size_t s)\n  418  {\n  419: \tstruct cpio *cpio;\n  420  \tint ret;\n  421  \n  422: \tcpio = (struct cpio *)a->format_data;\n  423  \tif (s > cpio->entry_bytes_remaining)\n  424  \t\ts = (size_t)cpio->entry_bytes_remaining;\n  ...\n  463  \n  464  static int\n  465: archive_write_odc_close(struct archive_write *a)\n  466  {\n  467  \tint er;\n  468: \tstruct archive_entry *trailer;\n  469  \n  470  \ttrailer = archive_entry_new2(NULL);\n  ...\n  479  \n  480  static int\n  481: archive_write_odc_free(struct archive_write *a)\n  482  {\n  483: \tstruct cpio *cpio;\n  484  \n  485: \tcpio = (struct cpio *)a->format_data;\n  486  \tfree(cpio->ino_list);\n  487  \tfree(cpio);\n  ...\n  491  \n  492  static int\n  493: archive_write_odc_finish_entry(struct archive_write *a)\n  494  {\n  495: \tstruct cpio *cpio;\n  496  \n  497: \tcpio = (struct cpio *)a->format_data;\n  498  \treturn (__archive_write_nulls(a,\n  499  \t\t(size_t)cpio->entry_bytes_remaining));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter_compress.c:\n   88  #define\tCLEAR\t256\t\t/* Table clear output code. */\n   89  \n   90: struct private_data {\n   91  \tint64_t in_count, out_count, checkpoint;\n   92  \n   ..\n  109  };\n  110  \n  111: static int archive_compressor_compress_open(struct archive_write_filter *);\n  112: static int archive_compressor_compress_write(struct archive_write_filter *,\n  113  \t\t    const void *, size_t);\n  114: static int archive_compressor_compress_close(struct archive_write_filter *);\n  115: static int archive_compressor_compress_free(struct archive_write_filter *);\n  116  \n  117  #if ARCHIVE_VERSION_NUMBER < 4000000\n  118  int\n  119: archive_write_set_compression_compress(struct archive *a)\n  120  {\n  121  \t__archive_write_filters_free(a);\n  ...\n  128   */\n  129  int\n  130: archive_write_add_filter_compress(struct archive *_a)\n  131  {\n  132: \tstruct archive_write *a = (struct archive_write *)_a;\n  133: \tstruct archive_write_filter *f = __archive_write_allocate_filter(_a);\n  134  \n  135  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n  ...\n  145   */\n  146  static int\n  147: archive_compressor_compress_open(struct archive_write_filter *f)\n  148  {\n  149: \tstruct private_data *state;\n  150  \tsize_t bs = 65536, bpb;\n  151  \n  ...\n  153  \tf->name = \"compress\";\n  154  \n  155: \tstate = (struct private_data *)calloc(1, sizeof(*state));\n  156  \tif (state == NULL) {\n  157  \t\tarchive_set_error(f->archive, ENOMEM,\n  ...\n  217   * Algorithm:\n  218   * \tMaintain a BITS character long buffer (so that 8 codes will\n  219:  * fit in it exactly).  Use the VAX insv instruction to insert each\n  220   * code in turn.  When the buffer fills up empty it and start over.\n  221   */\n  ...\n  225  \n  226  static int\n  227: output_byte(struct archive_write_filter *f, unsigned char c)\n  228  {\n  229: \tstruct private_data *state = f->data;\n  230  \n  231  \tstate->compressed[state->compressed_offset++] = c;\n  ...\n  244  \n  245  static int\n  246: output_code(struct archive_write_filter *f, int ocode)\n  247  {\n  248: \tstruct private_data *state = f->data;\n  249  \tint bits, ret, clear_flg, bit_offset;\n  250  \n  ...\n  310  \n  311  static int\n  312: output_flush(struct archive_write_filter *f)\n  313  {\n  314: \tstruct private_data *state = f->data;\n  315  \tint ret;\n  316  \n  ...\n  330   */\n  331  static int\n  332: archive_compressor_compress_write(struct archive_write_filter *f,\n  333      const void *buff, size_t length)\n  334  {\n  335: \tstruct private_data *state = (struct private_data *)f->data;\n  336  \tint i;\n  337  \tint ratio;\n  ...\n  419   */\n  420  static int\n  421: archive_compressor_compress_close(struct archive_write_filter *f)\n  422  {\n  423: \tstruct private_data *state = (struct private_data *)f->data;\n  424  \tint ret;\n  425  \n  ...\n  438  \n  439  static int\n  440: archive_compressor_compress_free(struct archive_write_filter *f)\n  441  {\n  442: \tstruct private_data *state = (struct private_data *)f->data;\n  443  \n  444  \tfree(state->compressed);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_private.h:\n   38  #include \"archive_entry.h\"\n   39  \n   40: void __archive_write_entry_filetype_unsupported(struct archive *a,\n   41:     struct archive_entry *entry, const char *format);\n   42  #endif\n   43  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_match.c:\n   46  #include \"archive_string.h\"\n   47  \n   48: struct match {\n   49: \tstruct match\t\t*next;\n   50  \tint\t\t\t matches;\n   51: \tstruct archive_mstring\t pattern;\n   52  };\n   53  \n   54: struct match_list {\n   55: \tstruct match\t\t*first;\n   56: \tstruct match\t\t**last;\n   57  \tint\t\t\t count;\n   58  \tint\t\t\t unmatched_count;\n   59: \tstruct match\t\t*unmatched_next;\n   60  \tint\t\t\t unmatched_eof;\n   61  };\n   62  \n   63: struct match_file {\n   64: \tstruct archive_rb_node\t node;\n   65: \tstruct match_file\t*next;\n   66: \tstruct archive_mstring\t pathname;\n   67  \tint\t\t\t flag;\n   68  \ttime_t\t\t\t mtime_sec;\n   ..\n   72  };\n   73  \n   74: struct entry_list {\n   75: \tstruct match_file\t*first;\n   76: \tstruct match_file\t**last;\n   77  \tint\t\t\t count;\n   78  };\n   79  \n   80: struct id_array {\n   81  \tsize_t\t\t\t size;/* Allocated size */\n   82  \tsize_t\t\t\t count;\n   ..\n   88  #define ID_IS_SET\t\t4\n   89  \n   90: struct archive_match {\n   91: \tstruct archive\t\t archive;\n   92  \n   93  \t/* exclusion/inclusion set flag. */\n   ..\n  100  \t * Matching filename patterns.\n  101  \t */\n  102: \tstruct match_list\t exclusions;\n  103: \tstruct match_list\t inclusions;\n  104  \n  105  \t/*\n  ...\n  122  \t * Matching time stamps with its filename.\n  123  \t */\n  124: \tstruct archive_rb_tree\t exclusion_tree;\n  125: \tstruct entry_list \t exclusion_entry_list;\n  126  \n  127  \t/*\n  128  \t * Matching file owners.\n  129  \t */\n  130: \tstruct id_array \t inclusion_uids;\n  131: \tstruct id_array \t inclusion_gids;\n  132: \tstruct match_list\t inclusion_unames;\n  133: \tstruct match_list\t inclusion_gnames;\n  134  };\n  135  \n  136: static int\tadd_pattern_from_file(struct archive_match *,\n  137: \t\t    struct match_list *, int, const void *, int);\n  138: static int\tadd_entry(struct archive_match *, int,\n  139: \t\t    struct archive_entry *);\n  140: static int\tadd_owner_id(struct archive_match *, struct id_array *,\n  141  \t\t    int64_t);\n  142: static int\tadd_owner_name(struct archive_match *, struct match_list *,\n  143  \t\t    int, const void *);\n  144: static int\tadd_pattern_mbs(struct archive_match *, struct match_list *,\n  145  \t\t    const char *);\n  146: static int\tadd_pattern_wcs(struct archive_match *, struct match_list *,\n  147  \t\t    const wchar_t *);\n  148: static int\tcmp_key_mbs(const struct archive_rb_node *, const void *);\n  149: static int\tcmp_key_wcs(const struct archive_rb_node *, const void *);\n  150: static int\tcmp_node_mbs(const struct archive_rb_node *,\n  151: \t\t    const struct archive_rb_node *);\n  152: static int\tcmp_node_wcs(const struct archive_rb_node *,\n  153: \t\t    const struct archive_rb_node *);\n  154: static void\tentry_list_add(struct entry_list *, struct match_file *);\n  155: static void\tentry_list_free(struct entry_list *);\n  156: static void\tentry_list_init(struct entry_list *);\n  157: static int\terror_nomem(struct archive_match *);\n  158: static void\tmatch_list_add(struct match_list *, struct match *);\n  159: static void\tmatch_list_free(struct match_list *);\n  160: static void\tmatch_list_init(struct match_list *);\n  161: static int\tmatch_list_unmatched_inclusions_next(struct archive_match *,\n  162: \t\t    struct match_list *, int, const void **);\n  163: static int\tmatch_owner_id(struct id_array *, int64_t);\n  164  #if !defined(_WIN32) || defined(__CYGWIN__)\n  165: static int\tmatch_owner_name_mbs(struct archive_match *,\n  166: \t\t    struct match_list *, const char *);\n  167  #else\n  168: static int\tmatch_owner_name_wcs(struct archive_match *,\n  169: \t\t    struct match_list *, const wchar_t *);\n  170  #endif\n  171: static int\tmatch_path_exclusion(struct archive_match *,\n  172: \t\t    struct match *, int, const void *);\n  173: static int\tmatch_path_inclusion(struct archive_match *,\n  174: \t\t    struct match *, int, const void *);\n  175: static int\towner_excluded(struct archive_match *,\n  176: \t\t    struct archive_entry *);\n  177: static int\tpath_excluded(struct archive_match *, int, const void *);\n  178: static int\tset_timefilter(struct archive_match *, int, time_t, long,\n  179  \t\t    time_t, long);\n  180: static int\tset_timefilter_pathname_mbs(struct archive_match *,\n  181  \t\t    int, const char *);\n  182: static int\tset_timefilter_pathname_wcs(struct archive_match *,\n  183  \t\t    int, const wchar_t *);\n  184: static int\tset_timefilter_date(struct archive_match *, int, const char *);\n  185: static int\tset_timefilter_date_w(struct archive_match *, int,\n  186  \t\t    const wchar_t *);\n  187: static int\ttime_excluded(struct archive_match *,\n  188: \t\t    struct archive_entry *);\n  189: static int\tvalidate_time_flag(struct archive *, int, const char *);\n  190  \n  191  #define get_date __archive_get_date\n  192  \n  193: static const struct archive_rb_tree_ops rb_ops_mbs = {\n  194  \tcmp_node_mbs, cmp_key_mbs\n  195  };\n  196  \n  197: static const struct archive_rb_tree_ops rb_ops_wcs = {\n  198  \tcmp_node_wcs, cmp_key_wcs\n  199  };\n  ...\n  207  \n  208  static int\n  209: error_nomem(struct archive_match *a)\n  210  {\n  211  \tarchive_set_error(&(a->archive), ENOMEM, \"No memory\");\n  ...\n  217   * Create an ARCHIVE_MATCH object.\n  218   */\n  219: struct archive *\n  220  archive_match_new(void)\n  221  {\n  222: \tstruct archive_match *a;\n  223  \n  224: \ta = (struct archive_match *)calloc(1, sizeof(*a));\n  225  \tif (a == NULL)\n  226  \t\treturn (NULL);\n  ...\n  242   */\n  243  int\n  244: archive_match_free(struct archive *_a)\n  245  {\n  246: \tstruct archive_match *a;\n  247  \n  248  \tif (_a == NULL)\n  ...\n  250  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  251  \t    ARCHIVE_STATE_ANY | ARCHIVE_STATE_FATAL, \"archive_match_free\");\n  252: \ta = (struct archive_match *)_a;\n  253  \tmatch_list_free(&(a->inclusions));\n  254  \tmatch_list_free(&(a->exclusions));\n  ...\n  270   */\n  271  int\n  272: archive_match_excluded(struct archive *_a, struct archive_entry *entry)\n  273  {\n  274: \tstruct archive_match *a;\n  275  \tint r;\n  276  \n  ...\n  278  \t    ARCHIVE_STATE_NEW, \"archive_match_excluded_ae\");\n  279  \n  280: \ta = (struct archive_match *)_a;\n  281  \tif (entry == NULL) {\n  282  \t\tarchive_set_error(&(a->archive), EINVAL, \"entry is NULL\");\n  ...\n  311  \n  312  int\n  313: archive_match_exclude_pattern(struct archive *_a, const char *pattern)\n  314  {\n  315: \tstruct archive_match *a;\n  316  \tint r;\n  317  \n  318  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  319  \t    ARCHIVE_STATE_NEW, \"archive_match_exclude_pattern\");\n  320: \ta = (struct archive_match *)_a;\n  321  \n  322  \tif (pattern == NULL || *pattern == '\\0') {\n  ...\n  330  \n  331  int\n  332: archive_match_exclude_pattern_w(struct archive *_a, const wchar_t *pattern)\n  333  {\n  334: \tstruct archive_match *a;\n  335  \tint r;\n  336  \n  337  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  338  \t    ARCHIVE_STATE_NEW, \"archive_match_exclude_pattern_w\");\n  339: \ta = (struct archive_match *)_a;\n  340  \n  341  \tif (pattern == NULL || *pattern == L'\\0') {\n  ...\n  349  \n  350  int\n  351: archive_match_exclude_pattern_from_file(struct archive *_a,\n  352      const char *pathname, int nullSeparator)\n  353  {\n  354: \tstruct archive_match *a;\n  355  \n  356  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  357  \t    ARCHIVE_STATE_NEW, \"archive_match_exclude_pattern_from_file\");\n  358: \ta = (struct archive_match *)_a;\n  359  \n  360  \treturn add_pattern_from_file(a, &(a->exclusions), 1, pathname,\n  ...\n  363  \n  364  int\n  365: archive_match_exclude_pattern_from_file_w(struct archive *_a,\n  366      const wchar_t *pathname, int nullSeparator)\n  367  {\n  368: \tstruct archive_match *a;\n  369  \n  370  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  371  \t    ARCHIVE_STATE_NEW, \"archive_match_exclude_pattern_from_file_w\");\n  372: \ta = (struct archive_match *)_a;\n  373  \n  374  \treturn add_pattern_from_file(a, &(a->exclusions), 0, pathname,\n  ...\n  377  \n  378  int\n  379: archive_match_include_pattern(struct archive *_a, const char *pattern)\n  380  {\n  381: \tstruct archive_match *a;\n  382  \tint r;\n  383  \n  384  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  385  \t    ARCHIVE_STATE_NEW, \"archive_match_include_pattern\");\n  386: \ta = (struct archive_match *)_a;\n  387  \n  388  \tif (pattern == NULL || *pattern == '\\0') {\n  ...\n  396  \n  397  int\n  398: archive_match_include_pattern_w(struct archive *_a, const wchar_t *pattern)\n  399  {\n  400: \tstruct archive_match *a;\n  401  \tint r;\n  402  \n  403  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  404  \t    ARCHIVE_STATE_NEW, \"archive_match_include_pattern_w\");\n  405: \ta = (struct archive_match *)_a;\n  406  \n  407  \tif (pattern == NULL || *pattern == L'\\0') {\n  ...\n  415  \n  416  int\n  417: archive_match_include_pattern_from_file(struct archive *_a,\n  418      const char *pathname, int nullSeparator)\n  419  {\n  420: \tstruct archive_match *a;\n  421  \n  422  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  423  \t    ARCHIVE_STATE_NEW, \"archive_match_include_pattern_from_file\");\n  424: \ta = (struct archive_match *)_a;\n  425  \n  426  \treturn add_pattern_from_file(a, &(a->inclusions), 1, pathname,\n  ...\n  429  \n  430  int\n  431: archive_match_include_pattern_from_file_w(struct archive *_a,\n  432      const wchar_t *pathname, int nullSeparator)\n  433  {\n  434: \tstruct archive_match *a;\n  435  \n  436  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  437  \t    ARCHIVE_STATE_NEW, \"archive_match_include_pattern_from_file_w\");\n  438: \ta = (struct archive_match *)_a;\n  439  \n  440  \treturn add_pattern_from_file(a, &(a->inclusions), 0, pathname,\n  ...\n  450   */\n  451  int\n  452: archive_match_path_excluded(struct archive *_a,\n  453:     struct archive_entry *entry)\n  454  {\n  455: \tstruct archive_match *a;\n  456  \n  457  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  458  \t    ARCHIVE_STATE_NEW, \"archive_match_path_excluded\");\n  459  \n  460: \ta = (struct archive_match *)_a;\n  461  \tif (entry == NULL) {\n  462  \t\tarchive_set_error(&(a->archive), EINVAL, \"entry is NULL\");\n  ...\n  486   */\n  487  int\n  488: archive_match_set_inclusion_recursion(struct archive *_a, int enabled)\n  489  {\n  490: \tstruct archive_match *a;\n  491  \n  492  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  493  \t    ARCHIVE_STATE_NEW, \"archive_match_set_inclusion_recursion\");\n  494: \ta = (struct archive_match *)_a;\n  495  \ta->recursive_include = enabled;\n  496  \treturn (ARCHIVE_OK);\n  ...\n  501   */\n  502  int\n  503: archive_match_path_unmatched_inclusions(struct archive *_a)\n  504  {\n  505: \tstruct archive_match *a;\n  506  \n  507  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  508  \t    ARCHIVE_STATE_NEW, \"archive_match_unmatched_inclusions\");\n  509: \ta = (struct archive_match *)_a;\n  510  \n  511  \treturn (a->inclusions.unmatched_count);\n  ...\n  513  \n  514  int\n  515: archive_match_path_unmatched_inclusions_next(struct archive *_a,\n  516      const char **_p)\n  517  {\n  518: \tstruct archive_match *a;\n  519  \tconst void *v;\n  520  \tint r;\n  ...\n  522  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  523  \t    ARCHIVE_STATE_NEW, \"archive_match_unmatched_inclusions_next\");\n  524: \ta = (struct archive_match *)_a;\n  525  \n  526  \tr = match_list_unmatched_inclusions_next(a, &(a->inclusions), 1, &v);\n  ...\n  530  \n  531  int\n  532: archive_match_path_unmatched_inclusions_next_w(struct archive *_a,\n  533      const wchar_t **_p)\n  534  {\n  535: \tstruct archive_match *a;\n  536  \tconst void *v;\n  537  \tint r;\n  ...\n  539  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  540  \t    ARCHIVE_STATE_NEW, \"archive_match_unmatched_inclusions_next_w\");\n  541: \ta = (struct archive_match *)_a;\n  542  \n  543  \tr = match_list_unmatched_inclusions_next(a, &(a->inclusions), 0, &v);\n  ...\n  550   */\n  551  static int\n  552: add_pattern_mbs(struct archive_match *a, struct match_list *list,\n  553      const char *pattern)\n  554  {\n  555: \tstruct match *match;\n  556  \tsize_t len;\n  557  \n  ...\n  570  \n  571  static int\n  572: add_pattern_wcs(struct archive_match *a, struct match_list *list,\n  573      const wchar_t *pattern)\n  574  {\n  575: \tstruct match *match;\n  576  \tsize_t len;\n  577  \n  ...\n  590  \n  591  static int\n  592: add_pattern_from_file(struct archive_match *a, struct match_list *mlist,\n  593      int mbs, const void *pathname, int nullSeparator)\n  594  {\n  595: \tstruct archive *ar;\n  596: \tstruct archive_entry *ae;\n  597: \tstruct archive_string as;\n  598  \tconst void *buff;\n  599  \tsize_t size;\n  ...\n  709   */\n  710  static int\n  711: path_excluded(struct archive_match *a, int mbs, const void *pathname)\n  712  {\n  713: \tstruct match *match;\n  714: \tstruct match *matched;\n  715  \tint r;\n  716  \n  ...\n  777   */\n  778  static int\n  779: match_path_exclusion(struct archive_match *a, struct match *m,\n  780      int mbs, const void *pn)\n  781  {\n  ...\n  805   */\n  806  static int\n  807: match_path_inclusion(struct archive_match *a, struct match *m,\n  808      int mbs, const void *pn)\n  809  {\n  ...\n  832  \n  833  static void\n  834: match_list_init(struct match_list *list)\n  835  {\n  836  \tlist->first = NULL;\n  ...\n  840  \n  841  static void\n  842: match_list_free(struct match_list *list)\n  843  {\n  844: \tstruct match *p, *q;\n  845  \n  846  \tfor (p = list->first; p != NULL; ) {\n  ...\n  853  \n  854  static void\n  855: match_list_add(struct match_list *list, struct match *m)\n  856  {\n  857  \t*list->last = m;\n  ...\n  862  \n  863  static int\n  864: match_list_unmatched_inclusions_next(struct archive_match *a,\n  865:     struct match_list *list, int mbs, const void **vp)\n  866  {\n  867: \tstruct match *m;\n  868  \n  869  \t*vp = NULL;\n  ...\n  916   */\n  917  int\n  918: archive_match_include_time(struct archive *_a, int flag, time_t sec,\n  919      long nsec)\n  920  {\n  ...\n  924  \tif (r != ARCHIVE_OK)\n  925  \t\treturn (r);\n  926: \treturn set_timefilter((struct archive_match *)_a, flag,\n  927  \t\t\tsec, nsec, sec, nsec);\n  928  }\n  929  \n  930  int\n  931: archive_match_include_date(struct archive *_a, int flag,\n  932      const char *datestr)\n  933  {\n  ...\n  937  \tif (r != ARCHIVE_OK)\n  938  \t\treturn (r);\n  939: \treturn set_timefilter_date((struct archive_match *)_a, flag, datestr);\n  940  }\n  941  \n  942  int\n  943: archive_match_include_date_w(struct archive *_a, int flag,\n  944      const wchar_t *datestr)\n  945  {\n  ...\n  950  \t\treturn (r);\n  951  \n  952: \treturn set_timefilter_date_w((struct archive_match *)_a, flag, datestr);\n  953  }\n  954  \n  955  int\n  956: archive_match_include_file_time(struct archive *_a, int flag,\n  957      const char *pathname)\n  958  {\n  ...\n  962  \tif (r != ARCHIVE_OK)\n  963  \t\treturn (r);\n  964: \treturn set_timefilter_pathname_mbs((struct archive_match *)_a,\n  965  \t\t\tflag, pathname);\n  966  }\n  967  \n  968  int\n  969: archive_match_include_file_time_w(struct archive *_a, int flag,\n  970      const wchar_t *pathname)\n  971  {\n  ...\n  975  \tif (r != ARCHIVE_OK)\n  976  \t\treturn (r);\n  977: \treturn set_timefilter_pathname_wcs((struct archive_match *)_a,\n  978  \t\t\tflag, pathname);\n  979  }\n  980  \n  981  int\n  982: archive_match_exclude_entry(struct archive *_a, int flag,\n  983:     struct archive_entry *entry)\n  984  {\n  985: \tstruct archive_match *a;\n  986  \tint r;\n  987  \n  988  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n  989  \t    ARCHIVE_STATE_NEW, \"archive_match_time_include_entry\");\n  990: \ta = (struct archive_match *)_a;\n  991  \n  992  \tif (entry == NULL) {\n  ...\n 1008   */\n 1009  int\n 1010: archive_match_time_excluded(struct archive *_a,\n 1011:     struct archive_entry *entry)\n 1012  {\n 1013: \tstruct archive_match *a;\n 1014  \n 1015  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n 1016  \t    ARCHIVE_STATE_NEW, \"archive_match_time_excluded_ae\");\n 1017  \n 1018: \ta = (struct archive_match *)_a;\n 1019  \tif (entry == NULL) {\n 1020  \t\tarchive_set_error(&(a->archive), EINVAL, \"entry is NULL\");\n ....\n 1030  \n 1031  static int\n 1032: validate_time_flag(struct archive *_a, int flag, const char *_fn)\n 1033  {\n 1034  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n ....\n 1065  \tARCHIVE_MATCH_NEWER | ARCHIVE_MATCH_OLDER)) == ARCHIVE_MATCH_EQUAL)\n 1066  static int\n 1067: set_timefilter(struct archive_match *a, int timetype,\n 1068      time_t mtime_sec, long mtime_nsec, time_t ctime_sec, long ctime_nsec)\n 1069  {\n ....\n 1100  \n 1101  static int\n 1102: set_timefilter_date(struct archive_match *a, int timetype, const char *datestr)\n 1103  {\n 1104  \ttime_t t;\n ....\n 1117  \n 1118  static int\n 1119: set_timefilter_date_w(struct archive_match *a, int timetype,\n 1120      const wchar_t *datestr)\n 1121  {\n 1122: \tstruct archive_string as;\n 1123  \ttime_t t;\n 1124  \n ....\n 1149  #define EPOC_TIME ARCHIVE_LITERAL_ULL(116444736000000000)\n 1150  static int\n 1151: set_timefilter_find_data(struct archive_match *a, int timetype,\n 1152      DWORD ftLastWriteTime_dwHighDateTime, DWORD ftLastWriteTime_dwLowDateTime,\n 1153      DWORD ftCreationTime_dwHighDateTime, DWORD ftCreationTime_dwLowDateTime)\n ....\n 1182  \n 1183  static int\n 1184: set_timefilter_pathname_mbs(struct archive_match *a, int timetype,\n 1185      const char *path)\n 1186  {\n ....\n 1207  \n 1208  static int\n 1209: set_timefilter_pathname_wcs(struct archive_match *a, int timetype,\n 1210      const wchar_t *path)\n 1211  {\n ....\n 1233  \n 1234  static int\n 1235: set_timefilter_stat(struct archive_match *a, int timetype, struct stat *st)\n 1236  {\n 1237: \tstruct archive_entry *ae;\n 1238  \ttime_t ctime_sec, mtime_sec;\n 1239  \tlong ctime_ns, mtime_ns;\n ....\n 1253  \n 1254  static int\n 1255: set_timefilter_pathname_mbs(struct archive_match *a, int timetype,\n 1256      const char *path)\n 1257  {\n 1258: \tstruct stat st;\n 1259  \n 1260  \tif (path == NULL || *path == '\\0') {\n ....\n 1270  \n 1271  static int\n 1272: set_timefilter_pathname_wcs(struct archive_match *a, int timetype,\n 1273      const wchar_t *path)\n 1274  {\n 1275: \tstruct archive_string as;\n 1276  \tint r;\n 1277  \n ....\n 1303   */\n 1304  static int\n 1305: cmp_node_mbs(const struct archive_rb_node *n1,\n 1306:     const struct archive_rb_node *n2)\n 1307  {\n 1308: \tstruct match_file *f1 = (struct match_file *)(uintptr_t)n1;\n 1309: \tstruct match_file *f2 = (struct match_file *)(uintptr_t)n2;\n 1310  \tconst char *p1, *p2;\n 1311  \n ....\n 1320          \n 1321  static int\n 1322: cmp_key_mbs(const struct archive_rb_node *n, const void *key)\n 1323  {\n 1324: \tstruct match_file *f = (struct match_file *)(uintptr_t)n;\n 1325  \tconst char *p;\n 1326  \n ....\n 1332  \n 1333  static int\n 1334: cmp_node_wcs(const struct archive_rb_node *n1,\n 1335:     const struct archive_rb_node *n2)\n 1336  {\n 1337: \tstruct match_file *f1 = (struct match_file *)(uintptr_t)n1;\n 1338: \tstruct match_file *f2 = (struct match_file *)(uintptr_t)n2;\n 1339  \tconst wchar_t *p1, *p2;\n 1340  \n ....\n 1349          \n 1350  static int\n 1351: cmp_key_wcs(const struct archive_rb_node *n, const void *key)\n 1352  {\n 1353: \tstruct match_file *f = (struct match_file *)(uintptr_t)n;\n 1354  \tconst wchar_t *p;\n 1355  \n ....\n 1361  \n 1362  static void\n 1363: entry_list_init(struct entry_list *list)\n 1364  {\n 1365  \tlist->first = NULL;\n ....\n 1369  \n 1370  static void\n 1371: entry_list_free(struct entry_list *list)\n 1372  {\n 1373: \tstruct match_file *p, *q;\n 1374  \n 1375  \tfor (p = list->first; p != NULL; ) {\n ....\n 1382  \n 1383  static void\n 1384: entry_list_add(struct entry_list *list, struct match_file *file)\n 1385  {\n 1386  \t*list->last = file;\n ....\n 1390  \n 1391  static int\n 1392: add_entry(struct archive_match *a, int flag,\n 1393:     struct archive_entry *entry)\n 1394  {\n 1395: \tstruct match_file *f;\n 1396  \tconst void *pathname;\n 1397  \tint r;\n ....\n 1428  \tr = __archive_rb_tree_insert_node(&(a->exclusion_tree), &(f->node));\n 1429  \tif (!r) {\n 1430: \t\tstruct match_file *f2;\n 1431  \n 1432  \t\t/* Get the duplicated file. */\n 1433: \t\tf2 = (struct match_file *)__archive_rb_tree_find_node(\n 1434  \t\t\t&(a->exclusion_tree), pathname);\n 1435  \n ....\n 1462   */\n 1463  static int\n 1464: time_excluded(struct archive_match *a, struct archive_entry *entry)\n 1465  {\n 1466: \tstruct match_file *f;\n 1467  \tconst void *pathname;\n 1468  \ttime_t sec;\n ....\n 1558  \t\treturn (0);\n 1559  \n 1560: \tf = (struct match_file *)__archive_rb_tree_find_node(\n 1561  \t\t&(a->exclusion_tree), pathname);\n 1562  \t/* If the file wasn't rejected, include it. */\n ....\n 1612  \n 1613  int\n 1614: archive_match_include_uid(struct archive *_a, la_int64_t uid)\n 1615  {\n 1616: \tstruct archive_match *a;\n 1617  \n 1618  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n 1619  \t    ARCHIVE_STATE_NEW, \"archive_match_include_uid\");\n 1620: \ta = (struct archive_match *)_a;\n 1621  \treturn (add_owner_id(a, &(a->inclusion_uids), uid));\n 1622  }\n 1623  \n 1624  int\n 1625: archive_match_include_gid(struct archive *_a, la_int64_t gid)\n 1626  {\n 1627: \tstruct archive_match *a;\n 1628  \n 1629  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n 1630  \t    ARCHIVE_STATE_NEW, \"archive_match_include_gid\");\n 1631: \ta = (struct archive_match *)_a;\n 1632  \treturn (add_owner_id(a, &(a->inclusion_gids), gid));\n 1633  }\n 1634  \n 1635  int\n 1636: archive_match_include_uname(struct archive *_a, const char *uname)\n 1637  {\n 1638: \tstruct archive_match *a;\n 1639  \n 1640  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n 1641  \t    ARCHIVE_STATE_NEW, \"archive_match_include_uname\");\n 1642: \ta = (struct archive_match *)_a;\n 1643  \treturn (add_owner_name(a, &(a->inclusion_unames), 1, uname));\n 1644  }\n 1645  \n 1646  int\n 1647: archive_match_include_uname_w(struct archive *_a, const wchar_t *uname)\n 1648  {\n 1649: \tstruct archive_match *a;\n 1650  \n 1651  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n 1652  \t    ARCHIVE_STATE_NEW, \"archive_match_include_uname_w\");\n 1653: \ta = (struct archive_match *)_a;\n 1654  \treturn (add_owner_name(a, &(a->inclusion_unames), 0, uname));\n 1655  }\n 1656  \n 1657  int\n 1658: archive_match_include_gname(struct archive *_a, const char *gname)\n 1659  {\n 1660: \tstruct archive_match *a;\n 1661  \n 1662  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n 1663  \t    ARCHIVE_STATE_NEW, \"archive_match_include_gname\");\n 1664: \ta = (struct archive_match *)_a;\n 1665  \treturn (add_owner_name(a, &(a->inclusion_gnames), 1, gname));\n 1666  }\n 1667  \n 1668  int\n 1669: archive_match_include_gname_w(struct archive *_a, const wchar_t *gname)\n 1670  {\n 1671: \tstruct archive_match *a;\n 1672  \n 1673  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n 1674  \t    ARCHIVE_STATE_NEW, \"archive_match_include_gname_w\");\n 1675: \ta = (struct archive_match *)_a;\n 1676  \treturn (add_owner_name(a, &(a->inclusion_gnames), 0, gname));\n 1677  }\n ....\n 1685   */\n 1686  int\n 1687: archive_match_owner_excluded(struct archive *_a,\n 1688:     struct archive_entry *entry)\n 1689  {\n 1690: \tstruct archive_match *a;\n 1691  \n 1692  \tarchive_check_magic(_a, ARCHIVE_MATCH_MAGIC,\n 1693  \t    ARCHIVE_STATE_NEW, \"archive_match_id_excluded_ae\");\n 1694  \n 1695: \ta = (struct archive_match *)_a;\n 1696  \tif (entry == NULL) {\n 1697  \t\tarchive_set_error(&(a->archive), EINVAL, \"entry is NULL\");\n ....\n 1707  \n 1708  static int\n 1709: add_owner_id(struct archive_match *a, struct id_array *ids, int64_t id)\n 1710  {\n 1711  \tunsigned i;\n ....\n 1744  \n 1745  static int\n 1746: match_owner_id(struct id_array *ids, int64_t id)\n 1747  {\n 1748  \tunsigned b, m, t;\n ....\n 1763  \n 1764  static int\n 1765: add_owner_name(struct archive_match *a, struct match_list *list,\n 1766      int mbs, const void *name)\n 1767  {\n 1768: \tstruct match *match;\n 1769  \n 1770  \tmatch = calloc(1, sizeof(*match));\n ....\n 1782  #if !defined(_WIN32) || defined(__CYGWIN__)\n 1783  static int\n 1784: match_owner_name_mbs(struct archive_match *a, struct match_list *list,\n 1785      const char *name)\n 1786  {\n 1787: \tstruct match *m;\n 1788  \tconst char *p;\n 1789  \n ....\n 1803  #else\n 1804  static int\n 1805: match_owner_name_wcs(struct archive_match *a, struct match_list *list,\n 1806      const wchar_t *name)\n 1807  {\n 1808: \tstruct match *m;\n 1809  \tconst wchar_t *p;\n 1810  \n ....\n 1828   */\n 1829  static int\n 1830: owner_excluded(struct archive_match *a, struct archive_entry *entry)\n 1831  {\n 1832  \tint r;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_getdate.c:\n   56  enum { tAGO = 260, tDAY, tDAYZONE, tAMPM, tMONTH, tMONTH_UNIT, tSEC_UNIT,\n   57         tUNUMBER, tZONE, tDST };\n   58: struct token { int token; time_t value; };\n   59  \n   60  /*\n   61   * Parser state.\n   62   */\n   63: struct gdstate {\n   64: \tstruct token *tokenp; /* Pointer to next token. */\n   65  \t/* HaveXxxx counts how many of this kind of phrase we've seen;\n   66  \t * it's a fatal error to have more than one time, zone, day,\n   ..\n  103   */\n  104  static int\n  105: timephrase(struct gdstate *gds)\n  106  {\n  107  \tif (gds->tokenp[0].token == tUNUMBER\n  ...\n  173   */\n  174  static int\n  175: zonephrase(struct gdstate *gds)\n  176  {\n  177  \tif (gds->tokenp[0].token == tZONE\n  ...\n  206   */\n  207  static int\n  208: datephrase(struct gdstate *gds)\n  209  {\n  210  \tif (gds->tokenp[0].token == tUNUMBER\n  ...\n  347   */\n  348  static int\n  349: relunitphrase(struct gdstate *gds)\n  350  {\n  351  \tif (gds->tokenp[0].token == '-'\n  ...\n  422   */\n  423  static int\n  424: dayphrase(struct gdstate *gds)\n  425  {\n  426  \tif (gds->tokenp[0].token == tDAY) {\n  ...\n  451   */\n  452  static int\n  453: phrase(struct gdstate *gds)\n  454  {\n  455  \tif (timephrase(gds))\n  ...\n  517   * A dictionary of time words.\n  518   */\n  519: static struct LEXICON {\n  520  \tsize_t\t\tabbrev;\n  521  \tconst char\t*name;\n  ...\n  698  \ttime_t\t\tJulian;\n  699  \tint\t\ti;\n  700: \tstruct tm\t*ltime;\n  701  #if defined(HAVE_LOCALTIME_R) || defined(HAVE__LOCALTIME64_S)\n  702: \tstruct tm\ttmbuf;\n  703  #endif\n  704  #if defined(HAVE__LOCALTIME64_S)\n  ...\n  755  \ttime_t\t\tStartDay;\n  756  \ttime_t\t\tFutureDay;\n  757: \tstruct tm\t*ltime;\n  758  #if defined(HAVE_LOCALTIME_R) || defined(HAVE__LOCALTIME64_S)\n  759: \tstruct tm\ttmbuf;\n  760  #endif\n  761  #if defined(HAVE__LOCALTIME64_S)\n  ...\n  798      time_t DayOrdinal, time_t DayNumber)\n  799  {\n  800: \tstruct tm\t*tm;\n  801  \ttime_t\tt, now;\n  802  #if defined(HAVE_GMTIME_R) || defined(HAVE__GMTIME64_S)\n  803: \tstruct tm\ttmbuf;\n  804  #endif\n  805  #if defined(HAVE__GMTIME64_S)\n  ...\n  833  RelativeMonth(time_t Start, time_t Timezone, time_t RelMonth)\n  834  {\n  835: \tstruct tm\t*tm;\n  836  \ttime_t\tMonth;\n  837  \ttime_t\tYear;\n  838  #if defined(HAVE_LOCALTIME_R) || defined(HAVE__LOCALTIME64_S)\n  839: \tstruct tm\ttmbuf;\n  840  #endif\n  841  #if defined(HAVE__LOCALTIME64_S)\n  ...\n  899  \t\t{\n  900  \t\t\tconst char *src = *in;\n  901: \t\t\tconst struct LEXICON *tp;\n  902  \t\t\tunsigned i = 0;\n  903  \n  ...\n  957  /* Yield A - B, measured in seconds.  */\n  958  static long\n  959: difftm (struct tm *a, struct tm *b)\n  960  {\n  961  \tint ay = a->tm_year + (TM_YEAR_ORIGIN - 1);\n  ...\n  985  __archive_get_date(time_t now, const char *p)\n  986  {\n  987: \tstruct token\ttokens[256];\n  988: \tstruct gdstate\t_gds;\n  989: \tstruct token\t*lasttoken;\n  990: \tstruct gdstate\t*gds;\n  991: \tstruct tm\tlocal, *tm;\n  992: \tstruct tm\tgmt, *gmt_ptr;\n  993  \ttime_t\t\tStart;\n  994  \ttime_t\t\ttod;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_disk_private.h:\n   36  #include \"archive_platform_acl.h\"\n   37  \n   38: struct tree;\n   39: struct archive_entry;\n   40  \n   41: struct archive_read_disk {\n   42: \tstruct archive\tarchive;\n   43  \n   44  \t/* Reused by archive_read_next_header() */\n   45: \tstruct archive_entry *entry;\n   46  \n   47  \t/*\n   ..\n   61  \n   62  \t/* Directory traversals. */\n   63: \tstruct tree *tree;\n   64: \tint\t(*open_on_current_dir)(struct tree*, const char *, int);\n   65: \tint\t(*tree_current_dir_fd)(struct tree*);\n   66: \tint\t(*tree_enter_working_dir)(struct tree*);\n   67  \n   68  \t/* Bitfield with ARCHIVE_READDISK_* tunables */\n   ..\n   76  \tvoid\t *lookup_uname_data;\n   77  \n   78: \tint\t(*metadata_filter_func)(struct archive *, void *,\n   79: \t\t\tstruct archive_entry *);\n   80  \tvoid\t*metadata_filter_data;\n   81  \n   82  \t/* ARCHIVE_MATCH object. */\n   83: \tstruct archive\t*matching;\n   84  \t/* Callback function, this will be invoked when ARCHIVE_MATCH\n   85  \t * archive_match_*_excluded_ae return true. */\n   86: \tvoid\t(*excluded_cb_func)(struct archive *, void *,\n   87: \t\t\t struct archive_entry *);\n   88  \tvoid\t*excluded_cb_data;\n   89  };\n   90  \n   91  const char *\n   92: archive_read_disk_entry_setup_path(struct archive_read_disk *,\n   93:     struct archive_entry *, int *);\n   94  \n   95  int\n   96: archive_read_disk_entry_setup_acls(struct archive_read_disk *,\n   97:     struct archive_entry *, int *);\n   98  #endif\n   99  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_open_memory.c:\n   33  #include \"archive.h\"\n   34  \n   35: struct write_memory_data {\n   36  \tsize_t\tused;\n   37  \tsize_t  size;\n   ..\n   40  };\n   41  \n   42: static int\tmemory_write_free(struct archive *, void *);\n   43: static int\tmemory_write_open(struct archive *, void *);\n   44: static ssize_t\tmemory_write(struct archive *, void *, const void *buff, size_t);\n   45  \n   46  /*\n   ..\n   50   */\n   51  int\n   52: archive_write_open_memory(struct archive *a, void *buff, size_t buffSize, size_t *used)\n   53  {\n   54: \tstruct write_memory_data *mine;\n   55  \n   56: \tmine = (struct write_memory_data *)calloc(1, sizeof(*mine));\n   57  \tif (mine == NULL) {\n   58  \t\tarchive_set_error(a, ENOMEM, \"No memory\");\n   ..\n   67  \n   68  static int\n   69: memory_write_open(struct archive *a, void *client_data)\n   70  {\n   71: \tstruct write_memory_data *mine;\n   72  \tmine = client_data;\n   73  \tmine->used = 0;\n   ..\n   87   */\n   88  static ssize_t\n   89: memory_write(struct archive *a, void *client_data, const void *buff, size_t length)\n   90  {\n   91: \tstruct write_memory_data *mine;\n   92  \tmine = client_data;\n   93  \n   ..\n  104  \n  105  static int\n  106: memory_write_free(struct archive *a, void *client_data)\n  107  {\n  108: \tstruct write_memory_data *mine;\n  109  \t(void)a; /* UNUSED */\n  110  \tmine = client_data;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_open_fd.c:\n   51  #include \"archive.h\"\n   52  \n   53: struct read_fd_data {\n   54  \tint\t fd;\n   55  \tsize_t\t block_size;\n   ..\n   58  };\n   59  \n   60: static int\tfile_close(struct archive *, void *);\n   61: static ssize_t\tfile_read(struct archive *, void *, const void **buff);\n   62: static int64_t\tfile_seek(struct archive *, void *, int64_t request, int);\n   63: static int64_t\tfile_skip(struct archive *, void *, int64_t request);\n   64  \n   65  int\n   66: archive_read_open_fd(struct archive *a, int fd, size_t block_size)\n   67  {\n   68: \tstruct stat st;\n   69: \tstruct read_fd_data *mine;\n   70  \tvoid *b;\n   71  \n   ..\n   76  \t}\n   77  \n   78: \tmine = (struct read_fd_data *)calloc(1, sizeof(*mine));\n   79  \tb = malloc(block_size);\n   80  \tif (mine == NULL || b == NULL) {\n   ..\n  111  \n  112  static ssize_t\n  113: file_read(struct archive *a, void *client_data, const void **buff)\n  114  {\n  115: \tstruct read_fd_data *mine = (struct read_fd_data *)client_data;\n  116  \tssize_t bytes_read;\n  117  \n  ...\n  130  \n  131  static int64_t\n  132: file_skip(struct archive *a, void *client_data, int64_t request)\n  133  {\n  134: \tstruct read_fd_data *mine = (struct read_fd_data *)client_data;\n  135  \tint64_t skip = request;\n  136  \tint64_t old_offset, new_offset;\n  ...\n  177   */\n  178  static int64_t\n  179: file_seek(struct archive *a, void *client_data, int64_t request, int whence)\n  180  {\n  181: \tstruct read_fd_data *mine = (struct read_fd_data *)client_data;\n  182  \tint64_t r;\n  183  \n  ...\n  201  \n  202  static int\n  203: file_close(struct archive *a, void *client_data)\n  204  {\n  205: \tstruct read_fd_data *mine = (struct read_fd_data *)client_data;\n  206  \n  207  \t(void)a; /* UNUSED */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_options_private.h:\n   32  #include \"archive_private.h\"\n   33  \n   34: typedef int (*option_handler)(struct archive *a,\n   35      const char *mod, const char *opt, const char *val);\n   36  \n   37  int\n   38: _archive_set_option(struct archive *a,\n   39      const char *mod, const char *opt, const char *val,\n   40      int magic, const char *fn, option_handler use_option);\n   41  \n   42  int\n   43: _archive_set_options(struct archive *a, const char *options,\n   44      int magic, const char *fn, option_handler use_option);\n   45  \n   46  int\n   47: _archive_set_either_option(struct archive *a,\n   48      const char *m, const char *o, const char *v,\n   49      option_handler use_format_option, option_handler use_filter_option);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_entry_link_resolver.c:\n   68  #define\tlinks_cache_initial_size 1024\n   69  \n   70: struct links_entry {\n   71: \tstruct links_entry\t*next;\n   72: \tstruct links_entry\t*previous;\n   73: \tstruct archive_entry\t*canonical;\n   74: \tstruct archive_entry\t*entry;\n   75  \tsize_t\t\t\t hash;\n   76  \tunsigned int\t\t links; /* # links not yet seen */\n   77  };\n   78  \n   79: struct archive_entry_linkresolver {\n   80: \tstruct links_entry\t**buckets;\n   81: \tstruct links_entry\t *spare;\n   82  \tunsigned long\t\t  number_entries;\n   83  \tsize_t\t\t\t  number_buckets;\n   ..\n   89  #define\tNEXT_ENTRY_ALL\t\t(NEXT_ENTRY_DEFERRED | NEXT_ENTRY_PARTIAL)\n   90  \n   91: static struct links_entry *find_entry(struct archive_entry_linkresolver *,\n   92: \t\t    struct archive_entry *);\n   93: static void grow_hash(struct archive_entry_linkresolver *);\n   94: static struct links_entry *insert_entry(struct archive_entry_linkresolver *,\n   95: \t\t    struct archive_entry *);\n   96: static struct links_entry *next_entry(struct archive_entry_linkresolver *,\n   97      int);\n   98  \n   99: struct archive_entry_linkresolver *\n  100  archive_entry_linkresolver_new(void)\n  101  {\n  102: \tstruct archive_entry_linkresolver *res;\n  103  \n  104  \t/* Check for positive power-of-two */\n  ...\n  107  \t\treturn (NULL);\n  108  \n  109: \tres = calloc(1, sizeof(struct archive_entry_linkresolver));\n  110  \tif (res == NULL)\n  111  \t\treturn (NULL);\n  ...\n  120  \n  121  void\n  122: archive_entry_linkresolver_set_strategy(struct archive_entry_linkresolver *res,\n  123      int fmt)\n  124  {\n  ...\n  158  \n  159  void\n  160: archive_entry_linkresolver_free(struct archive_entry_linkresolver *res)\n  161  {\n  162: \tstruct links_entry *le;\n  163  \n  164  \tif (res == NULL)\n  ...\n  172  \n  173  void\n  174: archive_entry_linkify(struct archive_entry_linkresolver *res,\n  175:     struct archive_entry **e, struct archive_entry **f)\n  176  {\n  177: \tstruct links_entry *le;\n  178: \tstruct archive_entry *t;\n  179  \n  180  \t*f = NULL; /* Default: Don't return a second entry. */\n  ...\n  258  }\n  259  \n  260: static struct links_entry *\n  261: find_entry(struct archive_entry_linkresolver *res,\n  262:     struct archive_entry *entry)\n  263  {\n  264: \tstruct links_entry\t*le;\n  265  \tsize_t\t\t\t hash, bucket;\n  266  \tdev_t\t\t\t dev;\n  ...\n  310  }\n  311  \n  312: static struct links_entry *\n  313: next_entry(struct archive_entry_linkresolver *res, int mode)\n  314  {\n  315: \tstruct links_entry\t*le;\n  316  \tsize_t\t\t\t bucket;\n  317  \n  ...\n  349  }\n  350  \n  351: static struct links_entry *\n  352: insert_entry(struct archive_entry_linkresolver *res,\n  353:     struct archive_entry *entry)\n  354  {\n  355: \tstruct links_entry *le;\n  356  \tsize_t hash, bucket;\n  357  \n  358  \t/* Add this entry to the links cache. */\n  359: \tle = calloc(1, sizeof(struct links_entry));\n  360  \tif (le == NULL)\n  361  \t\treturn (NULL);\n  ...\n  382  \n  383  static void\n  384: grow_hash(struct archive_entry_linkresolver *res)\n  385  {\n  386: \tstruct links_entry *le, **new_buckets;\n  387  \tsize_t new_size;\n  388  \tsize_t i, bucket;\n  ...\n  392  \tif (new_size < res->number_buckets)\n  393  \t\treturn;\n  394: \tnew_buckets = calloc(new_size, sizeof(struct links_entry *));\n  395  \n  396  \tif (new_buckets == NULL)\n  ...\n  418  }\n  419  \n  420: struct archive_entry *\n  421: archive_entry_partial_links(struct archive_entry_linkresolver *res,\n  422      unsigned int *links)\n  423  {\n  424: \tstruct archive_entry\t*e;\n  425: \tstruct links_entry\t*le;\n  426  \n  427  \t/* Free a held entry. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_tar.c:\n   52   * Layout of POSIX 'ustar' tar header.\n   53   */\n   54: struct archive_entry_header_ustar {\n   55  \tchar\tname[100];\n   56  \tchar\tmode[8];\n   ..\n   74   * Structure of GNU tar header\n   75   */\n   76: struct gnu_sparse {\n   77  \tchar\toffset[12];\n   78  \tchar\tnumbytes[12];\n   79  };\n   80  \n   81: struct archive_entry_header_gnutar {\n   82  \tchar\tname[100];\n   83  \tchar\tmode[8];\n   ..\n   99  \tchar\tlongnames[4];\n  100  \tchar\tunused[1];\n  101: \tstruct gnu_sparse sparse[4];\n  102  \tchar\tisextended[1];\n  103  \tchar\trealsize[12];\n  ...\n  111   * Data specific to this format.\n  112   */\n  113: struct sparse_block {\n  114: \tstruct sparse_block\t*next;\n  115  \tint64_t\toffset;\n  116  \tint64_t\tremaining;\n  ...\n  118  };\n  119  \n  120: struct tar {\n  121: \tstruct archive_string\t acl_text;\n  122: \tstruct archive_string\t entry_pathname;\n  123  \t/* For \"GNU.sparse.name\" and other similar path extensions. */\n  124: \tstruct archive_string\t entry_pathname_override;\n  125: \tstruct archive_string\t entry_linkpath;\n  126: \tstruct archive_string\t entry_uname;\n  127: \tstruct archive_string\t entry_gname;\n  128: \tstruct archive_string\t longlink;\n  129: \tstruct archive_string\t longname;\n  130: \tstruct archive_string\t pax_header;\n  131: \tstruct archive_string\t pax_global;\n  132: \tstruct archive_string\t line;\n  133  \tint\t\t\t pax_hdrcharset_binary;\n  134  \tint\t\t\t header_recursion_depth;\n  ...\n  139  \tint64_t\t\t\t realsize;\n  140  \tint\t\t\t sparse_allowed;\n  141: \tstruct sparse_block\t*sparse_list;\n  142: \tstruct sparse_block\t*sparse_last;\n  143  \tint64_t\t\t\t sparse_offset;\n  144  \tint64_t\t\t\t sparse_numbytes;\n  ...\n  147  \tchar\t\t\t sparse_gnu_pending;\n  148  \n  149: \tstruct archive_string\t localname;\n  150: \tstruct archive_string_conv *opt_sconv;\n  151: \tstruct archive_string_conv *sconv;\n  152: \tstruct archive_string_conv *sconv_acl;\n  153: \tstruct archive_string_conv *sconv_default;\n  154  \tint\t\t\t init_default_conversion;\n  155  \tint\t\t\t compat_2x;\n  ...\n  161  static int\tarchive_block_is_null(const char *p);\n  162  static char\t*base64_decode(const char *, size_t, size_t *);\n  163: static int\tgnu_add_sparse_entry(struct archive_read *, struct tar *,\n  164  \t\t    int64_t offset, int64_t remaining);\n  165  \n  166: static void\tgnu_clear_sparse_list(struct tar *);\n  167: static int\tgnu_sparse_old_read(struct archive_read *, struct tar *,\n  168: \t\t    const struct archive_entry_header_gnutar *header, size_t *);\n  169: static int\tgnu_sparse_old_parse(struct archive_read *, struct tar *,\n  170: \t\t    const struct gnu_sparse *sparse, int length);\n  171: static int\tgnu_sparse_01_parse(struct archive_read *, struct tar *,\n  172  \t\t    const char *);\n  173: static ssize_t\tgnu_sparse_10_read(struct archive_read *, struct tar *,\n  174  \t\t\tsize_t *);\n  175: static int\theader_Solaris_ACL(struct archive_read *,  struct tar *,\n  176: \t\t    struct archive_entry *, const void *, size_t *);\n  177: static int\theader_common(struct archive_read *,  struct tar *,\n  178: \t\t    struct archive_entry *, const void *);\n  179: static int\theader_old_tar(struct archive_read *, struct tar *,\n  180: \t\t    struct archive_entry *, const void *);\n  181: static int\theader_pax_extensions(struct archive_read *, struct tar *,\n  182: \t\t    struct archive_entry *, const void *, size_t *);\n  183: static int\theader_pax_global(struct archive_read *, struct tar *,\n  184: \t\t    struct archive_entry *, const void *h, size_t *);\n  185: static int\theader_longlink(struct archive_read *, struct tar *,\n  186: \t\t    struct archive_entry *, const void *h, size_t *);\n  187: static int\theader_longname(struct archive_read *, struct tar *,\n  188: \t\t    struct archive_entry *, const void *h, size_t *);\n  189: static int\tread_mac_metadata_blob(struct archive_read *, struct tar *,\n  190: \t\t    struct archive_entry *, const void *h, size_t *);\n  191: static int\theader_volume(struct archive_read *, struct tar *,\n  192: \t\t    struct archive_entry *, const void *h, size_t *);\n  193: static int\theader_ustar(struct archive_read *, struct tar *,\n  194: \t\t    struct archive_entry *, const void *h);\n  195: static int\theader_gnutar(struct archive_read *, struct tar *,\n  196: \t\t    struct archive_entry *, const void *h, size_t *);\n  197: static int\tarchive_read_format_tar_bid(struct archive_read *, int);\n  198: static int\tarchive_read_format_tar_options(struct archive_read *,\n  199  \t\t    const char *, const char *);\n  200: static int\tarchive_read_format_tar_cleanup(struct archive_read *);\n  201: static int\tarchive_read_format_tar_read_data(struct archive_read *a,\n  202  \t\t    const void **buff, size_t *size, int64_t *offset);\n  203: static int\tarchive_read_format_tar_skip(struct archive_read *a);\n  204: static int\tarchive_read_format_tar_read_header(struct archive_read *,\n  205: \t\t    struct archive_entry *);\n  206: static int\tchecksum(struct archive_read *, const void *);\n  207: static int \tpax_attribute(struct archive_read *, struct tar *,\n  208: \t\t    struct archive_entry *, const char *key, const char *value,\n  209  \t\t    size_t value_length);\n  210: static int\tpax_attribute_acl(struct archive_read *, struct tar *,\n  211: \t\t    struct archive_entry *, const char *, int);\n  212: static int\tpax_attribute_xattr(struct archive_entry *, const char *,\n  213  \t\t    const char *);\n  214: static int \tpax_header(struct archive_read *, struct tar *,\n  215: \t\t    struct archive_entry *, struct archive_string *);\n  216  static void\tpax_time(const char *, int64_t *sec, long *nanos);\n  217: static ssize_t\treadline(struct archive_read *, struct tar *, const char **,\n  218  \t\t    ssize_t limit, size_t *);\n  219: static int\tread_body_to_string(struct archive_read *, struct tar *,\n  220: \t\t    struct archive_string *, const void *h, size_t *);\n  221: static int\tsolaris_sparse_parse(struct archive_read *, struct tar *,\n  222: \t\t    struct archive_entry *, const char *);\n  223  static int64_t\ttar_atol(const char *, size_t);\n  224  static int64_t\ttar_atol10(const char *, size_t);\n  225  static int64_t\ttar_atol256(const char *, size_t);\n  226  static int64_t\ttar_atol8(const char *, size_t);\n  227: static int\ttar_read_header(struct archive_read *, struct tar *,\n  228: \t\t    struct archive_entry *, size_t *);\n  229  static int\ttohex(int c);\n  230  static char\t*url_decode(const char *);\n  231: static void\ttar_flush_unconsumed(struct archive_read *, size_t *);\n  232  \n  233  \n  234  int\n  235: archive_read_support_format_gnutar(struct archive *a)\n  236  {\n  237  \tarchive_check_magic(a, ARCHIVE_READ_MAGIC,\n  ...\n  242  \n  243  int\n  244: archive_read_support_format_tar(struct archive *_a)\n  245  {\n  246: \tstruct archive_read *a = (struct archive_read *)_a;\n  247: \tstruct tar *tar;\n  248  \tint r;\n  249  \n  ...\n  251  \t    ARCHIVE_STATE_NEW, \"archive_read_support_format_tar\");\n  252  \n  253: \ttar = (struct tar *)calloc(1, sizeof(*tar));\n  254  \tif (tar == NULL) {\n  255  \t\tarchive_set_error(&a->archive, ENOMEM,\n  ...\n  279  \n  280  static int\n  281: archive_read_format_tar_cleanup(struct archive_read *a)\n  282  {\n  283: \tstruct tar *tar;\n  284  \n  285: \ttar = (struct tar *)(a->format->data);\n  286  \tgnu_clear_sparse_list(tar);\n  287  \tarchive_string_free(&tar->acl_text);\n  ...\n  355  \n  356  static int\n  357: archive_read_format_tar_bid(struct archive_read *a, int best_bid)\n  358  {\n  359  \tint bid;\n  360  \tconst char *h;\n  361: \tconst struct archive_entry_header_ustar *header;\n  362  \n  363  \t(void)best_bid; /* UNUSED */\n  ...\n  385  \tbid += 48;  /* Checksum is usually 6 octal digits. */\n  386  \n  387: \theader = (const struct archive_entry_header_ustar *)h;\n  388  \n  389  \t/* Recognize POSIX formats. */\n  ...\n  423  \n  424  static int\n  425: archive_read_format_tar_options(struct archive_read *a,\n  426      const char *key, const char *val)\n  427  {\n  428: \tstruct tar *tar;\n  429  \tint ret = ARCHIVE_FAILED;\n  430  \n  431: \ttar = (struct tar *)(a->format->data);\n  432  \tif (strcmp(key, \"compat-2x\")  == 0) {\n  433  \t\t/* Handle UTF-8 filenames as libarchive 2.x */\n  ...\n  468   */\n  469  static void\n  470: tar_flush_unconsumed(struct archive_read *a, size_t *unconsumed)\n  471  {\n  472  \tif (*unconsumed) {\n  ...\n  491   */\n  492  static int\n  493: archive_read_format_tar_read_header(struct archive_read *a,\n  494:     struct archive_entry *entry)\n  495  {\n  496  \t/*\n  ...\n  510  \tstatic int default_inode;\n  511  \tstatic int default_dev;\n  512: \tstruct tar *tar;\n  513  \tconst char *p;\n  514  \tconst wchar_t *wp;\n  ...\n  525  \t}\n  526  \n  527: \ttar = (struct tar *)(a->format->data);\n  528  \ttar->entry_offset = 0;\n  529  \tgnu_clear_sparse_list(tar);\n  ...\n  555  \t\t\treturn (ARCHIVE_FATAL);\n  556  \t} else {\n  557: \t\tstruct sparse_block *sb;\n  558  \n  559  \t\tfor (sb = tar->sparse_list; sb != NULL; sb = sb->next) {\n  ...\n  586  \n  587  static int\n  588: archive_read_format_tar_read_data(struct archive_read *a,\n  589      const void **buff, size_t *size, int64_t *offset)\n  590  {\n  591  \tssize_t bytes_read;\n  592: \tstruct tar *tar;\n  593: \tstruct sparse_block *p;\n  594  \n  595: \ttar = (struct tar *)(a->format->data);\n  596  \n  597  \tfor (;;) {\n  ...\n  649  \n  650  static int\n  651: archive_read_format_tar_skip(struct archive_read *a)\n  652  {\n  653  \tint64_t bytes_skipped;\n  654  \tint64_t request;\n  655: \tstruct sparse_block *p;\n  656: \tstruct tar* tar;\n  657  \n  658: \ttar = (struct tar *)(a->format->data);\n  659  \n  660  \t/* Do not consume the hole of a sparse file. */\n  ...\n  691   */\n  692  static int\n  693: tar_read_header(struct archive_read *a, struct tar *tar,\n  694:     struct archive_entry *entry, size_t *unconsumed)\n  695  {\n  696  \tssize_t bytes;\n  697  \tint err, eof_vol_header;\n  698  \tconst char *h;\n  699: \tconst struct archive_entry_header_ustar *header;\n  700: \tconst struct archive_entry_header_gnutar *gnuheader;\n  701  \n  702  \teof_vol_header = 0;\n  ...\n  768  \n  769  \t/* Determine the format variant. */\n  770: \theader = (const struct archive_entry_header_ustar *)h;\n  771  \n  772  \tswitch(header->typeflag[0]) {\n  ...\n  806  \t\tbreak;\n  807  \tdefault:\n  808: \t\tgnuheader = (const struct archive_entry_header_gnutar *)h;\n  809  \t\tif (memcmp(gnuheader->magic, \"ustar  \\0\", 8) == 0) {\n  810  \t\t\ta->archive.archive_format = ARCHIVE_FORMAT_TAR_GNUTAR;\n  ...\n  885   */\n  886  static int\n  887: checksum(struct archive_read *a, const void *h)\n  888  {\n  889  \tconst unsigned char *bytes;\n  890: \tconst struct archive_entry_header_ustar\t*header;\n  891  \tint check, sum;\n  892  \tsize_t i;\n  ...\n  894  \t(void)a; /* UNUSED */\n  895  \tbytes = (const unsigned char *)h;\n  896: \theader = (const struct archive_entry_header_ustar *)h;\n  897  \n  898  \t/* Checksum field must hold an octal number */\n  ...\n  954   */\n  955  static int\n  956: header_Solaris_ACL(struct archive_read *a, struct tar *tar,\n  957:     struct archive_entry *entry, const void *h, size_t *unconsumed)\n  958  {\n  959: \tconst struct archive_entry_header_ustar *header;\n  960  \tsize_t size;\n  961  \tint err, acl_type;\n  ...\n  967  \t * more to make sure that we don't overrun acl_text later.\n  968  \t */\n  969: \theader = (const struct archive_entry_header_ustar *)h;\n  970  \tsize = (size_t)tar_atol(header->size, sizeof(header->size));\n  971  \terr = read_body_to_string(a, tar, &(tar->acl_text), h, unconsumed);\n  ...\n 1055   */\n 1056  static int\n 1057: header_longlink(struct archive_read *a, struct tar *tar,\n 1058:     struct archive_entry *entry, const void *h, size_t *unconsumed)\n 1059  {\n 1060  \tint err;\n ....\n 1072  \n 1073  static int\n 1074: set_conversion_failed_error(struct archive_read *a,\n 1075:     struct archive_string_conv *sconv, const char *name)\n 1076  {\n 1077  \tif (errno == ENOMEM) {\n ....\n 1090   */\n 1091  static int\n 1092: header_longname(struct archive_read *a, struct tar *tar,\n 1093:     struct archive_entry *entry, const void *h, size_t *unconsumed)\n 1094  {\n 1095  \tint err;\n ....\n 1113   */\n 1114  static int\n 1115: header_volume(struct archive_read *a, struct tar *tar,\n 1116:     struct archive_entry *entry, const void *h, size_t *unconsumed)\n 1117  {\n 1118  \t(void)h;\n ....\n 1126   */\n 1127  static int\n 1128: read_body_to_string(struct archive_read *a, struct tar *tar,\n 1129:     struct archive_string *as, const void *h, size_t *unconsumed)\n 1130  {\n 1131  \tint64_t size;\n 1132: \tconst struct archive_entry_header_ustar *header;\n 1133  \tconst void *src;\n 1134  \n 1135  \t(void)tar; /* UNUSED */\n 1136: \theader = (const struct archive_entry_header_ustar *)h;\n 1137  \tsize  = tar_atol(header->size, sizeof(header->size));\n 1138  \tif ((size > 1048576) || (size < 0)) {\n ....\n 1175   */\n 1176  static int\n 1177: header_common(struct archive_read *a, struct tar *tar,\n 1178:     struct archive_entry *entry, const void *h)\n 1179  {\n 1180: \tconst struct archive_entry_header_ustar\t*header;\n 1181  \tchar\ttartype;\n 1182  \tint     err = ARCHIVE_OK;\n 1183  \n 1184: \theader = (const struct archive_entry_header_ustar *)h;\n 1185  \tif (header->linkname[0])\n 1186  \t\tarchive_strncpy(&(tar->entry_linkpath),\n ....\n 1364   */\n 1365  static int\n 1366: header_old_tar(struct archive_read *a, struct tar *tar,\n 1367:     struct archive_entry *entry, const void *h)\n 1368  {\n 1369: \tconst struct archive_entry_header_ustar\t*header;\n 1370  \tint err = ARCHIVE_OK, err2;\n 1371  \n 1372  \t/* Copy filename over (to ensure null termination). */\n 1373: \theader = (const struct archive_entry_header_ustar *)h;\n 1374  \tif (archive_entry_copy_pathname_l(entry,\n 1375  \t    header->name, sizeof(header->name), tar->sconv) != 0) {\n ....\n 1393   */\n 1394  static int\n 1395: read_mac_metadata_blob(struct archive_read *a, struct tar *tar,\n 1396:     struct archive_entry *entry, const void *h, size_t *unconsumed)\n 1397  {\n 1398  \tint64_t size;\n ....\n 1469   */\n 1470  static int\n 1471: header_pax_global(struct archive_read *a, struct tar *tar,\n 1472:     struct archive_entry *entry, const void *h, size_t *unconsumed)\n 1473  {\n 1474  \tint err;\n ....\n 1482  \n 1483  static int\n 1484: header_pax_extensions(struct archive_read *a, struct tar *tar,\n 1485:     struct archive_entry *entry, const void *h, size_t *unconsumed)\n 1486  {\n 1487  \tint err, err2;\n ....\n 1497  \n 1498  \t/*\n 1499: \t * TODO: Parse global/default options into 'entry' struct here\n 1500  \t * before handling file-specific options.\n 1501  \t *\n ....\n 1518   */\n 1519  static int\n 1520: header_ustar(struct archive_read *a, struct tar *tar,\n 1521:     struct archive_entry *entry, const void *h)\n 1522  {\n 1523: \tconst struct archive_entry_header_ustar\t*header;\n 1524: \tstruct archive_string *as;\n 1525  \tint err = ARCHIVE_OK, r;\n 1526  \n 1527: \theader = (const struct archive_entry_header_ustar *)h;\n 1528  \n 1529  \t/* Copy name into an internal buffer to ensure null-termination. */\n ....\n 1586   */\n 1587  static int\n 1588: pax_header(struct archive_read *a, struct tar *tar,\n 1589:     struct archive_entry *entry, struct archive_string *in_as)\n 1590  {\n 1591  \tsize_t attr_length, l, line_length, value_length;\n 1592  \tchar *p;\n 1593  \tchar *key, *value;\n 1594: \tstruct archive_string *as;\n 1595: \tstruct archive_string_conv *sconv;\n 1596  \tint err, err2;\n 1597  \tchar *attr = in_as->s;\n ....\n 1757  \n 1758  static int\n 1759: pax_attribute_xattr(struct archive_entry *entry,\n 1760  \tconst char *name, const char *value)\n 1761  {\n ....\n 1790  \n 1791  static int\n 1792: pax_attribute_schily_xattr(struct archive_entry *entry,\n 1793  \tconst char *name, const char *value, size_t value_length)\n 1794  {\n ....\n 1804  \n 1805  static int\n 1806: pax_attribute_rht_security_selinux(struct archive_entry *entry,\n 1807  \tconst char *value, size_t value_length)\n 1808  {\n ....\n 1814  \n 1815  static int\n 1816: pax_attribute_acl(struct archive_read *a, struct tar *tar,\n 1817:     struct archive_entry *entry, const char *value, int type)\n 1818  {\n 1819  \tint r;\n ....\n 1873   */\n 1874  static int\n 1875: pax_attribute(struct archive_read *a, struct tar *tar,\n 1876:     struct archive_entry *entry, const char *key, const char *value, size_t value_length)\n 1877  {\n 1878  \tint64_t s;\n ....\n 2187   */\n 2188  static int\n 2189: header_gnutar(struct archive_read *a, struct tar *tar,\n 2190:     struct archive_entry *entry, const void *h, size_t *unconsumed)\n 2191  {\n 2192: \tconst struct archive_entry_header_gnutar *header;\n 2193  \tint64_t t;\n 2194  \tint err = ARCHIVE_OK;\n ....\n 2206  \n 2207  \t/* Copy filename over (to ensure null termination). */\n 2208: \theader = (const struct archive_entry_header_gnutar *)h;\n 2209  \tif (archive_entry_copy_pathname_l(entry,\n 2210  \t    header->name, sizeof(header->name), tar->sconv) != 0) {\n ....\n 2272  \n 2273  static int\n 2274: gnu_add_sparse_entry(struct archive_read *a, struct tar *tar,\n 2275      int64_t offset, int64_t remaining)\n 2276  {\n 2277: \tstruct sparse_block *p;\n 2278  \n 2279: \tp = (struct sparse_block *)calloc(1, sizeof(*p));\n 2280  \tif (p == NULL) {\n 2281  \t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n ....\n 2297  \n 2298  static void\n 2299: gnu_clear_sparse_list(struct tar *tar)\n 2300  {\n 2301: \tstruct sparse_block *p;\n 2302  \n 2303  \twhile (tar->sparse_list != NULL) {\n ....\n 2322  \n 2323  static int\n 2324: gnu_sparse_old_read(struct archive_read *a, struct tar *tar,\n 2325:     const struct archive_entry_header_gnutar *header, size_t *unconsumed)\n 2326  {\n 2327  \tssize_t bytes_read;\n 2328  \tconst void *data;\n 2329: \tstruct extended {\n 2330: \t\tstruct gnu_sparse sparse[21];\n 2331  \t\tchar\tisextended[1];\n 2332  \t\tchar\tpadding[7];\n 2333  \t};\n 2334: \tconst struct extended *ext;\n 2335  \n 2336  \tif (gnu_sparse_old_parse(a, tar, header->sparse, 4) != ARCHIVE_OK)\n ....\n 2351  \t\t}\n 2352  \t\t*unconsumed = 512;\n 2353: \t\text = (const struct extended *)data;\n 2354  \t\tif (gnu_sparse_old_parse(a, tar, ext->sparse, 21) != ARCHIVE_OK)\n 2355  \t\t\treturn (ARCHIVE_FATAL);\n ....\n 2361  \n 2362  static int\n 2363: gnu_sparse_old_parse(struct archive_read *a, struct tar *tar,\n 2364:     const struct gnu_sparse *sparse, int length)\n 2365  {\n 2366  \twhile (length > 0 && sparse->offset[0] != 0) {\n ....\n 2403  \n 2404  static int\n 2405: gnu_sparse_01_parse(struct archive_read *a, struct tar *tar, const char *p)\n 2406  {\n 2407  \tconst char *e;\n ....\n 2458   */\n 2459  static int64_t\n 2460: gnu_sparse_10_atol(struct archive_read *a, struct tar *tar,\n 2461      int64_t *remaining, size_t *unconsumed)\n 2462  {\n ....\n 2505   */\n 2506  static ssize_t\n 2507: gnu_sparse_10_read(struct archive_read *a, struct tar *tar, size_t *unconsumed)\n 2508  {\n 2509  \tssize_t bytes_read;\n ....\n 2552   */\n 2553  static int\n 2554: solaris_sparse_parse(struct archive_read *a, struct tar *tar,\n 2555:     struct archive_entry *entry, const char *p)\n 2556  {\n 2557  \tconst char *e;\n ....\n 2740   */\n 2741  static ssize_t\n 2742: readline(struct archive_read *a, struct tar *tar, const char **start,\n 2743      ssize_t limit, size_t *unconsumed)\n 2744  {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_lrzip.c:\n   49  #define LRZIP_HEADER_MAGIC_LEN 4\n   50  \n   51: static int\tlrzip_bidder_bid(struct archive_read_filter_bidder *,\n   52: \t\t    struct archive_read_filter *);\n   53: static int\tlrzip_bidder_init(struct archive_read_filter *);\n   54  \n   55  \n   56  static int\n   57: lrzip_reader_free(struct archive_read_filter_bidder *self)\n   58  {\n   59  \t(void)self; /* UNUSED */\n   ..\n   62  \n   63  int\n   64: archive_read_support_filter_lrzip(struct archive *_a)\n   65  {\n   66: \tstruct archive_read *a = (struct archive_read *)_a;\n   67: \tstruct archive_read_filter_bidder *reader;\n   68  \n   69  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n   ..\n   89   */\n   90  static int\n   91: lrzip_bidder_bid(struct archive_read_filter_bidder *self,\n   92:     struct archive_read_filter *filter)\n   93  {\n   94  \tconst unsigned char *p;\n   ..\n  119  \n  120  static int\n  121: lrzip_bidder_init(struct archive_read_filter *self)\n  122  {\n  123  \tint r;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter_xz.c:\n   50  #if ARCHIVE_VERSION_NUMBER < 4000000\n   51  int\n   52: archive_write_set_compression_lzip(struct archive *a)\n   53  {\n   54  \t__archive_write_filters_free(a);\n   ..\n   57  \n   58  int\n   59: archive_write_set_compression_lzma(struct archive *a)\n   60  {\n   61  \t__archive_write_filters_free(a);\n   ..\n   64  \n   65  int\n   66: archive_write_set_compression_xz(struct archive *a)\n   67  {\n   68  \t__archive_write_filters_free(a);\n   ..\n   74  #ifndef HAVE_LZMA_H\n   75  int\n   76: archive_write_add_filter_xz(struct archive *a)\n   77  {\n   78  \tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n   ..\n   82  \n   83  int\n   84: archive_write_add_filter_lzma(struct archive *a)\n   85  {\n   86  \tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n   ..\n   90  \n   91  int\n   92: archive_write_add_filter_lzip(struct archive *a)\n   93  {\n   94  \tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n   ..\n   99  /* Don't compile this if we don't have liblzma. */\n  100  \n  101: struct private_data {\n  102  \tint\t\t compression_level;\n  103  \tuint32_t\t threads;\n  ...\n  113  };\n  114  \n  115: static int\tarchive_compressor_xz_options(struct archive_write_filter *,\n  116  \t\t    const char *, const char *);\n  117: static int\tarchive_compressor_xz_open(struct archive_write_filter *);\n  118: static int\tarchive_compressor_xz_write(struct archive_write_filter *,\n  119  \t\t    const void *, size_t);\n  120: static int\tarchive_compressor_xz_close(struct archive_write_filter *);\n  121: static int\tarchive_compressor_xz_free(struct archive_write_filter *);\n  122: static int\tdrive_compressor(struct archive_write_filter *,\n  123: \t\t    struct private_data *, int finishing);\n  124  \n  125: struct option_value {\n  126  \tuint32_t dict_size;\n  127  \tuint32_t nice_len;\n  128  \tlzma_match_finder mf;\n  129  };\n  130: static const struct option_value option_values[] = {\n  131  \t{ 1 << 16, 32, LZMA_MF_HC3},\n  132  \t{ 1 << 20, 32, LZMA_MF_HC3},\n  ...\n  142  \n  143  static int\n  144: common_setup(struct archive_write_filter *f)\n  145  {\n  146: \tstruct private_data *data;\n  147: \tstruct archive_write *a = (struct archive_write *)f->archive;\n  148  \tdata = calloc(1, sizeof(*data));\n  149  \tif (data == NULL) {\n  ...\n  165   */\n  166  int\n  167: archive_write_add_filter_xz(struct archive *_a)\n  168  {\n  169: \tstruct archive_write_filter *f;\n  170  \tint r;\n  171  \n  ...\n  185   * the one place that XZ and LZMA require different handling.) */\n  186  int\n  187: archive_write_add_filter_lzma(struct archive *_a)\n  188  {\n  189: \tstruct archive_write_filter *f;\n  190  \tint r;\n  191  \n  ...\n  202  \n  203  int\n  204: archive_write_add_filter_lzip(struct archive *_a)\n  205  {\n  206: \tstruct archive_write_filter *f;\n  207  \tint r;\n  208  \n  ...\n  219  \n  220  static int\n  221: archive_compressor_xz_init_stream(struct archive_write_filter *f,\n  222:     struct private_data *data)\n  223  {\n  224  \tstatic const lzma_stream lzma_stream_init_data = LZMA_STREAM_INIT;\n  ...\n  305   */\n  306  static int\n  307: archive_compressor_xz_open(struct archive_write_filter *f)\n  308  {\n  309: \tstruct private_data *data = f->data;\n  310  \tint ret;\n  311  \n  ...\n  335  \t/* Initialize compression library. */\n  336  \tif (f->code == ARCHIVE_FILTER_LZIP) {\n  337: \t\tconst struct option_value *val =\n  338  \t\t    &option_values[data->compression_level];\n  339  \n  ...\n  373   */\n  374  static int\n  375: archive_compressor_xz_options(struct archive_write_filter *f,\n  376      const char *key, const char *value)\n  377  {\n  378: \tstruct private_data *data = (struct private_data *)f->data;\n  379  \n  380  \tif (strcmp(key, \"compression-level\") == 0) {\n  ...\n  417   */\n  418  static int\n  419: archive_compressor_xz_write(struct archive_write_filter *f,\n  420      const void *buff, size_t length)\n  421  {\n  422: \tstruct private_data *data = (struct private_data *)f->data;\n  423  \tint ret;\n  424  \n  ...\n  442   */\n  443  static int\n  444: archive_compressor_xz_close(struct archive_write_filter *f)\n  445  {\n  446: \tstruct private_data *data = (struct private_data *)f->data;\n  447  \tint ret;\n  448  \n  ...\n  467  \n  468  static int\n  469: archive_compressor_xz_free(struct archive_write_filter *f)\n  470  {\n  471: \tstruct private_data *data = (struct private_data *)f->data;\n  472  \tfree(data->compressed);\n  473  \tfree(data);\n  ...\n  484   */\n  485  static int\n  486: drive_compressor(struct archive_write_filter *f,\n  487:     struct private_data *data, int finishing)\n  488  {\n  489  \tint ret;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_cmdline_private.h:\n   35  #endif\n   36  \n   37: struct archive_cmdline {\n   38          char            *path;\n   39          char            **argv;\n   ..\n   41  };\n   42  \n   43: struct archive_cmdline *__archive_cmdline_allocate(void);\n   44: int __archive_cmdline_parse(struct archive_cmdline *, const char *);\n   45: int __archive_cmdline_free(struct archive_cmdline *);\n   46  \n   47  #endif\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_ppmd_private.h:\n   56  #define False 0\n   57  \n   58: /* The following interfaces use first parameter as pointer to structure */\n   59  \n   60: typedef struct\n   61  {\n   62:   struct archive_read *a;\n   63    Byte (*Read)(void *p); /* reads one byte, returns 0 in case of EOF or error */\n   64  } IByteIn;\n   65  \n   66: typedef struct\n   67  {\n   68:   struct archive_write *a;\n   69    void (*Write)(void *p, Byte b);\n   70  } IByteOut;\n   ..\n  103  \n  104  /* SEE-contexts for PPM-contexts with masked symbols */\n  105: typedef struct\n  106  {\n  107    UInt16 Summ; /* Freq */\n  ...\n  113      { (p)->Summ <<= 1; (p)->Count = (Byte)(3 << (p)->Shift++); }\n  114  \n  115: typedef struct\n  116  {\n  117    Byte Symbol;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_extract2.c:\n   42  #include \"archive_read_private.h\"\n   43  \n   44: static int\tcopy_data(struct archive *ar, struct archive *aw);\n   45: static int\tarchive_read_extract_cleanup(struct archive_read *);\n   46  \n   47  \n   ..\n   49   * archive_write_disk object.\n   50   */\n   51: struct archive_read_extract *\n   52: __archive_read_get_extract(struct archive_read *a)\n   53  {\n   54  \tif (a->extract == NULL) {\n   55: \t\ta->extract = (struct archive_read_extract *)calloc(1, sizeof(*a->extract));\n   56  \t\tif (a->extract == NULL) {\n   57  \t\t\tarchive_set_error(&a->archive, ENOMEM, \"Can't extract\");\n   ..\n   67   */\n   68  static int\n   69: archive_read_extract_cleanup(struct archive_read *a)\n   70  {\n   71  \tint ret = ARCHIVE_OK;\n   ..\n   80  \n   81  int\n   82: archive_read_extract2(struct archive *_a, struct archive_entry *entry,\n   83:     struct archive *ad)\n   84  {\n   85: \tstruct archive_read *a = (struct archive_read *)_a;\n   86  \tint r, r2;\n   87  \n   ..\n  112  \n  113  void\n  114: archive_read_extract_set_progress_callback(struct archive *_a,\n  115      void (*progress_func)(void *), void *user_data)\n  116  {\n  117: \tstruct archive_read *a = (struct archive_read *)_a;\n  118: \tstruct archive_read_extract *extract = __archive_read_get_extract(a);\n  119  \tif (extract != NULL) {\n  120  \t\textract->extract_progress = progress_func;\n  ...\n  124  \n  125  static int\n  126: copy_data(struct archive *ar, struct archive *aw)\n  127  {\n  128  \tint64_t offset;\n  129  \tconst void *buff;\n  130: \tstruct archive_read_extract *extract;\n  131  \tsize_t size;\n  132  \tint r;\n  133  \n  134: \textract = __archive_read_get_extract((struct archive_read *)ar);\n  135  \tif (extract == NULL)\n  136  \t\treturn (ARCHIVE_FATAL);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_cpio.c:\n    5   */\n    6  int\n    7: archive_write_set_format_cpio(struct archive *_a)\n    8  {\n    9  \treturn archive_write_set_format_cpio_odc(_a);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_extract.c:\n   37  \n   38  int\n   39: archive_read_extract(struct archive *_a, struct archive_entry *entry, int flags)\n   40  {\n   41: \tstruct archive_read_extract *extract;\n   42: \tstruct archive_read * a = (struct archive_read *)_a;\n   43  \n   44  \textract = __archive_read_get_extract(a);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_by_name.c:\n   43  /* A table that maps names to functions. */\n   44  static const\n   45: struct { const char *name; int (*setter)(struct archive *); } names[] =\n   46  {\n   47  \t{ \"7zip\",\tarchive_write_set_format_7zip },\n   ..\n   80  \n   81  int\n   82: archive_write_set_format_by_name(struct archive *a, const char *name)\n   83  {\n   84  \tint i;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_grzip.c:\n   50  \t0x02, 0x04, 0x3a, 0x29 };\n   51  \n   52: static int\tgrzip_bidder_bid(struct archive_read_filter_bidder *,\n   53: \t\t    struct archive_read_filter *);\n   54: static int\tgrzip_bidder_init(struct archive_read_filter *);\n   55  \n   56  \n   57  static int\n   58: grzip_reader_free(struct archive_read_filter_bidder *self)\n   59  {\n   60  \t(void)self; /* UNUSED */\n   ..\n   63  \n   64  int\n   65: archive_read_support_filter_grzip(struct archive *_a)\n   66  {\n   67: \tstruct archive_read *a = (struct archive_read *)_a;\n   68: \tstruct archive_read_filter_bidder *reader;\n   69  \n   70  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n   ..\n   89   */\n   90  static int\n   91: grzip_bidder_bid(struct archive_read_filter_bidder *self,\n   92:     struct archive_read_filter *filter)\n   93  {\n   94  \tconst unsigned char *p;\n   ..\n  108  \n  109  static int\n  110: grzip_bidder_init(struct archive_read_filter *self)\n  111  {\n  112  \tint r;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter_gzip.c:\n   49  #if ARCHIVE_VERSION_NUMBER < 4000000\n   50  int\n   51: archive_write_set_compression_gzip(struct archive *a)\n   52  {\n   53  \t__archive_write_filters_free(a);\n   ..\n   58  /* Don't compile this if we don't have zlib. */\n   59  \n   60: struct private_data {\n   61  \tint\t\t compression_level;\n   62  \tint\t\t timestamp;\n   ..\n   68  \tunsigned long\t crc;\n   69  #else\n   70: \tstruct archive_write_program_data *pdata;\n   71  #endif\n   72  };\n   ..\n   79  \t(st)->stream.next_in = (Bytef *)(uintptr_t)(const void *)(src)\n   80  \n   81: static int archive_compressor_gzip_options(struct archive_write_filter *,\n   82  \t\t    const char *, const char *);\n   83: static int archive_compressor_gzip_open(struct archive_write_filter *);\n   84: static int archive_compressor_gzip_write(struct archive_write_filter *,\n   85  \t\t    const void *, size_t);\n   86: static int archive_compressor_gzip_close(struct archive_write_filter *);\n   87: static int archive_compressor_gzip_free(struct archive_write_filter *);\n   88  #ifdef HAVE_ZLIB_H\n   89: static int drive_compressor(struct archive_write_filter *,\n   90: \t\t    struct private_data *, int finishing);\n   91  #endif\n   92  \n   ..\n   96   */\n   97  int\n   98: archive_write_add_filter_gzip(struct archive *_a)\n   99  {\n  100: \tstruct archive_write *a = (struct archive_write *)_a;\n  101: \tstruct archive_write_filter *f = __archive_write_allocate_filter(_a);\n  102: \tstruct private_data *data;\n  103  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n  104  \t    ARCHIVE_STATE_NEW, \"archive_write_add_filter_gzip\");\n  ...\n  134  \n  135  static int\n  136: archive_compressor_gzip_free(struct archive_write_filter *f)\n  137  {\n  138: \tstruct private_data *data = (struct private_data *)f->data;\n  139  \n  140  #ifdef HAVE_ZLIB_H\n  ...\n  152   */\n  153  static int\n  154: archive_compressor_gzip_options(struct archive_write_filter *f, const char *key,\n  155      const char *value)\n  156  {\n  157: \tstruct private_data *data = (struct private_data *)f->data;\n  158  \n  159  \tif (strcmp(key, \"compression-level\") == 0) {\n  ...\n  180   */\n  181  static int\n  182: archive_compressor_gzip_open(struct archive_write_filter *f)\n  183  {\n  184: \tstruct private_data *data = (struct private_data *)f->data;\n  185  \tint ret;\n  186  \n  ...\n  277   */\n  278  static int\n  279: archive_compressor_gzip_write(struct archive_write_filter *f, const void *buff,\n  280      size_t length)\n  281  {\n  282: \tstruct private_data *data = (struct private_data *)f->data;\n  283  \tint ret;\n  284  \n  ...\n  300   */\n  301  static int\n  302: archive_compressor_gzip_close(struct archive_write_filter *f)\n  303  {\n  304  \tunsigned char trailer[8];\n  305: \tstruct private_data *data = (struct private_data *)f->data;\n  306  \tint ret;\n  307  \n  ...\n  346   */\n  347  static int\n  348: drive_compressor(struct archive_write_filter *f,\n  349:     struct private_data *data, int finishing)\n  350  {\n  351  \tint ret;\n  ...\n  396  \n  397  static int\n  398: archive_compressor_gzip_open(struct archive_write_filter *f)\n  399  {\n  400: \tstruct private_data *data = (struct private_data *)f->data;\n  401: \tstruct archive_string as;\n  402  \tint r;\n  403  \n  ...\n  424  \n  425  static int\n  426: archive_compressor_gzip_write(struct archive_write_filter *f, const void *buff,\n  427      size_t length)\n  428  {\n  429: \tstruct private_data *data = (struct private_data *)f->data;\n  430  \n  431  \treturn __archive_write_program_write(f, data->pdata, buff, length);\n  ...\n  433  \n  434  static int\n  435: archive_compressor_gzip_close(struct archive_write_filter *f)\n  436  {\n  437: \tstruct private_data *data = (struct private_data *)f->data;\n  438  \n  439  \treturn __archive_write_program_close(f, data->pdata);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_open_filename.c:\n   71  #endif\n   72  \n   73: struct read_file_data {\n   74  \tint\t fd;\n   75  \tsize_t\t block_size;\n   ..\n   84  };\n   85  \n   86: static int\tfile_open(struct archive *, void *);\n   87: static int\tfile_close(struct archive *, void *);\n   88: static int file_close2(struct archive *, void *);\n   89: static int file_switch(struct archive *, void *, void *);\n   90: static ssize_t\tfile_read(struct archive *, void *, const void **buff);\n   91: static int64_t\tfile_seek(struct archive *, void *, int64_t request, int);\n   92: static int64_t\tfile_skip(struct archive *, void *, int64_t request);\n   93: static int64_t\tfile_skip_lseek(struct archive *, void *, int64_t request);\n   94  \n   95  int\n   96: archive_read_open_file(struct archive *a, const char *filename,\n   97      size_t block_size)\n   98  {\n   ..\n  101  \n  102  int\n  103: archive_read_open_filename(struct archive *a, const char *filename,\n  104      size_t block_size)\n  105  {\n  ...\n  111  \n  112  int\n  113: archive_read_open_filenames(struct archive *a, const char **filenames,\n  114      size_t block_size)\n  115  {\n  116: \tstruct read_file_data *mine;\n  117  \tconst char *filename = NULL;\n  118  \tif (filenames)\n  ...\n  124  \t\tif (filename == NULL)\n  125  \t\t\tfilename = \"\";\n  126: \t\tmine = (struct read_file_data *)calloc(1,\n  127  \t\t\tsizeof(*mine) + strlen(filename));\n  128  \t\tif (mine == NULL)\n  ...\n  157  \n  158  int\n  159: archive_read_open_filename_w(struct archive *a, const wchar_t *wfilename,\n  160      size_t block_size)\n  161  {\n  162: \tstruct read_file_data *mine = (struct read_file_data *)calloc(1,\n  163  \t\tsizeof(*mine) + wcslen(wfilename) * sizeof(wchar_t));\n  164  \tif (!mine)\n  ...\n  182  \t\t * filename to multi-byte one and use it.\n  183  \t\t */\n  184: \t\tstruct archive_string fn;\n  185  \n  186  \t\tarchive_string_init(&fn);\n  ...\n  216  \n  217  static int\n  218: file_open(struct archive *a, void *client_data)\n  219  {\n  220: \tstruct stat st;\n  221: \tstruct read_file_data *mine = (struct read_file_data *)client_data;\n  222  \tvoid *buffer;\n  223  \tconst char *filename = NULL;\n  ...\n  230  \toff_t mediasize = 0; /* FreeBSD-specific, so off_t okay here. */\n  231  #elif defined(__NetBSD__) || defined(__OpenBSD__)\n  232: \tstruct disklabel dl;\n  233  #elif defined(__DragonFly__)\n  234: \tstruct partinfo pi;\n  235  #endif\n  236  \n  ...\n  386  \n  387  static ssize_t\n  388: file_read(struct archive *a, void *client_data, const void **buff)\n  389  {\n  390: \tstruct read_file_data *mine = (struct read_file_data *)client_data;\n  391  \tssize_t bytes_read;\n  392  \n  ...\n  445   */\n  446  static int64_t\n  447: file_skip_lseek(struct archive *a, void *client_data, int64_t request)\n  448  {\n  449: \tstruct read_file_data *mine = (struct read_file_data *)client_data;\n  450  #if defined(_WIN32) && !defined(__CYGWIN__)\n  451  \t/* We use _lseeki64() on Windows. */\n  ...\n  492  \n  493  static int64_t\n  494: file_skip(struct archive *a, void *client_data, int64_t request)\n  495  {\n  496: \tstruct read_file_data *mine = (struct read_file_data *)client_data;\n  497  \n  498  \t/* Delegate skip requests. */\n  ...\n  508   */\n  509  static int64_t\n  510: file_seek(struct archive *a, void *client_data, int64_t request, int whence)\n  511  {\n  512: \tstruct read_file_data *mine = (struct read_file_data *)client_data;\n  513  \tint64_t r;\n  514  \n  ...\n  532  \n  533  static int\n  534: file_close2(struct archive *a, void *client_data)\n  535  {\n  536: \tstruct read_file_data *mine = (struct read_file_data *)client_data;\n  537  \n  538  \t(void)a; /* UNUSED */\n  ...\n  571  \n  572  static int\n  573: file_close(struct archive *a, void *client_data)\n  574  {\n  575: \tstruct read_file_data *mine = (struct read_file_data *)client_data;\n  576  \tfile_close2(a, client_data);\n  577  \tfree(mine);\n  ...\n  580  \n  581  static int\n  582: file_switch(struct archive *a, void *client_data1, void *client_data2)\n  583  {\n  584  \tfile_close2(a, client_data1);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_7zip.c:\n  111  #define kDummy\t\t\t0x19\n  112  \n  113: struct _7z_digests {\n  114  \tunsigned char\t*defineds;\n  115  \tuint32_t\t*digests;\n  ...\n  117  \n  118  \n  119: struct _7z_folder {\n  120  \tuint64_t\t\t numCoders;\n  121: \tstruct _7z_coder {\n  122  \t\tunsigned long\t codec;\n  123  \t\tuint64_t\t numInStreams;\n  ...\n  127  \t} *coders;\n  128  \tuint64_t\t\t numBindPairs;\n  129: \tstruct {\n  130  \t\tuint64_t\t inIndex;\n  131  \t\tuint64_t\t outIndex;\n  ...\n  144  };\n  145  \n  146: struct _7z_coders_info {\n  147  \tuint64_t\t\t numFolders;\n  148: \tstruct _7z_folder\t*folders;\n  149  \tuint64_t\t\t dataStreamIndex;\n  150  };\n  151  \n  152: struct _7z_pack_info {\n  153  \tuint64_t\t\t pos;\n  154  \tuint64_t\t\t numPackStreams;\n  155  \tuint64_t\t\t*sizes;\n  156: \tstruct _7z_digests\t digest;\n  157  \t/* Calculated from pos and numPackStreams. */\n  158  \tuint64_t\t\t*positions;\n  159  };\n  160  \n  161: struct _7z_substream_info {\n  162  \tsize_t\t\t\t unpack_streams;\n  163  \tuint64_t\t\t*unpackSizes;\n  ...\n  166  };\n  167  \n  168: struct _7z_stream_info {\n  169: \tstruct _7z_pack_info\t pi;\n  170: \tstruct _7z_coders_info\t ci;\n  171: \tstruct _7z_substream_info ss;\n  172  };\n  173  \n  174: struct _7z_header_info {\n  175  \tuint64_t\t\t dataIndex;\n  176  \n  ...\n  181  };\n  182  \n  183: struct _7zip_entry {\n  184  \tsize_t\t\t\t name_len;\n  185  \tunsigned char\t\t*utf16name;\n  ...\n  206  };\n  207  \n  208: struct _7zip {\n  209  \t/* Structural information about the archive. */\n  210: \tstruct _7z_stream_info\t si;\n  211  \n  212  \tint\t\t\t header_is_being_read;\n  ...\n  223  \tsize_t\t\t\t entries_remaining;\n  224  \tuint64_t\t\t numFiles;\n  225: \tstruct _7zip_entry\t*entries;\n  226: \tstruct _7zip_entry\t*entry;\n  227  \tunsigned char\t\t*entry_names;\n  228  \n  ...\n  284  \tCPpmd7z_RangeDec\t range_dec;\n  285  \tIByteIn\t\t\t bytein;\n  286: \tstruct {\n  287  \t\tconst unsigned char\t*next_in;\n  288  \t\tint64_t\t\t\t avail_in;\n  ...\n  325  \n  326  \t/* Filename character-set conversion data. */\n  327: \tstruct archive_string_conv *sconv;\n  328  \n  329  \tchar\t\t\t format_name[64];\n  ...\n  338  #define UMAX_ENTRY\tARCHIVE_LITERAL_ULL(100000000)\n  339  \n  340: static int\tarchive_read_format_7zip_has_encrypted_entries(struct archive_read *);\n  341: static int\tarchive_read_support_format_7zip_capabilities(struct archive_read *a);\n  342: static int\tarchive_read_format_7zip_bid(struct archive_read *, int);\n  343: static int\tarchive_read_format_7zip_cleanup(struct archive_read *);\n  344: static int\tarchive_read_format_7zip_read_data(struct archive_read *,\n  345  \t\t    const void **, size_t *, int64_t *);\n  346: static int\tarchive_read_format_7zip_read_data_skip(struct archive_read *);\n  347: static int\tarchive_read_format_7zip_read_header(struct archive_read *,\n  348: \t\t    struct archive_entry *);\n  349  static int\tcheck_7zip_header_in_sfx(const char *);\n  350  static unsigned long decode_codec_id(const unsigned char *, size_t);\n  351: static int\tdecode_encoded_header_info(struct archive_read *,\n  352: \t\t    struct _7z_stream_info *);\n  353: static int\tdecompress(struct archive_read *, struct _7zip *,\n  354  \t\t    void *, size_t *, const void *, size_t *);\n  355: static ssize_t\textract_pack_stream(struct archive_read *, size_t);\n  356  static void\tfileTimeToUtc(uint64_t, time_t *, long *);\n  357: static uint64_t folder_uncompressed_size(struct _7z_folder *);\n  358: static void\tfree_CodersInfo(struct _7z_coders_info *);\n  359: static void\tfree_Digest(struct _7z_digests *);\n  360: static void\tfree_Folder(struct _7z_folder *);\n  361: static void\tfree_Header(struct _7z_header_info *);\n  362: static void\tfree_PackInfo(struct _7z_pack_info *);\n  363: static void\tfree_StreamsInfo(struct _7z_stream_info *);\n  364: static void\tfree_SubStreamsInfo(struct _7z_substream_info *);\n  365: static int\tfree_decompression(struct archive_read *, struct _7zip *);\n  366: static ssize_t\tget_uncompressed_data(struct archive_read *, const void **,\n  367  \t\t    size_t, size_t);\n  368: static const unsigned char * header_bytes(struct archive_read *, size_t);\n  369: static int\tinit_decompression(struct archive_read *, struct _7zip *,\n  370: \t\t    const struct _7z_coder *, const struct _7z_coder *);\n  371: static int\tparse_7zip_uint64(struct archive_read *, uint64_t *);\n  372: static int\tread_Bools(struct archive_read *, unsigned char *, size_t);\n  373: static int\tread_CodersInfo(struct archive_read *,\n  374: \t\t    struct _7z_coders_info *);\n  375: static int\tread_Digests(struct archive_read *, struct _7z_digests *,\n  376  \t\t    size_t);\n  377: static int\tread_Folder(struct archive_read *, struct _7z_folder *);\n  378: static int\tread_Header(struct archive_read *, struct _7z_header_info *,\n  379  \t\t    int);\n  380: static int\tread_PackInfo(struct archive_read *, struct _7z_pack_info *);\n  381: static int\tread_StreamsInfo(struct archive_read *,\n  382: \t\t    struct _7z_stream_info *);\n  383: static int\tread_SubStreamsInfo(struct archive_read *,\n  384: \t\t    struct _7z_substream_info *, struct _7z_folder *, size_t);\n  385: static int\tread_Times(struct archive_read *, struct _7z_header_info *,\n  386  \t\t    int);\n  387: static void\tread_consume(struct archive_read *);\n  388: static ssize_t\tread_stream(struct archive_read *, const void **, size_t,\n  389  \t\t    size_t);\n  390: static int\tseek_pack(struct archive_read *);\n  391: static int64_t\tskip_stream(struct archive_read *, size_t);\n  392: static int\tskip_sfx(struct archive_read *, ssize_t);\n  393: static int\tslurp_central_directory(struct archive_read *, struct _7zip *,\n  394: \t\t    struct _7z_header_info *);\n  395: static int\tsetup_decode_folder(struct archive_read *, struct _7z_folder *,\n  396  \t\t    int);\n  397: static void\tx86_Init(struct _7zip *);\n  398: static size_t\tx86_Convert(struct _7zip *, uint8_t *, size_t);\n  399: static ssize_t\t\tBcj2_Decode(struct _7zip *, uint8_t *, size_t);\n  400  \n  401  \n  402  int\n  403: archive_read_support_format_7zip(struct archive *_a)\n  404  {\n  405: \tstruct archive_read *a = (struct archive_read *)_a;\n  406: \tstruct _7zip *zip;\n  407  \tint r;\n  408  \n  ...\n  443  \n  444  static int\n  445: archive_read_support_format_7zip_capabilities(struct archive_read * a)\n  446  {\n  447  \t(void)a; /* UNUSED */\n  ...\n  452  \n  453  static int\n  454: archive_read_format_7zip_has_encrypted_entries(struct archive_read *_a)\n  455  {\n  456  \tif (_a && _a->format) {\n  457: \t\tstruct _7zip * zip = (struct _7zip *)_a->format->data;\n  458  \t\tif (zip) {\n  459  \t\t\treturn zip->has_encrypted_entries;\n  ...\n  464  \n  465  static int\n  466: archive_read_format_7zip_bid(struct archive_read *a, int best_bid)\n  467  {\n  468  \tconst char *p;\n  ...\n  543  \n  544  static int\n  545: skip_sfx(struct archive_read *a, ssize_t bytes_avail)\n  546  {\n  547  \tconst void *h;\n  ...\n  586  \t\t\tint step = check_7zip_header_in_sfx(p);\n  587  \t\t\tif (step == 0) {\n  588: \t\t\t\tstruct _7zip *zip =\n  589: \t\t\t\t    (struct _7zip *)a->format->data;\n  590  \t\t\t\tskip = p - (const char *)h;\n  591  \t\t\t\t__archive_read_consume(a, skip);\n  ...\n  608  \n  609  static int\n  610: archive_read_format_7zip_read_header(struct archive_read *a,\n  611: \tstruct archive_entry *entry)\n  612  {\n  613: \tstruct _7zip *zip = (struct _7zip *)a->format->data;\n  614: \tstruct _7zip_entry *zip_entry;\n  615  \tint r, ret = ARCHIVE_OK;\n  616: \tstruct _7z_folder *folder = 0;\n  617  \tuint64_t fidx = 0;\n  618  \n  ...\n  633  \n  634  \tif (zip->entries == NULL) {\n  635: \t\tstruct _7z_header_info header;\n  636  \n  637  \t\tmemset(&header, 0, sizeof(header));\n  ...\n  783  \n  784  static int\n  785: archive_read_format_7zip_read_data(struct archive_read *a,\n  786      const void **buff, size_t *size, int64_t *offset)\n  787  {\n  788: \tstruct _7zip *zip;\n  789  \tssize_t bytes;\n  790  \tint ret = ARCHIVE_OK;\n  791  \n  792: \tzip = (struct _7zip *)(a->format->data);\n  793  \n  794  \tif (zip->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n  ...\n  855  \n  856  static int\n  857: archive_read_format_7zip_read_data_skip(struct archive_read *a)\n  858  {\n  859: \tstruct _7zip *zip;\n  860  \tint64_t bytes_skipped;\n  861  \n  862: \tzip = (struct _7zip *)(a->format->data);\n  863  \n  864  \tif (zip->pack_stream_bytes_unconsumed)\n  ...\n  884  \n  885  static int\n  886: archive_read_format_7zip_cleanup(struct archive_read *a)\n  887  {\n  888: \tstruct _7zip *zip;\n  889  \n  890: \tzip = (struct _7zip *)(a->format->data);\n  891  \tfree_StreamsInfo(&(zip->si));\n  892  \tfree(zip->entries);\n  ...\n  904  \n  905  static void\n  906: read_consume(struct archive_read *a)\n  907  {\n  908: \tstruct _7zip *zip = (struct _7zip *)a->format->data;\n  909  \n  910  \tif (zip->pack_stream_bytes_unconsumed) {\n  ...\n  921   */\n  922  static void\n  923: set_error(struct archive_read *a, int ret)\n  924  {\n  925  \n  ...\n  983  ppmd_read(void *p)\n  984  {\n  985: \tstruct archive_read *a = ((IByteIn*)p)->a;\n  986: \tstruct _7zip *zip = (struct _7zip *)(a->format->data);\n  987  \tByte b;\n  988  \n  ...\n 1000  \n 1001  static int\n 1002: init_decompression(struct archive_read *a, struct _7zip *zip,\n 1003:     const struct _7z_coder *coder1, const struct _7z_coder *coder2)\n 1004  {\n 1005  \tint r;\n ....\n 1252  \t\t\treturn (ARCHIVE_FAILED);\n 1253  \t\t}\n 1254: \t\t__archive_ppmd7_functions.Ppmd7_Construct(&zip->ppmd7_context);\n 1255  \t\tr = __archive_ppmd7_functions.Ppmd7_Alloc(\n 1256  \t\t\t&zip->ppmd7_context, msize);\n ....\n 1303  \n 1304  static int\n 1305: decompress(struct archive_read *a, struct _7zip *zip,\n 1306      void *buff, size_t *outbytes, const void *b, size_t *used)\n 1307  {\n ....\n 1598  \n 1599  static int\n 1600: free_decompression(struct archive_read *a, struct _7zip *zip)\n 1601  {\n 1602  \tint r = ARCHIVE_OK;\n ....\n 1641  \n 1642  static int\n 1643: parse_7zip_uint64(struct archive_read *a, uint64_t *val)\n 1644  {\n 1645  \tconst unsigned char *p;\n ....\n 1667  \n 1668  static int\n 1669: read_Bools(struct archive_read *a, unsigned char *data, size_t num)\n 1670  {\n 1671  \tconst unsigned char *p;\n ....\n 1686  \n 1687  static void\n 1688: free_Digest(struct _7z_digests *d)\n 1689  {\n 1690  \tfree(d->defineds);\n ....\n 1693  \n 1694  static int\n 1695: read_Digests(struct archive_read *a, struct _7z_digests *d, size_t num)\n 1696  {\n 1697  \tconst unsigned char *p;\n ....\n 1732  \n 1733  static void\n 1734: free_PackInfo(struct _7z_pack_info *pi)\n 1735  {\n 1736  \tfree(pi->sizes);\n ....\n 1740  \n 1741  static int\n 1742: read_PackInfo(struct archive_read *a, struct _7z_pack_info *pi)\n 1743  {\n 1744  \tconst unsigned char *p;\n ....\n 1816  \n 1817  static void\n 1818: free_Folder(struct _7z_folder *f)\n 1819  {\n 1820  \tunsigned i;\n ....\n 1832  \n 1833  static int\n 1834: read_Folder(struct archive_read *a, struct _7z_folder *f)\n 1835  {\n 1836: \tstruct _7zip *zip = (struct _7zip *)a->format->data;\n 1837  \tconst unsigned char *p;\n 1838  \tuint64_t numInStreamsTotal = 0;\n ....\n 1975  \n 1976  static void\n 1977: free_CodersInfo(struct _7z_coders_info *ci)\n 1978  {\n 1979  \tunsigned i;\n ....\n 1987  \n 1988  static int\n 1989: read_CodersInfo(struct archive_read *a, struct _7z_coders_info *ci)\n 1990  {\n 1991  \tconst unsigned char *p;\n 1992: \tstruct _7z_digests digest;\n 1993  \tunsigned i;\n 1994  \n ....\n 2048  \n 2049  \tfor (i = 0; i < ci->numFolders; i++) {\n 2050: \t\tstruct _7z_folder *folder = &(ci->folders[i]);\n 2051  \t\tunsigned j;\n 2052  \n ....\n 2092  \n 2093  static uint64_t\n 2094: folder_uncompressed_size(struct _7z_folder *f)\n 2095  {\n 2096  \tint n = (int)f->numOutStreams;\n ....\n 2110  \n 2111  static void\n 2112: free_SubStreamsInfo(struct _7z_substream_info *ss)\n 2113  {\n 2114  \tfree(ss->unpackSizes);\n ....\n 2118  \n 2119  static int\n 2120: read_SubStreamsInfo(struct archive_read *a, struct _7z_substream_info *ss,\n 2121:     struct _7z_folder *f, size_t numFolders)\n 2122  {\n 2123  \tconst unsigned char *p;\n ....\n 2205  \n 2206  \tif (type == kCRC) {\n 2207: \t\tstruct _7z_digests tmpDigests;\n 2208  \t\tunsigned char *digestsDefined = ss->digestsDefined;\n 2209  \t\tuint32_t * digests = ss->digests;\n ....\n 2246  \n 2247  static void\n 2248: free_StreamsInfo(struct _7z_stream_info *si)\n 2249  {\n 2250  \tfree_PackInfo(&(si->pi));\n ....\n 2254  \n 2255  static int\n 2256: read_StreamsInfo(struct archive_read *a, struct _7z_stream_info *si)\n 2257  {\n 2258: \tstruct _7zip *zip = (struct _7zip *)a->format->data;\n 2259  \tconst unsigned char *p;\n 2260  \tunsigned i;\n ....\n 2287  \tif (*p == kUnPackInfo) {\n 2288  \t\tuint32_t packIndex;\n 2289: \t\tstruct _7z_folder *f;\n 2290  \n 2291  \t\tif (read_CodersInfo(a, &(si->ci)) < 0)\n ....\n 2324  \n 2325  static void\n 2326: free_Header(struct _7z_header_info *h)\n 2327  {\n 2328  \tfree(h->emptyStreamBools);\n ....\n 2333  \n 2334  static int\n 2335: read_Header(struct archive_read *a, struct _7z_header_info *h,\n 2336      int check_header_id)\n 2337  {\n 2338: \tstruct _7zip *zip = (struct _7zip *)a->format->data;\n 2339  \tconst unsigned char *p;\n 2340: \tstruct _7z_folder *folders;\n 2341: \tstruct _7z_stream_info *si = &(zip->si);\n 2342: \tstruct _7zip_entry *entries;\n 2343  \tuint32_t folderIndex, indexInFolder;\n 2344  \tunsigned i;\n ....\n 2677  \n 2678  static int\n 2679: read_Times(struct archive_read *a, struct _7z_header_info *h, int type)\n 2680  {\n 2681: \tstruct _7zip *zip = (struct _7zip *)a->format->data;\n 2682  \tconst unsigned char *p;\n 2683: \tstruct _7zip_entry *entries = zip->entries;\n 2684  \tunsigned char *timeBools;\n 2685  \tint allAreDefined;\n ....\n 2746  \n 2747  static int\n 2748: decode_encoded_header_info(struct archive_read *a, struct _7z_stream_info *si)\n 2749  {\n 2750: \tstruct _7zip *zip = (struct _7zip *)a->format->data;\n 2751  \n 2752  \terrno = 0;\n ....\n 2777  \n 2778  static const unsigned char *\n 2779: header_bytes(struct archive_read *a, size_t rbytes)\n 2780  {\n 2781: \tstruct _7zip *zip = (struct _7zip *)a->format->data;\n 2782  \tconst unsigned char *p;\n 2783  \n ....\n 2810  \n 2811  static int\n 2812: slurp_central_directory(struct archive_read *a, struct _7zip *zip,\n 2813:     struct _7z_header_info *header)\n 2814  {\n 2815  \tconst unsigned char *p;\n ....\n 2967  \n 2968  static ssize_t\n 2969: get_uncompressed_data(struct archive_read *a, const void **buff, size_t size,\n 2970      size_t minimum)\n 2971  {\n 2972: \tstruct _7zip *zip = (struct _7zip *)a->format->data;\n 2973  \tssize_t bytes_avail;\n 2974  \n ....\n 3020  \n 3021  static ssize_t\n 3022: extract_pack_stream(struct archive_read *a, size_t minimum)\n 3023  {\n 3024: \tstruct _7zip *zip = (struct _7zip *)a->format->data;\n 3025  \tssize_t bytes_avail;\n 3026  \tint r;\n ....\n 3181  \n 3182  static int\n 3183: seek_pack(struct archive_read *a)\n 3184  {\n 3185: \tstruct _7zip *zip = (struct _7zip *)a->format->data;\n 3186  \tint64_t pack_offset;\n 3187  \n ....\n 3206  \n 3207  static ssize_t\n 3208: read_stream(struct archive_read *a, const void **buff, size_t size,\n 3209      size_t minimum)\n 3210  {\n 3211: \tstruct _7zip *zip = (struct _7zip *)a->format->data;\n 3212  \tuint64_t skip_bytes = 0;\n 3213  \tssize_t r;\n ....\n 3316  \n 3317  static int\n 3318: setup_decode_folder(struct archive_read *a, struct _7z_folder *folder,\n 3319      int header)\n 3320  {\n 3321: \tstruct _7zip *zip = (struct _7zip *)a->format->data;\n 3322: \tconst struct _7z_coder *coder1, *coder2;\n 3323  \tconst char *cname = (header)?\"archive header\":\"file content\";\n 3324  \tunsigned i;\n ....\n 3394  \t\t * as far as I know, two types of the storage form.\n 3395  \t\t */\n 3396: \t\tconst struct _7z_coder *fc = folder->coders;\n 3397: \t\tstatic const struct _7z_coder coder_copy = {0, 1, 1, 0, NULL};\n 3398: \t\tconst struct _7z_coder *scoder[3] =\n 3399  \t\t\t{&coder_copy, &coder_copy, &coder_copy};\n 3400  \t\tconst void *buff;\n ....\n 3479  \t\t/* Read following three sub streams. */\n 3480  \t\tfor (i = 0; i < 3; i++) {\n 3481: \t\t\tconst struct _7z_coder *coder = scoder[i];\n 3482  \n 3483  \t\t\tif ((r = seek_pack(a)) < 0) {\n ....\n 3573  \n 3574  static int64_t\n 3575: skip_stream(struct archive_read *a, size_t skip_bytes)\n 3576  {\n 3577: \tstruct _7zip *zip = (struct _7zip *)a->format->data;\n 3578  \tconst void *p;\n 3579  \tint64_t skipped_bytes;\n ....\n 3618  \n 3619  static void\n 3620: x86_Init(struct _7zip *zip)\n 3621  {\n 3622  \tzip->bcj_state = 0;\n ....\n 3627  \n 3628  static size_t\n 3629: x86_Convert(struct _7zip *zip, uint8_t *data, size_t size)\n 3630  {\n 3631  \tstatic const uint8_t kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};\n ....\n 3737  \n 3738  static ssize_t\n 3739: Bcj2_Decode(struct _7zip *zip, uint8_t *outBuf, size_t outSize)\n 3740  {\n 3741  \tsize_t inPos = 0, outPos = 0;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_entry.c:\n  152   ****************************************************************************/\n  153  \n  154: struct archive_entry *\n  155: archive_entry_clear(struct archive_entry *entry)\n  156  {\n  157  \tif (entry == NULL)\n  ...\n  174  }\n  175  \n  176: struct archive_entry *\n  177: archive_entry_clone(struct archive_entry *entry)\n  178  {\n  179: \tstruct archive_entry *entry2;\n  180: \tstruct ae_xattr *xp;\n  181: \tstruct ae_sparse *sp;\n  182  \tsize_t s;\n  183  \tconst void *p;\n  184  \n  185: \t/* Allocate new structure and copy over all of the fields. */\n  186  \t/* TODO: Should we copy the archive over?  Or require a new archive\n  187  \t * as an argument? */\n  ...\n  250  \n  251  void\n  252: archive_entry_free(struct archive_entry *entry)\n  253  {\n  254  \tarchive_entry_clear(entry);\n  ...\n  256  }\n  257  \n  258: struct archive_entry *\n  259  archive_entry_new(void)\n  260  {\n  ...\n  262  }\n  263  \n  264: struct archive_entry *\n  265: archive_entry_new2(struct archive *a)\n  266  {\n  267: \tstruct archive_entry *entry;\n  268  \n  269: \tentry = (struct archive_entry *)calloc(1, sizeof(*entry));\n  270  \tif (entry == NULL)\n  271  \t\treturn (NULL);\n  ...\n  280  \n  281  time_t\n  282: archive_entry_atime(struct archive_entry *entry)\n  283  {\n  284  \treturn (entry->ae_stat.aest_atime);\n  ...\n  286  \n  287  long\n  288: archive_entry_atime_nsec(struct archive_entry *entry)\n  289  {\n  290  \treturn (entry->ae_stat.aest_atime_nsec);\n  ...\n  292  \n  293  int\n  294: archive_entry_atime_is_set(struct archive_entry *entry)\n  295  {\n  296  \treturn (entry->ae_set & AE_SET_ATIME);\n  ...\n  298  \n  299  time_t\n  300: archive_entry_birthtime(struct archive_entry *entry)\n  301  {\n  302  \treturn (entry->ae_stat.aest_birthtime);\n  ...\n  304  \n  305  long\n  306: archive_entry_birthtime_nsec(struct archive_entry *entry)\n  307  {\n  308  \treturn (entry->ae_stat.aest_birthtime_nsec);\n  ...\n  310  \n  311  int\n  312: archive_entry_birthtime_is_set(struct archive_entry *entry)\n  313  {\n  314  \treturn (entry->ae_set & AE_SET_BIRTHTIME);\n  ...\n  316  \n  317  time_t\n  318: archive_entry_ctime(struct archive_entry *entry)\n  319  {\n  320  \treturn (entry->ae_stat.aest_ctime);\n  ...\n  322  \n  323  int\n  324: archive_entry_ctime_is_set(struct archive_entry *entry)\n  325  {\n  326  \treturn (entry->ae_set & AE_SET_CTIME);\n  ...\n  328  \n  329  long\n  330: archive_entry_ctime_nsec(struct archive_entry *entry)\n  331  {\n  332  \treturn (entry->ae_stat.aest_ctime_nsec);\n  ...\n  334  \n  335  dev_t\n  336: archive_entry_dev(struct archive_entry *entry)\n  337  {\n  338  \tif (entry->ae_stat.aest_dev_is_broken_down)\n  ...\n  344  \n  345  int\n  346: archive_entry_dev_is_set(struct archive_entry *entry)\n  347  {\n  348  \treturn (entry->ae_set & AE_SET_DEV);\n  ...\n  350  \n  351  dev_t\n  352: archive_entry_devmajor(struct archive_entry *entry)\n  353  {\n  354  \tif (entry->ae_stat.aest_dev_is_broken_down)\n  ...\n  359  \n  360  dev_t\n  361: archive_entry_devminor(struct archive_entry *entry)\n  362  {\n  363  \tif (entry->ae_stat.aest_dev_is_broken_down)\n  ...\n  368  \n  369  __LA_MODE_T\n  370: archive_entry_filetype(struct archive_entry *entry)\n  371  {\n  372  \treturn (AE_IFMT & entry->acl.mode);\n  ...\n  374  \n  375  void\n  376: archive_entry_fflags(struct archive_entry *entry,\n  377      unsigned long *set, unsigned long *clear)\n  378  {\n  ...\n  391   */\n  392  const char *\n  393: archive_entry_fflags_text(struct archive_entry *entry)\n  394  {\n  395  \tconst char *f;\n  ...\n  421  \n  422  la_int64_t\n  423: archive_entry_gid(struct archive_entry *entry)\n  424  {\n  425  \treturn (entry->ae_stat.aest_gid);\n  ...\n  427  \n  428  const char *\n  429: archive_entry_gname(struct archive_entry *entry)\n  430  {\n  431  \tconst char *p;\n  ...\n  438  \n  439  const char *\n  440: archive_entry_gname_utf8(struct archive_entry *entry)\n  441  {\n  442  \tconst char *p;\n  ...\n  450  \n  451  const wchar_t *\n  452: archive_entry_gname_w(struct archive_entry *entry)\n  453  {\n  454  \tconst wchar_t *p;\n  ...\n  461  \n  462  int\n  463: _archive_entry_gname_l(struct archive_entry *entry,\n  464:     const char **p, size_t *len, struct archive_string_conv *sc)\n  465  {\n  466  \treturn (archive_mstring_get_mbs_l(entry->archive, &entry->ae_gname, p, len, sc));\n  ...\n  468  \n  469  const char *\n  470: archive_entry_hardlink(struct archive_entry *entry)\n  471  {\n  472  \tconst char *p;\n  ...\n  482  \n  483  const char *\n  484: archive_entry_hardlink_utf8(struct archive_entry *entry)\n  485  {\n  486  \tconst char *p;\n  ...\n  496  \n  497  const wchar_t *\n  498: archive_entry_hardlink_w(struct archive_entry *entry)\n  499  {\n  500  \tconst wchar_t *p;\n  ...\n  510  \n  511  int\n  512: _archive_entry_hardlink_l(struct archive_entry *entry,\n  513:     const char **p, size_t *len, struct archive_string_conv *sc)\n  514  {\n  515  \tif ((entry->ae_set & AE_SET_HARDLINK) == 0) {\n  ...\n  522  \n  523  la_int64_t\n  524: archive_entry_ino(struct archive_entry *entry)\n  525  {\n  526  \treturn (entry->ae_stat.aest_ino);\n  ...\n  528  \n  529  int\n  530: archive_entry_ino_is_set(struct archive_entry *entry)\n  531  {\n  532  \treturn (entry->ae_set & AE_SET_INO);\n  ...\n  534  \n  535  la_int64_t\n  536: archive_entry_ino64(struct archive_entry *entry)\n  537  {\n  538  \treturn (entry->ae_stat.aest_ino);\n  ...\n  540  \n  541  __LA_MODE_T\n  542: archive_entry_mode(struct archive_entry *entry)\n  543  {\n  544  \treturn (entry->acl.mode);\n  ...\n  546  \n  547  time_t\n  548: archive_entry_mtime(struct archive_entry *entry)\n  549  {\n  550  \treturn (entry->ae_stat.aest_mtime);\n  ...\n  552  \n  553  long\n  554: archive_entry_mtime_nsec(struct archive_entry *entry)\n  555  {\n  556  \treturn (entry->ae_stat.aest_mtime_nsec);\n  ...\n  558  \n  559  int\n  560: archive_entry_mtime_is_set(struct archive_entry *entry)\n  561  {\n  562  \treturn (entry->ae_set & AE_SET_MTIME);\n  ...\n  564  \n  565  unsigned int\n  566: archive_entry_nlink(struct archive_entry *entry)\n  567  {\n  568  \treturn (entry->ae_stat.aest_nlink);\n  ...\n  570  \n  571  const char *\n  572: archive_entry_pathname(struct archive_entry *entry)\n  573  {\n  574  \tconst char *p;\n  ...\n  582  \n  583  const char *\n  584: archive_entry_pathname_utf8(struct archive_entry *entry)\n  585  {\n  586  \tconst char *p;\n  ...\n  594  \n  595  const wchar_t *\n  596: archive_entry_pathname_w(struct archive_entry *entry)\n  597  {\n  598  \tconst wchar_t *p;\n  ...\n  606  \n  607  int\n  608: _archive_entry_pathname_l(struct archive_entry *entry,\n  609:     const char **p, size_t *len, struct archive_string_conv *sc)\n  610  {\n  611  \treturn (archive_mstring_get_mbs_l(entry->archive, &entry->ae_pathname, p, len, sc));\n  ...\n  613  \n  614  __LA_MODE_T\n  615: archive_entry_perm(struct archive_entry *entry)\n  616  {\n  617  \treturn (~AE_IFMT & entry->acl.mode);\n  ...\n  619  \n  620  dev_t\n  621: archive_entry_rdev(struct archive_entry *entry)\n  622  {\n  623  \tif (entry->ae_stat.aest_rdev_is_broken_down)\n  ...\n  629  \n  630  dev_t\n  631: archive_entry_rdevmajor(struct archive_entry *entry)\n  632  {\n  633  \tif (entry->ae_stat.aest_rdev_is_broken_down)\n  ...\n  638  \n  639  dev_t\n  640: archive_entry_rdevminor(struct archive_entry *entry)\n  641  {\n  642  \tif (entry->ae_stat.aest_rdev_is_broken_down)\n  ...\n  647  \n  648  la_int64_t\n  649: archive_entry_size(struct archive_entry *entry)\n  650  {\n  651  \treturn (entry->ae_stat.aest_size);\n  ...\n  653  \n  654  int\n  655: archive_entry_size_is_set(struct archive_entry *entry)\n  656  {\n  657  \treturn (entry->ae_set & AE_SET_SIZE);\n  ...\n  659  \n  660  const char *\n  661: archive_entry_sourcepath(struct archive_entry *entry)\n  662  {\n  663  \tconst char *p;\n  ...\n  671  \n  672  const wchar_t *\n  673: archive_entry_sourcepath_w(struct archive_entry *entry)\n  674  {\n  675  \tconst wchar_t *p;\n  ...\n  681  \n  682  const char *\n  683: archive_entry_symlink(struct archive_entry *entry)\n  684  {\n  685  \tconst char *p;\n  ...\n  695  \n  696  int\n  697: archive_entry_symlink_type(struct archive_entry *entry)\n  698  {\n  699  \treturn (entry->ae_symlink_type);\n  ...\n  701  \n  702  const char *\n  703: archive_entry_symlink_utf8(struct archive_entry *entry)\n  704  {\n  705  \tconst char *p;\n  ...\n  715  \n  716  const wchar_t *\n  717: archive_entry_symlink_w(struct archive_entry *entry)\n  718  {\n  719  \tconst wchar_t *p;\n  ...\n  729  \n  730  int\n  731: _archive_entry_symlink_l(struct archive_entry *entry,\n  732:     const char **p, size_t *len, struct archive_string_conv *sc)\n  733  {\n  734  \tif ((entry->ae_set & AE_SET_SYMLINK) == 0) {\n  ...\n  741  \n  742  la_int64_t\n  743: archive_entry_uid(struct archive_entry *entry)\n  744  {\n  745  \treturn (entry->ae_stat.aest_uid);\n  ...\n  747  \n  748  const char *\n  749: archive_entry_uname(struct archive_entry *entry)\n  750  {\n  751  \tconst char *p;\n  ...\n  758  \n  759  const char *\n  760: archive_entry_uname_utf8(struct archive_entry *entry)\n  761  {\n  762  \tconst char *p;\n  ...\n  769  \n  770  const wchar_t *\n  771: archive_entry_uname_w(struct archive_entry *entry)\n  772  {\n  773  \tconst wchar_t *p;\n  ...\n  780  \n  781  int\n  782: _archive_entry_uname_l(struct archive_entry *entry,\n  783:     const char **p, size_t *len, struct archive_string_conv *sc)\n  784  {\n  785  \treturn (archive_mstring_get_mbs_l(entry->archive, &entry->ae_uname, p, len, sc));\n  ...\n  787  \n  788  int\n  789: archive_entry_is_data_encrypted(struct archive_entry *entry)\n  790  {\n  791  \treturn ((entry->encryption & AE_ENCRYPTION_DATA) == AE_ENCRYPTION_DATA);\n  ...\n  793  \n  794  int\n  795: archive_entry_is_metadata_encrypted(struct archive_entry *entry)\n  796  {\n  797  \treturn ((entry->encryption & AE_ENCRYPTION_METADATA) == AE_ENCRYPTION_METADATA);\n  ...\n  799  \n  800  int\n  801: archive_entry_is_encrypted(struct archive_entry *entry)\n  802  {\n  803  \treturn (entry->encryption & (AE_ENCRYPTION_DATA|AE_ENCRYPTION_METADATA));\n  ...\n  809  \n  810  void\n  811: archive_entry_set_filetype(struct archive_entry *entry, unsigned int type)\n  812  {\n  813  \tentry->stat_valid = 0;\n  ...\n  817  \n  818  void\n  819: archive_entry_set_fflags(struct archive_entry *entry,\n  820      unsigned long set, unsigned long clear)\n  821  {\n  ...\n  826  \n  827  const char *\n  828: archive_entry_copy_fflags_text(struct archive_entry *entry,\n  829      const char *flags)\n  830  {\n  ...\n  835  \n  836  const wchar_t *\n  837: archive_entry_copy_fflags_text_w(struct archive_entry *entry,\n  838      const wchar_t *flags)\n  839  {\n  ...\n  844  \n  845  void\n  846: archive_entry_set_gid(struct archive_entry *entry, la_int64_t g)\n  847  {\n  848  \tentry->stat_valid = 0;\n  ...\n  851  \n  852  void\n  853: archive_entry_set_gname(struct archive_entry *entry, const char *name)\n  854  {\n  855  \tarchive_mstring_copy_mbs(&entry->ae_gname, name);\n  ...\n  857  \n  858  void\n  859: archive_entry_set_gname_utf8(struct archive_entry *entry, const char *name)\n  860  {\n  861  \tarchive_mstring_copy_utf8(&entry->ae_gname, name);\n  ...\n  863  \n  864  void\n  865: archive_entry_copy_gname(struct archive_entry *entry, const char *name)\n  866  {\n  867  \tarchive_mstring_copy_mbs(&entry->ae_gname, name);\n  ...\n  869  \n  870  void\n  871: archive_entry_copy_gname_w(struct archive_entry *entry, const wchar_t *name)\n  872  {\n  873  \tarchive_mstring_copy_wcs(&entry->ae_gname, name);\n  ...\n  875  \n  876  int\n  877: archive_entry_update_gname_utf8(struct archive_entry *entry, const char *name)\n  878  {\n  879  \tif (archive_mstring_update_utf8(entry->archive,\n  ...\n  886  \n  887  int\n  888: _archive_entry_copy_gname_l(struct archive_entry *entry,\n  889:     const char *name, size_t len, struct archive_string_conv *sc)\n  890  {\n  891  \treturn (archive_mstring_copy_mbs_len_l(&entry->ae_gname, name, len, sc));\n  ...\n  893  \n  894  void\n  895: archive_entry_set_ino(struct archive_entry *entry, la_int64_t ino)\n  896  {\n  897  \tentry->stat_valid = 0;\n  ...\n  901  \n  902  void\n  903: archive_entry_set_ino64(struct archive_entry *entry, la_int64_t ino)\n  904  {\n  905  \tentry->stat_valid = 0;\n  ...\n  909  \n  910  void\n  911: archive_entry_set_hardlink(struct archive_entry *entry, const char *target)\n  912  {\n  913  \tarchive_mstring_copy_mbs(&entry->ae_hardlink, target);\n  ...\n  919  \n  920  void\n  921: archive_entry_set_hardlink_utf8(struct archive_entry *entry, const char *target)\n  922  {\n  923  \tarchive_mstring_copy_utf8(&entry->ae_hardlink, target);\n  ...\n  929  \n  930  void\n  931: archive_entry_copy_hardlink(struct archive_entry *entry, const char *target)\n  932  {\n  933  \tarchive_mstring_copy_mbs(&entry->ae_hardlink, target);\n  ...\n  939  \n  940  void\n  941: archive_entry_copy_hardlink_w(struct archive_entry *entry, const wchar_t *target)\n  942  {\n  943  \tarchive_mstring_copy_wcs(&entry->ae_hardlink, target);\n  ...\n  949  \n  950  int\n  951: archive_entry_update_hardlink_utf8(struct archive_entry *entry, const char *target)\n  952  {\n  953  \tif (target != NULL)\n  ...\n  964  \n  965  int\n  966: _archive_entry_copy_hardlink_l(struct archive_entry *entry,\n  967:     const char *target, size_t len, struct archive_string_conv *sc)\n  968  {\n  969  \tint r;\n  ...\n  979  \n  980  void\n  981: archive_entry_set_atime(struct archive_entry *entry, time_t t, long ns)\n  982  {\n  983  \tFIX_NS(t, ns);\n  ...\n  989  \n  990  void\n  991: archive_entry_unset_atime(struct archive_entry *entry)\n  992  {\n  993  \tarchive_entry_set_atime(entry, 0, 0);\n  ...\n  996  \n  997  void\n  998: archive_entry_set_birthtime(struct archive_entry *entry, time_t t, long ns)\n  999  {\n 1000  \tFIX_NS(t, ns);\n ....\n 1006  \n 1007  void\n 1008: archive_entry_unset_birthtime(struct archive_entry *entry)\n 1009  {\n 1010  \tarchive_entry_set_birthtime(entry, 0, 0);\n ....\n 1013  \n 1014  void\n 1015: archive_entry_set_ctime(struct archive_entry *entry, time_t t, long ns)\n 1016  {\n 1017  \tFIX_NS(t, ns);\n ....\n 1023  \n 1024  void\n 1025: archive_entry_unset_ctime(struct archive_entry *entry)\n 1026  {\n 1027  \tarchive_entry_set_ctime(entry, 0, 0);\n ....\n 1030  \n 1031  void\n 1032: archive_entry_set_dev(struct archive_entry *entry, dev_t d)\n 1033  {\n 1034  \tentry->stat_valid = 0;\n ....\n 1039  \n 1040  void\n 1041: archive_entry_set_devmajor(struct archive_entry *entry, dev_t m)\n 1042  {\n 1043  \tentry->stat_valid = 0;\n ....\n 1048  \n 1049  void\n 1050: archive_entry_set_devminor(struct archive_entry *entry, dev_t m)\n 1051  {\n 1052  \tentry->stat_valid = 0;\n ....\n 1058  /* Set symlink if symlink is already set, else set hardlink. */\n 1059  void\n 1060: archive_entry_set_link(struct archive_entry *entry, const char *target)\n 1061  {\n 1062  \tif (entry->ae_set & AE_SET_SYMLINK)\n ....\n 1067  \n 1068  void\n 1069: archive_entry_set_link_utf8(struct archive_entry *entry, const char *target)\n 1070  {\n 1071  \tif (entry->ae_set & AE_SET_SYMLINK)\n ....\n 1077  /* Set symlink if symlink is already set, else set hardlink. */\n 1078  void\n 1079: archive_entry_copy_link(struct archive_entry *entry, const char *target)\n 1080  {\n 1081  \tif (entry->ae_set & AE_SET_SYMLINK)\n ....\n 1087  /* Set symlink if symlink is already set, else set hardlink. */\n 1088  void\n 1089: archive_entry_copy_link_w(struct archive_entry *entry, const wchar_t *target)\n 1090  {\n 1091  \tif (entry->ae_set & AE_SET_SYMLINK)\n ....\n 1096  \n 1097  int\n 1098: archive_entry_update_link_utf8(struct archive_entry *entry, const char *target)\n 1099  {\n 1100  \tint r;\n ....\n 1113  \n 1114  int\n 1115: _archive_entry_copy_link_l(struct archive_entry *entry,\n 1116:     const char *target, size_t len, struct archive_string_conv *sc)\n 1117  {\n 1118  \tint r;\n ....\n 1128  \n 1129  void\n 1130: archive_entry_set_mode(struct archive_entry *entry, mode_t m)\n 1131  {\n 1132  \tentry->stat_valid = 0;\n ....\n 1135  \n 1136  void\n 1137: archive_entry_set_mtime(struct archive_entry *entry, time_t t, long ns)\n 1138  {\n 1139  \tFIX_NS(t, ns);\n ....\n 1145  \n 1146  void\n 1147: archive_entry_unset_mtime(struct archive_entry *entry)\n 1148  {\n 1149  \tarchive_entry_set_mtime(entry, 0, 0);\n ....\n 1152  \n 1153  void\n 1154: archive_entry_set_nlink(struct archive_entry *entry, unsigned int nlink)\n 1155  {\n 1156  \tentry->stat_valid = 0;\n ....\n 1159  \n 1160  void\n 1161: archive_entry_set_pathname(struct archive_entry *entry, const char *name)\n 1162  {\n 1163  \tarchive_mstring_copy_mbs(&entry->ae_pathname, name);\n ....\n 1165  \n 1166  void\n 1167: archive_entry_set_pathname_utf8(struct archive_entry *entry, const char *name)\n 1168  {\n 1169  \tarchive_mstring_copy_utf8(&entry->ae_pathname, name);\n ....\n 1171  \n 1172  void\n 1173: archive_entry_copy_pathname(struct archive_entry *entry, const char *name)\n 1174  {\n 1175  \tarchive_mstring_copy_mbs(&entry->ae_pathname, name);\n ....\n 1177  \n 1178  void\n 1179: archive_entry_copy_pathname_w(struct archive_entry *entry, const wchar_t *name)\n 1180  {\n 1181  \tarchive_mstring_copy_wcs(&entry->ae_pathname, name);\n ....\n 1183  \n 1184  int\n 1185: archive_entry_update_pathname_utf8(struct archive_entry *entry, const char *name)\n 1186  {\n 1187  \tif (archive_mstring_update_utf8(entry->archive,\n ....\n 1194  \n 1195  int\n 1196: _archive_entry_copy_pathname_l(struct archive_entry *entry,\n 1197:     const char *name, size_t len, struct archive_string_conv *sc)\n 1198  {\n 1199  \treturn (archive_mstring_copy_mbs_len_l(&entry->ae_pathname,\n ....\n 1202  \n 1203  void\n 1204: archive_entry_set_perm(struct archive_entry *entry, mode_t p)\n 1205  {\n 1206  \tentry->stat_valid = 0;\n ....\n 1210  \n 1211  void\n 1212: archive_entry_set_rdev(struct archive_entry *entry, dev_t m)\n 1213  {\n 1214  \tentry->stat_valid = 0;\n ....\n 1218  \n 1219  void\n 1220: archive_entry_set_rdevmajor(struct archive_entry *entry, dev_t m)\n 1221  {\n 1222  \tentry->stat_valid = 0;\n ....\n 1226  \n 1227  void\n 1228: archive_entry_set_rdevminor(struct archive_entry *entry, dev_t m)\n 1229  {\n 1230  \tentry->stat_valid = 0;\n ....\n 1234  \n 1235  void\n 1236: archive_entry_set_size(struct archive_entry *entry, la_int64_t s)\n 1237  {\n 1238  \tentry->stat_valid = 0;\n ....\n 1242  \n 1243  void\n 1244: archive_entry_unset_size(struct archive_entry *entry)\n 1245  {\n 1246  \tarchive_entry_set_size(entry, 0);\n ....\n 1249  \n 1250  void\n 1251: archive_entry_copy_sourcepath(struct archive_entry *entry, const char *path)\n 1252  {\n 1253  \tarchive_mstring_copy_mbs(&entry->ae_sourcepath, path);\n ....\n 1255  \n 1256  void\n 1257: archive_entry_copy_sourcepath_w(struct archive_entry *entry, const wchar_t *path)\n 1258  {\n 1259  \tarchive_mstring_copy_wcs(&entry->ae_sourcepath, path);\n ....\n 1261  \n 1262  void\n 1263: archive_entry_set_symlink(struct archive_entry *entry, const char *linkname)\n 1264  {\n 1265  \tarchive_mstring_copy_mbs(&entry->ae_symlink, linkname);\n ....\n 1271  \n 1272  void\n 1273: archive_entry_set_symlink_type(struct archive_entry *entry, int type)\n 1274  {\n 1275  \tentry->ae_symlink_type = type;\n ....\n 1277  \n 1278  void\n 1279: archive_entry_set_symlink_utf8(struct archive_entry *entry, const char *linkname)\n 1280  {\n 1281  \tarchive_mstring_copy_utf8(&entry->ae_symlink, linkname);\n ....\n 1287  \n 1288  void\n 1289: archive_entry_copy_symlink(struct archive_entry *entry, const char *linkname)\n 1290  {\n 1291  \tarchive_mstring_copy_mbs(&entry->ae_symlink, linkname);\n ....\n 1297  \n 1298  void\n 1299: archive_entry_copy_symlink_w(struct archive_entry *entry, const wchar_t *linkname)\n 1300  {\n 1301  \tarchive_mstring_copy_wcs(&entry->ae_symlink, linkname);\n ....\n 1307  \n 1308  int\n 1309: archive_entry_update_symlink_utf8(struct archive_entry *entry, const char *linkname)\n 1310  {\n 1311  \tif (linkname != NULL)\n ....\n 1322  \n 1323  int\n 1324: _archive_entry_copy_symlink_l(struct archive_entry *entry,\n 1325:     const char *linkname, size_t len, struct archive_string_conv *sc)\n 1326  {\n 1327  \tint r;\n ....\n 1337  \n 1338  void\n 1339: archive_entry_set_uid(struct archive_entry *entry, la_int64_t u)\n 1340  {\n 1341  \tentry->stat_valid = 0;\n ....\n 1344  \n 1345  void\n 1346: archive_entry_set_uname(struct archive_entry *entry, const char *name)\n 1347  {\n 1348  \tarchive_mstring_copy_mbs(&entry->ae_uname, name);\n ....\n 1350  \n 1351  void\n 1352: archive_entry_set_uname_utf8(struct archive_entry *entry, const char *name)\n 1353  {\n 1354  \tarchive_mstring_copy_utf8(&entry->ae_uname, name);\n ....\n 1356  \n 1357  void\n 1358: archive_entry_copy_uname(struct archive_entry *entry, const char *name)\n 1359  {\n 1360  \tarchive_mstring_copy_mbs(&entry->ae_uname, name);\n ....\n 1362  \n 1363  void\n 1364: archive_entry_copy_uname_w(struct archive_entry *entry, const wchar_t *name)\n 1365  {\n 1366  \tarchive_mstring_copy_wcs(&entry->ae_uname, name);\n ....\n 1368  \n 1369  int\n 1370: archive_entry_update_uname_utf8(struct archive_entry *entry, const char *name)\n 1371  {\n 1372  \tif (archive_mstring_update_utf8(entry->archive,\n ....\n 1379  \n 1380  void\n 1381: archive_entry_set_is_data_encrypted(struct archive_entry *entry, char is_encrypted)\n 1382  {\n 1383  \tif (is_encrypted) {\n ....\n 1389  \n 1390  void\n 1391: archive_entry_set_is_metadata_encrypted(struct archive_entry *entry, char is_encrypted)\n 1392  {\n 1393  \tif (is_encrypted) {\n ....\n 1399  \n 1400  int\n 1401: _archive_entry_copy_uname_l(struct archive_entry *entry,\n 1402:     const char *name, size_t len, struct archive_string_conv *sc)\n 1403  {\n 1404  \treturn (archive_mstring_copy_mbs_len_l(&entry->ae_uname,\n ....\n 1407  \n 1408  const void *\n 1409: archive_entry_mac_metadata(struct archive_entry *entry, size_t *s)\n 1410  {\n 1411    *s = entry->mac_metadata_size;\n ....\n 1414  \n 1415  void\n 1416: archive_entry_copy_mac_metadata(struct archive_entry *entry,\n 1417      const void *p, size_t s)\n 1418  {\n ....\n 1432  /* Digest handling */\n 1433  const unsigned char *\n 1434: archive_entry_digest(struct archive_entry *entry, int type)\n 1435  {\n 1436  \tswitch (type) {\n ....\n 1453  \n 1454  int\n 1455: archive_entry_set_digest(struct archive_entry *entry, int type,\n 1456      const unsigned char *digest)\n 1457  {\n ....\n 1495   */\n 1496  \n 1497: struct archive_acl *\n 1498: archive_entry_acl(struct archive_entry *entry)\n 1499  {\n 1500  \treturn &entry->acl;\n ....\n 1502  \n 1503  void\n 1504: archive_entry_acl_clear(struct archive_entry *entry)\n 1505  {\n 1506  \tarchive_acl_clear(&entry->acl);\n ....\n 1511   */\n 1512  int\n 1513: archive_entry_acl_add_entry(struct archive_entry *entry,\n 1514      int type, int permset, int tag, int id, const char *name)\n 1515  {\n ....\n 1521   */\n 1522  int\n 1523: archive_entry_acl_add_entry_w(struct archive_entry *entry,\n 1524      int type, int permset, int tag, int id, const wchar_t *name)\n 1525  {\n ....\n 1532   */\n 1533  int\n 1534: archive_entry_acl_types(struct archive_entry *entry)\n 1535  {\n 1536  \treturn (archive_acl_types(&entry->acl));\n ....\n 1541   */\n 1542  int\n 1543: archive_entry_acl_count(struct archive_entry *entry, int want_type)\n 1544  {\n 1545  \treturn archive_acl_count(&entry->acl, want_type);\n ....\n 1552   */\n 1553  int\n 1554: archive_entry_acl_reset(struct archive_entry *entry, int want_type)\n 1555  {\n 1556  \treturn archive_acl_reset(&entry->acl, want_type);\n ....\n 1562   */\n 1563  int\n 1564: archive_entry_acl_next(struct archive_entry *entry, int want_type, int *type,\n 1565      int *permset, int *tag, int *id, const char **name)\n 1566  {\n ....\n 1578   */\n 1579  wchar_t *\n 1580: archive_entry_acl_to_text_w(struct archive_entry *entry, la_ssize_t *len,\n 1581      int flags)\n 1582  {\n ....\n 1586  \n 1587  char *\n 1588: archive_entry_acl_to_text(struct archive_entry *entry, la_ssize_t *len,\n 1589      int flags)\n 1590  {\n ....\n 1593  \n 1594  char *\n 1595: _archive_entry_acl_to_text_l(struct archive_entry *entry, ssize_t *len,\n 1596:    int flags, struct archive_string_conv *sc)\n 1597  {\n 1598  \treturn (archive_acl_to_text_l(&entry->acl, len, flags, sc));\n ....\n 1603   */\n 1604  int\n 1605: archive_entry_acl_from_text_w(struct archive_entry *entry,\n 1606      const wchar_t *wtext, int type)\n 1607  {\n ....\n 1610  \n 1611  int\n 1612: archive_entry_acl_from_text(struct archive_entry *entry,\n 1613      const char *text, int type)\n 1614  {\n ....\n 1617  \n 1618  int\n 1619: _archive_entry_acl_from_text_l(struct archive_entry *entry, const char *text,\n 1620:     int type, struct archive_string_conv *sc)\n 1621  {\n 1622  \treturn (archive_acl_from_text_l(&entry->acl, text, type, sc));\n ....\n 1645  /* Deprecated */\n 1646  const wchar_t *\n 1647: archive_entry_acl_text_w(struct archive_entry *entry, int flags)\n 1648  {\n 1649  \tfree(entry->acl.acl_text_w);\n ....\n 1657  /* Deprecated */\n 1658  const char *\n 1659: archive_entry_acl_text(struct archive_entry *entry, int flags)\n 1660  {\n 1661  \tfree(entry->acl.acl_text);\n ....\n 1670  /* Deprecated */\n 1671  int\n 1672: _archive_entry_acl_text_l(struct archive_entry *entry, int flags,\n 1673:     const char **acl_text, size_t *len, struct archive_string_conv *sc)\n 1674  {\n 1675  \tfree(entry->acl.acl_text);\n ....\n 1764   */\n 1765  \n 1766: static const struct flag {\n 1767  \tconst char\t*name;\n 1768  \tconst wchar_t\t*wname;\n ....\n 1941  \tconst char *sp;\n 1942  \tunsigned long bits;\n 1943: \tconst struct flag *flag;\n 1944  \tsize_t\tlength;\n 1945  \n ....\n 1993  {\n 1994  \tconst char *start, *end;\n 1995: \tconst struct flag *flag;\n 1996  \tunsigned long set, clear;\n 1997  \tconst char *failed;\n ....\n 2061  {\n 2062  \tconst wchar_t *start, *end;\n 2063: \tconst struct flag *flag;\n 2064  \tunsigned long set, clear;\n 2065  \tconst wchar_t *failed;\n ....\n 2121  main(int argc, char **argv)\n 2122  {\n 2123: \tstruct archive_entry *entry = archive_entry_new();\n 2124  \tunsigned long set, clear;\n 2125  \tconst wchar_t *remainder;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter_b64encode.c:\n   45  #define LBYTES\t57\n   46  \n   47: struct private_b64encode {\n   48  \tint\t\t\tmode;\n   49: \tstruct archive_string\tname;\n   50: \tstruct archive_string\tencoded_buff;\n   51  \tsize_t\t\t\tbs;\n   52  \tsize_t\t\t\thold_len;\n   ..\n   54  };\n   55  \n   56: static int archive_filter_b64encode_options(struct archive_write_filter *,\n   57      const char *, const char *);\n   58: static int archive_filter_b64encode_open(struct archive_write_filter *);\n   59: static int archive_filter_b64encode_write(struct archive_write_filter *,\n   60      const void *, size_t);\n   61: static int archive_filter_b64encode_close(struct archive_write_filter *);\n   62: static int archive_filter_b64encode_free(struct archive_write_filter *);\n   63: static void la_b64_encode(struct archive_string *, const unsigned char *, size_t);\n   64  static int64_t atol8(const char *, size_t);\n   65  \n   ..\n   79   */\n   80  int\n   81: archive_write_add_filter_b64encode(struct archive *_a)\n   82  {\n   83: \tstruct archive_write *a = (struct archive_write *)_a;\n   84: \tstruct archive_write_filter *f = __archive_write_allocate_filter(_a);\n   85: \tstruct private_b64encode *state;\n   86  \n   87  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n   88  \t    ARCHIVE_STATE_NEW, \"archive_write_add_filter_uu\");\n   89  \n   90: \tstate = (struct private_b64encode *)calloc(1, sizeof(*state));\n   91  \tif (state == NULL) {\n   92  \t\tarchive_set_error(f->archive, ENOMEM,\n   ..\n  113   */\n  114  static int\n  115: archive_filter_b64encode_options(struct archive_write_filter *f, const char *key,\n  116      const char *value)\n  117  {\n  118: \tstruct private_b64encode *state = (struct private_b64encode *)f->data;\n  119  \n  120  \tif (strcmp(key, \"mode\") == 0) {\n  ...\n  146   */\n  147  static int\n  148: archive_filter_b64encode_open(struct archive_write_filter *f)\n  149  {\n  150: \tstruct private_b64encode *state = (struct private_b64encode *)f->data;\n  151  \tsize_t bs = 65536, bpb;\n  152  \n  ...\n  176  \n  177  static void\n  178: la_b64_encode(struct archive_string *as, const unsigned char *p, size_t len)\n  179  {\n  180  \tint c;\n  ...\n  213   */\n  214  static int\n  215: archive_filter_b64encode_write(struct archive_write_filter *f, const void *buff,\n  216      size_t length)\n  217  {\n  218: \tstruct private_b64encode *state = (struct private_b64encode *)f->data;\n  219  \tconst unsigned char *p = buff;\n  220  \tint ret = ARCHIVE_OK;\n  ...\n  259   */\n  260  static int\n  261: archive_filter_b64encode_close(struct archive_write_filter *f)\n  262  {\n  263: \tstruct private_b64encode *state = (struct private_b64encode *)f->data;\n  264  \n  265  \t/* Flush remaining bytes. */\n  ...\n  274  \n  275  static int\n  276: archive_filter_b64encode_free(struct archive_write_filter *f)\n  277  {\n  278: \tstruct private_b64encode *state = (struct private_b64encode *)f->data;\n  279  \n  280  \tarchive_string_free(&state->name);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_iso9660.c:\n  123   * Manage extra records.\n  124   */\n  125: struct extr_rec {\n  126  \tint\t\t location;\n  127  \tint\t\t offset;\n  128  \tunsigned char\t buf[LOGICAL_BLOCK_SIZE];\n  129: \tstruct extr_rec\t*next;\n  130  };\n  131  \n  132: struct ctl_extr_rec {\n  133  \tint\t\t use_extr;\n  134  \tunsigned char\t*bp;\n  135: \tstruct isoent\t*isoent;\n  136  \tunsigned char\t*ce_ptr;\n  137  \tint\t\t cur_len;\n  ...\n  145  \n  146  /*\n  147:  * The relation of struct isofile and isoent and archive_entry.\n  148   *\n  149:  * Primary volume tree  --> struct isoent\n  150   *                                |\n  151   *                                v\n  152:  *                          struct isofile --> archive_entry\n  153   *                                ^\n  154   *                                |\n  155:  * Joliet volume tree   --> struct isoent\n  156   *\n  157:  * struct isoent has specific information for volume.\n  158   */\n  159  \n  160: struct isofile {\n  161: \t/* Used for managing struct isofile list. */\n  162: \tstruct isofile\t\t*allnext;\n  163: \tstruct isofile\t\t*datanext;\n  164: \t/* Used for managing a hardlinked struct isofile list. */\n  165: \tstruct isofile\t\t*hlnext;\n  166: \tstruct isofile\t\t*hardlink_target;\n  167  \n  168: \tstruct archive_entry\t*entry;\n  169  \n  170  \t/*\n  171  \t * Used for making a directory tree.\n  172  \t */\n  173: \tstruct archive_string\t parentdir;\n  174: \tstruct archive_string\t basename;\n  175: \tstruct archive_string\t basename_utf16;\n  176: \tstruct archive_string\t symlink;\n  177  \tint\t\t\t dircnt;\t/* The number of elements of\n  178  \t\t\t\t\t\t * its parent directory */\n  ...\n  181  \t * Used for a Directory Record.\n  182  \t */\n  183: \tstruct content {\n  184  \t\tint64_t\t\t offset_of_temp;\n  185  \t\tint64_t\t\t size;\n  ...\n  191  \t\t * next content data.\n  192  \t\t */\n  193: \t\tstruct content\t*next;\t\t/* next content\t*/\n  194  \t} content, *cur_content;\n  195  \tint\t\t\t write_content;\n  ...\n  204  \t * Used for a zisofs.\n  205  \t */\n  206: \tstruct {\n  207  \t\tunsigned char\t header_size;\n  208  \t\tunsigned char\t log2_bs;\n  ...\n  211  };\n  212  \n  213: struct isoent {\n  214: \t/* Keep `rbnode' at the first member of struct isoent. */\n  215: \tstruct archive_rb_node\t rbnode;\n  216  \n  217: \tstruct isofile\t\t*file;\n  218  \n  219: \tstruct isoent\t\t*parent;\n  220  \t/* A list of children.(use chnext) */\n  221: \tstruct {\n  222: \t\tstruct isoent\t*first;\n  223: \t\tstruct isoent\t**last;\n  224  \t\tint\t\t cnt;\n  225  \t}\t\t\t children;\n  226: \tstruct archive_rb_tree\t rbtree;\n  227  \n  228  \t/* A list of sub directories.(use drnext) */\n  229: \tstruct {\n  230: \t\tstruct isoent\t*first;\n  231: \t\tstruct isoent\t**last;\n  232  \t\tint\t\t cnt;\n  233  \t}\t\t\t subdirs;\n  234  \t/* A sorted list of sub directories. */\n  235: \tstruct isoent\t\t**children_sorted;\n  236: \t/* Used for managing struct isoent list. */\n  237: \tstruct isoent\t\t*chnext;\n  238: \tstruct isoent\t\t*drnext;\n  239: \tstruct isoent\t\t*ptnext;\n  240  \n  241  \t/*\n  ...\n  243  \t */\n  244  \tint\t\t\t dir_number;\n  245: \tstruct {\n  246  \t\tint\t\t vd;\n  247  \t\tint\t\t self;\n  ...\n  275  \t * This is a part of Directory Records.\n  276  \t */\n  277: \tstruct isoent\t\t*rr_parent;\n  278: \tstruct isoent\t\t*rr_child;\n  279  \n  280  \t/* Extra Record.(which we call in this source file)\n  ...\n  284  \t * Extra Record.\n  285  \t */\n  286: \tstruct {\n  287: \t\tstruct extr_rec\t*first;\n  288: \t\tstruct extr_rec\t**last;\n  289: \t\tstruct extr_rec\t*current;\n  290  \t}\t\t\t extr_rec_list;\n  291  \n  ...\n  298  };\n  299  \n  300: struct hardlink {\n  301: \tstruct archive_rb_node\t rbnode;\n  302  \tint\t\t\t nlink;\n  303: \tstruct {\n  304: \t\tstruct isofile\t*first;\n  305: \t\tstruct isofile\t**last;\n  306  \t}\t\t\t file_list;\n  307  };\n  ...\n  310   * ISO writer options\n  311   */\n  312: struct iso_option {\n  313  \t/*\n  314  \t * Usage  : abstract-file=<value>\n  ...\n  677  };\n  678  \n  679: struct iso9660 {\n  680  \t/* The creation time of ISO image. */\n  681  \ttime_t\t\t\t birth_time;\n  ...\n  684  \tint\t\t\t temp_fd;\n  685  \n  686: \tstruct isofile\t\t*cur_file;\n  687: \tstruct isoent\t\t*cur_dirent;\n  688: \tstruct archive_string\t cur_dirstr;\n  689  \tuint64_t\t\t bytes_remaining;\n  690  \tint\t\t\t need_multi_extent;\n  691  \n  692  \t/* Temporary string buffer for Joliet extension. */ \n  693: \tstruct archive_string\t utf16be;\n  694: \tstruct archive_string\t mbs;\n  695  \n  696: \tstruct archive_string_conv *sconv_to_utf16be;\n  697: \tstruct archive_string_conv *sconv_from_utf16be;\n  698  \n  699: \t/* A list of all of struct isofile entries. */\n  700: \tstruct {\n  701: \t\tstruct isofile\t*first;\n  702: \t\tstruct isofile\t**last;\n  703  \t}\t\t\t all_file_list;\n  704  \n  705: \t/* A list of struct isofile entries which have its\n  706  \t * contents and are not a directory, a hardlinked file\n  707  \t * and a symlink file. */\n  708: \tstruct {\n  709: \t\tstruct isofile\t*first;\n  710: \t\tstruct isofile\t**last;\n  711  \t}\t\t\t data_file_list;\n  712  \n  713  \t/* Used for managing to find hardlinking files. */\n  714: \tstruct archive_rb_tree\t hardlink_rbtree;\n  715  \n  716  \t/* Used for making the Path Table Record. */\n  717: \tstruct vdd {\n  718  \t\t/* the root of entry tree. */\n  719: \t\tstruct isoent\t*rootent;\n  720  \t\tenum vdd_type {\n  721  \t\t\tVDD_PRIMARY,\n  ...\n  724  \t\t} vdd_type;\n  725  \n  726: \t\tstruct path_table {\n  727: \t\t\tstruct isoent\t\t*first;\n  728: \t\t\tstruct isoent\t\t**last;\n  729: \t\t\tstruct isoent\t\t**sorted;\n  730  \t\t\tint\t\t\t cnt;\n  731  \t\t} *pathtbl;\n  ...\n  743  \tint\t\t\t volume_sequence_number;\n  744  \tint\t\t\t total_file_block;\n  745: \tstruct archive_string\t volume_identifier;\n  746: \tstruct archive_string\t publisher_identifier;\n  747: \tstruct archive_string\t data_preparer_identifier;\n  748: \tstruct archive_string\t application_identifier;\n  749: \tstruct archive_string\t copyright_file_identifier;\n  750: \tstruct archive_string\t abstract_file_identifier;\n  751: \tstruct archive_string\t bibliographic_file_identifier;\n  752  \n  753  \t/* Used for making rockridge extensions. */\n  ...\n  755  \n  756  \t/* Used for making zisofs. */\n  757: \tstruct {\n  758  \t\tsigned int\t detect_magic:1;\n  759  \t\tsigned int\t making:1;\n  ...\n  787  \t} zisofs;\n  788  \n  789: \tstruct isoent\t\t*directories_too_deep;\n  790  \tint\t\t\t dircnt_max;\n  791  \n  792  \t/* Write buffer. */\n  793  #define wb_buffmax()\t(LOGICAL_BLOCK_SIZE * 32)\n  794: #define wb_remaining(a)\t(((struct iso9660 *)(a)->format_data)->wbuff_remaining)\n  795: #define wb_offset(a)\t(((struct iso9660 *)(a)->format_data)->wbuff_offset \\\n  796  \t\t+ wb_buffmax() - wb_remaining(a))\n  797  \tunsigned char\t\t wbuff[LOGICAL_BLOCK_SIZE * 32];\n  ...\n  806  \n  807  \t/* 'El Torito' boot data. */\n  808: \tstruct {\n  809  \t\t/* boot catalog file */\n  810: \t\tstruct archive_string\t catalog_filename;\n  811: \t\tstruct isoent\t\t*catalog;\n  812  \t\t/* boot image file */\n  813: \t\tstruct archive_string\t boot_filename;\n  814: \t\tstruct isoent\t\t*boot;\n  815  \n  816  \t\tunsigned char\t\t platform_id;\n  ...\n  818  #define BOOT_PLATFORM_PPC\t1\n  819  #define BOOT_PLATFORM_MAC\t2\n  820: \t\tstruct archive_string\t id;\n  821  \t\tunsigned char\t\t media_type;\n  822  #define BOOT_MEDIA_NO_EMULATION\t\t0\n  ...\n  831  \t} el_torito;\n  832  \n  833: \tstruct iso_option\t opt;\n  834  };\n  835  \n  ...\n  868   * Used for resolving duplicated filenames.\n  869   */\n  870: struct idr {\n  871: \tstruct idrent {\n  872: \t\tstruct archive_rb_node\trbnode;\n  873  \t\t/* Used in wait_list. */\n  874: \t\tstruct idrent\t\t*wnext;\n  875: \t\tstruct idrent\t\t*avail;\n  876  \n  877: \t\tstruct isoent\t\t*isoent;\n  878  \t\tint\t\t\t weight;\n  879  \t\tint\t\t\t noff;\n  ...\n  881  \t} *idrent_pool;\n  882  \n  883: \tstruct archive_rb_tree\t\t rbtree;\n  884  \n  885: \tstruct {\n  886: \t\tstruct idrent\t\t*first;\n  887: \t\tstruct idrent\t\t**last;\n  888  \t} wait_list;\n  889  \n  ...\n  902  \n  903  \n  904: static int\tiso9660_options(struct archive_write *,\n  905  \t\t    const char *, const char *);\n  906: static int\tiso9660_write_header(struct archive_write *,\n  907: \t\t    struct archive_entry *);\n  908: static ssize_t\tiso9660_write_data(struct archive_write *,\n  909  \t\t    const void *, size_t);\n  910: static int\tiso9660_finish_entry(struct archive_write *);\n  911: static int\tiso9660_close(struct archive_write *);\n  912: static int\tiso9660_free(struct archive_write *);\n  913  \n  914  static void\tget_system_identitier(char *, size_t);\n  ...\n  916  \t\t    const char *);\n  917  static inline int joliet_allowed_char(unsigned char, unsigned char);\n  918: static int\tset_str_utf16be(struct archive_write *, unsigned char *,\n  919  \t\t\tconst char *, size_t, uint16_t, enum vdc);\n  920: static int\tset_str_a_characters_bp(struct archive_write *,\n  921  \t\t\tunsigned char *, int, int, const char *, enum vdc);\n  922: static int\tset_str_d_characters_bp(struct archive_write *,\n  923  \t\t\tunsigned char *, int, int, const char *, enum  vdc);\n  924  static void\tset_VD_bp(unsigned char *, enum VD_type, unsigned char);\n  ...\n  926  \n  927  static unsigned char *extra_open_record(unsigned char *, int,\n  928: \t\t    struct isoent *, struct ctl_extr_rec *);\n  929: static void\textra_close_record(struct ctl_extr_rec *, int);\n  930: static unsigned char * extra_next_record(struct ctl_extr_rec *, int);\n  931: static unsigned char *extra_get_record(struct isoent *, int *, int *, int *);\n  932: static void\textra_tell_used_size(struct ctl_extr_rec *, int);\n  933: static int\textra_setup_location(struct isoent *, int);\n  934  static int\tset_directory_record_rr(unsigned char *, int,\n  935: \t\t    struct isoent *, struct iso9660 *, enum dir_rec_type);\n  936  static int\tset_directory_record(unsigned char *, size_t,\n  937: \t\t    struct isoent *, struct iso9660 *, enum dir_rec_type,\n  938  \t\t    enum vdd_type);\n  939: static inline int get_dir_rec_size(struct iso9660 *, struct isoent *,\n  940  \t\t    enum dir_rec_type, enum vdd_type);\n  941: static inline unsigned char *wb_buffptr(struct archive_write *);\n  942: static int\twb_write_out(struct archive_write *);\n  943: static int\twb_consume(struct archive_write *, size_t);\n  944  #ifdef HAVE_ZLIB_H\n  945: static int\twb_set_offset(struct archive_write *, int64_t);\n  946  #endif\n  947: static int\twrite_null(struct archive_write *, size_t);\n  948: static int\twrite_VD_terminator(struct archive_write *);\n  949  static int\tset_file_identifier(unsigned char *, int, int, enum vdc,\n  950: \t\t    struct archive_write *, struct vdd *,\n  951: \t\t    struct archive_string *, const char *, int,\n  952  \t\t    enum char_type);\n  953: static int\twrite_VD(struct archive_write *, struct vdd *);\n  954: static int\twrite_VD_boot_record(struct archive_write *);\n  955: static int\twrite_information_block(struct archive_write *);\n  956: static int\twrite_path_table(struct archive_write *, int,\n  957: \t\t    struct vdd *);\n  958: static int\twrite_directory_descriptors(struct archive_write *,\n  959: \t\t    struct vdd *);\n  960: static int\twrite_file_descriptors(struct archive_write *);\n  961: static int\twrite_rr_ER(struct archive_write *);\n  962: static void\tcalculate_path_table_size(struct vdd *);\n  963  \n  964: static void\tisofile_init_entry_list(struct iso9660 *);\n  965: static void\tisofile_add_entry(struct iso9660 *, struct isofile *);\n  966: static void\tisofile_free_all_entries(struct iso9660 *);\n  967: static void\tisofile_init_entry_data_file_list(struct iso9660 *);\n  968: static void\tisofile_add_data_file(struct iso9660 *, struct isofile *);\n  969: static struct isofile * isofile_new(struct archive_write *,\n  970: \t\t    struct archive_entry *);\n  971: static void\tisofile_free(struct isofile *);\n  972: static int\tisofile_gen_utility_names(struct archive_write *,\n  973: \t\t    struct isofile *);\n  974: static int\tisofile_register_hardlink(struct archive_write *,\n  975: \t\t    struct isofile *);\n  976: static void\tisofile_connect_hardlink_files(struct iso9660 *);\n  977: static void\tisofile_init_hardlinks(struct iso9660 *);\n  978: static void\tisofile_free_hardlinks(struct iso9660 *);\n  979  \n  980: static struct isoent *isoent_new(struct isofile *);\n  981: static int\tisoent_clone_tree(struct archive_write *,\n  982: \t\t    struct isoent **, struct isoent *);\n  983: static void\t_isoent_free(struct isoent *isoent);\n  984: static void\tisoent_free_all(struct isoent *);\n  985: static struct isoent * isoent_create_virtual_dir(struct archive_write *,\n  986: \t\t    struct iso9660 *, const char *);\n  987: static int\tisoent_cmp_node(const struct archive_rb_node *,\n  988: \t\t    const struct archive_rb_node *);\n  989: static int\tisoent_cmp_key(const struct archive_rb_node *,\n  990  \t\t    const void *);\n  991: static int\tisoent_add_child_head(struct isoent *, struct isoent *);\n  992: static int\tisoent_add_child_tail(struct isoent *, struct isoent *);\n  993: static void\tisoent_remove_child(struct isoent *, struct isoent *);\n  994: static void\tisoent_setup_directory_location(struct iso9660 *,\n  995: \t\t    int, struct vdd *);\n  996: static void\tisoent_setup_file_location(struct iso9660 *, int);\n  997  static int\tget_path_component(char *, size_t, const char *);\n  998: static int\tisoent_tree(struct archive_write *, struct isoent **);\n  999: static struct isoent *isoent_find_child(struct isoent *, const char *);\n 1000: static struct isoent *isoent_find_entry(struct isoent *, const char *);\n 1001  static void\tidr_relaxed_filenames(char *);\n 1002: static void\tidr_init(struct iso9660 *, struct vdd *, struct idr *);\n 1003: static void\tidr_cleanup(struct idr *);\n 1004: static int\tidr_ensure_poolsize(struct archive_write *, struct idr *,\n 1005  \t\t    int);\n 1006: static int\tidr_start(struct archive_write *, struct idr *,\n 1007: \t\t    int, int, int, int, const struct archive_rb_tree_ops *);\n 1008: static void\tidr_register(struct idr *, struct isoent *, int,\n 1009  \t\t    int);\n 1010: static void\tidr_extend_identifier(struct idrent *, int, int);\n 1011: static void\tidr_resolve(struct idr *, void (*)(unsigned char *, int));\n 1012  static void\tidr_set_num(unsigned char *, int);\n 1013  static void\tidr_set_num_beutf16(unsigned char *, int);\n 1014: static int\tisoent_gen_iso9660_identifier(struct archive_write *,\n 1015: \t\t    struct isoent *, struct idr *);\n 1016: static int\tisoent_gen_joliet_identifier(struct archive_write *,\n 1017: \t\t    struct isoent *, struct idr *);\n 1018: static int\tisoent_cmp_iso9660_identifier(const struct isoent *,\n 1019: \t\t    const struct isoent *);\n 1020: static int\tisoent_cmp_node_iso9660(const struct archive_rb_node *,\n 1021: \t\t    const struct archive_rb_node *);\n 1022: static int\tisoent_cmp_key_iso9660(const struct archive_rb_node *,\n 1023  \t\t    const void *);\n 1024: static int\tisoent_cmp_joliet_identifier(const struct isoent *,\n 1025: \t\t    const struct isoent *);\n 1026: static int\tisoent_cmp_node_joliet(const struct archive_rb_node *,\n 1027: \t\t    const struct archive_rb_node *);\n 1028: static int\tisoent_cmp_key_joliet(const struct archive_rb_node *,\n 1029  \t\t    const void *);\n 1030: static inline void path_table_add_entry(struct path_table *, struct isoent *);\n 1031: static inline struct isoent * path_table_last_entry(struct path_table *);\n 1032: static int\tisoent_make_path_table(struct archive_write *);\n 1033: static int\tisoent_find_out_boot_file(struct archive_write *,\n 1034: \t\t    struct isoent *);\n 1035: static int\tisoent_create_boot_catalog(struct archive_write *,\n 1036: \t\t    struct isoent *);\n 1037  static size_t\tfd_boot_image_size(int);\n 1038: static int\tmake_boot_catalog(struct archive_write *);\n 1039: static int\tsetup_boot_information(struct archive_write *);\n 1040  \n 1041: static int\tzisofs_init(struct archive_write *, struct isofile *);\n 1042: static void\tzisofs_detect_magic(struct archive_write *,\n 1043  \t\t    const void *, size_t);\n 1044: static int\tzisofs_write_to_temp(struct archive_write *,\n 1045  \t\t    const void *, size_t);\n 1046: static int\tzisofs_finish_entry(struct archive_write *);\n 1047: static int\tzisofs_rewind_boot_file(struct archive_write *);\n 1048: static int\tzisofs_free(struct archive_write *);\n 1049  \n 1050  int\n 1051: archive_write_set_format_iso9660(struct archive *_a)\n 1052  {\n 1053: \tstruct archive_write *a = (struct archive_write *)_a;\n 1054: \tstruct iso9660 *iso9660;\n 1055  \n 1056  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n ....\n 1188  \n 1189  static int\n 1190: get_str_opt(struct archive_write *a, struct archive_string *s,\n 1191      size_t maxsize, const char *key, const char *value)\n 1192  {\n ....\n 1203  \n 1204  static int\n 1205: get_num_opt(struct archive_write *a, int *num, int high, int low,\n 1206      const char *key, const char *value)\n 1207  {\n ....\n 1249  \n 1250  static int\n 1251: iso9660_options(struct archive_write *a, const char *key, const char *value)\n 1252  {\n 1253: \tstruct iso9660 *iso9660 = a->format_data;\n 1254  \tconst char *p;\n 1255  \tint r;\n ....\n 1394  \t\t */\n 1395  \t\tif (strcmp(key, \"creation\") == 0) {\n 1396: \t\t\tstruct tm tm;\n 1397  \t\t\tchar buf[5];\n 1398  \n ....\n 1520  \n 1521  static int\n 1522: iso9660_write_header(struct archive_write *a, struct archive_entry *entry)\n 1523  {\n 1524: \tstruct iso9660 *iso9660;\n 1525: \tstruct isofile *file;\n 1526: \tstruct isoent *isoent;\n 1527  \tint r, ret = ARCHIVE_OK;\n 1528  \n ....\n 1638  \n 1639  static int\n 1640: write_to_temp(struct archive_write *a, const void *buff, size_t s)\n 1641  {\n 1642: \tstruct iso9660 *iso9660 = a->format_data;\n 1643  \tssize_t written;\n 1644  \tconst unsigned char *b;\n ....\n 1659  \n 1660  static int\n 1661: wb_write_to_temp(struct archive_write *a, const void *buff, size_t s)\n 1662  {\n 1663  \tconst char *xp = buff;\n ....\n 1670  \t */\n 1671  \tif (wb_remaining(a) == wb_buffmax() && s > (1024 * 16)) {\n 1672: \t\tstruct iso9660 *iso9660 = (struct iso9660 *)a->format_data;\n 1673  \t\txs = s % LOGICAL_BLOCK_SIZE;\n 1674  \t\tiso9660->wbuff_offset += s - xs;\n ....\n 1694  \n 1695  static int\n 1696: wb_write_padding_to_temp(struct archive_write *a, int64_t csize)\n 1697  {\n 1698  \tsize_t ns;\n ....\n 1708  \n 1709  static ssize_t\n 1710: write_iso9660_data(struct archive_write *a, const void *buff, size_t s)\n 1711  {\n 1712: \tstruct iso9660 *iso9660 = a->format_data;\n 1713  \tsize_t ws;\n 1714  \n ....\n 1723  \t    (iso9660->cur_file->cur_content->size + ws) >=\n 1724  \t      (MULTI_EXTENT_SIZE - LOGICAL_BLOCK_SIZE)) {\n 1725: \t\tstruct content *con;\n 1726  \t\tsize_t ts;\n 1727  \n ....\n 1787  \n 1788  static ssize_t\n 1789: iso9660_write_data(struct archive_write *a, const void *buff, size_t s)\n 1790  {\n 1791: \tstruct iso9660 *iso9660 = a->format_data;\n 1792  \tssize_t r;\n 1793  \n ....\n 1808  \n 1809  static int\n 1810: iso9660_finish_entry(struct archive_write *a)\n 1811  {\n 1812: \tstruct iso9660 *iso9660 = a->format_data;\n 1813  \n 1814  \tif (iso9660->cur_file == NULL)\n ....\n 1850  \n 1851  static int\n 1852: iso9660_close(struct archive_write *a)\n 1853  {\n 1854: \tstruct iso9660 *iso9660;\n 1855  \tint ret, blocks;\n 1856  \n ....\n 2112  \n 2113  static int\n 2114: iso9660_free(struct archive_write *a)\n 2115  {\n 2116: \tstruct iso9660 *iso9660;\n 2117  \tint i, ret;\n 2118  \n ....\n 2170  {\n 2171  #if defined(HAVE_SYS_UTSNAME_H)\n 2172: \tstruct utsname u;\n 2173  \n 2174  \tuname(&u);\n ....\n 2231  \n 2232  static int\n 2233: set_str_utf16be(struct archive_write *a, unsigned char *p, const char *s,\n 2234      size_t l, uint16_t uf, enum vdc vdc)\n 2235  {\n ....\n 2245  \t\tonepad = 0;\n 2246  \tif (vdc == VDC_UCS2) {\n 2247: \t\tstruct iso9660 *iso9660 = a->format_data;\n 2248  \t\tif (archive_strncpy_l(&iso9660->utf16be, s, strlen(s),\n 2249  \t\t    iso9660->sconv_to_utf16be) != 0 && errno == ENOMEM) {\n ....\n 2330  \n 2331  static int\n 2332: set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,\n 2333      int from, int to, const char *s, enum vdc vdc)\n 2334  {\n ....\n 2358  \n 2359  static int\n 2360: set_str_d_characters_bp(struct archive_write *a, unsigned char *bp,\n 2361      int from, int to, const char *s, enum  vdc vdc)\n 2362  {\n ....\n 2501  #else\n 2502  static long\n 2503: get_gmoffset(struct tm *tm)\n 2504  {\n 2505  \tlong offset;\n ....\n 2520  \n 2521  static void\n 2522: get_tmfromtime(struct tm *tm, time_t *t)\n 2523  {\n 2524  #if HAVE_LOCALTIME_R\n ....\n 2540  set_date_time(unsigned char *p, time_t t)\n 2541  {\n 2542: \tstruct tm tm;\n 2543  \n 2544  \tget_tmfromtime(&tm, &t);\n ....\n 2563  set_time_915(unsigned char *p, time_t t)\n 2564  {\n 2565: \tstruct tm tm;\n 2566  \n 2567  \tget_tmfromtime(&tm, &t);\n ....\n 2617   */\n 2618  static unsigned char *\n 2619: extra_open_record(unsigned char *bp, int dr_len, struct isoent *isoent,\n 2620:     struct ctl_extr_rec *ctl)\n 2621  {\n 2622  \tctl->bp = bp;\n ....\n 2633  \n 2634  static void\n 2635: extra_close_record(struct ctl_extr_rec *ctl, int ce_size)\n 2636  {\n 2637  \tint padding = 0;\n ....\n 2657  \n 2658  static unsigned char *\n 2659: extra_next_record(struct ctl_extr_rec *ctl, int length)\n 2660  {\n 2661  \tint cur_len = ctl->cur_len;/* save cur_len */\n ....\n 2689  }\n 2690  \n 2691: static inline struct extr_rec *\n 2692: extra_last_record(struct isoent *isoent)\n 2693  {\n 2694  \tif (isoent->extr_rec_list.first == NULL)\n 2695  \t\treturn (NULL);\n 2696: \treturn ((struct extr_rec *)(void *)\n 2697  \t\t((char *)(isoent->extr_rec_list.last)\n 2698: \t\t    - offsetof(struct extr_rec, next)));\n 2699  }\n 2700  \n 2701  static unsigned char *\n 2702: extra_get_record(struct isoent *isoent, int *space, int *off, int *loc)\n 2703  {\n 2704: \tstruct extr_rec *rec;\n 2705  \n 2706  \tisoent = isoent->parent;\n ....\n 2749  \n 2750  static void\n 2751: extra_tell_used_size(struct ctl_extr_rec *ctl, int size)\n 2752  {\n 2753: \tstruct isoent *isoent;\n 2754: \tstruct extr_rec *rec;\n 2755  \n 2756  \tif (ctl->use_extr) {\n ....\n 2764  \n 2765  static int\n 2766: extra_setup_location(struct isoent *isoent, int location)\n 2767  {\n 2768: \tstruct extr_rec *rec;\n 2769  \tint cnt;\n 2770  \n ....\n 2786  static int\n 2787  set_directory_record_rr(unsigned char *bp, int dr_len,\n 2788:     struct isoent *isoent, struct iso9660 *iso9660, enum dir_rec_type t)\n 2789  {\n 2790  \t/* Flags(BP 5) of the Rockridge \"RR\" System Use Field */\n ....\n 2799  #define RR_USE_TF\t0x80\n 2800  \tint length;\n 2801: \tstruct ctl_extr_rec ctl;\n 2802: \tstruct isoent *rr_parent, *pxent;\n 2803: \tstruct isofile *file;\n 2804  \n 2805  \tbp = extra_open_record(bp, dr_len, isoent, &ctl);\n ....\n 3436   */\n 3437  static int\n 3438: set_directory_record(unsigned char *p, size_t n, struct isoent *isoent,\n 3439:     struct iso9660 *iso9660, enum dir_rec_type t,\n 3440      enum vdd_type vdd_type)\n 3441  {\n ....\n 3471  \n 3472  \tif (p != NULL) {\n 3473: \t\tstruct isoent *xisoent;\n 3474: \t\tstruct isofile *file;\n 3475  \t\tunsigned char flag;\n 3476  \n ....\n 3596   */\n 3597  static inline int\n 3598: get_dir_rec_size(struct iso9660 *iso9660, struct isoent *isoent,\n 3599      enum dir_rec_type t, enum vdd_type vdd_type)\n 3600  {\n ....\n 3611  \n 3612  static inline unsigned char *\n 3613: wb_buffptr(struct archive_write *a)\n 3614  {\n 3615: \tstruct iso9660 *iso9660 = (struct iso9660 *)a->format_data;\n 3616  \n 3617  \treturn (&(iso9660->wbuff[sizeof(iso9660->wbuff)\n ....\n 3620  \n 3621  static int\n 3622: wb_write_out(struct archive_write *a)\n 3623  {\n 3624: \tstruct iso9660 *iso9660 = (struct iso9660 *)a->format_data;\n 3625  \tsize_t wsize, nw;\n 3626  \tint r;\n ....\n 3645  \n 3646  static int\n 3647: wb_consume(struct archive_write *a, size_t size)\n 3648  {\n 3649: \tstruct iso9660 *iso9660 = (struct iso9660 *)a->format_data;\n 3650  \n 3651  \tif (size > iso9660->wbuff_remaining ||\n ....\n 3666  \n 3667  static int\n 3668: wb_set_offset(struct archive_write *a, int64_t off)\n 3669  {\n 3670: \tstruct iso9660 *iso9660 = (struct iso9660 *)a->format_data;\n 3671  \tint64_t used, ext_bytes;\n 3672  \n ....\n 3724  \n 3725  static int\n 3726: write_null(struct archive_write *a, size_t size)\n 3727  {\n 3728  \tsize_t remaining;\n ....\n 3762   */\n 3763  static int\n 3764: write_VD_terminator(struct archive_write *a)\n 3765  {\n 3766  \tunsigned char *bp;\n ....\n 3775  static int\n 3776  set_file_identifier(unsigned char *bp, int from, int to, enum vdc vdc,\n 3777:     struct archive_write *a, struct vdd *vdd, struct archive_string *id,\n 3778      const char *label, int leading_under, enum char_type char_type)\n 3779  {\n 3780  \tchar identifier[256];\n 3781: \tstruct isoent *isoent;\n 3782  \tconst char *ids;\n 3783  \tsize_t len;\n ....\n 3833   */\n 3834  static int\n 3835: write_VD(struct archive_write *a, struct vdd *vdd)\n 3836  {\n 3837: \tstruct iso9660 *iso9660;\n 3838  \tunsigned char *bp;\n 3839  \tuint16_t volume_set_size = 1;\n ....\n 3980   */\n 3981  static int\n 3982: write_VD_boot_record(struct archive_write *a)\n 3983  {\n 3984: \tstruct iso9660 *iso9660;\n 3985  \tunsigned char *bp;\n 3986  \n ....\n 4010  };\n 4011  static void\n 4012: set_option_info(struct archive_string *info, int *opt, const char *key,\n 4013      enum keytype type,  ...)\n 4014  {\n ....\n 4051   */\n 4052  static int\n 4053: write_information_block(struct archive_write *a)\n 4054  {\n 4055: \tstruct iso9660 *iso9660;\n 4056  \tchar buf[128];\n 4057  \tconst char *v;\n 4058  \tint opt, r;\n 4059: \tstruct archive_string info;\n 4060  \tsize_t info_size = LOGICAL_BLOCK_SIZE *\n 4061  \t\t\t       NON_ISO_FILE_SYSTEM_INFORMATION_BLOCK;\n 4062  \n 4063: \tiso9660 = (struct iso9660 *)a->format_data;\n 4064  \tif (info_size > wb_remaining(a)) {\n 4065  \t\tr = wb_write_out(a);\n ....\n 4179  \n 4180  static int\n 4181: write_rr_ER(struct archive_write *a)\n 4182  {\n 4183  \tunsigned char *p;\n ....\n 4202  \n 4203  static void\n 4204: calculate_path_table_size(struct vdd *vdd)\n 4205  {\n 4206  \tint depth, size;\n 4207: \tstruct path_table *pt;\n 4208  \n 4209  \tpt = vdd->pathtbl;\n 4210  \tsize = 0;\n 4211  \tfor (depth = 0; depth < vdd->max_depth; depth++) {\n 4212: \t\tstruct isoent **ptbl;\n 4213  \t\tint i, cnt;\n 4214  \n ....\n 4237  \n 4238  static int\n 4239: _write_path_table(struct archive_write *a, int type_m, int depth,\n 4240:     struct vdd *vdd)\n 4241  {\n 4242  \tunsigned char *bp, *wb;\n 4243: \tstruct isoent **ptbl;\n 4244  \tsize_t wbremaining;\n 4245  \tint i, r, wsize;\n ....\n 4254  \tptbl = vdd->pathtbl[depth].sorted;\n 4255  \tfor (i = 0; i < vdd->pathtbl[depth].cnt; i++) {\n 4256: \t\tstruct isoent *np;\n 4257  \t\tsize_t len;\n 4258  \n ....\n 4306  \n 4307  static int\n 4308: write_path_table(struct archive_write *a, int type_m, struct vdd *vdd)\n 4309  {\n 4310  \tint depth, r;\n ....\n 4328  \n 4329  static int\n 4330: calculate_directory_descriptors(struct iso9660 *iso9660, struct vdd *vdd,\n 4331:     struct isoent *isoent, int depth)\n 4332  {\n 4333: \tstruct isoent **enttbl;\n 4334  \tint bs, block, i;\n 4335  \n ....\n 4344  \tenttbl = isoent->children_sorted;\n 4345  \tfor (i = 0; i < isoent->children.cnt; i++) {\n 4346: \t\tstruct isoent *np = enttbl[i];\n 4347: \t\tstruct isofile *file;\n 4348  \n 4349  \t\tfile = np->file;\n ....\n 4368  \n 4369  static int\n 4370: _write_directory_descriptors(struct archive_write *a, struct vdd *vdd,\n 4371:     struct isoent *isoent, int depth)\n 4372  {\n 4373: \tstruct iso9660 *iso9660 = a->format_data;\n 4374: \tstruct isoent **enttbl;\n 4375  \tunsigned char *p, *wb;\n 4376  \tint i, r;\n ....\n 4392  \tenttbl = isoent->children_sorted;\n 4393  \tfor (i = 0; i < isoent->children.cnt; i++) {\n 4394: \t\tstruct isoent *np = enttbl[i];\n 4395: \t\tstruct isofile *file = np->file;\n 4396  \n 4397  \t\tif (file->hardlink_target != NULL)\n ....\n 4421  \n 4422  static int\n 4423: write_directory_descriptors(struct archive_write *a, struct vdd *vdd)\n 4424  {\n 4425: \tstruct isoent *np;\n 4426  \tint depth, r;\n 4427  \n ....\n 4429  \tnp = vdd->rootent;\n 4430  \tdo {\n 4431: \t\tstruct extr_rec *extr;\n 4432  \n 4433  \t\tr = _write_directory_descriptors(a, vdd, np, depth);\n ....\n 4479   */\n 4480  static int\n 4481: write_file_contents(struct archive_write *a, int64_t offset, int64_t size)\n 4482  {\n 4483: \tstruct iso9660 *iso9660 = a->format_data;\n 4484  \tint r;\n 4485  \n ....\n 4510  \n 4511  static int\n 4512: write_file_descriptors(struct archive_write *a)\n 4513  {\n 4514: \tstruct iso9660 *iso9660 = a->format_data;\n 4515: \tstruct isofile *file;\n 4516  \tint64_t blocks, offset;\n 4517  \tint r;\n ....\n 4581  \n 4582  static void\n 4583: isofile_init_entry_list(struct iso9660 *iso9660)\n 4584  {\n 4585  \tiso9660->all_file_list.first = NULL;\n ....\n 4588  \n 4589  static void\n 4590: isofile_add_entry(struct iso9660 *iso9660, struct isofile *file)\n 4591  {\n 4592  \tfile->allnext = NULL;\n ....\n 4596  \n 4597  static void\n 4598: isofile_free_all_entries(struct iso9660 *iso9660)\n 4599  {\n 4600: \tstruct isofile *file, *file_next;\n 4601  \n 4602  \tfile = iso9660->all_file_list.first;\n ....\n 4609  \n 4610  static void\n 4611: isofile_init_entry_data_file_list(struct iso9660 *iso9660)\n 4612  {\n 4613  \tiso9660->data_file_list.first = NULL;\n ....\n 4616  \n 4617  static void\n 4618: isofile_add_data_file(struct iso9660 *iso9660, struct isofile *file)\n 4619  {\n 4620  \tfile->datanext = NULL;\n ....\n 4624  \n 4625  \n 4626: static struct isofile *\n 4627: isofile_new(struct archive_write *a, struct archive_entry *entry)\n 4628  {\n 4629: \tstruct isofile *file;\n 4630  \n 4631  \tfile = calloc(1, sizeof(*file));\n ....\n 4651  \n 4652  static void\n 4653: isofile_free(struct isofile *file)\n 4654  {\n 4655: \tstruct content *con, *tmp;\n 4656  \n 4657  \tcon = file->content.next;\n ....\n 4710   */\n 4711  static int\n 4712: isofile_gen_utility_names(struct archive_write *a, struct isofile *file)\n 4713  {\n 4714: \tstruct iso9660 *iso9660;\n 4715  \tconst char *pathname;\n 4716  \tchar *p, *dirname, *slash;\n ....\n 4827  \tif (cleanup_backslash_1(file->parentdir.s) != 0) {\n 4828  \t\tconst wchar_t *wp = archive_entry_pathname_w(file->entry);\n 4829: \t\tstruct archive_wstring ws;\n 4830  \n 4831  \t\tif (wp != NULL) {\n ....\n 4942  \t\t\tconst wchar_t *wp =\n 4943  \t\t\t    archive_entry_symlink_w(file->entry);\n 4944: \t\t\tstruct archive_wstring ws;\n 4945  \n 4946  \t\t\tif (wp != NULL) {\n ....\n 4997   */\n 4998  static int\n 4999: isofile_register_hardlink(struct archive_write *a, struct isofile *file)\n 5000  {\n 5001: \tstruct iso9660 *iso9660 = a->format_data;\n 5002: \tstruct hardlink *hl;\n 5003  \tconst char *pathname;\n 5004  \n ....\n 5019  \t\thl->file_list.last = &(file->hlnext);\n 5020  \t\t__archive_rb_tree_insert_node(&(iso9660->hardlink_rbtree),\n 5021: \t\t    (struct archive_rb_node *)hl);\n 5022  \t} else {\n 5023: \t\thl = (struct hardlink *)__archive_rb_tree_find_node(\n 5024  \t\t    &(iso9660->hardlink_rbtree), pathname);\n 5025  \t\tif (hl != NULL) {\n ....\n 5042   */\n 5043  static void\n 5044: isofile_connect_hardlink_files(struct iso9660 *iso9660)\n 5045  {\n 5046: \tstruct archive_rb_node *n;\n 5047: \tstruct hardlink *hl;\n 5048: \tstruct isofile *target, *nf;\n 5049  \n 5050  \tARCHIVE_RB_TREE_FOREACH(n, &(iso9660->hardlink_rbtree)) {\n 5051: \t\thl = (struct hardlink *)n;\n 5052  \n 5053  \t\t/* The first entry must be a hardlink target. */\n ....\n 5064  \n 5065  static int\n 5066: isofile_hd_cmp_node(const struct archive_rb_node *n1,\n 5067:     const struct archive_rb_node *n2)\n 5068  {\n 5069: \tconst struct hardlink *h1 = (const struct hardlink *)n1;\n 5070: \tconst struct hardlink *h2 = (const struct hardlink *)n2;\n 5071  \n 5072  \treturn (strcmp(archive_entry_pathname(h1->file_list.first->entry),\n ....\n 5075  \n 5076  static int\n 5077: isofile_hd_cmp_key(const struct archive_rb_node *n, const void *key)\n 5078  {\n 5079: \tconst struct hardlink *h = (const struct hardlink *)n;\n 5080  \n 5081  \treturn (strcmp(archive_entry_pathname(h->file_list.first->entry),\n ....\n 5084  \n 5085  static void\n 5086: isofile_init_hardlinks(struct iso9660 *iso9660)\n 5087  {\n 5088: \tstatic const struct archive_rb_tree_ops rb_ops = {\n 5089  \t\tisofile_hd_cmp_node, isofile_hd_cmp_key,\n 5090  \t};\n ....\n 5094  \n 5095  static void\n 5096: isofile_free_hardlinks(struct iso9660 *iso9660)\n 5097  {\n 5098: \tstruct archive_rb_node *n, *tmp;\n 5099  \n 5100  \tARCHIVE_RB_TREE_FOREACH_SAFE(n, &(iso9660->hardlink_rbtree), tmp) {\n ....\n 5104  }\n 5105  \n 5106: static struct isoent *\n 5107: isoent_new(struct isofile *file)\n 5108  {\n 5109: \tstruct isoent *isoent;\n 5110: \tstatic const struct archive_rb_tree_ops rb_ops = {\n 5111  \t\tisoent_cmp_node, isoent_cmp_key,\n 5112  \t};\n ....\n 5130  }\n 5131  \n 5132: static inline struct isoent *\n 5133: isoent_clone(struct isoent *src)\n 5134  {\n 5135  \treturn (isoent_new(src->file));\n ....\n 5137  \n 5138  static void\n 5139: _isoent_free(struct isoent *isoent)\n 5140  {\n 5141: \tstruct extr_rec *er, *er_next;\n 5142  \n 5143  \tfree(isoent->children_sorted);\n ....\n 5153  \n 5154  static void\n 5155: isoent_free_all(struct isoent *isoent)\n 5156  {\n 5157: \tstruct isoent *np, *np_temp;\n 5158  \n 5159  \tif (isoent == NULL)\n ....\n 5185  }\n 5186  \n 5187: static struct isoent *\n 5188: isoent_create_virtual_dir(struct archive_write *a, struct iso9660 *iso9660, const char *pathname)\n 5189  {\n 5190: \tstruct isofile *file;\n 5191: \tstruct isoent *isoent;\n 5192  \n 5193  \tfile = isofile_new(a, NULL);\n ....\n 5218  \n 5219  static int\n 5220: isoent_cmp_node(const struct archive_rb_node *n1,\n 5221:     const struct archive_rb_node *n2)\n 5222  {\n 5223: \tconst struct isoent *e1 = (const struct isoent *)n1;\n 5224: \tconst struct isoent *e2 = (const struct isoent *)n2;\n 5225  \n 5226  \treturn (strcmp(e1->file->basename.s, e2->file->basename.s));\n ....\n 5228  \n 5229  static int\n 5230: isoent_cmp_key(const struct archive_rb_node *n, const void *key)\n 5231  {\n 5232: \tconst struct isoent *e = (const struct isoent *)n;\n 5233  \n 5234  \treturn (strcmp(e->file->basename.s, (const char *)key));\n ....\n 5236  \n 5237  static int\n 5238: isoent_add_child_head(struct isoent *parent, struct isoent *child)\n 5239  {\n 5240  \n 5241  \tif (!__archive_rb_tree_insert_node(\n 5242: \t    &(parent->rbtree), (struct archive_rb_node *)child))\n 5243  \t\treturn (0);\n 5244  \tif ((child->chnext = parent->children.first) == NULL)\n ....\n 5261  \n 5262  static int\n 5263: isoent_add_child_tail(struct isoent *parent, struct isoent *child)\n 5264  {\n 5265  \n 5266  \tif (!__archive_rb_tree_insert_node(\n 5267: \t    &(parent->rbtree), (struct archive_rb_node *)child))\n 5268  \t\treturn (0);\n 5269  \tchild->chnext = NULL;\n ....\n 5285  \n 5286  static void\n 5287: isoent_remove_child(struct isoent *parent, struct isoent *child)\n 5288  {\n 5289: \tstruct isoent *ent;\n 5290  \n 5291  \t/* Remove a child entry from children chain. */\n ....\n 5308  \n 5309  \t__archive_rb_tree_remove_node(&(parent->rbtree),\n 5310: \t    (struct archive_rb_node *)child);\n 5311  }\n 5312  \n 5313  static int\n 5314: isoent_clone_tree(struct archive_write *a, struct isoent **nroot,\n 5315:     struct isoent *root)\n 5316  {\n 5317: \tstruct isoent *np, *xroot, *newent;\n 5318  \n 5319  \tnp = root;\n ....\n 5356   */\n 5357  static void\n 5358: isoent_setup_directory_location(struct iso9660 *iso9660, int location,\n 5359:     struct vdd *vdd)\n 5360  {\n 5361: \tstruct isoent *np;\n 5362  \tint depth;\n 5363  \n ....\n 5397  \n 5398  static void\n 5399: _isoent_file_location(struct iso9660 *iso9660, struct isoent *isoent,\n 5400      int *symlocation)\n 5401  {\n 5402: \tstruct isoent **children;\n 5403  \tint n;\n 5404  \n ....\n 5408  \tchildren = isoent->children_sorted;\n 5409  \tfor (n = 0; n < isoent->children.cnt; n++) {\n 5410: \t\tstruct isoent *np;\n 5411: \t\tstruct isofile *file;\n 5412  \n 5413  \t\tnp = children[n];\n ....\n 5437   */\n 5438  static void\n 5439: isoent_setup_file_location(struct iso9660 *iso9660, int location)\n 5440  {\n 5441: \tstruct isoent *isoent;\n 5442: \tstruct isoent *np;\n 5443: \tstruct isofile *file;\n 5444  \tsize_t size;\n 5445  \tint block;\n ....\n 5547   */\n 5548  static int\n 5549: isoent_tree(struct archive_write *a, struct isoent **isoentpp)\n 5550  {\n 5551  #if defined(_WIN32) && !defined(__CYGWIN__)\n ....\n 5556  \tchar name[256];\n 5557  #endif\n 5558: \tstruct iso9660 *iso9660 = a->format_data;\n 5559: \tstruct isoent *dent, *isoent, *np;\n 5560: \tstruct isofile *f1, *f2;\n 5561  \tconst char *fn, *p;\n 5562  \tint l;\n ....\n 5578  \t    strcmp(iso9660->cur_dirstr.s, fn) == 0) {\n 5579  \t\tif (!isoent_add_child_tail(iso9660->cur_dirent, isoent)) {\n 5580: \t\t\tnp = (struct isoent *)__archive_rb_tree_find_node(\n 5581  \t\t\t    &(iso9660->cur_dirent->rbtree),\n 5582  \t\t\t    isoent->file->basename.s);\n ....\n 5626  \t\t */\n 5627  \t\twhile (fn[0] != '\\0') {\n 5628: \t\t\tstruct isoent *vp;\n 5629: \t\t\tstruct archive_string as;\n 5630  \n 5631  \t\t\tarchive_string_init(&as);\n ....\n 5688  \n 5689  \t\tif (!isoent_add_child_tail(dent, isoent)) {\n 5690: \t\t\tnp = (struct isoent *)__archive_rb_tree_find_node(\n 5691  \t\t\t    &(dent->rbtree), isoent->file->basename.s);\n 5692  \t\t\tgoto same_entry;\n ....\n 5729   * Find a entry from `isoent'\n 5730   */\n 5731: static struct isoent *\n 5732: isoent_find_child(struct isoent *isoent, const char *child_name)\n 5733  {\n 5734: \tstruct isoent *np;\n 5735  \n 5736: \tnp = (struct isoent *)__archive_rb_tree_find_node(\n 5737  \t    &(isoent->rbtree), child_name);\n 5738  \treturn (np);\n ....\n 5743   * in the tree.\n 5744   */\n 5745: static struct isoent *\n 5746: isoent_find_entry(struct isoent *rootent, const char *fn)\n 5747  {\n 5748  #if defined(_WIN32) && !defined(__CYGWIN__)\n ....\n 5753  \tchar name[256];\n 5754  #endif\n 5755: \tstruct isoent *isoent, *np;\n 5756  \tint l;\n 5757  \n ....\n 5804  \n 5805  static void\n 5806: idr_init(struct iso9660 *iso9660, struct vdd *vdd, struct idr *idr)\n 5807  {\n 5808  \n ....\n 5822  \n 5823  static void\n 5824: idr_cleanup(struct idr *idr)\n 5825  {\n 5826  \tfree(idr->idrent_pool);\n ....\n 5828  \n 5829  static int\n 5830: idr_ensure_poolsize(struct archive_write *a, struct idr *idr,\n 5831      int cnt)\n 5832  {\n ....\n 5838  \n 5839  \t\tpsize = (cnt + bk) & ~bk;\n 5840: \t\tp = realloc(idr->idrent_pool, sizeof(struct idrent) * psize);\n 5841  \t\tif (p == NULL) {\n 5842  \t\t\tarchive_set_error(&a->archive, ENOMEM,\n ....\n 5844  \t\t\treturn (ARCHIVE_FATAL);\n 5845  \t\t}\n 5846: \t\tidr->idrent_pool = (struct idrent *)p;\n 5847  \t\tidr->pool_size = psize;\n 5848  \t}\n ....\n 5851  \n 5852  static int\n 5853: idr_start(struct archive_write *a, struct idr *idr, int cnt, int ffmax,\n 5854:     int num_size, int null_size, const struct archive_rb_tree_ops *rbt_ops)\n 5855  {\n 5856  \tint r;\n ....\n 5871  \n 5872  static void\n 5873: idr_register(struct idr *idr, struct isoent *isoent, int weight, int noff)\n 5874  {\n 5875: \tstruct idrent *idrent, *n;\n 5876  \n 5877  \tidrent = &(idr->idrent_pool[idr->pool_idx++]);\n ....\n 5883  \n 5884  \tif (!__archive_rb_tree_insert_node(&(idr->rbtree), &(idrent->rbnode))) {\n 5885: \t\tn = (struct idrent *)__archive_rb_tree_find_node(\n 5886  \t\t    &(idr->rbtree), idrent->isoent);\n 5887  \t\tif (n != NULL) {\n ....\n 5895  \n 5896  static void\n 5897: idr_extend_identifier(struct idrent *wnp, int numsize, int nullsize)\n 5898  {\n 5899  \tunsigned char *p;\n ....\n 5912  \n 5913  static void\n 5914: idr_resolve(struct idr *idr, void (*fsetnum)(unsigned char *p, int num))\n 5915  {\n 5916: \tstruct idrent *n;\n 5917  \tunsigned char *p;\n 5918  \n ....\n 5971   */\n 5972  static int\n 5973: isoent_gen_iso9660_identifier(struct archive_write *a, struct isoent *isoent,\n 5974:     struct idr *idr)\n 5975  {\n 5976: \tstruct iso9660 *iso9660;\n 5977: \tstruct isoent *np;\n 5978  \tchar *p;\n 5979  \tint l, r;\n ....\n 5981  \tchar allow_ldots, allow_multidot, allow_period, allow_vernum;\n 5982  \tint fnmax, ffmax, dnmax;\n 5983: \tstatic const struct archive_rb_tree_ops rb_ops = {\n 5984  \t\tisoent_cmp_node_iso9660, isoent_cmp_key_iso9660\n 5985  \t};\n ....\n 6221   */\n 6222  static int\n 6223: isoent_gen_joliet_identifier(struct archive_write *a, struct isoent *isoent,\n 6224:     struct idr *idr)\n 6225  {\n 6226: \tstruct iso9660 *iso9660;\n 6227: \tstruct isoent *np;\n 6228  \tunsigned char *p;\n 6229  \tsize_t l;\n 6230  \tint r;\n 6231  \tsize_t ffmax, parent_len;\n 6232: \tstatic const struct archive_rb_tree_ops rb_ops = {\n 6233  \t\tisoent_cmp_node_joliet, isoent_cmp_key_joliet\n 6234  \t};\n ....\n 6342   */\n 6343  static int\n 6344: isoent_cmp_iso9660_identifier(const struct isoent *p1, const struct isoent *p2)\n 6345  {\n 6346  \tconst char *s1, *s2;\n ....\n 6414  \n 6415  static int\n 6416: isoent_cmp_node_iso9660(const struct archive_rb_node *n1,\n 6417:     const struct archive_rb_node *n2)\n 6418  {\n 6419: \tconst struct idrent *e1 = (const struct idrent *)n1;\n 6420: \tconst struct idrent *e2 = (const struct idrent *)n2;\n 6421  \n 6422  \treturn (isoent_cmp_iso9660_identifier(e2->isoent, e1->isoent));\n ....\n 6424  \n 6425  static int\n 6426: isoent_cmp_key_iso9660(const struct archive_rb_node *node, const void *key)\n 6427  {\n 6428: \tconst struct isoent *isoent = (const struct isoent *)key;\n 6429: \tconst struct idrent *idrent = (const struct idrent *)node;\n 6430  \n 6431  \treturn (isoent_cmp_iso9660_identifier(isoent, idrent->isoent));\n ....\n 6433  \n 6434  static int\n 6435: isoent_cmp_joliet_identifier(const struct isoent *p1, const struct isoent *p2)\n 6436  {\n 6437  \tconst unsigned char *s1, *s2;\n ....\n 6501  \n 6502  static int\n 6503: isoent_cmp_node_joliet(const struct archive_rb_node *n1,\n 6504:     const struct archive_rb_node *n2)\n 6505  {\n 6506: \tconst struct idrent *e1 = (const struct idrent *)n1;\n 6507: \tconst struct idrent *e2 = (const struct idrent *)n2;\n 6508  \n 6509  \treturn (isoent_cmp_joliet_identifier(e2->isoent, e1->isoent));\n ....\n 6511  \n 6512  static int\n 6513: isoent_cmp_key_joliet(const struct archive_rb_node *node, const void *key)\n 6514  {\n 6515: \tconst struct isoent *isoent = (const struct isoent *)key;\n 6516: \tconst struct idrent *idrent = (const struct idrent *)node;\n 6517  \n 6518  \treturn (isoent_cmp_joliet_identifier(isoent, idrent->isoent));\n ....\n 6520  \n 6521  static int\n 6522: isoent_make_sorted_files(struct archive_write *a, struct isoent *isoent,\n 6523:     struct idr *idr)\n 6524  {\n 6525: \tstruct archive_rb_node *rn;\n 6526: \tstruct isoent **children;\n 6527  \n 6528: \tchildren = malloc(isoent->children.cnt * sizeof(struct isoent *));\n 6529  \tif (children == NULL) {\n 6530  \t\tarchive_set_error(&a->archive, ENOMEM,\n ....\n 6535  \n 6536  \tARCHIVE_RB_TREE_FOREACH(rn, &(idr->rbtree)) {\n 6537: \t\tstruct idrent *idrent = (struct idrent *)rn;\n 6538  \t\t*children ++ = idrent->isoent;\n 6539  \t}\n ....\n 6546   */\n 6547  static int\n 6548: isoent_traverse_tree(struct archive_write *a, struct vdd* vdd)\n 6549  {\n 6550: \tstruct iso9660 *iso9660 = a->format_data;\n 6551: \tstruct isoent *np;\n 6552: \tstruct idr idr;\n 6553  \tint depth;\n 6554  \tint r;\n 6555: \tint (*genid)(struct archive_write *, struct isoent *, struct idr *);\n 6556  \n 6557  \tidr_init(iso9660, vdd, &idr);\n ....\n 6619   */\n 6620  static int\n 6621: isoent_collect_dirs(struct vdd *vdd, struct isoent *rootent, int depth)\n 6622  {\n 6623: \tstruct isoent *np;\n 6624  \n 6625  \tif (rootent == NULL)\n ....\n 6656   */\n 6657  static int\n 6658: isoent_rr_move_dir(struct archive_write *a, struct isoent **rr_moved,\n 6659:     struct isoent *curent, struct isoent **newent)\n 6660  {\n 6661: \tstruct iso9660 *iso9660 = a->format_data;\n 6662: \tstruct isoent *rrmoved, *mvent, *np;\n 6663  \n 6664  \tif ((rrmoved = *rr_moved) == NULL) {\n 6665: \t\tstruct isoent *rootent = iso9660->primary.rootent;\n 6666  \t\t/* There isn't rr_move entry.\n 6667  \t\t * Create rr_move entry and insert it into the root entry.\n ....\n 6737  \n 6738  static int\n 6739: isoent_rr_move(struct archive_write *a)\n 6740  {\n 6741: \tstruct iso9660 *iso9660 = a->format_data;\n 6742: \tstruct path_table *pt;\n 6743: \tstruct isoent *rootent, *rr_moved;\n 6744: \tstruct isoent *np, *last;\n 6745  \tint r;\n 6746  \n ....\n 6775  \t\tlast = path_table_last_entry(pt);\n 6776  \t\tfor (; np != NULL; np = np->ptnext) {\n 6777: \t\t\tstruct isoent *mvent;\n 6778: \t\t\tstruct isoent *newent;\n 6779  \n 6780  \t\t\tif (!np->dir)\n ....\n 6805  _compare_path_table(const void *v1, const void *v2)\n 6806  {\n 6807: \tconst struct isoent *p1, *p2;\n 6808  \tconst char *s1, *s2;\n 6809  \tint cmp, l;\n 6810  \n 6811: \tp1 = *((const struct isoent **)(uintptr_t)v1);\n 6812: \tp2 = *((const struct isoent **)(uintptr_t)v2);\n 6813  \n 6814  \t/* Compare parent directory number */\n ....\n 6847  _compare_path_table_joliet(const void *v1, const void *v2)\n 6848  {\n 6849: \tconst struct isoent *p1, *p2;\n 6850  \tconst unsigned char *s1, *s2;\n 6851  \tint cmp, l;\n 6852  \n 6853: \tp1 = *((const struct isoent **)(uintptr_t)v1);\n 6854: \tp2 = *((const struct isoent **)(uintptr_t)v2);\n 6855  \n 6856  \t/* Compare parent directory number */\n ....\n 6885  \n 6886  static inline void\n 6887: path_table_add_entry(struct path_table *pathtbl, struct isoent *ent)\n 6888  {\n 6889  \tent->ptnext = NULL;\n ....\n 6893  }\n 6894  \n 6895: static inline struct isoent *\n 6896: path_table_last_entry(struct path_table *pathtbl)\n 6897  {\n 6898  \tif (pathtbl->first == NULL)\n 6899  \t\treturn (NULL);\n 6900: \treturn (((struct isoent *)(void *)\n 6901: \t\t((char *)(pathtbl->last) - offsetof(struct isoent, ptnext))));\n 6902  }\n 6903  \n ....\n 6907   */\n 6908  static int\n 6909: isoent_make_path_table_2(struct archive_write *a, struct vdd *vdd,\n 6910      int depth, int *dir_number)\n 6911  {\n 6912: \tstruct isoent *np;\n 6913: \tstruct isoent **enttbl;\n 6914: \tstruct path_table *pt;\n 6915  \tint i;\n 6916  \n ....\n 6920  \t\treturn (ARCHIVE_OK);\n 6921  \t}\n 6922: \tenttbl = malloc(pt->cnt * sizeof(struct isoent *));\n 6923  \tif (enttbl == NULL) {\n 6924  \t\tarchive_set_error(&a->archive, ENOMEM,\n ....\n 6935  \tcase VDD_ENHANCED:\n 6936  #ifdef __COMPAR_FN_T\n 6937: \t\tqsort(enttbl, pt->cnt, sizeof(struct isoent *),\n 6938  \t\t    (__compar_fn_t)_compare_path_table);\n 6939  #else\n 6940: \t\tqsort(enttbl, pt->cnt, sizeof(struct isoent *),\n 6941  \t\t    _compare_path_table);\n 6942  #endif\n ....\n 6944  \tcase VDD_JOLIET:\n 6945  #ifdef __COMPAR_FN_T\n 6946: \t\tqsort(enttbl, pt->cnt, sizeof(struct isoent *),\n 6947  \t\t    (__compar_fn_t)_compare_path_table_joliet);\n 6948  #else\n 6949: \t\tqsort(enttbl, pt->cnt, sizeof(struct isoent *),\n 6950  \t\t    _compare_path_table_joliet);\n 6951  #endif\n ....\n 6959  \n 6960  static int\n 6961: isoent_alloc_path_table(struct archive_write *a, struct vdd *vdd,\n 6962      int max_depth)\n 6963  {\n ....\n 6984   */\n 6985  static int\n 6986: isoent_make_path_table(struct archive_write *a)\n 6987  {\n 6988: \tstruct iso9660 *iso9660 = a->format_data;\n 6989  \tint depth, r;\n 6990  \tint dir_number;\n ....\n 7085  \n 7086  static int\n 7087: isoent_find_out_boot_file(struct archive_write *a, struct isoent *rootent)\n 7088  {\n 7089: \tstruct iso9660 *iso9660 = a->format_data;\n 7090  \n 7091  \t/* Find a isoent of the boot file. */\n ....\n 7103  \n 7104  static int\n 7105: isoent_create_boot_catalog(struct archive_write *a, struct isoent *rootent)\n 7106  {\n 7107: \tstruct iso9660 *iso9660 = a->format_data;\n 7108: \tstruct isofile *file;\n 7109: \tstruct isoent *isoent;\n 7110: \tstruct archive_entry *entry;\n 7111  \n 7112  \t(void)rootent; /* UNUSED */\n ....\n 7243   */\n 7244  static int\n 7245: make_boot_catalog(struct archive_write *a)\n 7246  {\n 7247: \tstruct iso9660 *iso9660 = a->format_data;\n 7248  \tunsigned char *block;\n 7249  \tunsigned char *p;\n ....\n 7310  \n 7311  static int\n 7312: setup_boot_information(struct archive_write *a)\n 7313  {\n 7314: \tstruct iso9660 *iso9660 = a->format_data;\n 7315: \tstruct isoent *np;\n 7316  \tint64_t size;\n 7317  \tuint32_t sum;\n ....\n 7371  \n 7372  static int\n 7373: zisofs_init_zstream(struct archive_write *a)\n 7374  {\n 7375: \tstruct iso9660 *iso9660 = a->format_data;\n 7376  \tint r;\n 7377  \n ....\n 7413  \n 7414  static int\n 7415: zisofs_init(struct archive_write *a,  struct isofile *file)\n 7416  {\n 7417: \tstruct iso9660 *iso9660 = a->format_data;\n 7418  #ifdef HAVE_ZLIB_H\n 7419  \tuint64_t tsize;\n ....\n 7502  \n 7503  static void\n 7504: zisofs_detect_magic(struct archive_write *a, const void *buff, size_t s)\n 7505  {\n 7506: \tstruct iso9660 *iso9660 = a->format_data;\n 7507: \tstruct isofile *file = iso9660->cur_file;\n 7508  \tconst unsigned char *p, *endp;\n 7509  \tconst unsigned char *magic_buff;\n ....\n 7594   */\n 7595  static int\n 7596: zisofs_write_to_temp(struct archive_write *a, const void *buff, size_t s)\n 7597  {\n 7598: \tstruct iso9660 *iso9660 = a->format_data;\n 7599: \tstruct isofile *file = iso9660->cur_file;\n 7600  \tconst unsigned char *b;\n 7601  \tz_stream *zstrm;\n ....\n 7707  \n 7708  static int\n 7709: zisofs_finish_entry(struct archive_write *a)\n 7710  {\n 7711: \tstruct iso9660 *iso9660 = a->format_data;\n 7712: \tstruct isofile *file = iso9660->cur_file;\n 7713  \tunsigned char buff[16];\n 7714  \tsize_t s;\n ....\n 7779  \n 7780  static int\n 7781: zisofs_free(struct archive_write *a)\n 7782  {\n 7783: \tstruct iso9660 *iso9660 = a->format_data;\n 7784  \tint ret = ARCHIVE_OK;\n 7785  \n ....\n 7796  }\n 7797  \n 7798: struct zisofs_extract {\n 7799  \tint\t\t pz_log2_bs; /* Log2 of block size */\n 7800  \tuint64_t\t pz_uncompressed_size;\n ....\n 7816  \n 7817  static ssize_t\n 7818: zisofs_extract_init(struct archive_write *a, struct zisofs_extract *zisofs,\n 7819      const unsigned char *p, size_t bytes)\n 7820  {\n ....\n 7897  \n 7898  static ssize_t\n 7899: zisofs_extract(struct archive_write *a, struct zisofs_extract *zisofs,\n 7900      const unsigned char *p, size_t bytes)\n 7901  {\n ....\n 8017  \n 8018  static int\n 8019: zisofs_rewind_boot_file(struct archive_write *a)\n 8020  {\n 8021: \tstruct iso9660 *iso9660 = a->format_data;\n 8022: \tstruct isofile *file;\n 8023  \tunsigned char *rbuff;\n 8024  \tssize_t r;\n 8025  \tsize_t remaining, rbuff_size;\n 8026: \tstruct zisofs_extract zext;\n 8027  \tint64_t read_offset, write_offset, new_offset;\n 8028  \tint fd, ret = ARCHIVE_OK;\n ....\n 8124  \n 8125  static int\n 8126: zisofs_write_to_temp(struct archive_write *a, const void *buff, size_t s)\n 8127  {\n 8128  \t(void)buff; /* UNUSED */\n ....\n 8133  \n 8134  static int\n 8135: zisofs_rewind_boot_file(struct archive_write *a)\n 8136  {\n 8137: \tstruct iso9660 *iso9660 = a->format_data;\n 8138  \n 8139  \tif (iso9660->el_torito.boot->file->zisofs.header_size != 0) {\n ....\n 8147  \n 8148  static int\n 8149: zisofs_finish_entry(struct archive_write *a)\n 8150  {\n 8151  \t(void)a; /* UNUSED */\n ....\n 8154  \n 8155  static int\n 8156: zisofs_free(struct archive_write *a)\n 8157  {\n 8158  \t(void)a; /* UNUSED */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter.c:\n   40  /* A table that maps filter codes to functions. */\n   41  static const\n   42: struct { int code; int (*setter)(struct archive *); } codes[] =\n   43  {\n   44  \t{ ARCHIVE_FILTER_NONE,\t\tarchive_write_add_filter_none },\n   ..\n   59  \n   60  int\n   61: archive_write_add_filter(struct archive *a, int code)\n   62  {\n   63  \tint i;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_iso9660.c:\n  142  #define PVD_effective_date_offset (PVD_expiration_date_offset + PVD_expiration_date_size)\n  143  #define PVD_effective_date_size 17\n  144: #define PVD_file_structure_version_offset (PVD_effective_date_offset + PVD_effective_date_size)\n  145: #define PVD_file_structure_version_size 1\n  146: #define PVD_reserved4_offset (PVD_file_structure_version_offset + PVD_file_structure_version_size)\n  147  #define PVD_reserved4_size 1\n  148  #define PVD_application_data_offset (PVD_reserved4_offset + PVD_reserved4_size)\n  ...\n  181  #define SVD_root_directory_record_offset 156\n  182  #define SVD_root_directory_record_size 34\n  183: #define SVD_file_structure_version_offset 881\n  184  #define SVD_reserved2_offset\t882\n  185  #define SVD_reserved2_size\t1\n  ...\n  221  };\n  222  \n  223: struct zisofs {\n  224  \t/* Set 1 if this file compressed by paged zlib */\n  225  \tint\t\t pz;\n  ...\n  246  };\n  247  #else\n  248: struct zisofs {\n  249  \t/* Set 1 if this file compressed by paged zlib */\n  250  \tint\t\t pz;\n  ...\n  252  #endif\n  253  \n  254: struct content {\n  255  \tuint64_t\t offset;/* Offset on disk.\t\t*/\n  256  \tuint64_t\t size;\t/* File size in bytes.\t\t*/\n  257: \tstruct content\t*next;\n  258  };\n  259  \n  260  /* In-memory storage for a directory record. */\n  261: struct file_info {\n  262: \tstruct file_info\t*use_next;\n  263: \tstruct file_info\t*parent;\n  264: \tstruct file_info\t*next;\n  265: \tstruct file_info\t*re_next;\n  266  \tint\t\t subdirs;\n  267  \tuint64_t\t key;\t\t/* Heap Key.\t\t\t*/\n  ...\n  286  \tint64_t\t\t number;\n  287  \tint\t\t nlinks;\n  288: \tstruct archive_string name; /* Pathname */\n  289  \tunsigned char\t*utf16be_name;\n  290  \tsize_t\t\t utf16be_bytes;\n  291  \tchar\t\t name_continues; /* Non-zero if name continues */\n  292: \tstruct archive_string symlink;\n  293  \tchar\t\t symlink_continues; /* Non-zero if link continues */\n  294  \t/* Set 1 if this file compressed by paged zlib(zisofs) */\n  ...\n  298  \t/* Set 1 if this file is multi extent. */\n  299  \tint\t\t multi_extent;\n  300: \tstruct {\n  301: \t\tstruct content\t*first;\n  302: \t\tstruct content\t**last;\n  303  \t} contents;\n  304: \tstruct {\n  305: \t\tstruct file_info\t*first;\n  306: \t\tstruct file_info\t**last;\n  307  \t} rede_files;\n  308  };\n  309  \n  310: struct heap_queue {\n  311: \tstruct file_info **files;\n  312  \tint\t\t allocated;\n  313  \tint\t\t used;\n  314  };\n  315  \n  316: struct iso9660 {\n  317  \tint\tmagic;\n  318  #define ISO9660_MAGIC   0x96609660\n  ...\n  321  \tint opt_support_rockridge;\n  322  \n  323: \tstruct archive_string pathname;\n  324  \tchar\tseenRockridge;\t/* Set true if RR extensions are used. */\n  325  \tchar\tseenSUSP;\t/* Set true if SUSP is being used. */\n  ...\n  327  \n  328  \tunsigned char\tsuspOffset;\n  329: \tstruct file_info *rr_moved;\n  330: \tstruct read_ce_queue {\n  331: \t\tstruct read_ce_req {\n  332  \t\t\tuint64_t\t offset;/* Offset of CE on disk. */\n  333: \t\t\tstruct file_info *file;\n  334  \t\t}\t\t*reqs;\n  335  \t\tint\t\t cnt;\n  ...\n  338  \n  339  \tint64_t\t\tprevious_number;\n  340: \tstruct archive_string previous_pathname;\n  341  \n  342: \tstruct file_info\t\t*use_files;\n  343: \tstruct heap_queue\t\t pending_files;\n  344: \tstruct {\n  345: \t\tstruct file_info\t*first;\n  346: \t\tstruct file_info\t**last;\n  347  \t}\tcache_files;\n  348: \tstruct {\n  349: \t\tstruct file_info\t*first;\n  350: \t\tstruct file_info\t**last;\n  351  \t}\tre_files;\n  352  \n  ...\n  356  \tint32_t  volume_block;/* Total size of volume in logical blocks. */\n  357  \n  358: \tstruct vd {\n  359  \t\tint\t\tlocation;\t/* Location of Extent.\t*/\n  360  \t\tuint32_t\tsize;\n  ...\n  364  \tint64_t\tentry_bytes_remaining;\n  365  \tsize_t  entry_bytes_unconsumed;\n  366: \tstruct zisofs\t entry_zisofs;\n  367: \tstruct content\t*entry_content;\n  368: \tstruct archive_string_conv *sconv_utf16be;\n  369  \t/*\n  370  \t * Buffers for a full pathname in UTF-16BE in Joliet extensions.\n  ...\n  379  };\n  380  \n  381: static int\tarchive_read_format_iso9660_bid(struct archive_read *, int);\n  382: static int\tarchive_read_format_iso9660_options(struct archive_read *,\n  383  \t\t    const char *, const char *);\n  384: static int\tarchive_read_format_iso9660_cleanup(struct archive_read *);\n  385: static int\tarchive_read_format_iso9660_read_data(struct archive_read *,\n  386  \t\t    const void **, size_t *, int64_t *);\n  387: static int\tarchive_read_format_iso9660_read_data_skip(struct archive_read *);\n  388: static int\tarchive_read_format_iso9660_read_header(struct archive_read *,\n  389: \t\t    struct archive_entry *);\n  390: static const char *build_pathname(struct archive_string *, struct file_info *, int);\n  391  static int\tbuild_pathname_utf16be(unsigned char *, size_t, size_t *,\n  392: \t\t    struct file_info *);\n  393  #if DEBUG\n  394  static void\tdump_isodirrec(FILE *, const unsigned char *isodirrec);\n  395  #endif\n  396: static time_t\ttime_from_tm(struct tm *);\n  397  static time_t\tisodate17(const unsigned char *);\n  398  static time_t\tisodate7(const unsigned char *);\n  399: static int\tisBootRecord(struct iso9660 *, const unsigned char *);\n  400: static int\tisVolumePartition(struct iso9660 *, const unsigned char *);\n  401: static int\tisVDSetTerminator(struct iso9660 *, const unsigned char *);\n  402: static int\tisJolietSVD(struct iso9660 *, const unsigned char *);\n  403: static int\tisSVD(struct iso9660 *, const unsigned char *);\n  404: static int\tisEVD(struct iso9660 *, const unsigned char *);\n  405: static int\tisPVD(struct iso9660 *, const unsigned char *);\n  406: static int\tnext_cache_entry(struct archive_read *, struct iso9660 *,\n  407: \t\t    struct file_info **);\n  408: static int\tnext_entry_seek(struct archive_read *, struct iso9660 *,\n  409: \t\t    struct file_info **);\n  410: static struct file_info *\n  411: \t\tparse_file_info(struct archive_read *a,\n  412: \t\t    struct file_info *parent, const unsigned char *isodirrec,\n  413  \t\t    size_t reclen);\n  414: static int\tparse_rockridge(struct archive_read *a,\n  415: \t\t    struct file_info *file, const unsigned char *start,\n  416  \t\t    const unsigned char *end);\n  417: static int\tregister_CE(struct archive_read *a, int32_t location,\n  418: \t\t    struct file_info *file);\n  419: static int\tread_CE(struct archive_read *a, struct iso9660 *iso9660);\n  420: static void\tparse_rockridge_NM1(struct file_info *,\n  421  \t\t    const unsigned char *, int);\n  422: static void\tparse_rockridge_SL1(struct file_info *,\n  423  \t\t    const unsigned char *, int);\n  424: static void\tparse_rockridge_TF1(struct file_info *,\n  425  \t\t    const unsigned char *, int);\n  426: static void\tparse_rockridge_ZF1(struct file_info *,\n  427  \t\t    const unsigned char *, int);\n  428: static void\tregister_file(struct iso9660 *, struct file_info *);\n  429: static void\trelease_files(struct iso9660 *);\n  430  static unsigned\ttoi(const void *p, int n);\n  431: static inline void re_add_entry(struct iso9660 *, struct file_info *);\n  432: static inline struct file_info * re_get_entry(struct iso9660 *);\n  433: static inline int rede_add_entry(struct file_info *);\n  434: static inline struct file_info * rede_get_entry(struct file_info *);\n  435: static inline void cache_add_entry(struct iso9660 *iso9660,\n  436: \t\t    struct file_info *file);\n  437: static inline struct file_info *cache_get_entry(struct iso9660 *iso9660);\n  438: static int\theap_add_entry(struct archive_read *a, struct heap_queue *heap,\n  439: \t\t    struct file_info *file, uint64_t key);\n  440: static struct file_info *heap_get_entry(struct heap_queue *heap);\n  441  \n  442  #define add_entry(arch, iso9660, file)\t\\\n  ...\n  446  \n  447  int\n  448: archive_read_support_format_iso9660(struct archive *_a)\n  449  {\n  450: \tstruct archive_read *a = (struct archive_read *)_a;\n  451: \tstruct iso9660 *iso9660;\n  452  \tint r;\n  453  \n  ...\n  455  \t    ARCHIVE_STATE_NEW, \"archive_read_support_format_iso9660\");\n  456  \n  457: \tiso9660 = (struct iso9660 *)calloc(1, sizeof(*iso9660));\n  458  \tif (iso9660 == NULL) {\n  459  \t\tarchive_set_error(&a->archive, ENOMEM,\n  ...\n  493  \n  494  static int\n  495: archive_read_format_iso9660_bid(struct archive_read *a, int best_bid)\n  496  {\n  497: \tstruct iso9660 *iso9660;\n  498  \tssize_t bytes_read;\n  499  \tconst unsigned char *p;\n  ...\n  505  \t\treturn (-1);\n  506  \n  507: \tiso9660 = (struct iso9660 *)(a->format->data);\n  508  \n  509  \t/*\n  ...\n  565  \n  566  static int\n  567: archive_read_format_iso9660_options(struct archive_read *a,\n  568  \t\tconst char *key, const char *val)\n  569  {\n  570: \tstruct iso9660 *iso9660;\n  571  \n  572: \tiso9660 = (struct iso9660 *)(a->format->data);\n  573  \n  574  \tif (strcmp(key, \"joliet\") == 0) {\n  ...\n  595  \n  596  static int\n  597: isNull(struct iso9660 *iso9660, const unsigned char *h, unsigned offset,\n  598  unsigned bytes)\n  599  {\n  ...\n  612  \n  613  static int\n  614: isBootRecord(struct iso9660 *iso9660, const unsigned char *h)\n  615  {\n  616  \t(void)iso9660; /* UNUSED */\n  ...\n  628  \n  629  static int\n  630: isVolumePartition(struct iso9660 *iso9660, const unsigned char *h)\n  631  {\n  632  \tint32_t location;\n  ...\n  654  \n  655  static int\n  656: isVDSetTerminator(struct iso9660 *iso9660, const unsigned char *h)\n  657  {\n  658  \t(void)iso9660; /* UNUSED */\n  ...\n  674  \n  675  static int\n  676: isJolietSVD(struct iso9660 *iso9660, const unsigned char *h)\n  677  {\n  678  \tconst unsigned char *p;\n  ...\n  723  \n  724  static int\n  725: isSVD(struct iso9660 *iso9660, const unsigned char *h)\n  726  {\n  727  \tconst unsigned char *p;\n  ...\n  744  \t\treturn (0);\n  745  \n  746: \t/* File structure version must be 1 for ISO9660/ECMA119. */\n  747: \tif (h[SVD_file_structure_version_offset] != 1)\n  748  \t\treturn (0);\n  749  \n  ...\n  782  \n  783  static int\n  784: isEVD(struct iso9660 *iso9660, const unsigned char *h)\n  785  {\n  786  \tconst unsigned char *p;\n  ...\n  824  \t\treturn (0);\n  825  \n  826: \t/* File structure version must be 2 for ISO9660:1999. */\n  827: \tif (h[PVD_file_structure_version_offset] != 2)\n  828  \t\treturn (0);\n  829  \n  ...\n  860  \n  861  static int\n  862: isPVD(struct iso9660 *iso9660, const unsigned char *h)\n  863  {\n  864  \tconst unsigned char *p;\n  ...\n  900  \t\treturn (0);\n  901  \n  902: \t/* File structure version must be 1 for ISO9660/ECMA119. */\n  903: \tif (h[PVD_file_structure_version_offset] != 1)\n  904  \t\treturn (0);\n  905  \n  ...\n  954  \n  955  static int\n  956: read_children(struct archive_read *a, struct file_info *parent)\n  957  {\n  958: \tstruct iso9660 *iso9660;\n  959  \tconst unsigned char *b, *p;\n  960: \tstruct file_info *multi;\n  961  \tsize_t step, skip_size;\n  962  \n  963: \tiso9660 = (struct iso9660 *)(a->format->data);\n  964  \t/* flush any remaining bytes from the last round to ensure\n  965  \t * we're positioned */\n  ...\n 1009  \t\tstep -= iso9660->logical_block_size;\n 1010  \t\tfor (; *p != 0 && p < b && p + *p <= b; p += *p) {\n 1011: \t\t\tstruct file_info *child;\n 1012  \n 1013  \t\t\t/* N.B.: these special directory identifiers\n ....\n 1031  \t\t\tif (child->cl_offset == 0 &&\n 1032  \t\t\t    (child->multi_extent || multi != NULL)) {\n 1033: \t\t\t\tstruct content *con;\n 1034  \n 1035  \t\t\t\tif (multi == NULL) {\n ....\n 1039  \t\t\t\t\t    &(multi->contents.first);\n 1040  \t\t\t\t}\n 1041: \t\t\t\tcon = malloc(sizeof(struct content));\n 1042  \t\t\t\tif (con == NULL) {\n 1043  \t\t\t\t\tarchive_set_error(\n ....\n 1077  \n 1078  static int\n 1079: choose_volume(struct archive_read *a, struct iso9660 *iso9660)\n 1080  {\n 1081: \tstruct file_info *file;\n 1082  \tint64_t skipsize;\n 1083: \tstruct vd *vd;\n 1084  \tconst void *block;\n 1085  \tchar seenJoliet;\n ....\n 1165  \n 1166  static int\n 1167: archive_read_format_iso9660_read_header(struct archive_read *a,\n 1168:     struct archive_entry *entry)\n 1169  {\n 1170: \tstruct iso9660 *iso9660;\n 1171: \tstruct file_info *file;\n 1172  \tint r, rd_r = ARCHIVE_OK;\n 1173  \n 1174: \tiso9660 = (struct iso9660 *)(a->format->data);\n 1175  \n 1176  \tif (!a->archive.archive_format) {\n ....\n 1274  \t}\n 1275  \n 1276: \t/* Set up the entry structure with information about this entry. */\n 1277  \tarchive_entry_set_mode(entry, file->mode);\n 1278  \tarchive_entry_set_uid(entry, file->uid);\n ....\n 1355  \tif (file->pz) {\n 1356  #ifdef HAVE_ZLIB_H\n 1357: \t\tstruct zisofs  *zisofs;\n 1358  \n 1359  \t\tzisofs = &iso9660->entry_zisofs;\n ....\n 1397  \n 1398  static int\n 1399: archive_read_format_iso9660_read_data_skip(struct archive_read *a)\n 1400  {\n 1401  \t/* Because read_next_header always does an explicit skip\n ....\n 1408  \n 1409  static int\n 1410: zisofs_read_data(struct archive_read *a,\n 1411      const void **buff, size_t *size, int64_t *offset)\n 1412  {\n 1413: \tstruct iso9660 *iso9660;\n 1414: \tstruct zisofs  *zisofs;\n 1415  \tconst unsigned char *p;\n 1416  \tsize_t avail;\n ....\n 1419  \tint r;\n 1420  \n 1421: \tiso9660 = (struct iso9660 *)(a->format->data);\n 1422  \tzisofs = &iso9660->entry_zisofs;\n 1423  \n ....\n 1632  \n 1633  static int\n 1634: zisofs_read_data(struct archive_read *a,\n 1635      const void **buff, size_t *size, int64_t *offset)\n 1636  {\n ....\n 1647  \n 1648  static int\n 1649: archive_read_format_iso9660_read_data(struct archive_read *a,\n 1650      const void **buff, size_t *size, int64_t *offset)\n 1651  {\n 1652  \tssize_t bytes_read;\n 1653: \tstruct iso9660 *iso9660;\n 1654  \n 1655: \tiso9660 = (struct iso9660 *)(a->format->data);\n 1656  \n 1657  \tif (iso9660->entry_bytes_unconsumed) {\n ....\n 1715  \n 1716  static int\n 1717: archive_read_format_iso9660_cleanup(struct archive_read *a)\n 1718  {\n 1719: \tstruct iso9660 *iso9660;\n 1720  \tint r = ARCHIVE_OK;\n 1721  \n 1722: \tiso9660 = (struct iso9660 *)(a->format->data);\n 1723  \trelease_files(iso9660);\n 1724  \tfree(iso9660->read_ce_req.reqs);\n ....\n 1748   * of any extensions, and stores the result in memory.\n 1749   */\n 1750: static struct file_info *\n 1751: parse_file_info(struct archive_read *a, struct file_info *parent,\n 1752      const unsigned char *isodirrec, size_t reclen)\n 1753  {\n 1754: \tstruct iso9660 *iso9660;\n 1755: \tstruct file_info *file, *filep;\n 1756  \tsize_t name_len;\n 1757  \tconst unsigned char *rr_start, *rr_end;\n ....\n 1762  \tint flags;\n 1763  \n 1764: \tiso9660 = (struct iso9660 *)(a->format->data);\n 1765  \n 1766  \tif (reclen != 0)\n ....\n 1811  \t\tif (filep->offset == offset) {\n 1812  \t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n 1813: \t\t\t    \"Directory structure contains loop\");\n 1814  \t\t\treturn (NULL);\n 1815  \t\t}\n ....\n 1817  \n 1818  \t/* Create a new file entry and copy data from the ISO dir record. */\n 1819: \tfile = (struct file_info *)calloc(1, sizeof(*file));\n 1820  \tif (file == NULL) {\n 1821  \t\tarchive_set_error(&a->archive, ENOMEM,\n ....\n 2019  \t\t\tfile->re_descendant = 1;\n 2020  \t\tif (file->cl_offset) {\n 2021: \t\t\tstruct file_info *r;\n 2022  \n 2023  \t\t\tif (parent == NULL || parent->parent == NULL) {\n ....\n 2098  \n 2099  static int\n 2100: parse_rockridge(struct archive_read *a, struct file_info *file,\n 2101      const unsigned char *p, const unsigned char *end)\n 2102  {\n 2103: \tstruct iso9660 *iso9660;\n 2104  \tint entry_seen = 0;\n 2105  \n 2106: \tiso9660 = (struct iso9660 *)(a->format->data);\n 2107  \n 2108  \twhile (p + 4 <= end  /* Enough space for another entry. */\n ....\n 2271  \n 2272  static int\n 2273: register_CE(struct archive_read *a, int32_t location,\n 2274:     struct file_info *file)\n 2275  {\n 2276: \tstruct iso9660 *iso9660;\n 2277: \tstruct read_ce_queue *heap;\n 2278: \tstruct read_ce_req *p;\n 2279  \tuint64_t offset, parent_offset;\n 2280  \tint hole, parent;\n 2281  \n 2282: \tiso9660 = (struct iso9660 *)(a->format->data);\n 2283  \toffset = ((uint64_t)location) * (uint64_t)iso9660->logical_block_size;\n 2284  \tif (((file->mode & AE_IFMT) == AE_IFREG &&\n ....\n 2343  \n 2344  static void\n 2345: next_CE(struct read_ce_queue *heap)\n 2346  {\n 2347  \tuint64_t a_offset, b_offset, c_offset;\n 2348  \tint a, b, c;\n 2349: \tstruct read_ce_req tmp;\n 2350  \n 2351  \tif (heap->cnt < 1)\n ....\n 2386  \n 2387  static int\n 2388: read_CE(struct archive_read *a, struct iso9660 *iso9660)\n 2389  {\n 2390: \tstruct read_ce_queue *heap;\n 2391  \tconst unsigned char *b, *p, *end;\n 2392: \tstruct file_info *file;\n 2393  \tsize_t step;\n 2394  \tint r;\n ....\n 2433  \n 2434  static void\n 2435: parse_rockridge_NM1(struct file_info *file,\n 2436  \t\t    const unsigned char *data, int data_length)\n 2437  {\n ....\n 2478  \n 2479  static void\n 2480: parse_rockridge_TF1(struct file_info *file, const unsigned char *data,\n 2481      int data_length)\n 2482  {\n ....\n 2551  \n 2552  static void\n 2553: parse_rockridge_SL1(struct file_info *file, const unsigned char *data,\n 2554      int data_length)\n 2555  {\n ....\n 2638  \n 2639  static void\n 2640: parse_rockridge_ZF1(struct file_info *file, const unsigned char *data,\n 2641      int data_length)\n 2642  {\n ....\n 2651  \n 2652  static void\n 2653: register_file(struct iso9660 *iso9660, struct file_info *file)\n 2654  {\n 2655  \n ....\n 2659  \n 2660  static void\n 2661: release_files(struct iso9660 *iso9660)\n 2662  {\n 2663: \tstruct content *con, *connext;\n 2664: \tstruct file_info *file;\n 2665  \n 2666  \tfile = iso9660->use_files;\n 2667  \twhile (file != NULL) {\n 2668: \t\tstruct file_info *next = file->use_next;\n 2669  \n 2670  \t\tarchive_string_free(&file->name);\n ....\n 2683  \n 2684  static int\n 2685: next_entry_seek(struct archive_read *a, struct iso9660 *iso9660,\n 2686:     struct file_info **pfile)\n 2687  {\n 2688: \tstruct file_info *file;\n 2689  \tint r;\n 2690  \n ....\n 2721  \n 2722  static int\n 2723: next_cache_entry(struct archive_read *a, struct iso9660 *iso9660,\n 2724:     struct file_info **pfile)\n 2725  {\n 2726: \tstruct file_info *file;\n 2727: \tstruct {\n 2728: \t\tstruct file_info\t*first;\n 2729: \t\tstruct file_info\t**last;\n 2730  \t}\tempty_files;\n 2731  \tint64_t number;\n ....\n 2739  \n 2740  \tfor (;;) {\n 2741: \t\tstruct file_info *re, *d;\n 2742  \n 2743  \t\t*pfile = file = next_entry(iso9660);\n ....\n 2763  \n 2764  \t\tif (file->cl_offset) {\n 2765: \t\t\tstruct file_info *first_re = NULL;\n 2766  \t\t\tint nexted_re = 0;\n 2767  \n ....\n 2931  \n 2932  static inline void\n 2933: re_add_entry(struct iso9660 *iso9660, struct file_info *file)\n 2934  {\n 2935  \tfile->re_next = NULL;\n ....\n 2938  }\n 2939  \n 2940: static inline struct file_info *\n 2941: re_get_entry(struct iso9660 *iso9660)\n 2942  {\n 2943: \tstruct file_info *file;\n 2944  \n 2945  \tif ((file = iso9660->re_files.first) != NULL) {\n ....\n 2953  \n 2954  static inline int\n 2955: rede_add_entry(struct file_info *file)\n 2956  {\n 2957: \tstruct file_info *re;\n 2958  \n 2959  \t/*\n ....\n 2972  }\n 2973  \n 2974: static inline struct file_info *\n 2975: rede_get_entry(struct file_info *re)\n 2976  {\n 2977: \tstruct file_info *file;\n 2978  \n 2979  \tif ((file = re->rede_files.first) != NULL) {\n ....\n 2987  \n 2988  static inline void\n 2989: cache_add_entry(struct iso9660 *iso9660, struct file_info *file)\n 2990  {\n 2991  \tfile->next = NULL;\n ....\n 2994  }\n 2995  \n 2996: static inline struct file_info *\n 2997: cache_get_entry(struct iso9660 *iso9660)\n 2998  {\n 2999: \tstruct file_info *file;\n 3000  \n 3001  \tif ((file = iso9660->cache_files.first) != NULL) {\n ....\n 3009  \n 3010  static int\n 3011: heap_add_entry(struct archive_read *a, struct heap_queue *heap,\n 3012:     struct file_info *file, uint64_t key)\n 3013  {\n 3014  \tuint64_t file_key, parent_key;\n ....\n 3017  \t/* Expand our pending files list as necessary. */\n 3018  \tif (heap->used >= heap->allocated) {\n 3019: \t\tstruct file_info **new_pending_files;\n 3020  \t\tint new_size = heap->allocated * 2;\n 3021  \n ....\n 3028  \t\t\treturn (ARCHIVE_FATAL);\n 3029  \t\t}\n 3030: \t\tnew_pending_files = (struct file_info **)\n 3031  \t\t    malloc(new_size * sizeof(new_pending_files[0]));\n 3032  \t\tif (new_pending_files == NULL) {\n ....\n 3065  }\n 3066  \n 3067: static struct file_info *\n 3068: heap_get_entry(struct heap_queue *heap)\n 3069  {\n 3070  \tuint64_t a_key, b_key, c_key;\n 3071  \tint a, b, c;\n 3072: \tstruct file_info *r, *tmp;\n 3073  \n 3074  \tif (heap->used < 1)\n ....\n 3126  isodate7(const unsigned char *v)\n 3127  {\n 3128: \tstruct tm tm;\n 3129  \tint offset;\n 3130  \ttime_t t;\n ....\n 3152  isodate17(const unsigned char *v)\n 3153  {\n 3154: \tstruct tm tm;\n 3155  \tint offset;\n 3156  \ttime_t t;\n ....\n 3178  \n 3179  static time_t\n 3180: time_from_tm(struct tm *t)\n 3181  {\n 3182  #if HAVE_TIMEGM\n ....\n 3203  \n 3204  static const char *\n 3205: build_pathname(struct archive_string *as, struct file_info *file, int depth)\n 3206  {\n 3207  \t// Plain ISO9660 only allows 8 dir levels; if we get\n ....\n 3225  static int\n 3226  build_pathname_utf16be(unsigned char *p, size_t max, size_t *len,\n 3227:     struct file_info *file)\n 3228  {\n 3229  \tif (file->parent != NULL && file->parent->utf16be_bytes > 0) {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_digest.c:\n 1466   * 8. Windows API\n 1467   */\n 1468: const struct archive_digest __archive_digest =\n 1469  {\n 1470  /* MD5 */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_disk_set_standard_lookup.c:\n   50  #if defined(_WIN32) && !defined(__CYGWIN__)\n   51  int\n   52: archive_read_disk_set_standard_lookup(struct archive *a)\n   53  {\n   54  \tarchive_set_error(a, -1, \"Standard lookups not available on Windows\");\n   ..\n   60  static const char * const NO_NAME = \"(noname)\";\n   61  \n   62: struct name_cache {\n   63: \tstruct archive *archive;\n   64  \tchar   *buff;\n   65  \tsize_t  buff_size;\n   ..\n   67  \tint\thits;\n   68  \tsize_t\tsize;\n   69: \tstruct {\n   70  \t\tid_t id;\n   71  \t\tconst char *name;\n   ..\n   76  static const char *\tlookup_uname(void *, int64_t);\n   77  static void\tcleanup(void *);\n   78: static const char *\tlookup_gname_helper(struct name_cache *, id_t gid);\n   79: static const char *\tlookup_uname_helper(struct name_cache *, id_t uid);\n   80  \n   81  /*\n   ..\n   93   */\n   94  int\n   95: archive_read_disk_set_standard_lookup(struct archive *a)\n   96  {\n   97: \tstruct name_cache *ucache = malloc(sizeof(struct name_cache));\n   98: \tstruct name_cache *gcache = malloc(sizeof(struct name_cache));\n   99  \n  100  \tif (ucache == NULL || gcache == NULL) {\n  ...\n  122  cleanup(void *data)\n  123  {\n  124: \tstruct name_cache *cache = (struct name_cache *)data;\n  125  \tsize_t i;\n  126  \n  ...\n  140   */\n  141  static const char *\n  142: lookup_name(struct name_cache *cache,\n  143:     const char * (*lookup_fn)(struct name_cache *, id_t), id_t id)\n  144  {\n  145  \tconst char *name;\n  ...\n  178  lookup_uname(void *data, int64_t uid)\n  179  {\n  180: \tstruct name_cache *uname_cache = (struct name_cache *)data;\n  181  \treturn (lookup_name(uname_cache,\n  182  \t\t    &lookup_uname_helper, (id_t)uid));\n  ...\n  185  #if HAVE_GETPWUID_R\n  186  static const char *\n  187: lookup_uname_helper(struct name_cache *cache, id_t id)\n  188  {\n  189: \tstruct passwd\tpwent, *result;\n  190  \tchar * nbuff;\n  191  \tsize_t nbuff_size;\n  ...\n  230  #else\n  231  static const char *\n  232: lookup_uname_helper(struct name_cache *cache, id_t id)\n  233  {\n  234: \tstruct passwd\t*result;\n  235  \t(void)cache; /* UNUSED */\n  236  \n  ...\n  247  lookup_gname(void *data, int64_t gid)\n  248  {\n  249: \tstruct name_cache *gname_cache = (struct name_cache *)data;\n  250  \treturn (lookup_name(gname_cache,\n  251  \t\t    &lookup_gname_helper, (id_t)gid));\n  ...\n  254  #if HAVE_GETGRGID_R\n  255  static const char *\n  256: lookup_gname_helper(struct name_cache *cache, id_t id)\n  257  {\n  258: \tstruct group\tgrent, *result;\n  259  \tchar * nbuff;\n  260  \tsize_t nbuff_size;\n  ...\n  297  #else\n  298  static const char *\n  299: lookup_gname_helper(struct name_cache *cache, id_t id)\n  300  {\n  301: \tstruct group\t*result;\n  302  \t(void)cache; /* UNUSED */\n  303  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_random.c:\n  137  #endif\t\t\t\t/* !__GNUC__ */\n  138  \n  139: struct arc4_stream {\n  140  \tuint8_t i;\n  141  \tuint8_t j;\n  ...\n  155  \n  156  static int rs_initialized;\n  157: static struct arc4_stream rs;\n  158  static pid_t arc4_stir_pid;\n  159  static int arc4_count;\n  ...\n  194  {\n  195  \tint done, fd, i;\n  196: \tstruct {\n  197: \t\tstruct timeval\ttv;\n  198  \t\tpid_t\t\tpid;\n  199  \t\tuint8_t\t\trnd[KEYSIZE];\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_cpio_binary.c:\n   46  #include \"archive_write_set_format_private.h\"\n   47  \n   48: static ssize_t\tarchive_write_binary_data(struct archive_write *,\n   49  \t\t    const void *buff, size_t s);\n   50: static int\tarchive_write_binary_close(struct archive_write *);\n   51: static int\tarchive_write_binary_free(struct archive_write *);\n   52: static int\tarchive_write_binary_finish_entry(struct archive_write *);\n   53: static int\tarchive_write_binary_header(struct archive_write *,\n   54: \t\t    struct archive_entry *);\n   55: static int\tarchive_write_binary_options(struct archive_write *,\n   56  \t\t    const char *, const char *);\n   57: static int\twrite_header(struct archive_write *, struct archive_entry *);\n   58  \n   59: struct cpio {\n   60  \tuint64_t\t  entry_bytes_remaining;\n   61  \n   62  \tint64_t\t\t  ino_next;\n   63  \n   64: \tstruct\t\t { int64_t old; int new;} *ino_list;\n   65  \tsize_t\t\t  ino_list_size;\n   66  \tsize_t\t\t  ino_list_next;\n   67  \n   68: \tstruct archive_string_conv *opt_sconv;\n   69: \tstruct archive_string_conv *sconv_default;\n   70  \tint\t\t  init_default_conversion;\n   71  };\n   72  \n   73: /* This struct needs to be packed to get the header right */\n   74  \n   75  #if defined(__GNUC__)\n   ..\n   83  #define HSIZE 26\n   84  \n   85: PACKED(struct cpio_binary_header {\n   86  \tuint16_t\th_magic;\n   87  \tuint16_t\th_dev;\n   ..\n  169   */\n  170  static int\n  171: archive_write_set_format_cpio_binary(struct archive *_a, int format)\n  172  {\n  173: \tstruct archive_write *a = (struct archive_write *)_a;\n  174: \tstruct cpio *cpio;\n  175  \n  176: \tif (sizeof(struct cpio_binary_header) != HSIZE) {\n  177  \t\tarchive_set_error(&a->archive, EINVAL,\n  178  \t\t\t\t  \"Binary cpio format not supported on this platform\");\n  ...\n  187  \t\t(a->format_free)(a);\n  188  \n  189: \tcpio = (struct cpio *)calloc(1, sizeof(*cpio));\n  190  \tif (cpio == NULL) {\n  191  \t\tarchive_set_error(&a->archive, ENOMEM, \"Can't allocate cpio data\");\n  ...\n  219   */\n  220  int\n  221: archive_write_set_format_cpio_pwb(struct archive *_a)\n  222  {\n  223  \treturn archive_write_set_format_cpio_binary(_a, ARCHIVE_FORMAT_CPIO_PWB);\n  ...\n  228   */\n  229  int\n  230: archive_write_set_format_cpio_bin(struct archive *_a)\n  231  {\n  232  \treturn archive_write_set_format_cpio_binary(_a, ARCHIVE_FORMAT_CPIO_BIN_LE);\n  ...\n  234  \n  235  static int\n  236: archive_write_binary_options(struct archive_write *a, const char *key,\n  237      const char *val)\n  238  {\n  239: \tstruct cpio *cpio = (struct cpio *)a->format_data;\n  240  \tint ret = ARCHIVE_FAILED;\n  241  \n  ...\n  277   */\n  278  static int\n  279: synthesize_ino_value(struct cpio *cpio, struct archive_entry *entry)\n  280  {\n  281  \tint64_t ino = archive_entry_ino64(entry);\n  ...\n  328  \n  329  \n  330: static struct archive_string_conv *\n  331: get_sconv(struct archive_write *a)\n  332  {\n  333: \tstruct cpio *cpio;\n  334: \tstruct archive_string_conv *sconv;\n  335  \n  336: \tcpio = (struct cpio *)a->format_data;\n  337  \tsconv = cpio->opt_sconv;\n  338  \tif (sconv == NULL) {\n  ...\n  349  \n  350  static int\n  351: archive_write_binary_header(struct archive_write *a, struct archive_entry *entry)\n  352  {\n  353  \tconst char *path;\n  ...\n  378  \n  379  static int\n  380: write_header(struct archive_write *a, struct archive_entry *entry)\n  381  {\n  382: \tstruct cpio *cpio;\n  383  \tconst char *p, *path;\n  384  \tint pathlength, ret, ret_final;\n  385  \tint64_t\tino;\n  386: \tstruct cpio_binary_header h;\n  387: \tstruct archive_string_conv *sconv;\n  388: \tstruct archive_entry *entry_main;\n  389  \tsize_t len;\n  390  \n  391: \tcpio = (struct cpio *)a->format_data;\n  392  \tret_final = ARCHIVE_OK;\n  393  \tsconv = get_sconv(a);\n  ...\n  555  \n  556  static ssize_t\n  557: archive_write_binary_data(struct archive_write *a, const void *buff, size_t s)\n  558  {\n  559: \tstruct cpio *cpio;\n  560  \tint ret;\n  561  \n  562: \tcpio = (struct cpio *)a->format_data;\n  563  \tif (s > cpio->entry_bytes_remaining)\n  564  \t\ts = (size_t)cpio->entry_bytes_remaining;\n  ...\n  573  \n  574  static int\n  575: archive_write_binary_close(struct archive_write *a)\n  576  {\n  577  \tint er;\n  578: \tstruct archive_entry *trailer;\n  579  \n  580  \ttrailer = archive_entry_new2(NULL);\n  ...\n  589  \n  590  static int\n  591: archive_write_binary_free(struct archive_write *a)\n  592  {\n  593: \tstruct cpio *cpio;\n  594  \n  595: \tcpio = (struct cpio *)a->format_data;\n  596  \tfree(cpio->ino_list);\n  597  \tfree(cpio);\n  ...\n  601  \n  602  static int\n  603: archive_write_binary_finish_entry(struct archive_write *a)\n  604  {\n  605: \tstruct cpio *cpio;\n  606  \n  607: \tcpio = (struct cpio *)a->format_data;\n  608  \treturn (__archive_write_nulls(a,\n  609  \t\t(size_t)cpio->entry_bytes_remaining));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_all.c:\n   33  /* Deprecated; remove in libarchive 4.0 */\n   34  int\n   35: archive_read_support_compression_all(struct archive *a)\n   36  {\n   37  \treturn archive_read_support_filter_all(a);\n   ..\n   40  \n   41  int\n   42: archive_read_support_filter_all(struct archive *a)\n   43  {\n   44  \tarchive_check_magic(a, ARCHIVE_READ_MAGIC,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/xxhash.c:\n  101  static XXH_errorcode\t  XXH32_resetState(void*, unsigned int);\n  102  #define       XXH32_SIZEOFSTATE 48\n  103: typedef struct { long long ll[(XXH32_SIZEOFSTATE+(sizeof(long long)-1))/sizeof(long long)]; } XXH32_stateSpace_t;\n  104  static unsigned int\t  XXH32_intermediateDigest (void*);\n  105  \n  ...\n  136  #endif\n  137  \n  138: typedef struct _U32_S { U32 v; } _PACKED U32_S;\n  139  \n  140  #if !defined(XXH_USE_UNALIGNED_ACCESS) && !defined(__GNUC__)\n  ...\n  319  ******************************/\n  320  \n  321: struct XXH_state32_t\n  322  {\n  323      U64 total_len;\n  ...\n  335  int XXH32_sizeofState(void)\n  336  {\n  337:     XXH_STATIC_ASSERT(XXH32_SIZEOFSTATE >= sizeof(struct XXH_state32_t));   /* A compilation error here means XXH32_SIZEOFSTATE is not large enough */\n  338:     return sizeof(struct XXH_state32_t);\n  339  }\n  340  #endif\n  ...\n  343  XXH_errorcode XXH32_resetState(void* state_in, U32 seed)\n  344  {\n  345:     struct XXH_state32_t * state = (struct XXH_state32_t *) state_in;\n  346      state->seed = seed;\n  347      state->v1 = seed + PRIME32_1 + PRIME32_2;\n  ...\n  357  void* XXH32_init (U32 seed)\n  358  {\n  359:     void* state = XXH_malloc (sizeof(struct XXH_state32_t));\n  360      XXH32_resetState(state, seed);\n  361      return state;\n  ...\n  365  FORCE_INLINE XXH_errorcode XXH32_update_endian (void* state_in, const void* input, int len, XXH_endianess endian)\n  366  {\n  367:     struct XXH_state32_t * state = (struct XXH_state32_t *) state_in;\n  368      const BYTE* p = (const BYTE*)input;\n  369      const BYTE* const bEnd = p + len;\n  ...\n  443  FORCE_INLINE U32 XXH32_intermediateDigest_endian (void* state_in, XXH_endianess endian)\n  444  {\n  445:     struct XXH_state32_t * state = (struct XXH_state32_t *) state_in;\n  446      const BYTE * p = (const BYTE*)state->memory;\n  447      BYTE* bEnd = (BYTE*)state->memory + state->memsize;\n  ...\n  504  \n  505  const\n  506: struct archive_xxhash __archive_xxhash = {\n  507  \tXXH32,\n  508  \tXXH32_init,\n  ...\n  513  \n  514  /*\n  515:  * Define an empty version of the struct if we aren't using the LZ4 library.\n  516   */\n  517  const\n  518: struct archive_xxhash __archive_xxhash = {\n  519  \tNULL,\n  520  \tNULL,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_open_fd.c:\n   51  #include \"archive.h\"\n   52  \n   53: struct write_fd_data {\n   54  \tint\t\tfd;\n   55  };\n   56  \n   57: static int\tfile_free(struct archive *, void *);\n   58: static int\tfile_open(struct archive *, void *);\n   59: static ssize_t\tfile_write(struct archive *, void *, const void *buff, size_t);\n   60  \n   61  int\n   62: archive_write_open_fd(struct archive *a, int fd)\n   63  {\n   64: \tstruct write_fd_data *mine;\n   65  \n   66: \tmine = (struct write_fd_data *)malloc(sizeof(*mine));\n   67  \tif (mine == NULL) {\n   68  \t\tarchive_set_error(a, ENOMEM, \"No memory\");\n   ..\n   78  \n   79  static int\n   80: file_open(struct archive *a, void *client_data)\n   81  {\n   82: \tstruct write_fd_data *mine;\n   83: \tstruct stat st;\n   84  \n   85: \tmine = (struct write_fd_data *)client_data;\n   86  \n   87  \tif (fstat(mine->fd, &st) != 0) {\n   ..\n  116  \n  117  static ssize_t\n  118: file_write(struct archive *a, void *client_data, const void *buff, size_t length)\n  119  {\n  120: \tstruct write_fd_data\t*mine;\n  121  \tssize_t\tbytesWritten;\n  122  \n  123: \tmine = (struct write_fd_data *)client_data;\n  124  \tfor (;;) {\n  125  \t\tbytesWritten = write(mine->fd, buff, length);\n  ...\n  135  \n  136  static int\n  137: file_free(struct archive *a, void *client_data)\n  138  {\n  139: \tstruct write_fd_data\t*mine = (struct write_fd_data *)client_data;\n  140  \n  141  \t(void)a; /* UNUSED */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_disk_set_standard_lookup.c:\n   51  #include \"archive_write_disk_private.h\"\n   52  \n   53: struct bucket {\n   54  \tchar\t*name;\n   55  \tint\t hash;\n   ..\n   83   */\n   84  int\n   85: archive_write_disk_set_standard_lookup(struct archive *a)\n   86  {\n   87: \tstruct bucket *ucache = calloc(cache_size, sizeof(struct bucket));\n   88: \tstruct bucket *gcache = calloc(cache_size, sizeof(struct bucket));\n   89  \tif (ucache == NULL || gcache == NULL) {\n   90  \t\tfree(ucache);\n   ..\n  101  {\n  102  \tint h;\n  103: \tstruct bucket *b;\n  104: \tstruct bucket *gcache = (struct bucket *)private_data;\n  105  \n  106  \t/* If no gname, just use the gid provided. */\n  ...\n  126  \t\tchar *buffer = _buffer;\n  127  \t\tchar *allocated = NULL;\n  128: \t\tstruct group\tgrent, *result;\n  129  \t\tint r;\n  130  \n  ...\n  149  #  else /* HAVE_GETGRNAM_R */\n  150  \t{\n  151: \t\tstruct group *result;\n  152  \n  153  \t\tresult = getgrnam(gname);\n  ...\n  170  {\n  171  \tint h;\n  172: \tstruct bucket *b;\n  173: \tstruct bucket *ucache = (struct bucket *)private_data;\n  174  \n  175  \t/* If no uname, just use the uid provided. */\n  ...\n  195  \t\tchar *buffer = _buffer;\n  196  \t\tchar *allocated = NULL;\n  197: \t\tstruct passwd\tpwent, *result;\n  198  \t\tint r;\n  199  \n  ...\n  218  #  else /* HAVE_GETPWNAM_R */\n  219  \t{\n  220: \t\tstruct passwd *result;\n  221  \n  222  \t\tresult = getpwnam(uname);\n  ...\n  239  {\n  240  \tsize_t i;\n  241: \tstruct bucket *cache = (struct bucket *)private;\n  242  \n  243  \tfor (i = 0; i < cache_size; i++)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_util.c:\n   70  static int archive_utility_string_sort_helper(char **, unsigned int);\n   71  \n   72: /* Generic initialization of 'struct archive' objects. */\n   73  int\n   74: __archive_clean(struct archive *a)\n   75  {\n   76  \tarchive_string_conversion_free(a);\n   ..\n   91  \n   92  int\n   93: archive_errno(struct archive *a)\n   94  {\n   95  \treturn (a->archive_error_number);\n   ..\n   97  \n   98  const char *\n   99: archive_error_string(struct archive *a)\n  100  {\n  101  \n  ...\n  107  \n  108  int\n  109: archive_file_count(struct archive *a)\n  110  {\n  111  \treturn (a->file_count);\n  ...\n  113  \n  114  int\n  115: archive_format(struct archive *a)\n  116  {\n  117  \treturn (a->archive_format);\n  ...\n  119  \n  120  const char *\n  121: archive_format_name(struct archive *a)\n  122  {\n  123  \treturn (a->archive_format_name);\n  ...\n  126  \n  127  int\n  128: archive_compression(struct archive *a)\n  129  {\n  130  \treturn archive_filter_code(a, 0);\n  ...\n  132  \n  133  const char *\n  134: archive_compression_name(struct archive *a)\n  135  {\n  136  \treturn archive_filter_name(a, 0);\n  ...\n  142   */\n  143  la_int64_t\n  144: archive_position_compressed(struct archive *a)\n  145  {\n  146  \treturn archive_filter_bytes(a, -1);\n  ...\n  151   */\n  152  la_int64_t\n  153: archive_position_uncompressed(struct archive *a)\n  154  {\n  155  \treturn archive_filter_bytes(a, 0);\n  ...\n  157  \n  158  void\n  159: archive_clear_error(struct archive *a)\n  160  {\n  161  \tarchive_string_empty(&a->error_string);\n  ...\n  165  \n  166  void\n  167: archive_set_error(struct archive *a, int error_number, const char *fmt, ...)\n  168  {\n  169  \tva_list ap;\n  ...\n  183  \n  184  void\n  185: archive_copy_error(struct archive *dest, struct archive *src)\n  186  {\n  187  \tdest->archive_error_number = src->archive_error_number;\n  ...\n  235  \t};\n  236  \tHCRYPTPROV hProv;\n  237: \tstruct archive_wstring temp_name;\n  238  \twchar_t *ws;\n  239  \tDWORD attr;\n  ...\n  396  \n  397  static int\n  398: get_tempdir(struct archive_string *temppath)\n  399  {\n  400  \tconst char *tmp;\n  ...\n  422  __archive_mktemp(const char *tmpdir)\n  423  {\n  424: \tstruct archive_string temp_name;\n  425  \tint fd = -1;\n  426  \n  ...\n  479  \t\t'u', 'v', 'w', 'x', 'y', 'z'\n  480          };\n  481: \tstruct archive_string temp_name;\n  482: \tstruct stat st;\n  483  \tint fd;\n  484  \tchar *tp, *ep;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_check_magic.c:\n  128   */\n  129  int\n  130: __archive_check_magic(struct archive *a, unsigned int magic,\n  131      unsigned int state, const char *function)\n  132  {\n  ...\n  164  \t\t\tarchive_set_error(a, -1,\n  165  \t\t\t    \"INTERNAL ERROR: Function '%s' invoked with\"\n  166: \t\t\t    \" archive structure in state '%s',\"\n  167  \t\t\t    \" should be in state '%s'\",\n  168  \t\t\t    function,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_xar.c:\n   70   */\n   71  int\n   72: archive_read_support_format_xar(struct archive *_a)\n   73  {\n   74: \tstruct archive_read *a = (struct archive_read *)_a;\n   75  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n   76  \t    ARCHIVE_STATE_NEW, \"archive_read_support_format_xar\");\n   ..\n  117  };\n  118  \n  119: struct chksumval {\n  120  \tint\t\t\t alg;\n  121  \tsize_t\t\t\t len;\n  ...\n  123  };\n  124  \n  125: struct chksumwork {\n  126  \tint\t\t\t alg;\n  127  #ifdef ARCHIVE_HAS_MD5\n  ...\n  133  };\n  134  \n  135: struct xattr {\n  136: \tstruct xattr\t\t*next;\n  137: \tstruct archive_string\t name;\n  138  \tuint64_t\t\t id;\n  139  \tuint64_t\t\t length;\n  ...\n  141  \tuint64_t\t\t size;\n  142  \tenum enctype\t\t encoding;\n  143: \tstruct chksumval\t a_sum;\n  144: \tstruct chksumval\t e_sum;\n  145: \tstruct archive_string\t fstype;\n  146  };\n  147  \n  148: struct xar_file {\n  149: \tstruct xar_file\t\t*next;\n  150: \tstruct xar_file\t\t*hdnext;\n  151: \tstruct xar_file\t\t*parent;\n  152  \tint\t\t\t subdirs;\n  153  \n  ...\n  177  \tuint64_t\t\t size;\n  178  \tenum enctype\t\t encoding;\n  179: \tstruct chksumval\t a_sum;\n  180: \tstruct chksumval\t e_sum;\n  181: \tstruct archive_string\t pathname;\n  182: \tstruct archive_string\t symlink;\n  183  \ttime_t\t\t\t ctime;\n  184  \ttime_t\t\t\t mtime;\n  185  \ttime_t\t\t\t atime;\n  186: \tstruct archive_string\t uname;\n  187  \tint64_t\t\t\t uid;\n  188: \tstruct archive_string\t gname;\n  189  \tint64_t\t\t\t gid;\n  190  \tmode_t\t\t\t mode;\n  ...\n  193  \tdev_t\t\t\t devminor;\n  194  \tint64_t\t\t\t ino64;\n  195: \tstruct archive_string\t fflags_text;\n  196  \tunsigned int\t\t link;\n  197  \tunsigned int\t\t nlink;\n  198: \tstruct archive_string\t hardlink;\n  199: \tstruct xattr\t\t*xattr_list;\n  200  };\n  201  \n  202: struct hdlink {\n  203: \tstruct hdlink\t\t *next;\n  204  \n  205  \tunsigned int\t\t id;\n  206  \tint\t\t\t cnt;\n  207: \tstruct xar_file\t\t *files;\n  208  };\n  209  \n  210: struct heap_queue {\n  211: \tstruct xar_file\t\t**files;\n  212  \tint\t\t\t allocated;\n  213  \tint\t\t\t used;\n  ...\n  297  };\n  298  \n  299: struct unknown_tag {\n  300: \tstruct unknown_tag\t*next;\n  301: \tstruct archive_string\t name;\n  302  };\n  303  \n  304: struct xar {\n  305  \tuint64_t\t\t offset; /* Current position in the file. */\n  306  \tint64_t\t\t\t total;\n  ...\n  312  \tenum xmlstatus\t\t xmlsts;\n  313  \tenum xmlstatus\t\t xmlsts_unknown;\n  314: \tstruct unknown_tag\t*unknowntags;\n  315  \tint\t\t\t base64text;\n  316  \n  ...\n  340  \t * For Checksum data.\n  341  \t */\n  342: \tstruct chksumwork\t a_sumwrk;\n  343: \tstruct chksumwork\t e_sumwrk;\n  344  \n  345: \tstruct xar_file\t\t*file;\t/* current reading file. */\n  346: \tstruct xattr\t\t*xattr; /* current reading extended attribute. */\n  347: \tstruct heap_queue\t file_queue;\n  348: \tstruct xar_file\t\t*hdlink_orgs;\n  349: \tstruct hdlink\t\t*hdlink_list;\n  350  \n  351  \tint\t \t\t entry_init;\n  ...\n  355  \tuint64_t\t\t entry_size;\n  356  \tenum enctype \t\t entry_encoding;\n  357: \tstruct chksumval\t entry_a_sum;\n  358: \tstruct chksumval\t entry_e_sum;\n  359  \n  360: \tstruct archive_string_conv *sconv;\n  361  };\n  362  \n  363: struct xmlattr {\n  364: \tstruct xmlattr\t*next;\n  365  \tchar\t\t*name;\n  366  \tchar\t\t*value;\n  367  };\n  368  \n  369: struct xmlattr_list {\n  370: \tstruct xmlattr\t*first;\n  371: \tstruct xmlattr\t**last;\n  372  };\n  373  \n  374: static int\txar_bid(struct archive_read *, int);\n  375: static int\txar_read_header(struct archive_read *,\n  376: \t\t    struct archive_entry *);\n  377: static int\txar_read_data(struct archive_read *,\n  378  \t\t    const void **, size_t *, int64_t *);\n  379: static int\txar_read_data_skip(struct archive_read *);\n  380: static int\txar_cleanup(struct archive_read *);\n  381: static int\tmove_reading_point(struct archive_read *, uint64_t);\n  382: static int\trd_contents_init(struct archive_read *,\n  383  \t\t    enum enctype, int, int);\n  384: static int\trd_contents(struct archive_read *, const void **,\n  385  \t\t    size_t *, size_t *, uint64_t);\n  386  static uint64_t\tatol10(const char *, size_t);\n  ...\n  388  static size_t\tatohex(unsigned char *, size_t, const char *, size_t);\n  389  static time_t\tparse_time(const char *p, size_t n);\n  390: static int\theap_add_entry(struct archive_read *a,\n  391:     struct heap_queue *, struct xar_file *);\n  392: static struct xar_file *heap_get_entry(struct heap_queue *);\n  393: static int\tadd_link(struct archive_read *,\n  394:     struct xar *, struct xar_file *);\n  395: static void\tchecksum_init(struct archive_read *, int, int);\n  396: static void\tchecksum_update(struct archive_read *, const void *,\n  397  \t\t    size_t, const void *, size_t);\n  398: static int\tchecksum_final(struct archive_read *, const void *,\n  399  \t\t    size_t, const void *, size_t);\n  400: static void\tchecksum_cleanup(struct archive_read *);\n  401: static int\tdecompression_init(struct archive_read *, enum enctype);\n  402: static int\tdecompress(struct archive_read *, const void **,\n  403  \t\t    size_t *, const void *, size_t *);\n  404: static int\tdecompression_cleanup(struct archive_read *);\n  405: static void\txmlattr_cleanup(struct xmlattr_list *);\n  406: static int\tfile_new(struct archive_read *,\n  407:     struct xar *, struct xmlattr_list *);\n  408: static void\tfile_free(struct xar_file *);\n  409: static int\txattr_new(struct archive_read *,\n  410:     struct xar *, struct xmlattr_list *);\n  411: static void\txattr_free(struct xattr *);\n  412: static int\tgetencoding(struct xmlattr_list *);\n  413: static int\tgetsumalgorithm(struct xmlattr_list *);\n  414: static int\tunknowntag_start(struct archive_read *,\n  415:     struct xar *, const char *);\n  416: static void\tunknowntag_end(struct xar *, const char *);\n  417: static int\txml_start(struct archive_read *,\n  418:     const char *, struct xmlattr_list *);\n  419  static void\txml_end(void *, const char *);\n  420  static void\txml_data(void *, const char *, int);\n  421: static int\txml_parse_file_flags(struct xar *, const char *);\n  422: static int\txml_parse_file_ext2(struct xar *, const char *);\n  423  #if defined(HAVE_LIBXML_XMLREADER_H)\n  424: static int\txml2_xmlattr_setup(struct archive_read *,\n  425:     struct xmlattr_list *, xmlTextReaderPtr);\n  426  static int\txml2_read_cb(void *, char *, int);\n  427  static int\txml2_close_cb(void *);\n  428  static void\txml2_error_hdr(void *, const char *, xmlParserSeverities,\n  429  \t\t    xmlTextReaderLocatorPtr);\n  430: static int\txml2_read_toc(struct archive_read *);\n  431  #elif defined(HAVE_BSDXML_H) || defined(HAVE_EXPAT_H)\n  432: struct expat_userData {\n  433  \tint state;\n  434: \tstruct archive_read *archive;\n  435  };\n  436: static int\texpat_xmlattr_setup(struct archive_read *,\n  437:     struct xmlattr_list *, const XML_Char **);\n  438  static void\texpat_start_cb(void *, const XML_Char *, const XML_Char **);\n  439  static void\texpat_end_cb(void *, const XML_Char *);\n  440  static void\texpat_data_cb(void *, const XML_Char *, int);\n  441: static int\texpat_read_toc(struct archive_read *);\n  442  #endif\n  443  \n  444  int\n  445: archive_read_support_format_xar(struct archive *_a)\n  446  {\n  447: \tstruct xar *xar;\n  448: \tstruct archive_read *a = (struct archive_read *)_a;\n  449  \tint r;\n  450  \n  ...\n  452  \t    ARCHIVE_STATE_NEW, \"archive_read_support_format_xar\");\n  453  \n  454: \txar = (struct xar *)calloc(1, sizeof(*xar));\n  455  \tif (xar == NULL) {\n  456  \t\tarchive_set_error(&a->archive, ENOMEM,\n  ...\n  482  \n  483  static int\n  484: xar_bid(struct archive_read *a, int best_bid)\n  485  {\n  486  \tconst unsigned char *b;\n  ...\n  529  \n  530  static int\n  531: read_toc(struct archive_read *a)\n  532  {\n  533: \tstruct xar *xar;\n  534: \tstruct xar_file *file;\n  535  \tconst unsigned char *b;\n  536  \tuint64_t toc_compressed_size;\n  ...\n  540  \tint r;\n  541  \n  542: \txar = (struct xar *)(a->format->data);\n  543  \n  544  \t/*\n  ...\n  632  \t */\n  633  \tfor (file = xar->hdlink_orgs; file != NULL; file = file->hdnext) {\n  634: \t\tstruct hdlink **hdlink;\n  635  \n  636  \t\tfor (hdlink = &(xar->hdlink_list); *hdlink != NULL;\n  637  \t\t    hdlink = &((*hdlink)->next)) {\n  638  \t\t\tif ((*hdlink)->id == file->id) {\n  639: \t\t\t\tstruct hdlink *hltmp;\n  640: \t\t\t\tstruct xar_file *f2;\n  641  \t\t\t\tint nlink = (*hdlink)->cnt + 1;\n  642  \n  ...\n  663  \n  664  static int\n  665: xar_read_header(struct archive_read *a, struct archive_entry *entry)\n  666  {\n  667: \tstruct xar *xar;\n  668: \tstruct xar_file *file;\n  669: \tstruct xattr *xattr;\n  670  \tint r;\n  671  \n  672: \txar = (struct xar *)(a->format->data);\n  673  \tr = ARCHIVE_OK;\n  674  \n  ...\n  860  \n  861  static int\n  862: xar_read_data(struct archive_read *a,\n  863      const void **buff, size_t *size, int64_t *offset)\n  864  {\n  865: \tstruct xar *xar;\n  866  \tsize_t used = 0;\n  867  \tint r;\n  868  \n  869: \txar = (struct xar *)(a->format->data);\n  870  \n  871  \tif (xar->entry_unconsumed) {\n  ...\n  924  \n  925  static int\n  926: xar_read_data_skip(struct archive_read *a)\n  927  {\n  928: \tstruct xar *xar;\n  929  \tint64_t bytes_skipped;\n  930  \n  931: \txar = (struct xar *)(a->format->data);\n  932  \tif (xar->end_of_file)\n  933  \t\treturn (ARCHIVE_EOF);\n  ...\n  942  \n  943  static int\n  944: xar_cleanup(struct archive_read *a)\n  945  {\n  946: \tstruct xar *xar;\n  947: \tstruct hdlink *hdlink;\n  948  \tint i;\n  949  \tint r;\n  950  \n  951: \txar = (struct xar *)(a->format->data);\n  952  \tchecksum_cleanup(a);\n  953  \tr = decompression_cleanup(a);\n  954  \thdlink = xar->hdlink_list;\n  955  \twhile (hdlink != NULL) {\n  956: \t\tstruct hdlink *next = hdlink->next;\n  957  \n  958  \t\tfree(hdlink);\n  ...\n  963  \tfree(xar->file_queue.files);\n  964  \twhile (xar->unknowntags != NULL) {\n  965: \t\tstruct unknown_tag *tag;\n  966  \n  967  \t\ttag = xar->unknowntags;\n  ...\n  977  \n  978  static int\n  979: move_reading_point(struct archive_read *a, uint64_t offset)\n  980  {\n  981: \tstruct xar *xar;\n  982  \n  983: \txar = (struct xar *)(a->format->data);\n  984  \tif (xar->offset - xar->h_base != offset) {\n  985  \t\t/* Seek forward to the start of file contents. */\n  ...\n 1007  \n 1008  static int\n 1009: rd_contents_init(struct archive_read *a, enum enctype encoding,\n 1010      int a_sum_alg, int e_sum_alg)\n 1011  {\n ....\n 1021  \n 1022  static int\n 1023: rd_contents(struct archive_read *a, const void **buff, size_t *size,\n 1024      size_t *used, uint64_t remaining)\n 1025  {\n ....\n 1134  \n 1135  static time_t\n 1136: time_from_tm(struct tm *t)\n 1137  {\n 1138  #if HAVE_TIMEGM\n ....\n 1160  parse_time(const char *p, size_t n)\n 1161  {\n 1162: \tstruct tm tm;\n 1163  \ttime_t t = 0;\n 1164  \tint64_t data;\n ....\n 1218  \n 1219  static int\n 1220: heap_add_entry(struct archive_read *a,\n 1221:     struct heap_queue *heap, struct xar_file *file)\n 1222  {\n 1223  \tuint64_t file_id, parent_id;\n ....\n 1226  \t/* Expand our pending files list as necessary. */\n 1227  \tif (heap->used >= heap->allocated) {\n 1228: \t\tstruct xar_file **new_pending_files;\n 1229  \t\tint new_size;\n 1230  \n ....\n 1239  \t\t\treturn (ARCHIVE_FATAL);\n 1240  \t\t}\n 1241: \t\tnew_pending_files = (struct xar_file **)\n 1242  \t\t    malloc(new_size * sizeof(new_pending_files[0]));\n 1243  \t\tif (new_pending_files == NULL) {\n ....\n 1277  }\n 1278  \n 1279: static struct xar_file *\n 1280: heap_get_entry(struct heap_queue *heap)\n 1281  {\n 1282  \tuint64_t a_id, b_id, c_id;\n 1283  \tint a, b, c;\n 1284: \tstruct xar_file *r, *tmp;\n 1285  \n 1286  \tif (heap->used < 1)\n ....\n 1325  \n 1326  static int\n 1327: add_link(struct archive_read *a, struct xar *xar, struct xar_file *file)\n 1328  {\n 1329: \tstruct hdlink *hdlink;\n 1330  \n 1331  \tfor (hdlink = xar->hdlink_list; hdlink != NULL; hdlink = hdlink->next) {\n ....\n 1352  \n 1353  static void\n 1354: _checksum_init(struct chksumwork *sumwrk, int sum_alg)\n 1355  {\n 1356  \tsumwrk->alg = sum_alg;\n ....\n 1368  \n 1369  static void\n 1370: _checksum_update(struct chksumwork *sumwrk, const void *buff, size_t size)\n 1371  {\n 1372  \n ....\n 1384  \n 1385  static int\n 1386: _checksum_final(struct chksumwork *sumwrk, const void *val, size_t len)\n 1387  {\n 1388  \tunsigned char sum[MAX_SUM_SIZE];\n ....\n 1409  \n 1410  static void\n 1411: checksum_init(struct archive_read *a, int a_sum_alg, int e_sum_alg)\n 1412  {\n 1413: \tstruct xar *xar;\n 1414  \n 1415: \txar = (struct xar *)(a->format->data);\n 1416  \t_checksum_init(&(xar->a_sumwrk), a_sum_alg);\n 1417  \t_checksum_init(&(xar->e_sumwrk), e_sum_alg);\n ....\n 1419  \n 1420  static void\n 1421: checksum_update(struct archive_read *a, const void *abuff, size_t asize,\n 1422      const void *ebuff, size_t esize)\n 1423  {\n 1424: \tstruct xar *xar;\n 1425  \n 1426: \txar = (struct xar *)(a->format->data);\n 1427  \t_checksum_update(&(xar->a_sumwrk), abuff, asize);\n 1428  \t_checksum_update(&(xar->e_sumwrk), ebuff, esize);\n ....\n 1430  \n 1431  static int\n 1432: checksum_final(struct archive_read *a, const void *a_sum_val,\n 1433      size_t a_sum_len, const void *e_sum_val, size_t e_sum_len)\n 1434  {\n 1435: \tstruct xar *xar;\n 1436  \tint r;\n 1437  \n 1438: \txar = (struct xar *)(a->format->data);\n 1439  \tr = _checksum_final(&(xar->a_sumwrk), a_sum_val, a_sum_len);\n 1440  \tif (r == ARCHIVE_OK)\n ....\n 1447  \n 1448  static int\n 1449: decompression_init(struct archive_read *a, enum enctype encoding)\n 1450  {\n 1451: \tstruct xar *xar;\n 1452  \tconst char *detail;\n 1453  \tint r;\n 1454  \n 1455: \txar = (struct xar *)(a->format->data);\n 1456  \txar->rd_encoding = encoding;\n 1457  \tswitch (encoding) {\n ....\n 1586  \n 1587  static int\n 1588: decompress(struct archive_read *a, const void **buff, size_t *outbytes,\n 1589      const void *b, size_t *used)\n 1590  {\n 1591: \tstruct xar *xar;\n 1592  \tvoid *outbuff;\n 1593  \tsize_t avail_in, avail_out;\n 1594  \tint r;\n 1595  \n 1596: \txar = (struct xar *)(a->format->data);\n 1597  \tavail_in = *used;\n 1598  \toutbuff = (void *)(uintptr_t)*buff;\n ....\n 1715  \n 1716  static int\n 1717: decompression_cleanup(struct archive_read *a)\n 1718  {\n 1719: \tstruct xar *xar;\n 1720  \tint r;\n 1721  \n 1722: \txar = (struct xar *)(a->format->data);\n 1723  \tr = ARCHIVE_OK;\n 1724  \tif (xar->stream_valid) {\n ....\n 1757  \n 1758  static void\n 1759: checksum_cleanup(struct archive_read *a) {\n 1760: \tstruct xar *xar;\n 1761  \n 1762: \txar = (struct xar *)(a->format->data);\n 1763  \n 1764  \t_checksum_final(&(xar->a_sumwrk), NULL, 0);\n ....\n 1767  \n 1768  static void\n 1769: xmlattr_cleanup(struct xmlattr_list *list)\n 1770  {\n 1771: \tstruct xmlattr *attr, *next;\n 1772  \n 1773  \tattr = list->first;\n ....\n 1784  \n 1785  static int\n 1786: file_new(struct archive_read *a, struct xar *xar, struct xmlattr_list *list)\n 1787  {\n 1788: \tstruct xar_file *file;\n 1789: \tstruct xmlattr *attr;\n 1790  \n 1791  \tfile = calloc(1, sizeof(*file));\n ....\n 1811  \n 1812  static void\n 1813: file_free(struct xar_file *file)\n 1814  {\n 1815: \tstruct xattr *xattr;\n 1816  \n 1817  \tarchive_string_free(&(file->pathname));\n ....\n 1822  \txattr = file->xattr_list;\n 1823  \twhile (xattr != NULL) {\n 1824: \t\tstruct xattr *next;\n 1825  \n 1826  \t\tnext = xattr->next;\n ....\n 1833  \n 1834  static int\n 1835: xattr_new(struct archive_read *a, struct xar *xar, struct xmlattr_list *list)\n 1836  {\n 1837: \tstruct xattr *xattr, **nx;\n 1838: \tstruct xmlattr *attr;\n 1839  \n 1840  \txattr = calloc(1, sizeof(*xattr));\n ....\n 1861  \n 1862  static void\n 1863: xattr_free(struct xattr *xattr)\n 1864  {\n 1865  \tarchive_string_free(&(xattr->name));\n ....\n 1868  \n 1869  static int\n 1870: getencoding(struct xmlattr_list *list)\n 1871  {\n 1872: \tstruct xmlattr *attr;\n 1873  \tenum enctype encoding = NONE;\n 1874  \n ....\n 1891  \n 1892  static int\n 1893: getsumalgorithm(struct xmlattr_list *list)\n 1894  {\n 1895: \tstruct xmlattr *attr;\n 1896  \tint alg = CKSUM_NONE;\n 1897  \n ....\n 1914  \n 1915  static int\n 1916: unknowntag_start(struct archive_read *a, struct xar *xar, const char *name)\n 1917  {\n 1918: \tstruct unknown_tag *tag;\n 1919  \n 1920  \ttag = malloc(sizeof(*tag));\n ....\n 1938  \n 1939  static void\n 1940: unknowntag_end(struct xar *xar, const char *name)\n 1941  {\n 1942: \tstruct unknown_tag *tag;\n 1943  \n 1944  \ttag = xar->unknowntags;\n ....\n 1959  \n 1960  static int\n 1961: xml_start(struct archive_read *a, const char *name, struct xmlattr_list *list)\n 1962  {\n 1963: \tstruct xar *xar;\n 1964: \tstruct xmlattr *attr;\n 1965  \n 1966: \txar = (struct xar *)(a->format->data);\n 1967  \n 1968  #if DEBUG\n ....\n 2242  xml_end(void *userData, const char *name)\n 2243  {\n 2244: \tstruct archive_read *a;\n 2245: \tstruct xar *xar;\n 2246  \n 2247: \ta = (struct archive_read *)userData;\n 2248: \txar = (struct xar *)(a->format->data);\n 2249  \n 2250  #if DEBUG\n ....\n 2608  \n 2609  static void\n 2610: strappend_base64(struct xar *xar,\n 2611:     struct archive_string *as, const char *s, size_t l)\n 2612  {\n 2613  \tunsigned char buff[256];\n ....\n 2668  xml_data(void *userData, const char *s, int len)\n 2669  {\n 2670: \tstruct archive_read *a;\n 2671: \tstruct xar *xar;\n 2672  \n 2673: \ta = (struct archive_read *)userData;\n 2674: \txar = (struct xar *)(a->format->data);\n 2675  \n 2676  #if DEBUG\n ....\n 2903   */\n 2904  static int\n 2905: xml_parse_file_flags(struct xar *xar, const char *name)\n 2906  {\n 2907  \tconst char *flag = NULL;\n ....\n 2961   */\n 2962  static int\n 2963: xml_parse_file_ext2(struct xar *xar, const char *name)\n 2964  {\n 2965  \tconst char *flag = NULL;\n ....\n 3057  \n 3058  static int\n 3059: xml2_xmlattr_setup(struct archive_read *a,\n 3060:     struct xmlattr_list *list, xmlTextReaderPtr reader)\n 3061  {\n 3062: \tstruct xmlattr *attr;\n 3063  \tint r;\n 3064  \n ....\n 3098  xml2_read_cb(void *context, char *buffer, int len)\n 3099  {\n 3100: \tstruct archive_read *a;\n 3101: \tstruct xar *xar;\n 3102  \tconst void *d;\n 3103  \tsize_t outbytes;\n ....\n 3105  \tint r;\n 3106  \n 3107: \ta = (struct archive_read *)context;\n 3108: \txar = (struct xar *)(a->format->data);\n 3109  \n 3110  \tif (xar->toc_remaining <= 0)\n ....\n 3136      xmlTextReaderLocatorPtr locator)\n 3137  {\n 3138: \tstruct archive_read *a;\n 3139  \n 3140  \t(void)locator; /* UNUSED */\n 3141: \ta = (struct archive_read *)arg;\n 3142  \tswitch (severity) {\n 3143  \tcase XML_PARSER_SEVERITY_VALIDITY_WARNING:\n ....\n 3155  \n 3156  static int\n 3157: xml2_read_toc(struct archive_read *a)\n 3158  {\n 3159  \txmlTextReaderPtr reader;\n 3160: \tstruct xmlattr_list list;\n 3161  \tint r;\n 3162  \n ....\n 3210  \n 3211  static int\n 3212: expat_xmlattr_setup(struct archive_read *a,\n 3213:     struct xmlattr_list *list, const XML_Char **atts)\n 3214  {\n 3215: \tstruct xmlattr *attr;\n 3216  \tchar *name, *value;\n 3217  \n ....\n 3244  expat_start_cb(void *userData, const XML_Char *name, const XML_Char **atts)\n 3245  {\n 3246: \tstruct expat_userData *ud = (struct expat_userData *)userData;\n 3247: \tstruct archive_read *a = ud->archive;\n 3248: \tstruct xmlattr_list list;\n 3249  \tint r;\n 3250  \n ....\n 3259  expat_end_cb(void *userData, const XML_Char *name)\n 3260  {\n 3261: \tstruct expat_userData *ud = (struct expat_userData *)userData;\n 3262  \n 3263  \txml_end(ud->archive, (const char *)name);\n ....\n 3267  expat_data_cb(void *userData, const XML_Char *s, int len)\n 3268  {\n 3269: \tstruct expat_userData *ud = (struct expat_userData *)userData;\n 3270  \n 3271  \txml_data(ud->archive, s, len);\n ....\n 3273  \n 3274  static int\n 3275: expat_read_toc(struct archive_read *a)\n 3276  {\n 3277: \tstruct xar *xar;\n 3278  \tXML_Parser parser;\n 3279: \tstruct expat_userData ud;\n 3280  \n 3281  \tud.state = ARCHIVE_OK;\n 3282  \tud.archive = a;\n 3283  \n 3284: \txar = (struct xar *)(a->format->data);\n 3285  \n 3286  \t/* Initialize XML Parser library. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format.c:\n   41  /* A table that maps format codes to functions. */\n   42  static const\n   43: struct { int code; int (*setter)(struct archive *); } codes[] =\n   44  {\n   45  \t{ ARCHIVE_FORMAT_7ZIP,\t\tarchive_write_set_format_7zip },\n   ..\n   68  \n   69  int\n   70: archive_write_set_format(struct archive *a, int code)\n   71  {\n   72  \tint i;\n   ..\n   82  \n   83  void\n   84: __archive_write_entry_filetype_unsupported(struct archive *a,\n   85:     struct archive_entry *entry, const char *format)\n   86  {\n   87  \tconst char *name = NULL;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_windows.h:\n  266  \n  267  /* Replacement POSIX function */\n  268: extern int\t __la_fstat(int fd, struct stat *st);\n  269: extern int\t __la_lstat(const char *path, struct stat *st);\n  270  #if defined(__LA_LSEEK_NEEDED)\n  271  extern __int64\t __la_lseek(int fd, __int64 offset, int whence);\n  ...\n  273  extern int\t __la_open(const char *path, int flags, ...);\n  274  extern ssize_t\t __la_read(int fd, void *buf, size_t nbytes);\n  275: extern int\t __la_stat(const char *path, struct stat *st);\n  276  extern pid_t\t __la_waitpid(HANDLE child, int *status, int option);\n  277  extern ssize_t\t __la_write(int fd, const void *buf, size_t nbytes);\n  ...\n  287  extern void __la_dosmaperr(unsigned long e);\n  288  #define la_dosmaperr(e) __la_dosmaperr(e)\n  289: extern struct archive_entry *__la_win_entry_in_posix_pathseparator(\n  290:     struct archive_entry *);\n  291  \n  292  #if defined(HAVE_WCRTOMB) && defined(__BORLANDC__)\n  ...\n  302         );\n  303  # if _WIN32_WINNT < 0x0500 /* windows.h not providing 0x500 API */\n  304: typedef struct _FILE_ALLOCATED_RANGE_BUFFER {\n  305         LARGE_INTEGER FileOffset;\n  306         LARGE_INTEGER Length;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_gnutar.c:\n   49  #include \"archive_write_set_format_private.h\"\n   50  \n   51: struct gnutar {\n   52  \tuint64_t\tentry_bytes_remaining;\n   53  \tuint64_t\tentry_padding;\n   ..\n   60  \tconst char *\tgname;\n   61  \tsize_t\t\tgname_length;\n   62: \tstruct archive_string_conv *opt_sconv;\n   63: \tstruct archive_string_conv *sconv_default;\n   64  \tint init_default_conversion;\n   65  };\n   66  \n   67  /*\n   68:  * Define structure of GNU tar header.\n   69   */\n   70  #define\tGNUTAR_name_offset 0\n   ..\n  153  };\n  154  \n  155: static int      archive_write_gnutar_options(struct archive_write *,\n  156  \t\t    const char *, const char *);\n  157: static int\tarchive_format_gnutar_header(struct archive_write *, char h[512],\n  158: \t\t    struct archive_entry *, int tartype);\n  159: static int      archive_write_gnutar_header(struct archive_write *,\n  160: \t\t    struct archive_entry *entry);\n  161: static ssize_t\tarchive_write_gnutar_data(struct archive_write *a, const void *buff,\n  162  \t\t    size_t s);\n  163: static int\tarchive_write_gnutar_free(struct archive_write *);\n  164: static int\tarchive_write_gnutar_close(struct archive_write *);\n  165: static int\tarchive_write_gnutar_finish_entry(struct archive_write *);\n  166  static int\tformat_256(int64_t, char *, int);\n  167  static int\tformat_number(int64_t, char *, int size, int maxsize);\n  ...\n  172   */\n  173  int\n  174: archive_write_set_format_gnutar(struct archive *_a)\n  175  {\n  176: \tstruct archive_write *a = (struct archive_write *)_a;\n  177: \tstruct gnutar *gnutar;\n  178  \n  179: \tgnutar = (struct gnutar *)calloc(1, sizeof(*gnutar));\n  180  \tif (gnutar == NULL) {\n  181  \t\tarchive_set_error(&a->archive, ENOMEM,\n  ...\n  197  \n  198  static int\n  199: archive_write_gnutar_options(struct archive_write *a, const char *key,\n  200      const char *val)\n  201  {\n  202: \tstruct gnutar *gnutar = (struct gnutar *)a->format_data;\n  203  \tint ret = ARCHIVE_FAILED;\n  204  \n  ...\n  226  \n  227  static int\n  228: archive_write_gnutar_close(struct archive_write *a)\n  229  {\n  230  \treturn (__archive_write_nulls(a, 512*2));\n  ...\n  232  \n  233  static int\n  234: archive_write_gnutar_free(struct archive_write *a)\n  235  {\n  236: \tstruct gnutar *gnutar;\n  237  \n  238: \tgnutar = (struct gnutar *)a->format_data;\n  239  \tfree(gnutar);\n  240  \ta->format_data = NULL;\n  ...\n  243  \n  244  static int\n  245: archive_write_gnutar_finish_entry(struct archive_write *a)\n  246  {\n  247: \tstruct gnutar *gnutar;\n  248  \tint ret;\n  249  \n  250: \tgnutar = (struct gnutar *)a->format_data;\n  251  \tret = __archive_write_nulls(a, (size_t)\n  252  \t    (gnutar->entry_bytes_remaining + gnutar->entry_padding));\n  ...\n  256  \n  257  static ssize_t\n  258: archive_write_gnutar_data(struct archive_write *a, const void *buff, size_t s)\n  259  {\n  260: \tstruct gnutar *gnutar;\n  261  \tint ret;\n  262  \n  263: \tgnutar = (struct gnutar *)a->format_data;\n  264  \tif (s > gnutar->entry_bytes_remaining)\n  265  \t\ts = (size_t)gnutar->entry_bytes_remaining;\n  ...\n  272  \n  273  static int\n  274: archive_write_gnutar_header(struct archive_write *a,\n  275:      struct archive_entry *entry)\n  276  {\n  277  \tchar buff[512];\n  278  \tint r, ret, ret2 = ARCHIVE_OK;\n  279  \tint tartype;\n  280: \tstruct gnutar *gnutar;\n  281: \tstruct archive_string_conv *sconv;\n  282: \tstruct archive_entry *entry_main;\n  283  \n  284: \tgnutar = (struct gnutar *)a->format_data;\n  285  \n  286  \t/* Setup default string conversion. */\n  ...\n  314  \t\twp = archive_entry_pathname_w(entry);\n  315  \t\tif (wp != NULL && wp[wcslen(wp) -1] != L'/') {\n  316: \t\t\tstruct archive_wstring ws;\n  317  \n  318  \t\t\tarchive_string_init(&ws);\n  ...\n  342  \t\t */\n  343  \t\tif (p != NULL && p[0] != '\\0' && p[strlen(p) - 1] != '/') {\n  344: \t\t\tstruct archive_string as;\n  345  \n  346  \t\t\tarchive_string_init(&as);\n  ...\n  470  \tif (gnutar->linkname_length > GNUTAR_linkname_size) {\n  471  \t\tsize_t length = gnutar->linkname_length + 1;\n  472: \t\tstruct archive_entry *temp = archive_entry_new2(&a->archive);\n  473  \n  474  \t\t/* Uname/gname here don't really matter since no one reads them;\n  ...\n  500  \t\tconst char *pathname = gnutar->pathname;\n  501  \t\tsize_t length = gnutar->pathname_length + 1;\n  502: \t\tstruct archive_entry *temp = archive_entry_new2(&a->archive);\n  503  \n  504  \t\t/* Uname/gname here don't really matter since no one reads them;\n  ...\n  564  \n  565  static int\n  566: archive_format_gnutar_header(struct archive_write *a, char h[512],\n  567:     struct archive_entry *entry, int tartype)\n  568  {\n  569  \tunsigned int checksum;\n  ...\n  571  \tsize_t copy_length;\n  572  \tconst char *p;\n  573: \tstruct gnutar *gnutar;\n  574  \n  575: \tgnutar = (struct gnutar *)a->format_data;\n  576  \n  577  \tret = 0;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_cpio_newc.c:\n   47  #include \"archive_write_set_format_private.h\"\n   48  \n   49: static ssize_t\tarchive_write_newc_data(struct archive_write *,\n   50  \t\t    const void *buff, size_t s);\n   51: static int\tarchive_write_newc_close(struct archive_write *);\n   52: static int\tarchive_write_newc_free(struct archive_write *);\n   53: static int\tarchive_write_newc_finish_entry(struct archive_write *);\n   54: static int\tarchive_write_newc_header(struct archive_write *,\n   55: \t\t    struct archive_entry *);\n   56: static int      archive_write_newc_options(struct archive_write *,\n   57  \t\t    const char *, const char *);\n   58  static int\tformat_hex(int64_t, void *, int);\n   59  static int64_t\tformat_hex_recursive(int64_t, char *, int);\n   60: static int\twrite_header(struct archive_write *, struct archive_entry *);\n   61  \n   62: struct cpio {\n   63  \tuint64_t\t  entry_bytes_remaining;\n   64  \tint\t\t  padding;\n   65  \n   66: \tstruct archive_string_conv *opt_sconv;\n   67: \tstruct archive_string_conv *sconv_default;\n   68  \tint\t\t  init_default_conversion;\n   69  };\n   ..\n  106   */\n  107  int\n  108: archive_write_set_format_cpio_newc(struct archive *_a)\n  109  {\n  110: \tstruct archive_write *a = (struct archive_write *)_a;\n  111: \tstruct cpio *cpio;\n  112  \n  113  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n  ...\n  118  \t\t(a->format_free)(a);\n  119  \n  120: \tcpio = (struct cpio *)calloc(1, sizeof(*cpio));\n  121  \tif (cpio == NULL) {\n  122  \t\tarchive_set_error(&a->archive, ENOMEM, \"Can't allocate cpio data\");\n  ...\n  137  \n  138  static int\n  139: archive_write_newc_options(struct archive_write *a, const char *key,\n  140      const char *val)\n  141  {\n  142: \tstruct cpio *cpio = (struct cpio *)a->format_data;\n  143  \tint ret = ARCHIVE_FAILED;\n  144  \n  ...\n  165  }\n  166  \n  167: static struct archive_string_conv *\n  168: get_sconv(struct archive_write *a)\n  169  {\n  170: \tstruct cpio *cpio;\n  171: \tstruct archive_string_conv *sconv;\n  172  \n  173: \tcpio = (struct cpio *)a->format_data;\n  174  \tsconv = cpio->opt_sconv;\n  175  \tif (sconv == NULL) {\n  ...\n  186  \n  187  static int\n  188: archive_write_newc_header(struct archive_write *a, struct archive_entry *entry)\n  189  {\n  190  \tconst char *path;\n  ...\n  216  \n  217  static int\n  218: write_header(struct archive_write *a, struct archive_entry *entry)\n  219  {\n  220  \tint64_t ino;\n  221: \tstruct cpio *cpio;\n  222  \tconst char *p, *path;\n  223  \tint pathlength, ret, ret_final;\n  224  \tchar h[c_header_size];\n  225: \tstruct archive_string_conv *sconv;\n  226: \tstruct archive_entry *entry_main;\n  227  \tsize_t len;\n  228  \tint pad;\n  229  \n  230: \tcpio = (struct cpio *)a->format_data;\n  231  \tret_final = ARCHIVE_OK;\n  232  \tsconv = get_sconv(a);\n  ...\n  373  \n  374  static ssize_t\n  375: archive_write_newc_data(struct archive_write *a, const void *buff, size_t s)\n  376  {\n  377: \tstruct cpio *cpio;\n  378  \tint ret;\n  379  \n  380: \tcpio = (struct cpio *)a->format_data;\n  381  \tif (s > cpio->entry_bytes_remaining)\n  382  \t\ts = (size_t)cpio->entry_bytes_remaining;\n  ...\n  421  \n  422  static int\n  423: archive_write_newc_close(struct archive_write *a)\n  424  {\n  425  \tint er;\n  426: \tstruct archive_entry *trailer;\n  427  \n  428  \ttrailer = archive_entry_new();\n  ...\n  437  \n  438  static int\n  439: archive_write_newc_free(struct archive_write *a)\n  440  {\n  441: \tstruct cpio *cpio;\n  442  \n  443: \tcpio = (struct cpio *)a->format_data;\n  444  \tfree(cpio);\n  445  \ta->format_data = NULL;\n  ...\n  448  \n  449  static int\n  450: archive_write_newc_finish_entry(struct archive_write *a)\n  451  {\n  452: \tstruct cpio *cpio;\n  453  \n  454: \tcpio = (struct cpio *)a->format_data;\n  455  \treturn (__archive_write_nulls(a,\n  456  \t\t(size_t)cpio->entry_bytes_remaining + cpio->padding));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_xxhash.h:\n   35  typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;\n   36  \n   37: struct archive_xxhash {\n   38  \tunsigned int  (*XXH32)(const void* input, unsigned int len,\n   39  \t\t\tunsigned int seed);\n   ..\n   44  };\n   45  \n   46: extern const struct archive_xxhash __archive_xxhash;\n   47  \n   48  #endif\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_entry_copy_stat.c:\n   35  \n   36  void\n   37: archive_entry_copy_stat(struct archive_entry *entry, const struct stat *st)\n   38  {\n   39  #if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter_lrzip.c:\n   42  #include \"archive_write_private.h\"\n   43  \n   44: struct write_lrzip {\n   45: \tstruct archive_write_program_data *pdata;\n   46  \tint\tcompression_level;\n   47  \tenum { lzma = 0, bzip2, gzip, lzo, none, zpaq } compression;\n   48  };\n   49  \n   50: static int archive_write_lrzip_open(struct archive_write_filter *);\n   51: static int archive_write_lrzip_options(struct archive_write_filter *,\n   52  \t\t    const char *, const char *);\n   53: static int archive_write_lrzip_write(struct archive_write_filter *,\n   54  \t\t    const void *, size_t);\n   55: static int archive_write_lrzip_close(struct archive_write_filter *);\n   56: static int archive_write_lrzip_free(struct archive_write_filter *);\n   57  \n   58  int\n   59: archive_write_add_filter_lrzip(struct archive *_a)\n   60  {\n   61: \tstruct archive_write_filter *f = __archive_write_allocate_filter(_a);\n   62: \tstruct write_lrzip *data;\n   63  \n   64  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n   ..\n   94  \n   95  static int\n   96: archive_write_lrzip_options(struct archive_write_filter *f, const char *key,\n   97      const char *value)\n   98  {\n   99: \tstruct write_lrzip *data = (struct write_lrzip *)f->data;\n  100  \n  101  \tif (strcmp(key, \"compression\") == 0) {\n  ...\n  129  \n  130  static int\n  131: archive_write_lrzip_open(struct archive_write_filter *f)\n  132  {\n  133: \tstruct write_lrzip *data = (struct write_lrzip *)f->data;\n  134: \tstruct archive_string as;\n  135  \tint r;\n  136  \n  ...\n  171  \n  172  static int\n  173: archive_write_lrzip_write(struct archive_write_filter *f,\n  174      const void *buff, size_t length)\n  175  {\n  176: \tstruct write_lrzip *data = (struct write_lrzip *)f->data;\n  177  \n  178  \treturn __archive_write_program_write(f, data->pdata, buff, length);\n  ...\n  180  \n  181  static int\n  182: archive_write_lrzip_close(struct archive_write_filter *f)\n  183  {\n  184: \tstruct write_lrzip *data = (struct write_lrzip *)f->data;\n  185  \n  186  \treturn __archive_write_program_close(f, data->pdata);\n  ...\n  188  \n  189  static int\n  190: archive_write_lrzip_free(struct archive_write_filter *f)\n  191  {\n  192: \tstruct write_lrzip *data = (struct write_lrzip *)f->data;\n  193  \n  194  \t__archive_write_program_free(data->pdata);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_options.c:\n   30  #include \"archive_options_private.h\"\n   31  \n   32: static int\tarchive_set_format_option(struct archive *a,\n   33  \t\t    const char *m, const char *o, const char *v);\n   34: static int\tarchive_set_filter_option(struct archive *a,\n   35  \t\t    const char *m, const char *o, const char *v);\n   36: static int\tarchive_set_option(struct archive *a,\n   37  \t\t    const char *m, const char *o, const char *v);\n   38  \n   39  int\n   40: archive_write_set_format_option(struct archive *a, const char *m, const char *o,\n   41      const char *v)\n   42  {\n   ..\n   47  \n   48  int\n   49: archive_write_set_filter_option(struct archive *a, const char *m, const char *o,\n   50      const char *v)\n   51  {\n   ..\n   56  \n   57  int\n   58: archive_write_set_option(struct archive *a, const char *m, const char *o,\n   59      const char *v)\n   60  {\n   ..\n   65  \n   66  int\n   67: archive_write_set_options(struct archive *a, const char *options)\n   68  {\n   69  \treturn _archive_set_options(a, options,\n   ..\n   73  \n   74  static int\n   75: archive_set_format_option(struct archive *_a, const char *m, const char *o,\n   76      const char *v)\n   77  {\n   78: \tstruct archive_write *a = (struct archive_write *)_a;\n   79  \n   80  \tif (a->format_name == NULL)\n   ..\n   90  \n   91  static int\n   92: archive_set_filter_option(struct archive *_a, const char *m, const char *o,\n   93      const char *v)\n   94  {\n   95: \tstruct archive_write *a = (struct archive_write *)_a;\n   96: \tstruct archive_write_filter *filter;\n   97  \tint r, rv = ARCHIVE_WARN;\n   98  \n   ..\n  122  \n  123  static int\n  124: archive_set_option(struct archive *a, const char *m, const char *o,\n  125      const char *v)\n  126  {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_gzip.c:\n   55  \n   56  #ifdef HAVE_ZLIB_H\n   57: struct private_data {\n   58  \tz_stream\t stream;\n   59  \tchar\t\t in_stream;\n   ..\n   68  \n   69  /* Gzip Filter. */\n   70: static ssize_t\tgzip_filter_read(struct archive_read_filter *, const void **);\n   71: static int\tgzip_filter_close(struct archive_read_filter *);\n   72  #endif\n   73  \n   ..\n   82   * gzip program.\n   83   */\n   84: static int\tgzip_bidder_bid(struct archive_read_filter_bidder *,\n   85: \t\t    struct archive_read_filter *);\n   86: static int\tgzip_bidder_init(struct archive_read_filter *);\n   87  \n   88  #if ARCHIVE_VERSION_NUMBER < 4000000\n   89  /* Deprecated; remove in libarchive 4.0 */\n   90  int\n   91: archive_read_support_compression_gzip(struct archive *a)\n   92  {\n   93  \treturn archive_read_support_filter_gzip(a);\n   ..\n   96  \n   97  int\n   98: archive_read_support_filter_gzip(struct archive *_a)\n   99  {\n  100: \tstruct archive_read *a = (struct archive_read *)_a;\n  101: \tstruct archive_read_filter_bidder *bidder;\n  102  \n  103  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n  ...\n  131   */\n  132  static ssize_t\n  133: peek_at_header(struct archive_read_filter *filter, int *pbits,\n  134  #ifdef HAVE_ZLIB_H\n  135: \t       struct private_data *state\n  136  #else\n  137  \t       void *state\n  ...\n  239   */\n  240  static int\n  241: gzip_bidder_bid(struct archive_read_filter_bidder *self,\n  242:     struct archive_read_filter *filter)\n  243  {\n  244  \tint bits_checked;\n  ...\n  259   */\n  260  static int\n  261: gzip_bidder_init(struct archive_read_filter *self)\n  262  {\n  263  \tint r;\n  ...\n  275  \n  276  static int\n  277: gzip_read_header(struct archive_read_filter *self, struct archive_entry *entry)\n  278  {\n  279: \tstruct private_data *state;\n  280  \n  281: \tstate = (struct private_data *)self->data;\n  282  \n  283  \t/* A mtime of 0 is considered invalid/missing. */\n  ...\n  296   */\n  297  static int\n  298: gzip_bidder_init(struct archive_read_filter *self)\n  299  {\n  300: \tstruct private_data *state;\n  301  \tstatic const size_t out_block_size = 64 * 1024;\n  302  \tvoid *out_block;\n  ...\n  305  \tself->name = \"gzip\";\n  306  \n  307: \tstate = (struct private_data *)calloc(sizeof(*state), 1);\n  308  \tout_block = (unsigned char *)malloc(out_block_size);\n  309  \tif (state == NULL || out_block == NULL) {\n  ...\n  331  \n  332  static int\n  333: consume_header(struct archive_read_filter *self)\n  334  {\n  335: \tstruct private_data *state;\n  336  \tssize_t avail;\n  337  \tsize_t len;\n  338  \tint ret;\n  339  \n  340: \tstate = (struct private_data *)self->data;\n  341  \n  342  \t/* If this is a real header, consume it. */\n  ...\n  389  \n  390  static int\n  391: consume_trailer(struct archive_read_filter *self)\n  392  {\n  393: \tstruct private_data *state;\n  394  \tconst unsigned char *p;\n  395  \tssize_t avail;\n  396  \n  397: \tstate = (struct private_data *)self->data;\n  398  \n  399  \tstate->in_stream = 0;\n  ...\n  408  \t}\n  409  \n  410: \t/* GZip trailer is a fixed 8 byte structure. */\n  411  \tp = __archive_read_filter_ahead(self->upstream, 8, &avail);\n  412  \tif (p == NULL || avail == 0)\n  ...\n  422  \n  423  static ssize_t\n  424: gzip_filter_read(struct archive_read_filter *self, const void **p)\n  425  {\n  426: \tstruct private_data *state;\n  427  \tsize_t decompressed;\n  428  \tssize_t avail_in, max_in;\n  429  \tint ret;\n  430  \n  431: \tstate = (struct private_data *)self->data;\n  432  \n  433  \t/* Empty our output buffer. */\n  ...\n  507   */\n  508  static int\n  509: gzip_filter_close(struct archive_read_filter *self)\n  510  {\n  511: \tstruct private_data *state;\n  512  \tint ret;\n  513  \n  514: \tstate = (struct private_data *)self->data;\n  515  \tret = ARCHIVE_OK;\n  516  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_platform.h:\n   66  /* It should be possible to get rid of this by extending the feature-test\n   67   * macros to cover Windows API functions, probably along with non-trivial\n   68:  * refactoring of code to find structures that sit more cleanly on top of\n   69   * either Windows or Posix APIs. */\n   70  #if (defined(__WIN32__) || defined(_WIN32) || defined(__WIN32)) && !defined(__CYGWIN__)\n   ..\n   87  /* If not, define them so as to avoid dangling semicolons. */\n   88  #ifndef __FBSDID\n   89: #define\t__FBSDID(a)     struct _undefined_hack\n   90  #endif\n   91  #ifndef __RCSID\n   92: #define\t__RCSID(a)     struct _undefined_hack\n   93  #endif\n   94  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_ustar.c:\n   47  #include \"archive_write_set_format_private.h\"\n   48  \n   49: struct ustar {\n   50  \tuint64_t\tentry_bytes_remaining;\n   51  \tuint64_t\tentry_padding;\n   52  \n   53: \tstruct archive_string_conv *opt_sconv;\n   54: \tstruct archive_string_conv *sconv_default;\n   55  \tint\tinit_default_conversion;\n   56  };\n   57  \n   58  /*\n   59:  * Define structure of POSIX 'ustar' tar header.\n   60   */\n   61  #define\tUSTAR_name_offset 0\n   ..\n  149  };\n  150  \n  151: static ssize_t\tarchive_write_ustar_data(struct archive_write *a, const void *buff,\n  152  \t\t    size_t s);\n  153: static int\tarchive_write_ustar_free(struct archive_write *);\n  154: static int\tarchive_write_ustar_close(struct archive_write *);\n  155: static int\tarchive_write_ustar_finish_entry(struct archive_write *);\n  156: static int\tarchive_write_ustar_header(struct archive_write *,\n  157: \t\t    struct archive_entry *entry);\n  158: static int\tarchive_write_ustar_options(struct archive_write *,\n  159  \t\t    const char *, const char *);\n  160  static int\tformat_256(int64_t, char *, int);\n  ...\n  166   */\n  167  int\n  168: archive_write_set_format_ustar(struct archive *_a)\n  169  {\n  170: \tstruct archive_write *a = (struct archive_write *)_a;\n  171: \tstruct ustar *ustar;\n  172  \n  173  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n  ...\n  186  \t}\n  187  \n  188: \tustar = (struct ustar *)calloc(1, sizeof(*ustar));\n  189  \tif (ustar == NULL) {\n  190  \t\tarchive_set_error(&a->archive, ENOMEM,\n  ...\n  206  \n  207  static int\n  208: archive_write_ustar_options(struct archive_write *a, const char *key,\n  209      const char *val)\n  210  {\n  211: \tstruct ustar *ustar = (struct ustar *)a->format_data;\n  212  \tint ret = ARCHIVE_FAILED;\n  213  \n  ...\n  235  \n  236  static int\n  237: archive_write_ustar_header(struct archive_write *a, struct archive_entry *entry)\n  238  {\n  239  \tchar buff[512];\n  240  \tint ret, ret2;\n  241: \tstruct ustar *ustar;\n  242: \tstruct archive_entry *entry_main;\n  243: \tstruct archive_string_conv *sconv;\n  244  \n  245: \tustar = (struct ustar *)a->format_data;\n  246  \n  247  \t/* Setup default string conversion. */\n  ...\n  281  \t\twp = archive_entry_pathname_w(entry);\n  282  \t\tif (wp != NULL && wp[wcslen(wp) -1] != L'/') {\n  283: \t\t\tstruct archive_wstring ws;\n  284  \n  285  \t\t\tarchive_string_init(&ws);\n  ...\n  309  \t\t */\n  310  \t\tif (p != NULL && p[0] != '\\0' && p[strlen(p) - 1] != '/') {\n  311: \t\t\tstruct archive_string as;\n  312  \n  313  \t\t\tarchive_string_init(&as);\n  ...\n  382   */\n  383  int\n  384: __archive_write_format_header_ustar(struct archive_write *a, char h[512],\n  385:     struct archive_entry *entry, int tartype, int strict,\n  386:     struct archive_string_conv *sconv)\n  387  {\n  388  \tunsigned int checksum;\n  ...\n  713  \n  714  static int\n  715: archive_write_ustar_close(struct archive_write *a)\n  716  {\n  717  \treturn (__archive_write_nulls(a, 512*2));\n  ...\n  719  \n  720  static int\n  721: archive_write_ustar_free(struct archive_write *a)\n  722  {\n  723: \tstruct ustar *ustar;\n  724  \n  725: \tustar = (struct ustar *)a->format_data;\n  726  \tfree(ustar);\n  727  \ta->format_data = NULL;\n  ...\n  730  \n  731  static int\n  732: archive_write_ustar_finish_entry(struct archive_write *a)\n  733  {\n  734: \tstruct ustar *ustar;\n  735  \tint ret;\n  736  \n  737: \tustar = (struct ustar *)a->format_data;\n  738  \tret = __archive_write_nulls(a,\n  739  \t    (size_t)(ustar->entry_bytes_remaining + ustar->entry_padding));\n  ...\n  743  \n  744  static ssize_t\n  745: archive_write_ustar_data(struct archive_write *a, const void *buff, size_t s)\n  746  {\n  747: \tstruct ustar *ustar;\n  748  \tint ret;\n  749  \n  750: \tustar = (struct ustar *)a->format_data;\n  751  \tif (s > ustar->entry_bytes_remaining)\n  752  \t\ts = (size_t)ustar->entry_bytes_remaining;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_filter_bzip2.c:\n   50  \n   51  #if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n   52: struct private_data {\n   53  \tbz_stream\t stream;\n   54  \tchar\t\t*out_block;\n   ..\n   59  \n   60  /* Bzip2 filter */\n   61: static ssize_t\tbzip2_filter_read(struct archive_read_filter *, const void **);\n   62: static int\tbzip2_filter_close(struct archive_read_filter *);\n   63  #endif\n   64  \n   ..\n   69   * if bzlib is unavailable.\n   70   */\n   71: static int\tbzip2_reader_bid(struct archive_read_filter_bidder *, struct archive_read_filter *);\n   72: static int\tbzip2_reader_init(struct archive_read_filter *);\n   73: static int\tbzip2_reader_free(struct archive_read_filter_bidder *);\n   74  \n   75  #if ARCHIVE_VERSION_NUMBER < 4000000\n   76  /* Deprecated; remove in libarchive 4.0 */\n   77  int\n   78: archive_read_support_compression_bzip2(struct archive *a)\n   79  {\n   80  \treturn archive_read_support_filter_bzip2(a);\n   ..\n   83  \n   84  int\n   85: archive_read_support_filter_bzip2(struct archive *_a)\n   86  {\n   87: \tstruct archive_read *a = (struct archive_read *)_a;\n   88: \tstruct archive_read_filter_bidder *reader;\n   89  \n   90  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n   ..\n  110  \n  111  static int\n  112: bzip2_reader_free(struct archive_read_filter_bidder *self){\n  113  \t(void)self; /* UNUSED */\n  114  \treturn (ARCHIVE_OK);\n  ...\n  123   */\n  124  static int\n  125: bzip2_reader_bid(struct archive_read_filter_bidder *self, struct archive_read_filter *filter)\n  126  {\n  127  \tconst unsigned char *buffer;\n  ...\n  168   */\n  169  static int\n  170: bzip2_reader_init(struct archive_read_filter *self)\n  171  {\n  172  \tint r;\n  ...\n  188   */\n  189  static int\n  190: bzip2_reader_init(struct archive_read_filter *self)\n  191  {\n  192  \tstatic const size_t out_block_size = 64 * 1024;\n  193  \tvoid *out_block;\n  194: \tstruct private_data *state;\n  195  \n  196  \tself->code = ARCHIVE_FILTER_BZIP2;\n  197  \tself->name = \"bzip2\";\n  198  \n  199: \tstate = (struct private_data *)calloc(sizeof(*state), 1);\n  200  \tout_block = (unsigned char *)malloc(out_block_size);\n  201  \tif (state == NULL || out_block == NULL) {\n  ...\n  221   */\n  222  static ssize_t\n  223: bzip2_filter_read(struct archive_read_filter *self, const void **p)\n  224  {\n  225: \tstruct private_data *state;\n  226  \tsize_t decompressed;\n  227  \tconst char *read_buf;\n  228  \tssize_t ret;\n  229  \n  230: \tstate = (struct private_data *)self->data;\n  231  \n  232  \tif (state->eof) {\n  ...\n  344   */\n  345  static int\n  346: bzip2_filter_close(struct archive_read_filter *self)\n  347  {\n  348: \tstruct private_data *state;\n  349  \tint ret = ARCHIVE_OK;\n  350  \n  351: \tstate = (struct private_data *)self->data;\n  352  \n  353  \tif (state->valid) {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter_none.c:\n   30  \n   31  int\n   32: archive_write_set_compression_none(struct archive *a)\n   33  {\n   34  \t(void)a; /* UNUSED */\n   ..\n   37  \n   38  int\n   39: archive_write_add_filter_none(struct archive *a)\n   40  {\n   41  \t(void)a; /* UNUSED */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_empty.c:\n   32  #include \"archive_read_private.h\"\n   33  \n   34: static int\tarchive_read_format_empty_bid(struct archive_read *, int);\n   35: static int\tarchive_read_format_empty_read_data(struct archive_read *,\n   36  \t\t    const void **, size_t *, int64_t *);\n   37: static int\tarchive_read_format_empty_read_header(struct archive_read *,\n   38: \t\t    struct archive_entry *);\n   39  int\n   40: archive_read_support_format_empty(struct archive *_a)\n   41  {\n   42: \tstruct archive_read *a = (struct archive_read *)_a;\n   43  \tint r;\n   44  \n   ..\n   64  \n   65  static int\n   66: archive_read_format_empty_bid(struct archive_read *a, int best_bid)\n   67  {\n   68  \tif (best_bid < 1 && __archive_read_ahead(a, 1, NULL) == NULL)\n   ..\n   72  \n   73  static int\n   74: archive_read_format_empty_read_header(struct archive_read *a,\n   75:     struct archive_entry *entry)\n   76  {\n   77  \t(void)a; /* UNUSED */\n   ..\n   85  \n   86  static int\n   87: archive_read_format_empty_read_data(struct archive_read *a,\n   88      const void **buff, size_t *size, int64_t *offset)\n   89  {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_open_filename.c:\n   57  #endif\n   58  \n   59: struct write_file_data {\n   60  \tint\t\tfd;\n   61: \tstruct archive_mstring filename;\n   62  };\n   63  \n   64: static int\tfile_close(struct archive *, void *);\n   65: static int\tfile_free(struct archive *, void *);\n   66: static int\tfile_open(struct archive *, void *);\n   67: static ssize_t\tfile_write(struct archive *, void *, const void *buff, size_t);\n   68: static int\topen_filename(struct archive *, int, const void *);\n   69  \n   70  int\n   71: archive_write_open_file(struct archive *a, const char *filename)\n   72  {\n   73  \treturn (archive_write_open_filename(a, filename));\n   ..\n   75  \n   76  int\n   77: archive_write_open_filename(struct archive *a, const char *filename)\n   78  {\n   79  \n   ..\n   85  \n   86  int\n   87: archive_write_open_filename_w(struct archive *a, const wchar_t *filename)\n   88  {\n   89  \n   ..\n   95  \n   96  static int\n   97: open_filename(struct archive *a, int mbs_fn, const void *filename)\n   98  {\n   99: \tstruct write_file_data *mine;\n  100  \tint r;\n  101  \n  102: \tmine = (struct write_file_data *)calloc(1, sizeof(*mine));\n  103  \tif (mine == NULL) {\n  104  \t\tarchive_set_error(a, ENOMEM, \"No memory\");\n  ...\n  130  \n  131  static int\n  132: file_open(struct archive *a, void *client_data)\n  133  {\n  134  \tint flags;\n  135: \tstruct write_file_data *mine;\n  136: \tstruct stat st;\n  137  #if defined(_WIN32) && !defined(__CYGWIN__)\n  138  \twchar_t *fullpath;\n  ...\n  141  \tconst char *mbs;\n  142  \n  143: \tmine = (struct write_file_data *)client_data;\n  144  \tflags = O_WRONLY | O_CREAT | O_TRUNC | O_BINARY | O_CLOEXEC;\n  145  \n  ...\n  220  \n  221  static ssize_t\n  222: file_write(struct archive *a, void *client_data, const void *buff,\n  223      size_t length)\n  224  {\n  225: \tstruct write_file_data\t*mine;\n  226  \tssize_t\tbytesWritten;\n  227  \n  228: \tmine = (struct write_file_data *)client_data;\n  229  \tfor (;;) {\n  230  \t\tbytesWritten = write(mine->fd, buff, length);\n  ...\n  240  \n  241  static int\n  242: file_close(struct archive *a, void *client_data)\n  243  {\n  244: \tstruct write_file_data\t*mine = (struct write_file_data *)client_data;\n  245  \n  246  \t(void)a; /* UNUSED */\n  ...\n  256  \n  257  static int\n  258: file_free(struct archive *a, void *client_data)\n  259  {\n  260: \tstruct write_file_data\t*mine = (struct write_file_data *)client_data;\n  261  \n  262  \t(void)a; /* UNUSED */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_open_file.c:\n   51  #include \"archive.h\"\n   52  \n   53: struct read_FILE_data {\n   54  \tFILE    *f;\n   55  \tsize_t\t block_size;\n   ..\n   58  };\n   59  \n   60: static int\tfile_close(struct archive *, void *);\n   61: static ssize_t\tfile_read(struct archive *, void *, const void **buff);\n   62: static int64_t\tfile_skip(struct archive *, void *, int64_t request);\n   63  \n   64  int\n   65: archive_read_open_FILE(struct archive *a, FILE *f)\n   66  {\n   67: \tstruct stat st;\n   68: \tstruct read_FILE_data *mine;\n   69  \tsize_t block_size = 128 * 1024;\n   70  \tvoid *b;\n   71  \n   72  \tarchive_clear_error(a);\n   73: \tmine = (struct read_FILE_data *)malloc(sizeof(*mine));\n   74  \tb = malloc(block_size);\n   75  \tif (mine == NULL || b == NULL) {\n   ..\n  107  \n  108  static ssize_t\n  109: file_read(struct archive *a, void *client_data, const void **buff)\n  110  {\n  111: \tstruct read_FILE_data *mine = (struct read_FILE_data *)client_data;\n  112  \tsize_t bytes_read;\n  113  \n  ...\n  121  \n  122  static int64_t\n  123: file_skip(struct archive *a, void *client_data, int64_t request)\n  124  {\n  125: \tstruct read_FILE_data *mine = (struct read_FILE_data *)client_data;\n  126  #if HAVE_FSEEKO\n  127  \toff_t skip = (off_t)request;\n  ...\n  170  \n  171  static int\n  172: file_close(struct archive *a, void *client_data)\n  173  {\n  174: \tstruct read_FILE_data *mine = (struct read_FILE_data *)client_data;\n  175  \n  176  \t(void)a; /* UNUSED */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_rb.h:\n   33  #define\tARCHIVE_RB_H_INCLUDED\n   34  \n   35: struct archive_rb_node {\n   36: \tstruct archive_rb_node *rb_nodes[2];\n   37  \t/*\n   38  \t * rb_info contains the two flags and the parent back pointer.\n   ..\n   81   */\n   82  \n   83: typedef signed int (*const archive_rbto_compare_nodes_fn)(const struct archive_rb_node *,\n   84:     const struct archive_rb_node *);\n   85: typedef signed int (*const archive_rbto_compare_key_fn)(const struct archive_rb_node *,\n   86      const void *);\n   87  \n   88: struct archive_rb_tree_ops {\n   89  \tarchive_rbto_compare_nodes_fn rbto_compare_nodes;\n   90  \tarchive_rbto_compare_key_fn rbto_compare_key;\n   91  };\n   92  \n   93: struct archive_rb_tree {\n   94: \tstruct archive_rb_node *rbt_root;\n   95: \tconst struct archive_rb_tree_ops *rbt_ops;\n   96  };\n   97  \n   98: void\t__archive_rb_tree_init(struct archive_rb_tree *,\n   99:     const struct archive_rb_tree_ops *);\n  100: int\t__archive_rb_tree_insert_node(struct archive_rb_tree *,\n  101:     struct archive_rb_node *);\n  102: struct archive_rb_node\t*\n  103: \t__archive_rb_tree_find_node(struct archive_rb_tree *, const void *);\n  104: struct archive_rb_node\t*\n  105: \t__archive_rb_tree_find_node_geq(struct archive_rb_tree *, const void *);\n  106: struct archive_rb_node\t*\n  107: \t__archive_rb_tree_find_node_leq(struct archive_rb_tree *, const void *);\n  108: void\t__archive_rb_tree_remove_node(struct archive_rb_tree *, struct archive_rb_node *);\n  109: struct archive_rb_node *\n  110: \t__archive_rb_tree_iterate(struct archive_rb_tree *,\n  111: \tstruct archive_rb_node *, const unsigned int);\n  112  \n  113  #endif\t/* ARCHIVE_RB_H_*/\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_pax.c:\n   46  #include \"archive_write_set_format_private.h\"\n   47  \n   48: struct sparse_block {\n   49: \tstruct sparse_block\t*next;\n   50  \tint\t\tis_hole;\n   51  \tuint64_t\toffset;\n   ..\n   53  };\n   54  \n   55: struct pax {\n   56  \tuint64_t\tentry_bytes_remaining;\n   57  \tuint64_t\tentry_padding;\n   58: \tstruct archive_string\tl_url_encoded_name;\n   59: \tstruct archive_string\tpax_header;\n   60: \tstruct archive_string\tsparse_map;\n   61  \tsize_t\t\t\tsparse_map_padding;\n   62: \tstruct sparse_block\t*sparse_list;\n   63: \tstruct sparse_block\t*sparse_tail;\n   64: \tstruct archive_string_conv *sconv_utf8;\n   65  \tint\t\t\t opt_binary;\n   66  \n   ..\n   70  };\n   71  \n   72: static void\t\t add_pax_attr(struct archive_string *, const char *key,\n   73  \t\t\t     const char *value);\n   74: static void\t\t add_pax_attr_binary(struct archive_string *,\n   75  \t\t\t     const char *key,\n   76  \t\t\t     const char *value, size_t value_len);\n   77: static void\t\t add_pax_attr_int(struct archive_string *,\n   78  \t\t\t     const char *key, int64_t value);\n   79: static void\t\t add_pax_attr_time(struct archive_string *,\n   80  \t\t\t     const char *key, int64_t sec,\n   81  \t\t\t     unsigned long nanos);\n   82: static int\t\t add_pax_acl(struct archive_write *,\n   83: \t\t\t    struct archive_entry *, struct pax *, int);\n   84: static ssize_t\t\t archive_write_pax_data(struct archive_write *,\n   85  \t\t\t     const void *, size_t);\n   86: static int\t\t archive_write_pax_close(struct archive_write *);\n   87: static int\t\t archive_write_pax_free(struct archive_write *);\n   88: static int\t\t archive_write_pax_finish_entry(struct archive_write *);\n   89: static int\t\t archive_write_pax_header(struct archive_write *,\n   90: \t\t\t     struct archive_entry *);\n   91: static int\t\t archive_write_pax_options(struct archive_write *,\n   92  \t\t\t     const char *, const char *);\n   93  static char\t\t*base64_encode(const char *src, size_t len);\n   ..\n   98  static char\t\t*format_int(char *dest, int64_t);\n   99  static int\t\t has_non_ASCII(const char *);\n  100: static void\t\t sparse_list_clear(struct pax *);\n  101: static int\t\t sparse_list_add(struct pax *, int64_t, int64_t);\n  102  static char\t\t*url_encode(const char *in);\n  103  \n  ...\n  110   */\n  111  int\n  112: archive_write_set_format_pax_restricted(struct archive *_a)\n  113  {\n  114: \tstruct archive_write *a = (struct archive_write *)_a;\n  115  \tint r;\n  116  \n  ...\n  128   */\n  129  int\n  130: archive_write_set_format_pax(struct archive *_a)\n  131  {\n  132: \tstruct archive_write *a = (struct archive_write *)_a;\n  133: \tstruct pax *pax;\n  134  \n  135  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n  ...\n  139  \t\t(a->format_free)(a);\n  140  \n  141: \tpax = (struct pax *)calloc(1, sizeof(*pax));\n  142  \tif (pax == NULL) {\n  143  \t\tarchive_set_error(&a->archive, ENOMEM,\n  ...\n  161  \n  162  static int\n  163: archive_write_pax_options(struct archive_write *a, const char *key,\n  164      const char *val)\n  165  {\n  166: \tstruct pax *pax = (struct pax *)a->format_data;\n  167  \tint ret = ARCHIVE_FAILED;\n  168  \n  ...\n  239   */\n  240  static void\n  241: add_pax_attr_time(struct archive_string *as, const char *key,\n  242      int64_t sec, unsigned long nanos)\n  243  {\n  ...\n  293  \n  294  static void\n  295: add_pax_attr_int(struct archive_string *as, const char *key, int64_t value)\n  296  {\n  297  \tchar tmp[1 + 3 * sizeof(value)];\n  ...\n  306   */\n  307  static void\n  308: add_pax_attr(struct archive_string *as, const char *key, const char *value)\n  309  {\n  310  \tadd_pax_attr_binary(as, key, value, strlen(value));\n  ...\n  316   */\n  317  static void\n  318: add_pax_attr_binary(struct archive_string *as, const char *key,\n  319  \t\t    const char *value, size_t value_len)\n  320  {\n  ...\n  362  \n  363  static void\n  364: archive_write_pax_header_xattr(struct pax *pax, const char *encoded_name,\n  365      const void *value, size_t value_len)\n  366  {\n  367: \tstruct archive_string s;\n  368  \tchar *encoded_value;\n  369  \n  ...\n  390  \n  391  static int\n  392: archive_write_pax_header_xattrs(struct archive_write *a,\n  393:     struct pax *pax, struct archive_entry *entry)\n  394  {\n  395  \tint i = archive_entry_xattr_reset(entry);\n  ...\n  426  \n  427  static int\n  428: get_entry_hardlink(struct archive_write *a, struct archive_entry *entry,\n  429:     const char **name, size_t *length, struct archive_string_conv *sc)\n  430  {\n  431  \tint r;\n  ...\n  444  \n  445  static int\n  446: get_entry_pathname(struct archive_write *a, struct archive_entry *entry,\n  447:     const char **name, size_t *length, struct archive_string_conv *sc)\n  448  {\n  449  \tint r;\n  ...\n  462  \n  463  static int\n  464: get_entry_uname(struct archive_write *a, struct archive_entry *entry,\n  465:     const char **name, size_t *length, struct archive_string_conv *sc)\n  466  {\n  467  \tint r;\n  ...\n  480  \n  481  static int\n  482: get_entry_gname(struct archive_write *a, struct archive_entry *entry,\n  483:     const char **name, size_t *length, struct archive_string_conv *sc)\n  484  {\n  485  \tint r;\n  ...\n  498  \n  499  static int\n  500: get_entry_symlink(struct archive_write *a, struct archive_entry *entry,\n  501:     const char **name, size_t *length, struct archive_string_conv *sc)\n  502  {\n  503  \tint r;\n  ...\n  517  /* Add ACL to pax header */\n  518  static int\n  519: add_pax_acl(struct archive_write *a,\n  520:     struct archive_entry *entry, struct pax *pax, int flags)\n  521  {\n  522  \tchar *p;\n  ...\n  565   */\n  566  static int\n  567: archive_write_pax_header(struct archive_write *a,\n  568:     struct archive_entry *entry_original)\n  569  {\n  570: \tstruct archive_entry *entry_main;\n  571  \tconst char *p;\n  572  \tconst char *suffix;\n  ...\n  575  \tint sparse_count;\n  576  \tuint64_t sparse_total, real_size;\n  577: \tstruct pax *pax;\n  578  \tconst char *hardlink;\n  579  \tconst char *path = NULL, *linkpath = NULL;\n  ...\n  581  \tconst void *mac_metadata;\n  582  \tsize_t mac_metadata_size;\n  583: \tstruct archive_string_conv *sconv;\n  584  \tsize_t hardlink_length, path_length, linkpath_length;\n  585  \tsize_t uname_length, gname_length;\n  ...\n  590  \tchar pax_entry_name[256];\n  591  \tchar gnu_sparse_name[256];\n  592: \tstruct archive_string entry_name;\n  593  \n  594  \tret = ARCHIVE_OK;\n  595  \tneed_extension = 0;\n  596: \tpax = (struct pax *)a->format_data;\n  597  \n  598  \t/* Sanity check. */\n  ...\n  658  \t\t\twp = archive_entry_pathname_w(entry_original);\n  659  \t\t\tif (wp != NULL && wp[wcslen(wp) -1] != L'/') {\n  660: \t\t\t\tstruct archive_wstring ws;\n  661  \n  662  \t\t\t\tarchive_string_init(&ws);\n  ...\n  687  \t\t\t */\n  688  \t\t\tif (p != NULL && p[0] != '\\0' && p[strlen(p) - 1] != '/') {\n  689: \t\t\t\tstruct archive_string as;\n  690  \n  691  \t\t\t\tarchive_string_init(&as);\n  ...\n  741  \t\tchar *name, *bname;\n  742  \t\tsize_t name_length;\n  743: \t\tstruct archive_entry *extra = archive_entry_new2(&a->archive);\n  744  \n  745  \t\toname = archive_entry_pathname(entry_original);\n  ...\n 1383  \t/* If we built any extended attributes, write that entry first. */\n 1384  \tif (archive_strlen(&(pax->pax_header)) > 0) {\n 1385: \t\tstruct archive_entry *pax_attr_entry;\n 1386  \t\ttime_t s;\n 1387  \t\tint64_t uid, gid;\n ....\n 1709  \n 1710  \t/*\n 1711: \t * TODO: Push this string into the 'pax' structure to avoid\n 1712  \t * recomputing it every time.  That will also open the door\n 1713  \t * to having clients override it.\n ....\n 1772  /* Write two null blocks for the end of archive */\n 1773  static int\n 1774: archive_write_pax_close(struct archive_write *a)\n 1775  {\n 1776  \treturn (__archive_write_nulls(a, 512 * 2));\n ....\n 1778  \n 1779  static int\n 1780: archive_write_pax_free(struct archive_write *a)\n 1781  {\n 1782: \tstruct pax *pax;\n 1783  \n 1784: \tpax = (struct pax *)a->format_data;\n 1785  \tif (pax == NULL)\n 1786  \t\treturn (ARCHIVE_OK);\n ....\n 1796  \n 1797  static int\n 1798: archive_write_pax_finish_entry(struct archive_write *a)\n 1799  {\n 1800: \tstruct pax *pax;\n 1801  \tuint64_t remaining;\n 1802  \tint ret;\n 1803  \n 1804: \tpax = (struct pax *)a->format_data;\n 1805  \tremaining = pax->entry_bytes_remaining;\n 1806  \tif (remaining == 0) {\n 1807  \t\twhile (pax->sparse_list) {\n 1808: \t\t\tstruct sparse_block *sb;\n 1809  \t\t\tif (!pax->sparse_list->is_hole)\n 1810  \t\t\t\tremaining += pax->sparse_list->remaining;\n ....\n 1820  \n 1821  static ssize_t\n 1822: archive_write_pax_data(struct archive_write *a, const void *buff, size_t s)\n 1823  {\n 1824: \tstruct pax *pax;\n 1825  \tsize_t ws;\n 1826  \tsize_t total;\n 1827  \tint ret;\n 1828  \n 1829: \tpax = (struct pax *)a->format_data;\n 1830  \n 1831  \t/*\n ....\n 1850  \t\twhile (pax->sparse_list != NULL &&\n 1851  \t\t    pax->sparse_list->remaining == 0) {\n 1852: \t\t\tstruct sparse_block *sb = pax->sparse_list->next;\n 1853  \t\t\tfree(pax->sparse_list);\n 1854  \t\t\tpax->sparse_list = sb;\n ....\n 1988  \n 1989  static void\n 1990: sparse_list_clear(struct pax *pax)\n 1991  {\n 1992  \twhile (pax->sparse_list != NULL) {\n 1993: \t\tstruct sparse_block *sb = pax->sparse_list;\n 1994  \t\tpax->sparse_list = sb->next;\n 1995  \t\tfree(sb);\n ....\n 1999  \n 2000  static int\n 2001: _sparse_list_add_block(struct pax *pax, int64_t offset, int64_t length,\n 2002      int is_hole)\n 2003  {\n 2004: \tstruct sparse_block *sb;\n 2005  \n 2006: \tsb = (struct sparse_block *)malloc(sizeof(*sb));\n 2007  \tif (sb == NULL)\n 2008  \t\treturn (ARCHIVE_FATAL);\n ....\n 2021  \n 2022  static int\n 2023: sparse_list_add(struct pax *pax, int64_t offset, int64_t length)\n 2024  {\n 2025  \tint64_t last_offset;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_xar.c:\n   85   */\n   86  int\n   87: archive_write_set_format_xar(struct archive *_a)\n   88  {\n   89: \tstruct archive_write *a = (struct archive_write *)_a;\n   90  \n   91  \tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n   ..\n  124  };\n  125  \n  126: struct chksumwork {\n  127  \tenum sumalg\t\t alg;\n  128  #ifdef ARCHIVE_HAS_MD5\n  ...\n  142   * Universal zstream.\n  143   */\n  144: struct la_zstream {\n  145  \tconst unsigned char\t*next_in;\n  146  \tsize_t\t\t\t avail_in;\n  ...\n  153  \tint\t\t\t valid;\n  154  \tvoid\t\t\t*real_stream;\n  155: \tint\t\t\t (*code) (struct archive *a,\n  156: \t\t\t\t    struct la_zstream *lastrm,\n  157  \t\t\t\t    enum la_zaction action);\n  158: \tint\t\t\t (*end)(struct archive *a,\n  159: \t\t\t\t    struct la_zstream *lastrm);\n  160  };\n  161  \n  162: struct chksumval {\n  163  \tenum sumalg\t\t alg;\n  164  \tsize_t\t\t\t len;\n  ...\n  166  };\n  167  \n  168: struct heap_data {\n  169  \tint\t\t\t id;\n  170: \tstruct heap_data\t*next;\n  171  \tuint64_t\t\t temp_offset;\n  172  \tuint64_t\t\t length;\t/* archived size.\t*/\n  173  \tuint64_t\t\t size;\t\t/* extracted size.\t*/\n  174  \tenum enctype\t\t compression;\n  175: \tstruct chksumval\t a_sum;\t\t/* archived checksum.\t*/\n  176: \tstruct chksumval\t e_sum;\t\t/* extracted checksum.\t*/\n  177  };\n  178  \n  179: struct file {\n  180: \tstruct archive_rb_node\t rbnode;\n  181  \n  182  \tint\t\t\t id;\n  183: \tstruct archive_entry\t*entry;\n  184  \n  185: \tstruct archive_rb_tree\t rbtree;\n  186: \tstruct file\t\t*next;\n  187: \tstruct file\t\t*chnext;\n  188: \tstruct file\t\t*hlnext;\n  189  \t/* For hardlinked files.\n  190  \t * Use only when archive_entry_nlink() > 1 */\n  191: \tstruct file\t\t*hardlink_target;\n  192: \tstruct file\t\t*parent;\t/* parent directory entry */\n  193  \t/*\n  194  \t * To manage sub directory files.\n  195: \t * We use 'chnext' (a member of struct file) to chain.\n  196  \t */\n  197: \tstruct {\n  198: \t\tstruct file\t*first;\n  199: \t\tstruct file\t**last;\n  200  \t}\t\t\t children;\n  201  \n  202  \t/* For making a directory tree. */\n  203:         struct archive_string    parentdir;\n  204:         struct archive_string    basename;\n  205:         struct archive_string    symlink;\n  206  \n  207  \tint\t\t\t ea_idx;\n  208: \tstruct {\n  209: \t\tstruct heap_data *first;\n  210: \t\tstruct heap_data **last;\n  211  \t}\t\t\t xattr;\n  212: \tstruct heap_data\t data;\n  213:         struct archive_string    script;\n  214  \n  215  \tsigned int\t\t virtual:1;\n  ...\n  217  };\n  218  \n  219: struct hardlink {\n  220: \tstruct archive_rb_node\t rbnode;\n  221  \tint\t\t\t nlink;\n  222: \tstruct {\n  223: \t\tstruct file\t*first;\n  224: \t\tstruct file\t**last;\n  225  \t}\t\t\t file_list;\n  226  };\n  227  \n  228: struct xar {\n  229  \tint\t\t\t temp_fd;\n  230  \tuint64_t\t\t temp_offset;\n  231  \n  232  \tint\t\t\t file_idx;\n  233: \tstruct file\t\t*root;\n  234: \tstruct file\t\t*cur_dirent;\n  235: \tstruct archive_string\t cur_dirstr;\n  236: \tstruct file\t\t*cur_file;\n  237  \tuint64_t\t\t bytes_remaining;\n  238: \tstruct archive_string\t tstr;\n  239: \tstruct archive_string\t vstr;\n  240  \n  241  \tenum sumalg\t\t opt_toc_sumalg;\n  ...\n  245  \tuint32_t\t\t opt_threads;\n  246  \n  247: \tstruct chksumwork\t a_sumwrk;\t/* archived checksum.\t*/\n  248: \tstruct chksumwork\t e_sumwrk;\t/* extracted checksum.\t*/\n  249: \tstruct la_zstream\t stream;\n  250: \tstruct archive_string_conv *sconv;\n  251  \t/*\n  252  \t * Compressed data buffer.\n  ...\n  255  \tsize_t\t\t\t wbuff_remaining;\n  256  \n  257: \tstruct heap_data\t toc;\n  258  \t/*\n  259: \t * The list of all file entries is used to manage struct file\n  260  \t * objects.\n  261: \t * We use 'next' (a member of struct file) to chain.\n  262  \t */\n  263: \tstruct {\n  264: \t\tstruct file\t*first;\n  265: \t\tstruct file\t**last;\n  266  \t}\t\t\t file_list;\n  267  \t/*\n  268  \t * The list of hard-linked file entries.\n  269: \t * We use 'hlnext' (a member of struct file) to chain.\n  270  \t */\n  271: \tstruct archive_rb_tree\t hardlink_rbtree;\n  272  };\n  273  \n  274: static int\txar_options(struct archive_write *,\n  275  \t\t    const char *, const char *);\n  276: static int\txar_write_header(struct archive_write *,\n  277: \t\t    struct archive_entry *);\n  278: static ssize_t\txar_write_data(struct archive_write *,\n  279  \t\t    const void *, size_t);\n  280: static int\txar_finish_entry(struct archive_write *);\n  281: static int\txar_close(struct archive_write *);\n  282: static int\txar_free(struct archive_write *);\n  283  \n  284: static struct file *file_new(struct archive_write *a, struct archive_entry *);\n  285: static void\tfile_free(struct file *);\n  286: static struct file *file_create_virtual_dir(struct archive_write *a, struct xar *,\n  287  \t\t    const char *);\n  288: static int\tfile_add_child_tail(struct file *, struct file *);\n  289: static struct file *file_find_child(struct file *, const char *);\n  290: static int\tfile_gen_utility_names(struct archive_write *,\n  291: \t\t    struct file *);\n  292  static int\tget_path_component(char *, int, const char *);\n  293: static int\tfile_tree(struct archive_write *, struct file **);\n  294: static void\tfile_register(struct xar *, struct file *);\n  295: static void\tfile_init_register(struct xar *);\n  296: static void\tfile_free_register(struct xar *);\n  297: static int\tfile_register_hardlink(struct archive_write *,\n  298: \t\t    struct file *);\n  299: static void\tfile_connect_hardlink_files(struct xar *);\n  300: static void\tfile_init_hardlinks(struct xar *);\n  301: static void\tfile_free_hardlinks(struct xar *);\n  302  \n  303: static void\tchecksum_init(struct chksumwork *, enum sumalg);\n  304: static void\tchecksum_update(struct chksumwork *, const void *, size_t);\n  305: static void\tchecksum_final(struct chksumwork *, struct chksumval *);\n  306: static int\tcompression_init_encoder_gzip(struct archive *,\n  307: \t\t    struct la_zstream *, int, int);\n  308: static int\tcompression_code_gzip(struct archive *,\n  309: \t\t    struct la_zstream *, enum la_zaction);\n  310: static int\tcompression_end_gzip(struct archive *, struct la_zstream *);\n  311: static int\tcompression_init_encoder_bzip2(struct archive *,\n  312: \t\t    struct la_zstream *, int);\n  313  #if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n  314: static int\tcompression_code_bzip2(struct archive *,\n  315: \t\t    struct la_zstream *, enum la_zaction);\n  316: static int\tcompression_end_bzip2(struct archive *, struct la_zstream *);\n  317  #endif\n  318: static int\tcompression_init_encoder_lzma(struct archive *,\n  319: \t\t    struct la_zstream *, int);\n  320: static int\tcompression_init_encoder_xz(struct archive *,\n  321: \t\t    struct la_zstream *, int, int);\n  322  #if defined(HAVE_LZMA_H)\n  323: static int\tcompression_code_lzma(struct archive *,\n  324: \t\t    struct la_zstream *, enum la_zaction);\n  325: static int\tcompression_end_lzma(struct archive *, struct la_zstream *);\n  326  #endif\n  327: static int\txar_compression_init_encoder(struct archive_write *);\n  328: static int\tcompression_code(struct archive *,\n  329: \t\t    struct la_zstream *, enum la_zaction);\n  330: static int\tcompression_end(struct archive *,\n  331: \t\t    struct la_zstream *);\n  332: static int\tsave_xattrs(struct archive_write *, struct file *);\n  333  static int\tgetalgsize(enum sumalg);\n  334  static const char *getalgname(enum sumalg);\n  335  \n  336  int\n  337: archive_write_set_format_xar(struct archive *_a)\n  338  {\n  339: \tstruct archive_write *a = (struct archive_write *)_a;\n  340: \tstruct xar *xar;\n  341  \n  342  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n  ...\n  403  \n  404  static int\n  405: xar_options(struct archive_write *a, const char *key, const char *value)\n  406  {\n  407: \tstruct xar *xar;\n  408  \n  409: \txar = (struct xar *)a->format_data;\n  410  \n  411  \tif (strcmp(key, \"checksum\") == 0) {\n  ...\n  533  \n  534  static int\n  535: xar_write_header(struct archive_write *a, struct archive_entry *entry)\n  536  {\n  537: \tstruct xar *xar;\n  538: \tstruct file *file;\n  539: \tstruct archive_entry *file_entry;\n  540  \tint r, r2;\n  541  \n  542: \txar = (struct xar *)a->format_data;\n  543  \txar->cur_file = NULL;\n  544  \txar->bytes_remaining = 0;\n  ...\n  655  \n  656  static int\n  657: write_to_temp(struct archive_write *a, const void *buff, size_t s)\n  658  {\n  659: \tstruct xar *xar;\n  660  \tconst unsigned char *p;\n  661  \tssize_t ws;\n  662  \n  663: \txar = (struct xar *)a->format_data;\n  664  \tp = (const unsigned char *)buff;\n  665  \twhile (s) {\n  ...\n  678  \n  679  static ssize_t\n  680: xar_write_data(struct archive_write *a, const void *buff, size_t s)\n  681  {\n  682: \tstruct xar *xar;\n  683  \tenum la_zaction run;\n  684  \tsize_t size = 0;\n  ...\n  686  \tint r;\n  687  \n  688: \txar = (struct xar *)a->format_data;\n  689  \n  690  \tif (s > xar->bytes_remaining)\n  ...\n  779  \n  780  static int\n  781: xar_finish_entry(struct archive_write *a)\n  782  {\n  783: \tstruct xar *xar;\n  784: \tstruct file *file;\n  785  \tsize_t s;\n  786  \tssize_t w;\n  787  \n  788: \txar = (struct xar *)a->format_data;\n  789  \tif (xar->cur_file == NULL)\n  790  \t\treturn (ARCHIVE_OK);\n  ...\n  809  \n  810  static int\n  811: xmlwrite_string_attr(struct archive_write *a, xmlTextWriterPtr writer,\n  812  \tconst char *key, const char *value,\n  813  \tconst char *attrkey, const char *attrvalue)\n  ...\n  852  \n  853  static int\n  854: xmlwrite_string(struct archive_write *a, xmlTextWriterPtr writer,\n  855  \tconst char *key, const char *value)\n  856  {\n  ...\n  887  \n  888  static int\n  889: xmlwrite_fstring(struct archive_write *a, xmlTextWriterPtr writer,\n  890  \tconst char *key, const char *fmt, ...)\n  891  {\n  892: \tstruct xar *xar;\n  893  \tva_list ap;\n  894  \n  895: \txar = (struct xar *)a->format_data;\n  896  \tva_start(ap, fmt);\n  897  \tarchive_string_empty(&xar->vstr);\n  ...\n  902  \n  903  static int\n  904: xmlwrite_time(struct archive_write *a, xmlTextWriterPtr writer,\n  905  \tconst char *key, time_t t, int z)\n  906  {\n  907  \tchar timestr[100];\n  908: \tstruct tm tm;\n  909  #if defined(HAVE__GMTIME64_S)\n  910  \t__time64_t tmptime;\n  ...\n  928  \n  929  static int\n  930: xmlwrite_mode(struct archive_write *a, xmlTextWriterPtr writer,\n  931  \tconst char *key, mode_t mode)\n  932  {\n  ...\n  943  \n  944  static int\n  945: xmlwrite_sum(struct archive_write *a, xmlTextWriterPtr writer,\n  946: \tconst char *key, struct chksumval *sum)\n  947  {\n  948  \tconst char *algname;\n  ...\n  977  \n  978  static int\n  979: xmlwrite_heap(struct archive_write *a, xmlTextWriterPtr writer,\n  980: \tstruct heap_data *heap)\n  981  {\n  982  \tconst char *encname;\n  ...\n 1035   */\n 1036  static int\n 1037: make_fflags_entry(struct archive_write *a, xmlTextWriterPtr writer,\n 1038      const char *element, const char *fflags_text)\n 1039  {\n 1040: \tstatic const struct flagentry {\n 1041  \t\tconst char\t*name;\n 1042  \t\tconst char\t*xarname;\n ....\n 1090  \t\t{ NULL, NULL}\n 1091  \t};\n 1092: \tconst struct flagentry *fe, *flagentry;\n 1093  #define FLAGENTRY_MAXSIZE ((sizeof(flagbsd)+sizeof(flagext2))/sizeof(flagbsd))\n 1094: \tconst struct flagentry *avail[FLAGENTRY_MAXSIZE];\n 1095  \tconst char *p;\n 1096  \tint i, n, r;\n ....\n 1151  \n 1152  static int\n 1153: make_file_entry(struct archive_write *a, xmlTextWriterPtr writer,\n 1154:     struct file *file)\n 1155  {\n 1156: \tstruct xar *xar;\n 1157  \tconst char *filetype, *filelink, *fflags;\n 1158: \tstruct archive_string linkto;\n 1159: \tstruct heap_data *heap;\n 1160  \tunsigned char *tmp;\n 1161  \tconst char *p;\n ....\n 1163  \tint r, r2, l, ll;\n 1164  \n 1165: \txar = (struct xar *)a->format_data;\n 1166  \tr2 = ARCHIVE_OK;\n 1167  \n ....\n 1532   */\n 1533  static int\n 1534: make_toc(struct archive_write *a)\n 1535  {\n 1536: \tstruct xar *xar;\n 1537: \tstruct file *np;\n 1538  \txmlBufferPtr bp;\n 1539  \txmlTextWriterPtr writer;\n ....\n 1541  \tint r, ret;\n 1542  \n 1543: \txar = (struct xar *)a->format_data;\n 1544  \n 1545  \tret = ARCHIVE_FATAL;\n ....\n 1782  \n 1783  static int\n 1784: flush_wbuff(struct archive_write *a)\n 1785  {\n 1786: \tstruct xar *xar;\n 1787  \tint r;\n 1788  \tsize_t s;\n 1789  \n 1790: \txar = (struct xar *)a->format_data;\n 1791  \ts = sizeof(xar->wbuff) - xar->wbuff_remaining;\n 1792  \tr = __archive_write_output(a, xar->wbuff, s);\n ....\n 1798  \n 1799  static int\n 1800: copy_out(struct archive_write *a, uint64_t offset, uint64_t length)\n 1801  {\n 1802: \tstruct xar *xar;\n 1803  \tint r;\n 1804  \n 1805: \txar = (struct xar *)a->format_data;\n 1806  \tif (lseek(xar->temp_fd, offset, SEEK_SET) < 0) {\n 1807  \t\tarchive_set_error(&(a->archive), errno, \"lseek failed\");\n ....\n 1842  \n 1843  static int\n 1844: xar_close(struct archive_write *a)\n 1845  {\n 1846: \tstruct xar *xar;\n 1847  \tunsigned char *wb;\n 1848  \tuint64_t length;\n 1849  \tint r;\n 1850  \n 1851: \txar = (struct xar *)a->format_data;\n 1852  \n 1853  \t/* Empty! */\n ....\n 1908  \n 1909  static int\n 1910: xar_free(struct archive_write *a)\n 1911  {\n 1912: \tstruct xar *xar;\n 1913  \n 1914: \txar = (struct xar *)a->format_data;\n 1915  \n 1916  \t/* Close the temporary file. */\n ....\n 1930  \n 1931  static int\n 1932: file_cmp_node(const struct archive_rb_node *n1,\n 1933:     const struct archive_rb_node *n2)\n 1934  {\n 1935: \tconst struct file *f1 = (const struct file *)n1;\n 1936: \tconst struct file *f2 = (const struct file *)n2;\n 1937  \n 1938  \treturn (strcmp(f1->basename.s, f2->basename.s));\n ....\n 1940  \n 1941  static int\n 1942: file_cmp_key(const struct archive_rb_node *n, const void *key)\n 1943  {\n 1944: \tconst struct file *f = (const struct file *)n;\n 1945  \n 1946  \treturn (strcmp(f->basename.s, (const char *)key));\n 1947  }\n 1948  \n 1949: static struct file *\n 1950: file_new(struct archive_write *a, struct archive_entry *entry)\n 1951  {\n 1952: \tstruct file *file;\n 1953: \tstatic const struct archive_rb_tree_ops rb_ops = {\n 1954  \t\tfile_cmp_node, file_cmp_key\n 1955  \t};\n ....\n 1983  \n 1984  static void\n 1985: file_free(struct file *file)\n 1986  {\n 1987: \tstruct heap_data *heap, *next_heap;\n 1988  \n 1989  \theap = file->xattr.first;\n ....\n 2001  }\n 2002  \n 2003: static struct file *\n 2004: file_create_virtual_dir(struct archive_write *a, struct xar *xar,\n 2005      const char *pathname)\n 2006  {\n 2007: \tstruct file *file;\n 2008  \n 2009  \t(void)xar; /* UNUSED */\n ....\n 2022  \n 2023  static int\n 2024: file_add_child_tail(struct file *parent, struct file *child)\n 2025  {\n 2026  \tif (!__archive_rb_tree_insert_node(\n 2027: \t    &(parent->rbtree), (struct archive_rb_node *)child))\n 2028  \t\treturn (0);\n 2029  \tchild->chnext = NULL;\n ....\n 2037   * Find a entry from `parent'\n 2038   */\n 2039: static struct file *\n 2040: file_find_child(struct file *parent, const char *child_name)\n 2041  {\n 2042: \tstruct file *np;\n 2043  \n 2044: \tnp = (struct file *)__archive_rb_tree_find_node(\n 2045  \t    &(parent->rbtree), child_name);\n 2046  \treturn (np);\n ....\n 2068   */\n 2069  static int\n 2070: file_gen_utility_names(struct archive_write *a, struct file *file)\n 2071  {\n 2072: \tstruct xar *xar;\n 2073  \tconst char *pp;\n 2074  \tchar *p, *dirname, *slash;\n ....\n 2076  \tint r = ARCHIVE_OK;\n 2077  \n 2078: \txar = (struct xar *)a->format_data;\n 2079  \tarchive_string_empty(&(file->parentdir));\n 2080  \tarchive_string_empty(&(file->basename));\n ....\n 2253   */\n 2254  static int\n 2255: file_tree(struct archive_write *a, struct file **filepp)\n 2256  {\n 2257  #if defined(_WIN32) && !defined(__CYGWIN__)\n ....\n 2262  \tchar name[256];\n 2263  #endif\n 2264: \tstruct xar *xar = (struct xar *)a->format_data;\n 2265: \tstruct file *dent, *file, *np;\n 2266: \tstruct archive_entry *ent;\n 2267  \tconst char *fn, *p;\n 2268  \tint l;\n ....\n 2284  \t    strcmp(xar->cur_dirstr.s, fn) == 0) {\n 2285  \t\tif (!file_add_child_tail(xar->cur_dirent, file)) {\n 2286: \t\t\tnp = (struct file *)__archive_rb_tree_find_node(\n 2287  \t\t\t    &(xar->cur_dirent->rbtree),\n 2288  \t\t\t    file->basename.s);\n ....\n 2333  \t\t */\n 2334  \t\twhile (fn[0] != '\\0') {\n 2335: \t\t\tstruct file *vp;\n 2336: \t\t\tstruct archive_string as;\n 2337  \n 2338  \t\t\tarchive_string_init(&as);\n ....\n 2395  \n 2396  \t\tif (!file_add_child_tail(dent, file)) {\n 2397: \t\t\tnp = (struct file *)__archive_rb_tree_find_node(\n 2398  \t\t\t    &(dent->rbtree), file->basename.s);\n 2399  \t\t\tgoto same_entry;\n ....\n 2430  \n 2431  static void\n 2432: file_register(struct xar *xar, struct file *file)\n 2433  {\n 2434  \tfile->id = xar->file_idx++;\n ....\n 2439  \n 2440  static void\n 2441: file_init_register(struct xar *xar)\n 2442  {\n 2443  \txar->file_list.first = NULL;\n ....\n 2446  \n 2447  static void\n 2448: file_free_register(struct xar *xar)\n 2449  {\n 2450: \tstruct file *file, *file_next;\n 2451  \n 2452  \tfile = xar->file_list.first;\n ....\n 2462   */\n 2463  static int\n 2464: file_register_hardlink(struct archive_write *a, struct file *file)\n 2465  {\n 2466: \tstruct xar *xar = (struct xar *)a->format_data;\n 2467: \tstruct hardlink *hl;\n 2468  \tconst char *pathname;\n 2469  \n ....\n 2484  \t\thl->file_list.last = &(file->hlnext);\n 2485  \t\t__archive_rb_tree_insert_node(&(xar->hardlink_rbtree),\n 2486: \t\t    (struct archive_rb_node *)hl);\n 2487  \t} else {\n 2488: \t\thl = (struct hardlink *)__archive_rb_tree_find_node(\n 2489  \t\t    &(xar->hardlink_rbtree), pathname);\n 2490  \t\tif (hl != NULL) {\n ....\n 2507   */\n 2508  static void\n 2509: file_connect_hardlink_files(struct xar *xar)\n 2510  {\n 2511: \tstruct archive_rb_node *n;\n 2512: \tstruct hardlink *hl;\n 2513: \tstruct file *target, *nf;\n 2514  \n 2515  \tARCHIVE_RB_TREE_FOREACH(n, &(xar->hardlink_rbtree)) {\n 2516: \t\thl = (struct hardlink *)n;\n 2517  \n 2518  \t\t/* The first entry must be a hardlink target. */\n ....\n 2532  \n 2533  static int\n 2534: file_hd_cmp_node(const struct archive_rb_node *n1,\n 2535:     const struct archive_rb_node *n2)\n 2536  {\n 2537: \tconst struct hardlink *h1 = (const struct hardlink *)n1;\n 2538: \tconst struct hardlink *h2 = (const struct hardlink *)n2;\n 2539  \n 2540  \treturn (strcmp(archive_entry_pathname(h1->file_list.first->entry),\n ....\n 2543  \n 2544  static int\n 2545: file_hd_cmp_key(const struct archive_rb_node *n, const void *key)\n 2546  {\n 2547: \tconst struct hardlink *h = (const struct hardlink *)n;\n 2548  \n 2549  \treturn (strcmp(archive_entry_pathname(h->file_list.first->entry),\n ....\n 2553  \n 2554  static void\n 2555: file_init_hardlinks(struct xar *xar)\n 2556  {\n 2557: \tstatic const struct archive_rb_tree_ops rb_ops = {\n 2558  \t\tfile_hd_cmp_node, file_hd_cmp_key,\n 2559  \t};\n ....\n 2563  \n 2564  static void\n 2565: file_free_hardlinks(struct xar *xar)\n 2566  {\n 2567: \tstruct archive_rb_node *n, *tmp;\n 2568  \n 2569  \tARCHIVE_RB_TREE_FOREACH_SAFE(n, &(xar->hardlink_rbtree), tmp) {\n ....\n 2574  \n 2575  static void\n 2576: checksum_init(struct chksumwork *sumwrk, enum sumalg sum_alg)\n 2577  {\n 2578  \tsumwrk->alg = sum_alg;\n ....\n 2590  \n 2591  static void\n 2592: checksum_update(struct chksumwork *sumwrk, const void *buff, size_t size)\n 2593  {\n 2594  \n ....\n 2606  \n 2607  static void\n 2608: checksum_final(struct chksumwork *sumwrk, struct chksumval *sumval)\n 2609  {\n 2610  \n ....\n 2627  #if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR) || !defined(HAVE_LZMA_H)\n 2628  static int\n 2629: compression_unsupported_encoder(struct archive *a,\n 2630:     struct la_zstream *lastrm, const char *name)\n 2631  {\n 2632  \n ....\n 2640  \n 2641  static int\n 2642: compression_init_encoder_gzip(struct archive *a,\n 2643:     struct la_zstream *lastrm, int level, int withheader)\n 2644  {\n 2645  \tz_stream *strm;\n ....\n 2679  \n 2680  static int\n 2681: compression_code_gzip(struct archive *a,\n 2682:     struct la_zstream *lastrm, enum la_zaction action)\n 2683  {\n 2684  \tz_stream *strm;\n ....\n 2717  \n 2718  static int\n 2719: compression_end_gzip(struct archive *a, struct la_zstream *lastrm)\n 2720  {\n 2721  \tz_stream *strm;\n ....\n 2737  #if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n 2738  static int\n 2739: compression_init_encoder_bzip2(struct archive *a,\n 2740:     struct la_zstream *lastrm, int level)\n 2741  {\n 2742  \tbz_stream *strm;\n ....\n 2776  \n 2777  static int\n 2778: compression_code_bzip2(struct archive *a,\n 2779:     struct la_zstream *lastrm, enum la_zaction action)\n 2780  {\n 2781  \tbz_stream *strm;\n ....\n 2823  \n 2824  static int\n 2825: compression_end_bzip2(struct archive *a, struct la_zstream *lastrm)\n 2826  {\n 2827  \tbz_stream *strm;\n ....\n 2843  #else\n 2844  static int\n 2845: compression_init_encoder_bzip2(struct archive *a,\n 2846:     struct la_zstream *lastrm, int level)\n 2847  {\n 2848  \n ....\n 2856  #if defined(HAVE_LZMA_H)\n 2857  static int\n 2858: compression_init_encoder_lzma(struct archive *a,\n 2859:     struct la_zstream *lastrm, int level)\n 2860  {\n 2861  \tstatic const lzma_stream lzma_init_data = LZMA_STREAM_INIT;\n ....\n 2909  \n 2910  static int\n 2911: compression_init_encoder_xz(struct archive *a,\n 2912:     struct la_zstream *lastrm, int level, int threads)\n 2913  {\n 2914  \tstatic const lzma_stream lzma_init_data = LZMA_STREAM_INIT;\n ....\n 2986  \n 2987  static int\n 2988: compression_code_lzma(struct archive *a,\n 2989:     struct la_zstream *lastrm, enum la_zaction action)\n 2990  {\n 2991  \tlzma_stream *strm;\n ....\n 3031  \n 3032  static int\n 3033: compression_end_lzma(struct archive *a, struct la_zstream *lastrm)\n 3034  {\n 3035  \tlzma_stream *strm;\n ....\n 3045  #else\n 3046  static int\n 3047: compression_init_encoder_lzma(struct archive *a,\n 3048:     struct la_zstream *lastrm, int level)\n 3049  {\n 3050  \n ....\n 3055  }\n 3056  static int\n 3057: compression_init_encoder_xz(struct archive *a,\n 3058:     struct la_zstream *lastrm, int level, int threads)\n 3059  {\n 3060  \n ....\n 3068  \n 3069  static int\n 3070: xar_compression_init_encoder(struct archive_write *a)\n 3071  {\n 3072: \tstruct xar *xar;\n 3073  \tint r;\n 3074  \n 3075: \txar = (struct xar *)a->format_data;\n 3076  \tswitch (xar->opt_compression) {\n 3077  \tcase GZIP:\n ....\n 3110  \n 3111  static int\n 3112: compression_code(struct archive *a, struct la_zstream *lastrm,\n 3113      enum la_zaction action)\n 3114  {\n ....\n 3119  \n 3120  static int\n 3121: compression_end(struct archive *a, struct la_zstream *lastrm)\n 3122  {\n 3123  \tif (lastrm->valid)\n ....\n 3128  \n 3129  static int\n 3130: save_xattrs(struct archive_write *a, struct file *file)\n 3131  {\n 3132: \tstruct xar *xar;\n 3133  \tconst char *name;\n 3134  \tconst void *value;\n 3135: \tstruct heap_data *heap;\n 3136  \tsize_t size;\n 3137  \tint count, r;\n 3138  \n 3139: \txar = (struct xar *)a->format_data;\n 3140  \tcount = archive_entry_xattr_reset(file->entry);\n 3141  \tif (count == 0)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_entry_xattr.c:\n   71  \n   72  void\n   73: archive_entry_xattr_clear(struct archive_entry *entry)\n   74  {\n   75: \tstruct ae_xattr\t*xp;\n   76  \n   77  \twhile (entry->xattr_head != NULL) {\n   ..\n   87  \n   88  void\n   89: archive_entry_xattr_add_entry(struct archive_entry *entry,\n   90  \tconst char *name, const void *value, size_t size)\n   91  {\n   92: \tstruct ae_xattr\t*xp;\n   93  \n   94: \tif ((xp = (struct ae_xattr *)malloc(sizeof(struct ae_xattr))) == NULL)\n   95  \t\t__archive_errx(1, \"Out of memory\");\n   96  \n   ..\n  113   */\n  114  int\n  115: archive_entry_xattr_count(struct archive_entry *entry)\n  116  {\n  117: \tstruct ae_xattr *xp;\n  118  \tint count = 0;\n  119  \n  ...\n  125  \n  126  int\n  127: archive_entry_xattr_reset(struct archive_entry * entry)\n  128  {\n  129  \tentry->xattr_p = entry->xattr_head;\n  ...\n  133  \n  134  int\n  135: archive_entry_xattr_next(struct archive_entry * entry,\n  136  \tconst char **name, const void **value, size_t *size)\n  137  {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_entry_locale.h:\n   33  #endif\n   34  \n   35: struct archive_entry;\n   36: struct archive_string_conv;\n   37  \n   38  /*\n   ..\n   48  \n   49  #define archive_entry_gname_l\t_archive_entry_gname_l\n   50: int _archive_entry_gname_l(struct archive_entry *,\n   51:     const char **, size_t *, struct archive_string_conv *);\n   52  #define archive_entry_hardlink_l\t_archive_entry_hardlink_l\n   53: int _archive_entry_hardlink_l(struct archive_entry *,\n   54:     const char **, size_t *, struct archive_string_conv *);\n   55  #define archive_entry_pathname_l\t_archive_entry_pathname_l\n   56: int _archive_entry_pathname_l(struct archive_entry *,\n   57:     const char **, size_t *, struct archive_string_conv *);\n   58  #define archive_entry_symlink_l\t_archive_entry_symlink_l\n   59: int _archive_entry_symlink_l(struct archive_entry *,\n   60:     const char **, size_t *, struct archive_string_conv *);\n   61  #define archive_entry_uname_l\t_archive_entry_uname_l\n   62: int _archive_entry_uname_l(struct archive_entry *,\n   63:     const char **, size_t *, struct archive_string_conv *);\n   64  #define archive_entry_acl_text_l _archive_entry_acl_text_l\n   65: int _archive_entry_acl_text_l(struct archive_entry *, int,\n   66: const char **, size_t *, struct archive_string_conv *) __LA_DEPRECATED;\n   67  #define archive_entry_acl_to_text_l _archive_entry_acl_to_text_l\n   68: char *_archive_entry_acl_to_text_l(struct archive_entry *, ssize_t *, int,\n   69:     struct archive_string_conv *);\n   70  #define archive_entry_acl_from_text_l _archive_entry_acl_from_text_l\n   71: int _archive_entry_acl_from_text_l(struct archive_entry *, const char* text,\n   72:     int type, struct archive_string_conv *);\n   73  #define archive_entry_copy_gname_l\t_archive_entry_copy_gname_l\n   74: int _archive_entry_copy_gname_l(struct archive_entry *,\n   75:     const char *, size_t, struct archive_string_conv *);\n   76  #define archive_entry_copy_hardlink_l\t_archive_entry_copy_hardlink_l\n   77: int _archive_entry_copy_hardlink_l(struct archive_entry *,\n   78:     const char *, size_t, struct archive_string_conv *);\n   79  #define archive_entry_copy_link_l\t_archive_entry_copy_link_l\n   80: int _archive_entry_copy_link_l(struct archive_entry *,\n   81:     const char *, size_t, struct archive_string_conv *);\n   82  #define archive_entry_copy_pathname_l\t_archive_entry_copy_pathname_l\n   83: int _archive_entry_copy_pathname_l(struct archive_entry *,\n   84:     const char *, size_t, struct archive_string_conv *);\n   85  #define archive_entry_copy_symlink_l\t_archive_entry_copy_symlink_l\n   86: int _archive_entry_copy_symlink_l(struct archive_entry *,\n   87:     const char *, size_t, struct archive_string_conv *);\n   88  #define archive_entry_copy_uname_l\t_archive_entry_copy_uname_l\n   89: int _archive_entry_copy_uname_l(struct archive_entry *,\n   90:     const char *, size_t, struct archive_string_conv *);\n   91  \n   92  #endif /* ARCHIVE_ENTRY_LOCALE_H_INCLUDED */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter_lz4.c:\n   53  #define LZ4_MAGICNUMBER\t0x184d2204\n   54  \n   55: struct private_data {\n   56  \tint\t\t compression_level;\n   57  \tunsigned\t header_written:1;\n   ..\n   78  \tvoid\t\t*lz4_stream;\n   79  #else\n   80: \tstruct archive_write_program_data *pdata;\n   81  #endif\n   82  };\n   83  \n   84: static int archive_filter_lz4_close(struct archive_write_filter *);\n   85: static int archive_filter_lz4_free(struct archive_write_filter *);\n   86: static int archive_filter_lz4_open(struct archive_write_filter *);\n   87: static int archive_filter_lz4_options(struct archive_write_filter *,\n   88  \t\t    const char *, const char *);\n   89: static int archive_filter_lz4_write(struct archive_write_filter *,\n   90  \t\t    const void *, size_t);\n   91  \n   ..\n   94   */\n   95  int\n   96: archive_write_add_filter_lz4(struct archive *_a)\n   97  {\n   98: \tstruct archive_write *a = (struct archive_write *)_a;\n   99: \tstruct archive_write_filter *f = __archive_write_allocate_filter(_a);\n  100: \tstruct private_data *data;\n  101  \n  102  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n  ...\n  155   */\n  156  static int\n  157: archive_filter_lz4_options(struct archive_write_filter *f,\n  158      const char *key, const char *value)\n  159  {\n  160: \tstruct private_data *data = (struct private_data *)f->data;\n  161  \n  162  \tif (strcmp(key, \"compression-level\") == 0) {\n  ...\n  206  /* Don't compile this if we don't have liblz4. */\n  207  \n  208: static int drive_compressor(struct archive_write_filter *, const char *,\n  209      size_t);\n  210: static int drive_compressor_independence(struct archive_write_filter *,\n  211      const char *, size_t);\n  212: static int drive_compressor_dependence(struct archive_write_filter *,\n  213      const char *, size_t);\n  214: static int lz4_write_stream_descriptor(struct archive_write_filter *);\n  215: static ssize_t lz4_write_one_block(struct archive_write_filter *, const char *,\n  216      size_t);\n  217  \n  ...\n  221   */\n  222  static int\n  223: archive_filter_lz4_open(struct archive_write_filter *f)\n  224  {\n  225: \tstruct private_data *data = (struct private_data *)f->data;\n  226  \tsize_t required_size;\n  227  \tstatic size_t const bkmap[] = { 64 * 1024, 256 * 1024, 1 * 1024 * 1024,\n  ...\n  286   */\n  287  static int\n  288: archive_filter_lz4_write(struct archive_write_filter *f,\n  289      const void *buff, size_t length)\n  290  {\n  291: \tstruct private_data *data = (struct private_data *)f->data;\n  292  \tint ret = ARCHIVE_OK;\n  293  \tconst char *p;\n  ...\n  336   */\n  337  static int\n  338: archive_filter_lz4_close(struct archive_write_filter *f)\n  339  {\n  340: \tstruct private_data *data = (struct private_data *)f->data;\n  341  \tint ret;\n  342  \n  ...\n  366  \n  367  static int\n  368: archive_filter_lz4_free(struct archive_write_filter *f)\n  369  {\n  370: \tstruct private_data *data = (struct private_data *)f->data;\n  371  \n  372  \tif (data->lz4_stream != NULL) {\n  ...\n  395  \n  396  static int\n  397: lz4_write_stream_descriptor(struct archive_write_filter *f)\n  398  {\n  399: \tstruct private_data *data = (struct private_data *)f->data;\n  400  \tuint8_t *sd;\n  401  \n  ...\n  422  \n  423  static ssize_t\n  424: lz4_write_one_block(struct archive_write_filter *f, const char *p,\n  425      size_t length)\n  426  {\n  427: \tstruct private_data *data = (struct private_data *)f->data;\n  428  \tssize_t r;\n  429  \n  ...\n  471   */\n  472  static int\n  473: drive_compressor(struct archive_write_filter *f, const char *p, size_t length)\n  474  {\n  475: \tstruct private_data *data = (struct private_data *)f->data;\n  476  \n  477  \tif (data->stream_checksum)\n  ...\n  485  \n  486  static int\n  487: drive_compressor_independence(struct archive_write_filter *f, const char *p,\n  488      size_t length)\n  489  {\n  490: \tstruct private_data *data = (struct private_data *)f->data;\n  491  \tunsigned int outsize;\n  492  \n  ...\n  535  \n  536  static int\n  537: drive_compressor_dependence(struct archive_write_filter *f, const char *p,\n  538      size_t length)\n  539  {\n  540: \tstruct private_data *data = (struct private_data *)f->data;\n  541  \tint outsize;\n  542  \n  ...\n  639  \n  640  static int\n  641: archive_filter_lz4_open(struct archive_write_filter *f)\n  642  {\n  643: \tstruct private_data *data = (struct private_data *)f->data;\n  644: \tstruct archive_string as;\n  645  \tint r;\n  646  \n  ...\n  672  \n  673  static int\n  674: archive_filter_lz4_write(struct archive_write_filter *f, const void *buff,\n  675      size_t length)\n  676  {\n  677: \tstruct private_data *data = (struct private_data *)f->data;\n  678  \n  679  \treturn __archive_write_program_write(f, data->pdata, buff, length);\n  ...\n  681  \n  682  static int\n  683: archive_filter_lz4_close(struct archive_write_filter *f)\n  684  {\n  685: \tstruct private_data *data = (struct private_data *)f->data;\n  686  \n  687  \treturn __archive_write_program_close(f, data->pdata);\n  ...\n  689  \n  690  static int\n  691: archive_filter_lz4_free(struct archive_write_filter *f)\n  692  {\n  693: \tstruct private_data *data = (struct private_data *)f->data;\n  694  \n  695  \t__archive_write_program_free(data->pdata);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_ppmd8.c:\n   37  typedef CPpmd8_Context * CTX_PTR;\n   38  \n   39: struct CPpmd8_Node_;\n   40  \n   41  typedef\n   42    #ifdef PPMD_32BIT\n   43:     struct CPpmd8_Node_ *\n   44    #else\n   45      UInt32\n   ..\n   47    CPpmd8_Node_Ref;\n   48  \n   49: typedef struct CPpmd8_Node_\n   50  {\n   51    UInt32 Stamp;\n   ..\n   62  #define EMPTY_NODE 0xFFFFFFFF\n   63  \n   64: void Ppmd8_Construct(CPpmd8 *p)\n   65  {\n   66    unsigned i, k, m;\n   ..\n 1279  const IPpmd8 __archive_ppmd8_functions =\n 1280  {\n 1281:   &Ppmd8_Construct,\n 1282    &Ppmd8_Alloc,\n 1283    &Ppmd8_Free,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_7zip.c:\n  100   * A stream object of universal compressor.\n  101   */\n  102: struct la_zstream {\n  103  \tconst uint8_t\t\t*next_in;\n  104  \tsize_t\t\t\t avail_in;\n  ...\n  114  \tint\t\t\t valid;\n  115  \tvoid\t\t\t*real_stream;\n  116: \tint\t\t\t (*code) (struct archive *a,\n  117: \t\t\t\t    struct la_zstream *lastrm,\n  118  \t\t\t\t    enum la_zaction action);\n  119: \tint\t\t\t (*end)(struct archive *a,\n  120: \t\t\t\t    struct la_zstream *lastrm);\n  121  };\n  122  \n  ...\n  124  #define PPMD7_DEFAULT_MEM_SIZE\t(1 << 24)\n  125  \n  126: struct ppmd_stream {\n  127  \tint\t\t\t stat;\n  128  \tCPpmd7\t\t\t ppmd7_context;\n  ...\n  135  };\n  136  \n  137: struct coder {\n  138  \tunsigned\t\t codec;\n  139  \tsize_t\t\t\t prop_size;\n  ...\n  141  };\n  142  \n  143: struct file {\n  144: \tstruct archive_rb_node\t rbnode;\n  145  \n  146: \tstruct file\t\t*next;\n  147  \tunsigned\t\t name_len;\n  148  \tuint8_t\t\t\t*utf16name;/* UTF16-LE name. */\n  ...\n  155  #define HAS_STREAM\t(1<<4)\n  156  \n  157: \tstruct {\n  158  \t\ttime_t\t\t time;\n  159  \t\tlong\t\t time_ns;\n  ...\n  169  };\n  170  \n  171: struct _7zip {\n  172  \tint\t\t\t temp_fd;\n  173  \tuint64_t\t\t temp_offset;\n  174  \n  175: \tstruct file\t\t*cur_file;\n  176  \tsize_t\t\t\t total_number_entry;\n  177  \tsize_t\t\t\t total_number_nonempty_entry;\n  ...\n  193  \tint\t\t\t opt_compression_level;\n  194  \n  195: \tstruct la_zstream\t stream;\n  196: \tstruct coder\t\t coder;\n  197  \n  198: \tstruct archive_string_conv *sconv;\n  199  \n  200  \t/*\n  ...\n  206  \t/*\n  207  \t * The list of the file entries which has its contents is used to\n  208: \t * manage struct file objects.\n  209: \t * We use 'next' (a member of struct file) to chain.\n  210  \t */\n  211: \tstruct {\n  212: \t\tstruct file\t*first;\n  213: \t\tstruct file\t**last;\n  214  \t}\t\t\t file_list, empty_list;\n  215: \tstruct archive_rb_tree\t rbtree;/* for empty files */\n  216  };\n  217  \n  218: static int\t_7z_options(struct archive_write *,\n  219  \t\t    const char *, const char *);\n  220: static int\t_7z_write_header(struct archive_write *,\n  221: \t\t    struct archive_entry *);\n  222: static ssize_t\t_7z_write_data(struct archive_write *,\n  223  \t\t    const void *, size_t);\n  224: static int\t_7z_finish_entry(struct archive_write *);\n  225: static int\t_7z_close(struct archive_write *);\n  226: static int\t_7z_free(struct archive_write *);\n  227: static int\tfile_cmp_node(const struct archive_rb_node *,\n  228: \t\t    const struct archive_rb_node *);\n  229: static int\tfile_cmp_key(const struct archive_rb_node *, const void *);\n  230: static int\tfile_new(struct archive_write *a, struct archive_entry *,\n  231: \t\t    struct file **);\n  232: static void\tfile_free(struct file *);\n  233: static void\tfile_register(struct _7zip *, struct file *);\n  234: static void\tfile_register_empty(struct _7zip *, struct file *);\n  235: static void\tfile_init_register(struct _7zip *);\n  236: static void\tfile_init_register_empty(struct _7zip *);\n  237: static void\tfile_free_register(struct _7zip *);\n  238: static ssize_t\tcompress_out(struct archive_write *, const void *, size_t ,\n  239  \t\t    enum la_zaction);\n  240: static int\tcompression_init_encoder_copy(struct archive *,\n  241: \t\t    struct la_zstream *);\n  242: static int\tcompression_code_copy(struct archive *,\n  243: \t\t    struct la_zstream *, enum la_zaction);\n  244: static int\tcompression_end_copy(struct archive *, struct la_zstream *);\n  245: static int\tcompression_init_encoder_deflate(struct archive *,\n  246: \t\t    struct la_zstream *, int, int);\n  247  #ifdef HAVE_ZLIB_H\n  248: static int\tcompression_code_deflate(struct archive *,\n  249: \t\t    struct la_zstream *, enum la_zaction);\n  250: static int\tcompression_end_deflate(struct archive *, struct la_zstream *);\n  251  #endif\n  252: static int\tcompression_init_encoder_bzip2(struct archive *,\n  253: \t\t    struct la_zstream *, int);\n  254  #if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n  255: static int\tcompression_code_bzip2(struct archive *,\n  256: \t\t    struct la_zstream *, enum la_zaction);\n  257: static int\tcompression_end_bzip2(struct archive *, struct la_zstream *);\n  258  #endif\n  259: static int\tcompression_init_encoder_lzma1(struct archive *,\n  260: \t\t    struct la_zstream *, int);\n  261: static int\tcompression_init_encoder_lzma2(struct archive *,\n  262: \t\t    struct la_zstream *, int);\n  263  #if defined(HAVE_LZMA_H)\n  264: static int\tcompression_code_lzma(struct archive *,\n  265: \t\t    struct la_zstream *, enum la_zaction);\n  266: static int\tcompression_end_lzma(struct archive *, struct la_zstream *);\n  267  #endif\n  268: static int\tcompression_init_encoder_ppmd(struct archive *,\n  269: \t\t    struct la_zstream *, unsigned, uint32_t);\n  270: static int\tcompression_code_ppmd(struct archive *,\n  271: \t\t    struct la_zstream *, enum la_zaction);\n  272: static int\tcompression_end_ppmd(struct archive *, struct la_zstream *);\n  273: static int\t_7z_compression_init_encoder(struct archive_write *, unsigned,\n  274  \t\t    int);\n  275: static int\tcompression_code(struct archive *,\n  276: \t\t    struct la_zstream *, enum la_zaction);\n  277: static int\tcompression_end(struct archive *,\n  278: \t\t    struct la_zstream *);\n  279: static int\tenc_uint64(struct archive_write *, uint64_t);\n  280: static int\tmake_header(struct archive_write *, uint64_t, uint64_t,\n  281: \t\t    uint64_t, int, struct coder *);\n  282: static int\tmake_streamsInfo(struct archive_write *, uint64_t, uint64_t,\n  283: \t\t    \tuint64_t, int, struct coder *, int, uint32_t);\n  284  \n  285  int\n  286: archive_write_set_format_7zip(struct archive *_a)\n  287  {\n  288: \tstatic const struct archive_rb_tree_ops rb_ops = {\n  289  \t\tfile_cmp_node, file_cmp_key\n  290  \t};\n  291: \tstruct archive_write *a = (struct archive_write *)_a;\n  292: \tstruct _7zip *zip;\n  293  \n  294  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n  ...\n  338  \n  339  static int\n  340: _7z_options(struct archive_write *a, const char *key, const char *value)\n  341  {\n  342: \tstruct _7zip *zip;\n  343  \n  344: \tzip = (struct _7zip *)a->format_data;\n  345  \n  346  \tif (strcmp(key, \"compression\") == 0) {\n  ...\n  422  \n  423  static int\n  424: _7z_write_header(struct archive_write *a, struct archive_entry *entry)\n  425  {\n  426: \tstruct _7zip *zip;\n  427: \tstruct file *file;\n  428  \tint r;\n  429  \n  430: \tzip = (struct _7zip *)a->format_data;\n  431  \tzip->cur_file = NULL;\n  432  \tzip->entry_bytes_remaining = 0;\n  ...\n  447  \tif (file->size == 0 && file->dir) {\n  448  \t\tif (!__archive_rb_tree_insert_node(&(zip->rbtree),\n  449: \t\t    (struct archive_rb_node *)file)) {\n  450  \t\t\t/* We have already had the same file. */\n  451  \t\t\tfile_free(file);\n  ...\n  518   */\n  519  static int\n  520: write_to_temp(struct archive_write *a, const void *buff, size_t s)\n  521  {\n  522: \tstruct _7zip *zip;\n  523  \tconst unsigned char *p;\n  524  \tssize_t ws;\n  525  \n  526: \tzip = (struct _7zip *)a->format_data;\n  527  \n  528  \t/*\n  ...\n  555  \n  556  static ssize_t\n  557: compress_out(struct archive_write *a, const void *buff, size_t s,\n  558      enum la_zaction run)\n  559  {\n  560: \tstruct _7zip *zip = (struct _7zip *)a->format_data;\n  561  \tint r;\n  562  \n  ...\n  602  \n  603  static ssize_t\n  604: _7z_write_data(struct archive_write *a, const void *buff, size_t s)\n  605  {\n  606: \tstruct _7zip *zip;\n  607  \tssize_t bytes;\n  608  \n  609: \tzip = (struct _7zip *)a->format_data;\n  610  \n  611  \tif (s > zip->entry_bytes_remaining)\n  ...\n  622  \n  623  static int\n  624: _7z_finish_entry(struct archive_write *a)\n  625  {\n  626: \tstruct _7zip *zip;\n  627  \tsize_t s;\n  628  \tssize_t r;\n  629  \n  630: \tzip = (struct _7zip *)a->format_data;\n  631  \tif (zip->cur_file == NULL)\n  632  \t\treturn (ARCHIVE_OK);\n  ...\n  649  \n  650  static int\n  651: flush_wbuff(struct archive_write *a)\n  652  {\n  653: \tstruct _7zip *zip;\n  654  \tint r;\n  655  \tsize_t s;\n  656  \n  657: \tzip = (struct _7zip *)a->format_data;\n  658  \ts = sizeof(zip->wbuff) - zip->wbuff_remaining;\n  659  \tr = __archive_write_output(a, zip->wbuff, s);\n  ...\n  665  \n  666  static int\n  667: copy_out(struct archive_write *a, uint64_t offset, uint64_t length)\n  668  {\n  669: \tstruct _7zip *zip;\n  670  \tint r;\n  671  \n  672: \tzip = (struct _7zip *)a->format_data;\n  673  \tif (zip->temp_offset > 0 &&\n  674  \t    lseek(zip->temp_fd, offset, SEEK_SET) < 0) {\n  ...\n  710  \n  711  static int\n  712: _7z_close(struct archive_write *a)\n  713  {\n  714: \tstruct _7zip *zip;\n  715  \tunsigned char *wb;\n  716  \tuint64_t header_offset, header_size, header_unpacksize;\n  ...\n  719  \tint r;\n  720  \n  721: \tzip = (struct _7zip *)a->format_data;\n  722  \n  723  \tif (zip->total_number_entry > 0) {\n  724: \t\tstruct archive_rb_node *n;\n  725  \t\tuint64_t data_offset, data_size, data_unpacksize;\n  726  \t\tunsigned header_compression;\n  ...\n  747  \t\t/* Connect a directory file list. */\n  748  \t\tARCHIVE_RB_TREE_FOREACH(n, &(zip->rbtree)) {\n  749: \t\t\tfile_register(zip, (struct file *)n);\n  750  \t\t}\n  751  \n  ...\n  858   */\n  859  static int\n  860: enc_uint64(struct archive_write *a, uint64_t val)\n  861  {\n  862  \tunsigned mask = 0x80;\n  ...\n  879  \n  880  static int\n  881: make_substreamsInfo(struct archive_write *a, struct coder *coders)\n  882  {\n  883: \tstruct _7zip *zip = (struct _7zip *)a->format_data;\n  884: \tstruct file *file;\n  885  \tint r;\n  886  \n  ...\n  953  \n  954  static int\n  955: make_streamsInfo(struct archive_write *a, uint64_t offset, uint64_t pack_size,\n  956:     uint64_t unpack_size, int num_coder, struct coder *coders, int substrm,\n  957      uint32_t header_crc)\n  958  {\n  959: \tstruct _7zip *zip = (struct _7zip *)a->format_data;\n  960  \tuint8_t codec_buff[8];\n  961  \tint numFolders, fi;\n  ...\n  991  \n  992  \tif (numFolders > 1) {\n  993: \t\tstruct file *file = zip->file_list.first;\n  994  \t\tfor (;file != NULL; file = file->next) {\n  995  \t\t\tif (file->size == 0)\n  ...\n 1088  \n 1089  \tif (numFolders > 1) {\n 1090: \t\tstruct file *file = zip->file_list.first;\n 1091  \t\tfor (;file != NULL; file = file->next) {\n 1092  \t\t\tif (file->size == 0)\n ....\n 1161  \n 1162  static int\n 1163: make_time(struct archive_write *a, uint8_t type, unsigned flg, int ti)\n 1164  {\n 1165  \tuint8_t filetime[8];\n 1166: \tstruct _7zip *zip = (struct _7zip *)a->format_data;\n 1167: \tstruct file *file;\n 1168  \tint r;\n 1169  \tuint8_t b, mask;\n ....\n 1250  \n 1251  static int\n 1252: make_header(struct archive_write *a, uint64_t offset, uint64_t pack_size,\n 1253:     uint64_t unpack_size, int codernum, struct coder *coders)\n 1254  {\n 1255: \tstruct _7zip *zip = (struct _7zip *)a->format_data;\n 1256: \tstruct file *file;\n 1257  \tint r;\n 1258  \tuint8_t b, mask;\n ....\n 1454  \n 1455  static int\n 1456: _7z_free(struct archive_write *a)\n 1457  {\n 1458: \tstruct _7zip *zip = (struct _7zip *)a->format_data;\n 1459  \n 1460  \t/* Close the temporary file. */\n ....\n 1471  \n 1472  static int\n 1473: file_cmp_node(const struct archive_rb_node *n1,\n 1474:     const struct archive_rb_node *n2)\n 1475  {\n 1476: \tconst struct file *f1 = (const struct file *)n1;\n 1477: \tconst struct file *f2 = (const struct file *)n2;\n 1478  \n 1479  \tif (f1->name_len == f2->name_len)\n ....\n 1483          \n 1484  static int\n 1485: file_cmp_key(const struct archive_rb_node *n, const void *key)\n 1486  {\n 1487: \tconst struct file *f = (const struct file *)n;\n 1488  \n 1489  \treturn (f->name_len - *(const char *)key);\n ....\n 1491  \n 1492  static int\n 1493: file_new(struct archive_write *a, struct archive_entry *entry,\n 1494:     struct file **newfile)\n 1495  {\n 1496: \tstruct _7zip *zip;\n 1497: \tstruct file *file;\n 1498  \tconst char *u16;\n 1499  \tsize_t u16len;\n 1500  \tint ret = ARCHIVE_OK;\n 1501  \n 1502: \tzip = (struct _7zip *)a->format_data;\n 1503  \t*newfile = NULL;\n 1504  \n ....\n 1563  \n 1564  static void\n 1565: file_free(struct file *file)\n 1566  {\n 1567  \tfree(file->utf16name);\n ....\n 1570  \n 1571  static void\n 1572: file_register(struct _7zip *zip, struct file *file)\n 1573  {\n 1574  \tfile->next = NULL;\n ....\n 1578  \n 1579  static void\n 1580: file_init_register(struct _7zip *zip)\n 1581  {\n 1582  \tzip->file_list.first = NULL;\n ....\n 1585  \n 1586  static void\n 1587: file_free_register(struct _7zip *zip)\n 1588  {\n 1589: \tstruct file *file, *file_next;\n 1590  \n 1591  \tfile = zip->file_list.first;\n ....\n 1598  \n 1599  static void\n 1600: file_register_empty(struct _7zip *zip, struct file *file)\n 1601  {\n 1602  \tfile->next = NULL;\n ....\n 1606  \n 1607  static void\n 1608: file_init_register_empty(struct _7zip *zip)\n 1609  {\n 1610  \tzip->empty_list.first = NULL;\n ....\n 1615  \t !defined(BZ_CONFIG_ERROR) || !defined(HAVE_LZMA_H)\n 1616  static int\n 1617: compression_unsupported_encoder(struct archive *a,\n 1618:     struct la_zstream *lastrm, const char *name)\n 1619  {\n 1620  \n ....\n 1631   */\n 1632  static int\n 1633: compression_init_encoder_copy(struct archive *a, struct la_zstream *lastrm)\n 1634  {\n 1635  \n ....\n 1643  \n 1644  static int\n 1645: compression_code_copy(struct archive *a,\n 1646:     struct la_zstream *lastrm, enum la_zaction action)\n 1647  {\n 1648  \tsize_t bytes;\n ....\n 1668  \n 1669  static int\n 1670: compression_end_copy(struct archive *a, struct la_zstream *lastrm)\n 1671  {\n 1672  \t(void)a; /* UNUSED */\n ....\n 1680  #ifdef HAVE_ZLIB_H\n 1681  static int\n 1682: compression_init_encoder_deflate(struct archive *a,\n 1683:     struct la_zstream *lastrm, int level, int withheader)\n 1684  {\n 1685  \tz_stream *strm;\n ....\n 1719  \n 1720  static int\n 1721: compression_code_deflate(struct archive *a,\n 1722:     struct la_zstream *lastrm, enum la_zaction action)\n 1723  {\n 1724  \tz_stream *strm;\n ....\n 1757  \n 1758  static int\n 1759: compression_end_deflate(struct archive *a, struct la_zstream *lastrm)\n 1760  {\n 1761  \tz_stream *strm;\n ....\n 1776  #else\n 1777  static int\n 1778: compression_init_encoder_deflate(struct archive *a,\n 1779:     struct la_zstream *lastrm, int level, int withheader)\n 1780  {\n 1781  \n ....\n 1793  #if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n 1794  static int\n 1795: compression_init_encoder_bzip2(struct archive *a,\n 1796:     struct la_zstream *lastrm, int level)\n 1797  {\n 1798  \tbz_stream *strm;\n ....\n 1832  \n 1833  static int\n 1834: compression_code_bzip2(struct archive *a,\n 1835:     struct la_zstream *lastrm, enum la_zaction action)\n 1836  {\n 1837  \tbz_stream *strm;\n ....\n 1879  \n 1880  static int\n 1881: compression_end_bzip2(struct archive *a, struct la_zstream *lastrm)\n 1882  {\n 1883  \tbz_stream *strm;\n ....\n 1899  #else\n 1900  static int\n 1901: compression_init_encoder_bzip2(struct archive *a,\n 1902:     struct la_zstream *lastrm, int level)\n 1903  {\n 1904  \n ....\n 1915  #if defined(HAVE_LZMA_H)\n 1916  static int\n 1917: compression_init_encoder_lzma(struct archive *a,\n 1918:     struct la_zstream *lastrm, int level, uint64_t filter_id)\n 1919  {\n 1920  \tstatic const lzma_stream lzma_init_data = LZMA_STREAM_INIT;\n ....\n 2004  \n 2005  static int\n 2006: compression_init_encoder_lzma1(struct archive *a,\n 2007:     struct la_zstream *lastrm, int level)\n 2008  {\n 2009  \treturn compression_init_encoder_lzma(a, lastrm, level,\n ....\n 2012  \n 2013  static int\n 2014: compression_init_encoder_lzma2(struct archive *a,\n 2015:     struct la_zstream *lastrm, int level)\n 2016  {\n 2017  \treturn compression_init_encoder_lzma(a, lastrm, level,\n ....\n 2020  \n 2021  static int\n 2022: compression_code_lzma(struct archive *a,\n 2023:     struct la_zstream *lastrm, enum la_zaction action)\n 2024  {\n 2025  \tlzma_stream *strm;\n ....\n 2065  \n 2066  static int\n 2067: compression_end_lzma(struct archive *a, struct la_zstream *lastrm)\n 2068  {\n 2069  \tlzma_stream *strm;\n ....\n 2079  #else\n 2080  static int\n 2081: compression_init_encoder_lzma1(struct archive *a,\n 2082:     struct la_zstream *lastrm, int level)\n 2083  {\n 2084  \n ....\n 2089  }\n 2090  static int\n 2091: compression_init_encoder_lzma2(struct archive *a,\n 2092:     struct la_zstream *lastrm, int level)\n 2093  {\n 2094  \n ....\n 2106  ppmd_write(void *p, Byte b)\n 2107  {\n 2108: \tstruct archive_write *a = ((IByteOut *)p)->a;\n 2109: \tstruct _7zip *zip = (struct _7zip *)(a->format_data);\n 2110: \tstruct la_zstream *lastrm = &(zip->stream);\n 2111: \tstruct ppmd_stream *strm;\n 2112  \n 2113  \tif (lastrm->avail_out) {\n ....\n 2117  \t\treturn;\n 2118  \t}\n 2119: \tstrm = (struct ppmd_stream *)lastrm->real_stream;\n 2120  \tif (strm->buff_ptr < strm->buff_end) {\n 2121  \t\t*strm->buff_ptr++ = b;\n ....\n 2125  \n 2126  static int\n 2127: compression_init_encoder_ppmd(struct archive *a,\n 2128:     struct la_zstream *lastrm, unsigned maxOrder, uint32_t msize)\n 2129  {\n 2130: \tstruct ppmd_stream *strm;\n 2131  \tuint8_t *props;\n 2132  \tint r;\n ....\n 2160  \tprops[0] = maxOrder;\n 2161  \tarchive_le32enc(props+1, msize);\n 2162: \t__archive_ppmd7_functions.Ppmd7_Construct(&strm->ppmd7_context);\n 2163  \tr = __archive_ppmd7_functions.Ppmd7_Alloc(\n 2164  \t\t&strm->ppmd7_context, msize);\n ....\n 2172  \t}\n 2173  \t__archive_ppmd7_functions.Ppmd7_Init(&(strm->ppmd7_context), maxOrder);\n 2174: \tstrm->byteout.a = (struct archive_write *)a;\n 2175  \tstrm->byteout.Write = ppmd_write;\n 2176  \tstrm->range_enc.Stream = &(strm->byteout);\n ....\n 2188  \n 2189  static int\n 2190: compression_code_ppmd(struct archive *a,\n 2191:     struct la_zstream *lastrm, enum la_zaction action)\n 2192  {\n 2193: \tstruct ppmd_stream *strm;\n 2194  \n 2195  \t(void)a; /* UNUSED */\n 2196  \n 2197: \tstrm = (struct ppmd_stream *)lastrm->real_stream;\n 2198  \n 2199  \t/* Copy encoded data if there are remaining bytes from previous call. */\n ....\n 2231  \n 2232  static int\n 2233: compression_end_ppmd(struct archive *a, struct la_zstream *lastrm)\n 2234  {\n 2235: \tstruct ppmd_stream *strm;\n 2236  \n 2237  \t(void)a; /* UNUSED */\n 2238  \n 2239: \tstrm = (struct ppmd_stream *)lastrm->real_stream;\n 2240  \t__archive_ppmd7_functions.Ppmd7_Free(&strm->ppmd7_context);\n 2241  \tfree(strm->buff);\n ....\n 2250   */\n 2251  static int\n 2252: _7z_compression_init_encoder(struct archive_write *a, unsigned compression,\n 2253      int compression_level)\n 2254  {\n 2255: \tstruct _7zip *zip;\n 2256  \tint r;\n 2257  \n 2258: \tzip = (struct _7zip *)a->format_data;\n 2259  \tswitch (compression) {\n 2260  \tcase _7Z_DEFLATE:\n ....\n 2300  \n 2301  static int\n 2302: compression_code(struct archive *a, struct la_zstream *lastrm,\n 2303      enum la_zaction action)\n 2304  {\n ....\n 2309  \n 2310  static int\n 2311: compression_end(struct archive *a, struct la_zstream *lastrm)\n 2312  {\n 2313  \tif (lastrm->valid) {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter_zstd.c:\n   49  /* Don't compile this if we don't have zstd.h */\n   50  \n   51: struct private_data {\n   52  \tint\t\t compression_level;\n   53  #if HAVE_ZSTD_H && HAVE_LIBZSTD\n   ..\n   56  \tZSTD_outBuffer\t out;\n   57  #else\n   58: \tstruct archive_write_program_data *pdata;\n   59  #endif\n   60  };\n   ..\n   70  #define MINVER_MINCLEVEL 10306\n   71  \n   72: static int archive_compressor_zstd_options(struct archive_write_filter *,\n   73  \t\t    const char *, const char *);\n   74: static int archive_compressor_zstd_open(struct archive_write_filter *);\n   75: static int archive_compressor_zstd_write(struct archive_write_filter *,\n   76  \t\t    const void *, size_t);\n   77: static int archive_compressor_zstd_close(struct archive_write_filter *);\n   78: static int archive_compressor_zstd_free(struct archive_write_filter *);\n   79  #if HAVE_ZSTD_H && HAVE_LIBZSTD\n   80: static int drive_compressor(struct archive_write_filter *,\n   81: \t\t    struct private_data *, int, const void *, size_t);\n   82  #endif\n   83  \n   ..\n   87   */\n   88  int\n   89: archive_write_add_filter_zstd(struct archive *_a)\n   90  {\n   91: \tstruct archive_write *a = (struct archive_write *)_a;\n   92: \tstruct archive_write_filter *f = __archive_write_allocate_filter(_a);\n   93: \tstruct private_data *data;\n   94  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n   95  \t    ARCHIVE_STATE_NEW, \"archive_write_add_filter_zstd\");\n   ..\n  132  \n  133  static int\n  134: archive_compressor_zstd_free(struct archive_write_filter *f)\n  135  {\n  136: \tstruct private_data *data = (struct private_data *)f->data;\n  137  #if HAVE_ZSTD_H && HAVE_LIBZSTD\n  138  \tZSTD_freeCStream(data->cstream);\n  ...\n  175   */\n  176  static int\n  177: archive_compressor_zstd_options(struct archive_write_filter *f, const char *key,\n  178      const char *value)\n  179  {\n  180: \tstruct private_data *data = (struct private_data *)f->data;\n  181  \n  182  \tif (strcmp(key, \"compression-level\") == 0) {\n  ...\n  218   */\n  219  static int\n  220: archive_compressor_zstd_open(struct archive_write_filter *f)\n  221  {\n  222: \tstruct private_data *data = (struct private_data *)f->data;\n  223  \n  224  \tif (data->out.dst == NULL) {\n  ...\n  260   */\n  261  static int\n  262: archive_compressor_zstd_write(struct archive_write_filter *f, const void *buff,\n  263      size_t length)\n  264  {\n  265: \tstruct private_data *data = (struct private_data *)f->data;\n  266  \tint ret;\n  267  \n  ...\n  279   */\n  280  static int\n  281: archive_compressor_zstd_close(struct archive_write_filter *f)\n  282  {\n  283: \tstruct private_data *data = (struct private_data *)f->data;\n  284  \n  285  \t/* Finish zstd frame */\n  ...\n  295   */\n  296  static int\n  297: drive_compressor(struct archive_write_filter *f,\n  298:     struct private_data *data, int finishing, const void *src, size_t length)\n  299  {\n  300  \tZSTD_inBuffer in = (ZSTD_inBuffer) { src, length, 0 };\n  ...\n  339  \n  340  static int\n  341: archive_compressor_zstd_open(struct archive_write_filter *f)\n  342  {\n  343: \tstruct private_data *data = (struct private_data *)f->data;\n  344: \tstruct archive_string as;\n  345  \tint r;\n  346  \n  ...\n  350  \n  351  \tif (data->compression_level < CLEVEL_STD_MIN) {\n  352: \t\tstruct archive_string as2;\n  353  \t\tarchive_string_init(&as2);\n  354  \t\tarchive_string_sprintf(&as2, \" --fast=%d\", -data->compression_level);\n  ...\n  356  \t\tarchive_string_free(&as2);\n  357  \t} else {\n  358: \t\tstruct archive_string as2;\n  359  \t\tarchive_string_init(&as2);\n  360  \t\tarchive_string_sprintf(&as2, \" -%d\", data->compression_level);\n  ...\n  374  \n  375  static int\n  376: archive_compressor_zstd_write(struct archive_write_filter *f, const void *buff,\n  377      size_t length)\n  378  {\n  379: \tstruct private_data *data = (struct private_data *)f->data;\n  380  \n  381  \treturn __archive_write_program_write(f, data->pdata, buff, length);\n  ...\n  383  \n  384  static int\n  385: archive_compressor_zstd_close(struct archive_write_filter *f)\n  386  {\n  387: \tstruct private_data *data = (struct private_data *)f->data;\n  388  \n  389  \treturn __archive_write_program_close(f, data->pdata);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_disk_acl_linux.c:\n   51  #include \"archive_write_disk_private.h\"\n   52  \n   53: typedef struct {\n   54  \tconst int a_perm;\t/* Libarchive permission or flag */\n   55  \tconst int p_perm;\t/* Platform permission or flag */\n   ..\n  105  #if ARCHIVE_ACL_LIBACL\n  106  /*\n  107:  * Translate POSIX.1e ACLs into libarchive internal structure\n  108   */\n  109  static int\n  110: translate_acl(struct archive_read_disk *a,\n  111:     struct archive_entry *entry, acl_t acl, int default_entry_acl_type)\n  112  {\n  113  \tacl_tag_t\t acl_tag;\n  ...\n  216   */\n  217  static int\n  218: translate_richacl(struct archive_read_disk *a, struct archive_entry *entry,\n  219:     struct richacl *richacl)\n  220  {\n  221  \tint ae_id, ae_tag, ae_perm;\n  ...\n  223  \tconst char *ae_name;\n  224  \n  225: \tstruct richace *richace;\n  226  \n  227  \trichacl_for_each_entry(richace, richacl) {\n  ...\n  308  \n  309  static void\n  310: _richacl_mode_to_masks(struct richacl *richacl, __LA_MODE_T mode)\n  311  {\n  312  \trichacl->a_owner_mask = _richacl_mode_to_mask((mode & 0700) >> 6);\n  ...\n  318  #if ARCHIVE_ACL_LIBRICHACL\n  319  static int\n  320: set_richacl(struct archive *a, int fd, const char *name,\n  321:     struct archive_acl *abstract_acl, __LA_MODE_T mode,\n  322      int ae_requested_type, const char *tname)\n  323  {\n  ...\n  330  \tint\t\t ret;\n  331  \tint\t\t e = 0;\n  332: \tstruct richacl  *richacl = NULL;\n  333: \tstruct richace  *richace;\n  334  \n  335  \tret = ARCHIVE_OK;\n  ...\n  460  #if ARCHIVE_ACL_LIBACL\n  461  static int\n  462: set_acl(struct archive *a, int fd, const char *name,\n  463:     struct archive_acl *abstract_acl, __LA_MODE_T mode,\n  464      int ae_requested_type, const char *tname)\n  465  {\n  ...\n  610  \n  611  int\n  612: archive_read_disk_entry_setup_acls(struct archive_read_disk *a,\n  613:     struct archive_entry *entry, int *fd)\n  614  {\n  615  \tconst char\t*accpath;\n  ...\n  619  #endif\n  620  #if ARCHIVE_ACL_LIBRICHACL\n  621: \tstruct richacl *richacl;\n  622  \tmode_t\t\tmode;\n  623  #endif\n  ...\n  721  \n  722  int\n  723: archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n  724:     struct archive_acl *abstract_acl, __LA_MODE_T mode)\n  725  {\n  726  \tint\t\tret = ARCHIVE_OK;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_disk_posix.c:\n  135   */\n  136  \n  137: struct restore_time {\n  138  \tconst char\t\t*name;\n  139  \ttime_t\t\t\t mtime;\n  ...\n  145  };\n  146  \n  147: struct tree_entry {\n  148  \tint\t\t\t depth;\n  149: \tstruct tree_entry\t*next;\n  150: \tstruct tree_entry\t*parent;\n  151: \tstruct archive_string\t name;\n  152  \tsize_t\t\t\t dirname_length;\n  153  \tint64_t\t\t\t dev;\n  ...\n  158  \tint\t\t\t symlink_parent_fd;\n  159  \t/* How to restore time of a directory. */\n  160: \tstruct restore_time\t restore_time;\n  161  };\n  162  \n  163: struct filesystem {\n  164  \tint64_t\t\tdev;\n  165  \tint\t\tsynthetic;\n  ...\n  195   * Local data for this package.\n  196   */\n  197: struct tree {\n  198: \tstruct tree_entry\t*stack;\n  199: \tstruct tree_entry\t*current;\n  200  \tDIR\t\t\t*d;\n  201  #define\tINVALID_DIR_HANDLE NULL\n  202: \tstruct dirent\t\t*de;\n  203  #if defined(USE_READDIR_R)\n  204: \tstruct dirent\t\t*dirent;\n  205  \tsize_t\t\t\t dirent_allocated;\n  206  #endif\n  ...\n  211  \n  212  \t/* Dynamically-sized buffer for holding path */\n  213: \tstruct archive_string\t path;\n  214  \n  215  \t/* Last path element */\n  ...\n  224  \tint\t\t\t working_dir_fd;\n  225  \n  226: \tstruct stat\t\t lst;\n  227: \tstruct stat\t\t st;\n  228  \tint\t\t\t descend;\n  229  \tint\t\t\t nlink;\n  230  \t/* How to restore time of a file. */\n  231: \tstruct restore_time\t restore_time;\n  232  \n  233: \tstruct entry_sparse {\n  234  \t\tint64_t\t\t length;\n  235  \t\tint64_t\t\t offset;\n  ...\n  240  \tchar\t\t\t initial_symlink_mode;\n  241  \tchar\t\t\t symlink_mode;\n  242: \tstruct filesystem\t*current_filesystem;\n  243: \tstruct filesystem\t*filesystem_table;\n  244  \tint\t\t\t initial_filesystem_id;\n  245  \tint\t\t\t current_filesystem_id;\n  ...\n  264  \n  265  static int\n  266: tree_dir_next_posix(struct tree *t);\n  267  \n  268  #ifdef HAVE_DIRENT_D_NAMLEN\n  ...\n  274  \n  275  /* Initiate/terminate a tree traversal. */\n  276: static struct tree *tree_open(const char *, int, int);\n  277: static struct tree *tree_reopen(struct tree *, const char *, int);\n  278: static void tree_close(struct tree *);\n  279: static void tree_free(struct tree *);\n  280: static void tree_push(struct tree *, const char *, int, int64_t, int64_t,\n  281: \t\tstruct restore_time *);\n  282: static int tree_enter_initial_dir(struct tree *);\n  283: static int tree_enter_working_dir(struct tree *);\n  284: static int tree_current_dir_fd(struct tree *);\n  285  \n  286  /*\n  ...\n  308  #define\tTREE_ERROR_FATAL\t-2\n  309  \n  310: static int tree_next(struct tree *);\n  311  \n  312  /*\n  ...\n  328   *\n  329   */\n  330: static const char *tree_current_path(struct tree *);\n  331: static const char *tree_current_access_path(struct tree *);\n  332  \n  333  /*\n  ...\n  337   * than make a redundant stat() or lstat() call of your own.\n  338   */\n  339: static const struct stat *tree_current_stat(struct tree *);\n  340: static const struct stat *tree_current_lstat(struct tree *);\n  341: static int\ttree_current_is_symblic_link_target(struct tree *);\n  342  \n  343  /* The following functions use tricks to avoid a certain number of\n  344   * stat()/lstat() calls. */\n  345  /* \"is_physical_dir\" is equivalent to S_ISDIR(tree_current_lstat()->st_mode) */\n  346: static int tree_current_is_physical_dir(struct tree *);\n  347  /* \"is_dir\" is equivalent to S_ISDIR(tree_current_stat()->st_mode) */\n  348: static int tree_current_is_dir(struct tree *);\n  349: static int update_current_filesystem(struct archive_read_disk *a,\n  350  \t\t    int64_t dev);\n  351: static int setup_current_filesystem(struct archive_read_disk *);\n  352: static int tree_target_is_same_as_parent(struct tree *, const struct stat *);\n  353  \n  354: static int\t_archive_read_disk_open(struct archive *, const char *);\n  355: static int\t_archive_read_free(struct archive *);\n  356: static int\t_archive_read_close(struct archive *);\n  357: static int\t_archive_read_data_block(struct archive *,\n  358  \t\t    const void **, size_t *, int64_t *);\n  359: static int\t_archive_read_next_header(struct archive *,\n  360: \t\t    struct archive_entry **);\n  361: static int\t_archive_read_next_header2(struct archive *,\n  362: \t\t    struct archive_entry *);\n  363  static const char *trivial_lookup_gname(void *, int64_t gid);\n  364  static const char *trivial_lookup_uname(void *, int64_t uid);\n  365: static int\tsetup_sparse(struct archive_read_disk *, struct archive_entry *);\n  366: static int\tclose_and_restore_time(int fd, struct tree *,\n  367: \t\t    struct restore_time *);\n  368: static int\topen_on_current_dir(struct tree *, const char *, int);\n  369  static int\ttree_dup(int);\n  370  \n  371  \n  372: static struct archive_vtable *\n  373  archive_read_disk_vtable(void)\n  374  {\n  375: \tstatic struct archive_vtable av;\n  376  \tstatic int inited = 0;\n  377  \n  ...\n  388  \n  389  const char *\n  390: archive_read_disk_gname(struct archive *_a, la_int64_t gid)\n  391  {\n  392: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  393  \tif (ARCHIVE_OK != __archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n  394  \t\tARCHIVE_STATE_ANY, \"archive_read_disk_gname\"))\n  ...\n  400  \n  401  const char *\n  402: archive_read_disk_uname(struct archive *_a, la_int64_t uid)\n  403  {\n  404: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  405  \tif (ARCHIVE_OK != __archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n  406  \t\tARCHIVE_STATE_ANY, \"archive_read_disk_uname\"))\n  ...\n  412  \n  413  int\n  414: archive_read_disk_set_gname_lookup(struct archive *_a,\n  415      void *private_data,\n  416      const char * (*lookup_gname)(void *private, la_int64_t gid),\n  417      void (*cleanup_gname)(void *private))\n  418  {\n  419: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  420  \tarchive_check_magic(&a->archive, ARCHIVE_READ_DISK_MAGIC,\n  421  \t    ARCHIVE_STATE_ANY, \"archive_read_disk_set_gname_lookup\");\n  ...\n  431  \n  432  int\n  433: archive_read_disk_set_uname_lookup(struct archive *_a,\n  434      void *private_data,\n  435      const char * (*lookup_uname)(void *private, la_int64_t uid),\n  436      void (*cleanup_uname)(void *private))\n  437  {\n  438: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  439  \tarchive_check_magic(&a->archive, ARCHIVE_READ_DISK_MAGIC,\n  440  \t    ARCHIVE_STATE_ANY, \"archive_read_disk_set_uname_lookup\");\n  ...\n  452   * Create a new archive_read_disk object and initialize it with global state.\n  453   */\n  454: struct archive *\n  455  archive_read_disk_new(void)\n  456  {\n  457: \tstruct archive_read_disk *a;\n  458  \n  459: \ta = (struct archive_read_disk *)calloc(1, sizeof(*a));\n  460  \tif (a == NULL)\n  461  \t\treturn (NULL);\n  ...\n  474  \n  475  static int\n  476: _archive_read_free(struct archive *_a)\n  477  {\n  478: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  479  \tint r;\n  480  \n  ...\n  503  \n  504  static int\n  505: _archive_read_close(struct archive *_a)\n  506  {\n  507: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  508  \n  509  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n  ...\n  519  \n  520  static void\n  521: setup_symlink_mode(struct archive_read_disk *a, char symlink_mode,\n  522      int follow_symlinks)\n  523  {\n  ...\n  531  \n  532  int\n  533: archive_read_disk_set_symlink_logical(struct archive *_a)\n  534  {\n  535: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  536  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n  537  \t    ARCHIVE_STATE_ANY, \"archive_read_disk_set_symlink_logical\");\n  ...\n  541  \n  542  int\n  543: archive_read_disk_set_symlink_physical(struct archive *_a)\n  544  {\n  545: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  546  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n  547  \t    ARCHIVE_STATE_ANY, \"archive_read_disk_set_symlink_physical\");\n  ...\n  551  \n  552  int\n  553: archive_read_disk_set_symlink_hybrid(struct archive *_a)\n  554  {\n  555: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  556  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n  557  \t    ARCHIVE_STATE_ANY, \"archive_read_disk_set_symlink_hybrid\");\n  ...\n  561  \n  562  int\n  563: archive_read_disk_set_atime_restored(struct archive *_a)\n  564  {\n  565: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  566  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n  567  \t    ARCHIVE_STATE_ANY, \"archive_read_disk_restore_atime\");\n  ...\n  581  \n  582  int\n  583: archive_read_disk_set_behavior(struct archive *_a, int flags)\n  584  {\n  585: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  586  \tint r = ARCHIVE_OK;\n  587  \n  ...\n  626   */\n  627  static int\n  628: setup_suitable_read_buffer(struct archive_read_disk *a)\n  629  {\n  630: \tstruct tree *t = a->tree;\n  631: \tstruct filesystem *cf = t->current_filesystem;\n  632  \tsize_t asize;\n  633  \tsize_t s;\n  ...\n  688  \n  689  static int\n  690: _archive_read_data_block(struct archive *_a, const void **buff,\n  691      size_t *size, int64_t *offset)\n  692  {\n  693: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n  694: \tstruct tree *t = a->tree;\n  695  \tint r;\n  696  \tssize_t bytes;\n  ...\n  848  \n  849  static int\n  850: next_entry(struct archive_read_disk *a, struct tree *t,\n  851:     struct archive_entry *entry)\n  852  {\n  853: \tconst struct stat *st; /* info to use for this entry */\n  854: \tconst struct stat *lst;/* lstat() information */\n  855  \tconst char *name;\n  856  \tint delayed, delayed_errno, descend, r;\n  857: \tstruct archive_string delayed_str;\n  858  \n  859  \tdelayed = ARCHIVE_OK;\n  ...\n 1113  \n 1114  static int\n 1115: _archive_read_next_header(struct archive *_a, struct archive_entry **entryp)\n 1116  {\n 1117  \tint ret;\n 1118: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1119  \t*entryp = NULL;\n 1120  \tret = _archive_read_next_header2(_a, a->entry);\n ....\n 1124  \n 1125  static int\n 1126: _archive_read_next_header2(struct archive *_a, struct archive_entry *entry)\n 1127  {\n 1128: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1129: \tstruct tree *t;\n 1130  \tint r;\n 1131  \n ....\n 1198  \n 1199  static int\n 1200: setup_sparse(struct archive_read_disk *a, struct archive_entry *entry)\n 1201  {\n 1202: \tstruct tree *t = a->tree;\n 1203  \tint64_t length, offset;\n 1204  \tint i;\n ....\n 1236  \n 1237  int\n 1238: archive_read_disk_set_matching(struct archive *_a, struct archive *_ma,\n 1239:     void (*_excluded_func)(struct archive *, void *, struct archive_entry *),\n 1240      void *_client_data)\n 1241  {\n 1242: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1243  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n 1244  \t    ARCHIVE_STATE_ANY, \"archive_read_disk_set_matching\");\n ....\n 1250  \n 1251  int\n 1252: archive_read_disk_set_metadata_filter_callback(struct archive *_a,\n 1253:     int (*_metadata_filter_func)(struct archive *, void *,\n 1254:     struct archive_entry *), void *_client_data)\n 1255  {\n 1256: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1257  \n 1258  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC, ARCHIVE_STATE_ANY,\n ....\n 1265  \n 1266  int\n 1267: archive_read_disk_can_descend(struct archive *_a)\n 1268  {\n 1269: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1270: \tstruct tree *t = a->tree;\n 1271  \n 1272  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n ....\n 1282   */\n 1283  int\n 1284: archive_read_disk_descend(struct archive *_a)\n 1285  {\n 1286: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1287: \tstruct tree *t = a->tree;\n 1288  \n 1289  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n ....\n 1321  \n 1322  int\n 1323: archive_read_disk_open(struct archive *_a, const char *pathname)\n 1324  {\n 1325: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1326  \n 1327  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,\n ....\n 1334  \n 1335  int\n 1336: archive_read_disk_open_w(struct archive *_a, const wchar_t *pathname)\n 1337  {\n 1338: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1339: \tstruct archive_string path;\n 1340  \tint ret;\n 1341  \n ....\n 1365  \n 1366  static int\n 1367: _archive_read_disk_open(struct archive *_a, const char *pathname)\n 1368  {\n 1369: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1370  \n 1371  \tif (a->tree != NULL)\n ....\n 1391   */\n 1392  int\n 1393: archive_read_disk_current_filesystem(struct archive *_a)\n 1394  {\n 1395: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1396  \n 1397  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC, ARCHIVE_STATE_DATA,\n ....\n 1402  \n 1403  static int\n 1404: update_current_filesystem(struct archive_read_disk *a, int64_t dev)\n 1405  {\n 1406: \tstruct tree *t = a->tree;\n 1407  \tint i, fid;\n 1408  \n ....\n 1436  \t\t\treturn (ARCHIVE_FATAL);\n 1437  \t\t}\n 1438: \t\tt->filesystem_table = (struct filesystem *)p;\n 1439  \t\tt->allocated_filesystem = s;\n 1440  \t}\n ....\n 1455   */\n 1456  int\n 1457: archive_read_disk_current_filesystem_is_synthetic(struct archive *_a)\n 1458  {\n 1459: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1460  \n 1461  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC, ARCHIVE_STATE_DATA,\n ....\n 1470   */\n 1471  int\n 1472: archive_read_disk_current_filesystem_is_remote(struct archive *_a)\n 1473  {\n 1474: \tstruct archive_read_disk *a = (struct archive_read_disk *)_a;\n 1475  \n 1476  \tarchive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC, ARCHIVE_STATE_DATA,\n ....\n 1483  \tdefined(_PC_REC_MIN_XFER_SIZE) && defined(_PC_REC_XFER_ALIGN)\n 1484  static int\n 1485: get_xfer_size(struct tree *t, int fd, const char *path)\n 1486  {\n 1487  \tt->current_filesystem->xfer_align = -1;\n ....\n 1514  #else\n 1515  static int\n 1516: get_xfer_size(struct tree *t, int fd, const char *path)\n 1517  {\n 1518  \t(void)t; /* UNUSED */\n ....\n 1525  #if defined(HAVE_STATVFS)\n 1526  static inline __LA_UNUSED void\n 1527: set_statvfs_transfer_size(struct filesystem *fs, const struct statvfs *sfs)\n 1528  {\n 1529  \tfs->xfer_align = sfs->f_frsize > 0 ? (long)sfs->f_frsize : -1;\n ....\n 1541  #if defined(HAVE_STRUCT_STATFS)\n 1542  static inline __LA_UNUSED void\n 1543: set_statfs_transfer_size(struct filesystem *fs, const struct statfs *sfs)\n 1544  {\n 1545  \tfs->xfer_align = sfs->f_bsize > 0 ? (long)sfs->f_bsize : -1;\n ....\n 1562   */\n 1563  static int\n 1564: setup_current_filesystem(struct archive_read_disk *a)\n 1565  {\n 1566: \tstruct tree *t = a->tree;\n 1567: \tstruct statfs sfs;\n 1568  #if defined(HAVE_GETVFSBYNAME) && defined(VFCF_SYNTHETIC)\n 1569  /* TODO: configure should set GETVFSBYNAME_ARG_TYPE to make\n ....\n 1577   */\n 1578  #  if defined(HAVE_STRUCT_XVFSCONF)\n 1579: \tstruct xvfsconf vfc;\n 1580  #  else\n 1581: \tstruct vfsconf vfc;\n 1582  #  endif\n 1583  #endif\n ....\n 1658  #else\n 1659  # if defined(_PC_NAME_MAX)\n 1660: \t/* Mac OS X does not have f_namemax in struct statfs. */\n 1661  \tif (tree_current_is_symblic_link_target(t)) {\n 1662  \t\tif (tree_enter_working_dir(t) != 0) {\n ....\n 1685   */\n 1686  static int\n 1687: setup_current_filesystem(struct archive_read_disk *a)\n 1688  {\n 1689: \tstruct tree *t = a->tree;\n 1690: \tstruct statvfs svfs;\n 1691  \tint r, xr = 0;\n 1692  \n ....\n 1754   */\n 1755  static int\n 1756: setup_current_filesystem(struct archive_read_disk *a)\n 1757  {\n 1758: \tstruct tree *t = a->tree;\n 1759: \tstruct statfs sfs;\n 1760  #if defined(HAVE_STATVFS)\n 1761: \tstruct statvfs svfs;\n 1762  #endif\n 1763  \tint r, vr = 0, xr = 0;\n ....\n 1877   */\n 1878  static int\n 1879: setup_current_filesystem(struct archive_read_disk *a)\n 1880  {\n 1881: \tstruct tree *t = a->tree;\n 1882: \tstruct statvfs svfs;\n 1883  \tint r, xr = 0;\n 1884  \n ....\n 1958   */\n 1959  static int\n 1960: setup_current_filesystem(struct archive_read_disk *a)\n 1961  {\n 1962: \tstruct tree *t = a->tree;\n 1963  #if defined(_PC_NAME_MAX) && defined(USE_READDIR_R)\n 1964  \tlong nm;\n ....\n 2008  \n 2009  static int\n 2010: close_and_restore_time(int fd, struct tree *t, struct restore_time *rt)\n 2011  {\n 2012  #ifndef HAVE_UTIMES\n ....\n 2016  #else\n 2017  #if defined(HAVE_FUTIMENS) && !defined(__CYGWIN__)\n 2018: \tstruct timespec timespecs[2];\n 2019  #endif\n 2020: \tstruct timeval times[2];\n 2021  \n 2022  \tif ((t->flags & needsRestoreTimes) == 0 || rt->noatime) {\n ....\n 2064  \n 2065  static int\n 2066: open_on_current_dir(struct tree *t, const char *path, int flags)\n 2067  {\n 2068  #ifdef HAVE_OPENAT\n ....\n 2101   */\n 2102  static void\n 2103: tree_push(struct tree *t, const char *path, int filesystem_id,\n 2104:     int64_t dev, int64_t ino, struct restore_time *rt)\n 2105  {\n 2106: \tstruct tree_entry *te;\n 2107  \n 2108  \tte = calloc(1, sizeof(*te));\n ....\n 2135   */\n 2136  static void\n 2137: tree_append(struct tree *t, const char *name, size_t name_length)\n 2138  {\n 2139  \tsize_t size_needed;\n ....\n 2159   * Open a directory tree for traversal.\n 2160   */\n 2161: static struct tree *\n 2162  tree_open(const char *path, int symlink_mode, int restore_time)\n 2163  {\n 2164: \tstruct tree *t;\n 2165  \n 2166  \tif ((t = calloc(1, sizeof(*t))) == NULL)\n ....\n 2172  }\n 2173  \n 2174: static struct tree *\n 2175: tree_reopen(struct tree *t, const char *path, int restore_time)\n 2176  {\n 2177  #if defined(O_PATH)\n ....\n 2223  \n 2224  static int\n 2225: tree_descent(struct tree *t)\n 2226  {\n 2227  \tint flag, new_fd, r = 0;\n ....\n 2258   */\n 2259  static int\n 2260: tree_ascend(struct tree *t)\n 2261  {\n 2262: \tstruct tree_entry *te;\n 2263  \tint new_fd, r = 0, prev_dir_fd;\n 2264  \n ....\n 2294   */\n 2295  static int\n 2296: tree_enter_initial_dir(struct tree *t)\n 2297  {\n 2298  \tint r = 0;\n ....\n 2312   */\n 2313  static int\n 2314: tree_enter_working_dir(struct tree *t)\n 2315  {\n 2316  \tint r = 0;\n ....\n 2332  \n 2333  static int\n 2334: tree_current_dir_fd(struct tree *t)\n 2335  {\n 2336  \treturn (t->working_dir_fd);\n ....\n 2341   */\n 2342  static void\n 2343: tree_pop(struct tree *t)\n 2344  {\n 2345: \tstruct tree_entry *te;\n 2346  \n 2347  \tt->path.s[t->dirname_length] = '\\0';\n ....\n 2363   */\n 2364  static int\n 2365: tree_next(struct tree *t)\n 2366  {\n 2367  \tint r;\n ....\n 2421  \n 2422  static int\n 2423: tree_dir_next_posix(struct tree *t)\n 2424  {\n 2425  \tint r;\n ....\n 2450  \t\t}\n 2451  #if defined(USE_READDIR_R)\n 2452: \t\tdirent_size = offsetof(struct dirent, d_name) +\n 2453  \t\t  t->filesystem_table[t->current->filesystem_id].name_max + 1;\n 2454  \t\tif (t->dirent == NULL || t->dirent_allocated < dirent_size) {\n ....\n 2514   * Get the stat() data for the entry just returned from tree_next().\n 2515   */\n 2516: static const struct stat *\n 2517: tree_current_stat(struct tree *t)\n 2518  {\n 2519  \tif (!(t->flags & hasStat)) {\n ....\n 2535   * Get the lstat() data for the entry just returned from tree_next().\n 2536   */\n 2537: static const struct stat *\n 2538: tree_current_lstat(struct tree *t)\n 2539  {\n 2540  \tif (!(t->flags & hasLstat)) {\n ....\n 2558   */\n 2559  static int\n 2560: tree_current_is_dir(struct tree *t)\n 2561  {\n 2562: \tconst struct stat *st;\n 2563  \t/*\n 2564  \t * If we already have lstat() info, then try some\n ....\n 2596   */\n 2597  static int\n 2598: tree_current_is_physical_dir(struct tree *t)\n 2599  {\n 2600: \tconst struct stat *st;\n 2601  \n 2602  \t/*\n ....\n 2631   */\n 2632  static int\n 2633: tree_target_is_same_as_parent(struct tree *t, const struct stat *st)\n 2634  {\n 2635: \tstruct tree_entry *te;\n 2636  \n 2637  \tfor (te = t->current->parent; te != NULL; te = te->parent) {\n ....\n 2648   */\n 2649  static int\n 2650: tree_current_is_symblic_link_target(struct tree *t)\n 2651  {\n 2652: \tstatic const struct stat *lst, *st;\n 2653  \n 2654  \tlst = tree_current_lstat(t);\n ....\n 2663   */\n 2664  static const char *\n 2665: tree_current_access_path(struct tree *t)\n 2666  {\n 2667  \treturn (t->basename);\n ....\n 2672   */\n 2673  static const char *\n 2674: tree_current_path(struct tree *t)\n 2675  {\n 2676  \treturn (t->path.s);\n ....\n 2681   */\n 2682  static void\n 2683: tree_close(struct tree *t)\n 2684  {\n 2685  \n ....\n 2715   */\n 2716  static void\n 2717: tree_free(struct tree *t)\n 2718  {\n 2719  \tint i;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_add_passphrase.c:\n   33  \n   34  static void\n   35: add_passphrase_to_tail(struct archive_read *a,\n   36:     struct archive_read_passphrase *p)\n   37  {\n   38  \t*a->passphrases.last = p;\n   ..\n   41  }\n   42  \n   43: static struct archive_read_passphrase *\n   44: remove_passphrases_from_head(struct archive_read *a)\n   45  {\n   46: \tstruct archive_read_passphrase *p;\n   47  \n   48  \tp = a->passphrases.first;\n   ..\n   53  \n   54  static void\n   55: insert_passphrase_to_head(struct archive_read *a,\n   56:     struct archive_read_passphrase *p)\n   57  {\n   58  \tp->next = a->passphrases.first;\n   ..\n   64  }\n   65  \n   66: static struct archive_read_passphrase *\n   67: new_read_passphrase(struct archive_read *a, const char *passphrase)\n   68  {\n   69: \tstruct archive_read_passphrase *p;\n   70  \n   71  \tp = malloc(sizeof(*p));\n   ..\n   86  \n   87  int\n   88: archive_read_add_passphrase(struct archive *_a, const char *passphrase)\n   89  {\n   90: \tstruct archive_read *a = (struct archive_read *)_a;\n   91: \tstruct archive_read_passphrase *p;\n   92  \n   93  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,\n   ..\n  109  \n  110  int\n  111: archive_read_set_passphrase_callback(struct archive *_a, void *client_data,\n  112      archive_passphrase_callback *cb)\n  113  {\n  114: \tstruct archive_read *a = (struct archive_read *)_a;\n  115  \n  116  \tarchive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,\n  ...\n  127   */\n  128  void\n  129: __archive_read_reset_passphrase(struct archive_read *a)\n  130  {\n  131  \n  ...\n  137   */\n  138  const char *\n  139: __archive_read_next_passphrase(struct archive_read *a)\n  140  {\n  141: \tstruct archive_read_passphrase *p;\n  142  \tconst char *passphrase;\n  143  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_rar.c:\n  139   * Considering L1,L2 cache miss and a calling of write system-call,\n  140   * the best size of the output buffer(uncompressed buffer) is 128K.\n  141:  * If the structure of extracting process is changed, this value\n  142   * might be researched again.\n  143   */\n  ...\n  156  \n  157  /* Fields common to all headers */\n  158: struct rar_header\n  159  {\n  160    char crc[2];\n  ...\n  165  \n  166  /* Fields common to all file headers */\n  167: struct rar_file_header\n  168  {\n  169    char pack_size[4];\n  ...\n  178  };\n  179  \n  180: struct huffman_tree_node\n  181  {\n  182    int branches[2];\n  183  };\n  184  \n  185: struct huffman_table_entry\n  186  {\n  187    unsigned int length;\n  ...\n  189  };\n  190  \n  191: struct huffman_code\n  192  {\n  193:   struct huffman_tree_node *tree;\n  194    int numentries;\n  195    int numallocatedentries;\n  ...\n  197    int maxlength;\n  198    int tablesize;\n  199:   struct huffman_table_entry *table;\n  200  };\n  201  \n  202: struct lzss\n  203  {\n  204    unsigned char *window;\n  ...\n  207  };\n  208  \n  209: struct data_block_offsets\n  210  {\n  211    int64_t header_size;\n  ...\n  214  };\n  215  \n  216: struct rar\n  217  {\n  218    /* Entries from main RAR header */\n  ...\n  262    int found_first_header;\n  263    char has_endarc_header;\n  264:   struct data_block_offsets *dbo;\n  265    unsigned int cursor;\n  266    unsigned int nodes;\n  ...\n  268  \n  269    /* LZSS members */\n  270:   struct huffman_code maincode;\n  271:   struct huffman_code offsetcode;\n  272:   struct huffman_code lowoffsetcode;\n  273:   struct huffman_code lengthcode;\n  274    unsigned char lengthtable[HUFFMAN_TABLE_SIZE];\n  275:   struct lzss lzss;\n  276    char output_last_match;\n  277    unsigned int lastlength;\n  ...\n  296     */\n  297    int init_default_conversion;\n  298:   struct archive_string_conv *sconv_default;\n  299:   struct archive_string_conv *opt_sconv;\n  300:   struct archive_string_conv *sconv_utf8;\n  301:   struct archive_string_conv *sconv_utf16be;\n  302  \n  303    /*\n  304     * Bit stream reader.\n  305     */\n  306:   struct rar_br {\n  307  #define CACHE_TYPE\tuint64_t\n  308  #define CACHE_BITS\t(8 * sizeof(CACHE_TYPE))\n  ...\n  321  };\n  322  \n  323: static int archive_read_support_format_rar_capabilities(struct archive_read *);\n  324: static int archive_read_format_rar_has_encrypted_entries(struct archive_read *);\n  325: static int archive_read_format_rar_bid(struct archive_read *, int);\n  326: static int archive_read_format_rar_options(struct archive_read *,\n  327      const char *, const char *);\n  328: static int archive_read_format_rar_read_header(struct archive_read *,\n  329:     struct archive_entry *);\n  330: static int archive_read_format_rar_read_data(struct archive_read *,\n  331      const void **, size_t *, int64_t *);\n  332: static int archive_read_format_rar_read_data_skip(struct archive_read *a);\n  333: static int64_t archive_read_format_rar_seek_data(struct archive_read *, int64_t,\n  334      int);\n  335: static int archive_read_format_rar_cleanup(struct archive_read *);\n  336  \n  337  /* Support functions */\n  338: static int read_header(struct archive_read *, struct archive_entry *, char);\n  339  static time_t get_time(int);\n  340: static int read_exttime(const char *, struct rar *, const char *);\n  341: static int read_symlink_stored(struct archive_read *, struct archive_entry *,\n  342:                                struct archive_string_conv *);\n  343: static int read_data_stored(struct archive_read *, const void **, size_t *,\n  344                              int64_t *);\n  345: static int read_data_compressed(struct archive_read *, const void **, size_t *,\n  346                            int64_t *, size_t);\n  347: static int rar_br_preparation(struct archive_read *, struct rar_br *);\n  348: static int parse_codes(struct archive_read *);\n  349: static void free_codes(struct archive_read *);\n  350: static int read_next_symbol(struct archive_read *, struct huffman_code *);\n  351: static int create_code(struct archive_read *, struct huffman_code *,\n  352                          unsigned char *, int, char);\n  353: static int add_value(struct archive_read *, struct huffman_code *, int, int,\n  354                       int);\n  355: static int new_node(struct huffman_code *);\n  356: static int make_table(struct archive_read *, struct huffman_code *);\n  357: static int make_table_recurse(struct archive_read *, struct huffman_code *, int,\n  358:                               struct huffman_table_entry *, int, int);\n  359: static int64_t expand(struct archive_read *, int64_t);\n  360: static int copy_from_lzss_window(struct archive_read *, const void **,\n  361                                     int64_t, int);\n  362: static const void *rar_read_ahead(struct archive_read *, size_t, ssize_t *);\n  363  \n  364  /*\n  ...\n  404   */\n  405  static int\n  406: rar_br_fillup(struct archive_read *a, struct rar_br *br)\n  407  {\n  408:   struct rar *rar = (struct rar *)(a->format->data);\n  409    int n = CACHE_BITS - br->cache_avail;\n  410  \n  ...\n  499  \n  500  static int\n  501: rar_br_preparation(struct archive_read *a, struct rar_br *br)\n  502  {\n  503:   struct rar *rar = (struct rar *)(a->format->data);\n  504  \n  505    if (rar->bytes_remaining > 0) {\n  ...\n  531  /* LZSS functions */\n  532  static inline int64_t\n  533: lzss_position(struct lzss *lzss)\n  534  {\n  535    return lzss->position;\n  ...\n  537  \n  538  static inline int\n  539: lzss_mask(struct lzss *lzss)\n  540  {\n  541    return lzss->mask;\n  ...\n  543  \n  544  static inline int\n  545: lzss_size(struct lzss *lzss)\n  546  {\n  547    return lzss->mask + 1;\n  ...\n  549  \n  550  static inline int\n  551: lzss_offset_for_position(struct lzss *lzss, int64_t pos)\n  552  {\n  553    return (int)(pos & lzss->mask);\n  ...\n  555  \n  556  static inline unsigned char *\n  557: lzss_pointer_for_position(struct lzss *lzss, int64_t pos)\n  558  {\n  559    return &lzss->window[lzss_offset_for_position(lzss, pos)];\n  ...\n  561  \n  562  static inline int\n  563: lzss_current_offset(struct lzss *lzss)\n  564  {\n  565    return lzss_offset_for_position(lzss, lzss->position);\n  ...\n  567  \n  568  static inline uint8_t *\n  569: lzss_current_pointer(struct lzss *lzss)\n  570  {\n  571    return lzss_pointer_for_position(lzss, lzss->position);\n  ...\n  573  \n  574  static inline void\n  575: lzss_emit_literal(struct rar *rar, uint8_t literal)\n  576  {\n  577    *lzss_current_pointer(&rar->lzss) = literal;\n  ...\n  580  \n  581  static inline void\n  582: lzss_emit_match(struct rar *rar, int offset, int length)\n  583  {\n  584    int dstoffs = lzss_current_offset(&rar->lzss);\n  ...\n  615  ppmd_read(void *p)\n  616  {\n  617:   struct archive_read *a = ((IByteIn*)p)->a;\n  618:   struct rar *rar = (struct rar *)(a->format->data);\n  619:   struct rar_br *br = &(rar->br);\n  620    Byte b;\n  621    if (!rar_br_read_ahead(a, br, 8))\n  ...\n  632  \n  633  int\n  634: archive_read_support_format_rar(struct archive *_a)\n  635  {\n  636:   struct archive_read *a = (struct archive_read *)_a;\n  637:   struct rar *rar;\n  638    int r;\n  639  \n  ...\n  641                        \"archive_read_support_format_rar\");\n  642  \n  643:   rar = (struct rar *)calloc(sizeof(*rar), 1);\n  644    if (rar == NULL)\n  645    {\n  ...\n  673  \n  674  static int\n  675: archive_read_support_format_rar_capabilities(struct archive_read * a)\n  676  {\n  677  \t(void)a; /* UNUSED */\n  ...\n  681  \n  682  static int\n  683: archive_read_format_rar_has_encrypted_entries(struct archive_read *_a)\n  684  {\n  685  \tif (_a && _a->format) {\n  686: \t\tstruct rar * rar = (struct rar *)_a->format->data;\n  687  \t\tif (rar) {\n  688  \t\t\treturn rar->has_encrypted_entries;\n  ...\n  694  \n  695  static int\n  696: archive_read_format_rar_bid(struct archive_read *a, int best_bid)\n  697  {\n  698    const char *p;\n  ...\n  735  \n  736  static int\n  737: skip_sfx(struct archive_read *a)\n  738  {\n  739    const void *h;\n  ...\n  781  \n  782  static int\n  783: archive_read_format_rar_options(struct archive_read *a,\n  784      const char *key, const char *val)\n  785  {\n  786:   struct rar *rar;\n  787    int ret = ARCHIVE_FAILED;\n  788  \n  789:   rar = (struct rar *)(a->format->data);\n  790    if (strcmp(key, \"hdrcharset\")  == 0) {\n  791      if (val == NULL || val[0] == 0)\n  ...\n  811  \n  812  static int\n  813: archive_read_format_rar_read_header(struct archive_read *a,\n  814:                                     struct archive_entry *entry)\n  815  {\n  816    const void *h;\n  817    const char *p;\n  818:   struct rar *rar;\n  819    size_t skip;\n  820    char head_type;\n  ...\n  827      a->archive.archive_format_name = \"RAR\";\n  828  \n  829:   rar = (struct rar *)(a->format->data);\n  830  \n  831    /*\n  ...\n  994  \n  995  static int\n  996: archive_read_format_rar_read_data(struct archive_read *a, const void **buff,\n  997                                    size_t *size, int64_t *offset)\n  998  {\n  999:   struct rar *rar = (struct rar *)(a->format->data);\n 1000    int ret;\n 1001  \n ....\n 1048  \n 1049  static int\n 1050: archive_read_format_rar_read_data_skip(struct archive_read *a)\n 1051  {\n 1052:   struct rar *rar;\n 1053    int64_t bytes_skipped;\n 1054    int ret;\n 1055  \n 1056:   rar = (struct rar *)(a->format->data);\n 1057  \n 1058    if (rar->bytes_unconsumed > 0) {\n ....\n 1085  \n 1086  static int64_t\n 1087: archive_read_format_rar_seek_data(struct archive_read *a, int64_t offset,\n 1088      int whence)\n 1089  {\n 1090    int64_t client_offset, ret;\n 1091    unsigned int i;\n 1092:   struct rar *rar = (struct rar *)(a->format->data);\n 1093  \n 1094    if (rar->compression_method == COMPRESS_METHOD_STORE)\n ....\n 1239  \n 1240  static int\n 1241: archive_read_format_rar_cleanup(struct archive_read *a)\n 1242  {\n 1243:   struct rar *rar;\n 1244  \n 1245:   rar = (struct rar *)(a->format->data);\n 1246    free_codes(a);\n 1247    free(rar->filename);\n ....\n 1257  \n 1258  static int\n 1259: read_header(struct archive_read *a, struct archive_entry *entry,\n 1260              char head_type)\n 1261  {\n 1262    const void *h;\n 1263    const char *p, *endp;\n 1264:   struct rar *rar;\n 1265:   struct rar_header rar_header;\n 1266:   struct rar_file_header file_header;\n 1267    int64_t header_size;\n 1268    unsigned filename_size, end;\n ....\n 1272    char unp_size[8];\n 1273    int ttime;\n 1274:   struct archive_string_conv *sconv, *fn_sconv;\n 1275    unsigned long crc32_val;\n 1276    int ret = (ARCHIVE_OK), ret2;\n 1277  \n 1278:   rar = (struct rar *)(a->format->data);\n 1279  \n 1280    /* Setup a string conversion object for non-rar-unicode filenames. */\n ....\n 1710  get_time(int ttime)\n 1711  {\n 1712:   struct tm tm;\n 1713    tm.tm_sec = 2 * (ttime & 0x1f);\n 1714    tm.tm_min = (ttime >> 5) & 0x3f;\n ....\n 1722  \n 1723  static int\n 1724: read_exttime(const char *p, struct rar *rar, const char *endp)\n 1725  {\n 1726    unsigned rmode, flags, rem, j, count;\n 1727    int ttime, i;\n 1728:   struct tm *tm;\n 1729    time_t t;\n 1730    long nsec;\n 1731  #if defined(HAVE_LOCALTIME_R) || defined(HAVE__LOCALTIME64_S)\n 1732:   struct tm tmbuf;\n 1733  #endif\n 1734  #if defined(HAVE__LOCALTIME64_S)\n ....\n 1811  \n 1812  static int\n 1813: read_symlink_stored(struct archive_read *a, struct archive_entry *entry,\n 1814:                     struct archive_string_conv *sconv)\n 1815  {\n 1816    const void *h;\n 1817    const char *p;\n 1818:   struct rar *rar;\n 1819    int ret = (ARCHIVE_OK);\n 1820  \n 1821:   rar = (struct rar *)(a->format->data);\n 1822    if ((h = rar_read_ahead(a, (size_t)rar->packed_size, NULL)) == NULL)\n 1823      return (ARCHIVE_FATAL);\n ....\n 1843  \n 1844  static int\n 1845: read_data_stored(struct archive_read *a, const void **buff, size_t *size,\n 1846                   int64_t *offset)\n 1847  {\n 1848:   struct rar *rar;\n 1849    ssize_t bytes_avail;\n 1850  \n 1851:   rar = (struct rar *)(a->format->data);\n 1852    if (rar->bytes_remaining == 0 &&\n 1853      !(rar->main_flags & MHD_VOLUME && rar->file_flags & FHD_SPLIT_AFTER))\n ....\n 1886  \n 1887  static int\n 1888: read_data_compressed(struct archive_read *a, const void **buff, size_t *size,\n 1889                 int64_t *offset, size_t looper)\n 1890  {\n ....\n 1892      return (ARCHIVE_FATAL);\n 1893  \n 1894:   struct rar *rar;\n 1895    int64_t start, end, actualend;\n 1896    size_t bs;\n 1897    int ret = (ARCHIVE_OK), sym, code, lzss_offset, length, i;\n 1898  \n 1899:   rar = (struct rar *)(a->format->data);\n 1900  \n 1901    do {\n ....\n 2087  \n 2088  static int\n 2089: parse_codes(struct archive_read *a)\n 2090  {\n 2091    int i, j, val, n, r;\n 2092    unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;\n 2093    unsigned int maxorder;\n 2094:   struct huffman_code precode;\n 2095:   struct rar *rar = (struct rar *)(a->format->data);\n 2096:   struct rar_br *br = &(rar->br);\n 2097  \n 2098    free_codes(a);\n ....\n 2144        }\n 2145  \n 2146:       /* Make sure ppmd7_contest is freed before Ppmd7_Construct\n 2147         * because reading a broken file cause this abnormal sequence. */\n 2148        __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n ....\n 2152        __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);\n 2153        rar->range_dec.Stream = &rar->bytein;\n 2154:       __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);\n 2155  \n 2156        if (rar->dictionary_size == 0) {\n ....\n 2365  \n 2366  static void\n 2367: free_codes(struct archive_read *a)\n 2368  {\n 2369:   struct rar *rar = (struct rar *)(a->format->data);\n 2370    free(rar->maincode.tree);\n 2371    free(rar->offsetcode.tree);\n ....\n 2384  \n 2385  static int\n 2386: read_next_symbol(struct archive_read *a, struct huffman_code *code)\n 2387  {\n 2388    unsigned char bit;\n 2389    unsigned int bits;\n 2390    int length, value, node;\n 2391:   struct rar *rar;\n 2392:   struct rar_br *br;\n 2393  \n 2394    if (!code->table)\n ....\n 2398    }\n 2399  \n 2400:   rar = (struct rar *)(a->format->data);\n 2401    br = &(rar->br);\n 2402  \n ....\n 2456  \n 2457  static int\n 2458: create_code(struct archive_read *a, struct huffman_code *code,\n 2459              unsigned char *lengths, int numsymbols, char maxlength)\n 2460  {\n ....\n 2491  \n 2492  static int\n 2493: add_value(struct archive_read *a, struct huffman_code *code, int value,\n 2494            int codebits, int length)\n 2495  {\n ....\n 2600  \n 2601  static int\n 2602: new_node(struct huffman_code *code)\n 2603  {\n 2604    void *new_tree;\n ....\n 2611      if (new_tree == NULL)\n 2612          return (-1);\n 2613:     code->tree = (struct huffman_tree_node *)new_tree;\n 2614      code->numallocatedentries = new_num_entries;\n 2615    }\n ....\n 2620  \n 2621  static int\n 2622: make_table(struct archive_read *a, struct huffman_code *code)\n 2623  {\n 2624    if (code->maxlength < code->minlength || code->maxlength > 10)\n ....\n 2628  \n 2629    code->table =\n 2630:     (struct huffman_table_entry *)calloc(1, sizeof(*code->table)\n 2631      * ((size_t)1 << code->tablesize));\n 2632  \n ....\n 2635  \n 2636  static int\n 2637: make_table_recurse(struct archive_read *a, struct huffman_code *code, int node,\n 2638:                    struct huffman_table_entry *table, int depth,\n 2639                     int maxdepth)\n 2640  {\n ....\n 2693  \n 2694  static int64_t\n 2695: expand(struct archive_read *a, int64_t end)\n 2696  {\n 2697    static const unsigned char lengthbases[] =\n ....\n 2737    int symbol, offs, len, offsindex, lensymbol, i, offssymbol, lowoffsetsymbol;\n 2738    unsigned char newfile;\n 2739:   struct rar *rar = (struct rar *)(a->format->data);\n 2740:   struct rar_br *br = &(rar->br);\n 2741  \n 2742    if (rar->filterstart < end)\n ....\n 2923  \n 2924  static int\n 2925: copy_from_lzss_window(struct archive_read *a, const void **buffer,\n 2926                          int64_t startpos, int length)\n 2927  {\n 2928    int windowoffs, firstpart;\n 2929:   struct rar *rar = (struct rar *)(a->format->data);\n 2930  \n 2931    if (!rar->unp_buffer)\n ....\n 2973  \n 2974  static const void *\n 2975: rar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)\n 2976  {\n 2977:   struct rar *rar = (struct rar *)(a->format->data);\n 2978    const void *h = __archive_read_ahead(a, min, avail);\n 2979    int ret;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_add_filter_program.c:\n   52  #if ARCHIVE_VERSION_NUMBER < 4000000\n   53  int\n   54: archive_write_set_compression_program(struct archive *a, const char *cmd)\n   55  {\n   56  \t__archive_write_filters_free(a);\n   ..\n   59  #endif\n   60  \n   61: struct archive_write_program_data {\n   62  #if defined(_WIN32) && !defined(__CYGWIN__)\n   63  \tHANDLE\t\t child;\n   ..\n   72  };\n   73  \n   74: struct private_data {\n   75: \tstruct archive_write_program_data *pdata;\n   76: \tstruct archive_string description;\n   77  \tchar\t\t*cmd;\n   78  };\n   79  \n   80: static int archive_compressor_program_open(struct archive_write_filter *);\n   81: static int archive_compressor_program_write(struct archive_write_filter *,\n   82  \t\t    const void *, size_t);\n   83: static int archive_compressor_program_close(struct archive_write_filter *);\n   84: static int archive_compressor_program_free(struct archive_write_filter *);\n   85  \n   86  /*\n   ..\n   89   */\n   90  int\n   91: archive_write_add_filter_program(struct archive *_a, const char *cmd)\n   92  {\n   93: \tstruct archive_write_filter *f = __archive_write_allocate_filter(_a);\n   94: \tstruct private_data *data;\n   95  \tstatic const char prefix[] = \"Program: \";\n   96  \n   ..\n  101  \tif (f->data == NULL)\n  102  \t\tgoto memerr;\n  103: \tdata = (struct private_data *)f->data;\n  104  \n  105  \tdata->cmd = strdup(cmd);\n  ...\n  133  \n  134  static int\n  135: archive_compressor_program_open(struct archive_write_filter *f)\n  136  {\n  137: \tstruct private_data *data = (struct private_data *)f->data;\n  138  \n  139  \treturn __archive_write_program_open(f, data->pdata, data->cmd);\n  ...\n  141  \n  142  static int\n  143: archive_compressor_program_write(struct archive_write_filter *f,\n  144      const void *buff, size_t length)\n  145  {\n  146: \tstruct private_data *data = (struct private_data *)f->data;\n  147  \n  148  \treturn __archive_write_program_write(f, data->pdata, buff, length);\n  ...\n  150  \n  151  static int\n  152: archive_compressor_program_close(struct archive_write_filter *f)\n  153  {\n  154: \tstruct private_data *data = (struct private_data *)f->data;\n  155  \n  156  \treturn __archive_write_program_close(f, data->pdata);\n  ...\n  158  \n  159  static int\n  160: archive_compressor_program_free(struct archive_write_filter *f)\n  161  {\n  162: \tstruct private_data *data = (struct private_data *)f->data;\n  163  \n  164  \tif (data) {\n  ...\n  175   * Allocate resources for executing an external program.\n  176   */\n  177: struct archive_write_program_data *\n  178  __archive_write_program_allocate(const char *program)\n  179  {\n  180: \tstruct archive_write_program_data *data;\n  181  \n  182: \tdata = calloc(1, sizeof(struct archive_write_program_data));\n  183  \tif (data == NULL)\n  184  \t\treturn (data);\n  ...\n  193   */\n  194  int\n  195: __archive_write_program_free(struct archive_write_program_data *data)\n  196  {\n  197  \n  ...\n  205  \n  206  int\n  207: __archive_write_program_open(struct archive_write_filter *f,\n  208:     struct archive_write_program_data *data, const char *cmd)\n  209  {\n  210  \tint ret;\n  ...\n  233  \n  234  static ssize_t\n  235: child_write(struct archive_write_filter *f,\n  236:     struct archive_write_program_data *data, const char *buf, size_t buf_len)\n  237  {\n  238  \tssize_t ret;\n  ...\n  301   */\n  302  int\n  303: __archive_write_program_write(struct archive_write_filter *f,\n  304:     struct archive_write_program_data *data, const void *buff, size_t length)\n  305  {\n  306  \tssize_t ret;\n  ...\n  328   */\n  329  int\n  330: __archive_write_program_close(struct archive_write_filter *f,\n  331:     struct archive_write_program_data *data)\n  332  {\n  333  \tint ret, status;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_disk_windows.c:\n   86  }\n   87  \n   88: struct fixup_entry {\n   89: \tstruct fixup_entry\t*next;\n   90: \tstruct archive_acl\t acl;\n   91  \tmode_t\t\t\t mode;\n   92  \tint64_t\t\t\t atime;\n   ..\n  130  #define\tTODO_MAC_METADATA\tARCHIVE_EXTRACT_MAC_METADATA\n  131  \n  132: struct archive_write_disk {\n  133: \tstruct archive\tarchive;\n  134  \n  135  \tmode_t\t\t\t user_umask;\n  136: \tstruct fixup_entry\t*fixup_list;\n  137: \tstruct fixup_entry\t*current_fixup;\n  138  \tint64_t\t\t\t user_uid;\n  139  \tint\t\t\t skip_file_set;\n  ...\n  152  \t * Full path of last file to satisfy symlink checks.\n  153  \t */\n  154: \tstruct archive_wstring\tpath_safe;\n  155  \n  156  \t/*\n  ...\n  163  \n  164  \t/* Information about the object being restored right now. */\n  165: \tstruct archive_entry\t*entry; /* Entry being extracted. */\n  166  \twchar_t\t\t\t*name; /* Name of entry, possibly edited. */\n  167: \tstruct archive_wstring\t _name_data; /* backing store for 'name' */\n  168  \twchar_t\t\t\t*tmpname; /* Temporary name */\n  169: \tstruct archive_wstring\t_tmpname_data; /* backing store for 'tmpname' */\n  170  \t/* Tasks remaining for this object. */\n  171  \tint\t\t\t todo;\n  ...\n  210  static int\tdisk_unlink(const wchar_t *);\n  211  static int\tdisk_rmdir(const wchar_t *);\n  212: static int\tcheck_symlinks(struct archive_write_disk *);\n  213: static int\tcreate_filesystem_object(struct archive_write_disk *);\n  214: static struct fixup_entry *current_fixup(struct archive_write_disk *,\n  215  \t\t    const wchar_t *pathname);\n  216: static int\tcleanup_pathname(struct archive_write_disk *);\n  217: static int\tcreate_dir(struct archive_write_disk *, wchar_t *);\n  218: static int\tcreate_parent_dir(struct archive_write_disk *, wchar_t *);\n  219  static int\tla_chmod(const wchar_t *, mode_t);\n  220: static int\tla_mktemp(struct archive_write_disk *);\n  221: static int\tolder(BY_HANDLE_FILE_INFORMATION *, struct archive_entry *);\n  222: static int\tpermissive_name_w(struct archive_write_disk *);\n  223: static int\trestore_entry(struct archive_write_disk *);\n  224: static int\tset_acls(struct archive_write_disk *, HANDLE h,\n  225: \t\t    const wchar_t *, struct archive_acl *);\n  226: static int\tset_xattrs(struct archive_write_disk *);\n  227: static int\tclear_nochange_fflags(struct archive_write_disk *);\n  228: static int\tset_fflags(struct archive_write_disk *);\n  229  static int\tset_fflags_platform(const wchar_t *, unsigned long,\n  230  \t\t    unsigned long);\n  231: static int\tset_ownership(struct archive_write_disk *);\n  232: static int\tset_mode(struct archive_write_disk *, int mode);\n  233: static int\tset_times(struct archive_write_disk *, HANDLE, int,\n  234  \t\t    const wchar_t *, time_t, long, time_t, long, time_t,\n  235  \t\t    long, time_t, long);\n  236: static int\tset_times_from_entry(struct archive_write_disk *);\n  237: static struct fixup_entry *sort_dir_list(struct fixup_entry *p);\n  238: static ssize_t\twrite_data_block(struct archive_write_disk *,\n  239  \t\t    const char *, size_t);\n  240  \n  241: static struct archive_vtable *archive_write_disk_vtable(void);\n  242  \n  243: static int\t_archive_write_disk_close(struct archive *);\n  244: static int\t_archive_write_disk_free(struct archive *);\n  245: static int\t_archive_write_disk_header(struct archive *,\n  246: \t\t    struct archive_entry *);\n  247: static int64_t\t_archive_write_disk_filter_bytes(struct archive *, int);\n  248: static int\t_archive_write_disk_finish_entry(struct archive *);\n  249: static ssize_t\t_archive_write_disk_data(struct archive *, const void *,\n  250  \t\t    size_t);\n  251: static ssize_t\t_archive_write_disk_data_block(struct archive *, const void *,\n  252  \t\t    size_t, int64_t);\n  253  \n  ...\n  262  \n  263  static int\n  264: file_information(struct archive_write_disk *a, wchar_t *path,\n  265      BY_HANDLE_FILE_INFORMATION *st, mode_t *mode, int sim_lstat)\n  266  {\n  ...\n  363   */\n  364  static int\n  365: permissive_name_w(struct archive_write_disk *a)\n  366  {\n  367  \twchar_t *wn, *wnp;\n  ...\n  539  \n  540  static int\n  541: la_mktemp(struct archive_write_disk *a)\n  542  {\n  543  \tint fd;\n  ...\n  736  \n  737  static int\n  738: lazy_stat(struct archive_write_disk *a)\n  739  {\n  740  \tif (a->pst != NULL) {\n  ...\n  760  }\n  761  \n  762: static struct archive_vtable *\n  763  archive_write_disk_vtable(void)\n  764  {\n  765: \tstatic struct archive_vtable av;\n  766  \tstatic int inited = 0;\n  767  \n  ...\n  781  \n  782  static int64_t\n  783: _archive_write_disk_filter_bytes(struct archive *_a, int n)\n  784  {\n  785: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n  786  \t(void)n; /* UNUSED */\n  787  \tif (n == -1 || n == 0)\n  ...\n  792  \n  793  int\n  794: archive_write_disk_set_options(struct archive *_a, int flags)\n  795  {\n  796: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n  797  \n  798  \ta->flags = flags;\n  ...\n  813   */\n  814  static int\n  815: _archive_write_disk_header(struct archive *_a, struct archive_entry *entry)\n  816  {\n  817: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n  818: \tstruct fixup_entry *fe;\n  819  \tint ret, r;\n  820  \n  ...\n 1043  \n 1044  int\n 1045: archive_write_disk_set_skip_file(struct archive *_a, la_int64_t d, la_int64_t i)\n 1046  {\n 1047: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1048  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n 1049  \t    ARCHIVE_STATE_ANY, \"archive_write_disk_set_skip_file\");\n ....\n 1055  \n 1056  static ssize_t\n 1057: write_data_block(struct archive_write_disk *a, const char *buff, size_t size)\n 1058  {\n 1059  \tOVERLAPPED ol;\n ....\n 1136  \n 1137  static ssize_t\n 1138: _archive_write_disk_data_block(struct archive *_a,\n 1139      const void *buff, size_t size, int64_t offset)\n 1140  {\n 1141: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1142  \tssize_t r;\n 1143  \n ....\n 1162  \n 1163  static ssize_t\n 1164: _archive_write_disk_data(struct archive *_a, const void *buff, size_t size)\n 1165  {\n 1166: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1167  \n 1168  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n ....\n 1173  \n 1174  static int\n 1175: _archive_write_disk_finish_entry(struct archive *_a)\n 1176  {\n 1177: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1178  \tint ret = ARCHIVE_OK;\n 1179  \n ....\n 1301  \n 1302  int\n 1303: archive_write_disk_set_group_lookup(struct archive *_a,\n 1304      void *private_data,\n 1305      la_int64_t (*lookup_gid)(void *private, const char *gname, la_int64_t gid),\n 1306      void (*cleanup_gid)(void *private))\n 1307  {\n 1308: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1309  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n 1310  \t    ARCHIVE_STATE_ANY, \"archive_write_disk_set_group_lookup\");\n ....\n 1320  \n 1321  int\n 1322: archive_write_disk_set_user_lookup(struct archive *_a,\n 1323      void *private_data,\n 1324      int64_t (*lookup_uid)(void *private, const char *uname, int64_t uid),\n 1325      void (*cleanup_uid)(void *private))\n 1326  {\n 1327: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1328  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n 1329  \t    ARCHIVE_STATE_ANY, \"archive_write_disk_set_user_lookup\");\n ....\n 1339  \n 1340  int64_t\n 1341: archive_write_disk_gid(struct archive *_a, const char *name, la_int64_t id)\n 1342  {\n 1343:        struct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1344         archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n 1345             ARCHIVE_STATE_ANY, \"archive_write_disk_gid\");\n ....\n 1350   \n 1351  int64_t\n 1352: archive_write_disk_uid(struct archive *_a, const char *name, la_int64_t id)\n 1353  {\n 1354:        struct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1355         archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n 1356             ARCHIVE_STATE_ANY, \"archive_write_disk_uid\");\n ....\n 1363   * Create a new archive_write_disk object and initialize it with global state.\n 1364   */\n 1365: struct archive *\n 1366  archive_write_disk_new(void)\n 1367  {\n 1368: \tstruct archive_write_disk *a;\n 1369  \n 1370: \ta = (struct archive_write_disk *)calloc(1, sizeof(*a));\n 1371  \tif (a == NULL)\n 1372  \t\treturn (NULL);\n ....\n 1419   */\n 1420  static int\n 1421: restore_entry(struct archive_write_disk *a)\n 1422  {\n 1423  \tint ret = ARCHIVE_OK, en;\n ....\n 1659   */\n 1660  static int\n 1661: create_filesystem_object(struct archive_write_disk *a)\n 1662  {\n 1663  \t/* Create the entry. */\n ....\n 1682  \t\t\t/*\n 1683  \t\t\t * Unlinking and linking here is really not atomic,\n 1684: \t\t\t * but doing it right, would require us to construct\n 1685  \t\t\t * an mktemplink() function, and then use _wrename().\n 1686  \t\t\t */\n ....\n 1732  \t\t/*\n 1733  \t\t * Unlinking and linking here is really not atomic,\n 1734: \t\t * but doing it right, would require us to construct\n 1735  \t\t * an mktemplink() function, and then use _wrename().\n 1736  \t\t */\n ....\n 1881   */\n 1882  static int\n 1883: _archive_write_disk_close(struct archive *_a)\n 1884  {\n 1885: \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n 1886: \tstruct fixup_entry *next, *p;\n 1887  \tint ret;\n 1888  \n ....\n 1921  \n 1922  static int\n 1923: _archive_write_disk_free(struct archive *_a)\n 1924  {\n 1925: \tstruct archive_write_disk *a;\n 1926  \tint ret;\n 1927  \tif (_a == NULL)\n ....\n 1929  \tarchive_check_magic(_a, ARCHIVE_WRITE_DISK_MAGIC,\n 1930  \t    ARCHIVE_STATE_ANY | ARCHIVE_STATE_FATAL, \"archive_write_disk_free\");\n 1931: \ta = (struct archive_write_disk *)_a;\n 1932  \tret = _archive_write_disk_close(&a->archive);\n 1933  \tarchive_write_disk_set_group_lookup(&a->archive, NULL, NULL, NULL);\n ....\n 1948   * particular, we want to restore dir timestamps depth-first.\n 1949   */\n 1950: static struct fixup_entry *\n 1951: sort_dir_list(struct fixup_entry *p)\n 1952  {\n 1953: \tstruct fixup_entry *a, *b, *t;\n 1954  \n 1955  \tif (p == NULL)\n ....\n 2013   *\n 2014   * TODO: Reduce the memory requirements for this list by using a tree\n 2015:  * structure rather than a simple list of names.\n 2016   */\n 2017: static struct fixup_entry *\n 2018: new_fixup(struct archive_write_disk *a, const wchar_t *pathname)\n 2019  {\n 2020: \tstruct fixup_entry *fe;\n 2021  \n 2022: \tfe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));\n 2023  \tif (fe == NULL)\n 2024  \t\treturn (NULL);\n ....\n 2032  \n 2033  /*\n 2034:  * Returns a fixup structure for the current entry.\n 2035   */\n 2036: static struct fixup_entry *\n 2037: current_fixup(struct archive_write_disk *a, const wchar_t *pathname)\n 2038  {\n 2039  \tif (a->current_fixup == NULL)\n ....\n 2052   */\n 2053  static int\n 2054: check_symlinks(struct archive_write_disk *a)\n 2055  {\n 2056  \twchar_t *pn, *p;\n ....\n 2185   */\n 2186  static int\n 2187: cleanup_pathname(struct archive_write_disk *a)\n 2188  {\n 2189  \twchar_t *dest, *src, *p, *top;\n ....\n 2359   */\n 2360  static int\n 2361: create_parent_dir(struct archive_write_disk *a, wchar_t *path)\n 2362  {\n 2363  \twchar_t *slash;\n ....\n 2382   */\n 2383  static int\n 2384: create_dir(struct archive_write_disk *a, wchar_t *path)\n 2385  {\n 2386  \tBY_HANDLE_FILE_INFORMATION st;\n 2387: \tstruct fixup_entry *le;\n 2388  \twchar_t *slash, *base, *full;\n 2389  \tmode_t mode_final, mode, st_mode;\n ....\n 2502   */\n 2503  static int\n 2504: set_ownership(struct archive_write_disk *a)\n 2505  {\n 2506  /* unfortunately, on win32 there is no 'root' user with uid 0,\n ....\n 2521  \n 2522  static int\n 2523: set_times(struct archive_write_disk *a,\n 2524      HANDLE h, int mode, const wchar_t *name,\n 2525      time_t atime, long atime_nanos,\n ....\n 2586  \n 2587  static int\n 2588: set_times_from_entry(struct archive_write_disk *a)\n 2589  {\n 2590  \ttime_t atime, birthtime, mtime, ctime_sec;\n ....\n 2626  \n 2627  static int\n 2628: set_mode(struct archive_write_disk *a, int mode)\n 2629  {\n 2630  \tint r = ARCHIVE_OK;\n ....\n 2738  \n 2739  static int\n 2740: clear_nochange_fflags(struct archive_write_disk *a)\n 2741  {\n 2742  \treturn (set_fflags_platform(a->name, 0, FILE_ATTRIBUTE_READONLY));\n ....\n 2744  \n 2745  static int\n 2746: set_fflags(struct archive_write_disk *a)\n 2747  {\n 2748  \tunsigned long\tset, clear;\n ....\n 2760  /* Default empty function body to satisfy mainline code. */\n 2761  static int\n 2762: set_acls(struct archive_write_disk *a, HANDLE h, const wchar_t *name,\n 2763: \t struct archive_acl *acl)\n 2764  {\n 2765  \t(void)a; /* UNUSED */\n ....\n 2774   */\n 2775  static int\n 2776: set_xattrs(struct archive_write_disk *a)\n 2777  {\n 2778  \tstatic int warning_done = 0;\n ....\n 2812   */\n 2813  static int\n 2814: older(BY_HANDLE_FILE_INFORMATION *st, struct archive_entry *entry)\n 2815  {\n 2816  \ttime_t sec;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_set_format.c:\n   36  \n   37  int\n   38: archive_read_set_format(struct archive *_a, int code)\n   39  {\n   40    int r1, r2, slots, i;\n   41    char str[10];\n   42:   struct archive_read *a = (struct archive_read *)_a;\n   43  \n   44    if ((r1 = archive_read_support_format_by_code(_a, code)) < (ARCHIVE_OK))\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_read_support_format_cab.c:\n   50  \n   51  \n   52: struct lzx_dec {\n   53  \t/* Decoding status. */\n   54  \tint     \t\t state;\n   ..\n   86  \tint\t\t\t offset_bits;\n   87  \n   88: \tstruct lzx_pos_tbl {\n   89  \t\tint\t\t base;\n   90  \t\tint\t\t footer_bits;\n   ..\n   93  \t * Bit stream reader.\n   94  \t */\n   95: \tstruct lzx_br {\n   96  #define CACHE_TYPE\t\tuint64_t\n   97  #define CACHE_BITS\t\t(8 * sizeof(CACHE_TYPE))\n   ..\n  107  \t * Huffman coding.\n  108  \t */\n  109: \tstruct huffman {\n  110  \t\tint\t\t len_size;\n  111  \t\tint\t\t freq[17];\n  ...\n  134  #define SLOT_MAX\t21/*->25*/\n  135  \n  136: struct lzx_stream {\n  137  \tconst unsigned char\t*next_in;\n  138  \tint64_t\t\t\t avail_in;\n  ...\n  141  \tint64_t\t\t\t avail_out;\n  142  \tint64_t\t\t\t total_out;\n  143: \tstruct lzx_dec\t\t*ds;\n  144  };\n  145  \n  ...\n  187  };\n  188  \n  189: struct cfdata {\n  190  \t/* Sum value of this CFDATA. */\n  191  \tuint32_t\t\t sum;\n  ...\n  209  };\n  210  \n  211: struct cffolder {\n  212  \tuint32_t\t\t cfdata_offset_in_cab;\n  213  \tuint16_t\t\t cfdata_count;\n  ...\n  220  \tconst char\t\t*compname;\n  221  \t/* At the time reading CFDATA */\n  222: \tstruct cfdata\t\t cfdata;\n  223  \tint\t\t\t cfdata_index;\n  224  \t/* Flags to mark progress of decompression. */\n  ...\n  226  };\n  227  \n  228: struct cffile {\n  229  \tuint32_t\t\t uncompressed_size;\n  230  \tuint32_t\t\t offset;\n  ...\n  237  #define ATTR_RDONLY\t\t0x01\n  238  #define ATTR_NAME_IS_UTF\t0x80\n  239: \tstruct archive_string \t pathname;\n  240  };\n  241  \n  242: struct cfheader {\n  243  \t/* Total bytes of all file size in a Cabinet. */\n  244  \tuint32_t\t\t total_bytes;\n  ...\n  258  \tunsigned char\t\t cfdata;\n  259  \t/* All folders in a cabinet. */\n  260: \tstruct cffolder\t\t*folder_array;\n  261  \t/* All files in a cabinet. */\n  262: \tstruct cffile\t\t*file_array;\n  263  \tint\t\t\t file_index;\n  264  };\n  265  \n  266: struct cab {\n  267  \t/* entry_bytes_remaining is the number of bytes we expect.\t    */\n  268  \tint64_t\t\t\t entry_offset;\n  ...\n  271  \tint64_t\t\t\t entry_compressed_bytes_read;\n  272  \tint64_t\t\t\t entry_uncompressed_bytes_read;\n  273: \tstruct cffolder\t\t*entry_cffolder;\n  274: \tstruct cffile\t\t*entry_cffile;\n  275: \tstruct cfdata\t\t*entry_cfdata;\n  276  \n  277  \t/* Offset from beginning of a cabinet file. */\n  278  \tint64_t\t\t\t cab_offset;\n  279: \tstruct cfheader\t\t cfheader;\n  280: \tstruct archive_wstring\t ws;\n  281  \n  282  \t/* Flag to mark progress that an archive was read their first header.*/\n  ...\n  292  \n  293  \tint\t\t\t init_default_conversion;\n  294: \tstruct archive_string_conv *sconv;\n  295: \tstruct archive_string_conv *sconv_default;\n  296: \tstruct archive_string_conv *sconv_utf8;\n  297  \tchar\t\t\t format_name[64];\n  298  \n  ...\n  301  \tchar\t\t\t stream_valid;\n  302  #endif\n  303: \tstruct lzx_stream\t xstrm;\n  304  };\n  305  \n  306: static int\tarchive_read_format_cab_bid(struct archive_read *, int);\n  307: static int\tarchive_read_format_cab_options(struct archive_read *,\n  308  \t\t    const char *, const char *);\n  309: static int\tarchive_read_format_cab_read_header(struct archive_read *,\n  310: \t\t    struct archive_entry *);\n  311: static int\tarchive_read_format_cab_read_data(struct archive_read *,\n  312  \t\t    const void **, size_t *, int64_t *);\n  313: static int\tarchive_read_format_cab_read_data_skip(struct archive_read *);\n  314: static int\tarchive_read_format_cab_cleanup(struct archive_read *);\n  315  \n  316: static int\tcab_skip_sfx(struct archive_read *);\n  317  static time_t\tcab_dos_time(const unsigned char *);\n  318: static int\tcab_read_data(struct archive_read *, const void **,\n  319  \t\t    size_t *, int64_t *);\n  320: static int\tcab_read_header(struct archive_read *);\n  321  static uint32_t cab_checksum_cfdata_4(const void *, size_t bytes, uint32_t);\n  322  static uint32_t cab_checksum_cfdata(const void *, size_t bytes, uint32_t);\n  323: static void\tcab_checksum_update(struct archive_read *, size_t);\n  324: static int\tcab_checksum_finish(struct archive_read *);\n  325: static int\tcab_next_cfdata(struct archive_read *);\n  326: static const void *cab_read_ahead_cfdata(struct archive_read *, ssize_t *);\n  327: static const void *cab_read_ahead_cfdata_none(struct archive_read *, ssize_t *);\n  328: static const void *cab_read_ahead_cfdata_deflate(struct archive_read *,\n  329  \t\t    ssize_t *);\n  330: static const void *cab_read_ahead_cfdata_lzx(struct archive_read *,\n  331  \t\t    ssize_t *);\n  332: static int64_t\tcab_consume_cfdata(struct archive_read *, int64_t);\n  333: static int64_t\tcab_minimum_consume_cfdata(struct archive_read *, int64_t);\n  334: static int\tlzx_decode_init(struct lzx_stream *, int);\n  335: static int\tlzx_read_blocks(struct lzx_stream *, int);\n  336: static int\tlzx_decode_blocks(struct lzx_stream *, int);\n  337: static void\tlzx_decode_free(struct lzx_stream *);\n  338: static void\tlzx_translation(struct lzx_stream *, void *, size_t, uint32_t);\n  339: static void\tlzx_cleanup_bitstream(struct lzx_stream *);\n  340: static int\tlzx_decode(struct lzx_stream *, int);\n  341: static int\tlzx_read_pre_tree(struct lzx_stream *);\n  342: static int\tlzx_read_bitlen(struct lzx_stream *, struct huffman *, int);\n  343: static int\tlzx_huffman_init(struct huffman *, size_t, int);\n  344: static void\tlzx_huffman_free(struct huffman *);\n  345: static int\tlzx_make_huffman_table(struct huffman *);\n  346: static inline int lzx_decode_huffman(struct huffman *, unsigned);\n  347  \n  348  \n  349  int\n  350: archive_read_support_format_cab(struct archive *_a)\n  351  {\n  352: \tstruct archive_read *a = (struct archive_read *)_a;\n  353: \tstruct cab *cab;\n  354  \tint r;\n  355  \n  ...\n  357  \t    ARCHIVE_STATE_NEW, \"archive_read_support_format_cab\");\n  358  \n  359: \tcab = (struct cab *)calloc(1, sizeof(*cab));\n  360  \tif (cab == NULL) {\n  361  \t\tarchive_set_error(&a->archive, ENOMEM,\n  ...\n  408  \n  409  static int\n  410: archive_read_format_cab_bid(struct archive_read *a, int best_bid)\n  411  {\n  412  \tconst char *p;\n  ...\n  456  \n  457  static int\n  458: archive_read_format_cab_options(struct archive_read *a,\n  459      const char *key, const char *val)\n  460  {\n  461: \tstruct cab *cab;\n  462  \tint ret = ARCHIVE_FAILED;\n  463  \n  464: \tcab = (struct cab *)(a->format->data);\n  465  \tif (strcmp(key, \"hdrcharset\")  == 0) {\n  466  \t\tif (val == NULL || val[0] == 0)\n  ...\n  485  \n  486  static int\n  487: cab_skip_sfx(struct archive_read *a)\n  488  {\n  489  \tconst char *p, *q;\n  ...\n  527  \n  528  static int\n  529: truncated_error(struct archive_read *a)\n  530  {\n  531  \tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n  ...\n  550  /* Read bytes as much as remaining. */\n  551  static const void *\n  552: cab_read_ahead_remaining(struct archive_read *a, size_t min, ssize_t *avail)\n  553  {\n  554  \tconst void *p;\n  ...\n  565  /* Convert a path separator '\\' -> '/' */\n  566  static int\n  567: cab_convert_path_separator_1(struct archive_string *fn, unsigned char attr)\n  568  {\n  569  \tsize_t i;\n  ...\n  595   */\n  596  static void\n  597: cab_convert_path_separator_2(struct cab *cab, struct archive_entry *entry)\n  598  {\n  599  \tconst wchar_t *wp;\n  ...\n  615   */\n  616  static int\n  617: cab_read_header(struct archive_read *a)\n  618  {\n  619  \tconst unsigned char *p;\n  620: \tstruct cab *cab;\n  621: \tstruct cfheader *hd;\n  622  \tsize_t bytes, used;\n  623  \tssize_t len;\n  ...\n  634  \t\treturn (truncated_error(a));\n  635  \n  636: \tcab = (struct cab *)(a->format->data);\n  637  \tif (cab->found_header == 0 &&\n  638  \t    p[0] == 'M' && p[1] == 'Z') {\n  ...\n  718  \t * Read CFFOLDER.\n  719  \t */\n  720: \thd->folder_array = (struct cffolder *)calloc(\n  721: \t    hd->folder_count, sizeof(struct cffolder));\n  722  \tif (hd->folder_array == NULL)\n  723  \t\tgoto nomem;\n  ...\n  731  \toffset32 = 0;\n  732  \tfor (i = 0; i < hd->folder_count; i++) {\n  733: \t\tstruct cffolder *folder = &(hd->folder_array[i]);\n  734  \t\tfolder->cfdata_offset_in_cab =\n  735  \t\t    archive_le32dec(p + CFFOLDER_coffCabStart);\n  ...\n  781  \t}\n  782  \t/* Allocate memory for CFDATA */\n  783: \thd->file_array = (struct cffile *)calloc(\n  784: \t    hd->file_count, sizeof(struct cffile));\n  785  \tif (hd->file_array == NULL)\n  786  \t\tgoto nomem;\n  ...\n  788  \tprev_folder = -1;\n  789  \tfor (i = 0; i < hd->file_count; i++) {\n  790: \t\tstruct cffile *file = &(hd->file_array[i]);\n  791  \t\tssize_t avail;\n  792  \n  ...\n  881  \n  882  static int\n  883: archive_read_format_cab_read_header(struct archive_read *a,\n  884:     struct archive_entry *entry)\n  885  {\n  886: \tstruct cab *cab;\n  887: \tstruct cfheader *hd;\n  888: \tstruct cffolder *prev_folder;\n  889: \tstruct cffile *file;\n  890: \tstruct archive_string_conv *sconv;\n  891  \tint err = ARCHIVE_OK, r;\n  892  \t\n  893: \tcab = (struct cab *)(a->format->data);\n  894  \tif (cab->found_header == 0) {\n  895  \t\terr = cab_read_header(a); \n  ...\n 1005  \n 1006  static int\n 1007: archive_read_format_cab_read_data(struct archive_read *a,\n 1008      const void **buff, size_t *size, int64_t *offset)\n 1009  {\n 1010: \tstruct cab *cab = (struct cab *)(a->format->data);\n 1011  \tint r;\n 1012  \n ....\n 1106  \n 1107  static void\n 1108: cab_checksum_update(struct archive_read *a, size_t bytes)\n 1109  {\n 1110: \tstruct cab *cab = (struct cab *)(a->format->data);\n 1111: \tstruct cfdata *cfdata = cab->entry_cfdata;\n 1112  \tconst unsigned char *p;\n 1113  \tsize_t sumbytes;\n ....\n 1146  \n 1147  static int\n 1148: cab_checksum_finish(struct archive_read *a)\n 1149  {\n 1150: \tstruct cab *cab = (struct cab *)(a->format->data);\n 1151: \tstruct cfdata *cfdata = cab->entry_cfdata;\n 1152  \tint l;\n 1153  \n ....\n 1186   */\n 1187  static int\n 1188: cab_next_cfdata(struct archive_read *a)\n 1189  {\n 1190: \tstruct cab *cab = (struct cab *)(a->format->data);\n 1191: \tstruct cfdata *cfdata = cab->entry_cfdata;\n 1192  \n 1193  \t/* There are remaining bytes in current CFDATA, use it first. */\n ....\n 1334   */\n 1335  static const void *\n 1336: cab_read_ahead_cfdata(struct archive_read *a, ssize_t *avail)\n 1337  {\n 1338: \tstruct cab *cab = (struct cab *)(a->format->data);\n 1339  \tint err;\n 1340  \n ....\n 1365   */\n 1366  static const void *\n 1367: cab_read_ahead_cfdata_none(struct archive_read *a, ssize_t *avail)\n 1368  {\n 1369: \tstruct cab *cab = (struct cab *)(a->format->data);\n 1370: \tstruct cfdata *cfdata;\n 1371  \tconst void *d;\n 1372  \n ....\n 1397  #ifdef HAVE_ZLIB_H\n 1398  static const void *\n 1399: cab_read_ahead_cfdata_deflate(struct archive_read *a, ssize_t *avail)\n 1400  {\n 1401: \tstruct cab *cab = (struct cab *)(a->format->data);\n 1402: \tstruct cfdata *cfdata;\n 1403  \tconst void *d;\n 1404  \tint r, mszip;\n ....\n 1445  \t\t\treturn (NULL);\n 1446  \t\t}\n 1447: \t\t/* Stream structure has been set up. */\n 1448  \t\tcab->stream_valid = 1;\n 1449  \t\t/* We've initialized decompression for this stream. */\n ....\n 1616  \n 1617  static const void *\n 1618: cab_read_ahead_cfdata_deflate(struct archive_read *a, ssize_t *avail)\n 1619  {\n 1620  \t*avail = ARCHIVE_FATAL;\n ....\n 1627  \n 1628  static const void *\n 1629: cab_read_ahead_cfdata_lzx(struct archive_read *a, ssize_t *avail)\n 1630  {\n 1631: \tstruct cab *cab = (struct cab *)(a->format->data);\n 1632: \tstruct cfdata *cfdata;\n 1633  \tconst void *d;\n 1634  \tint r;\n ....\n 1759   */\n 1760  static int64_t\n 1761: cab_consume_cfdata(struct archive_read *a, int64_t consumed_bytes)\n 1762  {\n 1763: \tstruct cab *cab = (struct cab *)(a->format->data);\n 1764: \tstruct cfdata *cfdata;\n 1765  \tint64_t cbytes, rbytes;\n 1766  \tint err;\n ....\n 1852   */\n 1853  static int64_t\n 1854: cab_minimum_consume_cfdata(struct archive_read *a, int64_t consumed_bytes)\n 1855  {\n 1856: \tstruct cab *cab = (struct cab *)(a->format->data);\n 1857: \tstruct cfdata *cfdata;\n 1858  \tint64_t cbytes, rbytes;\n 1859  \tint err;\n ....\n 1908   */\n 1909  static int\n 1910: cab_read_data(struct archive_read *a, const void **buff,\n 1911      size_t *size, int64_t *offset)\n 1912  {\n 1913: \tstruct cab *cab = (struct cab *)(a->format->data);\n 1914  \tssize_t bytes_avail;\n 1915  \n ....\n 1955  \n 1956  static int\n 1957: archive_read_format_cab_read_data_skip(struct archive_read *a)\n 1958  {\n 1959: \tstruct cab *cab;\n 1960  \tint64_t bytes_skipped;\n 1961  \tint r;\n 1962  \n 1963: \tcab = (struct cab *)(a->format->data);\n 1964  \n 1965  \tif (cab->end_of_archive)\n ....\n 2010  \n 2011  static int\n 2012: archive_read_format_cab_cleanup(struct archive_read *a)\n 2013  {\n 2014: \tstruct cab *cab = (struct cab *)(a->format->data);\n 2015: \tstruct cfheader *hd = &cab->cfheader;\n 2016  \tint i;\n 2017  \n ....\n 2043  {\n 2044  \tint msTime, msDate;\n 2045: \tstruct tm ts;\n 2046  \n 2047  \tmsDate = archive_le16dec(p);\n ....\n 2074   */\n 2075  static int\n 2076: lzx_decode_init(struct lzx_stream *strm, int w_bits)\n 2077  {\n 2078: \tstruct lzx_dec *ds;\n 2079  \tint slot, w_size, w_slot;\n 2080  \tint base, footer;\n ....\n 2165   */\n 2166  static void\n 2167: lzx_decode_free(struct lzx_stream *strm)\n 2168  {\n 2169  \n ....\n 2184   */\n 2185  static void\n 2186: lzx_translation(struct lzx_stream *strm, void *p, size_t size, uint32_t offset)\n 2187  {\n 2188: \tstruct lzx_dec *ds = strm->ds;\n 2189  \tunsigned char *b, *end;\n 2190  \n ....\n 2261   */\n 2262  static int\n 2263: lzx_br_fillup(struct lzx_stream *strm, struct lzx_br *br)\n 2264  {\n 2265  /*\n ....\n 2331  \n 2332  static void\n 2333: lzx_br_fixup(struct lzx_stream *strm, struct lzx_br *br)\n 2334  {\n 2335  \tint n = CACHE_BITS - br->cache_avail;\n ....\n 2347  \n 2348  static void\n 2349: lzx_cleanup_bitstream(struct lzx_stream *strm)\n 2350  {\n 2351  \tstrm->ds->br.cache_avail = 0;\n ....\n 2387  \n 2388  static int\n 2389: lzx_decode(struct lzx_stream *strm, int last)\n 2390  {\n 2391: \tstruct lzx_dec *ds = strm->ds;\n 2392  \tint64_t avail_in;\n 2393  \tint r;\n ....\n 2414  \n 2415  static int\n 2416: lzx_read_blocks(struct lzx_stream *strm, int last)\n 2417  {\n 2418: \tstruct lzx_dec *ds = strm->ds;\n 2419: \tstruct lzx_br *br = &(ds->br);\n 2420  \tint i, r;\n 2421  \n ....\n 2739  \n 2740  static int\n 2741: lzx_decode_blocks(struct lzx_stream *strm, int last)\n 2742  {\n 2743: \tstruct lzx_dec *ds = strm->ds;\n 2744: \tstruct lzx_br bre = ds->br;\n 2745: \tstruct huffman *at = &(ds->at), *lt = &(ds->lt), *mt = &(ds->mt);\n 2746: \tconst struct lzx_pos_tbl *pos_tbl = ds->pos_tbl;\n 2747  \tunsigned char *noutp = strm->next_out;\n 2748  \tunsigned char *endp = noutp + strm->avail_out;\n ....\n 3013  \n 3014  static int\n 3015: lzx_read_pre_tree(struct lzx_stream *strm)\n 3016  {\n 3017: \tstruct lzx_dec *ds = strm->ds;\n 3018: \tstruct lzx_br *br = &(ds->br);\n 3019  \tint i;\n 3020  \n ....\n 3038   */\n 3039  static int\n 3040: lzx_read_bitlen(struct lzx_stream *strm, struct huffman *d, int end)\n 3041  {\n 3042: \tstruct lzx_dec *ds = strm->ds;\n 3043: \tstruct lzx_br *br = &(ds->br);\n 3044  \tint c, i, j, ret, same;\n 3045  \tunsigned rbits;\n ....\n 3116  \n 3117  static int\n 3118: lzx_huffman_init(struct huffman *hf, size_t len_size, int tbl_bits)\n 3119  {\n 3120  \n ....\n 3137  \n 3138  static void\n 3139: lzx_huffman_free(struct huffman *hf)\n 3140  {\n 3141  \tfree(hf->bitlen);\n ....\n 3147   */\n 3148  static int\n 3149: lzx_make_huffman_table(struct huffman *hf)\n 3150  {\n 3151  \tuint16_t *tbl;\n ....\n 3217  \n 3218  static inline int\n 3219: lzx_decode_huffman(struct huffman *hf, unsigned rbits)\n 3220  {\n 3221  \tint c;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive.h:\n   76  #endif\n   77  \n   78: /* The la_ssize_t should match the type used in 'struct stat' */\n   79  #if !defined(__LA_SSIZE_T_DEFINED)\n   80  /* Older code relied on the __LA_SSIZE_T macro; after 4.0 we'll switch to the typedef exclusively. */\n   ..\n  181  \n  182  /* Declare our basic types. */\n  183: struct archive;\n  184: struct archive_entry;\n  185  \n  186  /*\n  ...\n  220  \n  221  /* Returns pointer and size of next block of data from archive. */\n  222: typedef la_ssize_t\tarchive_read_callback(struct archive *,\n  223  \t\t\t    void *_client_data, const void **_buffer);\n  224  \n  ...\n  228   * read callback and discard data as necessary to make up the full skip.\n  229   */\n  230: typedef la_int64_t\tarchive_skip_callback(struct archive *,\n  231  \t\t\t    void *_client_data, la_int64_t request);\n  232  \n  ...\n  235   * Return ARCHIVE_FATAL if the seek fails for any reason.\n  236   */\n  237: typedef la_int64_t\tarchive_seek_callback(struct archive *,\n  238      void *_client_data, la_int64_t offset, int whence);\n  239  \n  240  /* Returns size actually written, zero on EOF, -1 on error. */\n  241: typedef la_ssize_t\tarchive_write_callback(struct archive *,\n  242  \t\t\t    void *_client_data,\n  243  \t\t\t    const void *_buffer, size_t _length);\n  244  \n  245: typedef int\tarchive_open_callback(struct archive *, void *_client_data);\n  246  \n  247: typedef int\tarchive_close_callback(struct archive *, void *_client_data);\n  248  \n  249: typedef int\tarchive_free_callback(struct archive *, void *_client_data);\n  250  \n  251  /* Switches from one client data object to the next/prev client data object.\n  ...\n  253   * that make up one large file.\n  254   */\n  255: typedef int archive_switch_callback(struct archive *, void *_client_data1,\n  256  \t\t\t    void *_client_data2);\n  257  \n  ...\n  260   * to do and give it up.\n  261   */\n  262: typedef const char *archive_passphrase_callback(struct archive *,\n  263  \t\t\t    void *_client_data);\n  264  \n  ...\n  382   *   5) Call archive_read_free to end processing.\n  383   */\n  384: __LA_DECL struct archive\t*archive_read_new(void);\n  385  \n  386  /*\n  ...\n  393  \n  394  #if ARCHIVE_VERSION_NUMBER < 4000000\n  395: __LA_DECL int archive_read_support_compression_all(struct archive *)\n  396  \t\t__LA_DEPRECATED;\n  397: __LA_DECL int archive_read_support_compression_bzip2(struct archive *)\n  398  \t\t__LA_DEPRECATED;\n  399: __LA_DECL int archive_read_support_compression_compress(struct archive *)\n  400  \t\t__LA_DEPRECATED;\n  401: __LA_DECL int archive_read_support_compression_gzip(struct archive *)\n  402  \t\t__LA_DEPRECATED;\n  403: __LA_DECL int archive_read_support_compression_lzip(struct archive *)\n  404  \t\t__LA_DEPRECATED;\n  405: __LA_DECL int archive_read_support_compression_lzma(struct archive *)\n  406  \t\t__LA_DEPRECATED;\n  407: __LA_DECL int archive_read_support_compression_none(struct archive *)\n  408  \t\t__LA_DEPRECATED;\n  409: __LA_DECL int archive_read_support_compression_program(struct archive *,\n  410  \t\t     const char *command) __LA_DEPRECATED;\n  411  __LA_DECL int archive_read_support_compression_program_signature\n  412: \t\t(struct archive *, const char *,\n  413  \t\t const void * /* match */, size_t) __LA_DEPRECATED;\n  414  \n  415: __LA_DECL int archive_read_support_compression_rpm(struct archive *)\n  416  \t\t__LA_DEPRECATED;\n  417: __LA_DECL int archive_read_support_compression_uu(struct archive *)\n  418  \t\t__LA_DEPRECATED;\n  419: __LA_DECL int archive_read_support_compression_xz(struct archive *)\n  420  \t\t__LA_DEPRECATED;\n  421  #endif\n  422  \n  423: __LA_DECL int archive_read_support_filter_all(struct archive *);\n  424: __LA_DECL int archive_read_support_filter_by_code(struct archive *, int);\n  425: __LA_DECL int archive_read_support_filter_bzip2(struct archive *);\n  426: __LA_DECL int archive_read_support_filter_compress(struct archive *);\n  427: __LA_DECL int archive_read_support_filter_gzip(struct archive *);\n  428: __LA_DECL int archive_read_support_filter_grzip(struct archive *);\n  429: __LA_DECL int archive_read_support_filter_lrzip(struct archive *);\n  430: __LA_DECL int archive_read_support_filter_lz4(struct archive *);\n  431: __LA_DECL int archive_read_support_filter_lzip(struct archive *);\n  432: __LA_DECL int archive_read_support_filter_lzma(struct archive *);\n  433: __LA_DECL int archive_read_support_filter_lzop(struct archive *);\n  434: __LA_DECL int archive_read_support_filter_none(struct archive *);\n  435: __LA_DECL int archive_read_support_filter_program(struct archive *,\n  436  \t\t     const char *command);\n  437  __LA_DECL int archive_read_support_filter_program_signature\n  438: \t\t(struct archive *, const char * /* cmd */,\n  439  \t\t\t\t    const void * /* match */, size_t);\n  440: __LA_DECL int archive_read_support_filter_rpm(struct archive *);\n  441: __LA_DECL int archive_read_support_filter_uu(struct archive *);\n  442: __LA_DECL int archive_read_support_filter_xz(struct archive *);\n  443: __LA_DECL int archive_read_support_filter_zstd(struct archive *);\n  444  \n  445: __LA_DECL int archive_read_support_format_7zip(struct archive *);\n  446: __LA_DECL int archive_read_support_format_all(struct archive *);\n  447: __LA_DECL int archive_read_support_format_ar(struct archive *);\n  448: __LA_DECL int archive_read_support_format_by_code(struct archive *, int);\n  449: __LA_DECL int archive_read_support_format_cab(struct archive *);\n  450: __LA_DECL int archive_read_support_format_cpio(struct archive *);\n  451: __LA_DECL int archive_read_support_format_empty(struct archive *);\n  452: __LA_DECL int archive_read_support_format_gnutar(struct archive *);\n  453: __LA_DECL int archive_read_support_format_iso9660(struct archive *);\n  454: __LA_DECL int archive_read_support_format_lha(struct archive *);\n  455: __LA_DECL int archive_read_support_format_mtree(struct archive *);\n  456: __LA_DECL int archive_read_support_format_rar(struct archive *);\n  457: __LA_DECL int archive_read_support_format_rar5(struct archive *);\n  458: __LA_DECL int archive_read_support_format_raw(struct archive *);\n  459: __LA_DECL int archive_read_support_format_tar(struct archive *);\n  460: __LA_DECL int archive_read_support_format_warc(struct archive *);\n  461: __LA_DECL int archive_read_support_format_xar(struct archive *);\n  462  /* archive_read_support_format_zip() enables both streamable and seekable\n  463   * zip readers. */\n  464: __LA_DECL int archive_read_support_format_zip(struct archive *);\n  465  /* Reads Zip archives as stream from beginning to end.  Doesn't\n  466   * correctly handle SFX ZIP files or ZIP archives that have been modified\n  467   * in-place. */\n  468: __LA_DECL int archive_read_support_format_zip_streamable(struct archive *);\n  469  /* Reads starting from central directory; requires seekable input. */\n  470: __LA_DECL int archive_read_support_format_zip_seekable(struct archive *);\n  471  \n  472  /* Functions to manually set the format and filters to be used. This is\n  ...\n  474   * is known in advance.\n  475   */\n  476: __LA_DECL int archive_read_set_format(struct archive *, int);\n  477: __LA_DECL int archive_read_append_filter(struct archive *, int);\n  478: __LA_DECL int archive_read_append_filter_program(struct archive *,\n  479      const char *);\n  480  __LA_DECL int archive_read_append_filter_program_signature\n  481:     (struct archive *, const char *, const void * /* match */, size_t);\n  482  \n  483  /* Set various callbacks. */\n  484: __LA_DECL int archive_read_set_open_callback(struct archive *,\n  485      archive_open_callback *);\n  486: __LA_DECL int archive_read_set_read_callback(struct archive *,\n  487      archive_read_callback *);\n  488: __LA_DECL int archive_read_set_seek_callback(struct archive *,\n  489      archive_seek_callback *);\n  490: __LA_DECL int archive_read_set_skip_callback(struct archive *,\n  491      archive_skip_callback *);\n  492: __LA_DECL int archive_read_set_close_callback(struct archive *,\n  493      archive_close_callback *);\n  494  /* Callback used to switch between one data object to the next */\n  495: __LA_DECL int archive_read_set_switch_callback(struct archive *,\n  496      archive_switch_callback *);\n  497  \n  498  /* This sets the first data object. */\n  499: __LA_DECL int archive_read_set_callback_data(struct archive *, void *);\n  500  /* This sets data object at specified index */\n  501: __LA_DECL int archive_read_set_callback_data2(struct archive *, void *,\n  502      unsigned int);\n  503  /* This adds a data object at the specified index. */\n  504: __LA_DECL int archive_read_add_callback_data(struct archive *, void *,\n  505      unsigned int);\n  506  /* This appends a data object to the end of list */\n  507: __LA_DECL int archive_read_append_callback_data(struct archive *, void *);\n  508  /* This prepends a data object to the beginning of list */\n  509: __LA_DECL int archive_read_prepend_callback_data(struct archive *, void *);\n  510  \n  511  /* Opening freezes the callbacks. */\n  512: __LA_DECL int archive_read_open1(struct archive *);\n  513  \n  514  /* Convenience wrappers around the above. */\n  515: __LA_DECL int archive_read_open(struct archive *, void *_client_data,\n  516  \t\t     archive_open_callback *, archive_read_callback *,\n  517  \t\t     archive_close_callback *);\n  518: __LA_DECL int archive_read_open2(struct archive *, void *_client_data,\n  519  \t\t     archive_open_callback *, archive_read_callback *,\n  520  \t\t     archive_skip_callback *, archive_close_callback *);\n  ...\n  526   */\n  527  /* Use this if you know the filename.  Note: NULL indicates stdin. */\n  528: __LA_DECL int archive_read_open_filename(struct archive *,\n  529  \t\t     const char *_filename, size_t _block_size);\n  530  /* Use this for reading multivolume files by filenames.\n  531   * NOTE: Must be NULL terminated. Sorting is NOT done. */\n  532: __LA_DECL int archive_read_open_filenames(struct archive *,\n  533  \t\t     const char **_filenames, size_t _block_size);\n  534: __LA_DECL int archive_read_open_filename_w(struct archive *,\n  535  \t\t     const wchar_t *_filename, size_t _block_size);\n  536  /* archive_read_open_file() is a deprecated synonym for ..._open_filename(). */\n  537: __LA_DECL int archive_read_open_file(struct archive *,\n  538  \t\t     const char *_filename, size_t _block_size) __LA_DEPRECATED;\n  539  /* Read an archive that's stored in memory. */\n  540: __LA_DECL int archive_read_open_memory(struct archive *,\n  541  \t\t     const void * buff, size_t size);\n  542  /* A more involved version that is only used for internal testing. */\n  543: __LA_DECL int archive_read_open_memory2(struct archive *a, const void *buff,\n  544  \t\t     size_t size, size_t read_size);\n  545  /* Read an archive that's already open, using the file descriptor. */\n  546: __LA_DECL int archive_read_open_fd(struct archive *, int _fd,\n  547  \t\t     size_t _block_size);\n  548  /* Read an archive that's already open, using a FILE *. */\n  549  /* Note: DO NOT use this with tape drives. */\n  550: __LA_DECL int archive_read_open_FILE(struct archive *, FILE *_file);\n  551  \n  552  /* Parses and returns next entry header. */\n  553: __LA_DECL int archive_read_next_header(struct archive *,\n  554: \t\t     struct archive_entry **);\n  555  \n  556  /* Parses and returns next entry header using the archive_entry passed in */\n  557: __LA_DECL int archive_read_next_header2(struct archive *,\n  558: \t\t     struct archive_entry *);\n  559  \n  560  /*\n  ...\n  562   * header started.\n  563   */\n  564: __LA_DECL la_int64_t\t\t archive_read_header_position(struct archive *);\n  565  \n  566  /*\n  ...\n  582   * just shows that there are some.\n  583   */\n  584: __LA_DECL int\tarchive_read_has_encrypted_entries(struct archive *);\n  585  \n  586  /*\n  ...\n  588   * If the reader has no special capabilities, ARCHIVE_READ_FORMAT_CAPS_NONE is returned.\n  589   */\n  590: __LA_DECL int\t\t archive_read_format_capabilities(struct archive *);\n  591  \n  592  /* Read data from the body of an entry.  Similar to read(2). */\n  593: __LA_DECL la_ssize_t\t\t archive_read_data(struct archive *,\n  594  \t\t\t\t    void *, size_t);\n  595  \n  596  /* Seek within the body of an entry.  Similar to lseek(2). */\n  597: __LA_DECL la_int64_t archive_seek_data(struct archive *, la_int64_t, int);\n  598  \n  599  /*\n  ...\n  603   * be strictly increasing and that returned blocks will not overlap.\n  604   */\n  605: __LA_DECL int archive_read_data_block(struct archive *a,\n  606  \t\t    const void **buff, size_t *size, la_int64_t *offset);\n  607  \n  ...\n  612   *  'into_fd': writes data to specified filedes\n  613   */\n  614: __LA_DECL int archive_read_data_skip(struct archive *);\n  615: __LA_DECL int archive_read_data_into_fd(struct archive *, int fd);\n  616  \n  617  /*\n  ...\n  619   */\n  620  /* Apply option to the format only. */\n  621: __LA_DECL int archive_read_set_format_option(struct archive *_a,\n  622  \t\t\t    const char *m, const char *o,\n  623  \t\t\t    const char *v);\n  624  /* Apply option to the filter only. */\n  625: __LA_DECL int archive_read_set_filter_option(struct archive *_a,\n  626  \t\t\t    const char *m, const char *o,\n  627  \t\t\t    const char *v);\n  628  /* Apply option to both the format and the filter. */\n  629: __LA_DECL int archive_read_set_option(struct archive *_a,\n  630  \t\t\t    const char *m, const char *o,\n  631  \t\t\t    const char *v);\n  632  /* Apply option string to both the format and the filter. */\n  633: __LA_DECL int archive_read_set_options(struct archive *_a,\n  634  \t\t\t    const char *opts);\n  635  \n  ...\n  637   * Add a decryption passphrase.\n  638   */\n  639: __LA_DECL int archive_read_add_passphrase(struct archive *, const char *);\n  640: __LA_DECL int archive_read_set_passphrase_callback(struct archive *,\n  641  \t\t\t    void *client_data, archive_passphrase_callback *);\n  642  \n  ...\n  701  #define\tARCHIVE_EXTRACT_SAFE_WRITES\t\t(0x40000)\n  702  \n  703: __LA_DECL int archive_read_extract(struct archive *, struct archive_entry *,\n  704  \t\t     int flags);\n  705: __LA_DECL int archive_read_extract2(struct archive *, struct archive_entry *,\n  706: \t\t     struct archive * /* dest */);\n  707: __LA_DECL void\t archive_read_extract_set_progress_callback(struct archive *,\n  708  \t\t     void (*_progress_func)(void *), void *_user_data);\n  709  \n  710  /* Record the dev/ino of a file that will not be written.  This is\n  711   * generally set to the dev/ino of the archive being read. */\n  712: __LA_DECL void\t\tarchive_read_extract_set_skip_file(struct archive *,\n  713  \t\t     la_int64_t, la_int64_t);\n  714  \n  715  /* Close the file and release most resources. */\n  716: __LA_DECL int\t\t archive_read_close(struct archive *);\n  717  /* Release all resources and destroy the object. */\n  718  /* Note that archive_read_free will call archive_read_close for you. */\n  719: __LA_DECL int\t\t archive_read_free(struct archive *);\n  720  #if ARCHIVE_VERSION_NUMBER < 4000000\n  721  /* Synonym for archive_read_free() for backwards compatibility. */\n  722: __LA_DECL int\t\t archive_read_finish(struct archive *) __LA_DEPRECATED;\n  723  #endif\n  724  \n  ...\n  732   *       which provide convenient canned I/O callbacks for you).\n  733   *   4) For each entry:\n  734:  *      - construct an appropriate struct archive_entry structure\n  735   *      - archive_write_header to write the header\n  736   *      - archive_write_data to write the entry data\n  ...\n  738   *   6) archive_write_free to cleanup the writer and release resources\n  739   */\n  740: __LA_DECL struct archive\t*archive_write_new(void);\n  741: __LA_DECL int archive_write_set_bytes_per_block(struct archive *,\n  742  \t\t     int bytes_per_block);\n  743: __LA_DECL int archive_write_get_bytes_per_block(struct archive *);\n  744  /* XXX This is badly misnamed; suggestions appreciated. XXX */\n  745: __LA_DECL int archive_write_set_bytes_in_last_block(struct archive *,\n  746  \t\t     int bytes_in_last_block);\n  747: __LA_DECL int archive_write_get_bytes_in_last_block(struct archive *);\n  748  \n  749  /* The dev/ino of a file that won't be archived.  This is used\n  750   * to avoid recursively adding an archive to itself. */\n  751: __LA_DECL int archive_write_set_skip_file(struct archive *,\n  752      la_int64_t, la_int64_t);\n  753  \n  754  #if ARCHIVE_VERSION_NUMBER < 4000000\n  755: __LA_DECL int archive_write_set_compression_bzip2(struct archive *)\n  756  \t\t__LA_DEPRECATED;\n  757: __LA_DECL int archive_write_set_compression_compress(struct archive *)\n  758  \t\t__LA_DEPRECATED;\n  759: __LA_DECL int archive_write_set_compression_gzip(struct archive *)\n  760  \t\t__LA_DEPRECATED;\n  761: __LA_DECL int archive_write_set_compression_lzip(struct archive *)\n  762  \t\t__LA_DEPRECATED;\n  763: __LA_DECL int archive_write_set_compression_lzma(struct archive *)\n  764  \t\t__LA_DEPRECATED;\n  765: __LA_DECL int archive_write_set_compression_none(struct archive *)\n  766  \t\t__LA_DEPRECATED;\n  767: __LA_DECL int archive_write_set_compression_program(struct archive *,\n  768  \t\t     const char *cmd) __LA_DEPRECATED;\n  769: __LA_DECL int archive_write_set_compression_xz(struct archive *)\n  770  \t\t__LA_DEPRECATED;\n  771  #endif\n  772  \n  773  /* A convenience function to set the filter based on the code. */\n  774: __LA_DECL int archive_write_add_filter(struct archive *, int filter_code);\n  775: __LA_DECL int archive_write_add_filter_by_name(struct archive *,\n  776  \t\t     const char *name);\n  777: __LA_DECL int archive_write_add_filter_b64encode(struct archive *);\n  778: __LA_DECL int archive_write_add_filter_bzip2(struct archive *);\n  779: __LA_DECL int archive_write_add_filter_compress(struct archive *);\n  780: __LA_DECL int archive_write_add_filter_grzip(struct archive *);\n  781: __LA_DECL int archive_write_add_filter_gzip(struct archive *);\n  782: __LA_DECL int archive_write_add_filter_lrzip(struct archive *);\n  783: __LA_DECL int archive_write_add_filter_lz4(struct archive *);\n  784: __LA_DECL int archive_write_add_filter_lzip(struct archive *);\n  785: __LA_DECL int archive_write_add_filter_lzma(struct archive *);\n  786: __LA_DECL int archive_write_add_filter_lzop(struct archive *);\n  787: __LA_DECL int archive_write_add_filter_none(struct archive *);\n  788: __LA_DECL int archive_write_add_filter_program(struct archive *,\n  789  \t\t     const char *cmd);\n  790: __LA_DECL int archive_write_add_filter_uuencode(struct archive *);\n  791: __LA_DECL int archive_write_add_filter_xz(struct archive *);\n  792: __LA_DECL int archive_write_add_filter_zstd(struct archive *);\n  793  \n  794  \n  795  /* A convenience function to set the format based on the code or name. */\n  796: __LA_DECL int archive_write_set_format(struct archive *, int format_code);\n  797: __LA_DECL int archive_write_set_format_by_name(struct archive *,\n  798  \t\t     const char *name);\n  799  /* To minimize link pollution, use one or more of the following. */\n  800: __LA_DECL int archive_write_set_format_7zip(struct archive *);\n  801: __LA_DECL int archive_write_set_format_ar_bsd(struct archive *);\n  802: __LA_DECL int archive_write_set_format_ar_svr4(struct archive *);\n  803: __LA_DECL int archive_write_set_format_cpio(struct archive *);\n  804: __LA_DECL int archive_write_set_format_cpio_bin(struct archive *);\n  805: __LA_DECL int archive_write_set_format_cpio_newc(struct archive *);\n  806: __LA_DECL int archive_write_set_format_cpio_odc(struct archive *);\n  807: __LA_DECL int archive_write_set_format_cpio_pwb(struct archive *);\n  808: __LA_DECL int archive_write_set_format_gnutar(struct archive *);\n  809: __LA_DECL int archive_write_set_format_iso9660(struct archive *);\n  810: __LA_DECL int archive_write_set_format_mtree(struct archive *);\n  811: __LA_DECL int archive_write_set_format_mtree_classic(struct archive *);\n  812: /* TODO: int archive_write_set_format_old_tar(struct archive *); */\n  813: __LA_DECL int archive_write_set_format_pax(struct archive *);\n  814: __LA_DECL int archive_write_set_format_pax_restricted(struct archive *);\n  815: __LA_DECL int archive_write_set_format_raw(struct archive *);\n  816: __LA_DECL int archive_write_set_format_shar(struct archive *);\n  817: __LA_DECL int archive_write_set_format_shar_dump(struct archive *);\n  818: __LA_DECL int archive_write_set_format_ustar(struct archive *);\n  819: __LA_DECL int archive_write_set_format_v7tar(struct archive *);\n  820: __LA_DECL int archive_write_set_format_warc(struct archive *);\n  821: __LA_DECL int archive_write_set_format_xar(struct archive *);\n  822: __LA_DECL int archive_write_set_format_zip(struct archive *);\n  823: __LA_DECL int archive_write_set_format_filter_by_ext(struct archive *a, const char *filename);\n  824: __LA_DECL int archive_write_set_format_filter_by_ext_def(struct archive *a, const char *filename, const char * def_ext);\n  825: __LA_DECL int archive_write_zip_set_compression_deflate(struct archive *);\n  826: __LA_DECL int archive_write_zip_set_compression_store(struct archive *);\n  827  /* Deprecated; use archive_write_open2 instead */\n  828: __LA_DECL int archive_write_open(struct archive *, void *,\n  829  \t\t     archive_open_callback *, archive_write_callback *,\n  830  \t\t     archive_close_callback *);\n  831: __LA_DECL int archive_write_open2(struct archive *, void *,\n  832  \t\t     archive_open_callback *, archive_write_callback *,\n  833  \t\t     archive_close_callback *, archive_free_callback *);\n  834: __LA_DECL int archive_write_open_fd(struct archive *, int _fd);\n  835: __LA_DECL int archive_write_open_filename(struct archive *, const char *_file);\n  836: __LA_DECL int archive_write_open_filename_w(struct archive *,\n  837  \t\t     const wchar_t *_file);\n  838  /* A deprecated synonym for archive_write_open_filename() */\n  839: __LA_DECL int archive_write_open_file(struct archive *, const char *_file)\n  840  \t\t__LA_DEPRECATED;\n  841: __LA_DECL int archive_write_open_FILE(struct archive *, FILE *);\n  842  /* _buffSize is the size of the buffer, _used refers to a variable that\n  843   * will be updated after each write into the buffer. */\n  844: __LA_DECL int archive_write_open_memory(struct archive *,\n  845  \t\t\tvoid *_buffer, size_t _buffSize, size_t *_used);\n  846  \n  ...\n  849   * to archive_write_header or pad if the provided data is short.\n  850   */\n  851: __LA_DECL int archive_write_header(struct archive *,\n  852: \t\t     struct archive_entry *);\n  853: __LA_DECL la_ssize_t\tarchive_write_data(struct archive *,\n  854  \t\t\t    const void *, size_t);\n  855  \n  856  /* This interface is currently only available for archive_write_disk handles.  */\n  857: __LA_DECL la_ssize_t\t archive_write_data_block(struct archive *,\n  858  \t\t\t\t    const void *, size_t, la_int64_t);\n  859  \n  860: __LA_DECL int\t\t archive_write_finish_entry(struct archive *);\n  861: __LA_DECL int\t\t archive_write_close(struct archive *);\n  862  /* Marks the archive as FATAL so that a subsequent free() operation\n  863   * won't try to close() cleanly.  Provides a fast abort capability\n  864   * when the client discovers that things have gone wrong. */\n  865: __LA_DECL int            archive_write_fail(struct archive *);\n  866  /* This can fail if the archive wasn't already closed, in which case\n  867   * archive_write_free() will implicitly call archive_write_close(). */\n  868: __LA_DECL int\t\t archive_write_free(struct archive *);\n  869  #if ARCHIVE_VERSION_NUMBER < 4000000\n  870  /* Synonym for archive_write_free() for backwards compatibility. */\n  871: __LA_DECL int\t\t archive_write_finish(struct archive *) __LA_DEPRECATED;\n  872  #endif\n  873  \n  ...\n  876   */\n  877  /* Apply option to the format only. */\n  878: __LA_DECL int archive_write_set_format_option(struct archive *_a,\n  879  \t\t\t    const char *m, const char *o,\n  880  \t\t\t    const char *v);\n  881  /* Apply option to the filter only. */\n  882: __LA_DECL int archive_write_set_filter_option(struct archive *_a,\n  883  \t\t\t    const char *m, const char *o,\n  884  \t\t\t    const char *v);\n  885  /* Apply option to both the format and the filter. */\n  886: __LA_DECL int archive_write_set_option(struct archive *_a,\n  887  \t\t\t    const char *m, const char *o,\n  888  \t\t\t    const char *v);\n  889  /* Apply option string to both the format and the filter. */\n  890: __LA_DECL int archive_write_set_options(struct archive *_a,\n  891  \t\t\t    const char *opts);\n  892  \n  ...\n  894   * Set a encryption passphrase.\n  895   */\n  896: __LA_DECL int archive_write_set_passphrase(struct archive *_a, const char *p);\n  897: __LA_DECL int archive_write_set_passphrase_callback(struct archive *,\n  898  \t\t\t    void *client_data, archive_passphrase_callback *);\n  899  \n  ...\n  906   *      want to set the options.\n  907   *   3) For each entry:\n  908:  *      - construct an appropriate struct archive_entry structure\n  909   *      - archive_write_header to create the file/dir/etc on disk\n  910   *      - archive_write_data to write the entry data\n  ...\n  914   * to pull entries out of an archive and create them on disk.\n  915   */\n  916: __LA_DECL struct archive\t*archive_write_disk_new(void);\n  917  /* This file will not be overwritten. */\n  918: __LA_DECL int archive_write_disk_set_skip_file(struct archive *,\n  919      la_int64_t, la_int64_t);\n  920  /* Set flags to control how the next item gets created.\n  921   * This accepts a bitmask of ARCHIVE_EXTRACT_XXX flags defined above. */\n  922: __LA_DECL int\t\t archive_write_disk_set_options(struct archive *,\n  923  \t\t     int flags);\n  924  /*\n  ...\n  939   * POSIX \"tar\".\n  940   */\n  941: __LA_DECL int\t archive_write_disk_set_standard_lookup(struct archive *);\n  942  /*\n  943   * If neither the default (naive) nor the standard (big) functions suit\n  ...\n  945   * include a cleanup function if you have allocated private data.\n  946   */\n  947: __LA_DECL int archive_write_disk_set_group_lookup(struct archive *,\n  948      void * /* private_data */,\n  949      la_int64_t (*)(void *, const char *, la_int64_t),\n  950      void (* /* cleanup */)(void *));\n  951: __LA_DECL int archive_write_disk_set_user_lookup(struct archive *,\n  952      void * /* private_data */,\n  953      la_int64_t (*)(void *, const char *, la_int64_t),\n  954      void (* /* cleanup */)(void *));\n  955: __LA_DECL la_int64_t archive_write_disk_gid(struct archive *, const char *, la_int64_t);\n  956: __LA_DECL la_int64_t archive_write_disk_uid(struct archive *, const char *, la_int64_t);\n  957  \n  958  /*\n  ...\n  961   * This is still evolving and somewhat experimental.\n  962   */\n  963: __LA_DECL struct archive *archive_read_disk_new(void);\n  964  /* The names for symlink modes here correspond to an old BSD\n  965   * command-line argument convention: -L, -P, -H */\n  966  /* Follow all symlinks. */\n  967: __LA_DECL int archive_read_disk_set_symlink_logical(struct archive *);\n  968  /* Follow no symlinks. */\n  969: __LA_DECL int archive_read_disk_set_symlink_physical(struct archive *);\n  970  /* Follow symlink initially, then not. */\n  971: __LA_DECL int archive_read_disk_set_symlink_hybrid(struct archive *);\n  972  /* TODO: Handle Linux stat32/stat64 ugliness. <sigh> */\n  973: __LA_DECL int archive_read_disk_entry_from_file(struct archive *,\n  974:     struct archive_entry *, int /* fd */, const struct stat *);\n  975  /* Look up gname for gid or uname for uid. */\n  976  /* Default implementations are very, very stupid. */\n  977: __LA_DECL const char *archive_read_disk_gname(struct archive *, la_int64_t);\n  978: __LA_DECL const char *archive_read_disk_uname(struct archive *, la_int64_t);\n  979  /* \"Standard\" implementation uses getpwuid_r, getgrgid_r and caches the\n  980   * results for performance. */\n  981: __LA_DECL int\tarchive_read_disk_set_standard_lookup(struct archive *);\n  982  /* You can install your own lookups if you like. */\n  983: __LA_DECL int\tarchive_read_disk_set_gname_lookup(struct archive *,\n  984      void * /* private_data */,\n  985      const char *(* /* lookup_fn */)(void *, la_int64_t),\n  986      void (* /* cleanup_fn */)(void *));\n  987: __LA_DECL int\tarchive_read_disk_set_uname_lookup(struct archive *,\n  988      void * /* private_data */,\n  989      const char *(* /* lookup_fn */)(void *, la_int64_t),\n  990      void (* /* cleanup_fn */)(void *));\n  991  /* Start traversal. */\n  992: __LA_DECL int\tarchive_read_disk_open(struct archive *, const char *);\n  993: __LA_DECL int\tarchive_read_disk_open_w(struct archive *, const wchar_t *);\n  994  /*\n  995   * Request that current entry be visited.  If you invoke it on every\n  ...\n  999   * traversal.\n 1000   */\n 1001: __LA_DECL int\tarchive_read_disk_descend(struct archive *);\n 1002: __LA_DECL int\tarchive_read_disk_can_descend(struct archive *);\n 1003: __LA_DECL int\tarchive_read_disk_current_filesystem(struct archive *);\n 1004: __LA_DECL int\tarchive_read_disk_current_filesystem_is_synthetic(struct archive *);\n 1005: __LA_DECL int\tarchive_read_disk_current_filesystem_is_remote(struct archive *);\n 1006  /* Request that the access time of the entry visited by traversal be restored. */\n 1007: __LA_DECL int  archive_read_disk_set_atime_restored(struct archive *);\n 1008  /*\n 1009   * Set behavior. The \"flags\" argument selects optional behavior.\n ....\n 1026  #define\tARCHIVE_READDISK_NO_FFLAGS\t\t(0x0040)\n 1027  \n 1028: __LA_DECL int  archive_read_disk_set_behavior(struct archive *,\n 1029  \t\t    int flags);\n 1030  \n ....\n 1035   * of archive_match.\n 1036   */\n 1037: __LA_DECL int\tarchive_read_disk_set_matching(struct archive *,\n 1038: \t\t    struct archive *_matching, void (*_excluded_func)\n 1039: \t\t    (struct archive *, void *, struct archive_entry *),\n 1040  \t\t    void *_client_data);\n 1041: __LA_DECL int\tarchive_read_disk_set_metadata_filter_callback(struct archive *,\n 1042: \t\t    int (*_metadata_filter_func)(struct archive *, void *,\n 1043: \t\t    \tstruct archive_entry *), void *_client_data);\n 1044  \n 1045  /* Simplified cleanup interface;\n 1046   * This calls archive_read_free() or archive_write_free() as needed. */\n 1047: __LA_DECL int\tarchive_free(struct archive *);\n 1048  \n 1049  /*\n 1050   * Accessor functions to read/set various information in\n 1051:  * the struct archive object:\n 1052   */\n 1053  \n ....\n 1056   * last filter, which is always the pseudo-filter that wraps the\n 1057   * client callbacks. */\n 1058: __LA_DECL int\t\t archive_filter_count(struct archive *);\n 1059: __LA_DECL la_int64_t\t archive_filter_bytes(struct archive *, int);\n 1060: __LA_DECL int\t\t archive_filter_code(struct archive *, int);\n 1061: __LA_DECL const char *\t archive_filter_name(struct archive *, int);\n 1062  \n 1063  #if ARCHIVE_VERSION_NUMBER < 4000000\n ....\n 1065   * will eventually be removed. */\n 1066  /* As of libarchive 3.0, this is an alias for archive_filter_bytes(a, -1); */\n 1067: __LA_DECL la_int64_t\t archive_position_compressed(struct archive *)\n 1068  \t\t\t\t__LA_DEPRECATED;\n 1069  /* As of libarchive 3.0, this is an alias for archive_filter_bytes(a, 0); */\n 1070: __LA_DECL la_int64_t\t archive_position_uncompressed(struct archive *)\n 1071  \t\t\t\t__LA_DEPRECATED;\n 1072  /* As of libarchive 3.0, this is an alias for archive_filter_name(a, 0); */\n 1073: __LA_DECL const char\t*archive_compression_name(struct archive *)\n 1074  \t\t\t\t__LA_DEPRECATED;\n 1075  /* As of libarchive 3.0, this is an alias for archive_filter_code(a, 0); */\n 1076: __LA_DECL int\t\t archive_compression(struct archive *)\n 1077  \t\t\t\t__LA_DEPRECATED;\n 1078  #endif\n 1079  \n 1080: __LA_DECL int\t\t archive_errno(struct archive *);\n 1081: __LA_DECL const char\t*archive_error_string(struct archive *);\n 1082: __LA_DECL const char\t*archive_format_name(struct archive *);\n 1083: __LA_DECL int\t\t archive_format(struct archive *);\n 1084: __LA_DECL void\t\t archive_clear_error(struct archive *);\n 1085: __LA_DECL void\t\t archive_set_error(struct archive *, int _err,\n 1086  \t\t\t    const char *fmt, ...) __LA_PRINTF(3, 4);\n 1087: __LA_DECL void\t\t archive_copy_error(struct archive *dest,\n 1088: \t\t\t    struct archive *src);\n 1089: __LA_DECL int\t\t archive_file_count(struct archive *);\n 1090  \n 1091  /*\n 1092   * ARCHIVE_MATCH API\n 1093   */\n 1094: __LA_DECL struct archive *archive_match_new(void);\n 1095: __LA_DECL int\tarchive_match_free(struct archive *);\n 1096  \n 1097  /*\n ....\n 1101   * and archive_match_owner_excluded.\n 1102   */\n 1103: __LA_DECL int\tarchive_match_excluded(struct archive *,\n 1104: \t\t    struct archive_entry *);\n 1105  \n 1106  /*\n 1107   * Test if pathname is excluded. The conditions are set by following functions.\n 1108   */\n 1109: __LA_DECL int\tarchive_match_path_excluded(struct archive *,\n 1110: \t\t    struct archive_entry *);\n 1111  /* Control recursive inclusion of directory content when directory is included. Default on. */\n 1112: __LA_DECL int\tarchive_match_set_inclusion_recursion(struct archive *, int);\n 1113  /* Add exclusion pathname pattern. */\n 1114: __LA_DECL int\tarchive_match_exclude_pattern(struct archive *, const char *);\n 1115: __LA_DECL int\tarchive_match_exclude_pattern_w(struct archive *,\n 1116  \t\t    const wchar_t *);\n 1117  /* Add exclusion pathname pattern from file. */\n 1118: __LA_DECL int\tarchive_match_exclude_pattern_from_file(struct archive *,\n 1119  \t\t    const char *, int _nullSeparator);\n 1120: __LA_DECL int\tarchive_match_exclude_pattern_from_file_w(struct archive *,\n 1121  \t\t    const wchar_t *, int _nullSeparator);\n 1122  /* Add inclusion pathname pattern. */\n 1123: __LA_DECL int\tarchive_match_include_pattern(struct archive *, const char *);\n 1124: __LA_DECL int\tarchive_match_include_pattern_w(struct archive *,\n 1125  \t\t    const wchar_t *);\n 1126  /* Add inclusion pathname pattern from file. */\n 1127: __LA_DECL int\tarchive_match_include_pattern_from_file(struct archive *,\n 1128  \t\t    const char *, int _nullSeparator);\n 1129: __LA_DECL int\tarchive_match_include_pattern_from_file_w(struct archive *,\n 1130  \t\t    const wchar_t *, int _nullSeparator);\n 1131  /*\n ....\n 1133   */\n 1134  /* Return the amount number of unmatched inclusion patterns. */\n 1135: __LA_DECL int\tarchive_match_path_unmatched_inclusions(struct archive *);\n 1136  /* Return the pattern of unmatched inclusion with ARCHIVE_OK.\n 1137   * Return ARCHIVE_EOF if there is no inclusion pattern. */\n 1138  __LA_DECL int\tarchive_match_path_unmatched_inclusions_next(\n 1139: \t\t    struct archive *, const char **);\n 1140  __LA_DECL int\tarchive_match_path_unmatched_inclusions_next_w(\n 1141: \t\t    struct archive *, const wchar_t **);\n 1142  \n 1143  /*\n ....\n 1145   * The conditions are set by following functions.\n 1146   */\n 1147: __LA_DECL int\tarchive_match_time_excluded(struct archive *,\n 1148: \t\t    struct archive_entry *);\n 1149  \n 1150  /*\n ....\n 1163  #define ARCHIVE_MATCH_EQUAL\t(0x0010)\n 1164  /* Set inclusion time. */\n 1165: __LA_DECL int\tarchive_match_include_time(struct archive *, int _flag,\n 1166  \t\t    time_t _sec, long _nsec);\n 1167  /* Set inclusion time by a date string. */\n 1168: __LA_DECL int\tarchive_match_include_date(struct archive *, int _flag,\n 1169  \t\t    const char *_datestr);\n 1170: __LA_DECL int\tarchive_match_include_date_w(struct archive *, int _flag,\n 1171  \t\t    const wchar_t *_datestr);\n 1172  /* Set inclusion time by a particular file. */\n 1173: __LA_DECL int\tarchive_match_include_file_time(struct archive *,\n 1174  \t\t    int _flag, const char *_pathname);\n 1175: __LA_DECL int\tarchive_match_include_file_time_w(struct archive *,\n 1176  \t\t    int _flag, const wchar_t *_pathname);\n 1177  /* Add exclusion entry. */\n 1178: __LA_DECL int\tarchive_match_exclude_entry(struct archive *,\n 1179: \t\t    int _flag, struct archive_entry *);\n 1180  \n 1181  /*\n ....\n 1183   * The conditions are set by following functions.\n 1184   */\n 1185: __LA_DECL int\tarchive_match_owner_excluded(struct archive *,\n 1186: \t\t    struct archive_entry *);\n 1187  /* Add inclusion uid, gid, uname and gname. */\n 1188: __LA_DECL int\tarchive_match_include_uid(struct archive *, la_int64_t);\n 1189: __LA_DECL int\tarchive_match_include_gid(struct archive *, la_int64_t);\n 1190: __LA_DECL int\tarchive_match_include_uname(struct archive *, const char *);\n 1191: __LA_DECL int\tarchive_match_include_uname_w(struct archive *,\n 1192  \t\t    const wchar_t *);\n 1193: __LA_DECL int\tarchive_match_include_gname(struct archive *, const char *);\n 1194: __LA_DECL int\tarchive_match_include_gname_w(struct archive *,\n 1195  \t\t    const wchar_t *);\n 1196  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write_set_format_zip.c:\n  109  #define MAX_DERIVED_KEY_BUF_SIZE (AES_MAX_KEY_SIZE * 2 + 2)\n  110  \n  111: struct cd_segment {\n  112: \tstruct cd_segment *next;\n  113  \tsize_t buff_size;\n  114  \tunsigned char *buff;\n  ...\n  116  };\n  117  \n  118: struct trad_enc_ctx {\n  119  \tuint32_t keys[3];\n  120  };\n  121  \n  122: struct zip {\n  123  \n  124  \tint64_t entry_offset;\n  ...\n  128  \tint64_t entry_uncompressed_written;\n  129  \tint64_t entry_uncompressed_limit;\n  130: \tstruct archive_entry *entry;\n  131  \tuint32_t entry_crc32;\n  132  \tenum compression entry_compression;\n  ...\n  135  \tint entry_uses_zip64;\n  136  \tint experiments;\n  137: \tstruct trad_enc_ctx tctx;\n  138  \tchar tctx_valid;\n  139  \tunsigned char trad_chkdat;\n  ...\n  148  \tunsigned long (*crc32func)(unsigned long crc, const void *buff, size_t len);\n  149  \n  150: \tstruct cd_segment *central_directory;\n  151: \tstruct cd_segment *central_directory_last;\n  152  \tsize_t central_directory_bytes;\n  153  \tsize_t central_directory_entries;\n  ...\n  155  \tint64_t written_bytes; /* Overall position in file. */\n  156  \n  157: \tstruct archive_string_conv *opt_sconv;\n  158: \tstruct archive_string_conv *sconv_default;\n  159  \tenum compression requested_compression;\n  160  \tint deflate_compression_level;\n  ...\n  178  #define zipmin(a, b) ((a) > (b) ? (b) : (a))\n  179  \n  180: static ssize_t archive_write_zip_data(struct archive_write *,\n  181  \t\t   const void *buff, size_t s);\n  182: static int archive_write_zip_close(struct archive_write *);\n  183: static int archive_write_zip_free(struct archive_write *);\n  184: static int archive_write_zip_finish_entry(struct archive_write *);\n  185: static int archive_write_zip_header(struct archive_write *,\n  186: \t      struct archive_entry *);\n  187: static int archive_write_zip_options(struct archive_write *,\n  188  \t      const char *, const char *);\n  189  static unsigned int dos_time(const time_t);\n  190: static size_t path_length(struct archive_entry *);\n  191: static int write_path(struct archive_entry *, struct archive_write *);\n  192: static void copy_path(struct archive_entry *, unsigned char *);\n  193: static struct archive_string_conv *get_sconv(struct archive_write *, struct zip *);\n  194: static int trad_enc_init(struct trad_enc_ctx *, const char *, size_t);\n  195: static unsigned trad_enc_encrypt_update(struct trad_enc_ctx *, const uint8_t *,\n  196      size_t, uint8_t *, size_t);\n  197: static int init_traditional_pkware_encryption(struct archive_write *);\n  198  static int is_traditional_pkware_encryption_supported(void);\n  199: static int init_winzip_aes_encryption(struct archive_write *);\n  200  static int is_winzip_aes_encryption_supported(int encryption);\n  201  \n  202  static unsigned char *\n  203: cd_alloc(struct zip *zip, size_t length)\n  204  {\n  205  \tunsigned char *p;\n  ...\n  208  \t    || (zip->central_directory_last->p + length\n  209  \t\t> zip->central_directory_last->buff + zip->central_directory_last->buff_size)) {\n  210: \t\tstruct cd_segment *segment = calloc(1, sizeof(*segment));\n  211  \t\tif (segment == NULL)\n  212  \t\t\treturn NULL;\n  ...\n  251  \n  252  static int\n  253: archive_write_zip_options(struct archive_write *a, const char *key,\n  254      const char *val)\n  255  {\n  256: \tstruct zip *zip = a->format_data;\n  257  \tint ret = ARCHIVE_FAILED;\n  258  \n  ...\n  397  \n  398  int\n  399: archive_write_zip_set_compression_deflate(struct archive *_a)\n  400  {\n  401: \tstruct archive_write *a = (struct archive_write *)_a;\n  402  \tint ret = ARCHIVE_FAILED;\n  403  \n  ...\n  412  \t} else {\n  413  #ifdef HAVE_ZLIB_H\n  414: \t\tstruct zip *zip = a->format_data;\n  415  \t\tzip->requested_compression = COMPRESSION_DEFLATE;\n  416  \t\tret = ARCHIVE_OK;\n  ...\n  425  \n  426  int\n  427: archive_write_zip_set_compression_store(struct archive *_a)\n  428  {\n  429: \tstruct archive_write *a = (struct archive_write *)_a;\n  430: \tstruct zip *zip = a->format_data;\n  431  \tint ret = ARCHIVE_FAILED;\n  432  \n  ...\n  447  \n  448  int\n  449: archive_write_set_format_zip(struct archive *_a)\n  450  {\n  451: \tstruct archive_write *a = (struct archive_write *)_a;\n  452: \tstruct zip *zip;\n  453  \n  454  \tarchive_check_magic(_a, ARCHIVE_WRITE_MAGIC,\n  ...\n  459  \t\t(a->format_free)(a);\n  460  \n  461: \tzip = (struct zip *) calloc(1, sizeof(*zip));\n  462  \tif (zip == NULL) {\n  463  \t\tarchive_set_error(&a->archive, ENOMEM,\n  ...\n  510  \n  511  static int\n  512: archive_write_zip_header(struct archive_write *a, struct archive_entry *entry)\n  513  {\n  514  \tunsigned char local_header[32];\n  515  \tunsigned char local_extra[144];\n  516: \tstruct zip *zip = a->format_data;\n  517  \tunsigned char *e;\n  518  \tunsigned char *cd_extra;\n  ...\n  520  \tconst char *slink = NULL;\n  521  \tsize_t slink_size = 0;\n  522: \tstruct archive_string_conv *sconv = get_sconv(a, zip);\n  523  \tint ret, ret2 = ARCHIVE_OK;\n  524  \tmode_t type;\n  ...\n 1002  \n 1003  static ssize_t\n 1004: archive_write_zip_data(struct archive_write *a, const void *buff, size_t s)\n 1005  {\n 1006  \tint ret;\n 1007: \tstruct zip *zip = a->format_data;\n 1008  \n 1009  \tif ((int64_t)s > zip->entry_uncompressed_limit)\n ....\n 1138  \n 1139  static int\n 1140: archive_write_zip_finish_entry(struct archive_write *a)\n 1141  {\n 1142: \tstruct zip *zip = a->format_data;\n 1143  \tint ret;\n 1144  \n ....\n 1275  \n 1276  static int\n 1277: archive_write_zip_close(struct archive_write *a)\n 1278  {\n 1279  \tuint8_t buff[64];\n 1280  \tint64_t offset_start, offset_end;\n 1281: \tstruct zip *zip = a->format_data;\n 1282: \tstruct cd_segment *segment;\n 1283  \tint ret;\n 1284  \n ....\n 1348  \n 1349  static int\n 1350: archive_write_zip_free(struct archive_write *a)\n 1351  {\n 1352: \tstruct zip *zip;\n 1353: \tstruct cd_segment *segment;\n 1354  \n 1355  \tzip = a->format_data;\n ....\n 1377  dos_time(const time_t unix_time)\n 1378  {\n 1379: \tstruct tm *t;\n 1380  \tunsigned int dt;\n 1381  #if defined(HAVE_LOCALTIME_R) || defined(HAVE__LOCALTIME64_S)\n 1382: \tstruct tm tmbuf;\n 1383  #endif\n 1384  #if defined(HAVE__LOCALTIME64_S)\n ....\n 1423  \n 1424  static size_t\n 1425: path_length(struct archive_entry *entry)\n 1426  {\n 1427  \tmode_t type;\n ....\n 1441  \n 1442  static int\n 1443: write_path(struct archive_entry *entry, struct archive_write *archive)\n 1444  {\n 1445  \tint ret;\n ....\n 1472  \n 1473  static void\n 1474: copy_path(struct archive_entry *entry, unsigned char *p)\n 1475  {\n 1476  \tconst char *path;\n ....\n 1490  \n 1491  \n 1492: static struct archive_string_conv *\n 1493: get_sconv(struct archive_write *a, struct zip *zip)\n 1494  {\n 1495  \tif (zip->opt_sconv != NULL)\n ....\n 1509  \n 1510  static void\n 1511: trad_enc_update_keys(struct trad_enc_ctx *ctx, uint8_t c)\n 1512  {\n 1513  \tuint8_t t;\n ....\n 1522  \n 1523  static uint8_t\n 1524: trad_enc_decrypt_byte(struct trad_enc_ctx *ctx)\n 1525  {\n 1526  \tunsigned temp = ctx->keys[2] | 2;\n ....\n 1529  \n 1530  static unsigned\n 1531: trad_enc_encrypt_update(struct trad_enc_ctx *ctx, const uint8_t *in,\n 1532      size_t in_len, uint8_t *out, size_t out_len)\n 1533  {\n ....\n 1545  \n 1546  static int\n 1547: trad_enc_init(struct trad_enc_ctx *ctx, const char *pw, size_t pw_len)\n 1548  {\n 1549  \n ....\n 1568  \n 1569  static int\n 1570: init_traditional_pkware_encryption(struct archive_write *a)\n 1571  {\n 1572: \tstruct zip *zip = a->format_data;\n 1573  \tconst char *passphrase;\n 1574  \tuint8_t key[TRAD_HEADER_SIZE];\n ....\n 1603  \n 1604  static int\n 1605: init_winzip_aes_encryption(struct archive_write *a)\n 1606  {\n 1607: \tstruct zip *zip = a->format_data;\n 1608  \tconst char *passphrase;\n 1609  \tsize_t key_len, salt_len;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_string_composition.h:\n   42  #endif\n   43  \n   44: struct unicode_composition_table {\n   45  \tuint32_t cp1;\n   46  \tuint32_t cp2;\n   ..\n   48  };\n   49  \n   50: static const struct unicode_composition_table u_composition_table[] = {\n   51  \t{ 0x0003C , 0x00338 , 0x0226E },\n   52  \t{ 0x0003D , 0x00338 , 0x02260 },\n   ..\n 1349    0, 0, 0, 0, 0, 0, 0, 0, 0,37,38,};\n 1350  \n 1351: struct unicode_decomposition_table {\n 1352  \tuint32_t nfc;\n 1353  \tuint32_t cp1;\n ....\n 1355  };\n 1356  \n 1357: static const struct unicode_decomposition_table u_decomposition_table[] = {\n 1358  \t{ 0x000C0 , 0x00041 , 0x00300 },\n 1359  \t{ 0x000C1 , 0x00041 , 0x00301 },\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_cryptor.c:\n  531  \n  532  \n  533: const struct archive_cryptor __archive_cryptor =\n  534  {\n  535    &pbkdf2_sha1,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_options.c:\n   38  \n   39  int\n   40: _archive_set_option(struct archive *a,\n   41      const char *m, const char *o, const char *v,\n   42      int magic, const char *fn, option_handler use_option)\n   ..\n   74  \n   75  int\n   76: _archive_set_either_option(struct archive *a, const char *m, const char *o, const char *v,\n   77      option_handler use_format_option, option_handler use_filter_option)\n   78  {\n   ..\n   98  \n   99  int\n  100: _archive_set_options(struct archive *a, const char *options,\n  101      int magic, const char *fn, option_handler use_option)\n  102  {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_disk_acl_sunos.c:\n   47  #include \"archive_write_disk_private.h\"\n   48  \n   49: typedef struct {\n   50  \tconst int a_perm;\t/* Libarchive permission or flag */\n   51  \tconst int p_perm;\t/* Platform permission or flag */\n   ..\n  313   */\n  314  static int\n  315: translate_acl(struct archive_read_disk *a,\n  316:     struct archive_entry *entry, void *aclp, int aclcnt,\n  317      int default_entry_acl_type)\n  318  {\n  ...\n  443  \n  444  static int\n  445: set_acl(struct archive *a, int fd, const char *name,\n  446:     struct archive_acl *abstract_acl, __LA_MODE_T mode,\n  447      int ae_requested_type, const char *tname)\n  448  {\n  ...\n  707  \n  708  int\n  709: archive_read_disk_entry_setup_acls(struct archive_read_disk *a,\n  710:     struct archive_entry *entry, int *fd)\n  711  {\n  712  \tconst char\t*accpath;\n  ...\n  797  \n  798  int\n  799: archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n  800:     struct archive_acl *abstract_acl, __LA_MODE_T mode)\n  801  {\n  802  \tint\t\tret = ARCHIVE_OK;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_write.c:\n   61  #include \"archive_write_private.h\"\n   62  \n   63: static struct archive_vtable *archive_write_vtable(void);\n   64  \n   65: static int\t_archive_filter_code(struct archive *, int);\n   66: static const char *_archive_filter_name(struct archive *, int);\n   67: static int64_t\t_archive_filter_bytes(struct archive *, int);\n   68: static int  _archive_write_filter_count(struct archive *);\n   69: static int\t_archive_write_close(struct archive *);\n   70: static int\t_archive_write_free(struct archive *);\n   71: static int\t_archive_write_header(struct archive *, struct archive_entry *);\n   72: static int\t_archive_write_finish_entry(struct archive *);\n   73: static ssize_t\t_archive_write_data(struct archive *, const void *, size_t);\n   74  \n   75: struct archive_none {\n   76  \tsize_t buffer_size;\n   77  \tsize_t avail;\n   ..\n   80  };\n   81  \n   82: static struct archive_vtable *\n   83  archive_write_vtable(void)\n   84  {\n   85: \tstatic struct archive_vtable av;\n   86  \tstatic int inited = 0;\n   87  \n   ..\n  104   * Allocate, initialize and return an archive object.\n  105   */\n  106: struct archive *\n  107  archive_write_new(void)\n  108  {\n  109: \tstruct archive_write *a;\n  110  \tunsigned char *nulls;\n  111  \n  112: \ta = (struct archive_write *)calloc(1, sizeof(*a));\n  113  \tif (a == NULL)\n  114  \t\treturn (NULL);\n  ...\n  139   */\n  140  int\n  141: archive_write_set_bytes_per_block(struct archive *_a, int bytes_per_block)\n  142  {\n  143: \tstruct archive_write *a = (struct archive_write *)_a;\n  144  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n  145  \t    ARCHIVE_STATE_NEW, \"archive_write_set_bytes_per_block\");\n  ...\n  152   */\n  153  int\n  154: archive_write_get_bytes_per_block(struct archive *_a)\n  155  {\n  156: \tstruct archive_write *a = (struct archive_write *)_a;\n  157  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n  158  \t    ARCHIVE_STATE_ANY, \"archive_write_get_bytes_per_block\");\n  ...\n  165   */\n  166  int\n  167: archive_write_set_bytes_in_last_block(struct archive *_a, int bytes)\n  168  {\n  169: \tstruct archive_write *a = (struct archive_write *)_a;\n  170  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n  171  \t    ARCHIVE_STATE_ANY, \"archive_write_set_bytes_in_last_block\");\n  ...\n  178   */\n  179  int\n  180: archive_write_get_bytes_in_last_block(struct archive *_a)\n  181  {\n  182: \tstruct archive_write *a = (struct archive_write *)_a;\n  183  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n  184  \t    ARCHIVE_STATE_ANY, \"archive_write_get_bytes_in_last_block\");\n  ...\n  191   */\n  192  int\n  193: archive_write_set_skip_file(struct archive *_a, la_int64_t d, la_int64_t i)\n  194  {\n  195: \tstruct archive_write *a = (struct archive_write *)_a;\n  196  \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n  197  \t    ARCHIVE_STATE_ANY, \"archive_write_set_skip_file\");\n  ...\n  203  \n  204  /*\n  205:  * Allocate and return the next filter structure.\n  206   */\n  207: struct archive_write_filter *\n  208: __archive_write_allocate_filter(struct archive *_a)\n  209  {\n  210: \tstruct archive_write *a = (struct archive_write *)_a;\n  211: \tstruct archive_write_filter *f;\n  212  \n  213  \tf = calloc(1, sizeof(*f));\n  ...\n  226   */\n  227  int\n  228: __archive_write_filter(struct archive_write_filter *f,\n  229      const void *buff, size_t length)\n  230  {\n  ...\n  249   */\n  250  static int\n  251: __archive_write_open_filter(struct archive_write_filter *f)\n  252  {\n  253  \tint ret;\n  ...\n  276   */\n  277  static int\n  278: __archive_write_filters_open(struct archive_write *a)\n  279  {\n  280  \treturn (__archive_write_open_filter(a->filter_first));\n  ...\n  285   */\n  286  static int\n  287: __archive_write_filters_close(struct archive_write *a)\n  288  {\n  289: \tstruct archive_write_filter *f;\n  290  \tint ret, ret1;\n  291  \tret = ARCHIVE_OK;\n  ...\n  312  \n  313  int\n  314: __archive_write_output(struct archive_write *a, const void *buff, size_t length)\n  315  {\n  316  \treturn (__archive_write_filter(a->filter_first, buff, length));\n  ...\n  318  \n  319  int\n  320: __archive_write_nulls(struct archive_write *a, size_t length)\n  321  {\n  322  \tif (length == 0)\n  ...\n  334  \n  335  static int\n  336: archive_write_client_open(struct archive_write_filter *f)\n  337  {\n  338: \tstruct archive_write *a = (struct archive_write *)f->archive;\n  339: \tstruct archive_none *state;\n  340  \tvoid *buffer;\n  341  \tsize_t buffer_size;\n  ...\n  347  \tbuffer_size = f->bytes_per_block;\n  348  \n  349: \tstate = (struct archive_none *)calloc(1, sizeof(*state));\n  350  \tbuffer = (char *)malloc(buffer_size);\n  351  \tif (state == NULL || buffer == NULL) {\n  ...\n  375  \n  376  static int\n  377: archive_write_client_write(struct archive_write_filter *f,\n  378      const void *_buff, size_t length)\n  379  {\n  380: \tstruct archive_write *a = (struct archive_write *)f->archive;\n  381:         struct archive_none *state = (struct archive_none *)f->data;\n  382  \tconst char *buff = (const char *)_buff;\n  383  \tssize_t remaining, to_copy;\n  ...\n  457  \n  458  static int\n  459: archive_write_client_free(struct archive_write_filter *f)\n  460  {\n  461: \tstruct archive_write *a = (struct archive_write *)f->archive;\n  462  \n  463  \tif (a->client_freer)\n  ...\n  476  \n  477  static int\n  478: archive_write_client_close(struct archive_write_filter *f)\n  479  {\n  480: \tstruct archive_write *a = (struct archive_write *)f->archive;\n  481: \tstruct archive_none *state = (struct archive_none *)f->data;\n  482  \tssize_t block_length;\n  483  \tssize_t target_block_length;\n  ...\n  540   */\n  541  int\n  542: archive_write_open2(struct archive *_a, void *client_data,\n  543      archive_open_callback *opener, archive_write_callback *writer,\n  544      archive_close_callback *closer, archive_free_callback *freer)\n  545  {\n  546: \tstruct archive_write *a = (struct archive_write *)_a;\n  547: \tstruct archive_write_filter *client_filter;\n  548  \tint ret, r1;\n  549  \n  ...\n  578  \n  579  int\n  580: archive_write_open(struct archive *_a, void *client_data,\n  581      archive_open_callback *opener, archive_write_callback *writer,\n  582      archive_close_callback *closer)\n  ...\n  590   */\n  591  static int\n  592: _archive_write_close(struct archive *_a)\n  593  {\n  594: \tstruct archive_write *a = (struct archive_write *)_a;\n  595  \tint r = ARCHIVE_OK, r1 = ARCHIVE_OK;\n  596  \n  ...\n  628  \n  629  static int\n  630: _archive_write_filter_count(struct archive *_a)\n  631  {\n  632: \tstruct archive_write *a = (struct archive_write *)_a;\n  633: \tstruct archive_write_filter *p = a->filter_first;\n  634  \tint count = 0;\n  635  \twhile(p) {\n  ...\n  641  \n  642  void\n  643: __archive_write_filters_free(struct archive *_a)\n  644  {\n  645: \tstruct archive_write *a = (struct archive_write *)_a;\n  646  \tint r = ARCHIVE_OK, r1;\n  647  \n  648  \twhile (a->filter_first != NULL) {\n  649: \t\tstruct archive_write_filter *next\n  650  \t\t    = a->filter_first->next_filter;\n  651  \t\tif (a->filter_first->free != NULL) {\n  ...\n  661  \n  662  /*\n  663:  * Destroy the archive structure.\n  664   *\n  665   * Be careful: user might just call write_new and then write_free.\n  ...\n  668   */\n  669  static int\n  670: _archive_write_free(struct archive *_a)\n  671  {\n  672: \tstruct archive_write *a = (struct archive_write *)_a;\n  673  \tint r = ARCHIVE_OK, r1;\n  674  \n  ...\n  708   */\n  709  static int\n  710: _archive_write_header(struct archive *_a, struct archive_entry *entry)\n  711  {\n  712: \tstruct archive_write *a = (struct archive_write *)_a;\n  713  \tint ret, r2;\n  714  \n  ...\n  760  \n  761  static int\n  762: _archive_write_finish_entry(struct archive *_a)\n  763  {\n  764: \tstruct archive_write *a = (struct archive_write *)_a;\n  765  \tint ret = ARCHIVE_OK;\n  766  \n  ...\n  779   */\n  780  static ssize_t\n  781: _archive_write_data(struct archive *_a, const void *buff, size_t s)\n  782  {\n  783: \tstruct archive_write *a = (struct archive_write *)_a;\n  784  \tconst size_t max_write = INT_MAX;\n  785  \n  ...\n  793  }\n  794  \n  795: static struct archive_write_filter *\n  796: filter_lookup(struct archive *_a, int n)\n  797  {\n  798: \tstruct archive_write *a = (struct archive_write *)_a;\n  799: \tstruct archive_write_filter *f = a->filter_first;\n  800  \tif (n == -1)\n  801  \t\treturn a->filter_last;\n  ...\n  810  \n  811  static int\n  812: _archive_filter_code(struct archive *_a, int n)\n  813  {\n  814: \tstruct archive_write_filter *f = filter_lookup(_a, n);\n  815  \treturn f == NULL ? -1 : f->code;\n  816  }\n  817  \n  818  static const char *\n  819: _archive_filter_name(struct archive *_a, int n)\n  820  {\n  821: \tstruct archive_write_filter *f = filter_lookup(_a, n);\n  822  \treturn f != NULL ? f->name : NULL;\n  823  }\n  824  \n  825  static int64_t\n  826: _archive_filter_bytes(struct archive *_a, int n)\n  827  {\n  828: \tstruct archive_write_filter *f = filter_lookup(_a, n);\n  829  \treturn f == NULL ? -1 : f->bytes_written;\n  830  }\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/archive_entry_stat.c:\n   37  #include \"archive_entry_private.h\"\n   38  \n   39: const struct stat *\n   40: archive_entry_stat(struct archive_entry *entry)\n   41  {\n   42: \tstruct stat *st;\n   43  \tif (entry->stat == NULL) {\n   44  \t\tentry->stat = calloc(1, sizeof(*st));\n   ..\n   54  \t * extra complexity probably isn't worth it.  It will be very\n   55  \t * rare for anyone to change just one field then request a new\n   56: \t * stat structure.\n   57  \t */\n   58  \tif (entry->stat_valid)\n   ..\n   81  \t/*\n   82  \t * On systems that support high-res timestamps, copy that\n   83: \t * information into struct stat.\n   84  \t */\n   85  #if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC\n   ..\n  110  \t/*\n  111  \t * TODO: On Linux, store 32 or 64 here depending on whether\n  112: \t * the cached stat structure is a stat32 or a stat64.  This\n  113  \t * will allow us to support both variants interchangeably.\n  114  \t */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_afio.c:\n   80  \tunsigned char *p;\n   81  \tsize_t size;\n   82: \tstruct archive_entry *ae;\n   83: \tstruct archive *a;\n   84  \n   85  \t/* The default block size of afio is 5120. we simulate it */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_solaris_pax_sparse.c:\n   34  {\n   35  \tchar name[] = \"test_compat_solaris_pax_sparse_1.pax.Z\";\n   36: \tstruct archive_entry *ae;\n   37: \tstruct archive *a;\n   38  \tint64_t offset, length;\n   39  \tconst void *buff;\n   ..\n  115  {\n  116  \tchar name[] = \"test_compat_solaris_pax_sparse_2.pax.Z\";\n  117: \tstruct archive_entry *ae;\n  118: \tstruct archive *a;\n  119  \tint64_t offset, length;\n  120  \tconst void *buff;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_tar_ustar.c:\n   50  DEFINE_TEST(test_write_format_tar_ustar)\n   51  {\n   52: \tstruct archive *a;\n   53: \tstruct archive_entry *entry;\n   54  \tchar *buff, *e;\n   55  \tsize_t buffsize = 100000;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_warc.c:\n   33  \tchar buff[256U];\n   34  \tconst char reffile[] = \"test_read_format_warc.warc\";\n   35: \tstruct archive_entry *ae;\n   36: \tstruct archive *a;\n   37  \n   38  \textract_reference_file(reffile);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_pax_xattr_schily.c:\n   31  DEFINE_TEST(test_read_pax_xattr_schily)\n   32  {\n   33: \tstruct archive *a;\n   34: \tstruct archive_entry *ae;\n   35  \tconst char *refname = \"test_read_pax_xattr_schily.tar\";\n   36  \tconst char *xname; /* For xattr tests. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_sparse.c:\n   33   */\n   34  static void\n   35: verify_write_data(struct archive *a, int sparse)\n   36  {\n   37  \tstatic const char data[]=\"abcdefghijklmnopqrstuvwxyz\";\n   38: \tstruct stat st;\n   39: \tstruct archive_entry *ae;\n   40  \tsize_t buff_size = 64 * 1024;\n   41  \tchar *buff, *p;\n   ..\n  130   */\n  131  static void\n  132: verify_write_data_block(struct archive *a, int sparse)\n  133  {\n  134  \tstatic const char data[]=\"abcdefghijklmnopqrstuvwxyz\";\n  135: \tstruct stat st;\n  136: \tstruct archive_entry *ae;\n  137  \tsize_t buff_size = 64 * 1024;\n  138  \tchar *buff, *p;\n  ...\n  266  DEFINE_TEST(test_write_disk_sparse)\n  267  {\n  268: \tstruct archive *ad;\n  269  \n  270  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_entry_strmode.c:\n   28  DEFINE_TEST(test_entry_strmode)\n   29  {\n   30: \tstruct archive_entry *entry;\n   31  \n   32  \tassert((entry = archive_entry_new()) != NULL);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_extract.c:\n   31  DEFINE_TEST(test_read_extract)\n   32  {\n   33: \tstruct archive_entry *ae;\n   34: \tstruct archive *a;\n   35  \tsize_t used;\n   36  \tint i, numEntries = 0;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_encryption_header.c:\n   31  \t   ARE encrypted. Password is \"12345678\". */\n   32  \tconst char *refname = \"test_read_format_zip_encryption_header.zip\";\n   33: \tstruct archive_entry *ae;\n   34: \tstruct archive *a;\n   35  \tchar buff[128];\n   36  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_gtar_sparse_skip_entry.c:\n   37  {\n   38  \tconst char *refname = \"test_read_format_gtar_sparse_skip_entry.tar.Z.uu\";\n   39: \tstruct archive *a;\n   40: \tstruct archive_entry *ae;\n   41  \tconst void *p;\n   42  \tsize_t s;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_set_format.c:\n   33    const char test_txt[] = \"test text document\\r\\n\";\n   34    int size = sizeof(test_txt)-1;\n   35:   struct archive_entry *ae;\n   36:   struct archive *a;\n   37  \n   38    extract_reference_file(reffile);\n   ..\n  103  {\n  104    const char reffile[] = \"test_read_format_zip.zip\";\n  105:   struct archive_entry *ae;\n  106:   struct archive *a;\n  107  \n  108    extract_reference_file(reffile);\n  ...\n  127  DEFINE_TEST(test_read_append_filter)\n  128  {\n  129:   struct archive_entry *ae;\n  130:   struct archive *a;\n  131    int r;\n  132  \n  ...\n  152  DEFINE_TEST(test_read_append_wrong_filter)\n  153  {\n  154:   struct archive_entry *ae;\n  155:   struct archive *a;\n  156    int r;\n  157  \n  ...\n  177  DEFINE_TEST(test_read_append_filter_program)\n  178  {\n  179:   struct archive_entry *ae;\n  180:   struct archive *a;\n  181  \n  182    if (!canGzip()) {\n  ...\n  200  DEFINE_TEST(test_read_append_filter_wrong_program)\n  201  {\n  202:   struct archive_entry *ae;\n  203:   struct archive *a;\n  204  #if !defined(_WIN32) || defined(__CYGWIN__)\n  205    FILE * fp;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_iso9660_empty.c:\n   50  DEFINE_TEST(test_write_format_iso9660_empty)\n   51  {\n   52: \tstruct archive *a;\n   53: \tstruct archive_entry *ae;\n   54  \tunsigned char *buff;\n   55  \tsize_t buffsize = 190 * 2048;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_zstd.c:\n   38  {\n   39  \tconst char *n[7] = { \"f1\", \"f2\", \"f3\", \"d1/f1\", \"d1/f2\", \"d1/f3\", NULL };\n   40: \tstruct archive_entry *ae;\n   41: \tstruct archive *a;\n   42  \tint i, r;\n   43  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_gtar_gz.c:\n   35  DEFINE_TEST(test_read_format_gtar_gz)\n   36  {\n   37: \tstruct archive_entry *ae;\n   38: \tstruct archive *a;\n   39  \tint r;\n   40  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_lzip.c:\n   94  {\n   95  \tconst char *n[7] = { \"f1\", \"f2\", \"f3\", \"d1/f1\", \"d1/f2\", \"d1/f3\", NULL };\n   96: \tstruct archive_entry *ae;\n   97: \tstruct archive *a;\n   98  \tint i, r;\n   99  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_zip_zip64.c:\n   30  verify_zip_filesize(uint64_t size, int expected)\n   31  {\n   32: \tstruct archive *a;\n   33: \tstruct archive_entry *ae;\n   34  \tchar buff[256];\n   35  \tsize_t used;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_acl_text.c:\n   33   */\n   34  \n   35: static struct archive_test_acl_t acls0[] = {\n   36  \t{ ARCHIVE_ENTRY_ACL_TYPE_ACCESS,\n   37  \t    ARCHIVE_ENTRY_ACL_EXECUTE |\n   ..\n   77  };\n   78  \n   79: static struct archive_test_acl_t acls1[] = {\n   80  \t{ ARCHIVE_ENTRY_ACL_TYPE_ALLOW,\n   81  \t    ARCHIVE_ENTRY_ACL_READ_DATA |\n   ..\n  248  \n  249  static void\n  250: compare_acl_text(struct archive_entry *ae, int flags, const char *s)\n  251  {\n  252  \tchar *text;\n  ...\n  273  DEFINE_TEST(test_acl_from_text)\n  274  {\n  275: \tstruct archive_entry *ae;\n  276  \twchar_t *ws = NULL;\n  277  \n  ...\n  411  DEFINE_TEST(test_acl_to_text)\n  412  {\n  413: \tstruct archive_entry *ae;\n  414  \n  415  \t/* Create an empty archive_entry. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_ar.c:\n   34  \tchar buff[64];\n   35  \tconst char reffile[] = \"test_read_format_ar.ar\";\n   36: \tstruct archive_entry *ae;\n   37: \tstruct archive *a;\n   38  \n   39  \textract_reference_file(reffile);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_gtar.c:\n   42  {\n   43  \tchar name[] = \"test_compat_gtar_1.tar\";\n   44: \tstruct archive_entry *ae;\n   45: \tstruct archive *a;\n   46  \tint r;\n   47  \n   ..\n  115  {\n  116  \tchar name[] = \"test_compat_gtar_2.tar\";\n  117: \tstruct archive_entry *ae;\n  118: \tstruct archive *a;\n  119  \tint r;\n  120  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_acl_platform_posix1e.c:\n   36  #endif\n   37  \n   38: static struct archive_test_acl_t acls2[] = {\n   39  \t{ ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ARCHIVE_ENTRY_ACL_EXECUTE | ARCHIVE_ENTRY_ACL_READ,\n   40  \t  ARCHIVE_ENTRY_ACL_USER_OBJ, -1, \"\" },\n   ..\n  130  #if ARCHIVE_ACL_SUNOS\n  131  static int\n  132: acl_match(aclent_t *aclent, struct archive_test_acl_t *myacl)\n  133  {\n  134  \n  ...\n  171  #else\t/* ARCHIVE_ACL_FREEBSD || ARCHIVE_ACL_LIBACL */\n  172  static int\n  173: acl_match(acl_entry_t aclent, struct archive_test_acl_t *myacl)\n  174  {\n  175  \tgid_t g, *gp;\n  ...\n  224      acl_t acl,\n  225  #endif\n  226:     struct archive_test_acl_t *myacls, int n)\n  227  {\n  228  \tint *marker;\n  ...\n  294  \tskipping(\"POSIX.1e ACLs are not supported on this platform\");\n  295  #else\t/* ARCHIVE_ACL_POSIX1E */\n  296: \tstruct stat st;\n  297: \tstruct archive *a;\n  298: \tstruct archive_entry *ae;\n  299  #if ARCHIVE_ACL_SUNOS\n  300  \tvoid *aclp;\n  ...\n  362  \tskipping(\"POSIX.1e ACLs are not supported on this platform\");\n  363  #else /* ARCHIVE_ACL_POSIX1E */\n  364: \tstruct archive *a;\n  365: \tstruct archive_entry *ae;\n  366  \tint n, fd, flags, dflags;\n  367  \tchar *acl_text;\n  ...\n  375  \n  376  \t/*\n  377: \t * Manually construct a directory and two files with\n  378  \t * different ACLs.  This also serves to verify that ACLs\n  379  \t * are supported on the local filesystem.\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/read_open_memory.c:\n   39   */\n   40  \n   41: struct read_memory_data {\n   42  \tconst unsigned char\t*start;\n   43  \tconst unsigned char\t*p;\n   ..\n   49  };\n   50  \n   51: static int\tmemory_read_close(struct archive *, void *);\n   52: static int\tmemory_read_open(struct archive *, void *);\n   53: static int64_t\tmemory_read_seek(struct archive *, void *, int64_t request, int whence);\n   54: static int64_t\tmemory_read_skip(struct archive *, void *, int64_t request);\n   55: static ssize_t\tmemory_read(struct archive *, void *, const void **buff);\n   56: static int\tread_open_memory_internal(struct archive *a, const void *buff,\n   57      size_t size, size_t read_size, int fullapi);\n   58  \n   59  \n   60  int\n   61: read_open_memory(struct archive *a, const void *buff, size_t size, size_t read_size)\n   62  {\n   63  \treturn read_open_memory_internal(a, buff, size, read_size, 2);\n   ..\n   69   */\n   70  int\n   71: read_open_memory_minimal(struct archive *a, const void *buff, size_t size, size_t read_size)\n   72  {\n   73  \treturn read_open_memory_internal(a, buff, size, read_size, 1);\n   ..\n   78   */\n   79  int\n   80: read_open_memory_seek(struct archive *a, const void *buff, size_t size, size_t read_size)\n   81  {\n   82  \treturn read_open_memory_internal(a, buff, size, read_size, 3);\n   ..\n   84  \n   85  static int\n   86: read_open_memory_internal(struct archive *a, const void *buff,\n   87      size_t size, size_t read_size, int level)\n   88  {\n   89: \tstruct read_memory_data *mine = NULL;\n   90  \n   91  \tswitch (level) {\n   ..\n  123   */\n  124  static int\n  125: memory_read_open(struct archive *a, void *client_data)\n  126  {\n  127  \t(void)a; /* UNUSED */\n  ...\n  137   */\n  138  static ssize_t\n  139: memory_read(struct archive *a, void *client_data, const void **buff)\n  140  {\n  141: \tstruct read_memory_data *mine = (struct read_memory_data *)client_data;\n  142  \tssize_t size;\n  143  \n  ...\n  163   */\n  164  static int64_t\n  165: memory_read_skip(struct archive *a, void *client_data, int64_t skip)\n  166  {\n  167: \tstruct read_memory_data *mine = (struct read_memory_data *)client_data;\n  168  \n  169  \t(void)a; /* UNUSED */\n  ...\n  181   */\n  182  static int64_t\n  183: memory_read_seek(struct archive *a, void *client_data, int64_t offset, int whence)\n  184  {\n  185: \tstruct read_memory_data *mine = (struct read_memory_data *)client_data;\n  186  \n  187  \t(void)a; /* UNUSED */\n  ...\n  212   */\n  213  static int\n  214: memory_read_close(struct archive *a, void *client_data)\n  215  {\n  216: \tstruct read_memory_data *mine = (struct read_memory_data *)client_data;\n  217  \t(void)a; /* UNUSED */\n  218  \tif (mine != NULL)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_mtree_classic.c:\n   29  \n   30  static char buff[4096];\n   31: static struct {\n   32  \tconst char\t*path;\n   33  \tmode_t\t\t mode;\n   ..\n  111  test_write_format_mtree_sub(int dironly)\n  112  {\n  113: \tstruct archive_entry *ae;\n  114: \tstruct archive* a;\n  115  \tsize_t used;\n  116  \tint i;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_empty.c:\n   30  DEFINE_TEST(test_read_format_empty)\n   31  {\n   32: \tstruct archive_entry *ae;\n   33: \tstruct archive *a;\n   34  \tassert((a = archive_read_new()) != NULL);\n   35  \tassertA(0 == archive_read_support_filter_all(a));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_filter_lzop.c:\n   34  DEFINE_TEST(test_write_filter_lzop)\n   35  {\n   36: \tstruct archive_entry *ae;\n   37: \tstruct archive* a;\n   38  \tchar *buff, *data;\n   39  \tsize_t buffsize, datasize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_xar.c:\n   33  \tsize_t buffsize = 1500;\n   34  \tchar *buff;\n   35: \tstruct archive_entry *ae;\n   36: \tstruct archive *a;\n   37  \tsize_t used;\n   38  \tconst char *name;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_filter_gzip_timestamp.c:\n   31  DEFINE_TEST(test_write_filter_gzip_timestamp)\n   32  {\n   33: \tstruct archive_entry *ae;\n   34: \tstruct archive* a;\n   35  \tchar *buff, *data;\n   36  \tsize_t buffsize, datasize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_isorr_ce.c:\n   89  \tchar path2[160];\n   90  \tchar path3[160];\n   91: \tstruct archive_entry *ae;\n   92: \tstruct archive *a;\n   93  \tconst void *p;\n   94  \tsize_t size;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_mtree_classic_indent.c:\n   29  \n   30  static char buff[4096];\n   31: static struct {\n   32  \tconst char\t*path;\n   33  \tmode_t\t\t mode;\n   ..\n  111  test_write_format_mtree_sub(int dironly)\n  112  {\n  113: \tstruct archive_entry *ae;\n  114: \tstruct archive* a;\n  115  \tsize_t used;\n  116  \tint i;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_uudecode.c:\n   46  DEFINE_TEST(test_compat_uudecode)\n   47  {\n   48: \tstruct archive_entry *ae;\n   49: \tstruct archive *a;\n   50  \n   51  \tassert((a = archive_read_new()) != NULL);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_sparse_basic.c:\n   62   */\n   63  \n   64: struct sparse {\n   65  \tenum { DATA, HOLE, END } type;\n   66  \tsize_t\tsize;\n   67  };\n   68  \n   69: static void create_sparse_file(const char *, const struct sparse *);\n   70  \n   71  #if defined(__APPLE__)\n   ..\n  113  \n  114  static void\n  115: create_sparse_file(const char *path, const struct sparse *s)\n  116  {\n  117  \tchar buff[1024];\n  ...\n  178  is_sparse_supported_fiemap(const char *path)\n  179  {\n  180: \tconst struct sparse sparse_file[] = {\n  181   \t\t/* This hole size is too small to create a sparse\n  182  \t\t * files for almost filesystem. */\n  ...\n  185  \t};\n  186  \tint fd, r;\n  187: \tstruct fiemap *fm;\n  188  \tchar buff[1024];\n  189  \tconst char *testfile = \"can_sparse\";\n  ...\n  195  \tif (fd < 0)\n  196  \t\treturn (0);\n  197: \tfm = (struct fiemap *)buff;\n  198  \tfm->fm_start = 0;\n  199  \tfm->fm_length = ~0ULL;;\n  200  \tfm->fm_flags = FIEMAP_FLAG_SYNC;\n  201  \tfm->fm_extent_count = (sizeof(buff) - sizeof(*fm))/\n  202: \t\tsizeof(struct fiemap_extent);\n  203  \tr = ioctl(fd, FS_IOC_FIEMAP, fm);\n  204  \tclose(fd);\n  ...\n  234  is_sparse_supported(const char *path)\n  235  {\n  236: \tconst struct sparse sparse_file[] = {\n  237   \t\t/* This hole size is too small to create a sparse\n  238  \t\t * files for almost filesystem. */\n  ...\n  279  \n  280  static void\n  281: create_sparse_file(const char *path, const struct sparse *s)\n  282  {\n  283  \tchar buff[1024];\n  284  \tint fd;\n  285  \tuint64_t total_size = 0;\n  286: \tconst struct sparse *cur = s;\n  287  \n  288  \tmemset(buff, ' ', sizeof(buff));\n  ...\n  323   */\n  324  static void\n  325: verify_sparse_file(struct archive *a, const char *path,\n  326:     const struct sparse *sparse, int expected_holes)\n  327  {\n  328: \tstruct archive_entry *ae;\n  329  \tconst void *buff;\n  330  \tsize_t bytes_read;\n  ...\n  447   */\n  448  static void\n  449: verify_sparse_file2(struct archive *a, const char *path,\n  450:     const struct sparse *sparse, int blocks, int preopen)\n  451  {\n  452: \tstruct archive_entry *ae;\n  453  \tint fd;\n  454  \n  ...\n  475  test_sparse_whole_file_data(void)\n  476  {\n  477: \tstruct archive_entry *ae;\n  478  \tint64_t offset;\n  479  \tint i;\n  ...\n  499  {\n  500  \tchar *cwd;\n  501: \tstruct archive *a;\n  502  \tconst char *skip_sparse_tests;\n  503  \t/*\n  ...\n  509  \t * on all platform.\n  510  \t */\n  511: \tconst struct sparse sparse_file0[] = {\n  512  \t\t// 0             // 1024\n  513  \t\t{ DATA,\t 1024 }, { HOLE,   MIN_HOLE + 1638400 },\n  ...\n  521  \t\t{ DATA,     1 }, { END,\t0 }\n  522  \t};\n  523: \tconst struct sparse sparse_file1[] = {\n  524  \t\t{ HOLE,\tMIN_HOLE }, { DATA, 1 },\n  525  \t\t{ HOLE,\tMIN_HOLE }, { DATA, 1 },\n  526  \t\t{ HOLE, MIN_HOLE }, { END,  0 }\n  527  \t};\n  528: \tconst struct sparse sparse_file2[] = {\n  529  \t\t{ HOLE,\tMIN_HOLE }, { DATA, 1024 },\n  530  \t\t{ HOLE,\tMIN_HOLE + 409600 * 1 }, { DATA, 1024 },\n  ...\n  549  \t\t{ END,\t0 }\n  550  \t};\n  551: \tconst struct sparse sparse_file3[] = {\n  552   \t\t/* This hole size is too small to create a sparse file */\n  553  \t\t{ HOLE,\t 1 }, { DATA, 10240 },\n  ...\n  556  \t\t{ END,\t0 }\n  557  \t};\n  558: \tconst struct sparse sparse_file4[] = {\n  559  \t\t{ DATA, 4096 }, { HOLE, 0xc0000000 },\n  560  \t\t/* This hole overflows the offset if stored in 32 bits. */\n  ...\n  622  {\n  623  \tchar *cwd;\n  624: \tstruct archive *a;\n  625  \tconst char *skip_sparse_tests;\n  626  \n  627: \tconst struct sparse sparse_file[] = {\n  628  \t\t{ HOLE, MIN_HOLE }, { END, 0 }\n  629  \t};\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_empty_write.c:\n   29  {\n   30  \tchar buff[32768];\n   31: \tstruct archive_entry *ae;\n   32: \tstruct archive *a;\n   33  \tsize_t used;\n   34  \tint r;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_filter_compress.c:\n   28  {\n   29  \tconst char data[] = {0x1f, 0x9d};\n   30: \tstruct archive *a;\n   31  \n   32  \tassert((a = archive_read_new()) != NULL);\n   ..\n   44  {\n   45  \tconst char data[] = {0x1f, 0x9d, 0x10};\n   46: \tstruct archive *a;\n   47: \tstruct archive_entry *ae;\n   48  \n   49  \tassert((a = archive_read_new()) != NULL);\n   ..\n   68  {\n   69  \tconst char data[] = {0x1f, 0x9d, 0x11};\n   70: \tstruct archive *a;\n   71  \n   72  \tassert((a = archive_read_new()) != NULL);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_malformed.c:\n   31  {\n   32  \tconst char *refname = \"test_read_format_zip_malformed1.zip\";\n   33: \tstruct archive *a;\n   34: \tstruct archive_entry *ae;\n   35  \tchar *p;\n   36  \tsize_t s;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_svr4_gzip_rpm.c:\n   85  DEFINE_TEST(test_read_format_cpio_svr4_gzip_rpm)\n   86  {\n   87: \tstruct archive_entry *ae;\n   88: \tstruct archive *a;\n   89  \tconst char *name = \"test_read_format_cpio_svr4_gzip_rpm.rpm\";\n   90  \tint r;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_disk_directory_traversals.c:\n   40  {\n   41  \tconst char *fn = \"fs_noatime\";\n   42: \tstruct stat st;\n   43  #if defined(_WIN32) && !defined(CYGWIN)\n   44  \tchar *buff = NULL;\n   ..\n   83  test_basic(void)\n   84  {\n   85: \tstruct archive *a;\n   86: \tstruct archive_entry *ae;\n   87  \tconst void *p;\n   88  \tchar *initial_cwd, *cwd;\n   ..\n  576  test_symlink_hybrid(void)\n  577  {\n  578: \tstruct archive *a;\n  579: \tstruct archive_entry *ae;\n  580  \tconst void *p;\n  581  \tsize_t size;\n  ...\n  733  test_symlink_logical(void)\n  734  {\n  735: \tstruct archive *a;\n  736: \tstruct archive_entry *ae;\n  737  \tconst void *p;\n  738  \tsize_t size;\n  ...\n  963  test_symlink_logical_loop(void)\n  964  {\n  965: \tstruct archive *a;\n  966: \tstruct archive_entry *ae;\n  967  \tconst void *p;\n  968  \tsize_t size;\n  ...\n 1042  test_restore_atime(void)\n 1043  {\n 1044: \tstruct archive *a;\n 1045: \tstruct archive_entry *ae;\n 1046  \tconst void *p;\n 1047  \tsize_t size;\n ....\n 1307  \n 1308  static int\n 1309: metadata_filter(struct archive *a, void *data, struct archive_entry *ae)\n 1310  {\n 1311  \t(void)data; /* UNUSED */\n ....\n 1333  test_callbacks(void)\n 1334  {\n 1335: \tstruct archive *a;\n 1336: \tstruct archive *m;\n 1337: \tstruct archive_entry *ae;\n 1338  \tconst void *p;\n 1339  \tsize_t size;\n ....\n 1465  test_nodump(void)\n 1466  {\n 1467: \tstruct archive *a;\n 1468: \tstruct archive_entry *ae;\n 1469  \tconst void *p;\n 1470  \tsize_t size;\n ....\n 1601  test_parent(void)\n 1602  {\n 1603: \tstruct archive *a;\n 1604: \tstruct archive_entry *ae;\n 1605  \tconst void *p;\n 1606  \tsize_t size;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_isojoliet_versioned.c:\n   38  {\n   39  \tconst char *refname = \"test_read_format_iso_joliet_by_nero.iso.Z\";\n   40: \tstruct archive_entry *ae;\n   41: \tstruct archive *a;\n   42  \n   43  \textract_reference_file(refname);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_zip_large.c:\n   41  static void *nulldata;\n   42  \n   43: struct fileblock {\n   44: \tstruct fileblock *next;\n   45  \tint\tsize;\n   46  \tvoid *buff;\n   ..\n   48  };\n   49  \n   50: struct fileblocks {\n   51  \tint64_t filesize;\n   52  \tint64_t fileposition;\n   53  \tint64_t gap_remaining;\n   54  \tvoid *buff;\n   55: \tstruct fileblock *first;\n   56: \tstruct fileblock *current;\n   57: \tstruct fileblock *last;\n   58  };\n   59  \n   ..\n   64  #define TB ((int64_t)1024 * GB)\n   65  \n   66: static int64_t\tmemory_read_skip(struct archive *, void *, int64_t request);\n   67: static ssize_t\tmemory_read(struct archive *, void *, const void **buff);\n   68: static ssize_t\tmemory_write(struct archive *, void *, const void *, size_t);\n   69  \n   70  static uint16_t le16(const void *_p) {\n   ..\n   84  \n   85  static ssize_t\n   86: memory_write(struct archive *a, void *_private, const void *buff, size_t size)\n   87  {\n   88: \tstruct fileblocks *private = _private;\n   89: \tstruct fileblock *block;\n   90  \n   91  \t(void)a;\n   ..\n   98  \t\t/* Yes, we're assuming the very first write is metadata. */\n   99  \t\t/* It's header or metadata, copy and save it. */\n  100: \t\tblock = (struct fileblock *)malloc(sizeof(*block));\n  101  \t\tmemset(block, 0, sizeof(*block));\n  102  \t\tblock->size = (int)size;\n  ...\n  116  \n  117  static ssize_t\n  118: memory_read(struct archive *a, void *_private, const void **buff)\n  119  {\n  120: \tstruct fileblocks *private = _private;\n  121  \tssize_t size;\n  122  \n  ...\n  172  \n  173  static int\n  174: memory_read_open(struct archive *a, void *_private)\n  175  {\n  176: \tstruct fileblocks *private = _private;\n  177  \n  178  \t(void)a; /* UNUSED */\n  ...\n  188  \n  189  static int64_t\n  190: memory_read_seek(struct archive *a, void *_private, int64_t offset, int whence)\n  191  {\n  192: \tstruct fileblocks *private = _private;\n  193  \n  194  \t(void)a;\n  ...\n  238  \n  239  static int64_t\n  240: memory_read_skip(struct archive *a, void *_private, int64_t skip)\n  241  {\n  242: \tstruct fileblocks *private = _private;\n  243  \tint64_t old_position = private->fileposition;\n  244  \tint64_t new_position = memory_read_seek(a, _private, skip, SEEK_CUR);\n  ...\n  246  }\n  247  \n  248: static struct fileblocks *\n  249  fileblocks_new(void)\n  250  {\n  251: \tstruct fileblocks *fileblocks;\n  252  \n  253: \tfileblocks = calloc(1, sizeof(struct fileblocks));\n  254  \treturn fileblocks;\n  255  }\n  256  \n  257  static void\n  258: fileblocks_free(struct fileblocks *fileblocks)\n  259  {\n  260  \twhile (fileblocks->first != NULL) {\n  261: \t\tstruct fileblock *b = fileblocks->first;\n  262  \t\tfileblocks->first = fileblocks->first->next;\n  263  \t\tfree(b->buff);\n  ...\n  284  \n  285  static void\n  286: verify_large_zip(struct archive *a, struct fileblocks *fileblocks)\n  287  {\n  288  \tchar namebuff[64];\n  289: \tstruct archive_entry *ae;\n  290  \tint i;\n  291  \n  ...\n  327  \tint i;\n  328  \tchar namebuff[64];\n  329: \tstruct fileblocks *fileblocks = fileblocks_new();\n  330: \tstruct archive_entry *ae;\n  331: \tstruct archive *a;\n  332  \tconst char *p;\n  333  \tconst char *cd_start, *zip64_eocd, *zip64_locator, *eocd;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_solaris_tar_acl.c:\n   35   */\n   36  \n   37: static struct archive_test_acl_t acls0[] = {\n   38  \t{ ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ARCHIVE_ENTRY_ACL_WRITE |\n   39  \t    ARCHIVE_ENTRY_ACL_READ,\n   ..\n   54  };\n   55  \n   56: static struct archive_test_acl_t acls1[] = {\n   57  \t{ ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ARCHIVE_ENTRY_ACL_EXECUTE |\n   58  \t    ARCHIVE_ENTRY_ACL_WRITE | ARCHIVE_ENTRY_ACL_READ,\n   ..\n   74  };\n   75  \n   76: static struct archive_test_acl_t acls2[] = {\n   77  \t{ ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, ARCHIVE_ENTRY_ACL_EXECUTE |\n   78  \t    ARCHIVE_ENTRY_ACL_WRITE | ARCHIVE_ENTRY_ACL_READ,\n   ..\n   94  };\n   95  \n   96: static struct archive_test_acl_t acls3[] = {\n   97  \t{ ARCHIVE_ENTRY_ACL_TYPE_DENY,\n   98  \t    ARCHIVE_ENTRY_ACL_EXECUTE |\n   ..\n  151  };\n  152  \n  153: static struct archive_test_acl_t acls4[] = {\n  154  \t{ ARCHIVE_ENTRY_ACL_TYPE_ALLOW,\n  155  \t    ARCHIVE_ENTRY_ACL_EXECUTE |\n  ...\n  212  {\n  213  \tchar name[] = \"test_compat_solaris_tar_acl.tar\";\n  214: \tstruct archive *a;\n  215: \tstruct archive_entry *ae;\n  216  \n  217  \t/* Read archive file */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_cmdline.c:\n   32  DEFINE_TEST(test_archive_cmdline)\n   33  {\n   34: \tstruct archive_cmdline *cl;\n   35  \n   36  \t/* Command name only. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_zip_empty_zip64.c:\n   33  DEFINE_TEST(test_write_format_zip_empty_zip64)\n   34  {\n   35: \tstruct archive *a;\n   36: \tstruct archive_entry *ae;\n   37  \tchar buff[256];\n   38  \tsize_t used;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_filter_count.c:\n   32  read_test(const char *name)\n   33  {\n   34: \tstruct archive* a = archive_read_new();\n   35  \tint r;\n   36  \n   ..\n   55  {\n   56  \tchar buff[4096];\n   57: \tstruct archive* a = archive_write_new();\n   58  \tint r;\n   59  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cab.c:\n  178  verify(const char *refname, enum comp_type comp)\n  179  {\n  180: \tstruct archive_entry *ae;\n  181: \tstruct archive *a;\n  182  \tchar buff[128];\n  183  \tchar zero[128];\n  ...\n  278  verify2(const char *refname, enum comp_type comp)\n  279  {\n  280: \tstruct archive_entry *ae;\n  281: \tstruct archive *a;\n  282  \tchar buff[128];\n  283  \tchar zero[128];\n  ...\n  344  verify3(const char *refname, enum comp_type comp)\n  345  {\n  346: \tstruct archive_entry *ae;\n  347: \tstruct archive *a;\n  348  \tchar zero[128];\n  349  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_write_set_filter_option.c:\n   33  test(int pristine)\n   34  {\n   35: \tstruct archive* a = archive_write_new();\n   36  \n   37  \tif (!pristine)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_raw.c:\n   26  \n   27  static void\n   28: test_format(int\t(*set_format)(struct archive *))\n   29  {\n   30  \tchar filedata[64];\n   31: \tstruct archive_entry *ae;\n   32: \tstruct archive *a;\n   33  \tsize_t used;\n   34  \tsize_t buffsize = 1000000;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_winzip_aes_large.c:\n   30  {\n   31  \tconst char *refname = \"test_read_format_zip_winzip_aes256_large.zip\";\n   32: \tstruct archive_entry *ae;\n   33: \tstruct archive *a;\n   34  \tchar buff[512];\n   35  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_write_set_options.c:\n   33  test(int pristine)\n   34  {\n   35: \tstruct archive* a = archive_write_new();\n   36  \tint halfempty_options_rv = pristine ? ARCHIVE_FAILED : ARCHIVE_OK;\n   37  \tint known_option_rv = pristine ? ARCHIVE_FAILED : ARCHIVE_OK;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_read_open2.c:\n   27  \n   28  static int\n   29: open_cb(struct archive *a, void *client)\n   30  {\n   31  \t(void)a; /* UNUSED */\n   ..\n   34  }\n   35  static ssize_t\n   36: read_cb(struct archive *a, void *client, const void **buff)\n   37  {\n   38  \t(void)a; /* UNUSED */\n   ..\n   42  }\n   43  static int64_t\n   44: skip_cb(struct archive *a, void *client, int64_t request)\n   45  {\n   46  \t(void)a; /* UNUSED */\n   ..\n   50  }\n   51  static int\n   52: close_cb(struct archive *a, void *client)\n   53  {\n   54  \t(void)a; /* UNUSED */\n   ..\n   62      int rv, const char *msg)\n   63  {\n   64: \tstruct archive* a = archive_read_new();\n   65  \tif (formatted)\n   66  \t    assertEqualInt(ARCHIVE_OK,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_cpio.c:\n   27  \n   28  static void\n   29: test_format(int\t(*set_format)(struct archive *))\n   30  {\n   31  \tchar filedata[64];\n   32: \tstruct archive_entry *ae;\n   33: \tstruct archive *a;\n   34  \tchar *p;\n   35  \tsize_t used;\n   ..\n  242  \n  243  static void\n  244: test_big_entries(int (*set_format)(struct archive *), int64_t size, int expected)\n  245  {\n  246: \tstruct archive_entry *ae;\n  247: \tstruct archive *a;\n  248  \tsize_t buffsize = 1000000;\n  249  \tsize_t used;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_7zip_packinfo_digests.c:\n   29  DEFINE_TEST(test_read_format_7zip_packinfo_digests)\n   30  {\n   31: \tstruct archive_entry *ae;\n   32: \tstruct archive *a;\n   33  \tchar buff[4];\n   34  \tconst char *refname = \"test_read_format_7zip_packinfo_digests.7z\";\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_filename.c:\n   31  {\n   32  \tconst char *refname = \"test_read_format_cpio_filename_eucjp.cpio\";\n   33: \tstruct archive *a;\n   34: \tstruct archive_entry *ae;\n   35  \n   36  \t/*\n   ..\n   86  {\n   87  \tconst char *refname = \"test_read_format_cpio_filename_utf8_jp.cpio\";\n   88: \tstruct archive *a;\n   89: \tstruct archive_entry *ae;\n   90  \n   91  \t/*\n   ..\n  139  {\n  140  \tconst char *refname = \"test_read_format_cpio_filename_utf8_jp.cpio\";\n  141: \tstruct archive *a;\n  142: \tstruct archive_entry *ae;\n  143  \n  144  \t/*\n  ...\n  186  {\n  187  \tconst char *refname = \"test_read_format_cpio_filename_cp866.cpio\";\n  188: \tstruct archive *a;\n  189: \tstruct archive_entry *ae;\n  190  \n  191  \t/*\n  ...\n  239  {\n  240  \tconst char *refname = \"test_read_format_cpio_filename_cp866.cpio\";\n  241: \tstruct archive *a;\n  242: \tstruct archive_entry *ae;\n  243  \n  244  \t/*\n  ...\n  291  {\n  292  \tconst char *refname = \"test_read_format_cpio_filename_koi8r.cpio\";\n  293: \tstruct archive *a;\n  294: \tstruct archive_entry *ae;\n  295  \n  296  \t/*\n  ...\n  344  {\n  345  \tconst char *refname = \"test_read_format_cpio_filename_koi8r.cpio\";\n  346: \tstruct archive *a;\n  347: \tstruct archive_entry *ae;\n  348  \n  349  \t/*\n  ...\n  396  {\n  397  \tconst char *refname = \"test_read_format_cpio_filename_utf8_ru.cpio\";\n  398: \tstruct archive *a;\n  399: \tstruct archive_entry *ae;\n  400  \n  401  \t/*\n  ...\n  449  {\n  450  \tconst char *refname = \"test_read_format_cpio_filename_utf8_ru.cpio\";\n  451: \tstruct archive *a;\n  452: \tstruct archive_entry *ae;\n  453  \n  454  \t/*\n  ...\n  502  {\n  503  \tconst char *refname = \"test_read_format_cpio_filename_utf8_ru.cpio\";\n  504: \tstruct archive *a;\n  505: \tstruct archive_entry *ae;\n  506  \n  507  \t/*\n  ...\n  548  {\n  549  \tconst char *refname = \"test_read_format_cpio_filename_eucjp.cpio\";\n  550: \tstruct archive *a;\n  551: \tstruct archive_entry *ae;\n  552  \n  553  \t/*\n  ...\n  599  {\n  600  \tconst char *refname = \"test_read_format_cpio_filename_utf8_jp.cpio\";\n  601: \tstruct archive *a;\n  602: \tstruct archive_entry *ae;\n  603  \n  604  \t/*\n  ...\n  651  {\n  652  \tconst char *refname = \"test_read_format_cpio_filename_cp866.cpio\";\n  653: \tstruct archive *a;\n  654: \tstruct archive_entry *ae;\n  655  \n  656  \t/*\n  ...\n  710  {\n  711  \tconst char *refname = \"test_read_format_cpio_filename_cp866.cpio\";\n  712: \tstruct archive *a;\n  713: \tstruct archive_entry *ae;\n  714  \n  715  \t/*\n  ...\n  756  {\n  757  \tconst char *refname = \"test_read_format_cpio_filename_koi8r.cpio\";\n  758: \tstruct archive *a;\n  759: \tstruct archive_entry *ae;\n  760  \n  761  \t/*\n  ...\n  809  {\n  810  \tconst char *refname = \"test_read_format_cpio_filename_utf8_ru.cpio\";\n  811: \tstruct archive *a;\n  812: \tstruct archive_entry *ae;\n  813  \n  814  \t/*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_failures.c:\n   31  \tskipping(\"archive_write_disk interface\");\n   32  #else\n   33: \tstruct archive_entry *ae;\n   34: \tstruct archive *a;\n   35  \tint fd;\n   36  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_symlink.c:\n   32  {\n   33  \tstatic const char data[]=\"abcdefghijklmnopqrstuvwxyz\";\n   34: \tstruct archive *ad;\n   35: \tstruct archive_entry *ae;\n   36  \tint r;\n   37  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_mac_metadata.c:\n  109  #else\n  110  \tconst char *refname = \"test_write_disk_mac_metadata.tar.gz\";\n  111: \tstruct archive *ad, *a;\n  112: \tstruct archive_entry *ae;\n  113: \tstruct stat st;\n  114  \tacl_t acl;\n  115  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_xar.c:\n   80  };\n   81  \n   82: static void verify0(struct archive *a, struct archive_entry *ae)\n   83  {\n   84  \tconst void *p;\n   ..\n  103  }\n  104  \n  105: static void verify1(struct archive *a, struct archive_entry *ae)\n  106  {\n  107  \t(void)a; /* UNUSED */\n  ...\n  172  };\n  173  \n  174: static void verify2(struct archive *a, struct archive_entry *ae)\n  175  {\n  176  \t(void)a; /* UNUSED */\n  ...\n  221  };\n  222  \n  223: static void verify3(struct archive *a, struct archive_entry *ae)\n  224  {\n  225  \t(void)a; /* UNUSED */\n  ...\n  271  };\n  272  \n  273: static void verify4(struct archive *a, struct archive_entry *ae)\n  274  {\n  275  \t(void)a; /* UNUSED */\n  ...\n  319  };\n  320  \n  321: static void verify5(struct archive *a, struct archive_entry *ae)\n  322  {\n  323  \t(void)a; /* UNUSED */\n  ...\n  362  };\n  363  \n  364: static void verify6(struct archive *a, struct archive_entry *ae)\n  365  {\n  366  \t(void)a; /* UNUSED */\n  ...\n  424  };\n  425  \n  426: static void verify7(struct archive *a, struct archive_entry *ae)\n  427  {\n  428  \t(void)a; /* UNUSED */\n  ...\n  618  has the corresponding timestamps unset.\n  619  #How to make e.g.\n  620:   struct archive *a = archive_write_new();\n  621    archive_write_set_format_xar(a);\n  622    archive_write_add_filter_none(a);\n  ...\n  625    archive_write_open_memory(a, buff, buffsize, &used);\n  626  \n  627:   struct archive_entry *ae = archive_entry_new();\n  628    archive_entry_copy_pathname(ae, \"file\");\n  629    archive_entry_set_size(ae, 8);\n  ...\n  664  };\n  665  \n  666: static void verify12(struct archive *a, struct archive_entry *ae)\n  667  {\n  668  \t(void)a; /* UNUSED */\n  ...\n  732  \n  733  static void verify(unsigned char *d, size_t s,\n  734:     void (*f1)(struct archive *, struct archive_entry *),\n  735:     void (*f2)(struct archive *, struct archive_entry *),\n  736      enum enc etype)\n  737  {\n  738: \tstruct archive_entry *ae;\n  739: \tstruct archive *a;\n  740  \tunsigned char *buff;\n  741  \tint r;\n  ...\n  798  \n  799  static void verifyB(unsigned char *d, size_t s) {\n  800: \tstruct archive* a;\n  801: \tstruct archive_entry *entry = NULL;\n  802  \tsize_t buf_size;\n  803  \tunsigned char *buf;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_zip_compression_store.c:\n   75  }\n   76  \n   77: static void verify_write_uncompressed(struct archive *a)\n   78  {\n   79: \tstruct archive_entry *entry;\n   80  \n   81  \t/* Write entries. */\n   ..\n  129  \t/* Misc variables */\n  130  \tunsigned long crc;\n  131: \tstruct tm *tm = localtime(&now);\n  132  \n  133  \t/* p is the pointer to walk over the central directory,\n  ...\n  333  {\n  334  \t/* Buffer data */\n  335: \tstruct archive *a;\n  336  \tchar buff[100000];\n  337  \tsize_t used;\n  ...\n  358  \tassertEqualIntA(a, ARCHIVE_OK, archive_write_close(a));\n  359  \tassertEqualInt(ARCHIVE_OK, archive_write_free(a));\n  360: \tdumpfile(\"constructed.zip\", buff, used);\n  361  \n  362  \tverify_uncompressed_contents(buff, used);\n  ...\n  380  \tassertEqualIntA(a, ARCHIVE_OK, archive_write_close(a));\n  381  \tassertEqualInt(ARCHIVE_OK, archive_write_free(a));\n  382: \tdumpfile(\"constructed.zip\", buff, used);\n  383  \n  384  \tverify_uncompressed_contents(buff, used);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_high_compression.c:\n   44  \tchar *p;\n   45  \tsize_t archive_size;\n   46: \tstruct archive *a;\n   47: \tstruct archive_entry *entry;\n   48  \n   49  \tconst void *pv;\n   ..\n  104  \n  105  \tfor(n = 1024; n < (int)body_size; n += 1024) {\n  106: \t\tstruct archive *a;\n  107: \t\tstruct archive_entry *entry;\n  108  \t\tsize_t used = 0;\n  109  \t\tconst void *pv;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_xar_empty.c:\n   34  DEFINE_TEST(test_write_format_xar_empty)\n   35  {\n   36: \tstruct archive *a;\n   37: \tstruct archive_entry *ae;\n   38  \tchar buff[256];\n   39  \tsize_t used;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_encryption_data.c:\n   31  \t   are NOT encrypted. Password is \"12345678\". */\n   32  \tconst char *refname = \"test_read_format_zip_encryption_data.zip\";\n   33: \tstruct archive_entry *ae;\n   34: \tstruct archive *a;\n   35  \tchar buff[128];\n   36  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_filter_b64encode.c:\n   34  DEFINE_TEST(test_write_filter_b64encode)\n   35  {\n   36: \tstruct archive_entry *ae;\n   37: \tstruct archive* a;\n   38  \tchar *buff, *data;\n   39  \tsize_t buffsize, datasize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_warn_missing_hardlink_target.c:\n   27  DEFINE_TEST(test_warn_missing_hardlink_target)\n   28  {\n   29: \tstruct archive *a;\n   30: \tstruct archive_entry *ae;\n   31  \n   32  \tassert(NULL != (a = archive_write_disk_new()));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_zip_filename_encoding.c:\n   30  DEFINE_TEST(test_zip_filename_encoding_UTF8)\n   31  {\n   32:   \tstruct archive *a;\n   33:   \tstruct archive_entry *entry;\n   34  \tchar buff[4096];\n   35  \tsize_t used;\n   ..\n  118  DEFINE_TEST(test_zip_filename_encoding_KOI8R)\n  119  {\n  120:   \tstruct archive *a;\n  121:   \tstruct archive_entry *entry;\n  122  \tchar buff[4096];\n  123  \tsize_t used;\n  ...\n  218  DEFINE_TEST(test_zip_filename_encoding_ru_RU_CP1251)\n  219  {\n  220:   \tstruct archive *a;\n  221:   \tstruct archive_entry *entry;\n  222  \tchar buff[4096];\n  223  \tsize_t used;\n  ...\n  261  DEFINE_TEST(test_zip_filename_encoding_Russian_Russia)\n  262  {\n  263:   \tstruct archive *a;\n  264:   \tstruct archive_entry *entry;\n  265  \tchar buff[4096];\n  266  \tsize_t used;\n  ...\n  330  DEFINE_TEST(test_zip_filename_encoding_EUCJP)\n  331  {\n  332:   \tstruct archive *a;\n  333:   \tstruct archive_entry *entry;\n  334  \tchar buff[4096];\n  335  \tsize_t used;\n  ...\n  429  DEFINE_TEST(test_zip_filename_encoding_CP932)\n  430  {\n  431:   \tstruct archive *a;\n  432:   \tstruct archive_entry *entry;\n  433  \tchar buff[4096];\n  434  \tsize_t used;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_filter_bzip2.c:\n   36  DEFINE_TEST(test_write_filter_bzip2)\n   37  {\n   38: \tstruct archive_entry *ae;\n   39: \tstruct archive* a;\n   40  \tchar *buff, *data;\n   41  \tsize_t buffsize, datasize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_filter_lzop.c:\n   32  \tconst char *n[] = {\n   33  \t\t\"d1/\", \"d1/f2\", \"d1/f3\", \"d1/f1\", \"f1\", \"f2\", \"f3\", NULL };\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tint i, r;\n   37  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_tar_large.c:\n   50   * each possibly followed by bytes of file data.\n   51   */\n   52: struct memblock {\n   53: \tstruct memblock *next;\n   54  \tsize_t\tsize;\n   55  \tvoid *buff;\n   ..\n   61   * some accounting overhead.\n   62   */\n   63: struct memdata {\n   64  \tint64_t filebytes;\n   65  \tvoid *buff;\n   66: \tstruct memblock *first;\n   67: \tstruct memblock *last;\n   68  };\n   69  \n   ..\n   74  #define TB ((int64_t)1024 * GB)\n   75  \n   76: static int64_t\tmemory_read_skip(struct archive *, void *, int64_t request);\n   77: static ssize_t\tmemory_read(struct archive *, void *, const void **buff);\n   78: static ssize_t\tmemory_write(struct archive *, void *, const void *, size_t);\n   79  \n   80  \n   81  static ssize_t\n   82: memory_write(struct archive *a, void *_private, const void *buff, size_t size)\n   83  {\n   84: \tstruct memdata *private = _private;\n   85: \tstruct memblock *block;\n   86  \n   87  \t(void)a;\n   ..\n  101  \t\t/* Yes, we're assuming the very first write is metadata. */\n  102  \t\t/* It's header or metadata, copy and save it. */\n  103: \t\tblock = (struct memblock *)malloc(sizeof(*block));\n  104  \t\tmemset(block, 0, sizeof(*block));\n  105  \t\tblock->size = size;\n  ...\n  118  \n  119  static ssize_t\n  120: memory_read(struct archive *a, void *_private, const void **buff)\n  121  {\n  122: \tstruct memdata *private = _private;\n  123: \tstruct memblock *block;\n  124  \tssize_t size;\n  125  \n  ...\n  165  \n  166  static int64_t\n  167: memory_read_skip(struct archive *a, void *_private, int64_t skip)\n  168  {\n  169: \tstruct memdata *private = _private;\n  170  \n  171  \t(void)a;\n  ...\n  201  \tint i;\n  202  \tchar namebuff[64];\n  203: \tstruct memdata memdata;\n  204: \tstruct archive_entry *ae;\n  205: \tstruct archive *a;\n  206  \tint64_t  filesize;\n  207  \tsize_t writesize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_secure744.c:\n   38  \tskipping(\"archive_write_disk security checks not supported on Windows\");\n   39  #else\n   40: \tstruct archive *a;\n   41: \tstruct archive_entry *ae;\n   42  \tsize_t buff_size = 8192;\n   43  \tchar *buff = malloc(buff_size);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_7zip_empty.c:\n   33  DEFINE_TEST(test_write_format_7zip_empty_archive)\n   34  {\n   35: \tstruct archive *a;\n   36  \tsize_t buffsize = 1000;\n   37  \tchar *buff;\n   ..\n   70  test_only_empty_file(void)\n   71  {\n   72: \tstruct archive *a;\n   73: \tstruct archive_entry *ae;\n   74  \tsize_t buffsize = 1000;\n   75  \tchar *buff;\n   ..\n  159  test_only_empty_files(void)\n  160  {\n  161: \tstruct archive *a;\n  162: \tstruct archive_entry *ae;\n  163  \tsize_t buffsize = 1000;\n  164  \tchar *buff;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_winzip_aes.c:\n   30  test_winzip_aes(const char *refname, int need_libz)\n   31  {\n   32: \tstruct archive_entry *ae;\n   33: \tstruct archive *a;\n   34  \tchar buff[512];\n   35  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_tar_concatenated.c:\n   36  {\n   37  \tchar name[] = \"test_read_format_tar_concatenated.tar\";\n   38: \tstruct archive_entry *ae;\n   39: \tstruct archive *a;\n   40  \n   41  \t/*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_txz.c:\n   41  DEFINE_TEST(test_read_format_txz)\n   42  {\n   43: \tstruct archive_entry *ae;\n   44: \tstruct archive *a;\n   45  \tint r;\n   46  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_acl_platform_nfs4.c:\n   39  #endif\n   40  \n   41: struct myacl_t {\n   42  \tint type;\n   43  \tint permset;\n   ..\n   47  };\n   48  \n   49: static struct myacl_t acls_reg[] = {\n   50  #if !ARCHIVE_ACL_DARWIN\n   51  \t/* For this test, we need the file owner to be able to read and write the ACL. */\n   ..\n  136  static const int acls_reg_cnt = (int)(sizeof(acls_reg)/sizeof(acls_reg[0]));\n  137  \n  138: static struct myacl_t acls_dir[] = {\n  139  \t/* For this test, we need to be able to read and write the ACL. */\n  140  #if !ARCHIVE_ACL_DARWIN\n  ...\n  257  \n  258  static void\n  259: set_acls(struct archive_entry *ae, struct myacl_t *acls, int start, int end)\n  260  {\n  261  \tint i;\n  ...\n  287  #endif\n  288  {\n  289: \tstatic struct { int portable; int machine; } perms[] = {\n  290  #ifdef ARCHIVE_ACL_SUNOS_NFS4\t/* Solaris NFSv4 ACL permissions */\n  291  \t\t{ARCHIVE_ENTRY_ACL_EXECUTE, ACE_EXECUTE},\n  ...\n  385  #endif\n  386  {\n  387: \tstatic struct { int portable; int machine; } perms[] = {\n  388  #if ARCHIVE_ACL_SUNOS_NFS4\t/* Solaris NFSv4 ACL inheritance flags */\n  389  \t\t{ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT, ACE_FILE_INHERIT_ACE},\n  ...\n  434  #if ARCHIVE_ACL_SUNOS_NFS4\n  435  static int\n  436: acl_match(ace_t *ace, struct myacl_t *myacl)\n  437  {\n  438  \tint perms;\n  ...\n  488  #elif ARCHIVE_ACL_LIBRICHACL\n  489  static int\n  490: acl_match(struct richace *richace, struct myacl_t *myacl)\n  491  {\n  492  \tint perms;\n  ...\n  544  #elif ARCHIVE_ACL_DARWIN\n  545  static int\n  546: acl_match(acl_entry_t aclent, struct myacl_t *myacl)\n  547  {\n  548  \tvoid *q;\n  ...\n  603  #else /* ARCHIVE_ACL_FREEBSD_NFS4 */\n  604  static int\n  605: acl_match(acl_entry_t aclent, struct myacl_t *myacl)\n  606  {\n  607  \tgid_t g, *gp;\n  ...\n  686      int aclcnt,\n  687  #elif ARCHIVE_ACL_LIBRICHACL\n  688:     struct richacl *richacl,\n  689  #else\n  690      acl_t acl,\n  691  #endif\n  692:     struct myacl_t *myacls, const char *filename, int start, int end)\n  693  {\n  694  \tint *marker;\n  ...\n  700  #elif ARCHIVE_ACL_LIBRICHACL\n  701  \tint e;\n  702: \tstruct richace *acl_entry;\n  703  \tint aclcnt;\n  704  #else\n  ...\n  783  \n  784  static void\n  785: compare_entry_acls(struct archive_entry *ae, struct myacl_t *myacls, const char *filename, int start, int end)\n  786  {\n  787  \tint *marker;\n  ...\n  855  \tchar buff[64];\n  856  \tint i;\n  857: \tstruct stat st;\n  858: \tstruct archive *a;\n  859: \tstruct archive_entry *ae;\n  860  #if ARCHIVE_ACL_DARWIN /* On MacOS we skip trivial ACLs in some tests */\n  861  \tconst int regcnt = acls_reg_cnt - 4;\n  ...\n  869  \tint aclcnt;\n  870  #elif ARCHIVE_ACL_LIBRICHACL\n  871: \tstruct richacl *richacl;\n  872  #else\t/* !ARCHIVE_ACL_SUNOS_NFS4 */\n  873  \tacl_t acl;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_pax.c:\n   32  \tsize_t buffsize = 1000000;\n   33  \tchar *buff;\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tsize_t used;\n   37  \tint i;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_truncated.c:\n   31  DEFINE_TEST(test_read_truncated)\n   32  {\n   33: \tstruct archive_entry *ae;\n   34: \tstruct archive *a;\n   35  \tunsigned int i;\n   36  \tsize_t used;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_read_next_header_raw.c:\n   34  test(int skip_explicitely)\n   35  {\n   36: \tstruct archive* a = archive_read_new();\n   37: \tstruct archive_entry* e;\n   38  \n   39  \tassertEqualInt(ARCHIVE_OK, archive_read_support_format_raw(a));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_mtree_quoted_filename.c:\n   38  DEFINE_TEST(test_write_format_mtree_quoted_filename)\n   39  {\n   40: \tstruct archive_entry *ae;\n   41: \tstruct archive* a;\n   42  \tsize_t used;\n   43  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_write_add_filter_by_name.c:\n   32      int (*can_filter_prog)(void))\n   33  {\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tsize_t used;\n   37  \tsize_t buffsize = 1024 * 128;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_file_nonexistent.c:\n   28  DEFINE_TEST(test_read_file_nonexistent)\n   29  {\n   30: \tstruct archive* a = archive_read_new();\n   31  \tassertEqualInt(ARCHIVE_OK, archive_read_support_format_all(a));\n   32  \tassertEqualInt(ARCHIVE_FATAL,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_lookup.c:\n   70  DEFINE_TEST(test_write_disk_lookup)\n   71  {\n   72: \tstruct archive *a;\n   73  \tint gmagic = 0x13579, umagic = 0x1234;\n   74  \tint64_t id;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_acl_posix1e.c:\n   35   */\n   36  \n   37: static struct archive_test_acl_t acls0[] = {\n   38  \t{ ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ARCHIVE_ENTRY_ACL_EXECUTE,\n   39  \t  ARCHIVE_ENTRY_ACL_USER_OBJ, 0, \"\" },\n   ..\n   44  };\n   45  \n   46: static struct archive_test_acl_t acls1[] = {\n   47  \t{ ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ARCHIVE_ENTRY_ACL_EXECUTE,\n   48  \t  ARCHIVE_ENTRY_ACL_USER_OBJ, -1, \"\" },\n   ..\n   55  };\n   56  \n   57: static struct archive_test_acl_t acls2[] = {\n   58  \t{ ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ARCHIVE_ENTRY_ACL_EXECUTE | ARCHIVE_ENTRY_ACL_READ,\n   59  \t  ARCHIVE_ENTRY_ACL_USER_OBJ, -1, \"\" },\n   ..\n   74   * attributes should fail.\n   75   */\n   76: static struct archive_test_acl_t acls_nfs4[] = {\n   77  \t/* NFS4 types */\n   78  \t{ ARCHIVE_ENTRY_ACL_TYPE_ALLOW, ARCHIVE_ENTRY_ACL_READ,\n   ..\n  100  DEFINE_TEST(test_acl_posix1e)\n  101  {\n  102: \tstruct archive_entry *ae;\n  103  \tint i;\n  104  \n  ...\n  168  \tassertEntrySetAcls(ae, acls2, sizeof(acls2)/sizeof(acls2[0]));\n  169  \tfor (i = 0; i < (int)(sizeof(acls_nfs4)/sizeof(acls_nfs4[0])); ++i) {\n  170: \t\tstruct archive_test_acl_t *p = &acls_nfs4[i];\n  171  \t\tfailure(\"Malformed ACL test #%d\", i);\n  172  \t\tassertEqualInt(ARCHIVE_FAILED,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_plexus_archiver_tar.c:\n   37  {\n   38  \tchar name[] = \"test_compat_plexus_archiver_tar.tar\";\n   39: \tstruct archive_entry *ae;\n   40: \tstruct archive *a;\n   41  \tint r;\n   42  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_read_set_filter_option.c:\n   33  test(int pristine)\n   34  {\n   35: \tstruct archive* a = archive_read_new();\n   36  \n   37  \tif (!pristine)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_no_hfs_compression.c:\n   78  #else\n   79  \tconst char *refname = \"test_write_disk_no_hfs_compression.tgz\";\n   80: \tstruct archive *ad, *a;\n   81: \tstruct archive_entry *ae;\n   82: \tstruct stat st;\n   83  \n   84  \textract_reference_file(refname);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_iso9660_boot.c:\n   91  {\n   92  \tunsigned char nullb[2048];\n   93: \tstruct archive *a;\n   94: \tstruct archive_entry *ae;\n   95  \tunsigned char *buff;\n   96  \tsize_t buffsize = 39 * 2048;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_read_close_twice.c:\n   30  DEFINE_TEST(test_archive_read_close_twice)\n   31  {\n   32: \tstruct archive* a = archive_read_new();\n   33  \n   34  \tassertEqualInt(0, archive_read_close(a));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_tar_filenames.c:\n   38  \tchar filename[400];\n   39  \tchar dirname[400];\n   40: \tstruct archive_entry *ae;\n   41: \tstruct archive *a;\n   42  \tsize_t used;\n   43  \tchar *p;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_7zip_large.c:\n   32  test_large(const char *compression_type)\n   33  {\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tsize_t used;\n   37  \tsize_t buffsize = LARGE_SIZE + 1024 * 256;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_tar_filename.c:\n   41  test_read_format_tar_filename_KOI8R_CP866(const char *refname)\n   42  {\n   43: \tstruct archive *a;\n   44: \tstruct archive_entry *ae;\n   45  \n   46  \t/*\n   ..\n  159  test_read_format_tar_filename_KOI8R_UTF8(const char *refname)\n  160  {\n  161: \tstruct archive *a;\n  162: \tstruct archive_entry *ae;\n  163  \n  164  \t/*\n  ...\n  270  test_read_format_tar_filename_KOI8R_CP1251(const char *refname)\n  271  {\n  272: \tstruct archive *a;\n  273: \tstruct archive_entry *ae;\n  274  \n  275  \t/*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_pax_truncated.c:\n   28  DEFINE_TEST(test_read_pax_truncated)\n   29  {\n   30: \tstruct archive_entry *ae;\n   31: \tstruct archive *a;\n   32  \tsize_t used, i, buff_size = 1000000;\n   33  \tsize_t filedata_size = 100000;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_bin_xz.c:\n   47  DEFINE_TEST(test_read_format_cpio_bin_xz)\n   48  {\n   49: \tstruct archive_entry *ae;\n   50: \tstruct archive *a;\n   51  \tint r;\n   52  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_extattr_freebsd.c:\n   45  \tconst void *xval;\n   46  \tsize_t xsize;\n   47: \tstruct stat st;\n   48: \tstruct archive *a;\n   49: \tstruct archive_entry *ae;\n   50  \tint n, fd;\n   51  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_hardlink.c:\n   48  #else\n   49  \tstatic const char data[]=\"abcdefghijklmnopqrstuvwxyz\";\n   50: \tstruct archive *ad;\n   51: \tstruct archive_entry *ae;\n   52  #ifdef HAVE_LINKAT\n   53  \tint can_symlink;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_pax_bz2.c:\n   43  DEFINE_TEST(test_read_format_pax_bz2)\n   44  {\n   45: \tstruct archive_entry *ae;\n   46: \tstruct archive *a;\n   47  \tint r;\n   48  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_zip_file_zip64.c:\n   73  DEFINE_TEST(test_write_format_zip_file_zip64)\n   74  {\n   75: \tstruct archive *a;\n   76: \tstruct archive_entry *ae;\n   77  \ttime_t t = 1234567890;\n   78: \tstruct tm *tm = localtime(&t);\n   79  \tsize_t used, buffsize = 1000000;\n   80  \tunsigned long crc;\n   ..\n  118  \tassertEqualInt(ARCHIVE_OK, archive_write_free(a));\n  119  \tbuffend = buff + used;\n  120: \tdumpfile(\"constructed.zip\", buff, used);\n  121  \n  122  \t/* Verify \"End of Central Directory\" record. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_bin.c:\n   45  DEFINE_TEST(test_read_format_cpio_bin)\n   46  {\n   47: \tstruct archive_entry *ae;\n   48: \tstruct archive *a;\n   49  \tassert((a = archive_read_new()) != NULL);\n   50  \tassertEqualIntA(a, 0, archive_read_support_filter_all(a));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_mtree_fflags.c:\n   37  \n   38  static char buff[4096];\n   39: static struct {\n   40  \tconst char\t*path;\n   41  \tunsigned long\t fflags;\n   ..\n   51  test_write_format_mtree_sub(int use_set)\n   52  {\n   53: \tstruct archive_entry *ae;\n   54: \tstruct archive* a;\n   55  \tsize_t used;\n   56  \tint i;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_encryption_partially.c:\n   32  \t   on this file. */\n   33  \tconst char *refname = \"test_read_format_zip_encryption_partially.zip\";\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tchar buff[128];\n   37  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_short_writes.c:\n   32   * This test checks whether things work correctly when the archive_write_callback\n   33   * passed to archive_write_open() does a short write and only writes some of the\n   34:  * data passed in. The way the test works is that two archives are constructed\n   35   * in parallel - one with short writes, one with full writes - and the results\n   36   * are compared to see if they are identical.\n   37   */\n   38  \n   39: struct checker {\n   40:         struct archive *short_archive;\n   41          char *shortbuf;\n   42          size_t shortbuf_len;\n   43  \n   44:         struct archive *full_archive;\n   45          char *fullbuf;\n   46          size_t fullbuf_len;\n   ..\n   48  \n   49  static ssize_t\n   50: short_write_callback(struct archive *a, void *client_data, const void *buffer, size_t length)\n   51  {\n   52          (void)a;\n   53  \n   54:         struct checker *checker = client_data;\n   55          size_t to_write = length < 100 ? length : 100;\n   56          size_t new_len = checker->shortbuf_len + to_write;\n   ..\n   66  \n   67  static ssize_t\n   68: full_write_callback(struct archive *a, void *client_data, const void *buffer, size_t length)\n   69  {\n   70          (void)a;\n   71  \n   72:         struct checker *checker = client_data;\n   73          size_t to_write = length;\n   74          size_t new_len = checker->fullbuf_len + to_write;\n   ..\n   83  }\n   84  \n   85: static struct archive *\n   86: create_archive(struct checker *checker, archive_write_callback write_cb, int buffered)\n   87  {\n   88:         struct archive *a;\n   89  \n   90          assert((a = archive_write_new()) != NULL);\n   ..\n  115  }\n  116  \n  117: static struct checker *\n  118  checker_new(int buffered)\n  119  {\n  120:         struct checker *checker;\n  121  \n  122          assert ((checker = calloc(1, sizeof *checker)) != NULL);\n  ...\n  129  \n  130  static void\n  131: checker_add_file(struct checker *checker, const char *name, char *buffer, size_t len)\n  132  {\n  133:         struct archive_entry *entry;\n  134          assert((entry = archive_entry_new()) != NULL);\n  135  \n  ...\n  152  \n  153  static void\n  154: checker_close(struct checker *checker)\n  155  {\n  156          assertEqualIntA(checker->short_archive, ARCHIVE_OK,\n  ...\n  161  \n  162  static void\n  163: checker_check(struct checker *checker)\n  164  {\n  165          assertEqualInt(checker->shortbuf_len, checker->fullbuf_len);\n  ...\n  168  \n  169  static void\n  170: checker_free(struct checker *checker)\n  171  {\n  172          free(checker->shortbuf);\n  ...\n  177  DEFINE_TEST(test_short_writes)\n  178  {\n  179:         struct checker *checker;\n  180          uint16_t test_data[16384];\n  181          int i;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_gnutar_filename_encoding.c:\n   30  DEFINE_TEST(test_gnutar_filename_encoding_UTF8_CP866)\n   31  {\n   32:   \tstruct archive *a;\n   33:   \tstruct archive_entry *entry;\n   34  \tchar buff[4096];\n   35  \tsize_t used;\n   ..\n   71  DEFINE_TEST(test_gnutar_filename_encoding_KOI8R_UTF8)\n   72  {\n   73:   \tstruct archive *a;\n   74:   \tstruct archive_entry *entry;\n   75  \tchar buff[4096];\n   76  \tsize_t used;\n   ..\n  112  DEFINE_TEST(test_gnutar_filename_encoding_KOI8R_CP866)\n  113  {\n  114:   \tstruct archive *a;\n  115:   \tstruct archive_entry *entry;\n  116  \tchar buff[4096];\n  117  \tsize_t used;\n  ...\n  153  DEFINE_TEST(test_gnutar_filename_encoding_CP1251_UTF8)\n  154  {\n  155:   \tstruct archive *a;\n  156:   \tstruct archive_entry *entry;\n  157  \tchar buff[4096];\n  158  \tsize_t used;\n  ...\n  198  DEFINE_TEST(test_gnutar_filename_encoding_ru_RU_CP1251)\n  199  {\n  200:   \tstruct archive *a;\n  201:   \tstruct archive_entry *entry;\n  202  \tchar buff[4096];\n  203  \tsize_t used;\n  ...\n  238  DEFINE_TEST(test_gnutar_filename_encoding_Russian_Russia)\n  239  {\n  240:   \tstruct archive *a;\n  241:   \tstruct archive_entry *entry;\n  242  \tchar buff[4096];\n  243  \tsize_t used;\n  ...\n  273  DEFINE_TEST(test_gnutar_filename_encoding_EUCJP_UTF8)\n  274  {\n  275:   \tstruct archive *a;\n  276:   \tstruct archive_entry *entry;\n  277  \tchar buff[4096];\n  278  \tsize_t used;\n  ...\n  313  DEFINE_TEST(test_gnutar_filename_encoding_EUCJP_CP932)\n  314  {\n  315:   \tstruct archive *a;\n  316:   \tstruct archive_entry *entry;\n  317  \tchar buff[4096];\n  318  \tsize_t used;\n  ...\n  353  DEFINE_TEST(test_gnutar_filename_encoding_CP932_UTF8)\n  354  {\n  355:   \tstruct archive *a;\n  356:   \tstruct archive_entry *entry;\n  357  \tchar buff[4096];\n  358  \tsize_t used;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_svr4_gzip.c:\n   35  DEFINE_TEST(test_read_format_cpio_svr4_gzip)\n   36  {\n   37: \tstruct archive_entry *ae;\n   38: \tstruct archive *a;\n   39  \tint r;\n   40  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_filter_uuencode.c:\n   34  DEFINE_TEST(test_write_filter_uuencode)\n   35  {\n   36: \tstruct archive_entry *ae;\n   37: \tstruct archive* a;\n   38  \tchar *buff, *data;\n   39  \tsize_t buffsize, datasize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_lha_filename_utf16.c:\n   31  test_read_format_lha_filename_UTF16_UTF8(const char *refname)\n   32  {\n   33: \tstruct archive *a;\n   34: \tstruct archive_entry *ae;\n   35  \n   36  \t/*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_ustar_filename_encoding.c:\n   30  DEFINE_TEST(test_ustar_filename_encoding_UTF8_CP866)\n   31  {\n   32:   \tstruct archive *a;\n   33:   \tstruct archive_entry *entry;\n   34  \tchar buff[4096];\n   35  \tsize_t used;\n   ..\n   71  DEFINE_TEST(test_ustar_filename_encoding_KOI8R_UTF8)\n   72  {\n   73:   \tstruct archive *a;\n   74:   \tstruct archive_entry *entry;\n   75  \tchar buff[4096];\n   76  \tsize_t used;\n   ..\n  112  DEFINE_TEST(test_ustar_filename_encoding_KOI8R_CP866)\n  113  {\n  114:   \tstruct archive *a;\n  115:   \tstruct archive_entry *entry;\n  116  \tchar buff[4096];\n  117  \tsize_t used;\n  ...\n  153  DEFINE_TEST(test_ustar_filename_encoding_CP1251_UTF8)\n  154  {\n  155:   \tstruct archive *a;\n  156:   \tstruct archive_entry *entry;\n  157  \tchar buff[4096];\n  158  \tsize_t used;\n  ...\n  198  DEFINE_TEST(test_ustar_filename_encoding_ru_RU_CP1251)\n  199  {\n  200:   \tstruct archive *a;\n  201:   \tstruct archive_entry *entry;\n  202  \tchar buff[4096];\n  203  \tsize_t used;\n  ...\n  238  DEFINE_TEST(test_ustar_filename_encoding_Russian_Russia)\n  239  {\n  240:   \tstruct archive *a;\n  241:   \tstruct archive_entry *entry;\n  242  \tchar buff[4096];\n  243  \tsize_t used;\n  ...\n  273  DEFINE_TEST(test_ustar_filename_encoding_EUCJP_UTF8)\n  274  {\n  275:   \tstruct archive *a;\n  276:   \tstruct archive_entry *entry;\n  277  \tchar buff[4096];\n  278  \tsize_t used;\n  ...\n  313  DEFINE_TEST(test_ustar_filename_encoding_EUCJP_CP932)\n  314  {\n  315:   \tstruct archive *a;\n  316:   \tstruct archive_entry *entry;\n  317  \tchar buff[4096];\n  318  \tsize_t used;\n  ...\n  353  DEFINE_TEST(test_ustar_filename_encoding_CP932_UTF8)\n  354  {\n  355:   \tstruct archive *a;\n  356:   \tstruct archive_entry *entry;\n  357  \tchar buff[4096];\n  358  \tsize_t used;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_7075_utf8_paths.c:\n   31  \n   32  static void\n   33: verify(struct archive *a) {\n   34: \tstruct archive_entry *ae;\n   35  \tconst char *p;\n   36  \n   ..\n   70  {\n   71  \tconst char *refname = \"test_read_format_zip_7075_utf8_paths.zip\";\n   72: \tstruct archive *a;\n   73  \tchar *p;\n   74  \tsize_t s;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_isozisofs_bz2.c:\n   55  {\n   56  \tconst char *refname = \"test_read_format_iso_zisofs.iso.Z\";\n   57: \tstruct archive_entry *ae;\n   58: \tstruct archive *a;\n   59  \tconst void *p;\n   60  \tsize_t size;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_gzip.c:\n   43  {\n   44  \tconst char *n[7] = { \"f1\", \"f2\", \"f3\", \"d1/f1\", \"d1/f2\", \"d1/f3\", NULL };\n   45: \tstruct archive_entry *ae;\n   46: \tstruct archive *a;\n   47  \tint i,r;\n   48  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_bad_fd.c:\n   29  DEFINE_TEST(test_bad_fd)\n   30  {\n   31: \tstruct archive *a;\n   32  \tassert((a = archive_read_new()) != NULL);\n   33  \tassertA(0 == archive_read_support_filter_all(a));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_write_set_format_filter_by_ext.c:\n   33      int format_id, int filter_id, int dot_stored, const char * def_ext)\n   34  {\n   35: \tstruct archive_entry *ae;\n   36: \tstruct archive *a;\n   37  \tsize_t used;\n   38  \tsize_t buffsize = 1024 * 1024;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_lzma.c:\n  103  {\n  104  \tconst char *n[7] = { \"f1\", \"f2\", \"f3\", \"d1/f1\", \"d1/f2\", \"d1/f3\", NULL };\n  105: \tstruct archive_entry *ae;\n  106: \tstruct archive *a;\n  107  \tint i, r;\n  108  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_warc.c:\n   27  __FBSDID(\"$FreeBSD$\");\n   28  \n   29: static void test_read(struct archive *a, char *buff, size_t used, char *filedata)\n   30  {\n   31: \tstruct archive_entry *ae;\n   32  \tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_none(a));\n   33  \tassertEqualIntA(a, ARCHIVE_OK, archive_read_open_memory(a, buff, used));\n   ..\n   43  {\n   44  \tchar filedata[64];\n   45: \tstruct archive *a;\n   46: \tstruct archive_entry *ae;\n   47  \tconst size_t bsiz = 2048U;\n   48  \tchar *buff;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_mtree_crash747.c:\n   32  {\n   33  \tconst char *reffile = \"test_read_format_mtree_crash747.mtree.bz2\";\n   34: \tstruct archive *a;\n   35  \n   36  \tif (archive_bzlib_version() == NULL) {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip.c:\n   31  \n   32  static\n   33: int extract_one(struct archive* a, struct archive_entry* ae, uint32_t crc)\n   34  {\n   35  \tla_ssize_t fsize, bytes_read;\n   ..\n   59  \n   60  static\n   61: int extract_one_using_blocks(struct archive* a, int block_size, uint32_t crc)\n   62  {\n   63  \tuint8_t* buf;\n   ..\n  103   */\n  104  static void\n  105: verify_basic(struct archive *a, int seek_checks)\n  106  {\n  107: \tstruct archive_entry *ae;\n  108  \tchar *buff[128];\n  109  \tconst void *pv;\n  ...\n  181  {\n  182  \tconst char *refname = \"test_read_format_zip.zip\";\n  183: \tstruct archive *a;\n  184  \tchar *p;\n  185  \tsize_t s;\n  ...\n  209   */\n  210  static void\n  211: verify_info_zip_ux(struct archive *a, int seek_checks)\n  212  {\n  213: \tstruct archive_entry *ae;\n  214  \tchar *buff[128];\n  215  \n  ...\n  251  {\n  252  \tconst char *refname = \"test_read_format_zip_ux.zip\";\n  253: \tstruct archive *a;\n  254  \tchar *p;\n  255  \tsize_t s;\n  ...\n  279   */\n  280  static void\n  281: verify_extract_length_at_end(struct archive *a, int seek_checks)\n  282  {\n  283: \tstruct archive_entry *ae;\n  284  \n  285  \tassertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));\n  ...\n  317  \tchar *p;\n  318  \tsize_t s;\n  319: \tstruct archive *a;\n  320  \n  321  \textract_reference_file(refname);\n  ...\n  344  \tchar *p;\n  345  \tsize_t s;\n  346: \tstruct archive *a;\n  347: \tstruct archive_entry *ae;\n  348  \n  349  \textract_reference_file(refname);\n  ...\n  387  {\n  388  \tconst char *refname = \"test_read_format_zip_ppmd8.zipx\";\n  389: \tstruct archive *a;\n  390: \tstruct archive_entry *ae;\n  391  \n  392  \textract_reference_file(refname);\n  ...\n  407  {\n  408  \tconst char *refname = \"test_read_format_zip_ppmd8.zipx\";\n  409: \tstruct archive *a;\n  410: \tstruct archive_entry *ae;\n  411  \n  412  \textract_reference_file(refname);\n  ...\n  427  {\n  428  \tconst char *refname = \"test_read_format_zip_ppmd8_multi.zipx\";\n  429: \tstruct archive *a;\n  430: \tstruct archive_entry *ae;\n  431  \n  432  \textract_reference_file(refname);\n  ...\n  459  {\n  460  \tconst char *refname = \"test_read_format_zip_ppmd8_multi.zipx\";\n  461: \tstruct archive *a;\n  462: \tstruct archive_entry *ae;\n  463  \n  464  \textract_reference_file(refname);\n  ...\n  491  {\n  492  \tconst char *refname = \"test_read_format_zip_lzma.zipx\";\n  493: \tstruct archive *a;\n  494: \tstruct archive_entry *ae;\n  495  \n  496  \tassert((a = archive_read_new()) != NULL);\n  ...\n  516  {\n  517  \tconst char *refname = \"test_read_format_zip_lzma.zipx\";\n  518: \tstruct archive *a;\n  519: \tstruct archive_entry *ae;\n  520  \n  521  \tassert((a = archive_read_new()) != NULL);\n  ...\n  541  {\n  542  \tconst char *refname = \"test_read_format_zip_lzma_multi.zipx\";\n  543: \tstruct archive *a;\n  544: \tstruct archive_entry *ae;\n  545  \n  546  \tassert((a = archive_read_new()) != NULL);\n  ...\n  578  {\n  579  \tconst char *refname = \"test_read_format_zip_lzma_multi.zipx\";\n  580: \tstruct archive *a;\n  581: \tstruct archive_entry *ae;\n  582  \n  583  \tassert((a = archive_read_new()) != NULL);\n  ...\n  616  {\n  617  \tconst char *refname = \"test_read_format_zip_bzip2.zipx\";\n  618: \tstruct archive *a;\n  619: \tstruct archive_entry *ae;\n  620  \n  621  \tassert((a = archive_read_new()) != NULL);\n  ...\n  641  {\n  642  \tconst char *refname = \"test_read_format_zip_bzip2.zipx\";\n  643: \tstruct archive *a;\n  644: \tstruct archive_entry *ae;\n  645  \n  646  \tassert((a = archive_read_new()) != NULL);\n  ...\n  666  {\n  667  \tconst char *refname = \"test_read_format_zip_bzip2_multi.zipx\";\n  668: \tstruct archive *a;\n  669: \tstruct archive_entry *ae;\n  670  \n  671  \tassert((a = archive_read_new()) != NULL);\n  ...\n  703  {\n  704  \tconst char *refname = \"test_read_format_zip_bzip2_multi.zipx\";\n  705: \tstruct archive *a;\n  706: \tstruct archive_entry *ae;\n  707  \n  708  \tassert((a = archive_read_new()) != NULL);\n  ...\n  740  {\n  741  \tconst char *refname = \"test_read_format_zip_xz_multi.zipx\";\n  742: \tstruct archive *a;\n  743: \tstruct archive_entry *ae;\n  744  \n  745  \tassert((a = archive_read_new()) != NULL);\n  ...\n  777  {\n  778  \tconst char *refname = \"test_read_format_zip_xz_multi.zipx\";\n  779: \tstruct archive *a;\n  780: \tstruct archive_entry *ae;\n  781  \n  782  \tassert((a = archive_read_new()) != NULL);\n  ...\n  814  {\n  815  \tconst char *refname = \"test_read_format_zip_ppmd8_crash_2.zipx\";\n  816: \tstruct archive *a;\n  817: \tstruct archive_entry *ae;\n  818  \tchar buf[64];\n  819  \n  ...\n  836  {\n  837  \tconst char *refname = \"test_read_format_zip_bz2_hang.zip\";\n  838: \tstruct archive *a;\n  839: \tstruct archive_entry *ae;\n  840  \tchar buf[8];\n  841  \n  ...\n  862  {\n  863  \tconst char *refname = \"test_read_format_zip_ppmd8_crash_2.zipx\";\n  864: \tstruct archive *a;\n  865: \tstruct archive_entry *ae;\n  866  \tchar buf[64];\n  867  \n  ...\n  883  {\n  884  \tconst char *refname = \"test_read_format_zip_lzma_alone_leak.zipx\";\n  885: \tstruct archive *a;\n  886: \tstruct archive_entry *ae;\n  887  \tchar buf[64];\n  888  \n  ...\n  921  {\n  922  \tconst char *refname = \"test_read_format_zip_lzma_stream_end.zipx\";\n  923: \tstruct archive *a;\n  924: \tstruct archive_entry *ae;\n  925  \n  926  \tassert((a = archive_read_new()) != NULL);\n  ...\n  946  {\n  947  \tconst char *refname = \"test_read_format_zip_lzma_stream_end.zipx\";\n  948: \tstruct archive *a;\n  949: \tstruct archive_entry *ae;\n  950  \n  951  \tassert((a = archive_read_new()) != NULL);\n  ...\n  971  {\n  972  \tconst char *refname = \"test_read_format_zip_7z_lzma.zip\";\n  973: \tstruct archive_entry *ae;\n  974: \tstruct archive *a;\n  975  \n  976  \tassert((a = archive_read_new()) != NULL);\n  ...\n 1003  {\n 1004  \tconst char *refname = \"test_read_format_zip_7z_deflate.zip\";\n 1005: \tstruct archive_entry *ae;\n 1006: \tstruct archive *a;\n 1007  \n 1008  \tassert((a = archive_read_new()) != NULL);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_gtar_lzma.c:\n   42  \tint r;\n   43  \n   44: \tstruct archive_entry *ae;\n   45: \tstruct archive *a;\n   46  \tassert((a = archive_read_new()) != NULL);\n   47  \tassertEqualIntA(a, ARCHIVE_OK,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_read_support.c:\n   32   */\n   33  \n   34: typedef struct archive *constructor(void);\n   35: typedef int enabler(struct archive *);\n   36: typedef int destructor(struct archive *);\n   37  \n   38  static int format_code = 0;\n   39: static int format_code_enabler(struct archive *a)\n   40  {\n   41  \treturn archive_read_support_format_by_code(a, format_code);\n   42  }\n   43  \n   44: static int format_code_setter(struct archive *a)\n   45  {\n   46  \treturn archive_read_set_format(a, format_code);\n   ..\n   48  \n   49  static void\n   50: test_success(constructor new_, enabler enable_, destructor free_)\n   51  {\n   52: \tstruct archive *a = new_();\n   53  \tint result = enable_(a);\n   54  \tif (result == ARCHIVE_WARN) {\n   ..\n   64  \n   65  static void\n   66: test_failure(constructor new_, enabler enable_, destructor free_)\n   67  {\n   68: \tstruct archive *a = new_();\n   69  \tassertEqualIntA(a, ARCHIVE_FATAL, enable_(a));\n   70  \tassert(NULL != archive_error_string(a));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_set_error.c:\n   28  \n   29  static void\n   30: test(struct archive *a, int code, const char *msg)\n   31  {\n   32  \tarchive_set_error(a, code, \"%s\", msg);\n   ..\n   38  DEFINE_TEST(test_archive_set_error)\n   39  {\n   40: \tstruct archive* a = archive_read_new();\n   41  \n   42  \t/* unlike printf(\"%s\", NULL),\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_isorr_new_bz2.c:\n   57  {\n   58  \tconst char *refname = \"test_read_format_iso_rockridge_new.iso.Z\";\n   59: \tstruct archive_entry *ae;\n   60: \tstruct archive *a;\n   61  \tconst void *p;\n   62  \tsize_t size;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_perms.c:\n   52  \tgid_t gid = 0;\n   53  \tunsigned int n;\n   54: \tstruct stat st;\n   55  \tint fd;\n   56  \n   ..\n  129  \tskipping(\"archive_write_disk interface\");\n  130  #else\n  131: \tstruct archive *a;\n  132: \tstruct archive_entry *ae;\n  133: \tstruct stat st;\n  134  \tuid_t original_uid;\n  135  \tuid_t try_to_change_uid;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_pax_filename_encoding.c:\n   50  \t */\n   51  \tchar filename[] = \"abc\\314\\214mno\\374xyz\";\n   52: \tstruct archive *a;\n   53: \tstruct archive_entry *entry;\n   54  \n   55  \t/*\n   ..\n   90  {\n   91  \tchar filename[] = \"abc\\314\\214mno\\374xyz\";\n   92: \tstruct archive *a;\n   93: \tstruct archive_entry *entry;\n   94  \tchar buff[65536];\n   95  \tchar longname[] = \"abc\\314\\214mno\\374xyz\"\n   ..\n  193  \twchar_t badname[] = L\"xxxAyyyBzzz\";\n  194  \tconst char badname_utf8[] = \"xxx\\xE1\\x88\\xB4yyy\\xE5\\x99\\xB8zzz\";\n  195: \tstruct archive *a;\n  196: \tstruct archive_entry *entry;\n  197  \tchar buff[65536];\n  198  \tsize_t used;\n  ...\n  338  DEFINE_TEST(test_pax_filename_encoding_KOI8R)\n  339  {\n  340:   \tstruct archive *a;\n  341:   \tstruct archive_entry *entry;\n  342  \tchar buff[4096];\n  343  \tsize_t used;\n  ...\n  384  DEFINE_TEST(test_pax_filename_encoding_CP1251)\n  385  {\n  386:   \tstruct archive *a;\n  387:   \tstruct archive_entry *entry;\n  388  \tchar buff[4096];\n  389  \tsize_t used;\n  ...\n  431  DEFINE_TEST(test_pax_filename_encoding_EUCJP)\n  432  {\n  433:   \tstruct archive *a;\n  434:   \tstruct archive_entry *entry;\n  435  \tchar buff[4096];\n  436  \tsize_t used;\n  ...\n  478  DEFINE_TEST(test_pax_filename_encoding_CP932)\n  479  {\n  480:   \tstruct archive *a;\n  481:   \tstruct archive_entry *entry;\n  482  \tchar buff[4096];\n  483  \tsize_t used;\n  ...\n  527  DEFINE_TEST(test_pax_filename_encoding_KOI8R_BINARY)\n  528  {\n  529:   \tstruct archive *a;\n  530:   \tstruct archive_entry *entry;\n  531  \tchar buff[4096];\n  532  \tsize_t used;\n  ...\n  566  DEFINE_TEST(test_pax_filename_encoding_KOI8R_CP1251)\n  567  {\n  568:   \tstruct archive *a;\n  569  \n  570  \tif (NULL == setlocale(LC_ALL, \"ru_RU.KOI8-R\")) {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_open_fd.c:\n   40  {\n   41  \tchar buff[64];\n   42: \tstruct archive_entry *ae;\n   43: \tstruct archive *a;\n   44  \tint fd;\n   45  \tconst char *skip_open_fd_err_test;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_large.c:\n   42  \tchar tmpfilename[] = \"test-read_large.XXXXXX\";\n   43  \tsize_t used;\n   44: \tstruct archive *a;\n   45: \tstruct archive_entry *entry;\n   46  \tFILE *f;\n   47  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_zip_file.c:\n   71  DEFINE_TEST(test_write_format_zip_file)\n   72  {\n   73: \tstruct archive *a;\n   74: \tstruct archive_entry *ae;\n   75  \ttime_t t = 1234567890;\n   76: \tstruct tm *tm = localtime(&t);\n   77  \tsize_t used, buffsize = 1000000;\n   78  \tunsigned long crc;\n   ..\n  115  \tassertEqualInt(ARCHIVE_OK, archive_write_free(a));\n  116  \tbuffend = buff + used;\n  117: \tdumpfile(\"constructed.zip\", buff, used);\n  118  \n  119  \t/* Verify \"End of Central Directory\" record. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_read_format_zip.c:\n   41   */\n   42  static void\n   43: write_contents(struct archive *a)\n   44  {\n   45: \tstruct archive_entry *ae;\n   46  \n   47  \t/*\n   ..\n  269   */\n  270  static void\n  271: verify_contents(struct archive *a, int seeking, int improved_streaming)\n  272  {\n  273  \tchar filedata[64];\n  274: \tstruct archive_entry *ae;\n  275  \n  276  \t/*\n  ...\n  552  DEFINE_TEST(test_write_read_format_zip)\n  553  {\n  554: \tstruct archive *a;\n  555  \tsize_t used;\n  556  \tsize_t buffsize = 1000000;\n  ...\n  566  \t    archive_write_open_memory(a, buff, buffsize, &used));\n  567  \twrite_contents(a);\n  568: \tdumpfile(\"constructed.zip\", buff, used);\n  569  \n  570  \t/*\n  ...\n  601  DEFINE_TEST(test_write_read_format_zip_improved_streaming)\n  602  {\n  603: \tstruct archive *a;\n  604  \tsize_t used;\n  605  \tsize_t buffsize = 1000000;\n  ...\n  616  \t    archive_write_open_memory(a, buff, buffsize, &used));\n  617  \twrite_contents(a);\n  618: \tdumpfile(\"constructed.zip\", buff, used);\n  619  \n  620  \t/*\n  ...\n  651  DEFINE_TEST(test_write_read_format_zip64)\n  652  {\n  653: \tstruct archive *a;\n  654  \tsize_t used;\n  655  \tsize_t buffsize = 1000000;\n  ...\n  669  \t    archive_write_open_memory(a, buff, buffsize, &used));\n  670  \twrite_contents(a);\n  671: \tdumpfile(\"constructed64.zip\", buff, used);\n  672  \n  673  \t/*\n  ...\n  705  DEFINE_TEST(test_write_read_format_zip64_improved_streaming)\n  706  {\n  707: \tstruct archive *a;\n  708  \tsize_t used;\n  709  \tsize_t buffsize = 1000000;\n  ...\n  721  \t    archive_write_open_memory(a, buff, buffsize, &used));\n  722  \twrite_contents(a);\n  723: \tdumpfile(\"constructed64.zip\", buff, used);\n  724  \n  725  \t/*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_rar_invalid1.c:\n   29  {\n   30  \tconst char *refname = \"test_read_format_rar_invalid1.rar\";\n   31: \tstruct archive *a;\n   32: \tstruct archive_entry *ae;\n   33  \tchar *buff[100];\n   34  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_filter_xz.c:\n   36  DEFINE_TEST(test_write_filter_xz)\n   37  {\n   38: \tstruct archive_entry *ae;\n   39: \tstruct archive* a;\n   40  \tchar *buff, *data;\n   41  \tsize_t buffsize, datasize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_truncated_filter.c:\n   35  static void\n   36  test_truncation(const char *compression,\n   37:     int (*set_compression)(struct archive *), int can_prog)\n   38  {\n   39: \tstruct archive_entry *ae;\n   40: \tstruct archive* a;\n   41  \tchar path[16];\n   42  \tchar *buff, *data;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_lha_filename.c:\n   31  test_read_format_lha_filename_CP932_eucJP(const char *refname)\n   32  {\n   33: \tstruct archive *a;\n   34: \tstruct archive_entry *ae;\n   35  \n   36  \t/*\n   ..\n   94  test_read_format_lha_filename_CP932_UTF8(const char *refname)\n   95  {\n   96: \tstruct archive *a;\n   97: \tstruct archive_entry *ae;\n   98  \n   99  \t/*\n  ...\n  155  test_read_format_lha_filename_CP932_Windows(const char *refname)\n  156  {\n  157: \tstruct archive *a;\n  158: \tstruct archive_entry *ae;\n  159  \n  160  \t/*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_filter_uudecode.c:\n   73  test_read_uu_sub(const char *uudata, size_t uusize, int no_nl)\n   74  {\n   75: \tstruct archive_entry *ae;\n   76: \tstruct archive *a;\n   77  \tchar *buff;\n   78  \tchar extradata_no_nl[sizeof(extradata)];\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_7zip_encryption_partially.c:\n   32  \t   and one unencrypted file. */\n   33  \tconst char *refname = \"test_read_format_7zip_encryption_partially.7z\";\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tchar buff[128];\n   37  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_bin_lzip.c:\n   38  DEFINE_TEST(test_read_format_cpio_bin_lzip)\n   39  {\n   40: \tstruct archive_entry *ae;\n   41: \tstruct archive *a;\n   42  \tint r;\n   43  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_secure745.c:\n   39  \tskipping(\"archive_write_disk security checks not supported on Windows\");\n   40  #else\n   41: \tstruct archive *a;\n   42: \tstruct archive_entry *ae;\n   43  \n   44  \t/* Start with a known umask. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_nofiletype.c:\n   36  \tchar *p;\n   37  \tsize_t s;\n   38: \tstruct archive *a;\n   39: \tstruct archive_entry *ae;\n   40  \tchar data[16];\n   41  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_ustar_filenames.c:\n   36  \tchar filename[400];\n   37  \tchar dirname[400];\n   38: \tstruct archive_entry *ae;\n   39: \tstruct archive *a;\n   40  \tsize_t used;\n   41  \tint separator = 0;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_bzip2.c:\n   43  {\n   44  \tconst char *n[7] = { \"f1\", \"f2\", \"f3\", \"d1/f1\", \"d1/f2\", \"d1/f3\", NULL };\n   45: \tstruct archive_entry *ae;\n   46: \tstruct archive *a;\n   47  \tint i;\n   48  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_bin_Z.c:\n   34  DEFINE_TEST(test_read_format_cpio_bin_Z)\n   35  {\n   36: \tstruct archive_entry *ae;\n   37: \tstruct archive *a;\n   38  \tassert((a = archive_read_new()) != NULL);\n   39  \tassertEqualIntA(a, ARCHIVE_OK,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_data_large.c:\n   45  DEFINE_TEST(test_read_data_large)\n   46  {\n   47: \tstruct archive_entry *ae;\n   48: \tstruct archive *a;\n   49  \tchar tmpfilename[] = \"largefile\";\n   50  \tint tmpfilefd;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_tar.c:\n   31  DEFINE_TEST(test_write_format_tar)\n   32  {\n   33: \tstruct archive_entry *ae;\n   34: \tstruct archive *a;\n   35  \tchar *p;\n   36  \tsize_t used;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_write_set_format_option.c:\n   33  test(int pristine)\n   34  {\n   35: \tstruct archive* a = archive_write_new();\n   36  \tint known_option_rv = pristine ? ARCHIVE_FAILED : ARCHIVE_OK;\n   37  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_read_close_twice_open_fd.c:\n   29  DEFINE_TEST(test_archive_read_close_twice_open_fd)\n   30  {\n   31: \tstruct archive* a = archive_read_new();\n   32  \n   33  \tassertEqualInt(ARCHIVE_OK, archive_read_support_format_empty(a));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_pax_xattr_header.c:\n   26  __FBSDID(\"$FreeBSD$\");\n   27  \n   28: static struct archive_entry*\n   29  create_archive_entry(void) {\n   30: \tstruct archive_entry *ae;\n   31  \n   32  \tassert((ae = archive_entry_new()) != NULL);\n   ..\n   52  \t    NULL\n   53  \t};\n   54: \tstruct archive *a;\n   55: \tstruct archive_entry *ae;\n   56  \n   57  \textract_reference_files(reffiles);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_bin_bz2.c:\n   35  DEFINE_TEST(test_read_format_cpio_bin_bz2)\n   36  {\n   37: \tstruct archive_entry *ae;\n   38: \tstruct archive *a;\n   39  \tint r;\n   40  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_filter_zstd.c:\n   30  DEFINE_TEST(test_write_filter_zstd)\n   31  {\n   32: \tstruct archive_entry *ae;\n   33: \tstruct archive *a;\n   34  \tchar *buff, *data;\n   35  \tsize_t buffsize, datasize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_read_set_option.c:\n   33  test(int pristine)\n   34  {\n   35: \tstruct archive* a = archive_read_new();\n   36  \tint known_option_rv = pristine ? ARCHIVE_FAILED : ARCHIVE_OK;\n   37  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_filter_lz4.c:\n   34  DEFINE_TEST(test_write_filter_lz4)\n   35  {\n   36: \tstruct archive_entry *ae;\n   37: \tstruct archive* a;\n   38  \tchar *buff, *data;\n   39  \tsize_t buffsize, datasize;\n   ..\n  278  test_options(const char *options)\n  279  {\n  280: \tstruct archive_entry *ae;\n  281: \tstruct archive* a;\n  282  \tchar *buff, *data;\n  283  \tsize_t buffsize, datasize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_ustar_filename.c:\n   31  test_read_format_ustar_filename_eucJP_UTF8(const char *refname)\n   32  {\n   33: \tstruct archive *a;\n   34: \tstruct archive_entry *ae;\n   35  \n   36  \t/*\n   ..\n   85  test_read_format_ustar_filename_CP866_KOI8R(const char *refname)\n   86  {\n   87: \tstruct archive *a;\n   88: \tstruct archive_entry *ae;\n   89  \n   90  \t/*\n   ..\n  140  test_read_format_ustar_filename_CP866_UTF8(const char *refname)\n  141  {\n  142: \tstruct archive *a;\n  143: \tstruct archive_entry *ae;\n  144  \n  145  \t/*\n  ...\n  195  test_read_format_ustar_filename_KOI8R_CP866(const char *refname)\n  196  {\n  197: \tstruct archive *a;\n  198: \tstruct archive_entry *ae;\n  199  \n  200  \t/*\n  ...\n  251  test_read_format_ustar_filename_KOI8R_UTF8(const char *refname)\n  252  {\n  253: \tstruct archive *a;\n  254: \tstruct archive_entry *ae;\n  255  \n  256  \t/*\n  ...\n  306  test_read_format_ustar_filename_eucJP_CP932(const char *refname)\n  307  {\n  308: \tstruct archive *a;\n  309: \tstruct archive_entry *ae;\n  310  \n  311  \t/*\n  ...\n  360  test_read_format_ustar_filename_CP866_CP1251(const char *refname)\n  361  {\n  362: \tstruct archive *a;\n  363: \tstruct archive_entry *ae;\n  364  \n  365  \t/*\n  ...\n  422  test_read_format_ustar_filename_CP866_CP1251_win(const char *refname)\n  423  {\n  424: \tstruct archive *a;\n  425: \tstruct archive_entry *ae;\n  426  \n  427  \t/*\n  ...\n  471  test_read_format_ustar_filename_KOI8R_CP1251(const char *refname)\n  472  {\n  473: \tstruct archive *a;\n  474: \tstruct archive_entry *ae;\n  475  \n  476  \t/*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_uudecode_large.c:\n   30  {\n   31  \tconst char *refname = \"test_compat_uudecode_large.tar.Z.uu\";\n   32: \tstruct archive_entry *ae;\n   33: \tstruct archive *a;\n   34  \n   35  \tcopy_reference_file(refname);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_filter_program.c:\n   37  {\n   38  \tint r;\n   39: \tstruct archive_entry *ae;\n   40: \tstruct archive *a;\n   41  \n   42  \t/*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_read_close_twice_open_filename.c:\n   30  {\n   31  \tconst char *filename = \"empty.file\";\n   32: \tstruct archive* a = archive_read_new();\n   33  \n   34  \tassertMakeFile(filename, 0644, \"\");\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_comment_stored.c:\n   35  \tchar *p;\n   36  \tsize_t s;\n   37: \tstruct archive *a;\n   38: \tstruct archive_entry *ae;\n   39  \n   40  \textract_reference_file(refname);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_string_conversion.c:\n  252  test_archive_string_normalization_nfc(const char *testdata)\n  253  {\n  254: \tstruct archive *a, *a2;\n  255: \tstruct archive_string utf8;\n  256: \tstruct archive_mstring mstr;\n  257: \tstruct archive_string_conv *f_sconv8, *t_sconv8;\n  258: \tstruct archive_string_conv *f_sconv16be, *f_sconv16le;\n  259  \tFILE *fp;\n  260  \tchar buff[512];\n  ...\n  463  test_archive_string_normalization_mac_nfd(const char *testdata)\n  464  {\n  465: \tstruct archive *a, *a2;\n  466: \tstruct archive_string utf8;\n  467: \tstruct archive_mstring mstr;\n  468: \tstruct archive_string_conv *f_sconv8, *t_sconv8;\n  469: \tstruct archive_string_conv *f_sconv16be, *f_sconv16le;\n  470  \tFILE *fp;\n  471  \tchar buff[512];\n  ...\n  713  test_archive_string_canonicalization(void)\n  714  {\n  715: \tstruct archive *a;\n  716: \tstruct archive_string_conv *sconv;\n  717  \n  718  \tsetlocale(LC_ALL, \"en_US.UTF-8\");\n  ...\n  779  \n  780  static void\n  781: check_string(struct archive *a, struct archive_mstring *mstr, struct archive_string_conv *sc,\n  782    const char *exp, const wchar_t *wexp)\n  783  {\n  784  \t/* Do all the tests on a copy so that we can have a clear initial state every time */\n  785: \tstruct archive_mstring mstr2;\n  786  \tconst char *p = NULL;\n  787  \tconst wchar_t *wp = NULL;\n  ...\n  822  test_archive_string_set_get(void)\n  823  {\n  824: \tstruct archive *a;\n  825: \tstruct archive_mstring mstr;\n  826: \tstruct archive_string_conv *sc;\n  827  \n  828  \tsetlocale(LC_ALL, \"en_US.UTF-8\");\n  ...\n  856  \tstatic const char reffile[] = \"test_archive_string_conversion.txt.Z\";\n  857  \tstatic const char testdata[] = \"testdata.txt\";\n  858: \tstruct archive *a;\n  859: \tstruct archive_entry *ae;\n  860  \tchar buff[512];\n  861  \tssize_t size;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_rar5.c:\n   32  \n   33  #define PROLOGUE(reffile) \\\n   34: \tstruct archive_entry *ae; \\\n   35: \tstruct archive *a; \\\n   36  \t\\\n   37  \t(void) a;  /* Make the compiler happy if we won't use this variables */ \\\n   ..\n   45  \n   46  #define PROLOGUE_MULTI(reffile) \\\n   47: \tstruct archive_entry *ae; \\\n   48: \tstruct archive *a; \\\n   49  \t\\\n   50  \t(void) a; \\\n   ..\n   91  \n   92  static\n   93: int extract_one(struct archive* a, struct archive_entry* ae, uint32_t crc) {\n   94  \tla_ssize_t fsize, bytes_read;\n   95  \tuint8_t* buf;\n   ..\n  119  DEFINE_TEST(test_read_format_rar5_set_format)\n  120  {\n  121: \tstruct archive *a;\n  122: \tstruct archive_entry *ae;\n  123  \tconst char reffile[] = \"test_read_format_rar5_stored.rar\";\n  124  \n  ...\n  811  \t/* This test uses strange buffer sizes intentionally. */\n  812  \n  813: \tstruct archive_entry *ae;\n  814: \tstruct archive *a;\n  815  \tuint8_t buf[173];\n  816  \tint bytes_read;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_with_invalid_traditional_eocd.c:\n   36  \tchar *p;\n   37  \tsize_t s;\n   38: \tstruct archive *a;\n   39: \tstruct archive_entry *ae;\n   40  \n   41  \textract_reference_file(refname);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_fixup.c:\n   33  \tskipping(\"Skipping test on Windows\");\n   34  #else\n   35: \tstruct archive *ad;\n   36: \tstruct archive_entry *ae;\n   37  \tint r;\n   38  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_bin_le.c:\n   28  DEFINE_TEST(test_read_format_cpio_bin_le)\n   29  {\n   30: \tstruct archive_entry *ae;\n   31: \tstruct archive *a;\n   32  \tconst char *reference = \"test_read_format_cpio_bin_le.cpio\";\n   33  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_open_memory.c:\n   32  {\n   33  \tunsigned int i;\n   34: \tstruct archive *a;\n   35: \tstruct archive_entry *ae;\n   36  \tconst char *name=\"/tmp/test\";\n   37  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_shar_empty.c:\n   32  DEFINE_TEST(test_write_format_shar_empty)\n   33  {\n   34: \tstruct archive *a;\n   35  \tchar buff[2048];\n   36  \tsize_t used;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_times.c:\n   34  DEFINE_TEST(test_write_disk_times)\n   35  {\n   36: \tstruct archive *a;\n   37: \tstruct archive_entry *ae;\n   38  \n   39  \t/* Create an archive_write_disk object. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_star_acl.c:\n   35   */\n   36  \n   37: static struct archive_test_acl_t acls0[] = {\n   38  \t{ ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ARCHIVE_ENTRY_ACL_EXECUTE,\n   39  \t  ARCHIVE_ENTRY_ACL_USER_OBJ, -1, \"\" },\n   ..\n   48  };\n   49  \n   50: static struct archive_test_acl_t acls1[] = {\n   51  \t{ ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ARCHIVE_ENTRY_ACL_EXECUTE | ARCHIVE_ENTRY_ACL_READ,\n   52  \t  ARCHIVE_ENTRY_ACL_USER_OBJ, -1, \"\" },\n   ..\n   65  };\n   66  \n   67: static struct archive_test_acl_t acls2[] = {\n   68  \t{ ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, ARCHIVE_ENTRY_ACL_EXECUTE,\n   69  \t  ARCHIVE_ENTRY_ACL_USER_OBJ, -1 ,\"\" },\n   ..\n   80  };\n   81  \n   82: static struct archive_test_acl_t acls3[] = {\n   83  \t{ ARCHIVE_ENTRY_ACL_TYPE_ALLOW,\n   84  \t    ARCHIVE_ENTRY_ACL_READ_DATA |\n   ..\n  114  };\n  115  \n  116: static struct archive_test_acl_t acls4[] = {\n  117  \t{ ARCHIVE_ENTRY_ACL_TYPE_ALLOW,\n  118  \t    ARCHIVE_ENTRY_ACL_READ_DATA |\n  ...\n  167  };\n  168  \n  169: static struct archive_test_acl_t acls5[] = {\n  170  \t{ ARCHIVE_ENTRY_ACL_TYPE_ALLOW,\n  171  \t    ARCHIVE_ENTRY_ACL_READ_DATA |\n  ...\n  234  {\n  235  \tchar name[] = \"test_compat_star_acl_posix1e.tar\";\n  236: \tstruct archive *a;\n  237: \tstruct archive_entry *ae;\n  238  \n  239  \t/* Read archive file */\n  ...\n  284  {\n  285  \tchar name[] = \"test_compat_star_acl_nfs4.tar\";\n  286: \tstruct archive *a;\n  287: \tstruct archive_entry *ae;\n  288  \n  289  \t/* Read archive file */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_match_path.c:\n   30  test_exclusion_mbs(void)\n   31  {\n   32: \tstruct archive_entry *ae;\n   33: \tstruct archive *m;\n   34  \n   35  \tif (!assert((m = archive_match_new()) != NULL))\n   ..\n   73  test_exclusion_wcs(void)\n   74  {\n   75: \tstruct archive_entry *ae;\n   76: \tstruct archive *m;\n   77  \n   78  \tif (!assert((m = archive_match_new()) != NULL))\n   ..\n  114  \n  115  static void\n  116: exclusion_from_file(struct archive *m)\n  117  {\n  118: \tstruct archive_entry *ae;\n  119  \n  120  \tif (!assert((ae = archive_entry_new()) != NULL)) {\n  ...\n  174  test_exclusion_from_file_mbs(void)\n  175  {\n  176: \tstruct archive *m;\n  177  \n  178  \t/* Test1: read exclusion patterns from file */\n  ...\n  199  test_exclusion_from_file_wcs(void)\n  200  {\n  201: \tstruct archive *m;\n  202  \n  203  \t/* Test1: read exclusion patterns from file */\n  ...\n  224  test_inclusion_mbs(void)\n  225  {\n  226: \tstruct archive_entry *ae;\n  227: \tstruct archive *m;\n  228  \tconst char *mp;\n  229  \n  ...\n  273  test_inclusion_wcs(void)\n  274  {\n  275: \tstruct archive_entry *ae;\n  276: \tstruct archive *m;\n  277  \tconst char *mp;\n  278  \n  ...\n  322  test_inclusion_from_file_mbs(void)\n  323  {\n  324: \tstruct archive *m;\n  325  \n  326  \t/* Test1: read inclusion patterns from file */\n  ...\n  346  test_inclusion_from_file_wcs(void)\n  347  {\n  348: \tstruct archive *m;\n  349  \n  350  \t/* Test1: read inclusion patterns from file */\n  ...\n  372  test_exclusion_and_inclusion(void)\n  373  {\n  374: \tstruct archive_entry *ae;\n  375: \tstruct archive *m;\n  376  \tconst char *mp;\n  377  \tconst wchar_t *wp;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_lzop.c:\n   41  \tconst char *sample2 = \"test_compat_lzop_2.tar.lzo\";\n   42  \tconst char *sample3 = \"test_compat_lzop_3.tar.lzo\";\n   43: \tstruct archive_entry *ae;\n   44: \tstruct archive *a;\n   45  \tint r;\n   46  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_msdos.c:\n   42   */\n   43  \n   44: static void verify(struct archive *a, int streaming) {\n   45: \tstruct archive_entry *ae;\n   46  \n   47  \tassertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));\n   ..\n   88  {\n   89  \tconst char *refname = \"test_read_format_zip_msdos.zip\";\n   90: \tstruct archive *a;\n   91  \tchar *p;\n   92  \tsize_t s;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_zip.c:\n   44   */\n   45  static void\n   46: write_contents(struct archive *a)\n   47  {\n   48: \tstruct archive_entry *ae;\n   49  \n   50  \t/*\n   ..\n  272   */\n  273  static void\n  274: verify_contents(struct archive *a, int seeking, int content)\n  275  {\n  276  \tchar filedata[64];\n  277: \tstruct archive_entry *ae;\n  278  \n  279  \t/*\n  ...\n  544  DEFINE_TEST(test_write_format_zip)\n  545  {\n  546: \tstruct archive *a;\n  547  \tsize_t used;\n  548  \tsize_t buffsize = 1000000;\n  ...\n  560  \t    archive_write_open_memory(a, buff, buffsize, &used));\n  561  \twrite_contents(a);\n  562: \tdumpfile(\"constructed.zip\", buff, used);\n  563  \n  564  \t/*\n  ...\n  608  DEFINE_TEST(test_write_format_zip64)\n  609  {\n  610: \tstruct archive *a;\n  611  \tsize_t used;\n  612  \tsize_t buffsize = 1000000;\n  ...\n  626  \t    archive_write_open_memory(a, buff, buffsize, &used));\n  627  \twrite_contents(a);\n  628: \tdumpfile(\"constructed64.zip\", buff, used);\n  629  \n  630  \t/*\n  ...\n  671  DEFINE_TEST(test_write_format_zip_traditional_pkware_encryption)\n  672  {\n  673: \tstruct archive *a;\n  674  \tsize_t used;\n  675  \tsize_t buffsize = 1000000;\n  ...\n  696  \t    archive_write_open_memory(a, buff, buffsize, &used));\n  697  \twrite_contents(a);\n  698: \tdumpfile(\"constructed.zip\", buff, used);\n  699  \n  700  \t/*\n  ...\n  751  DEFINE_TEST(test_write_format_zip_winzip_aes128_encryption)\n  752  {\n  753: \tstruct archive *a;\n  754  \tsize_t used;\n  755  \tsize_t buffsize = 1000000;\n  ...\n  776  \t    archive_write_open_memory(a, buff, buffsize, &used));\n  777  \twrite_contents(a);\n  778: \tdumpfile(\"constructed.zip\", buff, used);\n  779  \n  780  \t/*\n  ...\n  831  DEFINE_TEST(test_write_format_zip_winzip_aes256_encryption)\n  832  {\n  833: \tstruct archive *a;\n  834  \tsize_t used;\n  835  \tsize_t buffsize = 1000000;\n  ...\n  856  \t    archive_write_open_memory(a, buff, buffsize, &used));\n  857  \twrite_contents(a);\n  858: \tdumpfile(\"constructed.zip\", buff, used);\n  859  \n  860  \t/*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_string.c:\n   50  test_archive_string_ensure(void)\n   51  {\n   52: \tstruct archive_string s;\n   53  \n   54  \tarchive_string_init(&s);\n   ..\n   75  test_archive_strcat(void)\n   76  {\n   77: \tstruct archive_string s;\n   78  \n   79  \tarchive_string_init(&s);\n   ..\n  102  test_archive_strappend_char(void)\n  103  {\n  104: \tstruct archive_string s;\n  105  \n  106  \tarchive_string_init(&s);\n  ...\n  125  test_archive_strncat(void)\n  126  {\n  127: \tstruct archive_string s;\n  128  \n  129  \tarchive_string_init(&s);\n  ...\n  148  test_archive_strncpy(void)\n  149  {\n  150: \tstruct archive_string s;\n  151  \n  152  \tarchive_string_init(&s);\n  ...\n  171  test_archive_strcpy(void)\n  172  {\n  173: \tstruct archive_string s;\n  174  \n  175  \tarchive_string_init(&s);\n  ...\n  194  test_archive_string_concat(void)\n  195  {\n  196: \tstruct archive_string s, t, u, v;\n  197  \n  198  \tarchive_string_init(&s);\n  ...\n  245  test_archive_string_copy(void)\n  246  {\n  247: \tstruct archive_string s, t, u, v;\n  248  \n  249  \tarchive_string_init(&s);\n  ...\n  302  test_archive_string_sprintf(void)\n  303  {\n  304: \tstruct archive_string s;\n  305  #define S16 \"0123456789abcdef\"\n  306  #define S32 S16 S16\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_match_time.c:\n   33  test_newer_time(void)\n   34  {\n   35: \tstruct archive_entry *ae;\n   36: \tstruct archive *m;\n   37  \n   38  \tif (!assert((m = archive_match_new()) != NULL))\n   ..\n   85  test_newer_time_str(void)\n   86  {\n   87: \tstruct archive_entry *ae;\n   88: \tstruct archive *m;\n   89  \ttime_t now, t;\n   90  \n   ..\n  173  test_newer_time_str_w(void)\n  174  {\n  175: \tstruct archive_entry *ae;\n  176: \tstruct archive *m;\n  177  \ttime_t now, t;\n  178  \n  ...\n  261  test_newer_mtime_than_file_mbs(void)\n  262  {\n  263: \tstruct archive *a;\n  264: \tstruct archive_entry *ae;\n  265: \tstruct archive *m;\n  266  \n  267  \tif (!assert((m = archive_match_new()) != NULL))\n  ...\n  318  test_newer_ctime_than_file_mbs(void)\n  319  {\n  320: \tstruct archive *a;\n  321: \tstruct archive_entry *ae;\n  322: \tstruct archive *m;\n  323  \n  324  \tif (!assert((m = archive_match_new()) != NULL))\n  ...\n  375  test_newer_mtime_than_file_wcs(void)\n  376  {\n  377: \tstruct archive *a;\n  378: \tstruct archive_entry *ae;\n  379: \tstruct archive *m;\n  380  \n  381  \tif (!assert((m = archive_match_new()) != NULL))\n  ...\n  432  test_newer_ctime_than_file_wcs(void)\n  433  {\n  434: \tstruct archive *a;\n  435: \tstruct archive_entry *ae;\n  436: \tstruct archive *m;\n  437  \n  438  \tif (!assert((m = archive_match_new()) != NULL))\n  ...\n  490  test_older_time(void)\n  491  {\n  492: \tstruct archive_entry *ae;\n  493: \tstruct archive *m;\n  494  \n  495  \tif (!assert((m = archive_match_new()) != NULL))\n  ...\n  542  test_older_time_str(void)\n  543  {\n  544: \tstruct archive_entry *ae;\n  545: \tstruct archive *m;\n  546  \ttime_t now, t;\n  547  \n  ...\n  632  test_older_time_str_w(void)\n  633  {\n  634: \tstruct archive_entry *ae;\n  635: \tstruct archive *m;\n  636  \ttime_t now, t;\n  637  \n  ...\n  722  test_older_mtime_than_file_mbs(void)\n  723  {\n  724: \tstruct archive *a;\n  725: \tstruct archive_entry *ae;\n  726: \tstruct archive *m;\n  727  \n  728  \tif (!assert((m = archive_match_new()) != NULL))\n  ...\n  779  test_older_ctime_than_file_mbs(void)\n  780  {\n  781: \tstruct archive *a;\n  782: \tstruct archive_entry *ae;\n  783: \tstruct archive *m;\n  784  \n  785  \tif (!assert((m = archive_match_new()) != NULL))\n  ...\n  837  test_older_mtime_than_file_wcs(void)\n  838  {\n  839: \tstruct archive *a;\n  840: \tstruct archive_entry *ae;\n  841: \tstruct archive *m;\n  842  \n  843  \tif (!assert((m = archive_match_new()) != NULL))\n  ...\n  894  test_older_ctime_than_file_wcs(void)\n  895  {\n  896: \tstruct archive *a;\n  897: \tstruct archive_entry *ae;\n  898: \tstruct archive *m;\n  899  \n  900  \tif (!assert((m = archive_match_new()) != NULL))\n  ...\n  952  test_mtime_between_files_mbs(void)\n  953  {\n  954: \tstruct archive *a;\n  955: \tstruct archive_entry *ae;\n  956: \tstruct archive *m;\n  957  \n  958  \tif (!assert((m = archive_match_new()) != NULL))\n  ...\n 1011  test_mtime_between_files_wcs(void)\n 1012  {\n 1013: \tstruct archive *a;\n 1014: \tstruct archive_entry *ae;\n 1015: \tstruct archive *m;\n 1016  \n 1017  \tif (!assert((m = archive_match_new()) != NULL))\n ....\n 1070  test_ctime_between_files_mbs(void)\n 1071  {\n 1072: \tstruct archive *a;\n 1073: \tstruct archive_entry *ae;\n 1074: \tstruct archive *m;\n 1075  \n 1076  \tif (!assert((m = archive_match_new()) != NULL))\n ....\n 1129  test_ctime_between_files_wcs(void)\n 1130  {\n 1131: \tstruct archive *a;\n 1132: \tstruct archive_entry *ae;\n 1133: \tstruct archive *m;\n 1134  \n 1135  \tif (!assert((m = archive_match_new()) != NULL))\n ....\n 1186  \n 1187  static void\n 1188: excluded(struct archive *m)\n 1189  {\n 1190: \tstruct archive_entry *ae;\n 1191  \n 1192  \tif (!assert((ae = archive_entry_new()) != NULL))\n ....\n 1261  test_pathname_newer_mtime(void)\n 1262  {\n 1263: \tstruct archive_entry *ae;\n 1264: \tstruct archive *m;\n 1265  \n 1266  \tif (!assert((m = archive_match_new()) != NULL))\n ....\n 1296  DEFINE_TEST(test_archive_match_time)\n 1297  {\n 1298: \tstruct stat st;\n 1299  \n 1300  \t/* Test: matching newer times. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_disk_entry_from_file.c:\n   44  DEFINE_TEST(test_read_disk_entry_from_file)\n   45  {\n   46: \tstruct archive *a;\n   47: \tstruct archive_entry *entry;\n   48  \tFILE *f;\n   49  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_gnutar.c:\n  100  \tsize_t buffsize = 1000000;\n  101  \tchar *buff;\n  102: \tstruct archive_entry *ae;\n  103: \tstruct archive *a;\n  104  \tsize_t used;\n  105  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_tar.c:\n   28  /*\n   29   * Each of these archives is a short archive with a single entry.  The\n   30:  * corresponding verify function verifies the entry structure returned\n   31   * from libarchive is what it should be.  The support functions pad with\n   32   * lots of zeros, so we can trim trailing zero bytes from each hardcoded\n   ..\n   63  static void verifyEmpty(void)\n   64  {\n   65: \tstruct archive_entry *ae;\n   66: \tstruct archive *a;\n   67  \n   68  \tassert((a = archive_read_new()) != NULL);\n   ..\n   97  '0','0','0','0','0',' ',0,'0','0','0','0','0','0',' '};\n   98  \n   99: static void verify1(struct archive_entry *ae)\n  100  {\n  101  \t/* A hardlink is not a symlink. */\n  ...\n  129  '0','0','0','0','0','0','0',' ','0','0','0','0','0','0','0',' '};\n  130  \n  131: static void verify2(struct archive_entry *ae)\n  132  {\n  133  \tassertEqualInt(archive_entry_filetype(ae), AE_IFLNK);\n  ...\n  158  '0','0','0','0','0','0','0',' ','0','0','0','0','0','0','0',' '};\n  159  \n  160: static void verify3(struct archive_entry *ae)\n  161  {\n  162  \tassertEqualInt(archive_entry_filetype(ae), AE_IFCHR);\n  ...\n  187  '0','0','0','0','0','0','0',' ','0','0','0','0','0','0','0',' '};\n  188  \n  189: static void verify4(struct archive_entry *ae)\n  190  {\n  191  \tassertEqualInt(archive_entry_filetype(ae), AE_IFBLK);\n  ...\n  216  0,0,'0','0','0','0','0','0',' ',0,'0','0','0','0','0','0',' '};\n  217  \n  218: static void verify5(struct archive_entry *ae)\n  219  {\n  220  \tassertEqualInt(archive_entry_filetype(ae), AE_IFDIR);\n  ...\n  242  '0','0','0','0','0','0','0',' ','0','0','0','0','0','0','0',' '};\n  243  \n  244: static void verify6(struct archive_entry *ae)\n  245  {\n  246  \tassertEqualInt(archive_entry_filetype(ae), AE_IFIFO);\n  ...\n  313  0,0,0,0,0,0,0,0,0,0,0,0,0,'t','i','m'};\n  314  \n  315: static void verifyK(struct archive_entry *ae)\n  316  {\n  317  \tassertEqualInt(archive_entry_filetype(ae), AE_IFLNK);\n  ...\n  399  0,0,0,0,0,0,0,'0','0','0','0','0','0','0',0,'0','0','0','0','0','0','0'};\n  400  \n  401: static void verifyxL(struct archive_entry *ae)\n  402  {\n  403  \tassertEqualInt(archive_entry_filetype(ae), AE_IFLNK);\n  ...\n  425  \n  426  static void verify(unsigned char *d, size_t s,\n  427:     void (*f)(struct archive_entry *),\n  428      int compression, int format)\n  429  {\n  430: \tstruct archive_entry *ae;\n  431: \tstruct archive *a;\n  432  \tunsigned char *buff = malloc(100000);\n  433  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_tar_empty.c:\n   32  DEFINE_TEST(test_write_format_tar_empty)\n   33  {\n   34: \tstruct archive *a;\n   35  \tchar buff[2048];\n   36  \tsize_t used;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_cpio_newc.c:\n   51  DEFINE_TEST(test_write_format_cpio_newc)\n   52  {\n   53: \tstruct archive *a;\n   54: \tstruct archive_entry *entry;\n   55  \tchar *buff, *e, *file;\n   56  \tsize_t buffsize = 100000;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_filter_lzip.c:\n   36  DEFINE_TEST(test_write_filter_lzip)\n   37  {\n   38: \tstruct archive_entry *ae;\n   39: \tstruct archive* a;\n   40  \tchar *buff, *data;\n   41  \tsize_t buffsize, datasize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_iso_multi_extent.c:\n   30  {\n   31  \tconst char *refname = \"test_read_format_iso_multi_extent.iso.Z\";\n   32: \tstruct archive_entry *ae;\n   33: \tstruct archive *a;\n   34  \tconst void *p;\n   35  \tsize_t size;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_disk.c:\n   77  DEFINE_TEST(test_read_disk)\n   78  {\n   79: \tstruct archive *a;\n   80  \tint gmagic = 0x13579, umagic = 0x1234;\n   81  #if !defined(__CYGWIN__) && !defined(__HAIKU__)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_mtree_no_separator.c:\n   35  DEFINE_TEST(test_write_format_mtree_no_separator)\n   36  {\n   37: \tstruct archive_entry *ae;\n   38: \tstruct archive* a;\n   39  \tsize_t used;\n   40  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_cpio_empty.c:\n   47  DEFINE_TEST(test_write_format_cpio_empty)\n   48  {\n   49: \tstruct archive *a;\n   50  \tchar buff[2048];\n   51  \tsize_t used;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cab_filename.c:\n   31  test_read_format_cab_filename_CP932_eucJP(const char *refname)\n   32  {\n   33: \tstruct archive *a;\n   34: \tstruct archive_entry *ae;\n   35  \n   36  \t/*\n   ..\n   88  test_read_format_cab_filename_CP932_UTF8(const char *refname)\n   89  {\n   90: \tstruct archive *a;\n   91: \tstruct archive_entry *ae;\n   92  \n   93  \t/*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_7zip.c:\n   32  {\n   33  \tchar filedata[64];\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tsize_t used;\n   37  \tsize_t buffsize = 1000;\n   ..\n  322  {\n  323  \tchar filedata[64];\n  324: \tstruct archive_entry *ae;\n  325: \tstruct archive *a;\n  326  \tsize_t used;\n  327  \tsize_t buffsize = 1000;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_mac_metadata.c:\n   35  \tchar *p;\n   36  \tsize_t s;\n   37: \tstruct archive *a;\n   38: \tstruct archive_entry *ae;\n   39  \tconst unsigned char appledouble[] = {\n   40  \t\t0x00, 0x05, 0x16, 0x07, 0x00, 0x02, 0x00, 0x00,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_rar_encryption_data.c:\n   31  \t   are NOT encrypted. Password is \"12345678\". */\n   32  \tconst char *refname = \"test_read_format_rar_encryption_data.rar\";\n   33: \tstruct archive_entry *ae;\n   34: \tstruct archive *a;\n   35  \tchar buff[128];\n   36  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_tbz.c:\n   36  DEFINE_TEST(test_read_format_tbz)\n   37  {\n   38: \tstruct archive_entry *ae;\n   39: \tstruct archive *a;\n   40  \tint r;\n   41  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_7zip.c:\n   39  {\n   40  \tconst char *refname = \"test_read_format_7zip_copy.7z\";\n   41: \tstruct archive_entry *ae;\n   42: \tstruct archive *a;\n   43  \tchar buff[128];\n   44  \tint fd = -1;\n   ..\n   91  {\n   92  \tconst char *refname = \"test_read_format_7zip_empty_archive.7z\";\n   93: \tstruct archive_entry *ae;\n   94: \tstruct archive *a;\n   95  \n   96  \textract_reference_file(refname);\n   ..\n  123  {\n  124  \tconst char *refname = \"test_read_format_7zip_empty_file.7z\";\n  125: \tstruct archive_entry *ae;\n  126: \tstruct archive *a;\n  127  \n  128  \textract_reference_file(refname);\n  ...\n  163  test_plain_header(const char *refname)\n  164  {\n  165: \tstruct archive_entry *ae;\n  166: \tstruct archive *a;\n  167  \tchar buff[128];\n  168  \n  ...\n  206  test_extract_all_files(const char *refname)\n  207  {\n  208: \tstruct archive_entry *ae;\n  209: \tstruct archive *a;\n  210  \tchar buff[128];\n  211  \n  ...\n  291  test_extract_last_file(const char *refname)\n  292  {\n  293: \tstruct archive_entry *ae;\n  294: \tstruct archive *a;\n  295  \tchar buff[128];\n  296  \n  ...\n  371  test_extract_all_files2(const char *refname)\n  372  {\n  373: \tstruct archive_entry *ae;\n  374: \tstruct archive *a;\n  375  \tchar buff[128];\n  376  \n  ...\n  500  test_delta_lzma(const char *refname)\n  501  {\n  502: \tstruct archive_entry *ae;\n  503: \tstruct archive *a;\n  504  \tsize_t remaining;\n  505  \tssize_t bytes;\n  ...\n  556  test_bcj(const char *refname)\n  557  {\n  558: \tstruct archive_entry *ae;\n  559: \tstruct archive *a;\n  560  \tsize_t remaining;\n  561  \tssize_t bytes;\n  ...\n  613  {\n  614  \tconst char *refname = \"test_read_format_7zip_ppmd.7z\";\n  615: \tstruct archive_entry *ae;\n  616: \tstruct archive *a;\n  617  \tsize_t remaining;\n  618  \tssize_t bytes;\n  ...\n  667  {\n  668  \tconst char *refname = \"test_read_format_7zip_symbolic_name.7z\";\n  669: \tstruct archive_entry *ae;\n  670: \tstruct archive *a;\n  671  \tchar buff[128];\n  672  \n  ...\n  715  DEFINE_TEST(test_read_format_7zip)\n  716  {\n  717: \tstruct archive *a;\n  718  \n  719  \tassert((a = archive_read_new()) != NULL);\n  ...\n  735  DEFINE_TEST(test_read_format_7zip_bzip2)\n  736  {\n  737: \tstruct archive *a;\n  738  \n  739  \tassert((a = archive_read_new()) != NULL);\n  ...\n  766  DEFINE_TEST(test_read_format_7zip_deflate)\n  767  {\n  768: \tstruct archive *a;\n  769  \n  770  \tassert((a = archive_read_new()) != NULL);\n  ...\n  791  DEFINE_TEST(test_read_format_7zip_lzma1)\n  792  {\n  793: \tstruct archive *a;\n  794  \n  795  \tassert((a = archive_read_new()) != NULL);\n  ...\n  814  DEFINE_TEST(test_read_format_7zip_lzma2)\n  815  {\n  816: \tstruct archive *a;\n  817  \n  818  \tassert((a = archive_read_new()) != NULL);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_xattr_platform.c:\n   32  \tskipping(\"Extended attributes are not supported on this platform\");\n   33  #else /* ARCHIVE_XATTR_SUPPORT */\n   34: \tstruct archive *a;\n   35: \tstruct archive_entry *ae;\n   36  \tconst char *name;\n   37  \tconst void *value;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_mtree.c:\n   32  \tconst char reffile[] = \"test_read_format_mtree.mtree\";\n   33  \tchar buff[16];\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tFILE *f;\n   37  \t/* Compute max 64-bit signed twos-complement value\n   ..\n  281  \t    \"#mtree\\n\"\n  282  \t    \"d type=dir content=.\\n\";\n  283: \tstruct archive_entry *ae;\n  284: \tstruct archive *a;\n  285  \n  286  \tassert((a = archive_read_new()) != NULL);\n  ...\n  316  \t    \"b type=link link=a\\n\"\n  317  \t    \"c type=file contents=file\\n\";\n  318: \tstruct archive_entry *ae;\n  319: \tstruct archive *a;\n  320  \n  321  \tassertMakeDir(\"mtree3\", 0777);\n  ...\n  373  \t    \"./e\\n\"\n  374  \t    \"./f mode=0444\\n\";\n  375: \tstruct archive_entry *ae;\n  376: \tstruct archive *a;\n  377  \n  378  \tassertMakeFile(\"file\", 0644, \"file contents\");\n  ...\n  436  \t    \"./b type=file mode=0644 time=234\\n\"\n  437  \t    \"./c type=file mode=0644 time=345 nochange\\n\";\n  438: \tstruct archive_entry *ae;\n  439: \tstruct archive *a;\n  440  \n  441  \tassertMakeFile(\"a\", 0640, \"12345\");\n  ...\n  528  \tconst char reffile[] = \"test_read_format_mtree_nomagic.mtree\";\n  529  \tchar buff[16];\n  530: \tstruct archive_entry *ae;\n  531: \tstruct archive *a;\n  532  \tFILE *f;\n  533  \n  ...\n  633  \tconst char reffile[] = \"test_read_format_mtree_nomagic2.mtree\";\n  634  \tchar buff[16];\n  635: \tstruct archive_entry *ae;\n  636: \tstruct archive *a;\n  637  \tFILE *f;\n  638  \n  ...\n  700  \tconst char reffile[] = \"test_read_format_mtree_nomagic3.mtree\";\n  701  \tchar buff[16];\n  702: \tstruct archive_entry *ae;\n  703: \tstruct archive *a;\n  704  \tFILE *f;\n  705  \n  ...\n  768  \t    \"#mtree\\n\"\n  769  \t    \"a type=file contents=nonexistent_file\\n\";\n  770: \tstruct archive_entry *ae;\n  771: \tstruct archive *a;\n  772  \n  773  \tassert((a = archive_read_new()) != NULL);\n  ...\n  796  {\n  797  \tconst char reffile[] = \"test_read_format_mtree_noprint.mtree\";\n  798: \tstruct archive_entry *ae;\n  799: \tstruct archive *a;\n  800  \n  801  \textract_reference_file(reffile);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_acl_pax.c:\n   37  static unsigned char buff[16384];\n   38  \n   39: static struct archive_test_acl_t acls0[] = {\n   40  \t{ ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ARCHIVE_ENTRY_ACL_EXECUTE,\n   41  \t  ARCHIVE_ENTRY_ACL_USER_OBJ, 0, \"\" },\n   ..\n   46  };\n   47  \n   48: static struct archive_test_acl_t acls1[] = {\n   49  \t{ ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ARCHIVE_ENTRY_ACL_EXECUTE,\n   50  \t  ARCHIVE_ENTRY_ACL_USER_OBJ, -1, \"\" },\n   ..\n   57  };\n   58  \n   59: static struct archive_test_acl_t acls2[] = {\n   60  \t{ ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ARCHIVE_ENTRY_ACL_EXECUTE | ARCHIVE_ENTRY_ACL_READ,\n   61  \t  ARCHIVE_ENTRY_ACL_USER_OBJ, -1, \"\" },\n   ..\n   72  };\n   73  \n   74: static struct archive_test_acl_t acls3[] = {\n   75  \t{ ARCHIVE_ENTRY_ACL_TYPE_ALLOW,\n   76  \t    ARCHIVE_ENTRY_ACL_READ_DATA |\n   ..\n  106  };\n  107  \n  108: static struct archive_test_acl_t acls4[] = {\n  109  \t{ ARCHIVE_ENTRY_ACL_TYPE_ALLOW,\n  110  \t    ARCHIVE_ENTRY_ACL_READ_DATA |\n  ...\n  159  };\n  160  \n  161: static struct archive_test_acl_t acls5[] = {\n  162  \t{ ARCHIVE_ENTRY_ACL_TYPE_ALLOW,\n  163  \t    ARCHIVE_ENTRY_ACL_READ_DATA |\n  ...\n  216  DEFINE_TEST(test_acl_pax_posix1e)\n  217  {\n  218: \tstruct archive *a;\n  219: \tstruct archive_entry *ae;\n  220  \tsize_t used;\n  221  \tFILE *f;\n  ...\n  327  DEFINE_TEST(test_acl_pax_nfs4)\n  328  {\n  329: \tstruct archive *a;\n  330: \tstruct archive_entry *ae;\n  331  \tsize_t used;\n  332  \tFILE *f;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_isojoliet_rr.c:\n   59  {\n   60  \tconst char *refname = \"test_read_format_iso_joliet_rockridge.iso.Z\";\n   61: \tstruct archive_entry *ae;\n   62: \tstruct archive *a;\n   63  \tconst void *p;\n   64  \tsize_t size;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_raw_b64.c:\n   26  \n   27  static void\n   28: test_format(int\t(*set_format)(struct archive *))\n   29  {\n   30  \tchar filedata[64];\n   31: \tstruct archive_entry *ae;\n   32: \tstruct archive *a;\n   33  \tsize_t used;\n   34  \tsize_t buffsize = 1000000;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_bin_lzma.c:\n   37  DEFINE_TEST(test_read_format_cpio_bin_lzma)\n   38  {\n   39: \tstruct archive_entry *ae;\n   40: \tstruct archive *a;\n   41  \tint r;\n   42  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_iso9660_zisofs.c:\n   96  \tunsigned char buff2[1024];\n   97  \tunsigned char nullb[1024];\n   98: \tstruct archive *a;\n   99: \tstruct archive_entry *ae;\n  100  \tunsigned char *buff;\n  101  \tsize_t buffsize = 36 * 2048;\n  ...\n  329  \tunsigned char buff2[1024];\n  330  \tunsigned char data[1024];\n  331: \tstruct archive *a;\n  332: \tstruct archive_entry *ae;\n  333  \tunsigned char *buff;\n  334  \tsize_t buffsize = 60 * 2048;\n  ...\n  581  \tunsigned char buff2[1024];\n  582  \tunsigned char nullb[2048];\n  583: \tstruct archive *a;\n  584: \tstruct archive_entry *ae;\n  585  \tunsigned char *buff;\n  586  \tsize_t buffsize = 50 * 2048;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_extra_padding.c:\n   49  \n   50  \n   51: static void verify(struct archive *a) {\n   52: \tstruct archive_entry *ae;\n   53  \n   54  \tassertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));\n   ..\n   65  {\n   66  \tconst char *refname = \"test_read_format_zip_extra_padding.zip\";\n   67: \tstruct archive *a;\n   68  \tchar *p;\n   69  \tsize_t s;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_tar_empty_with_gnulabel.c:\n   33  {\n   34  \tchar name[] = \"test_read_format_tar_empty_with_gnulabel.tar\";\n   35: \tstruct archive_entry *ae;\n   36: \tstruct archive *a;\n   37  \n   38  \tassert((a = archive_read_new()) != NULL);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_lz4.c:\n   43  verify(const char *name, const char *n[])\n   44  {\n   45: \tstruct archive_entry *ae;\n   46: \tstruct archive *a;\n   47  \tint i,r;\n   48  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_too_many_filters.c:\n   28  {\n   29  \tconst char *name = \"test_read_too_many_filters.gz\";\n   30: \tstruct archive *a;\n   31  \tint r;\n   32  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_lha_bugfix_0.c:\n   29  {\n   30  \tconst char *refname = \"test_read_format_lha_bugfix_0.lzh\";\n   31: \tstruct archive_entry *ae;\n   32: \tstruct archive *a;\n   33  \tconst void *pv;\n   34  \tsize_t s;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_bin_be.c:\n   28  DEFINE_TEST(test_read_format_cpio_bin_be)\n   29  {\n   30: \tstruct archive_entry *ae;\n   31: \tstruct archive *a;\n   32  \tconst char *reference = \"test_read_format_cpio_bin_be.cpio\";\n   33  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_filter_lzma.c:\n   35  DEFINE_TEST(test_write_filter_lzma)\n   36  {\n   37: \tstruct archive_entry *ae;\n   38: \tstruct archive* a;\n   39  \tchar *buff, *data;\n   40  \tsize_t buffsize, datasize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_tz.c:\n   37  DEFINE_TEST(test_read_format_tz)\n   38  {\n   39: \tstruct archive_entry *ae;\n   40: \tstruct archive *a;\n   41  \tassert((a = archive_read_new()) != NULL);\n   42  \tassertEqualIntA(a, ARCHIVE_OK,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_gnutar_filenames.c:\n   40  \tsize_t buffsize = 1000000;\n   41  \tchar *buff;\n   42: \tstruct archive_entry *ae, *template;\n   43: \tstruct archive *a;\n   44  \tsize_t used;\n   45  \tint i;\n   ..\n   96  \tsize_t buffsize = 1000000;\n   97  \tchar *buff;\n   98: \tstruct archive_entry *ae, *template;\n   99: \tstruct archive *a;\n  100  \tsize_t used;\n  101  \tint i;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_open_file.c:\n   29  {\n   30  \tchar buff[64];\n   31: \tstruct archive_entry *ae;\n   32: \tstruct archive *a;\n   33  \tFILE *f;\n   34  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_appledouble.c:\n  109  #else\n  110  \tconst char *refname = \"test_write_disk_appledouble.cpio.gz\";\n  111: \tstruct archive *ad, *a;\n  112: \tstruct archive_entry *ae;\n  113: \tstruct stat st;\n  114  \tacl_t acl;\n  115  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_rar_encryption_partially.c:\n   32  \t   on this file. */\n   33  \tconst char *refname = \"test_read_format_rar_encryption_partially.rar\";\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tchar buff[128];\n   37  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_warc_empty.c:\n   29  DEFINE_TEST(test_write_format_warc_empty)\n   30  {\n   31: \tstruct archive *a;\n   32: \tstruct archive_entry *ae;\n   33  \tchar buff[512U];\n   34  \tsize_t used;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_zip64.c:\n   32   */\n   33  static void\n   34: verify_file0_seek(struct archive *a)\n   35  {\n   36: \tstruct archive_entry *ae;\n   37  \n   38  \tassertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));\n   ..\n   53  \n   54  static void\n   55: verify_file0_stream(struct archive *a, int size_known)\n   56  {\n   57: \tstruct archive_entry *ae;\n   58  \n   59  \tassertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));\n   ..\n   84  {\n   85  \tconst char *refname = \"test_read_format_zip_zip64a.zip\";\n   86: \tstruct archive *a;\n   87  \tchar *p;\n   88  \tsize_t s;\n   ..\n  108  {\n  109  \tconst char *refname = \"test_read_format_zip_zip64b.zip\";\n  110: \tstruct archive *a;\n  111  \tchar *p;\n  112  \tsize_t s;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_tar_hardlink.c:\n   48  {\n   49  \tchar name[] = \"test_compat_tar_hardlink_1.tar\";\n   50: \tstruct archive_entry *ae;\n   51: \tstruct archive *a;\n   52  \n   53  \tassert((a = archive_read_new()) != NULL);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_position.c:\n   31  size_t data_sizes[] = {0, 5, 511, 512, 513};\n   32  \n   33: static void verify_read_positions(struct archive *a);\n   34  \n   35  static void\n   36: verify_read_positions(struct archive *a)\n   37  {\n   38: \tstruct archive_entry *ae;\n   39  \tintmax_t read_position = 0;\n   40  \tsize_t j;\n   ..\n   68  DEFINE_TEST(test_read_position)\n   69  {\n   70: \tstruct archive *a;\n   71: \tstruct archive_entry *ae;\n   72  \tsize_t write_pos;\n   73  \tsize_t i;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_write_set_format_by_name.c:\n   32      int format_id, int dot_stored, const void *image, size_t image_size)\n   33  {\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tsize_t used;\n   37  \tsize_t buffsize = 1024 * 1024;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_isojoliet_bz2.c:\n   56  {\n   57  \tconst char *refname = \"test_read_format_iso_joliet.iso.Z\";\n   58: \tstruct archive_entry *ae;\n   59: \tstruct archive *a;\n   60  \tconst void *p;\n   61  \tsize_t size;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_tar_empty_pax.c:\n   39  \t * archiving an empty project.)\n   40  \t */\n   41: \tstruct archive_entry *ae;\n   42: \tstruct archive *a;\n   43  \tconst char *refname = \"test_read_format_tar_empty_pax.tar.Z\";\n   44  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_xz.c:\n   42  {\n   43  \tconst char *n[7] = { \"f1\", \"f2\", \"f3\", \"d1/f1\", \"d1/f2\", \"d1/f3\", NULL };\n   44: \tstruct archive_entry *ae;\n   45: \tstruct archive *a;\n   46  \tint i, r;\n   47  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk.c:\n   36  #define MODE_MASK 0777777\n   37  \n   38: static void create(struct archive_entry *ae, const char *msg)\n   39  {\n   40: \tstruct archive *ad;\n   41: \tstruct stat st;\n   42  \n   43  \t/* Write the entry to disk. */\n   ..\n   62  }\n   63  \n   64: static void create_reg_file(struct archive_entry *ae, const char *msg)\n   65  {\n   66  \tstatic const char data[]=\"abcdefghijklmnopqrstuvwxyz\";\n   67: \tstruct archive *ad;\n   68  \n   69  \t/* Write the entry to disk. */\n   ..\n  104  }\n  105  \n  106: static void create_reg_file2(struct archive_entry *ae, const char *msg)\n  107  {\n  108  \tconst int datasize = 100000;\n  109  \tchar *data;\n  110: \tstruct archive *ad;\n  111  \tint i;\n  112  \n  ...\n  138  }\n  139  \n  140: static void create_reg_file3(struct archive_entry *ae, const char *msg)\n  141  {\n  142  \tstatic const char data[]=\"abcdefghijklmnopqrstuvwxyz\";\n  143: \tstruct archive *ad;\n  144: \tstruct stat st;\n  145  \n  146  \t/* Write the entry to disk. */\n  ...\n  165  \n  166  \n  167: static void create_reg_file4(struct archive_entry *ae, const char *msg)\n  168  {\n  169  \tstatic const char data[]=\"abcdefghijklmnopqrstuvwxyz\";\n  170: \tstruct archive *ad;\n  171: \tstruct stat st;\n  172  \n  173  \t/* Write the entry to disk. */\n  ...\n  192  \n  193  #if defined(_WIN32) && !defined(__CYGWIN__)\n  194: static void create_reg_file_win(struct archive_entry *ae, const char *msg)\n  195  {\n  196  \tstatic const char data[]=\"abcdefghijklmnopqrstuvwxyz\";\n  197: \tstruct archive *ad;\n  198: \tstruct _stat st;\n  199  \twchar_t *p, *fname;\n  200  \tsize_t l;\n  ...\n  239  DEFINE_TEST(test_write_disk)\n  240  {\n  241: \tstruct archive_entry *ae;\n  242  #if defined(_WIN32) && !defined(__CYGWIN__)\n  243  \twchar_t *fullpath;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_read_set_format_option.c:\n   33  test(int pristine)\n   34  {\n   35: \tstruct archive* a = archive_read_new();\n   36  \tint known_option_rv = pristine ? ARCHIVE_FAILED : ARCHIVE_OK;\n   37  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_pax_xattr_rht_security_selinux.c:\n   31  DEFINE_TEST(test_read_pax_xattr_rht_security_selinux)\n   32  {\n   33: \tstruct archive *a;\n   34: \tstruct archive_entry *ae;\n   35  \tconst char *refname = \"test_read_pax_xattr_rht_security_selinux.tar\";\n   36  \tconst char *xname; /* For xattr tests. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_open_failure.c:\n   27  \n   28  #define MAGIC 123456789\n   29: struct my_data {\n   30  \tint magic;\n   31  \tint read_return;\n   ..\n   40  \n   41  static ssize_t\n   42: my_read(struct archive *a, void *_private, const void **buff)\n   43  {\n   44: \tstruct my_data *private = (struct my_data *)_private;\n   45  \t(void)a; /* UNUSED */\n   46  \t(void)buff; /* UNUSED */\n   ..\n   51  \n   52  static ssize_t\n   53: my_write(struct archive *a, void *_private, const void *buff, size_t s)\n   54  {\n   55: \tstruct my_data *private = (struct my_data *)_private;\n   56  \t(void)a; /* UNUSED */\n   57  \t(void)buff; /* UNUSED */\n   ..\n   63  \n   64  static int\n   65: my_open(struct archive *a, void *_private)\n   66  {\n   67: \tstruct my_data *private = (struct my_data *)_private;\n   68  \t(void)a; /* UNUSED */\n   69  \tassertEqualInt(MAGIC, private->magic);\n   ..\n   73  \n   74  static int\n   75: my_close(struct archive *a, void *_private)\n   76  {\n   77: \tstruct my_data *private = (struct my_data *)_private;\n   78  \t(void)a; /* UNUSED */\n   79  \tassertEqualInt(MAGIC, private->magic);\n   ..\n   85  DEFINE_TEST(test_open_failure)\n   86  {\n   87: \tstruct archive *a;\n   88: \tstruct my_data private;\n   89  \n   90  \tmemset(&private, 0, sizeof(private));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_entry.c:\n   57  \tchar buff[128];\n   58  \twchar_t wbuff[128];\n   59: \tstruct stat st;\n   60: \tstruct archive_entry *e, *e2;\n   61: \tconst struct stat *pst;\n   62  \tunsigned long set, clear; /* For fflag testing. */\n   63  \tint type, permset, tag, qual; /* For ACL testing. */\n   ..\n  746  \t */\n  747  \tmemset(&st, 0, sizeof(st));\n  748: \t/* Set all of the standard 'struct stat' fields. */\n  749  \tst.st_atime = 456789;\n  750  \tst.st_ctime = 345678;\n  ...\n  803  \tarchive_entry_set_size(e, 123456789);\n  804  \tarchive_entry_set_uid(e, 23);\n  805: \t/* Retrieve a stat structure. */\n  806  \tassert((pst = archive_entry_stat(e)) != NULL);\n  807  \tif (pst == NULL)\n  ...\n  825  #endif\n  826  \n  827: \t/* Changing any one value should update struct stat. */\n  828  \tarchive_entry_set_atime(e, 456788, 0);\n  829  \tassert((pst = archive_entry_stat(e)) != NULL);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_jar.c:\n   36  \tchar *p;\n   37  \tsize_t s;\n   38: \tstruct archive *a;\n   39: \tstruct archive_entry *ae;\n   40  \tchar data[16];\n   41  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_iso9660.c:\n   32  \tsize_t buffsize = 1000000;\n   33  \tchar *buff;\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tchar dirname[1024];\n   37  \tchar dir[6];\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_svr4_bzip2_rpm.c:\n   85  DEFINE_TEST(test_read_format_cpio_svr4_bzip2_rpm)\n   86  {\n   87: \tstruct archive_entry *ae;\n   88: \tstruct archive *a;\n   89  \tconst char *name = \"test_read_format_cpio_svr4_bzip2_rpm.rpm\";\n   90  \tint r;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_filter_lrzip.c:\n   31  \tconst char *n[] = {\n   32  \t\t\"d1/\", \"d1/f1\", \"d1/f2\", \"d1/f3\", \"f1\", \"f2\", \"f3\", NULL };\n   33: \tstruct archive_entry *ae;\n   34: \tstruct archive *a;\n   35  \tint i;\n   36  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_hfs_compression.c:\n   94  #else\n   95  \tconst char *refname = \"test_write_disk_hfs_compression.tgz\";\n   96: \tstruct archive *ad, *a;\n   97: \tstruct archive_entry *ae;\n   98: \tstruct stat st;\n   99  \tchar rsrc[50];\n  100  \tstatic const char rsrc_footer[50] = {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_tgz.c:\n   35  DEFINE_TEST(test_read_format_tgz)\n   36  {\n   37: \tstruct archive_entry *ae;\n   38: \tstruct archive *a;\n   39  \tint r;\n   40  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_link_resolver.c:\n   28  static void test_linkify_tar(void)\n   29  {\n   30: \tstruct archive_entry *entry, *e2;\n   31: \tstruct archive_entry_linkresolver *resolver;\n   32  \n   33  \t/* Initialize the resolver. */\n   ..\n   93  static void test_linkify_old_cpio(void)\n   94  {\n   95: \tstruct archive_entry *entry, *e2;\n   96: \tstruct archive_entry_linkresolver *resolver;\n   97  \n   98  \t/* Initialize the resolver. */\n   ..\n  128  static void test_linkify_new_cpio(void)\n  129  {\n  130: \tstruct archive_entry *entry, *e2;\n  131: \tstruct archive_entry_linkresolver *resolver;\n  132  \n  133  \t/* Initialize the resolver. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_secure746.c:\n   43  \tskipping(\"archive_write_disk security checks not supported on Windows\");\n   44  #else\n   45: \tstruct archive *a;\n   46: \tstruct archive_entry *ae;\n   47  \n   48  \t/* Start with a known umask. */\n   ..\n   88  \tskipping(\"archive_write_disk security checks not supported on Windows\");\n   89  #else\n   90: \tstruct archive *a;\n   91: \tstruct archive_entry *ae;\n   92  \n   93  \t/* Start with a known umask. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_rar_encryption_header.c:\n   31  \t   ARE encrypted. Password is \"12345678\". */\n   32  \tconst char *refname = \"test_read_format_rar_encryption_header.rar\";\n   33: \tstruct archive_entry *ae;\n   34: \tstruct archive *a;\n   35  \tchar buff[128];\n   36  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_cpio_odc.c:\n   45  DEFINE_TEST(test_write_format_cpio_odc)\n   46  {\n   47: \tstruct archive *a;\n   48: \tstruct archive_entry *entry;\n   49  \tchar *buff, *e, *file;\n   50  \tsize_t buffsize = 100000;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_filter_compress.c:\n   36  DEFINE_TEST(test_write_filter_compress)\n   37  {\n   38: \tstruct archive_entry *ae;\n   39: \tstruct archive* a;\n   40  \tchar *buff, *data;\n   41  \tsize_t buffsize, datasize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_isojoliet_long.c:\n   61  \tconst char *refname = \"test_read_format_iso_joliet_long.iso.Z\";\n   62  \tchar pathname[104];\n   63: \tstruct archive_entry *ae;\n   64: \tstruct archive *a;\n   65  \tconst void *p;\n   66  \tsize_t size;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_write_set_option.c:\n   33  test(int pristine)\n   34  {\n   35: \tstruct archive* a = archive_write_new();\n   36  \tint known_option_rv = pristine ? ARCHIVE_FAILED : ARCHIVE_OK;\n   37  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_iso9660_filename.c:\n   29   */\n   30  static void\n   31: add_entry(struct archive *a, const char *fname, const char *sym)\n   32  {\n   33: \tstruct archive_entry *ae;\n   34  \n   35  \tassert((ae = archive_entry_new()) != NULL);\n   ..\n   47  }\n   48  \n   49: struct fns {\n   50  \tsize_t\tmaxlen;\n   51  \tsize_t\tlongest_len;\n   ..\n   71   */\n   72  static void\n   73: verify_file(struct archive *a, enum vtype type, struct fns *fns)\n   74  {\n   75: \tstruct archive_entry *ae;\n   76  \tint i;\n   77  \n   ..\n  139  \n  140  static void\n  141: verify(unsigned char *buff, size_t used, enum vtype type, struct fns *fns)\n  142  {\n  143: \tstruct archive *a;\n  144: \tstruct archive_entry *ae;\n  145  \tsize_t i;\n  146  \n  ...\n  202      const char *opt)\n  203  {\n  204: \tstruct archive *a;\n  205  \tint i, l, fcnt;\n  206  \tconst int lens[] = {\n  ...\n  309  \tsize_t used;\n  310  \tint fcnt;\n  311: \tstruct fns fns;\n  312  \n  313  \tbuff = malloc(buffsize);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_gtar_filename.c:\n   31  {\n   32  \tconst char *refname = \"test_read_format_gtar_filename_eucjp.tar.Z\";\n   33: \tstruct archive *a;\n   34: \tstruct archive_entry *ae;\n   35  \n   36  \t/*\n   ..\n   84  {\n   85  \tconst char *refname = \"test_read_format_gtar_filename_cp866.tar.Z\";\n   86: \tstruct archive *a;\n   87: \tstruct archive_entry *ae;\n   88  \n   89  \t/*\n   ..\n  137  {\n  138  \tconst char *refname = \"test_read_format_gtar_filename_cp866.tar.Z\";\n  139: \tstruct archive *a;\n  140: \tstruct archive_entry *ae;\n  141  \n  142  \t/*\n  ...\n  189  {\n  190  \tconst char *refname = \"test_read_format_gtar_filename_koi8r.tar.Z\";\n  191: \tstruct archive *a;\n  192: \tstruct archive_entry *ae;\n  193  \n  194  \t/*\n  ...\n  242  {\n  243  \tconst char *refname = \"test_read_format_gtar_filename_koi8r.tar.Z\";\n  244: \tstruct archive *a;\n  245: \tstruct archive_entry *ae;\n  246  \n  247  \t/*\n  ...\n  294  {\n  295  \tconst char *refname = \"test_read_format_gtar_filename_eucjp.tar.Z\";\n  296: \tstruct archive *a;\n  297: \tstruct archive_entry *ae;\n  298  \n  299  \t/*\n  ...\n  345  {\n  346  \tconst char *refname = \"test_read_format_gtar_filename_cp866.tar.Z\";\n  347: \tstruct archive *a;\n  348: \tstruct archive_entry *ae;\n  349  \n  350  \t/*\n  ...\n  404  {\n  405  \tconst char *refname = \"test_read_format_gtar_filename_cp866.tar.Z\";\n  406: \tstruct archive *a;\n  407: \tstruct archive_entry *ae;\n  408  \n  409  \t/*\n  ...\n  450  {\n  451  \tconst char *refname = \"test_read_format_gtar_filename_koi8r.tar.Z\";\n  452: \tstruct archive *a;\n  453: \tstruct archive_entry *ae;\n  454  \n  455  \t/*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_7zip_malformed.c:\n   31  {\n   32  \tconst char *refname = \"test_read_format_7zip_malformed.7z\";\n   33: \tstruct archive *a;\n   34: \tstruct archive_entry *ae;\n   35  \n   36  \textract_reference_file(refname);\n   ..\n   48  {\n   49  \tconst char *refname = \"test_read_format_7zip_malformed2.7z\";\n   50: \tstruct archive *a;\n   51: \tstruct archive_entry *ae;\n   52  \n   53  \textract_reference_file(refname);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_padded.c:\n   31  \tchar *p;\n   32  \tsize_t s;\n   33: \tstruct archive *a;\n   34: \tstruct archive_entry *ae;\n   35  \n   36  \textract_reference_file(refname);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_odc.c:\n   49  DEFINE_TEST(test_read_format_cpio_odc)\n   50  {\n   51: \tstruct archive_entry *ae;\n   52: \tstruct archive *a;\n   53  \tassert((a = archive_read_new()) != NULL);\n   54  \tassertA(0 == archive_read_support_filter_all(a));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_read_add_passphrase.c:\n   28  __FBSDID(\"$FreeBSD$\");\n   29  \n   30: struct archive_read;\n   31: extern void __archive_read_reset_passphrase(struct archive_read *);\n   32: extern const char * __archive_read_next_passphrase(struct archive_read *);\n   33  \n   34  static void\n   35  test(int pristine)\n   36  {\n   37: \tstruct archive* a = archive_read_new();\n   38  \n   39  \tif (!pristine) {\n   ..\n   59  DEFINE_TEST(test_archive_read_add_passphrase_incorrect_sequance)\n   60  {\n   61: \tstruct archive* a = archive_read_new();\n   62: \tstruct archive_read *ar = (struct archive_read *)a;\n   63  \n   64  \tassertEqualInt(ARCHIVE_OK, archive_read_add_passphrase(a, \"pass1\"));\n   ..\n   73  DEFINE_TEST(test_archive_read_add_passphrase_single)\n   74  {\n   75: \tstruct archive* a = archive_read_new();\n   76: \tstruct archive_read *ar = (struct archive_read *)a;\n   77  \n   78  \tassertEqualInt(ARCHIVE_OK, archive_read_add_passphrase(a, \"pass1\"));\n   ..\n   90  DEFINE_TEST(test_archive_read_add_passphrase_multiple)\n   91  {\n   92: \tstruct archive* a = archive_read_new();\n   93: \tstruct archive_read *ar = (struct archive_read *)a;\n   94  \n   95  \tassertEqualInt(ARCHIVE_OK, archive_read_add_passphrase(a, \"pass1\"));\n   ..\n  109  \n  110  static const char *\n  111: callback1(struct archive *a, void *_client_data)\n  112  {\n  113  \t(void)a; /* UNUSED */\n  ...\n  118  DEFINE_TEST(test_archive_read_add_passphrase_set_callback1)\n  119  {\n  120: \tstruct archive* a = archive_read_new();\n  121: \tstruct archive_read *ar = (struct archive_read *)a;\n  122  \n  123  \tassertEqualInt(ARCHIVE_OK,\n  ...\n  135  \t * should work fine. */\n  136  \ta = archive_read_new();\n  137: \tar = (struct archive_read *)a;\n  138  \tassertEqualInt(ARCHIVE_OK,\n  139  \t    archive_read_set_passphrase_callback(a, NULL, callback1));\n  ...\n  147  \n  148  static const char *\n  149: callback2(struct archive *a, void *_client_data)\n  150  {\n  151  \tint *cd = (int *)_client_data;\n  ...\n  162  DEFINE_TEST(test_archive_read_add_passphrase_set_callback2)\n  163  {\n  164: \tstruct archive* a = archive_read_new();\n  165: \tstruct archive_read *ar = (struct archive_read *)a;\n  166  \tint client_data = 0;\n  167  \n  ...\n  181  DEFINE_TEST(test_archive_read_add_passphrase_set_callback3)\n  182  {\n  183: \tstruct archive* a = archive_read_new();\n  184: \tstruct archive_read *ar = (struct archive_read *)a;\n  185  \tint client_data = 0;\n  186  \n  ...\n  203  DEFINE_TEST(test_archive_read_add_passphrase_multiple_with_callback)\n  204  {\n  205: \tstruct archive* a = archive_read_new();\n  206: \tstruct archive_read *ar = (struct archive_read *)a;\n  207  \tint client_data = 0;\n  208  \n  ...\n  228  DEFINE_TEST(test_archive_read_add_passphrase_multiple_with_callback2)\n  229  {\n  230: \tstruct archive* a = archive_read_new();\n  231: \tstruct archive_read *ar = (struct archive_read *)a;\n  232  \tint client_data = 0;\n  233  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_iso_xorriso.c:\n   68  {\n   69  \tconst char *refname = \"test_read_format_iso_xorriso.iso.Z\";\n   70: \tstruct archive_entry *ae;\n   71: \tstruct archive *a;\n   72  \tconst void *p;\n   73  \tsize_t size;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_filter_lzop_multiple_parts.c:\n   29  {\n   30  \tconst char *reference = \"test_read_filter_lzop_multiple_parts.tar.lzo\";\n   31: \tstruct archive_entry *ae;\n   32: \tstruct archive *a;\n   33  \tint r;\n   34  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_read_next_header_empty.c:\n   30  test_empty_file1(void)\n   31  {\n   32: \tstruct archive* a = archive_read_new();\n   33  \n   34  \t/* Try opening an empty file with the raw handler. */\n   ..\n   45  \n   46  static void\n   47: test_empty_file2_check(struct archive* a)\n   48  {\n   49: \tstruct archive_entry* e;\n   50  \tassertEqualInt(0, archive_errno(a));\n   51  \tassertEqualString(NULL, archive_error_string(a));\n   ..\n   65  test_empty_file2(void)\n   66  {\n   67: \tstruct archive* a = archive_read_new();\n   68  \n   69  \t/* Try opening an empty file with raw and empty handlers. */\n   ..\n   84  test_empty_tarfile(void)\n   85  {\n   86: \tstruct archive* a = archive_read_new();\n   87: \tstruct archive_entry* e;\n   88  \n   89  \t/* Try opening an empty file with raw and empty handlers. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_filter_program_signature.c:\n   40  {\n   41  \tint r;\n   42: \tstruct archive_entry *ae;\n   43: \tstruct archive *a;\n   44  \n   45  \t/*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_tar_sparse.c:\n   32  test_1(void)\n   33  {\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tsize_t used;\n   37  \tsize_t blocksize;\n   ..\n  175  test_2(void)\n  176  {\n  177: \tstruct archive_entry *ae;\n  178: \tstruct archive *a;\n  179  \tsize_t used;\n  180  \tsize_t blocksize = 20 * 512;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_filter_program.c:\n   32  DEFINE_TEST(test_write_filter_program)\n   33  {\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tsize_t used;\n   37  \tint blocksize = 1024;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_nested.c:\n   31  \tchar *p, *inner;\n   32  \tsize_t s, innerLength;\n   33: \tstruct archive *a;\n   34: \tstruct archive_entry *ae;\n   35  \n   36  \textract_reference_file(refname);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_7zip_encryption_data.c:\n   31  \t   are NOT encrypted. Password is \"12345678\". */\n   32  \tconst char *refname = \"test_read_format_7zip_encryption.7z\";\n   33: \tstruct archive_entry *ae;\n   34: \tstruct archive *a;\n   35  \tchar buff[128];\n   36  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_write_set_passphrase.c:\n   28  __FBSDID(\"$FreeBSD$\");\n   29  \n   30: struct archive_write;\n   31: extern const char * __archive_write_get_passphrase(struct archive_write *);\n   32  \n   33  static void\n   34  test(int pristine)\n   35  {\n   36: \tstruct archive* a = archive_write_new();\n   37: \tstruct archive_write* aw = (struct archive_write *)a;\n   38  \n   39  \tif (!pristine) {\n   ..\n   64  \n   65  static const char *\n   66: callback1(struct archive *a, void *_client_data)\n   67  {\n   68  \tint *cnt;\n   ..\n   77  DEFINE_TEST(test_archive_write_set_passphrase_callback)\n   78  {\n   79: \tstruct archive* a = archive_write_new();\n   80: \tstruct archive_write* aw = (struct archive_write *)a;\n   81  \tint cnt = 0;\n   82  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_zip.c:\n   30  {\n   31  \tchar name[] = \"test_compat_zip_1.zip\";\n   32: \tstruct archive_entry *ae;\n   33: \tstruct archive *a;\n   34  \tint r;\n   35  \n   ..\n   73  {\n   74  \tchar name[] = \"test_compat_zip_2.zip\";\n   75: \tstruct archive_entry *ae;\n   76: \tstruct archive *a;\n   77  \n   78  \tassert((a = archive_read_new()) != NULL);\n   ..\n  102  {\n  103  \tconst char *refname = \"test_compat_zip_3.zip\";\n  104: \tstruct archive_entry *ae;\n  105: \tstruct archive *a;\n  106  \n  107  \textract_reference_file(refname);\n  ...\n  151  {\n  152  \tconst char *refname = \"test_compat_zip_4.zip\";\n  153: \tstruct archive_entry *ae;\n  154: \tstruct archive *a;\n  155  \tvoid *p;\n  156  \tsize_t s;\n  ...\n  209  {\n  210  \tconst char *refname = \"test_compat_zip_5.zip\";\n  211: \tstruct archive_entry *ae;\n  212: \tstruct archive *a;\n  213  \tvoid *p;\n  214  \tsize_t s;\n  ...\n  342   */\n  343  static void\n  344: compat_zip_6_verify(struct archive *a)\n  345  {\n  346: \tstruct archive_entry *ae;\n  347  \n  348  \tassertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));\n  ...\n  366  {\n  367  \tconst char *refname = \"test_compat_zip_6.zip\";\n  368: \tstruct archive *a;\n  369  \tvoid *p;\n  370  \tsize_t s;\n  ...\n  396  {\n  397  \tconst char *refname = \"test_compat_zip_7.xps\";\n  398: \tstruct archive *a;\n  399: \tstruct archive_entry *ae;\n  400  \tvoid *p;\n  401  \tsize_t s;\n  ...\n  431  {\n  432  \tconst char *refname = \"test_compat_zip_8.zip\";\n  433: \tstruct archive *a;\n  434: \tstruct archive_entry *ae;\n  435  \tvoid *p;\n  436  \tsize_t s;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_fuzz.c:\n   47  /* Because this works for any archive, we can just re-use the archives\n   48   * developed for other tests. */\n   49: struct files {\n   50  \tint uncompress; /* If 1, decompress the file before fuzzing. */\n   51  \tconst char **names;\n   ..\n   53  \n   54  static void\n   55: test_fuzz(const struct files *filesets)\n   56  {\n   57  \tconst void *blk;\n   ..\n   70  \tfor (n = 0; filesets[n].names != NULL; ++n) {\n   71  \t\tconst size_t buffsize = 30000000;\n   72: \t\tstruct archive_entry *ae;\n   73: \t\tstruct archive *a;\n   74  \t\tchar *rawimage = NULL, *image = NULL, *tmp = NULL;\n   75  \t\tsize_t size = 0, oldsize = 0;\n   ..\n  229  \t\tNULL\n  230  \t};\n  231: \tstatic const struct files filesets[] = {\n  232  \t\t{0, fileset1},\n  233  \t\t{1, NULL}\n  ...\n  242  \t\tNULL\n  243  \t};\n  244: \tstatic const struct files filesets[] = {\n  245  \t\t{0, fileset1},\n  246  \t\t{1, NULL}\n  ...\n  264  \t\tNULL\n  265  \t};\n  266: \tstatic const struct files filesets[] = {\n  267  \t\t{0, fileset1},\n  268  \t\t{0, fileset2},\n  ...\n  279  \t\tNULL\n  280  \t};\n  281: \tstatic const struct files filesets[] = {\n  282  \t\t{0, fileset1}, /* Exercise compress decompressor. */\n  283  \t\t{1, fileset1},\n  ...\n  293  \t\tNULL\n  294  \t};\n  295: \tstatic const struct files filesets[] = {\n  296  \t\t{0, fileset1},\n  297  \t\t{1, NULL}\n  ...\n  306  \t\tNULL\n  307  \t};\n  308: \tstatic const struct files filesets[] = {\n  309  \t\t{0, fileset1},\n  310  \t\t{1, NULL}\n  ...\n  367  \t\tNULL\n  368  \t};\n  369: \tstatic const struct files filesets[] = {\n  370  \t\t{0, fileset1},\n  371  \t\t{0, fileset2},\n  ...\n  429  \t};\n  430  #endif\n  431: \tstatic const struct files filesets[] = {\n  432  \t\t{0, fileset1}, /* Exercise bzip2 decompressor. */\n  433  \t\t{1, fileset1},\n  ...\n  597  \t};\n  598  \n  599: \tstatic const struct files filesets[] = {\n  600  \t\t{0, fileset1},\n  601  \t\t{0, fileset2},\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_zip_empty.c:\n   33  DEFINE_TEST(test_write_format_zip_empty)\n   34  {\n   35: \tstruct archive *a;\n   36: \tstruct archive_entry *ae;\n   37  \tchar buff[256];\n   38  \tsize_t used;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_filter_lrzip.c:\n   33  DEFINE_TEST(test_write_filter_lrzip)\n   34  {\n   35: \tstruct archive_entry *ae;\n   36: \tstruct archive* a;\n   37  \tchar *buff, *data;\n   38  \tsize_t buffsize, datasize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_mac.c:\n   46  {\n   47  \tchar name[] = \"test_compat_mac-1.tar.Z\";\n   48: \tstruct archive_entry *ae;\n   49: \tstruct archive *a;\n   50  \tconst void *attr;\n   51  \tsize_t attrSize;\n   ..\n  143  {\n  144  \tchar name[] = \"test_compat_mac-2.tar.Z\";\n  145: \tstruct archive_entry *ae;\n  146: \tstruct archive *a;\n  147  \tconst void *attr;\n  148  \tsize_t attrSize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_lha.c:\n  136  verify(const char *refname, int posix)\n  137  {\n  138: \tstruct archive_entry *ae;\n  139: \tstruct archive *a;\n  140  \tchar buff[128];\n  141  \tconst void *pv;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_rar.c:\n   31  DEFINE_TEST(test_read_format_rar_set_format)\n   32  {\n   33:     struct archive *a;\n   34:     struct archive_entry *ae;\n   35      const char reffile[] = \"test_read_format_rar.rar\";\n   36  \n   ..\n   51    const char test_txt[] = \"test text document\\r\\n\";\n   52    int size = sizeof(test_txt)-1;\n   53:   struct archive_entry *ae;\n   54:   struct archive *a;\n   55  \n   56    extract_reference_file(reffile);\n   ..\n  134    const char test_txt[] = \"test text document\\r\\n\";\n  135    int size = sizeof(test_txt)-1;\n  136:   struct archive_entry *ae;\n  137:   struct archive *a;\n  138  \n  139    extract_reference_file(reffile);\n  ...\n  169    const char test_txt[] = \"test text document\\r\\n\";\n  170    int size = sizeof(test_txt)-1;\n  171:   struct archive_entry *ae;\n  172:   struct archive *a;\n  173  \n  174    extract_reference_file(reffile);\n  ...\n  203    const char reffile[] = \"test_read_format_rar_unicode.rar\";\n  204    const char test_txt[] = \"kanji\";\n  205:   struct archive_entry *ae;\n  206:   struct archive *a;\n  207  \n  208    if (NULL == setlocale(LC_ALL, \"en_US.UTF-8\")) {\n  ...\n  334    const char reffile[] = \"test_read_format_rar_unicode.rar\";\n  335    const char test_txt[] = \"kanji\";\n  336:   struct archive_entry *ae;\n  337:   struct archive *a;\n  338  \n  339    if (NULL == setlocale(LC_ALL, \"Japanese_Japan\") &&\n  ...\n  448    int file2_size = sizeof(file2_buff);\n  449    const char file2_test_txt[] = \"test text document\\r\\n\";\n  450:   struct archive_entry *ae;\n  451:   struct archive *a;\n  452  \n  453    extract_reference_file(reffile);\n  ...\n  551    int size = 20131111, offset = 0;\n  552    char buff[64];\n  553:   struct archive_entry *ae;\n  554:   struct archive *a;\n  555  \n  556    extract_reference_file(reffile);\n  ...\n  597    int file2_size = sizeof(file2_buff);\n  598    const char file2_test_txt[] = \"test text document\\r\\n\";\n  599:   struct archive_entry *ae;\n  600:   struct archive *a;\n  601  \n  602    extract_reference_file(reffile);\n  ...\n  700    int size = 241647978, offset = 0;\n  701    char buff[64];\n  702:   struct archive_entry *ae;\n  703:   struct archive *a;\n  704  \n  705    extract_reference_file(reffile);\n  ...\n  752                                  \"\\x00\\x12\\x00\\x12\\x00\\xaa\\x04\\x00\\x00\\xaa\\x7a\"\n  753                                  \"\\x00\\x00\\x00\\x00\";\n  754:   struct archive_entry *ae;\n  755:   struct archive *a;\n  756  \n  757    extract_reference_file(reffile);\n  ...\n  804    const char test_txt[] = \"test text file\\r\\n\";\n  805    int size = sizeof(test_txt)-1;\n  806:   struct archive_entry *ae;\n  807:   struct archive *a;\n  808  \n  809    extract_reference_file(reffile);\n  ...\n  903    int file3_size = sizeof(file3_buff);\n  904    const char file3_test_txt[] = \"test text document\\r\\n\";\n  905:   struct archive_entry *ae;\n  906:   struct archive *a;\n  907  \n  908    extract_reference_files(reffiles);\n  ...\n 1030    int file2_size = 20111;\n 1031    int file3_size = 20;\n 1032:   struct archive_entry *ae;\n 1033:   struct archive *a;\n 1034  \n 1035    extract_reference_files(reffiles);\n ....\n 1132    const char test_txt[] = \"test text file\\r\\n\";\n 1133    int size = sizeof(test_txt)-1;\n 1134:   struct archive_entry *ae;\n 1135:   struct archive *a;\n 1136  \n 1137    extract_reference_file(reffile);\n ....\n 1223                                  \"</BODY>\\n\"\n 1224                                  \"</HTML>\";\n 1225:   struct archive_entry *ae;\n 1226:   struct archive *a;\n 1227  \n 1228    extract_reference_files(reffiles);\n ....\n 1263    };\n 1264    int file_size = 20111;\n 1265:   struct archive_entry *ae;\n 1266:   struct archive *a;\n 1267  \n 1268    extract_reference_files(reffiles);\n ....\n 1311    const char file_test_txt5[] = \"SS=\\\"western\\\">make check</TT> will usually\"\n 1312                                  \" run\\n\\tall of the tests.\";\n 1313:   struct archive_entry *ae;\n 1314:   struct archive *a;\n 1315  \n 1316    extract_reference_files(reffiles);\n ....\n 1451    const char file_test_txt8[] = \"lt\\ninput file and verify the results. Thes\"\n 1452                                  \"e use <TT CLASS=\\\"weste\";\n 1453:   struct archive_entry *ae;\n 1454:   struct archive *a;\n 1455  \n 1456    extract_reference_files(reffiles);\n ....\n 1572  \n 1573  static void\n 1574: test_read_format_rar_multivolume_uncompressed_files_helper(struct archive *a)\n 1575  {\n 1576    char buff[64];\n ....\n 1643    char buff[64];\n 1644    ssize_t bytes_read;\n 1645:   struct archive *a;\n 1646:   struct archive_entry *ae;\n 1647  \n 1648    extract_reference_files(reffiles);\n ....\n 3763    const char* reffile = \"test_read_format_rar_ppmd_use_after_free.rar\";\n 3764  \n 3765:   struct archive_entry *ae;\n 3766:   struct archive *a;\n 3767  \n 3768    extract_reference_file(reffile);\n ....\n 3789    const char* reffile = \"test_read_format_rar_ppmd_use_after_free2.rar\";\n 3790  \n 3791:   struct archive_entry *ae;\n 3792:   struct archive *a;\n 3793  \n 3794    extract_reference_file(reffile);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_read_set_options.c:\n   33  test(int pristine)\n   34  {\n   35: \tstruct archive* a = archive_read_new();\n   36  \tint halfempty_options_rv = pristine ? ARCHIVE_FAILED : ARCHIVE_OK;\n   37  \tint known_option_rv = pristine ? ARCHIVE_FAILED : ARCHIVE_OK;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_isorr_bz2.c:\n   56  {\n   57  \tconst char *refname = \"test_read_format_iso_rockridge.iso.Z\";\n   58: \tstruct archive_entry *ae;\n   59: \tstruct archive *a;\n   60  \tconst void *p;\n   61  \tsize_t size;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_7zip_encryption_header.c:\n   32  \t   ARE encrypted. Password is \"12345678\". */\n   33  \tconst char *refname = \"test_read_format_7zip_encryption_header.7z\";\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tchar buff[128];\n   37  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_clear_error.c:\n   29  DEFINE_TEST(test_archive_clear_error)\n   30  {\n   31: \tstruct archive* a = archive_read_new();\n   32  \n   33  \tarchive_set_error(a, 12, \"abcdefgh\");\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_disk_secure.c:\n   38  \tskipping(\"archive_write_disk security checks not supported on Windows\");\n   39  #else\n   40: \tstruct archive *a;\n   41: \tstruct archive_entry *ae;\n   42: \tstruct stat st;\n   43  #if defined(HAVE_LCHMOD) && defined(HAVE_SYMLINK) && \\\n   44      defined(S_IRUSR) && defined(S_IWUSR) && defined(S_IXUSR)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_filename.c:\n   31  {\n   32  \tconst char *refname = \"test_read_format_zip_filename_cp932.zip\";\n   33: \tstruct archive *a;\n   34: \tstruct archive_entry *ae;\n   35  \n   36  \t/*\n   ..\n   91  {\n   92  \tconst char *refname = \"test_read_format_zip_filename_cp932.zip\";\n   93: \tstruct archive *a;\n   94: \tstruct archive_entry *ae;\n   95  \n   96  \t/*\n   ..\n  169  {\n  170  \tconst char *refname = \"test_read_format_zip_filename_utf8_jp.zip\";\n  171: \tstruct archive *a;\n  172: \tstruct archive_entry *ae;\n  173  \n  174  \t/*\n  ...\n  244  {\n  245  \tconst char *refname = \"test_read_format_zip_filename_utf8_jp.zip\";\n  246: \tstruct archive *a;\n  247: \tstruct archive_entry *ae;\n  248  \n  249  \t/*\n  ...\n  338  {\n  339  \tconst char *refname = \"test_read_format_zip_filename_cp866.zip\";\n  340: \tstruct archive *a;\n  341: \tstruct archive_entry *ae;\n  342  \n  343  \t/*\n  ...\n  395  {\n  396  \tconst char *refname = \"test_read_format_zip_filename_cp866.zip\";\n  397: \tstruct archive *a;\n  398: \tstruct archive_entry *ae;\n  399  \n  400  \t/*\n  ...\n  451  {\n  452  \tconst char *refname = \"test_read_format_zip_filename_koi8r.zip\";\n  453: \tstruct archive *a;\n  454: \tstruct archive_entry *ae;\n  455  \n  456  \t/*\n  ...\n  508  {\n  509  \tconst char *refname = \"test_read_format_zip_filename_koi8r.zip\";\n  510: \tstruct archive *a;\n  511: \tstruct archive_entry *ae;\n  512  \n  513  \t/*\n  ...\n  564  {\n  565  \tconst char *refname = \"test_read_format_zip_filename_utf8_ru.zip\";\n  566: \tstruct archive *a;\n  567: \tstruct archive_entry *ae;\n  568  \n  569  \t/*\n  ...\n  626  {\n  627  \tconst char *refname = \"test_read_format_zip_filename_utf8_ru.zip\";\n  628: \tstruct archive *a;\n  629: \tstruct archive_entry *ae;\n  630  \n  631  \t/*\n  ...\n  691  {\n  692  \tconst char *refname = \"test_read_format_zip_filename_utf8_ru.zip\";\n  693: \tstruct archive *a;\n  694: \tstruct archive_entry *ae;\n  695  \n  696  \t/*\n  ...\n  743  {\n  744  \tconst char *refname = \"test_read_format_zip_filename_cp932.zip\";\n  745: \tstruct archive *a;\n  746: \tstruct archive_entry *ae;\n  747  \n  748  \t/*\n  ...\n  802  {\n  803  \tconst char *refname = \"test_read_format_zip_filename_utf8_jp.zip\";\n  804: \tstruct archive *a;\n  805: \tstruct archive_entry *ae;\n  806  \n  807  \t/*\n  ...\n  879  {\n  880  \tconst char *refname = \"test_read_format_zip_filename_cp866.zip\";\n  881: \tstruct archive *a;\n  882: \tstruct archive_entry *ae;\n  883  \n  884  \t/*\n  ...\n  942  {\n  943  \tconst char *refname = \"test_read_format_zip_filename_cp866.zip\";\n  944: \tstruct archive *a;\n  945: \tstruct archive_entry *ae;\n  946  \n  947  \t/*\n  ...\n  992  {\n  993  \tconst char *refname = \"test_read_format_zip_filename_koi8r.zip\";\n  994: \tstruct archive *a;\n  995: \tstruct archive_entry *ae;\n  996  \n  997  \t/*\n  ...\n 1049  {\n 1050  \tconst char *refname = \"test_read_format_zip_filename_utf8_ru.zip\";\n 1051: \tstruct archive *a;\n 1052: \tstruct archive_entry *ae;\n 1053  \n 1054  \t/*\n ....\n 1123  {\n 1124  \tconst char *refname = \"test_read_format_zip_filename_utf8_ru2.zip\";\n 1125: \tstruct archive *a;\n 1126: \tstruct archive_entry *ae;\n 1127  \n 1128  \t/*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_traditional_encryption_data.c:\n   33  \tconst char *refname =\n   34  \t\t\"test_read_format_zip_traditional_encryption_data.zip\";\n   35: \tstruct archive_entry *ae;\n   36: \tstruct archive *a;\n   37  \tchar buff[512];\n   38  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_raw.c:\n   32  {\n   33  \tchar buff[512];\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \tconst char *reffile1 = \"test_read_format_raw.data\";\n   37  \tconst char *reffile2 = \"test_read_format_raw.data.Z\";\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_cpio.c:\n   45  {\n   46  \tchar name[] = \"test_compat_cpio_1.cpio\";\n   47: \tstruct archive_entry *ae;\n   48: \tstruct archive *a;\n   49  \n   50  \tassert((a = archive_read_new()) != NULL);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_tar_empty_filename.c:\n   32  {\n   33  \tchar name[] = \"test_read_format_tar_empty_filename.tar\";\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive *a;\n   36  \n   37  \tassert((a = archive_read_new()) != NULL);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_isorr_rr_moved.c:\n   62  {\n   63  \tconst char *refname = \"test_read_format_iso_rockridge_rr_moved.iso.Z\";\n   64: \tstruct archive_entry *ae;\n   65: \tstruct archive *a;\n   66  \tconst void *p;\n   67  \tsize_t size;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_ar.c:\n   35  DEFINE_TEST(test_write_format_ar)\n   36  {\n   37: \tstruct archive_entry *ae;\n   38: \tstruct archive* a;\n   39  \tsize_t used;\n   40  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_acl_nfs4.c:\n   34   */\n   35  \n   36: static struct archive_test_acl_t acls1[] = {\n   37  \t{ ARCHIVE_ENTRY_ACL_TYPE_ALLOW, ARCHIVE_ENTRY_ACL_EXECUTE,\n   38  \t  ARCHIVE_ENTRY_ACL_USER_OBJ, -1, \"\" },\n   ..\n   45  };\n   46  \n   47: static struct archive_test_acl_t acls2[] = {\n   48  \t/* An entry for each type. */\n   49  \t{ ARCHIVE_ENTRY_ACL_TYPE_ALLOW, 0,\n   ..\n  129   * on an ACL that already has NFS4 entries.\n  130   */\n  131: static struct archive_test_acl_t acls_bad[] = {\n  132  \t/* POSIX.1e ACL types */\n  133  \t{ ARCHIVE_ENTRY_ACL_TYPE_ACCESS, ARCHIVE_ENTRY_ACL_EXECUTE,\n  ...\n  151  DEFINE_TEST(test_acl_nfs4)\n  152  {\n  153: \tstruct archive_entry *ae;\n  154  \tint i;\n  155  \n  ...\n  195  \tassertEntrySetAcls(ae, acls2, sizeof(acls2)/sizeof(acls2[0]));\n  196  \tfor (i = 0; i < (int)(sizeof(acls_bad)/sizeof(acls_bad[0])); ++i) {\n  197: \t\tstruct archive_test_acl_t *p = &acls_bad[i];\n  198  \t\tfailure(\"Malformed ACL test #%d\", i);\n  199  \t\tassertEqualInt(ARCHIVE_FAILED,\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_gtar_sparse.c:\n   27  \n   28  \n   29: struct contents {\n   30  \tint64_t\to;\n   31  \tsize_t\ts;\n   ..\n   33  };\n   34  \n   35: struct contents archive_contents_sparse[] = {\n   36  \t{ 1000000, 1, \"a\" },\n   37  \t{ 2000000, 1, \"a\" },\n   ..\n   39  };\n   40  \n   41: struct contents archive_contents_sparse2[] = {\n   42  \t{ 1000000, 1, \"a\" },\n   43  \t{ 2000000, 1, \"a\" },\n   ..\n  142  };\n  143  \n  144: struct contents archive_contents_nonsparse[] = {\n  145  \t{ 0, 1, \"a\" },\n  146  \t{ 1, 0, NULL }\n  ...\n  162   */\n  163  \n  164: struct archive_contents {\n  165  \tconst char *filename;\n  166: \tstruct contents *contents;\n  167  } files[] = {\n  168  \t{ \"sparse\", archive_contents_sparse },\n  ...\n  173  \n  174  static void\n  175: verify_archive_file(const char *name, struct archive_contents *ac)\n  176  {\n  177: \tstruct archive_entry *ae;\n  178  \tint err;\n  179  \t/* data, size, offset of next expected block. */\n  180: \tstruct contents expect;\n  181  \t/* data, size, offset of block read from archive. */\n  182: \tstruct contents actual;\n  183  \tconst void *p;\n  184: \tstruct archive *a;\n  185  \n  186  \textract_reference_file(name);\n  ...\n  193  \n  194  \twhile (ac->filename != NULL) {\n  195: \t\tstruct contents *cts = ac->contents;\n  196  \n  197  \t\tif (!assertEqualIntA(a, 0, archive_read_next_header(a, &ae))) {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_open_filename.c:\n   30  {\n   31  \tchar buff[64];\n   32: \tstruct archive_entry *ae;\n   33: \tstruct archive *a;\n   34  \n   35  \t/* Write an archive through this FILE *. */\n   ..\n  114  {\n  115  \tchar buff[64];\n  116: \tstruct archive_entry *ae;\n  117: \tstruct archive *a;\n  118  \n  119  \t/* Write an archive through this FILE *. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_compat_perl_archive_tar.c:\n   33  {\n   34  \tchar name[] = \"test_compat_perl_archive_tar.tar\";\n   35: \tstruct archive_entry *ae;\n   36: \tstruct archive *a;\n   37  \tint r;\n   38  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_read_multiple_data_objects.c:\n   54    const char test_txt[] = \"test text document\\r\\n\";\n   55    int size = sizeof(test_txt)-1;\n   56:   struct archive_entry *ae;\n   57:   struct archive *a;\n   58  \n   59    extract_reference_files(reffiles);\n   ..\n  136    int size = 241647978, offset = 0;\n  137    char buff[64];\n  138:   struct archive_entry *ae;\n  139:   struct archive *a;\n  140  \n  141    extract_reference_files(reffiles);\n  ...\n  170  \n  171  #define BLOCK_SIZE 10240\n  172: struct mydata {\n  173    char *filename;\n  174    void *buffer;\n  ...\n  177  \n  178  static int\n  179: file_open(struct archive *a, void *data)\n  180  {\n  181:   struct mydata *mydata = (struct mydata *)data;\n  182    (void)a;\n  183    if (mydata->fd < 0)\n  ...\n  193  }\n  194  static ssize_t\n  195: file_read(struct archive *a, void *data, const void **buff)\n  196  {\n  197:   struct mydata *mydata = (struct mydata *)data;\n  198    (void)a;\n  199    *buff = mydata->buffer;\n  ...\n  201  }\n  202  static int64_t\n  203: file_skip(struct archive *a, void *data, int64_t request)\n  204  {\n  205:   struct mydata *mydata = (struct mydata *)data;\n  206    int64_t result = lseek(mydata->fd, SEEK_CUR, request);\n  207    if (result >= 0)\n  ...\n  211  }\n  212  static int\n  213: file_switch(struct archive *a, void *data1, void *data2)\n  214  {\n  215:   struct mydata *mydata1 = (struct mydata *)data1;\n  216:   struct mydata *mydata2 = (struct mydata *)data2;\n  217    int r = (ARCHIVE_OK);\n  218  \n  ...\n  232  }\n  233  static int\n  234: file_close(struct archive *a, void *data)\n  235  {\n  236:   struct mydata *mydata = (struct mydata *)data;\n  237    if (mydata == NULL)\n  238      return (ARCHIVE_FATAL);\n  ...\n  243  }\n  244  static int64_t\n  245: file_seek(struct archive *a, void *data, int64_t request, int whence)\n  246  {\n  247:   struct mydata *mine = (struct mydata *)data;\n  248    int64_t r;\n  249  \n  ...\n  269    const char test_txt[] = \"test text document\\r\\n\";\n  270    int size = sizeof(test_txt)-1;\n  271:   struct archive_entry *ae;\n  272:   struct archive *a;\n  273:   struct mydata *mydata;\n  274    const char *filename = *reffiles;\n  275    int i;\n  ...\n  282    for (i = 0; filename != NULL;)\n  283    {\n  284:     assert((mydata = (struct mydata *)calloc(1, sizeof(*mydata))) != NULL);\n  285      if (mydata == NULL) {\n  286        assertEqualInt(ARCHIVE_OK, archive_read_free(a));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_mtree_absolute_path.c:\n   32  DEFINE_TEST(test_write_format_mtree_absolute_path)\n   33  {\n   34: \tstruct archive_entry *ae;\n   35: \tstruct archive* a;\n   36  \tsize_t used;\n   37  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_filter_gzip.c:\n   36  DEFINE_TEST(test_write_filter_gzip)\n   37  {\n   38: \tstruct archive_entry *ae;\n   39: \tstruct archive* a;\n   40  \tchar *buff, *data;\n   41  \tsize_t buffsize, datasize;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_zip_sfx.c:\n   34  \tchar *p;\n   35  \tsize_t s;\n   36: \tstruct archive *a;\n   37: \tstruct archive_entry *ae;\n   38  \n   39  \textract_reference_file(refname);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test.h:\n   30  #undef\tPROGRAM              /* Testing a library, not a program. */\n   31  #define\tLIBRARY\t\"libarchive\"\n   32: #define\tEXTRA_DUMP(x)\tarchive_error_string((struct archive *)(x))\n   33: #define\tEXTRA_ERRNO(x)\tarchive_errno((struct archive *)(x))\n   34  #define\tEXTRA_VERSION\tarchive_version_details()\n   35  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_iso_Z.c:\n   29  test1(void)\n   30  {\n   31: \tstruct archive_entry *ae;\n   32: \tstruct archive *a;\n   33  \tconst char *name = \"test_read_format_iso.iso.Z\";\n   34  \n   ..\n   57  test2(void)\n   58  {\n   59: \tstruct archive_entry *ae;\n   60: \tstruct archive *a;\n   61  \tconst char *name = \"test_read_format_iso_2.iso.Z\";\n   62  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_archive_match_owner.c:\n   30  test_uid(void)\n   31  {\n   32: \tstruct archive_entry *ae;\n   33: \tstruct archive *m;\n   34  \n   35  \tif (!assert((m = archive_match_new()) != NULL))\n   ..\n   72  test_gid(void)\n   73  {\n   74: \tstruct archive_entry *ae;\n   75: \tstruct archive *m;\n   76  \n   77  \tif (!assert((m = archive_match_new()) != NULL))\n   ..\n  114  test_uname_mbs(void)\n  115  {\n  116: \tstruct archive_entry *ae;\n  117: \tstruct archive *m;\n  118  \n  119  \tif (!assert((m = archive_match_new()) != NULL))\n  ...\n  156  test_uname_wcs(void)\n  157  {\n  158: \tstruct archive_entry *ae;\n  159: \tstruct archive *m;\n  160  \n  161  \tif (!assert((m = archive_match_new()) != NULL))\n  ...\n  198  test_gname_mbs(void)\n  199  {\n  200: \tstruct archive_entry *ae;\n  201: \tstruct archive *m;\n  202  \n  203  \tif (!assert((m = archive_match_new()) != NULL))\n  ...\n  240  test_gname_wcs(void)\n  241  {\n  242: \tstruct archive_entry *ae;\n  243: \tstruct archive *m;\n  244  \n  245  \tif (!assert((m = archive_match_new()) != NULL))\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_filter_grzip.c:\n   31  \tconst char *n[] = {\n   32  \t\t\"f1\", \"f2\", \"f3\", \"d1/f1\", \"d1/f2\", \"d1/f3\", NULL };\n   33: \tstruct archive_entry *ae;\n   34: \tstruct archive *a;\n   35  \tint i;\n   36  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_mtree.c:\n   29  \n   30  static char buff[4096];\n   31: static struct {\n   32  \tconst char\t*path;\n   33  \tmode_t\t\t mode;\n   ..\n   49  \t{ NULL, 0, 0, 0, 0 }\n   50  };\n   51: static struct {\n   52    const char  *path;\n   53    mode_t     mode;\n   ..\n   73  test_write_format_mtree_sub(int use_set, int dironly)\n   74  {\n   75: \tstruct archive_entry *ae;\n   76: \tstruct archive* a;\n   77  \tsize_t used;\n   78  \tint i;\n   ..\n  160  test_write_format_mtree_sub2(int use_set, int dironly)\n  161  {\n  162:   struct archive_entry *ae;\n  163:   struct archive* a;\n  164    size_t used;\n  165    int i;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_svr4c_Z.c:\n   36  DEFINE_TEST(test_read_format_cpio_svr4c_Z)\n   37  {\n   38: \tstruct archive_entry *ae;\n   39: \tstruct archive *a;\n   40  /*\tprintf(\"Archive address: start=%X, end=%X\\n\", archive, archive+sizeof(archive)); */\n   41  \tassert((a = archive_read_new()) != NULL);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_cpio_bin_gz.c:\n   34  DEFINE_TEST(test_read_format_cpio_bin_gz)\n   35  {\n   36: \tstruct archive_entry *ae;\n   37: \tstruct archive *a;\n   38  \tint r;\n   39  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_write_format_tar_v7tar.c:\n   51  DEFINE_TEST(test_write_format_tar_v7tar)\n   52  {\n   53: \tstruct archive *a;\n   54: \tstruct archive_entry *entry;\n   55  \tchar *buff, *e;\n   56  \tsize_t buffsize = 100000;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive/test/test_read_format_tlz.c:\n   38  DEFINE_TEST(test_read_format_tlz)\n   39  {\n   40: \tstruct archive_entry *ae;\n   41: \tstruct archive *a;\n   42  \tint r;\n   43  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cpio/cpio_windows.h:\n   47  #endif\n   48  \n   49: struct passwd {\n   50  \tchar\t*pw_name;\n   51  \tuid_t\t pw_uid;\n   ..\n   53  };\n   54  \n   55: struct group {\n   56  \tchar\t*gr_name;\n   57  \tgid_t\t gr_gid;\n   58  };\n   59  \n   60: struct _timeval64i32 {\n   61  \ttime_t\t\ttv_sec;\n   62  \tlong\t\ttv_usec;\n   ..\n   64  #define __timeval _timeval64i32\n   65  \n   66: extern int futimes(int fd, const struct __timeval *times);\n   67  #ifndef HAVE_FUTIMES\n   68  #define HAVE_FUTIMES 1\n   69  #endif\n   70: extern int utimes(const char *name, const struct __timeval *times);\n   71  #ifndef HAVE_UTIMES\n   72  #define HAVE_UTIMES 1\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cpio/cpio_platform.h:\n   54  /* If not, define it so as to avoid dangling semicolons. */\n   55  #ifndef __FBSDID\n   56: #define\t__FBSDID(a)     struct _undefined_hack\n   57  #endif\n   58  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cpio/cpio_windows.c:\n  177  #define WINTIME(sec, usec)\t((Int32x32To64(sec, 10000000) + EPOC_TIME) + (usec * 10))\n  178  static int\n  179: __hutimes(HANDLE handle, const struct __timeval *times)\n  180  {\n  181  \tULARGE_INTEGER wintm;\n  ...\n  196  \n  197  int\n  198: futimes(int fd, const struct __timeval *times)\n  199  {\n  200  \n  ...\n  203  \n  204  int\n  205: utimes(const char *name, const struct __timeval *times)\n  206  {\n  207  \tint ret;\n  ...\n  262  */\n  263  \n  264: static const struct {\n  265  \tDWORD\t\twinerr;\n  266  \tint\t\tdoserr;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cpio/cpio.c:\n   92  #endif\n   93  \n   94: struct name_cache {\n   95  \tint\tprobes;\n   96  \tint\thits;\n   97  \tsize_t\tsize;\n   98: \tstruct {\n   99  \t\tid_t id;\n  100  \t\tchar *name;\n  ...\n  102  };\n  103  \n  104: static int\textract_data(struct archive *, struct archive *);\n  105  const char *\tcpio_i64toa(int64_t);\n  106  static const char *cpio_rename(const char *name);\n  107: static int\tentry_to_archive(struct cpio *, struct archive_entry *);\n  108: static int\tfile_to_archive(struct cpio *, const char *);\n  109: static void\tfree_cache(struct name_cache *cache);\n  110: static void\tlist_item_verbose(struct cpio *, struct archive_entry *);\n  111  static void\tlong_help(void) __LA_DEAD;\n  112: static const char *lookup_gname(struct cpio *, gid_t gid);\n  113: static int\tlookup_gname_helper(struct cpio *,\n  114  \t\t    const char **name, id_t gid);\n  115: static const char *lookup_uname(struct cpio *, uid_t uid);\n  116: static int\tlookup_uname_helper(struct cpio *,\n  117  \t\t    const char **name, id_t uid);\n  118: static void\tmode_in(struct cpio *) __LA_DEAD;\n  119: static void\tmode_list(struct cpio *) __LA_DEAD;\n  120: static void\tmode_out(struct cpio *);\n  121: static void\tmode_pass(struct cpio *, const char *);\n  122  static const char *remove_leading_slash(const char *);\n  123: static int\trestore_time(struct cpio *, struct archive_entry *,\n  124  \t\t    const char *, int fd);\n  125  static void\tusage(void) __LA_DEAD;\n  126  static void\tversion(void) __LA_DEAD;\n  127: static const char * passphrase_callback(struct archive *, void *);\n  128  static void\tpassphrase_free(char *);\n  129  \n  ...\n  132  {\n  133  \tstatic char buff[16384];\n  134: \tstruct cpio _cpio; /* Allocated on stack. */\n  135: \tstruct cpio *cpio;\n  136  \tconst char *errmsg;\n  137  \tchar *tptr;\n  ...\n  146  #if defined(HAVE_SIGACTION) && defined(SIGPIPE)\n  147  \t{ /* Ignore SIGPIPE signals. */\n  148: \t\tstruct sigaction sa;\n  149  \t\tsigemptyset(&sa.sa_mask);\n  150  \t\tsa.sa_flags = 0;\n  ...\n  521  \n  522  static void\n  523: mode_out(struct cpio *cpio)\n  524  {\n  525: \tstruct archive_entry *entry, *spare;\n  526: \tstruct lafe_line_reader *lr;\n  527  \tconst char *p;\n  528  \tint r;\n  ...\n  699   */\n  700  static int\n  701: file_to_archive(struct cpio *cpio, const char *srcpath)\n  702  {\n  703  \tconst char *destpath;\n  704: \tstruct archive_entry *entry, *spare;\n  705  \tsize_t len;\n  706  \tint r;\n  ...\n  791  \n  792  static int\n  793: entry_to_archive(struct cpio *cpio, struct archive_entry *entry)\n  794  {\n  795  \tconst char *destpath = archive_entry_pathname(entry);\n  ...\n  817  \t    && archive_entry_filetype(entry) == AE_IFREG)\n  818  \t{\n  819: \t\tstruct archive_entry *t;\n  820  \t\t/* Save the original entry in case we need it later. */\n  821  \t\tt = archive_entry_clone(entry);\n  ...\n  903  \n  904  static int\n  905: restore_time(struct cpio *cpio, struct archive_entry *entry,\n  906      const char *name, int fd)\n  907  {\n  ...\n  919  #else\n  920  #if defined(_WIN32) && !defined(__CYGWIN__)\n  921: \tstruct __timeval times[2];\n  922  #else\n  923: \tstruct timeval times[2];\n  924  #endif\n  925  \n  ...\n  959  \n  960  static void\n  961: mode_in(struct cpio *cpio)\n  962  {\n  963: \tstruct archive *a;\n  964: \tstruct archive_entry *entry;\n  965: \tstruct archive *ext;\n  966  \tconst char *destpath;\n  967  \tint r;\n  ...\n 1053   */\n 1054  static int\n 1055: extract_data(struct archive *ar, struct archive *aw)\n 1056  {\n 1057  \tint r;\n ....\n 1079  \n 1080  static void\n 1081: mode_list(struct cpio *cpio)\n 1082  {\n 1083: \tstruct archive *a;\n 1084: \tstruct archive_entry *entry;\n 1085  \tint r;\n 1086  \n ....\n 1141   */\n 1142  static void\n 1143: list_item_verbose(struct cpio *cpio, struct archive_entry *entry)\n 1144  {\n 1145  \tchar\t\t\t size[32];\n ....\n 1151  \ttime_t\t\t\t mtime;\n 1152  \tstatic time_t\t\t now;\n 1153: \tstruct tm\t\t*ltime;\n 1154  #if defined(HAVE_LOCALTIME_R) || defined(HAVE__LOCALTIME64_S)\n 1155: \tstruct tm\t\ttmbuf;\n 1156  #endif\n 1157  #if defined(HAVE__LOCALTIME64_S)\n ....\n 1235  \n 1236  static void\n 1237: mode_pass(struct cpio *cpio, const char *destdir)\n 1238  {\n 1239: \tstruct lafe_line_reader *lr;\n 1240  \tconst char *p;\n 1241  \tint r;\n ....\n 1349  \n 1350  static void\n 1351: free_cache(struct name_cache *cache)\n 1352  {\n 1353  \tsize_t i;\n ....\n 1364   */\n 1365  static const char *\n 1366: lookup_name(struct cpio *cpio, struct name_cache **name_cache_variable,\n 1367:     int (*lookup_fn)(struct cpio *, const char **, id_t), id_t id)\n 1368  {\n 1369  \tchar asnum[16];\n 1370: \tstruct name_cache\t*cache;\n 1371  \tconst char *name;\n 1372  \tint slot;\n ....\n 1374  \n 1375  \tif (*name_cache_variable == NULL) {\n 1376: \t\t*name_cache_variable = calloc(1, sizeof(struct name_cache));\n 1377  \t\tif (*name_cache_variable == NULL)\n 1378  \t\t\tlafe_errc(1, ENOMEM, \"No more memory\");\n ....\n 1414  \n 1415  static const char *\n 1416: lookup_uname(struct cpio *cpio, uid_t uid)\n 1417  {\n 1418  \treturn (lookup_name(cpio, &cpio->uname_cache,\n ....\n 1421  \n 1422  static int\n 1423: lookup_uname_helper(struct cpio *cpio, const char **name, id_t id)\n 1424  {\n 1425: \tstruct passwd\t*pwent;\n 1426  \n 1427  \t(void)cpio; /* UNUSED */\n ....\n 1441  \n 1442  static const char *\n 1443: lookup_gname(struct cpio *cpio, gid_t gid)\n 1444  {\n 1445  \treturn (lookup_name(cpio, &cpio->gname_cache,\n ....\n 1448  \n 1449  static int\n 1450: lookup_gname_helper(struct cpio *cpio, const char **name, id_t id)\n 1451  {\n 1452: \tstruct group\t*grent;\n 1453  \n 1454  \t(void)cpio; /* UNUSED */\n ....\n 1494  #define PPBUFF_SIZE 1024\n 1495  static const char *\n 1496: passphrase_callback(struct archive *a, void *_client_data)\n 1497  {\n 1498: \tstruct cpio *cpio = (struct cpio *)_client_data;\n 1499  \t(void)a; /* UNUSED */\n 1500  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cpio/cpio.h:\n   35   * The internal state for the \"cpio\" program.\n   36   *\n   37:  * Keeping all of the state in a structure like this simplifies memory\n   38   * leak testing (at exit, anything left on the heap is suspect).  A\n   39:  * pointer to this structure is passed to most cpio internal\n   40   * functions.\n   41   */\n   42: struct cpio {\n   43  \t/* Option parsing */\n   44  \tconst char\t *argument;\n   ..\n   80  \n   81  \t/* Miscellaneous state information */\n   82: \tstruct archive\t *archive;\n   83: \tstruct archive\t *archive_read_disk;\n   84  \tint\t\t  argc;\n   85  \tchar\t\t**argv;\n   86  \tint\t\t  return_value; /* Value returned by main() */\n   87: \tstruct archive_entry_linkresolver *linkresolver;\n   88  \n   89: \tstruct name_cache *uname_cache;\n   90: \tstruct name_cache *gname_cache;\n   91  \n   92  \t/* Work data. */\n   93: \tstruct archive   *matching;\n   94  \tchar\t\t *buff;\n   95  \tsize_t\t\t  buff_size;\n   ..\n  118  };\n  119  \n  120: int\tcpio_getopt(struct cpio *cpio);\n  121  \n  122  #endif\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cpio/cmdline.c:\n   57   * Long options for cpio.  Please keep this sorted.\n   58   */\n   59: static const struct option {\n   60  \tconst char *name;\n   61  \tint required;\t/* 1 if this option requires an argument */\n   ..\n  110   */\n  111  int\n  112: cpio_getopt(struct cpio *cpio)\n  113  {\n  114  \tenum { state_start = 0, state_next_word, state_short, state_long };\n  ...\n  116  \tstatic char *opt_word;\n  117  \n  118: \tconst struct option *popt, *match = NULL, *match2 = NULL;\n  119  \tconst char *p, *long_prefix = \"--\";\n  120  \tsize_t optlength;\n  ...\n  339  \t\t/* Look up user: ue is first char after end of user. */\n  340  \t\tchar *user;\n  341: \t\tstruct passwd *pwent;\n  342  \n  343  \t\tuser = (char *)malloc(ue - u + 1);\n  ...\n  366  \n  367  \tif (*g != '\\0') {\n  368: \t\tstruct group *grp;\n  369  \t\tif ((grp = getgrnam(g)) != NULL) {\n  370  \t\t\t*gid = grp->gr_gid;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cpio/test/test_0.c:\n   38  DEFINE_TEST(test_0)\n   39  {\n   40: \tstruct stat st;\n   41  \n   42  \tfailure(\"File %s does not exist?!\", testprogfile);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cpio/test/test_format_newc.c:\n   74  nlinks(const char *p)\n   75  {\n   76: \tstruct stat st;\n   77  \tassertEqualInt(0, stat(p, &st));\n   78  \treturn st.st_nlink;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cpio/test/test_option_u.c:\n   33  DEFINE_TEST(test_option_u)\n   34  {\n   35: \tstruct utimbuf times;\n   36  \tchar *p;\n   37  \tsize_t s;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cpio/test/test_option_c.c:\n   56  nlinks(const char *p)\n   57  {\n   58: \tstruct stat st;\n   59  \tassertEqualInt(0, stat(p, &st));\n   60  \treturn st.st_nlink;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cpio/test/test_option_B_upper.c:\n   29  DEFINE_TEST(test_option_B_upper)\n   30  {\n   31: \tstruct stat st;\n   32  \tint r;\n   33  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cpio/test/test_option_a.c:\n   31  __FBSDID(\"$FreeBSD: src/usr.bin/cpio/test/test_option_a.c,v 1.3 2008/08/24 06:21:00 kientzle Exp $\");\n   32  \n   33: static struct {\n   34  \tconst char *name;\n   35  \ttime_t atime_sec;\n   ..\n   54  test_create(void)\n   55  {\n   56: \tstruct stat st;\n   57: \tstruct utimbuf times;\n   58  \tstatic const int numfiles = sizeof(files) / sizeof(files[0]);\n   59  \tint i;\n   ..\n   94  DEFINE_TEST(test_option_a)\n   95  {\n   96: \tstruct stat st;\n   97  \tint r;\n   98  \tchar *p;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive_fe/passphrase.c:\n  171  \tint input, output, save_errno, i, need_restart;\n  172  \tchar ch, *p, *end;\n  173: \tstruct termios term, oterm;\n  174: \tstruct sigaction sa, savealrm, saveint, savehup, savequit, saveterm;\n  175: \tstruct sigaction savetstp, savettin, savettou, savepipe;\n  176  \n  177  \t/* I suppose we could alloc on demand in this case (XXX). */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive_fe/lafe_platform.h:\n   50  /* If not, define it so as to avoid dangling semicolons. */\n   51  #ifndef __FBSDID\n   52: #define\t__FBSDID(a)     struct _undefined_hack\n   53  #endif\n   54  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive_fe/line_reader.h:\n   27  #define LAFE_LINE_READER_H\n   28  \n   29: struct lafe_line_reader;\n   30  \n   31: struct lafe_line_reader *lafe_line_reader(const char *, int nullSeparator);\n   32: const char *lafe_line_reader_next(struct lafe_line_reader *);\n   33: void\tlafe_line_reader_free(struct lafe_line_reader *);\n   34  \n   35  #endif\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/libarchive_fe/line_reader.c:\n   48   * This uses a self-sizing buffer to handle arbitrarily-long lines.\n   49   */\n   50: struct lafe_line_reader {\n   51  \tFILE *f;\n   52  \tchar *buff, *buff_end, *line_start, *line_end;\n   ..\n   56  };\n   57  \n   58: struct lafe_line_reader *\n   59  lafe_line_reader(const char *pathname, int nullSeparator)\n   60  {\n   61: \tstruct lafe_line_reader *lr;\n   62  \n   63  \tlr = calloc(1, sizeof(*lr));\n   ..\n   81  \n   82  static void\n   83: lafe_line_reader_find_eol(struct lafe_line_reader *lr)\n   84  {\n   85  \n   ..\n   90  \n   91  const char *\n   92: lafe_line_reader_next(struct lafe_line_reader *lr)\n   93  {\n   94  \tsize_t bytes_wanted, bytes_read, new_buff_size;\n   ..\n  161  \n  162  void\n  163: lafe_line_reader_free(struct lafe_line_reader *lr)\n  164  {\n  165  \tfree(lr->buff);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/util.c:\n  288   */\n  289  void\n  290: set_chdir(struct bsdtar *bsdtar, const char *newdir)\n  291  {\n  292  #if defined(_WIN32) && !defined(__CYGWIN__)\n  ...\n  323  \n  324  void\n  325: do_chdir(struct bsdtar *bsdtar)\n  326  {\n  327  \tif (bsdtar->pending_chdir == NULL)\n  ...\n  376  \n  377  static void\n  378: warn_strip_leading_char(struct bsdtar *bsdtar, const char *c)\n  379  {\n  380  \tif (!bsdtar->warned_lead_slash) {\n  ...\n  387  \n  388  static void\n  389: warn_strip_drive_letter(struct bsdtar *bsdtar)\n  390  {\n  391  \tif (!bsdtar->warned_lead_slash) {\n  ...\n  402   */\n  403  static const char*\n  404: strip_absolute_path(struct bsdtar *bsdtar, const char *p)\n  405  {\n  406  \tconst char *rp;\n  ...\n  465   */\n  466  int\n  467: edit_pathname(struct bsdtar *bsdtar, struct archive_entry *entry)\n  468  {\n  469  \tconst char *name = archive_entry_pathname(entry);\n  ...\n  627  #define PPBUFF_SIZE 1024\n  628  const char *\n  629: passphrase_callback(struct archive *a, void *_client_data)\n  630  {\n  631: \tstruct bsdtar *bsdtar = (struct bsdtar *)_client_data;\n  632  \t(void)a; /* UNUSED */\n  633  \n  ...\n  659   */\n  660  void\n  661: list_item_verbose(struct bsdtar *bsdtar, FILE *out, struct archive_entry *entry)\n  662  {\n  663  \tchar\t\t\t tmp[100];\n  ...\n  667  \ttime_t\t\t\t tim;\n  668  \tstatic time_t\t\t now;\n  669: \tstruct tm\t\t*ltime;\n  670  #if defined(HAVE_LOCALTIME_R) || defined(HAVE__LOCALTIME64_S)\n  671: \tstruct tm\t\ttmbuf;\n  672  #endif\n  673  #if defined(HAVE__LOCALTIME64_S)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/bsdtar.h:\n   37  #define IGNORE_WRONG_MODULE_NAME \"__ignore_wrong_module_name__,\"\n   38  \n   39: struct creation_set;\n   40  /*\n   41   * The internal state for the \"bsdtar\" program.\n   42   *\n   43:  * Keeping all of the state in a structure like this simplifies memory\n   44   * leak testing (at exit, anything left on the heap is suspect).  A\n   45:  * pointer to this structure is passed to most bsdtar internal\n   46   * functions.\n   47   */\n   48: struct bsdtar {\n   49  \t/* Options */\n   50  \tconst char\t *filename; /* -f filename */\n   ..\n   67  \tconst char\t *option_options; /* --options */\n   68  \tchar\t\t  day_first; /* show day before month in -tv output */\n   69: \tstruct creation_set *cset;\n   70  \n   71  \t/* Option parser state */\n   ..\n   91  \t * the file where they are used.\n   92  \t */\n   93: \tstruct archive\t\t*diskreader;\t/* for write.c */\n   94: \tstruct archive_entry_linkresolver *resolver; /* for write.c */\n   95: \tstruct archive_dir\t*archive_dir;\t/* for write.c */\n   96: \tstruct name_cache\t*gname_cache;\t/* for write.c */\n   97  \tchar\t\t\t*buff;\t\t/* for write.c */\n   98  \tsize_t\t\t\t buff_size;\t/* for write.c */\n   99  \tint\t\t\t first_fs;\t/* for write.c */\n  100: \tstruct archive\t\t*matching;\t/* for matching.c */\n  101: \tstruct security\t\t*security;\t/* for read.c */\n  102: \tstruct name_cache\t*uname_cache;\t/* for write.c */\n  103: \tstruct siginfo_data\t*siginfo;\t/* for siginfo.c */\n  104: \tstruct substitution\t*substitution;\t/* for subst.c */\n  105  \tchar\t\t\t*ppbuff;\t/* for util.c */\n  106  };\n  ...\n  192  };\n  193  \n  194: int\tbsdtar_getopt(struct bsdtar *);\n  195: void\tdo_chdir(struct bsdtar *);\n  196: int\tedit_pathname(struct bsdtar *, struct archive_entry *);\n  197  int\tneed_report(void);\n  198  int\tpathcmp(const char *a, const char *b);\n  199  void\tsafe_fprintf(FILE *, const char *fmt, ...) __LA_PRINTF(2, 3);\n  200: void\tset_chdir(struct bsdtar *, const char *newdir);\n  201  const char *tar_i64toa(int64_t);\n  202: void\ttar_mode_c(struct bsdtar *bsdtar);\n  203: void\ttar_mode_r(struct bsdtar *bsdtar);\n  204: void\ttar_mode_t(struct bsdtar *bsdtar);\n  205: void\ttar_mode_u(struct bsdtar *bsdtar);\n  206: void\ttar_mode_x(struct bsdtar *bsdtar);\n  207  void\tusage(void) __LA_DEAD;\n  208  int\tyes(const char *fmt, ...) __LA_PRINTF(1, 2);\n  209  \n  210  #if defined(HAVE_REGEX_H) || defined(HAVE_PCREPOSIX_H)\n  211: void\tadd_substitution(struct bsdtar *, const char *);\n  212: int\tapply_substitution(struct bsdtar *, const char *, char **, int, int);\n  213: void\tcleanup_substitution(struct bsdtar *);\n  214  #endif\n  215  \n  216: void\t\tcset_add_filter(struct creation_set *, const char *);\n  217: void\t\tcset_add_filter_program(struct creation_set *, const char *);\n  218: int\t\tcset_auto_compress(struct creation_set *, const char *);\n  219: void\t\tcset_free(struct creation_set *);\n  220: const char *\tcset_get_format(struct creation_set *);\n  221: struct creation_set *cset_new(void);\n  222: int\t\tcset_read_support_filter_program(struct creation_set *,\n  223: \t\t    struct archive *);\n  224: void\t\tcset_set_format(struct creation_set *, const char *);\n  225: int\t\tcset_write_add_filters(struct creation_set *,\n  226: \t\t    struct archive *, const void **);\n  227  \n  228: const char * passphrase_callback(struct archive *, void *);\n  229  void\t     passphrase_free(char *);\n  230: void\tlist_item_verbose(struct bsdtar *, FILE *,\n  231: \t\t    struct archive_entry *);\n  232  \n  233  #endif\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/read.c:\n   79  #include \"err.h\"\n   80  \n   81: struct progress_data {\n   82: \tstruct bsdtar *bsdtar;\n   83: \tstruct archive *archive;\n   84: \tstruct archive_entry *entry;\n   85  };\n   86  \n   87: static void\tread_archive(struct bsdtar *bsdtar, char mode, struct archive *);\n   88: static int unmatched_inclusions_warn(struct archive *matching, const char *);\n   89  \n   90  \n   91  void\n   92: tar_mode_t(struct bsdtar *bsdtar)\n   93  {\n   94  \tread_archive(bsdtar, 't', NULL);\n   ..\n   99  \n  100  void\n  101: tar_mode_x(struct bsdtar *bsdtar)\n  102  {\n  103: \tstruct archive *writer;\n  104  \n  105  \twriter = archive_write_disk_new();\n  ...\n  121  progress_func(void *cookie)\n  122  {\n  123: \tstruct progress_data *progress_data = (struct progress_data *)cookie;\n  124: \tstruct bsdtar *bsdtar = progress_data->bsdtar;\n  125: \tstruct archive *a = progress_data->archive;\n  126: \tstruct archive_entry *entry = progress_data->entry;\n  127  \tuint64_t comp, uncomp;\n  128  \tint compression;\n  ...\n  158   */\n  159  static void\n  160: read_archive(struct bsdtar *bsdtar, char mode, struct archive *writer)\n  161  {\n  162: \tstruct progress_data\tprogress_data;\n  163  \tFILE\t\t\t *out;\n  164: \tstruct archive\t\t *a;\n  165: \tstruct archive_entry\t *entry;\n  166  \tconst char\t\t *reader_options;\n  167  \tint\t\t\t  r;\n  ...\n  403  \n  404  static int\n  405: unmatched_inclusions_warn(struct archive *matching, const char *msg)\n  406  {\n  407  \tconst char *p;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/subst.c:\n   45  #include \"err.h\"\n   46  \n   47: struct subst_rule {\n   48: \tstruct subst_rule *next;\n   49  \tregex_t re;\n   50  \tchar *result;\n   ..\n   52  };\n   53  \n   54: struct substitution {\n   55: \tstruct subst_rule *first_rule, *last_rule;\n   56  };\n   57  \n   58  static void\n   59: init_substitution(struct bsdtar *bsdtar)\n   60  {\n   61: \tstruct substitution *subst;\n   62  \n   63  \tbsdtar->substitution = subst = malloc(sizeof(*subst));\n   ..\n   68  \n   69  void\n   70: add_substitution(struct bsdtar *bsdtar, const char *rule_text)\n   71  {\n   72: \tstruct subst_rule *rule;\n   73: \tstruct substitution *subst;\n   74  \tconst char *end_pattern, *start_subst;\n   75  \tchar *pattern;\n   ..\n  208  \n  209  int\n  210: apply_substitution(struct bsdtar *bsdtar, const char *name, char **result,\n  211      int symlink_target, int hardlink_target)\n  212  {\n  ...\n  214  \tregmatch_t matches[10];\n  215  \tsize_t i, j;\n  216: \tstruct subst_rule *rule;\n  217: \tstruct substitution *subst;\n  218  \tint c, got_match, print_match;\n  219  \n  ...\n  310  \n  311  void\n  312: cleanup_substitution(struct bsdtar *bsdtar)\n  313  {\n  314: \tstruct subst_rule *rule;\n  315: \tstruct substitution *subst;\n  316  \n  317  \tif ((subst = bsdtar->substitution) == NULL)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/bsdtar.c:\n  120  \n  121  static void\t\t long_help(void) __LA_DEAD;\n  122: static void\t\t only_mode(struct bsdtar *, const char *opt,\n  123  \t\t\t     const char *valid);\n  124: static void\t\t set_mode(struct bsdtar *, char opt);\n  125  static void\t\t version(void) __LA_DEAD;\n  126  \n  ...\n  155  main(int argc, char **argv)\n  156  {\n  157: \tstruct bsdtar\t\t*bsdtar, bsdtar_storage;\n  158  \tint\t\t\t opt, t;\n  159  \tchar\t\t\t compression, compression2;\n  ...\n  180  #if defined(HAVE_SIGACTION)\n  181  \t{ /* Set up signal handling. */\n  182: \t\tstruct sigaction sa;\n  183  \t\tsa.sa_handler = siginfo_handler;\n  184  \t\tsigemptyset(&sa.sa_mask);\n  ...\n  941  \n  942  static void\n  943: set_mode(struct bsdtar *bsdtar, char opt)\n  944  {\n  945  \tif (bsdtar->mode != '\\0' && bsdtar->mode != opt)\n  ...\n  953   */\n  954  static void\n  955: only_mode(struct bsdtar *bsdtar, const char *opt, const char *valid_modes)\n  956  {\n  957  \tif (strchr(valid_modes, bsdtar->mode) == NULL)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/write.c:\n   83  #endif\n   84  \n   85: struct archive_dir_entry {\n   86: \tstruct archive_dir_entry\t*next;\n   87  \ttime_t\t\t\t mtime_sec;\n   88  \tint\t\t\t mtime_nsec;\n   ..\n   90  };\n   91  \n   92: struct archive_dir {\n   93: \tstruct archive_dir_entry *head, *tail;\n   94  };\n   95  \n   96: static int\t\t append_archive(struct bsdtar *, struct archive *,\n   97: \t\t\t     struct archive *ina);\n   98: static int\t\t append_archive_filename(struct bsdtar *,\n   99: \t\t\t     struct archive *, const char *fname);\n  100: static void\t\t archive_names_from_file(struct bsdtar *bsdtar,\n  101: \t\t\t     struct archive *a);\n  102: static int\t\t copy_file_data_block(struct bsdtar *,\n  103: \t\t\t     struct archive *a, struct archive *,\n  104: \t\t\t     struct archive_entry *);\n  105: static void\t\t excluded_callback(struct archive *, void *,\n  106: \t\t\t     struct archive_entry *);\n  107: static void\t\t report_write(struct bsdtar *, struct archive *,\n  108: \t\t\t     struct archive_entry *, int64_t progress);\n  109: static void\t\t test_for_append(struct bsdtar *);\n  110: static int\t\t metadata_filter(struct archive *, void *,\n  111: \t\t\t     struct archive_entry *);\n  112: static void\t\t write_archive(struct archive *, struct bsdtar *);\n  113: static void\t\t write_entry(struct bsdtar *, struct archive *,\n  114: \t\t\t     struct archive_entry *);\n  115: static void\t\t write_file(struct bsdtar *, struct archive *,\n  116: \t\t\t     struct archive_entry *);\n  117: static void\t\t write_hierarchy(struct bsdtar *, struct archive *,\n  118  \t\t\t     const char *);\n  119  \n  ...\n  139  \n  140  static void\n  141: set_writer_options(struct bsdtar *bsdtar, struct archive *a)\n  142  {\n  143  \tconst char *writer_options;\n  ...\n  169  \n  170  static void\n  171: set_reader_options(struct bsdtar *bsdtar, struct archive *a)\n  172  {\n  173  \tconst char *reader_options;\n  ...\n  200  \n  201  void\n  202: tar_mode_c(struct bsdtar *bsdtar)\n  203  {\n  204: \tstruct archive *a;\n  205  \tconst void *filter_name;\n  206  \tint r;\n  ...\n  253   */\n  254  void\n  255: tar_mode_r(struct bsdtar *bsdtar)\n  256  {\n  257  \tint64_t\tend_offset;\n  258  \tint\tformat;\n  259: \tstruct archive *a;\n  260: \tstruct archive_entry *entry;\n  261  \tint\tr;\n  262  \n  ...\n  344  \n  345  void\n  346: tar_mode_u(struct bsdtar *bsdtar)\n  347  {\n  348  \tint64_t\t\t\t end_offset;\n  349: \tstruct archive\t\t*a;\n  350: \tstruct archive_entry\t*entry;\n  351  \tint\t\t\t format;\n  352: \tstruct archive_dir_entry\t*p;\n  353: \tstruct archive_dir\t archive_dir;\n  354  \n  355  \tbsdtar->archive_dir = &archive_dir;\n  ...\n  433   */\n  434  static void\n  435: write_archive(struct archive *a, struct bsdtar *bsdtar)\n  436  {\n  437  \tconst char *arg;\n  438: \tstruct archive_entry *entry, *sparse_entry;\n  439  \n  440  \t/* Choose a suitable copy buffer size */\n  ...\n  523  \twhile (entry != NULL) {\n  524  \t\tint r;\n  525: \t\tstruct archive_entry *entry2;\n  526: \t\tstruct archive *disk = bsdtar->diskreader;\n  527  \n  528  \t\t/*\n  ...\n  598   */\n  599  static void\n  600: archive_names_from_file(struct bsdtar *bsdtar, struct archive *a)\n  601  {\n  602: \tstruct lafe_line_reader *lr;\n  603  \tconst char *line;\n  604  \n  ...\n  641   */\n  642  static int\n  643: append_archive_filename(struct bsdtar *bsdtar, struct archive *a,\n  644      const char *raw_filename)\n  645  {\n  646: \tstruct archive *ina;\n  647  \tconst char *filename = raw_filename;\n  648  \tint rc;\n  ...\n  683  \n  684  static int\n  685: append_archive(struct bsdtar *bsdtar, struct archive *a, struct archive *ina)\n  686  {\n  687: \tstruct archive_entry *in_entry;\n  688  \tint e;\n  689  \n  ...\n  731  /* Helper function to copy file to archive. */\n  732  static int\n  733: copy_file_data_block(struct bsdtar *bsdtar, struct archive *a,\n  734:     struct archive *in_a, struct archive_entry *entry)\n  735  {\n  736  \tsize_t\tbytes_read;\n  ...\n  806  \n  807  static void\n  808: excluded_callback(struct archive *a, void *_data, struct archive_entry *entry)\n  809  {\n  810: \tstruct bsdtar *bsdtar = (struct bsdtar *)_data;\n  811  \n  812  \tif (bsdtar->flags & OPTFLAG_NO_SUBDIRS)\n  ...\n  821  \n  822  static int\n  823: metadata_filter(struct archive *a, void *_data, struct archive_entry *entry)\n  824  {\n  825: \tstruct bsdtar *bsdtar = (struct bsdtar *)_data;\n  826  \n  827  \t/* XXX TODO: check whether this filesystem is\n  ...\n  861   */\n  862  static void\n  863: write_hierarchy(struct bsdtar *bsdtar, struct archive *a, const char *path)\n  864  {\n  865: \tstruct archive *disk = bsdtar->diskreader;\n  866: \tstruct archive_entry *entry = NULL, *spare_entry = NULL;\n  867  \tint r;\n  868  \n  ...\n  955   */\n  956  static void\n  957: write_file(struct bsdtar *bsdtar, struct archive *a,\n  958:     struct archive_entry *entry)\n  959  {\n  960  \twrite_entry(bsdtar, a, entry);\n  ...\n  965   */\n  966  static void\n  967: write_entry(struct bsdtar *bsdtar, struct archive *a,\n  968:     struct archive_entry *entry)\n  969  {\n  970  \tint e;\n  ...\n 1000  \n 1001  static void\n 1002: report_write(struct bsdtar *bsdtar, struct archive *a,\n 1003:     struct archive_entry *entry, int64_t progress)\n 1004  {\n 1005  \tuint64_t comp, uncomp;\n ....\n 1028  \n 1029  static void\n 1030: test_for_append(struct bsdtar *bsdtar)\n 1031  {\n 1032: \tstruct stat s;\n 1033  \n 1034  \tif (*bsdtar->argv == NULL && bsdtar->names_from_file == NULL)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/bsdtar_platform.h:\n   54  /* If not, define it so as to avoid dangling semicolons. */\n   55  #ifndef __FBSDID\n   56: #define\t__FBSDID(a)     struct _undefined_hack\n   57  #endif\n   58  \n   ..\n   75   *\n   76   * This is slightly modified from the GNU autoconf recipe.\n   77:  * In particular, FreeBSD includes d_namlen in its dirent structure,\n   78   * so my configure script includes an explicit test for the d_namlen\n   79   * field.\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/creation_set.c:\n   37  #include \"err.h\"\n   38  \n   39: struct creation_set {\n   40  \tchar\t\t *create_format;\n   41: \tstruct filter_set {\n   42  \t\tint\t  program;\t/* Set 1 if filter is a program name */\n   43  \t\tchar\t *filter_name;\n   ..\n   46  };\n   47  \n   48: struct suffix_code_t {\n   49  \tconst char *suffix;\n   50  \tconst char *form;\n   ..\n   52  \n   53  static const char *\n   54: get_suffix_code(const struct suffix_code_t *tbl, const char *suffix)\n   55  {\n   56  \tint i;\n   ..\n   69  {\n   70  \t/* A pair of suffix and compression/filter. */\n   71: \tstatic const struct suffix_code_t filters[] = {\n   72  \t\t{ \".Z\",\t\t\"compress\" },\n   73  \t\t{ \".bz2\",\t\"bzip2\" },\n   ..\n   92  {\n   93  \t/* A pair of suffix and format. */\n   94: \tstatic const struct suffix_code_t formats[] = {\n   95  \t\t{ \".7z\",\t\"7zip\" },\n   96  \t\t{ \".ar\",\t\"arbsd\" },\n   ..\n  112  decompose_alias(const char *suffix)\n  113  {\n  114: \tstatic const struct suffix_code_t alias[] = {\n  115  \t\t{ \".taz\",\t\".tar.gz\" },\n  116  \t\t{ \".tgz\",\t\".tar.gz\" },\n  ...\n  131  \n  132  static void\n  133: _cset_add_filter(struct creation_set *cset, int program, const char *filter)\n  134  {\n  135: \tstruct filter_set *new_ptr;\n  136  \tchar *new_filter;\n  137  \n  138: \tnew_ptr = (struct filter_set *)realloc(cset->filters,\n  139  \t    sizeof(*cset->filters) * (cset->filter_count + 1));\n  140  \tif (new_ptr == NULL)\n  ...\n  150  \n  151  void\n  152: cset_add_filter(struct creation_set *cset, const char *filter)\n  153  {\n  154  \t_cset_add_filter(cset, 0, filter);\n  ...\n  156  \n  157  void\n  158: cset_add_filter_program(struct creation_set *cset, const char *filter)\n  159  {\n  160  \t_cset_add_filter(cset, 1, filter);\n  ...\n  162  \n  163  int\n  164: cset_read_support_filter_program(struct creation_set *cset, struct archive *a)\n  165  {\n  166  \tint cnt = 0, i;\n  ...\n  177  \n  178  int\n  179: cset_write_add_filters(struct creation_set *cset, struct archive *a,\n  180      const void **filter_name)\n  181  {\n  ...\n  199  \n  200  void\n  201: cset_set_format(struct creation_set *cset, const char *format)\n  202  {\n  203  \tchar *f;\n  ...\n  211  \n  212  const char *\n  213: cset_get_format(struct creation_set *cset)\n  214  {\n  215  \treturn (cset->create_format);\n  ...\n  217  \n  218  static void\n  219: _cleanup_filters(struct filter_set *filters, int count)\n  220  {\n  221  \tint i;\n  ...\n  230   */\n  231  void\n  232: cset_free(struct creation_set *cset)\n  233  {\n  234  \t_cleanup_filters(cset->filters, cset->filter_count);\n  ...\n  237  }\n  238  \n  239: struct creation_set *\n  240  cset_new(void)\n  241  {\n  242: \treturn calloc(1, sizeof(struct creation_set));\n  243  }\n  244  \n  ...\n  247   */\n  248  int\n  249: cset_auto_compress(struct creation_set *cset, const char *filename)\n  250  {\n  251: \tstruct filter_set *old_filters;\n  252  \tchar *name, *p;\n  253  \tconst char *code;\n  ...\n  295  \tfree(name);\n  296  \tif (cset->filters) {\n  297: \t\tstruct filter_set *v;\n  298  \t\tint i, r;\n  299  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/bsdtar_windows.c:\n  221  */\n  222  \n  223: static const struct {\n  224  \tDWORD\t\twinerr;\n  225  \tint\t\tdoserr;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/cmdline.c:\n   59   */\n   60  \n   61: static const struct bsdtar_option {\n   62  \tconst char *name;\n   63  \tint required;      /* 1 if this option requires an argument. */\n   ..\n  211  \n  212  int\n  213: bsdtar_getopt(struct bsdtar *bsdtar)\n  214  {\n  215  \tenum { state_start = 0, state_old_tar, state_next_word,\n  216  \t       state_short, state_long };\n  217  \n  218: \tconst struct bsdtar_option *popt, *match = NULL, *match2 = NULL;\n  219  \tconst char *p, *long_prefix = \"--\";\n  220  \tsize_t optlength;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/test/test_option_acls.c:\n  283  #endif\n  284  #if ARCHIVE_ACL_LIBRICHACL\n  285: \tstruct richacl *richacl_a, *richacl_b;\n  286  \n  287  \trichacl_a = NULL;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/test/test_option_s.c:\n   28  DEFINE_TEST(test_option_s)\n   29  {\n   30: \tstruct stat st;\n   31  \n   32  \t/* Create a sample file hierarchy. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/test/test_0.c:\n   38  DEFINE_TEST(test_0)\n   39  {\n   40: \tstruct stat st;\n   41  \n   42  \tfailure(\"File %s does not exist?!\", testprog);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/test/test_option_older_than.c:\n   29  DEFINE_TEST(test_option_older_than)\n   30  {\n   31: \tstruct stat st;\n   32  \n   33  \t/*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/test/test_option_C_mtree.c:\n   71  \tassertEmptyFile(\"step1.err\");\n   72  \n   73: \t/* Do validation of the constructed archive. */\n   74  \n   75  \tp0 = slurpfile(&s, \"output.tar\");\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/test/test_option_newer_than.c:\n   28  DEFINE_TEST(test_option_newer_than)\n   29  {\n   30:   struct stat st;\n   31  \n   32    /*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/test/test_copy.c:\n  244  \t\tfor (dp = \"dflms\"; *dp != '\\0'; ++dp) {\n  245  \t\t\tDIR *d;\n  246: \t\t\tstruct dirent *de;\n  247  \t\t\tchar dir[2];\n  248  \t\t\tdir[0] = *dp; dir[1] = '\\0';\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/tar/test/test_option_r.c:\n   49  \tassertEmptyFile(\"step1.err\");\n   50  \n   51: \t/* Do some basic validation of the constructed archive. */\n   52  \tp0 = slurpfile(&s, \"archive.tar\");\n   53  \tif (!assert(p0 != NULL))\n   ..\n   76  \tassertEmptyFile(\"step2.err\");\n   77  \n   78: \t/* The constructed archive should just have the new entry appended. */\n   79  \tp1 = slurpfile(&s, \"archive.tar\");\n   80  \tif (!assert(p1 != NULL))\n   ..\n  102  \tassertEmptyFile(\"step3.err\");\n  103  \n  104: \t/* Validate the constructed archive. */\n  105  \tp1 = slurpfile(&s, \"archive.tar\");\n  106  \tif (!assert(p1 != NULL))\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/test_utils/test_utils.h:\n   28  #define TEST_UTILS_H\n   29  \n   30: struct test_list_t\n   31  {\n   32    void (*func)(void);\n   ..\n   35  };\n   36  \n   37: int get_test_set(int *, int, const char *, struct test_list_t *);\n   38  \n   39  #endif /* TEST_UTILS_H */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/test_utils/test_main.c:\n  169  \t\t     BY_HANDLE_FILE_INFORMATION *);\n  170  \n  171: typedef struct _REPARSE_DATA_BUFFER {\n  172  \tULONG\tReparseTag;\n  173  \tUSHORT ReparseDataLength;\n  174  \tUSHORT\tReserved;\n  175  \tunion {\n  176: \t\tstruct {\n  177  \t\t\tUSHORT\tSubstituteNameOffset;\n  178  \t\t\tUSHORT\tSubstituteNameLength;\n  ...\n  182  \t\t\tWCHAR\tPathBuffer[1];\n  183  \t\t} SymbolicLinkReparseBuffer;\n  184: \t\tstruct {\n  185  \t\t\tUSHORT\tSubstituteNameOffset;\n  186  \t\t\tUSHORT\tSubstituteNameLength;\n  ...\n  189  \t\t\tWCHAR\tPathBuffer[1];\n  190  \t\t} MountPointReparseBuffer;\n  191: \t\tstruct {\n  192  \t\t\tUCHAR\tDataBuffer[1];\n  193  \t\t} GenericReparseBuffer;\n  ...\n  472   * used by test_summarize().\n  473   */\n  474: static struct line {\n  475  \tint count;\n  476  \tint skip;\n  ...\n  967  {\n  968  \tchar buff[1024];\n  969: \tstruct stat st;\n  970  \tssize_t s;\n  971  \tFILE *f;\n  ...\n 1002  assertion_non_empty_file(const char *filename, int line, const char *f1)\n 1003  {\n 1004: \tstruct stat st;\n 1005  \n 1006  \tassertion_count(filename, line);\n ....\n 1368  \t\t&& bhfi1.nFileIndexLow == bhfi2.nFileIndexLow);\n 1369  #else\n 1370: \tstruct stat st1, st2;\n 1371  \tint r;\n 1372  \n ....\n 1458  \tnsec = (nsec / 100) * 100; /* Round the request */\n 1459  #else\n 1460: \tstruct stat st;\n 1461  \n 1462  \tassertion_count(file, line);\n ....\n 1566  #else\n 1567  \t{\n 1568: \t\tstruct stat st;\n 1569  \t\tr = lstat(pathname, &st);\n 1570  \t\tmode = (int)(st.st_mode & 0777);\n ....\n 1612  \treturn (0);\n 1613  #else\n 1614: \tstruct stat st;\n 1615  \tint r;\n 1616  \n ....\n 1642  #else\n 1643  \t{\n 1644: \t\tstruct stat st;\n 1645  \t\tr = lstat(pathname, &st);\n 1646  \t\tfilesize = st.st_size;\n ....\n 1659  assertion_is_dir(const char *file, int line, const char *pathname, int mode)\n 1660  {\n 1661: \tstruct stat st;\n 1662  \tint r;\n 1663  \n ....\n 1697  assertion_is_reg(const char *file, int line, const char *pathname, int mode)\n 1698  {\n 1699: \tstruct stat st;\n 1700  \tint r;\n 1701  \n ....\n 1860  #else\n 1861  \tchar buff[300];\n 1862: \tstruct stat st;\n 1863  \tssize_t linklen;\n 1864  \tint r;\n ....\n 2113  \treturn (1);\n 2114  #else /* defined(_WIN32) && !defined(__CYGWIN__) */\n 2115: \tstruct stat st;\n 2116: \tstruct timeval times[2];\n 2117  \n 2118  #if !defined(__FreeBSD__)\n ....\n 2172  {\n 2173  #if defined(HAVE_STRUCT_STAT_ST_FLAGS) && defined(UF_NODUMP)\n 2174: \tstruct stat sa, sb;\n 2175  \n 2176  \tassertion_count(file, line);\n ....\n 2655  #if defined(HAVE_STRUCT_STAT_ST_FLAGS) && defined(UF_NODUMP)\n 2656  \tconst char *path = \"cannodumptest\";\n 2657: \tstruct stat sb;\n 2658  \n 2659  \tassertion_make_file(__FILE__, __LINE__, path, 0644, 0, NULL);\n ....\n 2871  #endif\n 2872  #if ARCHIVE_ACL_LIBRICHACL\n 2873: \tstruct richacl *richacl;\n 2874  #endif\n 2875  #if ARCHIVE_ACL_LIBACL || ARCHIVE_ACL_FREEBSD\n ....\n 3083  {\n 3084  \tchar filename[8192];\n 3085: \tstruct stat st;\n 3086  \tva_list ap;\n 3087  \tchar *p;\n ....\n 3250  \treturn (bhfi.nFileIndexHigh & 0x0000FFFFUL);\n 3251  #else\n 3252: \tstruct stat st;\n 3253  \tint64_t ino;\n 3254  \n ....\n 3270  /* Set ACLs */\n 3271  int\n 3272: assertion_entry_set_acls(const char *file, int line, struct archive_entry *ae,\n 3273:     struct archive_test_acl_t *acls, int n)\n 3274  {\n 3275  \tint i, r, ret;\n ....\n 3297  \n 3298  static int\n 3299: archive_test_acl_match(struct archive_test_acl_t *acl, int type, int permset,\n 3300      int tag, int qual, const char *name)\n 3301  {\n ....\n 3332  int\n 3333  assertion_entry_compare_acls(const char *file, int line,\n 3334:     struct archive_entry *ae, struct archive_test_acl_t *acls, int cnt,\n 3335      int want_type, int mode)\n 3336  {\n ....\n 3472  #undef DEFINE_TEST\n 3473  #define\tDEFINE_TEST(n) { n, #n, 0 },\n 3474: static struct test_list_t tests[] = {\n 3475  \t#include \"list.h\"\n 3476  };\n ....\n 3977  #if !defined(_WIN32) && defined(SIGPIPE)\n 3978  \t{   /* Ignore SIGPIPE signals */\n 3979: \t\tstruct sigaction sa;\n 3980  \t\tsa.sa_handler = SIG_IGN;\n 3981  \t\tsigemptyset(&sa.sa_mask);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/test_utils/test_utils.c:\n   75  \n   76  int get_test_set(int *test_set, int limit, const char *test,\n   77: \tstruct test_list_t *tests)\n   78  {\n   79  \tint start, end;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/test_utils/test_common.h:\n  142  /* If not, define it so as to avoid dangling semicolons. */\n  143  #ifndef __FBSDID\n  144: #define\t__FBSDID(a)     struct _undefined_hack\n  145  #endif\n  146  \n  ...\n  422  #include \"archive_entry.h\"\n  423  \n  424: /* ACL structure */\n  425: struct archive_test_acl_t {\n  426  \tint type;  /* Type of ACL */\n  427  \tint permset; /* Permissions for this class of users. */\n  ...\n  432  \n  433  /* Set ACLs */\n  434: int assertion_entry_set_acls(const char *, int, struct archive_entry *,\n  435:     struct archive_test_acl_t *, int);\n  436  \n  437  /* Compare ACLs */\n  438: int assertion_entry_compare_acls(const char *, int, struct archive_entry *,\n  439:     struct archive_test_acl_t *, int, int, int);\n  440  \n  441  /* Special customized read-from-memory interface. */\n  442: int read_open_memory(struct archive *, const void *, size_t, size_t);\n  443  /* _minimal version exercises a slightly different set of libarchive APIs. */\n  444: int read_open_memory_minimal(struct archive *, const void *, size_t, size_t);\n  445  /* _seek version produces a seekable file. */\n  446: int read_open_memory_seek(struct archive *, const void *, size_t, size_t);\n  447  \n  448  /* Versions of above that accept an archive argument for additional info. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/examples/untar.c:\n   68  static void\textract(const char *filename, int do_extract, int flags);\n   69  static void\tfail(const char *, const char *, int);\n   70: static int\tcopy_data(struct archive *, struct archive *);\n   71  static void\tmsg(const char *);\n   72  static void\tusage(void);\n   ..\n  136  extract(const char *filename, int do_extract, int flags)\n  137  {\n  138: \tstruct archive *a;\n  139: \tstruct archive *ext;\n  140: \tstruct archive_entry *entry;\n  141  \tint r;\n  142  \n  ...\n  198  \n  199  static int\n  200: copy_data(struct archive *ar, struct archive *aw)\n  201  {\n  202  \tint r;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/examples/tarfilter.c:\n   42  \tint r;\n   43  \tmode_t m;\n   44: \tstruct archive *ina;\n   45: \tstruct archive *outa;\n   46: \tstruct archive_entry *entry;\n   47  \n   48  \t/* Read an archive from stdin, with automatic format detection. */\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/examples/minitar/minitar.c:\n  122  static void\terrmsg(const char *);\n  123  static void\textract(const char *filename, int do_extract, int flags);\n  124: static int\tcopy_data(struct archive *, struct archive *);\n  125  static void\tmsg(const char *);\n  126  static void\tusage(void);\n  ...\n  222  create(const char *filename, int compress, const char **argv)\n  223  {\n  224: \tstruct archive *a;\n  225: \tstruct archive_entry *entry;\n  226  \tssize_t len;\n  227  \tint fd;\n  ...\n  254  \n  255  \twhile (*argv != NULL) {\n  256: \t\tstruct archive *disk = archive_read_disk_new();\n  257  #ifndef NO_LOOKUP\n  258  \t\tarchive_read_disk_set_standard_lookup(disk);\n  ...\n  332  extract(const char *filename, int do_extract, int flags)\n  333  {\n  334: \tstruct archive *a;\n  335: \tstruct archive *ext;\n  336: \tstruct archive_entry *entry;\n  337  \tint r;\n  338  \n  ...\n  406  \n  407  static int\n  408: copy_data(struct archive *ar, struct archive *aw)\n  409  {\n  410  \tint r;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cat/bsdcat.c:\n   43  #define\tBYTES_PER_BLOCK\t(20*512)\n   44  \n   45: static struct archive *a;\n   46: static struct archive_entry *ae;\n   47  static const char *bsdcat_current_path;\n   48  static int exit_status = 0;\n   ..\n  116  main(int argc, char **argv)\n  117  {\n  118: \tstruct bsdcat *bsdcat, bsdcat_storage;\n  119  \tint c;\n  120  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cat/bsdcat.h:\n   38  #include <archive_entry.h>\n   39  \n   40: struct bsdcat {\n   41  \t/* Option parser state */\n   42  \tint\t\t  getopt_state;\n   ..\n   53  };\n   54  \n   55: int bsdcat_getopt(struct bsdcat *);\n   56  void usage(FILE *stream, int eval);\n   57  void bsdcat_next(void);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cat/cmdline.c:\n   58   */\n   59  \n   60: static const struct bsdcat_option {\n   61  \tconst char *name;\n   62  \tint required;      /* 1 if this option requires an argument. */\n   ..\n  111  \n  112  int\n  113: bsdcat_getopt(struct bsdcat *bsdcat)\n  114  {\n  115  \tenum { state_start = 0, state_old_tar, state_next_word,\n  116  \t       state_short, state_long };\n  117  \n  118: \tconst struct bsdcat_option *popt, *match = NULL, *match2 = NULL;\n  119  \tconst char *p, *long_prefix = \"--\";\n  120  \tsize_t optlength;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cat/bsdcat_platform.h:\n   50  /* If not, define it so as to avoid dangling semicolons. */\n   51  #ifndef __FBSDID\n   52: #define\t__FBSDID(a)     struct _undefined_hack\n   53  #endif\n   54  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/libarchive/cat/test/test_0.c:\n   37  DEFINE_TEST(test_0)\n   38  {\n   39: \tstruct stat st;\n   40  \n   41  \tfailure(\"File %s does not exist?!\", testprog);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/tests/test_parser.js:\n  235    type: {\n  236      get() {\n  237:       return this.constructor.name;\n  238      }\n  239    },\n  ...\n  249  \n  250  class Terminal extends Node {\n  251:   constructor(value) {\n  252      super();\n  253      this.value = value;\n  ...\n  259  \n  260  class NonTerminal extends Node {\n  261:   constructor(name) {\n  262      super();\n  263      this.name = name;\n  ...\n  269  \n  270  class List extends Node {\n  271:   constructor(nodes, separator) {\n  272      super();\n  273      this.nodes = nodes;\n  ...\n  283  \n  284  class Alternatives extends List {\n  285:   constructor(nodes) {\n  286      super(nodes, ' | ');\n  287    }\n  ...\n  289  \n  290  class Sequence extends List {\n  291:   constructor(nodes) {\n  292      super(nodes, ' ');\n  293    }\n  ...\n  295  \n  296  class Operator extends Node {\n  297:   constructor(node, operator) {\n  298      super();\n  299      this.node = node;\n  ...\n  306  \n  307  class Optional extends Operator {\n  308:   constructor(node) {\n  309      super(node, s => s + '?');\n  310    }\n  ...\n  312  \n  313  class OneOrMany extends Operator {\n  314:   constructor(node) {\n  315      super(node, s => s + '+');\n  316    }\n  ...\n  318  \n  319  class Any extends Operator {\n  320:   constructor(node) {\n  321      super(node, s => s + '*');\n  322    }\n  ...\n  324  \n  325  class Not extends Operator {\n  326:   constructor(node) {\n  327      super(node, s => '~' + s);\n  328    }\n  ...\n  330  \n  331  class EBNFParser extends Parser {\n  332:   constructor(grammar) {\n  333      super(new BNFLexer());\n  334  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/tests/test_op_overloading.js:\n   95  function test_operators_create() {\n   96    class Expr1 {\n   97:     constructor(op, ...args) {\n   98        this.op = op;\n   99        this.children = args;\n  ...\n  118  function test_operators_ctor() {\n  119    class Expr2 {\n  120:     constructor(op, ...args) {\n  121        this.op = op;\n  122        this.children = args;\n  ...\n  220  \n  221    Expr3 = class Expr3 extends ExprOps {\n  222:     constructor(op, ...args) {\n  223        super();\n  224        this.op = op;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/tests/test_misc.js:\n    4  import { Location } from 'misc';\n    5  import { extendArray } from 'util';\n    6: import { JS_EVAL_FLAG_COMPILE_ONLY, JS_EVAL_TYPE_MODULE, JS_EVAL_TYPE_GLOBAL, toArrayBuffer, btoa, atob, valueToAtom, atomToValue, getClassConstructor, arrayToBitfield, bitfieldToArray, compileScript, writeObject, readObject, getByteCode, getOpCodes, resizeArrayBuffer, getClassID, getClassCount, getClassName } from 'misc';\n    7  import * as fs from 'fs';\n    8  import * as path from 'path';\n    .\n   98        console.log('misc.getClassID()', getClassID(Symbol));\n   99        console.log('misc.getClassCount()', getClassCount());\n  100:       console.log('misc.getClassName()', new Map(Range(1, getClassCount()).map((id, idx) => [idx, [getClassName(id), getClassConstructor(id)]])));\n  101      }\n  102      let bits = arrayToBitfield([2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30], 2);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/tests/test_inspect.js:\n   17  \n   18  class Test {\n   19:   constructor() {}\n   20  \n   21    inspect(level, options = {}) {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/socklen_t.js:\n    1  export class socklen_t extends ArrayBuffer {\n    2:   constructor(v) {\n    3      super(4);\n    4  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/console.js:\n    2  import * as std from 'std';\n    3  import inspect from 'inspect';\n    4: //import {types,getPrototypeChain,getConstructorChain} from 'util';\n    5  \n    6  /*const FileProto = Object.getPrototypeOf(std.in);\n    7: const { constructor: File } = FileProto;*/\n    8  \n    9  export function Console(...args) {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/clexer.js:\n   12    typedef: /typedef/,\n   13    switch: /switch/,\n   14:   struct: /struct/,\n   15    static: /static/,\n   16    sizeof: /sizeof/,\n   ..\n  101  \n  102  export class CLexer extends Lexer {\n  103:   constructor(input, filename, mask) {\n  104      super(input, Lexer.LONGEST, filename, mask);\n  105  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/jslexer.js:\n  100  \n  101  export class JSLexer extends Lexer {\n  102:   constructor(input, fileName) {\n  103      super(input, Lexer.FIRST, fileName);\n  104:     //console.log('JSLexer.constructor', { fileName });\n  105      this.fileName = fileName;\n  106  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/require.js:\n   73  \n   74  class CJSModule {\n   75:   constructor(id, m) {\n   76      this.id = id;\n   77      this.path = m;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/stack.js:\n    4  const inspectSymbol = Symbol.inspect ?? Symbol.for('quickjs.inspect.custom');\n    5  \n    6: const booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n    7  const numericProps = ['columnNumber', 'lineNumber'];\n    8  const stringProps = ['fileName', 'functionName', 'source'];\n    .\n  117  \n  118  export class StackFrame {\n  119:   constructor(obj) {\n  120      if(!obj) return;\n  121  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/util.js:\n    1  import inspect from 'inspect';\n    2  import { SyscallError } from 'syscallerror';\n    3: import { arrayToBitfield, atob, atomToString, atomToValue, bitfieldToArray, btoa, compileScript, concatArrayBuffer, dupArrayBuffer, evalBinary, getByteCode, getClassAtom, getClassConstructor, getClassCount, getClassID, getClassName, getClassProto, getCommandLine, getCurrentWorkingDirectory, getExecutable, getFileDescriptor, getOpCodes, getPerformanceCounter, getProcMaps, getProcMounts, getProcStat, getPrototypeChain, getRootDirectory, getegid, geteuid, getgid, getpid, getppid, getsid, getuid, hrtime, readObject, resizeArrayBuffer, setegid, seteuid, setgid, setuid, toArrayBuffer, toPointer, toString, uname, valuePtr, valueTag, valueToAtom, valueType, writeObject, rand, randi, randf, srand } from 'misc';\n    4  import { extendArray, ArrayExtensions } from './extendArray.js';\n    5: import { extendGenerator, GeneratorExtensions, GeneratorPrototype, GeneratorConstructor } from './extendGenerator.js';\n    6  import * as os from 'os';\n    7  \n    .\n   16  }\n   17  \n   18: util.prototype.constructor = util;\n   19  \n   20: const AsyncFunction = async function x() {}.constructor;\n   21: const GeneratorFunction = function* () {}.constructor;\n   22: const AsyncGeneratorFunction = async function* () {}.constructor;\n   23: const TypedArray = protoOf(protoOf(new Uint16Array(10))).constructor;\n   24  \n   25  const SetIteratorPrototype = protoOf(new Set().values());\n   ..\n  255    },\n  256    isNativeError(v) {\n  257:     return isObject(v) && v instanceof Error && isNative(v.constructor);\n  258    },\n  259    isMapIterator(v) {\n  ...\n  301  \n  302  export function format(...args) {\n  303:   return formatWithOptionsInternal({ hideKeys: ['constructor'] }, args);\n  304  }\n  305  \n  ...\n  497  }\n  498  \n  499: export function getConstructorChain(obj) {\n  500    let ret = [];\n  501    let chain = getPrototypeChain(obj);\n  502:   if(obj.constructor && obj.constructor != chain[0].constructor) chain.unshift(obj);\n  503:   for(let proto of chain) ret.push(proto.constructor);\n  504    return ret;\n  505  }\n  ...\n  770  util.errors = errors;\n  771  util.getPrototypeChain = getPrototypeChain;\n  772: util.getConstructorChain = getConstructorChain;\n  773  util.hasPrototype = hasPrototype;\n  774  util.ansiStyles = ansiStyles;\n  ...\n  785  export { extendArray, ArrayExtensions } from './extendArray.js';\n  786  export { SyscallError } from 'syscallerror';\n  787: export { arrayToBitfield, atob, atomToString, atomToValue, bitfieldToArray, btoa, compileScript, concatArrayBuffer, dupArrayBuffer, evalBinary, getByteCode, getClassAtom, getClassConstructor, getClassCount, getClassID, getClassName, getClassProto, getCommandLine, getCurrentWorkingDirectory, getExecutable, getFileDescriptor, getOpCodes, getPerformanceCounter, getProcMaps, getProcMounts, getProcStat, getPrototypeChain, getRootDirectory, getegid, geteuid, getgid, getpid, getppid, getsid, getuid, hrtime, readObject, resizeArrayBuffer, setegid, seteuid, setgid, setuid, toArrayBuffer, toPointer, toString, uname, valuePtr, valueTag, valueToAtom, valueType, writeObject } from 'misc';\n  788  export { inspect } from 'inspect';\n  789  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/repl.js:\n  155    out = std.out;\n  156  \n  157:   constructor(name, show_banner = true) {\n  158      if('fs' in globalThis) this.fs = globalThis.fs;\n  159      //else import('fs').then(fs => (globalThis.fs = this.fs = fs));\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/bnflexer.js:\n   22    };\n   23  \n   24:   constructor(input, filename) {\n   25:     //console.log('BNFLexer.constructor', { input, filename });\n   26      super(input, Lexer.FIRST, filename);\n   27  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/fs.js:\n   31   */\n   32  export class Stats {\n   33:   constructor(st) {\n   34      this.mode = st.mode;\n   35  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/parser.js:\n    8  \n    9  export class Parser {\n   10:   constructor(lexer) {\n   11      this.lexer = lexer;\n   12      this.buffer = [];\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/events.js:\n    2  \n    3  export class EventEmitter {\n    4:   constructor() {\n    5      this.events = {};\n    6    }\n    .\n   41  \n   42  export class EventTarget {\n   43:   constructor() {\n   44      Object.defineProperty(this, PRIVATE, {\n   45        value: {\n   ..\n   82  const getMethods = obj =>\n   83    Object.getOwnPropertyNames(obj)\n   84:     .filter(n => n != 'constructor')\n   85      .reduce((acc, n) => ({ ...acc, [n]: obj[n] }), {});\n   86  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/extendGenerator.js:\n    6  \n    7  export const GeneratorPrototype = Object.getPrototypeOf(function* () {});\n    8: export const GeneratorConstructor = GeneratorPrototype.constructor;\n    9  \n   10  export function extendGenerator(proto = GeneratorPrototype) {\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/extendArray.js:\n   39      return this;\n   40    },\n   41:   search(item, pred = (a, b) => (a == b ? true : a && b && a.constructor && b.constructor && a.constructor === b.constructor && a.constructor.equal ? a.constructor.equal(a, b) : false)) {\n   42      for(let i = 0; i < this.length; i++) if(pred(item, this[i])) return i;\n   43      return -1;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/pigpiod_if2.c:\n   61  typedef void (*CBF_t) ();\n   62  \n   63: struct callback_s\n   64  {\n   65  \n   ..\n   75  };\n   76  \n   77: struct evtCallback_s\n   78  {\n   79  \n   ..\n  238  {\n  239     int sock, err, opt;\n  240:    struct addrinfo hints, *res, *rp;\n  241  \n  242     memset (&hints, 0, sizeof (hints));\n  ...\n  570  double time_time(void)\n  571  {\n  572:    struct timeval tv;\n  573     double t;\n  574  \n  ...\n  582  void time_sleep(double seconds)\n  583  {\n  584:    struct timespec ts, rem;\n  585  \n  586     if (seconds > 0.0)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/command.h:\n   53  #define CMD_PAR     3\n   54  \n   55: typedef struct\n   56  {\n   57     uint32_t cmd;\n   ..\n   66  } cmdCmd_t;\n   67  \n   68: typedef struct\n   69  {\n   70     int    eaten;\n   ..\n   72  } cmdCtlParse_t;\n   73  \n   74: typedef struct\n   75  {\n   76     int   cmd;  /* command number            */\n   ..\n   81  } cmdInfo_t;\n   82  \n   83: typedef struct\n   84  {\n   85     uint32_t tag;\n   ..\n   87  } cmdTagStep_t;\n   88  \n   89: typedef struct\n   90  {\n   91     uintptr_t p[5]; //these are sometimes converted to pointers, so presumablly they sometimes have pointers stored in them, I haven't figured out where though. --plugwash\n   ..\n   93  } cmdInstr_t;\n   94  \n   95: typedef struct\n   96  {\n   97     /*\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/pigpiod_if2.h:\n   54  o notifications when any of GPIO 0-31 change state\n   55  \n   56: o the construction of output waveforms with microsecond timing\n   57  \n   58  o rudimentary permission control over GPIO\n   ..\n  355     (int pi, unsigned user_gpio, unsigned level, uint32_t tick, void *userdata);\n  356  \n  357: typedef struct callback_s callback_t;\n  358  \n  359  typedef void (*evtCBFunc_t)\n  ...\n  363     (int pi, unsigned event, uint32_t tick, void *userdata);\n  364  \n  365: typedef struct evtCallback_s evtCallback_t;\n  366  \n  367  /*F*/\n  ...\n  832  \n  833  . .\n  834: typedef struct\n  835  {\n  836     uint16_t seqno;\n  ...\n 1347  \n 1348  A waveform comprises one or more pulses.  Each pulse consists of a\n 1349: [*gpioPulse_t*] structure.\n 1350  \n 1351  . .\n 1352: typedef struct\n 1353  {\n 1354     uint32_t gpioOn;\n ....\n 1396  A usage would be the creation of two waves where one is filled while the other\n 1397  is being transmitted. Each wave is assigned 50% of the resources.\n 1398: This buffer structure allows the transmission of infinite wave sequences.\n 1399  \n 1400  Normal usage:\n ....\n 3526  . .\n 3527       pi: >=0 (as returned by [*pigpio_start*]).\n 3528: bscxfer: a structure defining the transfer.\n 3529  \n 3530: typedef struct\n 3531  {\n 3532     uint32_t control;          // Write\n ....\n 3665        pi: >=0 (as returned by [*pigpio_start*]).\n 3666  i2c_addr: 0-0x7F.\n 3667:  bscxfer: a structure defining the transfer.\n 3668  \n 3669: typedef struct\n 3670  {\n 3671     uint32_t control;          // N/A\n ....\n 3830  \n 3831  . .\n 3832: typedef struct\n 3833  {\n 3834     uint32_t control;          // Write\n ....\n 3986  gpioPulse_t::\n 3987  . .\n 3988: typedef struct\n 3989  {\n 3990     uint32_t gpioOn;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/pigs.c:\n  111  {\n  112     int sock, err;\n  113:    struct addrinfo hints, *res, *rp;\n  114     const char *addrStr, *portStr;\n  115  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/pig2vcd.c:\n   53     static char buf[32];\n   54  \n   55:    struct timeval now;\n   56:    struct tm tmp;\n   57  \n   58     gettimeofday(&now, NULL);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/pigpio.h:\n   54  o notifications when any of GPIO 0-31 change state\n   55  \n   56: o the construction of output waveforms with microsecond timing\n   57  \n   58  o rudimentary permission control over GPIO\n   ..\n  425  #endif\n  426  \n  427: typedef struct\n  428  {\n  429     uint16_t func;\n  ...\n  431  } gpioHeader_t;\n  432  \n  433: typedef struct\n  434  {\n  435     size_t size;\n  ...\n  438  } gpioExtent_t;\n  439  \n  440: typedef struct\n  441  {\n  442     uint32_t tick;\n  ...\n  444  } gpioSample_t;\n  445  \n  446: typedef struct\n  447  {\n  448     uint16_t seqno;\n  ...\n  452  } gpioReport_t;\n  453  \n  454: typedef struct\n  455  {\n  456     uint32_t gpioOn;\n  ...\n  462  #define WAVE_FLAG_TICK  2\n  463  \n  464: typedef struct\n  465  {\n  466     uint32_t gpioOn;\n  ...\n  483  */\n  484  \n  485: typedef struct\n  486  {\n  487     uint16_t botCB;  /* first CB used by wave  */\n  ...\n  497  } rawWaveInfo_t;\n  498  \n  499: typedef struct\n  500  {\n  501     int clk;     /* GPIO for clock           */\n  ...\n  509  } rawSPI_t;\n  510  \n  511: typedef struct { /* linux/arch/arm/mach-bcm2708/include/mach/dma.h */\n  512     uint32_t info;\n  513     uint32_t src;\n  ...\n  519  } rawCbs_t;\n  520  \n  521: typedef struct\n  522  {\n  523     uint16_t addr;  /* slave address       */\n  ...\n  531  #define BSC_FIFO_SIZE 512\n  532  \n  533: typedef struct\n  534  {\n  535     uint32_t control;          /* Write */\n  ...\n 1709  \n 1710  Each notification occupies 12 bytes in the fifo and has the\n 1711: following structure.\n 1712  \n 1713  . .\n 1714: typedef struct\n 1715  {\n 1716     uint16_t seqno;\n ....\n 1846  \n 1847  ...\n 1848: // Construct and send a 30 microsecond square wave.\n 1849  \n 1850  gpioSetMode(gpio, PI_OUTPUT);\n ....\n 1973  \n 1974  A waveform comprises one of more pulses.  Each pulse consists of a\n 1975: [*gpioPulse_t*] structure.\n 1976  \n 1977  . .\n 1978: typedef struct\n 1979  {\n 1980     uint32_t gpioOn;\n ....\n 2022  A usage would be the creation of two waves where one is filled while the other\n 2023  is being transmitted. Each wave is assigned 50% of the resources.\n 2024: This buffer structure allows the transmission of infinite wave sequences.\n 2025  \n 2026  ...\n ....\n 2987  \n 2988  . .\n 2989: bsc_xfer:= a structure defining the transfer\n 2990  \n 2991: typedef struct\n 2992  {\n 2993     uint32_t control;          // Write\n ....\n 5338  \n 5339  . .\n 5340: typedef struct\n 5341  {\n 5342     uint32_t control;          // Write\n ....\n 5567  gpioPulse_t::\n 5568  . .\n 5569: typedef struct\n 5570  {\n 5571     uint32_t gpioOn;\n ....\n 5577  gpioSample_t::\n 5578  . .\n 5579: typedef struct\n 5580  {\n 5581     uint32_t tick;\n ....\n 5807  pi_i2c_msg_t::\n 5808  . .\n 5809: typedef struct\n 5810  {\n 5811     uint16_t addr;  // slave address\n ....\n 5884  rawCbs_t::\n 5885  . .\n 5886: typedef struct // linux/arch/arm/mach-bcm2708/include/mach/dma.h\n 5887  {\n 5888     unsigned long info;\n ....\n 5898  rawSPI_t::\n 5899  . .\n 5900: typedef struct\n 5901  {\n 5902     int clk;     // GPIO for clock\n ....\n 5913  rawWave_t::\n 5914  . .\n 5915: typedef struct\n 5916  {\n 5917     uint32_t gpioOn;\n ....\n 5924  rawWaveInfo_t::\n 5925  . .\n 5926: typedef struct\n 5927  {\n 5928     uint16_t botCB;  // first CB used by wave\n ....\n 6024  \n 6025  *spi::\n 6026: A pointer to a [*rawSPI_t*] structure.\n 6027  \n 6028  spiBitFirst::\n ....\n 6420  #define PI_TOO_MANY_CHARS   -37 // waveform has too many chars\n 6421  #define PI_NOT_SERIAL_GPIO  -38 // no bit bang serial read on GPIO\n 6422: #define PI_BAD_SERIAL_STRUC -39 // bad (null) serial structure parameter\n 6423  #define PI_BAD_SERIAL_BUF   -40 // bad (null) serial buf parameter\n 6424  #define PI_NOT_PERMITTED    -41 // GPIO operation not permitted\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/pigpio.c:\n  720     0  CB [13]  13*8  104 CBs for counter 0\n  721   104  CB [13]  13*8  104 CBs for counter 1\n  722:  208  CB [60]  60*8  480 CBs reserved to construct wave\n  723:  688 OOL [60]  60*1   60 OOL reserved to construct wave\n  724   748 OOL[136] 136*1  136 OOL for counter 0\n  725   884 OOL[136] 136*1  136 OOL for counter 1\n  ...\n  898  typedef void (*callbk_t) ();\n  899  \n  900: typedef struct\n  901  {\n  902     rawCbs_t cb           [128];\n  903  } dmaPage_t;\n  904  \n  905: typedef struct\n  906  {\n  907     rawCbs_t cb           [CBS_PER_IPAGE];\n  ...\n  914  } dmaIPage_t;\n  915  \n  916: typedef struct\n  917  {\n  918     rawCbs_t cb     [CBS_PER_OPAGE];\n  ...\n  921  } dmaOPage_t;\n  922  \n  923: typedef struct\n  924  {\n  925     uint8_t  is;\n  ...\n  932  } gpioInfo_t;\n  933  \n  934: typedef struct\n  935  {\n  936     callbk_t func;\n  ...\n  958  } gpioAlert_t;\n  959  \n  960: typedef struct\n  961  {\n  962     callbk_t func;\n  ...\n  967  } eventAlert_t;\n  968  \n  969: typedef struct\n  970  {\n  971     unsigned gpio;\n  ...\n  980  } gpioISR_t;\n  981  \n  982: typedef struct\n  983  {\n  984     callbk_t func;\n  ...\n  987  } gpioSignal_t;\n  988  \n  989: typedef struct\n  990  {\n  991     callbk_t func;\n  ...\n  995  } gpioGetSamples_t;\n  996  \n  997: typedef struct\n  998  {\n  999     callbk_t func;\n ....\n 1006  } gpioTimer_t;\n 1007  \n 1008: typedef struct\n 1009  {\n 1010     unsigned id;\n ....\n 1022  \n 1023  \n 1024: typedef struct\n 1025  {\n 1026     uint16_t valid;\n ....\n 1028  } clkCfg_t;\n 1029  \n 1030: typedef struct\n 1031  {\n 1032     uint16_t seqno;\n ....\n 1040  } gpioNotify_t;\n 1041  \n 1042: typedef struct\n 1043  {\n 1044     uint16_t state;\n ....\n 1047  } fileInfo_t;\n 1048  \n 1049: typedef struct\n 1050  {\n 1051     uint16_t state;\n ....\n 1056  } i2cInfo_t;\n 1057  \n 1058: typedef struct\n 1059  {\n 1060     uint16_t state;\n ....\n 1063  } serInfo_t;\n 1064  \n 1065: typedef struct\n 1066  {\n 1067     uint16_t state;\n ....\n 1070  } spiInfo_t;\n 1071  \n 1072: typedef struct\n 1073  {\n 1074     uint32_t alertTicks;\n ....\n 1089  } gpioStats_t;\n 1090  \n 1091: typedef struct\n 1092  {\n 1093     unsigned bufferMilliseconds;\n ....\n 1108  } gpioCfg_t;\n 1109  \n 1110: typedef struct\n 1111  {\n 1112     uint32_t micros;\n ....\n 1121  } wfStats_t;\n 1122  \n 1123: typedef struct\n 1124  {\n 1125     char    *buf;\n ....\n 1140  } wfRxSerial_t;\n 1141  \n 1142: typedef struct\n 1143  {\n 1144     int SDA;\n ....\n 1150  } wfRxI2C_t;\n 1151  \n 1152: typedef struct\n 1153  {\n 1154     int CS;\n ....\n 1165  } wfRxSPI_t;\n 1166  \n 1167: typedef struct\n 1168  {\n 1169     int      mode;\n ....\n 1186  };\n 1187  \n 1188: struct my_smbus_ioctl_data\n 1189  {\n 1190     uint8_t read_write;\n ....\n 1194  };\n 1195  \n 1196: typedef struct\n 1197  {\n 1198     pi_i2c_msg_t *msgs; /* pointers to pi_i2c_msgs */\n ....\n 1200  } my_i2c_rdwr_ioctl_data_t;\n 1201  \n 1202: typedef struct\n 1203  {\n 1204     unsigned div;\n ....\n 1207  } clkInf_t;\n 1208  \n 1209: typedef struct\n 1210  {\n 1211     unsigned  handle;        /* mbAllocateMemory() */\n ....\n 1235  /* initialise every gpioInitialise */\n 1236  \n 1237: static struct timespec libStarted;\n 1238  \n 1239  static uint32_t sockNetAddr[MAX_CONNECT_ADDRESSES];\n ....\n 1544  static char * myTimeStamp()\n 1545  {\n 1546:    static struct timeval last;\n 1547     static char buf[32];\n 1548:    struct timeval now;\n 1549  \n 1550:    struct tm tmp;\n 1551  \n 1552     gettimeofday(&now, NULL);\n ....\n 1630     int fd, char rw, uint8_t cmd, int size, union my_smbus_data *data)\n 1631  {\n 1632:    struct my_smbus_ioctl_data args;\n 1633  \n 1634     DBG(DBG_INTERNAL, \"rw=%d reg=%d cmd=%d data=%s\",\n ....\n 1677  static void myGpioSleep(int seconds, int micros)\n 1678  {\n 1679:    struct timespec ts, rem;\n 1680  \n 1681     ts.tv_sec  = seconds;\n ....\n 4908  {\n 4909     static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n 4910:    struct termios new;\n 4911     int speed;\n 4912     int fd;\n ....\n 5647  {\n 5648     int i;\n 5649:    struct sigaction new;\n 5650  \n 5651     for (i=PI_MIN_SIGNUM; i<=PI_MAX_SIGNUM; i++)\n ....\n 6282  static void * pthAlertThread(void *x)\n 6283  {\n 6284:    struct timespec req, rem;\n 6285     uint32_t oldLevel, newLevel, level;\n 6286     uint32_t oldSlot,  newSlot;\n ....\n 6875  {\n 6876     gpioTimer_t *tp;\n 6877:    struct timespec req, rem;\n 6878  \n 6879     tp = x;\n ....\n 7165  }\n 7166  \n 7167: static int addrAllowed(struct sockaddr *saddr)\n 7168  {\n 7169     int i;\n ....\n 7175     if (saddr->sa_family != AF_INET) return 0;\n 7176  \n 7177:    addr = ((struct sockaddr_in *) saddr)->sin_addr.s_addr;\n 7178  \n 7179     for (i=0; i<numSockNetAddr; i++)\n ....\n 7189  {\n 7190     int fdC=0, c, *sock;\n 7191:    struct sockaddr_storage client;\n 7192     pthread_attr_t attr;\n 7193  \n ....\n 7219        pthread_t thr;\n 7220  \n 7221:       fdC = accept(fdSock, (struct sockaddr *)&client, (socklen_t*)&c);\n 7222  \n 7223        closeOrphanedNotifications(-1, fdC);\n 7224  \n 7225:       if (addrAllowed((struct sockaddr *)&client))\n 7226        {\n 7227           DBG(DBG_USER, \"Connection accepted on socket %d\", fdC);\n ....\n 8247     int i;\n 8248     unsigned rev, model;\n 8249:    struct sockaddr_in server;\n 8250:    struct sockaddr_in6 server6;\n 8251     char * portStr;\n 8252     unsigned port;\n 8253:    struct sched_param param;\n 8254     pthread_attr_t pthAttr;\n 8255  \n ....\n 8395              int opt = 1;\n 8396              setsockopt(fdSock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n 8397:             if (bind(fdSock,(struct sockaddr *)&server6, sizeof(server6)) < 0)\n 8398                 SOFT_ERROR(PI_INIT_FAILED, \"bind to port %d failed (%m)\", port);\n 8399           }\n ....\n 8422           server.sin_port = htons(port);\n 8423  \n 8424:          if (bind(fdSock,(struct sockaddr *)&server , sizeof(server)) < 0)\n 8425              SOFT_ERROR(PI_INIT_FAILED, \"bind to port %d failed (%m)\", port);\n 8426        }\n ....\n 8576  double time_time(void)\n 8577  {\n 8578:    struct timeval tv;\n 8579     double t;\n 8580  \n ....\n 8590  void time_sleep(double seconds)\n 8591  {\n 8592:    struct timespec ts, rem;\n 8593  \n 8594     if (seconds > 0.0)\n ....\n 11761     int level;\n 11762     uint32_t levels;\n 11763:    struct pollfd pfd;\n 11764     char buf[64];\n 11765  \n .....\n 13302     int fd=-1;\n 13303     int i, slot, oflag, omode, pmode, rmode;\n 13304:    struct stat statbuf;\n 13305  \n 13306     DBG(DBG_USER, \"file=%s mode=%d\", file, mode);\n .....\n 13574  int gpioTime(unsigned timetype, int *seconds, int *micros)\n 13575  {\n 13576:    struct timespec ts;\n 13577  \n 13578     DBG(DBG_USER, \"timetype=%d &seconds=%08\"PRIXPTR\" &micros=%08\"PRIXPTR,\n .....\n 13608  int gpioSleep(unsigned timetype, int seconds, int micros)\n 13609  {\n 13610:    struct timespec ts, rem;\n 13611  \n 13612     DBG(DBG_USER, \"timetype=%d seconds=%d micros=%d\",\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/pigpiod_if.c:\n   59  typedef void (*CBF_t) ();\n   60  \n   61: struct callback_s\n   62  {\n   63  \n   ..\n  165  {\n  166     int sock, err, opt;\n  167:    struct addrinfo hints, *res, *rp;\n  168     const char *addrStr, *portStr;\n  169  \n  ...\n  380  double time_time(void)\n  381  {\n  382:    struct timeval tv;\n  383     double t;\n  384  \n  ...\n  392  void time_sleep(double seconds)\n  393  {\n  394:    struct timespec ts, rem;\n  395  \n  396     if (seconds > 0.0)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/pigpiod.c:\n  131  {\n  132     int err;\n  133:    struct addrinfo hints, *res;\n  134:    struct sockaddr_in *sin;\n  135     const char *portStr;\n  136     uint32_t addr;\n  ...\n  150     if (err) return 0;\n  151  \n  152:    sin = (struct sockaddr_in *)res->ai_addr;\n  153     addr = sin->sin_addr.s_addr;\n  154  \n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/pigpiod_if.h:\n   57  o notifications when any of GPIO 0-31 change state\n   58  \n   59: o the construction of output waveforms with microsecond timing\n   60  \n   61  o rudimentary permission control over GPIO\n   ..\n  291     (unsigned user_gpio, unsigned level, uint32_t tick, void * user);\n  292  \n  293: typedef struct callback_s callback_t;\n  294  \n  295  /*F*/\n  ...\n  731  \n  732  . .\n  733: typedef struct\n  734  {\n  735     uint16_t seqno;\n  ...\n 1185  \n 1186  A waveform comprises one or more pulses.  Each pulse consists of a\n 1187: [*gpioPulse_t*] structure.\n 1188  \n 1189  . .\n 1190: typedef struct\n 1191  {\n 1192     uint32_t gpioOn;\n ....\n 2710  gpioPulse_t::\n 2711  . .\n 2712: typedef struct\n 2713  {\n 2714  uint32_t gpioOn;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/command.c:\n  414  \\n\";\n  415  \n  416: typedef struct\n  417  {\n  418     int error;\n  ...\n  460     {PI_TOO_MANY_CHARS   , \"waveform has too many chars\"},\n  461     {PI_NOT_SERIAL_GPIO  , \"no bit bang serial read in progress on GPIO\"},\n  462:    {PI_BAD_SERIAL_STRUC , \"bad (null) serial structure parameter\"},\n  463     {PI_BAD_SERIAL_BUF   , \"bad (null) serial buf parameter\"}, \n  464     {PI_NOT_PERMITTED    , \"no permission to update GPIO\"},\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/EXAMPLES/C/WIEGAND_CODE/wiegand.h:\n    6  typedef void (*Pi_Wieg_CB_t)(int, uint32_t);\n    7  \n    8: struct _Pi_Wieg_s;\n    9  \n   10: typedef struct _Pi_Wieg_s Pi_Wieg_t;\n   11  \n   12  Pi_Wieg_t *Pi_Wieg(int gpio_0, int gpio_1, Pi_Wieg_CB_t callback, int timeout);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/EXAMPLES/C/WIEGAND_CODE/wiegand.c:\n    5  #include \"wiegand.h\"\n    6  \n    7: struct _Pi_Wieg_s\n    8  {\n    9     int mygpio_0;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/EXAMPLES/C/ROTARY_ENCODER/rotary_encoder.h:\n    4  typedef void (*Pi_Renc_CB_t)(int);\n    5  \n    6: struct _Pi_Renc_s;\n    7  \n    8: typedef struct _Pi_Renc_s Pi_Renc_t;\n    9  \n   10  Pi_Renc_t * Pi_Renc(int gpioA, int gpioB, Pi_Renc_CB_t callback);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/EXAMPLES/C/ROTARY_ENCODER/rotary_encoder.c:\n    6  #include \"rotary_encoder.h\"\n    7  \n    8: struct _Pi_Renc_s\n    9  {\n   10     int gpioA;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/EXAMPLES/C/IR_RECEIVER/ir_hasher.c:\n   19  */\n   20  \n   21: struct _Pi_Hasher_s\n   22  {\n   23     int gpio;\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/EXAMPLES/C/IR_RECEIVER/ir_hasher.h:\n    6  typedef void (*Pi_Hasher_CB_t)(uint32_t);\n    7  \n    8: struct _Pi_Hasher_s;\n    9  \n   10: typedef struct _Pi_Hasher_s Pi_Hasher_t;\n   11  \n   12  Pi_Hasher_t * Pi_Hasher(int gpio, Pi_Hasher_CB_t callback, int timeout);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/pigpio/EXAMPLES/C/I2C_SNIFFER/pig2i2c.c:\n   62     static char buf[32];\n   63  \n   64:    struct timeval now;\n   65:    struct tm tmp;\n   66  \n   67     gettimeofday(&now, NULL);\n\n10771 matches across 563 files\n\n\nSearching 792 files for \"^MemoryBlock\" (regex)\n\n0 matches\n\nSearching 792 files for \"^(struct |)MemoryBlock\" (regex)\n\n0 matches\n\nSearching 792 files for \"^(struct |)(Memory_?Block|pointer_?range)\" (regex)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/buffer-utils.h:\n   98  }\n   99  \n  100: struct memory_block;\n  101: struct pointer_range;\n  102  struct offset_length;\n  103  \n\n2 matches in 1 file\n\n\nSearching 792 files for \"^(struct |)(Memory_?Block|pointer_?range|input_*buffer)\" (regex)\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/buffer-utils.h:\n   98  }\n   99  \n  100: struct memory_block;\n  101: struct pointer_range;\n  102  struct offset_length;\n  103  \n  ...\n  212  \n  213  static inline void\n  214: input_buffer_free_default(JSContext* ctx, const char* str, JSValue val) {\n  215    if(JS_IsString(val))\n  216      JS_FreeCString(ctx, str);\n  ...\n  220  }\n  221  \n  222: InputBuffer js_input_buffer(JSContext* ctx, JSValueConst value);\n  223: InputBuffer js_input_chars(JSContext* ctx, JSValueConst value);\n  224: InputBuffer input_buffer_clone(const InputBuffer* in, JSContext* ctx);\n  225  BOOL input_buffer_valid(const InputBuffer* in);\n  226  void input_buffer_dump(const InputBuffer* in, DynBuf* db);\n  ...\n  228  \n  229  static inline uint8_t*\n  230: input_buffer_data(const InputBuffer* in) {\n  231    return in->data + in->range.offset;\n  232  }\n  233  \n  234  static inline size_t\n  235: input_buffer_length(const InputBuffer* in) {\n  236    return MIN_NUM(in->range.length, in->size);\n  237  }\n  238  \n  239  static inline MemoryBlock\n  240: input_buffer_block(InputBuffer* in) {\n  241    return (MemoryBlock){input_buffer_data(in), input_buffer_length(in)};\n  242  }\n  243  \n  244  static inline InputBuffer\n  245: input_buffer_offset(InputBuffer in, OffsetLength off) {\n  246    InputBuffer ret = in;\n  247  \n  ...\n  261  \n  262  static int\n  263: input_buffer_peekc(InputBuffer* in, size_t* lenp) {\n  264    const uint8_t *pos, *end, *next;\n  265    int cp;\n  ...\n  274  \n  275  static inline int\n  276: input_buffer_getc(InputBuffer* in) {\n  277    size_t n;\n  278    int ret;\n  ...\n  283  \n  284  static inline uint8_t*\n  285: input_buffer_begin(const InputBuffer* in) {\n  286    return input_buffer_data(in);\n  287  }\n  288  static inline uint8_t*\n  289: input_buffer_end(const InputBuffer* in) {\n  290    return input_buffer_data(in) + input_buffer_length(in);\n  291  }\n  292  static inline BOOL\n  293: input_buffer_eof(const InputBuffer* in) {\n  294    return in->pos == input_buffer_length(in);\n  295  }\n  296  static inline size_t\n  297: input_buffer_remain(const InputBuffer* in) {\n  298    return input_buffer_length(in) - in->pos;\n  299  }\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-blob.c:\n   62  }\n   63  \n   64: InputBuffer\n   65  blob_input(JSContext* ctx, Blob* blob) {\n   66    InputBuffer ret = {blob->data, 0, blob->size, &input_buffer_free_default, JS_UNDEFINED, {0, INT64_MAX}};\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-blob.h:\n   24  ssize_t blob_write(JSContext*, Blob* blob, const void* x, size_t len);\n   25  void blob_free(JSContext*, Blob* blob);\n   26: InputBuffer blob_input(JSContext*, Blob* blob);\n   27  JSValue js_blob_wrap(JSContext*, Blob* blob);\n   28  JSValue js_blob_new(JSContext*, const void* x, size_t len, const char* type);\n\n/home/roman/Sources/plot-cv/quickjs/qjs-modules/buffer-utils.c:\n  327  }\n  328  \n  329: InputBuffer\n  330  js_input_buffer(JSContext* ctx, JSValueConst value) {\n  331    InputBuffer ret = {0, 0, 0, &input_buffer_free_default, JS_UNDEFINED};\n  ...\n  369  }\n  370  \n  371: InputBuffer\n  372  js_input_chars(JSContext* ctx, JSValueConst value) {\n  373    InputBuffer ret = {0, 0, 0, &input_buffer_free_default, JS_UNDEFINED};\n  ...\n  388  \n  389  BOOL\n  390: input_buffer_valid(const InputBuffer* in) {\n  391    return !JS_IsException(in->value);\n  392  }\n  393  \n  394: InputBuffer\n  395: input_buffer_clone(const InputBuffer* in, JSContext* ctx) {\n  396    InputBuffer ret = js_input_buffer(ctx, in->value);\n  397  \n  ...\n  404  \n  405  void\n  406: input_buffer_dump(const InputBuffer* in, DynBuf* db) {\n  407    dbuf_printf(db, \"(InputBuffer){ .data = %p, .size = %zu, .pos = %zu, .free = %p }\", in->data, in->size, in->pos, in->free);\n  408  }\n  409  \n  410  void\n  411: input_buffer_free(InputBuffer* in, JSContext* ctx) {\n  412    if(in->data) {\n  413      in->free(ctx, (const char*)in->data, in->value);\n  ...\n  420  \n  421  const uint8_t*\n  422: input_buffer_peek(InputBuffer* in, size_t* lenp) {\n  423    input_buffer_peekc(in, lenp);\n  424    return input_buffer_data(in) + in->pos;\n  ...\n  426  \n  427  const uint8_t*\n  428: input_buffer_get(InputBuffer* in, size_t* lenp) {\n  429    size_t n;\n  430    const uint8_t* ret;\n  ...\n  437  \n  438  const char*\n  439: input_buffer_currentline(InputBuffer* in, size_t* len) {\n  440    size_t i;\n  441  \n  ...\n  450  \n  451  size_t\n  452: input_buffer_column(InputBuffer* in, size_t* len) {\n  453    size_t i;\n  454  \n\n29 matches across 4 files\n",
			"settings":
			{
				"buffer_size": 1104676,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "/home/roman/Sources/plot-cv/quickjs/qjs-modules/buffer-utils.h",
			"settings":
			{
				"buffer_size": 7730,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					5,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAACXHQAAI2lmbmRlZiBCVUZGRVJfVVRJTFNfSAojZGVmaW5lIEJVRkZFUl9VVElMU19ICgojaW5jbHVkZSA8cXVpY2tqcy5oPgojaW5jbHVkZSA8Y3V0aWxzLmg+CiNpbmNsdWRlIDxzdGRhcmcuaD4KCiNpbmNsdWRlICJjaGFyLXV0aWxzLmgiCgojaWZuZGVmIE1BWF9OVU0KI2RlZmluZSBNQVhfTlVNKGEsIGIpICgoYSkgPiAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgojaWZuZGVmIE1JTl9OVU0KI2RlZmluZSBNSU5fTlVNKGEsIGIpICgoYSkgPCAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgoKc2l6ZV90IGFuc2lfbGVuZ3RoKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV9za2lwKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV90cnVuY2F0ZShjb25zdCBjaGFyKiwgc2l6ZV90LCBzaXplX3QgbGltaXQpOwppbnQ2NF90IGFycmF5X3NlYXJjaCh2b2lkKiwgc2l6ZV90LCBzaXplX3QgZWxzeiwgdm9pZCogbmVlZGxlKTsKY2hhciogc3RyX2VzY2FwZShjb25zdCBjaGFyKik7CmNoYXIqIGJ5dGVfZXNjYXBlKGNvbnN0IHZvaWQqLCBzaXplX3QpOwpzaXplX3QgYnl0ZV9maW5kYihjb25zdCB2b2lkKiwgc2l6ZV90LCBjb25zdCB2b2lkKiB3aGF0LCBzaXplX3Qgd2xlbik7CnNpemVfdCBieXRlX2ZpbmRzKGNvbnN0IHZvaWQqLCBzaXplX3QsIGNvbnN0IGNoYXIqIHdoYXQpOwpzaXplX3QgYnl0ZV9lcXVhbChjb25zdCB2b2lkKiBzLCBzaXplX3QgbiwgY29uc3Qgdm9pZCogdCk7CmNoYXIqIGRidWZfYXRfbihjb25zdCBEeW5CdWYqLCBzaXplX3QsIHNpemVfdCogbiwgY2hhciBzZXApOwpjb25zdCBjaGFyKiBkYnVmX2xhc3RfbGluZShEeW5CdWYqLCBzaXplX3QqKTsKaW50IGRidWZfcHJlcGVuZChEeW5CdWYqLCBjb25zdCB1aW50OF90Kiwgc2l6ZV90IGxlbik7CnZvaWQgZGJ1Zl9wdXRfY29sb3JzdHIoRHluQnVmKiwgY29uc3QgY2hhciosIGNvbnN0IGNoYXIqIGNvbG9yLCBpbnQgd2l0aF9jb2xvcik7CnZvaWQgZGJ1Zl9wdXRfZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkX3RhYmxlKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBjb25zdCBjaGFyIHRhYmxlWzI1Nl0pOwp2b2lkIGRidWZfcHV0X3VuZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuKTsKdm9pZCBkYnVmX3B1dF92YWx1ZShEeW5CdWYqLCBKU0NvbnRleHQqLCBKU1ZhbHVlIHZhbHVlKTsKaW50IGRidWZfcmVzZXJ2ZV9zdGFydChEeW5CdWYqLCBzaXplX3QpOwpzaXplX3QgZGJ1Zl90b2tlbl9wb3AoRHluQnVmKiwgY2hhcik7CnNpemVfdCBkYnVmX3Rva2VuX3B1c2goRHluQnVmKiwgY29uc3QgY2hhciosIHNpemVfdCBsZW4sIGNoYXIgZGVsaW0pOwpKU1ZhbHVlIGRidWZfdG9zdHJpbmdfZnJlZShEeW5CdWYqLCBKU0NvbnRleHQqKTsKc3NpemVfdCBkYnVmX2xvYWQoRHluQnVmKiwgY29uc3QgY2hhciopOwoKc3RhdGljIGlubGluZSBpbnQKZGJ1Zl9wdXRtKER5bkJ1ZiogZGIsIC4uLikgewogIGludCByID0gMDsKICB2YV9saXN0IGE7CiAgY29uc3QgY2hhciogczsKICB2YV9zdGFydChhLCBkYik7CiAgd2hpbGUoKHMgPSB2YV9hcmcoYSwgY2hhciopKSkKICAgIGlmKGRidWZfcHV0c3RyKGRiLCBzKSkKICAgICAgcmV0dXJuIC0xOwogIHZhX2VuZChhKTsKICByZXR1cm4gcjsKfQoKI2RlZmluZSBkYnVmX2FwcGVuZChkLCB4LCBuKSBkYnVmX3B1dCgoZCksIChjb25zdCB1aW50OF90KikoeCksIChuKSkKCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfY291bnQoRHluQnVmKiBkYiwgaW50IGNoKSB7CiAgcmV0dXJuIGJ5dGVfY291bnQoZGItPmJ1ZiwgZGItPnNpemUsIGNoKTsKfQoKc3RhdGljIGlubGluZSB2b2lkCmRidWZfMChEeW5CdWYqIGRiKSB7CiAgZGJ1Zl9wdXRjKGRiLCAnXDAnKTsKICBkYi0+c2l6ZS0tOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQKZGJ1Zl96ZXJvKER5bkJ1ZiogZGIpIHsKICBkYnVmX3JlYWxsb2MoZGIsIDApOwp9CgpzdGF0aWMgaW5saW5lIGludDMyX3QKZGJ1Zl9nZXRfY29sdW1uKER5bkJ1ZiogZGIpIHsKICBzaXplX3QgbGVuOwogIGNvbnN0IGNoYXIqIHN0cjsKICBpZihkYi0+c2l6ZSkgewogICAgc3RyID0gZGJ1Zl9sYXN0X2xpbmUoZGIsICZsZW4pOwogICAgcmV0dXJuIGFuc2lfbGVuZ3RoKHN0ciwgbGVuKTsKICB9CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfYml0ZmxhZ3MoRHluQnVmKiBkYiwgdWludDMyX3QgYml0cywgY29uc3QgY2hhciogY29uc3QgbmFtZXNbXSkgewogIHNpemVfdCBpLCBuID0gMDsKICBmb3IoaSA9IDA7IGkgPCBzaXplb2YoYml0cykgKiA4OyBpKyspIHsKICAgIGlmKGJpdHMgJiAoMSA8PCBpKSkgewogICAgICBzaXplX3QgbGVuID0gc3RybGVuKG5hbWVzW2ldKTsKICAgICAgaWYobikgewogICAgICAgIG4rKzsKICAgICAgICBkYnVmX3B1dHN0cihkYiwgInwiKTsKICAgICAgfQogICAgICBkYnVmX2FwcGVuZChkYiwgbmFtZXNbaV0sIGxlbik7CiAgICAgIG4gKz0gbGVuOwogICAgfQogIH0KICByZXR1cm4gbjsKfQoKc3RydWN0IG1lbW9yeV9ibG9jazsKc3RydWN0IHBvaW50ZXJfcmFuZ2U7CnN0cnVjdCBvZmZzZXRfbGVuZ3RoOwoKdHlwZWRlZiBzdHJ1Y3QgbWVtb3J5X2Jsb2NrIHsKICB1aW50OF90KiBiYXNlOwogIHNpemVfdCBzaXplOwp9IE1lbW9yeUJsb2NrOwoKc3RhdGljIGlubGluZSB2b2lkCmJsb2NrX2luaXQoTWVtb3J5QmxvY2sqIG1iKSB7CiAgbWItPmJhc2UgPSAwOwogIG1iLT5zaXplID0gMDsKfQoKc3RhdGljIGlubGluZSB2b2lkKgpibG9ja19kYXRhKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+YmFzZTsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKYmxvY2tfbGVuZ3RoKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+c2l6ZTsKfQoKdHlwZWRlZiBzdHJ1Y3QgcG9pbnRlcl9yYW5nZSB7CiAgdWludDhfdCAqc3RhcnQsICplbmQ7Cn0gUG9pbnRlclJhbmdlOwoKc3RhdGljIGlubGluZSB2b2lkCnJhbmdlX2luaXQoUG9pbnRlclJhbmdlKiBwcikgewogIHByLT5lbmQgPSBwci0+c3RhcnQgPSAwOwp9CgpzdGF0aWMgaW5saW5lIFBvaW50ZXJSYW5nZQpyYW5nZV9mcm9tKGNvbnN0IE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiAoUG9pbnRlclJhbmdlKXttYi0+YmFzZSwgbWItPmJhc2UgKyBtYi0+c2l6ZX07Cn0KCnR5cGVkZWYgc3RydWN0IG9mZnNldF9sZW5ndGggewogIGludDY0X3Qgb2Zmc2V0LCBsZW5ndGg7Cn0gT2Zmc2V0TGVuZ3RoOwoKc3RhdGljIGlubGluZSB2b2lkCm9mZnNldF9pbml0KE9mZnNldExlbmd0aCogb2wpIHsKICBvbC0+b2Zmc2V0ID0gMDsKICBvbC0+bGVuZ3RoID0gSU5UNjRfTUFYOwp9CgpzdGF0aWMgaW5saW5lIEJPT0wKb2Zmc2V0X2lzX2RlZmF1bHQoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCkgewogIHJldHVybiBvbC0+b2Zmc2V0ID09IDAgJiYgb2wtPmxlbmd0aCA9PSBJTlQ2NF9NQVg7Cn0KCnN0YXRpYyBpbmxpbmUgdWludDhfdCoKb2Zmc2V0X2RhdGEoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCwgY29uc3Qgdm9pZCogeCkgewogIHJldHVybiAodWludDhfdCopeCArIG9sLT5vZmZzZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90Cm9mZnNldF9zaXplKGNvbnN0IE9mZnNldExlbmd0aCogb2wsIHNpemVfdCBuKSB7CiAgcmV0dXJuIE1JTl9OVU0ob2wtPmxlbmd0aCwgbiAtIG9sLT5vZmZzZXQpOwp9CgpzdGF0aWMgaW5saW5lIE1lbW9yeUJsb2NrCm9mZnNldF9ibG9jayhjb25zdCBPZmZzZXRMZW5ndGgqIG9sLCBjb25zdCB2b2lkKiB4LCBzaXplX3QgbikgewogIHJldHVybiAoTWVtb3J5QmxvY2spe29mZnNldF9kYXRhKG9sLCB4KSwgb2Zmc2V0X3NpemUob2wsIG4pfTsKfQoKc3RhdGljIGlubGluZSBQb2ludGVyUmFuZ2UKb2Zmc2V0X3JhbmdlKGNvbnN0IE9mZnNldExlbmd0aCogb2wsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBuKSB7CiAgTWVtb3J5QmxvY2sgbWIgPSBvZmZzZXRfYmxvY2sob2wsIHgsIG4pOwogIHJldHVybiByYW5nZV9mcm9tKCZtYik7Cn0KCnN0YXRpYyBpbmxpbmUgT2Zmc2V0TGVuZ3RoCm9mZnNldF9zbGljZShjb25zdCBPZmZzZXRMZW5ndGggb2wsIGludDY0X3Qgc3RhcnQsIGludDY0X3QgZW5kKSB7CiAgaWYoc3RhcnQgPCAwKQogICAgc3RhcnQgPSBvbC5sZW5ndGggKyAoc3RhcnQgJSBvbC5sZW5ndGgpOwogIGVsc2UgaWYoc3RhcnQgPiBvbC5sZW5ndGgpCiAgICBzdGFydCA9IG9sLmxlbmd0aDsKICBpZihlbmQgPCAwKQogICAgZW5kID0gb2wubGVuZ3RoICsgKGVuZCAlIG9sLmxlbmd0aCk7CiAgZWxzZSBpZihlbmQgPiBvbC5sZW5ndGgpCiAgICBlbmQgPSBvbC5sZW5ndGg7CgogIHJldHVybiAoT2Zmc2V0TGVuZ3RoKXtzdGFydCwgZW5kIC0gc3RhcnR9Owp9CgpzdGF0aWMgaW5saW5lIE9mZnNldExlbmd0aApvZmZzZXRfb2Zmc2V0KGNvbnN0IE9mZnNldExlbmd0aCogb2wsIGNvbnN0IE9mZnNldExlbmd0aCogYnkpIHsKICBPZmZzZXRMZW5ndGggcmV0OwogIHJldC5vZmZzZXQgPSBvbC0+b2Zmc2V0ICsgYnktPm9mZnNldDsKICByZXQubGVuZ3RoID0gTUlOX05VTShieS0+bGVuZ3RoLCBvbC0+bGVuZ3RoIC0gYnktPm9mZnNldCk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBNZW1vcnlCbG9jawpibG9ja19yYW5nZShjb25zdCBNZW1vcnlCbG9jayogbWIsIHN0cnVjdCBvZmZzZXRfbGVuZ3RoKiByYW5nZSkgewogIE1lbW9yeUJsb2NrIHJldDsKICByZXQuYmFzZSA9IG1iLT5iYXNlICsgcmFuZ2UtPm9mZnNldDsKICByZXQuc2l6ZSA9IE1JTl9OVU0ocmFuZ2UtPmxlbmd0aCwgbWItPnNpemUgLSByYW5nZS0+b2Zmc2V0KTsKICByZXR1cm4gcmV0Owp9Cgp0eXBlZGVmIHN0cnVjdCBJbnB1dEJ1ZmZlciB7CiAgdWludDhfdCogZGF0YTsKICBzaXplX3QgcG9zLCBzaXplOwogIHZvaWQgKCpmcmVlKShKU0NvbnRleHQqLCBjb25zdCBjaGFyKiwgSlNWYWx1ZSk7CiAgSlNWYWx1ZSB2YWx1ZTsKICBPZmZzZXRMZW5ndGggcmFuZ2U7Cn0gSW5wdXRCdWZmZXI7CgpzdGF0aWMgaW5saW5lIHZvaWQKaW5wdXRfYnVmZmVyX2ZyZWVfZGVmYXVsdChKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogc3RyLCBKU1ZhbHVlIHZhbCkgewogIGlmKEpTX0lzU3RyaW5nKHZhbCkpCiAgICBKU19GcmVlQ1N0cmluZyhjdHgsIHN0cik7CgogIGlmKCFKU19Jc1VuZGVmaW5lZCh2YWwpKQogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsKTsKfQoKSW5wdXRCdWZmZXIganNfaW5wdXRfYnVmZmVyKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwpJbnB1dEJ1ZmZlciBqc19pbnB1dF9jaGFycyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKSW5wdXRCdWZmZXIgaW5wdXRfYnVmZmVyX2Nsb25lKGNvbnN0IElucHV0QnVmZmVyKiBpbiwgSlNDb250ZXh0KiBjdHgpOwpCT09MIGlucHV0X2J1ZmZlcl92YWxpZChjb25zdCBJbnB1dEJ1ZmZlciogaW4pOwp2b2lkIGlucHV0X2J1ZmZlcl9kdW1wKGNvbnN0IElucHV0QnVmZmVyKiBpbiwgRHluQnVmKiBkYik7CnZvaWQgaW5wdXRfYnVmZmVyX2ZyZWUoSW5wdXRCdWZmZXIqIGluLCBKU0NvbnRleHQqIGN0eCk7CgpzdGF0aWMgaW5saW5lIHVpbnQ4X3QqCmlucHV0X2J1ZmZlcl9kYXRhKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbi0+ZGF0YSArIGluLT5yYW5nZS5vZmZzZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmlucHV0X2J1ZmZlcl9sZW5ndGgoY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIE1JTl9OVU0oaW4tPnJhbmdlLmxlbmd0aCwgaW4tPnNpemUpOwp9CgpzdGF0aWMgaW5saW5lIE1lbW9yeUJsb2NrCmlucHV0X2J1ZmZlcl9ibG9jayhJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gKE1lbW9yeUJsb2NrKXtpbnB1dF9idWZmZXJfZGF0YShpbiksIGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pfTsKfQoKc3RhdGljIGlubGluZSBJbnB1dEJ1ZmZlcgppbnB1dF9idWZmZXJfb2Zmc2V0KElucHV0QnVmZmVyIGluLCBPZmZzZXRMZW5ndGggb2ZmKSB7CiAgSW5wdXRCdWZmZXIgcmV0ID0gaW47CgogIHJldC5kYXRhICs9IG9mZi5vZmZzZXQ7CiAgcmV0LnNpemUgLT0gb2ZmLm9mZnNldDsKCiAgaWYocmV0LnNpemUgPiBvZmYubGVuZ3RoKQogICAgcmV0LnNpemUgPSBvZmYubGVuZ3RoOwoKICByZXR1cm4gcmV0Owp9Cgpjb25zdCB1aW50OF90KiBpbnB1dF9idWZmZXJfZ2V0KElucHV0QnVmZmVyKiBpbiwgc2l6ZV90KiBsZW5wKTsKY29uc3QgdWludDhfdCogaW5wdXRfYnVmZmVyX3BlZWsoSW5wdXRCdWZmZXIqIGluLCBzaXplX3QqIGxlbnApOwpjb25zdCBjaGFyKiBpbnB1dF9idWZmZXJfY3VycmVudGxpbmUoSW5wdXRCdWZmZXIqLCBzaXplX3QqIGxlbik7CnNpemVfdCBpbnB1dF9idWZmZXJfY29sdW1uKElucHV0QnVmZmVyKiwgc2l6ZV90KiBsZW4pOwoKc3RhdGljIGludAppbnB1dF9idWZmZXJfcGVla2MoSW5wdXRCdWZmZXIqIGluLCBzaXplX3QqIGxlbnApIHsKICBjb25zdCB1aW50OF90ICpwb3MsICplbmQsICpuZXh0OwogIGludCBjcDsKICBwb3MgPSBpbnB1dF9idWZmZXJfZGF0YShpbikgKyBpbi0+cG9zOwogIGVuZCA9IGlucHV0X2J1ZmZlcl9kYXRhKGluKSArIGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pOwogIGNwID0gdW5pY29kZV9mcm9tX3V0ZjgocG9zLCBlbmQgLSBwb3MsICZuZXh0KTsKICBpZihsZW5wKQogICAgKmxlbnAgPSBuZXh0IC0gcG9zOwoKICByZXR1cm4gY3A7Cn0KCnN0YXRpYyBpbmxpbmUgaW50CmlucHV0X2J1ZmZlcl9nZXRjKElucHV0QnVmZmVyKiBpbikgewogIHNpemVfdCBuOwogIGludCByZXQ7CiAgcmV0ID0gaW5wdXRfYnVmZmVyX3BlZWtjKGluLCAmbik7CiAgaW4tPnBvcyArPSBuOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgdWludDhfdCoKaW5wdXRfYnVmZmVyX2JlZ2luKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbnB1dF9idWZmZXJfZGF0YShpbik7Cn0Kc3RhdGljIGlubGluZSB1aW50OF90KgppbnB1dF9idWZmZXJfZW5kKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbnB1dF9idWZmZXJfZGF0YShpbikgKyBpbnB1dF9idWZmZXJfbGVuZ3RoKGluKTsKfQpzdGF0aWMgaW5saW5lIEJPT0wKaW5wdXRfYnVmZmVyX2VvZihjb25zdCBJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gaW4tPnBvcyA9PSBpbnB1dF9idWZmZXJfbGVuZ3RoKGluKTsKfQpzdGF0aWMgaW5saW5lIHNpemVfdAppbnB1dF9idWZmZXJfcmVtYWluKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbnB1dF9idWZmZXJfbGVuZ3RoKGluKSAtIGluLT5wb3M7Cn0KCk9mZnNldExlbmd0aCBqc19vZmZzZXRfbGVuZ3RoKEpTQ29udGV4dCosIGludDY0X3Qgc2l6ZSwgaW50IGFyZ2MsIEpTVmFsdWUgYXJndltdKTsKCiNlbmRpZiAvKiBkZWZpbmVkKEJVRkZFUl9VVElMUykgKi8KAAAAAAAAAAA7HgAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAADuFAAAAAAAAP0UAAAAAAAAAAAAAAAA8L8"
				],
				[
					6,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAA7HgAAI2lmbmRlZiBCVUZGRVJfVVRJTFNfSAojZGVmaW5lIEJVRkZFUl9VVElMU19ICgojaW5jbHVkZSA8cXVpY2tqcy5oPgojaW5jbHVkZSA8Y3V0aWxzLmg+CiNpbmNsdWRlIDxzdGRhcmcuaD4KCiNpbmNsdWRlICJjaGFyLXV0aWxzLmgiCgojaWZuZGVmIE1BWF9OVU0KI2RlZmluZSBNQVhfTlVNKGEsIGIpICgoYSkgPiAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgojaWZuZGVmIE1JTl9OVU0KI2RlZmluZSBNSU5fTlVNKGEsIGIpICgoYSkgPCAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgoKc2l6ZV90IGFuc2lfbGVuZ3RoKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV9za2lwKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV90cnVuY2F0ZShjb25zdCBjaGFyKiwgc2l6ZV90LCBzaXplX3QgbGltaXQpOwppbnQ2NF90IGFycmF5X3NlYXJjaCh2b2lkKiwgc2l6ZV90LCBzaXplX3QgZWxzeiwgdm9pZCogbmVlZGxlKTsKY2hhciogc3RyX2VzY2FwZShjb25zdCBjaGFyKik7CmNoYXIqIGJ5dGVfZXNjYXBlKGNvbnN0IHZvaWQqLCBzaXplX3QpOwpzaXplX3QgYnl0ZV9maW5kYihjb25zdCB2b2lkKiwgc2l6ZV90LCBjb25zdCB2b2lkKiB3aGF0LCBzaXplX3Qgd2xlbik7CnNpemVfdCBieXRlX2ZpbmRzKGNvbnN0IHZvaWQqLCBzaXplX3QsIGNvbnN0IGNoYXIqIHdoYXQpOwpzaXplX3QgYnl0ZV9lcXVhbChjb25zdCB2b2lkKiBzLCBzaXplX3QgbiwgY29uc3Qgdm9pZCogdCk7CmNoYXIqIGRidWZfYXRfbihjb25zdCBEeW5CdWYqLCBzaXplX3QsIHNpemVfdCogbiwgY2hhciBzZXApOwpjb25zdCBjaGFyKiBkYnVmX2xhc3RfbGluZShEeW5CdWYqLCBzaXplX3QqKTsKaW50IGRidWZfcHJlcGVuZChEeW5CdWYqLCBjb25zdCB1aW50OF90Kiwgc2l6ZV90IGxlbik7CnZvaWQgZGJ1Zl9wdXRfY29sb3JzdHIoRHluQnVmKiwgY29uc3QgY2hhciosIGNvbnN0IGNoYXIqIGNvbG9yLCBpbnQgd2l0aF9jb2xvcik7CnZvaWQgZGJ1Zl9wdXRfZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkX3RhYmxlKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBjb25zdCBjaGFyIHRhYmxlWzI1Nl0pOwp2b2lkIGRidWZfcHV0X3VuZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuKTsKdm9pZCBkYnVmX3B1dF92YWx1ZShEeW5CdWYqLCBKU0NvbnRleHQqLCBKU1ZhbHVlIHZhbHVlKTsKaW50IGRidWZfcmVzZXJ2ZV9zdGFydChEeW5CdWYqLCBzaXplX3QpOwpzaXplX3QgZGJ1Zl90b2tlbl9wb3AoRHluQnVmKiwgY2hhcik7CnNpemVfdCBkYnVmX3Rva2VuX3B1c2goRHluQnVmKiwgY29uc3QgY2hhciosIHNpemVfdCBsZW4sIGNoYXIgZGVsaW0pOwpKU1ZhbHVlIGRidWZfdG9zdHJpbmdfZnJlZShEeW5CdWYqLCBKU0NvbnRleHQqKTsKc3NpemVfdCBkYnVmX2xvYWQoRHluQnVmKiwgY29uc3QgY2hhciopOwoKc3RhdGljIGlubGluZSBpbnQKZGJ1Zl9wdXRtKER5bkJ1ZiogZGIsIC4uLikgewogIGludCByID0gMDsKICB2YV9saXN0IGE7CiAgY29uc3QgY2hhciogczsKICB2YV9zdGFydChhLCBkYik7CiAgd2hpbGUoKHMgPSB2YV9hcmcoYSwgY2hhciopKSkKICAgIGlmKGRidWZfcHV0c3RyKGRiLCBzKSkKICAgICAgcmV0dXJuIC0xOwogIHZhX2VuZChhKTsKICByZXR1cm4gcjsKfQoKI2RlZmluZSBkYnVmX2FwcGVuZChkLCB4LCBuKSBkYnVmX3B1dCgoZCksIChjb25zdCB1aW50OF90KikoeCksIChuKSkKCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfY291bnQoRHluQnVmKiBkYiwgaW50IGNoKSB7CiAgcmV0dXJuIGJ5dGVfY291bnQoZGItPmJ1ZiwgZGItPnNpemUsIGNoKTsKfQoKc3RhdGljIGlubGluZSB2b2lkCmRidWZfMChEeW5CdWYqIGRiKSB7CiAgZGJ1Zl9wdXRjKGRiLCAnXDAnKTsKICBkYi0+c2l6ZS0tOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQKZGJ1Zl96ZXJvKER5bkJ1ZiogZGIpIHsKICBkYnVmX3JlYWxsb2MoZGIsIDApOwp9CgpzdGF0aWMgaW5saW5lIGludDMyX3QKZGJ1Zl9nZXRfY29sdW1uKER5bkJ1ZiogZGIpIHsKICBzaXplX3QgbGVuOwogIGNvbnN0IGNoYXIqIHN0cjsKICBpZihkYi0+c2l6ZSkgewogICAgc3RyID0gZGJ1Zl9sYXN0X2xpbmUoZGIsICZsZW4pOwogICAgcmV0dXJuIGFuc2lfbGVuZ3RoKHN0ciwgbGVuKTsKICB9CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfYml0ZmxhZ3MoRHluQnVmKiBkYiwgdWludDMyX3QgYml0cywgY29uc3QgY2hhciogY29uc3QgbmFtZXNbXSkgewogIHNpemVfdCBpLCBuID0gMDsKICBmb3IoaSA9IDA7IGkgPCBzaXplb2YoYml0cykgKiA4OyBpKyspIHsKICAgIGlmKGJpdHMgJiAoMSA8PCBpKSkgewogICAgICBzaXplX3QgbGVuID0gc3RybGVuKG5hbWVzW2ldKTsKICAgICAgaWYobikgewogICAgICAgIG4rKzsKICAgICAgICBkYnVmX3B1dHN0cihkYiwgInwiKTsKICAgICAgfQogICAgICBkYnVmX2FwcGVuZChkYiwgbmFtZXNbaV0sIGxlbik7CiAgICAgIG4gKz0gbGVuOwogICAgfQogIH0KICByZXR1cm4gbjsKfQoKc3RydWN0IG1lbW9yeV9ibG9jazsKc3RydWN0IHBvaW50ZXJfcmFuZ2U7CnN0cnVjdCBvZmZzZXRfbGVuZ3RoOwoKdHlwZWRlZiBzdHJ1Y3QgbWVtb3J5X2Jsb2NrIHsKICB1aW50OF90KiBiYXNlOwogIHNpemVfdCBzaXplOwp9IE1lbW9yeUJsb2NrOwoKc3RhdGljIGlubGluZSB2b2lkCmJsb2NrX2luaXQoTWVtb3J5QmxvY2sqIG1iKSB7CiAgbWItPmJhc2UgPSAwOwogIG1iLT5zaXplID0gMDsKfQoKc3RhdGljIGlubGluZSB2b2lkKgpibG9ja19kYXRhKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+YmFzZTsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKYmxvY2tfbGVuZ3RoKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+c2l6ZTsKfQoKCnN0YXRpYyBpbmxpbmUgQk9PTApibG9ja19hcnJheWJ1ZmZlcihNZW1vcnlCbG9jayogbWIsIEpTVmFsdWVDb25zdCBhYiwgSlNDb250ZXh0KiBjdHgpIHsKICBtYi0+YmFzZSA9IEpTX0dldEFycmF5QnVmZmVyKGN0eCwgJm1iLT5zaXplLCBhYik7CiAgcmV0dXJuIG1iLT5zaXplOwp9Cgp0eXBlZGVmIHN0cnVjdCBwb2ludGVyX3JhbmdlIHsKICB1aW50OF90ICpzdGFydCwgKmVuZDsKfSBQb2ludGVyUmFuZ2U7CgpzdGF0aWMgaW5saW5lIHZvaWQKcmFuZ2VfaW5pdChQb2ludGVyUmFuZ2UqIHByKSB7CiAgcHItPmVuZCA9IHByLT5zdGFydCA9IDA7Cn0KCnN0YXRpYyBpbmxpbmUgUG9pbnRlclJhbmdlCnJhbmdlX2Zyb20oY29uc3QgTWVtb3J5QmxvY2sqIG1iKSB7CiAgcmV0dXJuIChQb2ludGVyUmFuZ2Upe21iLT5iYXNlLCBtYi0+YmFzZSArIG1iLT5zaXplfTsKfQoKdHlwZWRlZiBzdHJ1Y3Qgb2Zmc2V0X2xlbmd0aCB7CiAgaW50NjRfdCBvZmZzZXQsIGxlbmd0aDsKfSBPZmZzZXRMZW5ndGg7CgpzdGF0aWMgaW5saW5lIHZvaWQKb2Zmc2V0X2luaXQoT2Zmc2V0TGVuZ3RoKiBvbCkgewogIG9sLT5vZmZzZXQgPSAwOwogIG9sLT5sZW5ndGggPSBJTlQ2NF9NQVg7Cn0KCnN0YXRpYyBpbmxpbmUgQk9PTApvZmZzZXRfaXNfZGVmYXVsdChjb25zdCBPZmZzZXRMZW5ndGgqIG9sKSB7CiAgcmV0dXJuIG9sLT5vZmZzZXQgPT0gMCAmJiBvbC0+bGVuZ3RoID09IElOVDY0X01BWDsKfQoKc3RhdGljIGlubGluZSB1aW50OF90KgpvZmZzZXRfZGF0YShjb25zdCBPZmZzZXRMZW5ndGgqIG9sLCBjb25zdCB2b2lkKiB4KSB7CiAgcmV0dXJuICh1aW50OF90Kil4ICsgb2wtPm9mZnNldDsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKb2Zmc2V0X3NpemUoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCwgc2l6ZV90IG4pIHsKICByZXR1cm4gTUlOX05VTShvbC0+bGVuZ3RoLCBuIC0gb2wtPm9mZnNldCk7Cn0KCnN0YXRpYyBpbmxpbmUgTWVtb3J5QmxvY2sKb2Zmc2V0X2Jsb2NrKGNvbnN0IE9mZnNldExlbmd0aCogb2wsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBuKSB7CiAgcmV0dXJuIChNZW1vcnlCbG9jayl7b2Zmc2V0X2RhdGEob2wsIHgpLCBvZmZzZXRfc2l6ZShvbCwgbil9Owp9CgpzdGF0aWMgaW5saW5lIFBvaW50ZXJSYW5nZQpvZmZzZXRfcmFuZ2UoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCwgY29uc3Qgdm9pZCogeCwgc2l6ZV90IG4pIHsKICBNZW1vcnlCbG9jayBtYiA9IG9mZnNldF9ibG9jayhvbCwgeCwgbik7CiAgcmV0dXJuIHJhbmdlX2Zyb20oJm1iKTsKfQoKc3RhdGljIGlubGluZSBPZmZzZXRMZW5ndGgKb2Zmc2V0X3NsaWNlKGNvbnN0IE9mZnNldExlbmd0aCBvbCwgaW50NjRfdCBzdGFydCwgaW50NjRfdCBlbmQpIHsKICBpZihzdGFydCA8IDApCiAgICBzdGFydCA9IG9sLmxlbmd0aCArIChzdGFydCAlIG9sLmxlbmd0aCk7CiAgZWxzZSBpZihzdGFydCA+IG9sLmxlbmd0aCkKICAgIHN0YXJ0ID0gb2wubGVuZ3RoOwogIGlmKGVuZCA8IDApCiAgICBlbmQgPSBvbC5sZW5ndGggKyAoZW5kICUgb2wubGVuZ3RoKTsKICBlbHNlIGlmKGVuZCA+IG9sLmxlbmd0aCkKICAgIGVuZCA9IG9sLmxlbmd0aDsKCiAgcmV0dXJuIChPZmZzZXRMZW5ndGgpe3N0YXJ0LCBlbmQgLSBzdGFydH07Cn0KCnN0YXRpYyBpbmxpbmUgT2Zmc2V0TGVuZ3RoCm9mZnNldF9vZmZzZXQoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCwgY29uc3QgT2Zmc2V0TGVuZ3RoKiBieSkgewogIE9mZnNldExlbmd0aCByZXQ7CiAgcmV0Lm9mZnNldCA9IG9sLT5vZmZzZXQgKyBieS0+b2Zmc2V0OwogIHJldC5sZW5ndGggPSBNSU5fTlVNKGJ5LT5sZW5ndGgsIG9sLT5sZW5ndGggLSBieS0+b2Zmc2V0KTsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW5saW5lIE1lbW9yeUJsb2NrCmJsb2NrX3JhbmdlKGNvbnN0IE1lbW9yeUJsb2NrKiBtYiwgc3RydWN0IG9mZnNldF9sZW5ndGgqIHJhbmdlKSB7CiAgTWVtb3J5QmxvY2sgcmV0OwogIHJldC5iYXNlID0gbWItPmJhc2UgKyByYW5nZS0+b2Zmc2V0OwogIHJldC5zaXplID0gTUlOX05VTShyYW5nZS0+bGVuZ3RoLCBtYi0+c2l6ZSAtIHJhbmdlLT5vZmZzZXQpOwogIHJldHVybiByZXQ7Cn0KCnR5cGVkZWYgc3RydWN0IElucHV0QnVmZmVyIHsKICB1aW50OF90KiBkYXRhOwogIHNpemVfdCBwb3MsIHNpemU7CiAgdm9pZCAoKmZyZWUpKEpTQ29udGV4dCosIGNvbnN0IGNoYXIqLCBKU1ZhbHVlKTsKICBKU1ZhbHVlIHZhbHVlOwogIE9mZnNldExlbmd0aCByYW5nZTsKfSBJbnB1dEJ1ZmZlcjsKCnN0YXRpYyBpbmxpbmUgdm9pZAppbnB1dF9idWZmZXJfZnJlZV9kZWZhdWx0KEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBzdHIsIEpTVmFsdWUgdmFsKSB7CiAgaWYoSlNfSXNTdHJpbmcodmFsKSkKICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgc3RyKTsKCiAgaWYoIUpTX0lzVW5kZWZpbmVkKHZhbCkpCiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWwpOwp9CgpJbnB1dEJ1ZmZlciBqc19pbnB1dF9idWZmZXIoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CklucHV0QnVmZmVyIGpzX2lucHV0X2NoYXJzKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwpJbnB1dEJ1ZmZlciBpbnB1dF9idWZmZXJfY2xvbmUoY29uc3QgSW5wdXRCdWZmZXIqIGluLCBKU0NvbnRleHQqIGN0eCk7CkJPT0wgaW5wdXRfYnVmZmVyX3ZhbGlkKGNvbnN0IElucHV0QnVmZmVyKiBpbik7CnZvaWQgaW5wdXRfYnVmZmVyX2R1bXAoY29uc3QgSW5wdXRCdWZmZXIqIGluLCBEeW5CdWYqIGRiKTsKdm9pZCBpbnB1dF9idWZmZXJfZnJlZShJbnB1dEJ1ZmZlciogaW4sIEpTQ29udGV4dCogY3R4KTsKCnN0YXRpYyBpbmxpbmUgdWludDhfdCoKaW5wdXRfYnVmZmVyX2RhdGEoY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIGluLT5kYXRhICsgaW4tPnJhbmdlLm9mZnNldDsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKaW5wdXRfYnVmZmVyX2xlbmd0aChjb25zdCBJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gTUlOX05VTShpbi0+cmFuZ2UubGVuZ3RoLCBpbi0+c2l6ZSk7Cn0KCnN0YXRpYyBpbmxpbmUgTWVtb3J5QmxvY2sKaW5wdXRfYnVmZmVyX2Jsb2NrKElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiAoTWVtb3J5QmxvY2spe2lucHV0X2J1ZmZlcl9kYXRhKGluKSwgaW5wdXRfYnVmZmVyX2xlbmd0aChpbil9Owp9CgpzdGF0aWMgaW5saW5lIElucHV0QnVmZmVyCmlucHV0X2J1ZmZlcl9vZmZzZXQoSW5wdXRCdWZmZXIgaW4sIE9mZnNldExlbmd0aCBvZmYpIHsKICBJbnB1dEJ1ZmZlciByZXQgPSBpbjsKCiAgcmV0LmRhdGEgKz0gb2ZmLm9mZnNldDsKICByZXQuc2l6ZSAtPSBvZmYub2Zmc2V0OwoKICBpZihyZXQuc2l6ZSA+IG9mZi5sZW5ndGgpCiAgICByZXQuc2l6ZSA9IG9mZi5sZW5ndGg7CgogIHJldHVybiByZXQ7Cn0KCmNvbnN0IHVpbnQ4X3QqIGlucHV0X2J1ZmZlcl9nZXQoSW5wdXRCdWZmZXIqIGluLCBzaXplX3QqIGxlbnApOwpjb25zdCB1aW50OF90KiBpbnB1dF9idWZmZXJfcGVlayhJbnB1dEJ1ZmZlciogaW4sIHNpemVfdCogbGVucCk7CmNvbnN0IGNoYXIqIGlucHV0X2J1ZmZlcl9jdXJyZW50bGluZShJbnB1dEJ1ZmZlciosIHNpemVfdCogbGVuKTsKc2l6ZV90IGlucHV0X2J1ZmZlcl9jb2x1bW4oSW5wdXRCdWZmZXIqLCBzaXplX3QqIGxlbik7CgpzdGF0aWMgaW50CmlucHV0X2J1ZmZlcl9wZWVrYyhJbnB1dEJ1ZmZlciogaW4sIHNpemVfdCogbGVucCkgewogIGNvbnN0IHVpbnQ4X3QgKnBvcywgKmVuZCwgKm5leHQ7CiAgaW50IGNwOwogIHBvcyA9IGlucHV0X2J1ZmZlcl9kYXRhKGluKSArIGluLT5wb3M7CiAgZW5kID0gaW5wdXRfYnVmZmVyX2RhdGEoaW4pICsgaW5wdXRfYnVmZmVyX2xlbmd0aChpbik7CiAgY3AgPSB1bmljb2RlX2Zyb21fdXRmOChwb3MsIGVuZCAtIHBvcywgJm5leHQpOwogIGlmKGxlbnApCiAgICAqbGVucCA9IG5leHQgLSBwb3M7CgogIHJldHVybiBjcDsKfQoKc3RhdGljIGlubGluZSBpbnQKaW5wdXRfYnVmZmVyX2dldGMoSW5wdXRCdWZmZXIqIGluKSB7CiAgc2l6ZV90IG47CiAgaW50IHJldDsKICByZXQgPSBpbnB1dF9idWZmZXJfcGVla2MoaW4sICZuKTsKICBpbi0+cG9zICs9IG47CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSB1aW50OF90KgppbnB1dF9idWZmZXJfYmVnaW4oY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIGlucHV0X2J1ZmZlcl9kYXRhKGluKTsKfQpzdGF0aWMgaW5saW5lIHVpbnQ4X3QqCmlucHV0X2J1ZmZlcl9lbmQoY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIGlucHV0X2J1ZmZlcl9kYXRhKGluKSArIGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pOwp9CnN0YXRpYyBpbmxpbmUgQk9PTAppbnB1dF9idWZmZXJfZW9mKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbi0+cG9zID09IGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pOwp9CnN0YXRpYyBpbmxpbmUgc2l6ZV90CmlucHV0X2J1ZmZlcl9yZW1haW4oY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pIC0gaW4tPnBvczsKfQoKT2Zmc2V0TGVuZ3RoIGpzX29mZnNldF9sZW5ndGgoSlNDb250ZXh0KiwgaW50NjRfdCBzaXplLCBpbnQgYXJnYywgSlNWYWx1ZSBhcmd2W10pOwoKI2VuZGlmIC8qIGRlZmluZWQoQlVGRkVSX1VUSUxTKSAqLwoAAAAAAAAAACgeAAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAADuFAAAAAAAAP0UAAAAAAAAAAAAAAAA8L8"
				],
				[
					7,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAoHgAAI2lmbmRlZiBCVUZGRVJfVVRJTFNfSAojZGVmaW5lIEJVRkZFUl9VVElMU19ICgojaW5jbHVkZSA8cXVpY2tqcy5oPgojaW5jbHVkZSA8Y3V0aWxzLmg+CiNpbmNsdWRlIDxzdGRhcmcuaD4KCiNpbmNsdWRlICJjaGFyLXV0aWxzLmgiCgojaWZuZGVmIE1BWF9OVU0KI2RlZmluZSBNQVhfTlVNKGEsIGIpICgoYSkgPiAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgojaWZuZGVmIE1JTl9OVU0KI2RlZmluZSBNSU5fTlVNKGEsIGIpICgoYSkgPCAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgoKc2l6ZV90IGFuc2lfbGVuZ3RoKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV9za2lwKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV90cnVuY2F0ZShjb25zdCBjaGFyKiwgc2l6ZV90LCBzaXplX3QgbGltaXQpOwppbnQ2NF90IGFycmF5X3NlYXJjaCh2b2lkKiwgc2l6ZV90LCBzaXplX3QgZWxzeiwgdm9pZCogbmVlZGxlKTsKY2hhciogc3RyX2VzY2FwZShjb25zdCBjaGFyKik7CmNoYXIqIGJ5dGVfZXNjYXBlKGNvbnN0IHZvaWQqLCBzaXplX3QpOwpzaXplX3QgYnl0ZV9maW5kYihjb25zdCB2b2lkKiwgc2l6ZV90LCBjb25zdCB2b2lkKiB3aGF0LCBzaXplX3Qgd2xlbik7CnNpemVfdCBieXRlX2ZpbmRzKGNvbnN0IHZvaWQqLCBzaXplX3QsIGNvbnN0IGNoYXIqIHdoYXQpOwpzaXplX3QgYnl0ZV9lcXVhbChjb25zdCB2b2lkKiBzLCBzaXplX3QgbiwgY29uc3Qgdm9pZCogdCk7CmNoYXIqIGRidWZfYXRfbihjb25zdCBEeW5CdWYqLCBzaXplX3QsIHNpemVfdCogbiwgY2hhciBzZXApOwpjb25zdCBjaGFyKiBkYnVmX2xhc3RfbGluZShEeW5CdWYqLCBzaXplX3QqKTsKaW50IGRidWZfcHJlcGVuZChEeW5CdWYqLCBjb25zdCB1aW50OF90Kiwgc2l6ZV90IGxlbik7CnZvaWQgZGJ1Zl9wdXRfY29sb3JzdHIoRHluQnVmKiwgY29uc3QgY2hhciosIGNvbnN0IGNoYXIqIGNvbG9yLCBpbnQgd2l0aF9jb2xvcik7CnZvaWQgZGJ1Zl9wdXRfZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkX3RhYmxlKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBjb25zdCBjaGFyIHRhYmxlWzI1Nl0pOwp2b2lkIGRidWZfcHV0X3VuZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuKTsKdm9pZCBkYnVmX3B1dF92YWx1ZShEeW5CdWYqLCBKU0NvbnRleHQqLCBKU1ZhbHVlIHZhbHVlKTsKaW50IGRidWZfcmVzZXJ2ZV9zdGFydChEeW5CdWYqLCBzaXplX3QpOwpzaXplX3QgZGJ1Zl90b2tlbl9wb3AoRHluQnVmKiwgY2hhcik7CnNpemVfdCBkYnVmX3Rva2VuX3B1c2goRHluQnVmKiwgY29uc3QgY2hhciosIHNpemVfdCBsZW4sIGNoYXIgZGVsaW0pOwpKU1ZhbHVlIGRidWZfdG9zdHJpbmdfZnJlZShEeW5CdWYqLCBKU0NvbnRleHQqKTsKc3NpemVfdCBkYnVmX2xvYWQoRHluQnVmKiwgY29uc3QgY2hhciopOwoKc3RhdGljIGlubGluZSBpbnQKZGJ1Zl9wdXRtKER5bkJ1ZiogZGIsIC4uLikgewogIGludCByID0gMDsKICB2YV9saXN0IGE7CiAgY29uc3QgY2hhciogczsKICB2YV9zdGFydChhLCBkYik7CiAgd2hpbGUoKHMgPSB2YV9hcmcoYSwgY2hhciopKSkKICAgIGlmKGRidWZfcHV0c3RyKGRiLCBzKSkKICAgICAgcmV0dXJuIC0xOwogIHZhX2VuZChhKTsKICByZXR1cm4gcjsKfQoKI2RlZmluZSBkYnVmX2FwcGVuZChkLCB4LCBuKSBkYnVmX3B1dCgoZCksIChjb25zdCB1aW50OF90KikoeCksIChuKSkKCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfY291bnQoRHluQnVmKiBkYiwgaW50IGNoKSB7CiAgcmV0dXJuIGJ5dGVfY291bnQoZGItPmJ1ZiwgZGItPnNpemUsIGNoKTsKfQoKc3RhdGljIGlubGluZSB2b2lkCmRidWZfMChEeW5CdWYqIGRiKSB7CiAgZGJ1Zl9wdXRjKGRiLCAnXDAnKTsKICBkYi0+c2l6ZS0tOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQKZGJ1Zl96ZXJvKER5bkJ1ZiogZGIpIHsKICBkYnVmX3JlYWxsb2MoZGIsIDApOwp9CgpzdGF0aWMgaW5saW5lIGludDMyX3QKZGJ1Zl9nZXRfY29sdW1uKER5bkJ1ZiogZGIpIHsKICBzaXplX3QgbGVuOwogIGNvbnN0IGNoYXIqIHN0cjsKICBpZihkYi0+c2l6ZSkgewogICAgc3RyID0gZGJ1Zl9sYXN0X2xpbmUoZGIsICZsZW4pOwogICAgcmV0dXJuIGFuc2lfbGVuZ3RoKHN0ciwgbGVuKTsKICB9CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfYml0ZmxhZ3MoRHluQnVmKiBkYiwgdWludDMyX3QgYml0cywgY29uc3QgY2hhciogY29uc3QgbmFtZXNbXSkgewogIHNpemVfdCBpLCBuID0gMDsKICBmb3IoaSA9IDA7IGkgPCBzaXplb2YoYml0cykgKiA4OyBpKyspIHsKICAgIGlmKGJpdHMgJiAoMSA8PCBpKSkgewogICAgICBzaXplX3QgbGVuID0gc3RybGVuKG5hbWVzW2ldKTsKICAgICAgaWYobikgewogICAgICAgIG4rKzsKICAgICAgICBkYnVmX3B1dHN0cihkYiwgInwiKTsKICAgICAgfQogICAgICBkYnVmX2FwcGVuZChkYiwgbmFtZXNbaV0sIGxlbik7CiAgICAgIG4gKz0gbGVuOwogICAgfQogIH0KICByZXR1cm4gbjsKfQoKc3RydWN0IG1lbW9yeV9ibG9jazsKc3RydWN0IHBvaW50ZXJfcmFuZ2U7CnN0cnVjdCBvZmZzZXRfbGVuZ3RoOwoKdHlwZWRlZiBzdHJ1Y3QgbWVtb3J5X2Jsb2NrIHsKICB1aW50OF90KiBiYXNlOwogIHNpemVfdCBzaXplOwp9IE1lbW9yeUJsb2NrOwoKc3RhdGljIGlubGluZSB2b2lkCmJsb2NrX2luaXQoTWVtb3J5QmxvY2sqIG1iKSB7CiAgbWItPmJhc2UgPSAwOwogIG1iLT5zaXplID0gMDsKfQoKc3RhdGljIGlubGluZSB2b2lkKgpibG9ja19kYXRhKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+YmFzZTsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKYmxvY2tfbGVuZ3RoKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+c2l6ZTsKfQoKCnN0YXRpYyBpbmxpbmUgQk9PTApibG9ja19hcnJheWJ1ZmZlcihNZW1vcnlCbG9jayogbWIsIEpTVmFsdWVDb25zdCBhYiwgSlNDb250ZXh0KiBjdHgpIHsKICBtYi0+YmFzZSA9IEpTX0dldEFycmF5QnVmZmVyKGN0eCwgJm1iLT5zaXplLCBhYik7Cn0KCnR5cGVkZWYgc3RydWN0IHBvaW50ZXJfcmFuZ2UgewogIHVpbnQ4X3QgKnN0YXJ0LCAqZW5kOwp9IFBvaW50ZXJSYW5nZTsKCnN0YXRpYyBpbmxpbmUgdm9pZApyYW5nZV9pbml0KFBvaW50ZXJSYW5nZSogcHIpIHsKICBwci0+ZW5kID0gcHItPnN0YXJ0ID0gMDsKfQoKc3RhdGljIGlubGluZSBQb2ludGVyUmFuZ2UKcmFuZ2VfZnJvbShjb25zdCBNZW1vcnlCbG9jayogbWIpIHsKICByZXR1cm4gKFBvaW50ZXJSYW5nZSl7bWItPmJhc2UsIG1iLT5iYXNlICsgbWItPnNpemV9Owp9Cgp0eXBlZGVmIHN0cnVjdCBvZmZzZXRfbGVuZ3RoIHsKICBpbnQ2NF90IG9mZnNldCwgbGVuZ3RoOwp9IE9mZnNldExlbmd0aDsKCnN0YXRpYyBpbmxpbmUgdm9pZApvZmZzZXRfaW5pdChPZmZzZXRMZW5ndGgqIG9sKSB7CiAgb2wtPm9mZnNldCA9IDA7CiAgb2wtPmxlbmd0aCA9IElOVDY0X01BWDsKfQoKc3RhdGljIGlubGluZSBCT09MCm9mZnNldF9pc19kZWZhdWx0KGNvbnN0IE9mZnNldExlbmd0aCogb2wpIHsKICByZXR1cm4gb2wtPm9mZnNldCA9PSAwICYmIG9sLT5sZW5ndGggPT0gSU5UNjRfTUFYOwp9CgpzdGF0aWMgaW5saW5lIHVpbnQ4X3QqCm9mZnNldF9kYXRhKGNvbnN0IE9mZnNldExlbmd0aCogb2wsIGNvbnN0IHZvaWQqIHgpIHsKICByZXR1cm4gKHVpbnQ4X3QqKXggKyBvbC0+b2Zmc2V0Owp9CgpzdGF0aWMgaW5saW5lIHNpemVfdApvZmZzZXRfc2l6ZShjb25zdCBPZmZzZXRMZW5ndGgqIG9sLCBzaXplX3QgbikgewogIHJldHVybiBNSU5fTlVNKG9sLT5sZW5ndGgsIG4gLSBvbC0+b2Zmc2V0KTsKfQoKc3RhdGljIGlubGluZSBNZW1vcnlCbG9jawpvZmZzZXRfYmxvY2soY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCwgY29uc3Qgdm9pZCogeCwgc2l6ZV90IG4pIHsKICByZXR1cm4gKE1lbW9yeUJsb2NrKXtvZmZzZXRfZGF0YShvbCwgeCksIG9mZnNldF9zaXplKG9sLCBuKX07Cn0KCnN0YXRpYyBpbmxpbmUgUG9pbnRlclJhbmdlCm9mZnNldF9yYW5nZShjb25zdCBPZmZzZXRMZW5ndGgqIG9sLCBjb25zdCB2b2lkKiB4LCBzaXplX3QgbikgewogIE1lbW9yeUJsb2NrIG1iID0gb2Zmc2V0X2Jsb2NrKG9sLCB4LCBuKTsKICByZXR1cm4gcmFuZ2VfZnJvbSgmbWIpOwp9CgpzdGF0aWMgaW5saW5lIE9mZnNldExlbmd0aApvZmZzZXRfc2xpY2UoY29uc3QgT2Zmc2V0TGVuZ3RoIG9sLCBpbnQ2NF90IHN0YXJ0LCBpbnQ2NF90IGVuZCkgewogIGlmKHN0YXJ0IDwgMCkKICAgIHN0YXJ0ID0gb2wubGVuZ3RoICsgKHN0YXJ0ICUgb2wubGVuZ3RoKTsKICBlbHNlIGlmKHN0YXJ0ID4gb2wubGVuZ3RoKQogICAgc3RhcnQgPSBvbC5sZW5ndGg7CiAgaWYoZW5kIDwgMCkKICAgIGVuZCA9IG9sLmxlbmd0aCArIChlbmQgJSBvbC5sZW5ndGgpOwogIGVsc2UgaWYoZW5kID4gb2wubGVuZ3RoKQogICAgZW5kID0gb2wubGVuZ3RoOwoKICByZXR1cm4gKE9mZnNldExlbmd0aCl7c3RhcnQsIGVuZCAtIHN0YXJ0fTsKfQoKc3RhdGljIGlubGluZSBPZmZzZXRMZW5ndGgKb2Zmc2V0X29mZnNldChjb25zdCBPZmZzZXRMZW5ndGgqIG9sLCBjb25zdCBPZmZzZXRMZW5ndGgqIGJ5KSB7CiAgT2Zmc2V0TGVuZ3RoIHJldDsKICByZXQub2Zmc2V0ID0gb2wtPm9mZnNldCArIGJ5LT5vZmZzZXQ7CiAgcmV0Lmxlbmd0aCA9IE1JTl9OVU0oYnktPmxlbmd0aCwgb2wtPmxlbmd0aCAtIGJ5LT5vZmZzZXQpOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgTWVtb3J5QmxvY2sKYmxvY2tfcmFuZ2UoY29uc3QgTWVtb3J5QmxvY2sqIG1iLCBzdHJ1Y3Qgb2Zmc2V0X2xlbmd0aCogcmFuZ2UpIHsKICBNZW1vcnlCbG9jayByZXQ7CiAgcmV0LmJhc2UgPSBtYi0+YmFzZSArIHJhbmdlLT5vZmZzZXQ7CiAgcmV0LnNpemUgPSBNSU5fTlVNKHJhbmdlLT5sZW5ndGgsIG1iLT5zaXplIC0gcmFuZ2UtPm9mZnNldCk7CiAgcmV0dXJuIHJldDsKfQoKdHlwZWRlZiBzdHJ1Y3QgSW5wdXRCdWZmZXIgewogIHVpbnQ4X3QqIGRhdGE7CiAgc2l6ZV90IHBvcywgc2l6ZTsKICB2b2lkICgqZnJlZSkoSlNDb250ZXh0KiwgY29uc3QgY2hhciosIEpTVmFsdWUpOwogIEpTVmFsdWUgdmFsdWU7CiAgT2Zmc2V0TGVuZ3RoIHJhbmdlOwp9IElucHV0QnVmZmVyOwoKc3RhdGljIGlubGluZSB2b2lkCmlucHV0X2J1ZmZlcl9mcmVlX2RlZmF1bHQoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIHN0ciwgSlNWYWx1ZSB2YWwpIHsKICBpZihKU19Jc1N0cmluZyh2YWwpKQogICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBzdHIpOwoKICBpZighSlNfSXNVbmRlZmluZWQodmFsKSkKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbCk7Cn0KCklucHV0QnVmZmVyIGpzX2lucHV0X2J1ZmZlcihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKSW5wdXRCdWZmZXIganNfaW5wdXRfY2hhcnMoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CklucHV0QnVmZmVyIGlucHV0X2J1ZmZlcl9jbG9uZShjb25zdCBJbnB1dEJ1ZmZlciogaW4sIEpTQ29udGV4dCogY3R4KTsKQk9PTCBpbnB1dF9idWZmZXJfdmFsaWQoY29uc3QgSW5wdXRCdWZmZXIqIGluKTsKdm9pZCBpbnB1dF9idWZmZXJfZHVtcChjb25zdCBJbnB1dEJ1ZmZlciogaW4sIER5bkJ1ZiogZGIpOwp2b2lkIGlucHV0X2J1ZmZlcl9mcmVlKElucHV0QnVmZmVyKiBpbiwgSlNDb250ZXh0KiBjdHgpOwoKc3RhdGljIGlubGluZSB1aW50OF90KgppbnB1dF9idWZmZXJfZGF0YShjb25zdCBJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gaW4tPmRhdGEgKyBpbi0+cmFuZ2Uub2Zmc2V0Owp9CgpzdGF0aWMgaW5saW5lIHNpemVfdAppbnB1dF9idWZmZXJfbGVuZ3RoKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBNSU5fTlVNKGluLT5yYW5nZS5sZW5ndGgsIGluLT5zaXplKTsKfQoKc3RhdGljIGlubGluZSBNZW1vcnlCbG9jawppbnB1dF9idWZmZXJfYmxvY2soSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIChNZW1vcnlCbG9jayl7aW5wdXRfYnVmZmVyX2RhdGEoaW4pLCBpbnB1dF9idWZmZXJfbGVuZ3RoKGluKX07Cn0KCnN0YXRpYyBpbmxpbmUgSW5wdXRCdWZmZXIKaW5wdXRfYnVmZmVyX29mZnNldChJbnB1dEJ1ZmZlciBpbiwgT2Zmc2V0TGVuZ3RoIG9mZikgewogIElucHV0QnVmZmVyIHJldCA9IGluOwoKICByZXQuZGF0YSArPSBvZmYub2Zmc2V0OwogIHJldC5zaXplIC09IG9mZi5vZmZzZXQ7CgogIGlmKHJldC5zaXplID4gb2ZmLmxlbmd0aCkKICAgIHJldC5zaXplID0gb2ZmLmxlbmd0aDsKCiAgcmV0dXJuIHJldDsKfQoKY29uc3QgdWludDhfdCogaW5wdXRfYnVmZmVyX2dldChJbnB1dEJ1ZmZlciogaW4sIHNpemVfdCogbGVucCk7CmNvbnN0IHVpbnQ4X3QqIGlucHV0X2J1ZmZlcl9wZWVrKElucHV0QnVmZmVyKiBpbiwgc2l6ZV90KiBsZW5wKTsKY29uc3QgY2hhciogaW5wdXRfYnVmZmVyX2N1cnJlbnRsaW5lKElucHV0QnVmZmVyKiwgc2l6ZV90KiBsZW4pOwpzaXplX3QgaW5wdXRfYnVmZmVyX2NvbHVtbihJbnB1dEJ1ZmZlciosIHNpemVfdCogbGVuKTsKCnN0YXRpYyBpbnQKaW5wdXRfYnVmZmVyX3BlZWtjKElucHV0QnVmZmVyKiBpbiwgc2l6ZV90KiBsZW5wKSB7CiAgY29uc3QgdWludDhfdCAqcG9zLCAqZW5kLCAqbmV4dDsKICBpbnQgY3A7CiAgcG9zID0gaW5wdXRfYnVmZmVyX2RhdGEoaW4pICsgaW4tPnBvczsKICBlbmQgPSBpbnB1dF9idWZmZXJfZGF0YShpbikgKyBpbnB1dF9idWZmZXJfbGVuZ3RoKGluKTsKICBjcCA9IHVuaWNvZGVfZnJvbV91dGY4KHBvcywgZW5kIC0gcG9zLCAmbmV4dCk7CiAgaWYobGVucCkKICAgICpsZW5wID0gbmV4dCAtIHBvczsKCiAgcmV0dXJuIGNwOwp9CgpzdGF0aWMgaW5saW5lIGludAppbnB1dF9idWZmZXJfZ2V0YyhJbnB1dEJ1ZmZlciogaW4pIHsKICBzaXplX3QgbjsKICBpbnQgcmV0OwogIHJldCA9IGlucHV0X2J1ZmZlcl9wZWVrYyhpbiwgJm4pOwogIGluLT5wb3MgKz0gbjsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW5saW5lIHVpbnQ4X3QqCmlucHV0X2J1ZmZlcl9iZWdpbihjb25zdCBJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gaW5wdXRfYnVmZmVyX2RhdGEoaW4pOwp9CnN0YXRpYyBpbmxpbmUgdWludDhfdCoKaW5wdXRfYnVmZmVyX2VuZChjb25zdCBJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gaW5wdXRfYnVmZmVyX2RhdGEoaW4pICsgaW5wdXRfYnVmZmVyX2xlbmd0aChpbik7Cn0Kc3RhdGljIGlubGluZSBCT09MCmlucHV0X2J1ZmZlcl9lb2YoY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIGluLT5wb3MgPT0gaW5wdXRfYnVmZmVyX2xlbmd0aChpbik7Cn0Kc3RhdGljIGlubGluZSBzaXplX3QKaW5wdXRfYnVmZmVyX3JlbWFpbihjb25zdCBJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gaW5wdXRfYnVmZmVyX2xlbmd0aChpbikgLSBpbi0+cG9zOwp9CgpPZmZzZXRMZW5ndGgganNfb2Zmc2V0X2xlbmd0aChKU0NvbnRleHQqLCBpbnQ2NF90IHNpemUsIGludCBhcmdjLCBKU1ZhbHVlIGFyZ3ZbXSk7CgojZW5kaWYgLyogZGVmaW5lZChCVUZGRVJfVVRJTFMpICovCgAAAAAAAAAAMx4AAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAADuFAAAAAAAAP0UAAAAAAAAAAAAAAAA8L8"
				],
				[
					8,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAzHgAAI2lmbmRlZiBCVUZGRVJfVVRJTFNfSAojZGVmaW5lIEJVRkZFUl9VVElMU19ICgojaW5jbHVkZSA8cXVpY2tqcy5oPgojaW5jbHVkZSA8Y3V0aWxzLmg+CiNpbmNsdWRlIDxzdGRhcmcuaD4KCiNpbmNsdWRlICJjaGFyLXV0aWxzLmgiCgojaWZuZGVmIE1BWF9OVU0KI2RlZmluZSBNQVhfTlVNKGEsIGIpICgoYSkgPiAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgojaWZuZGVmIE1JTl9OVU0KI2RlZmluZSBNSU5fTlVNKGEsIGIpICgoYSkgPCAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgoKc2l6ZV90IGFuc2lfbGVuZ3RoKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV9za2lwKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV90cnVuY2F0ZShjb25zdCBjaGFyKiwgc2l6ZV90LCBzaXplX3QgbGltaXQpOwppbnQ2NF90IGFycmF5X3NlYXJjaCh2b2lkKiwgc2l6ZV90LCBzaXplX3QgZWxzeiwgdm9pZCogbmVlZGxlKTsKY2hhciogc3RyX2VzY2FwZShjb25zdCBjaGFyKik7CmNoYXIqIGJ5dGVfZXNjYXBlKGNvbnN0IHZvaWQqLCBzaXplX3QpOwpzaXplX3QgYnl0ZV9maW5kYihjb25zdCB2b2lkKiwgc2l6ZV90LCBjb25zdCB2b2lkKiB3aGF0LCBzaXplX3Qgd2xlbik7CnNpemVfdCBieXRlX2ZpbmRzKGNvbnN0IHZvaWQqLCBzaXplX3QsIGNvbnN0IGNoYXIqIHdoYXQpOwpzaXplX3QgYnl0ZV9lcXVhbChjb25zdCB2b2lkKiBzLCBzaXplX3QgbiwgY29uc3Qgdm9pZCogdCk7CmNoYXIqIGRidWZfYXRfbihjb25zdCBEeW5CdWYqLCBzaXplX3QsIHNpemVfdCogbiwgY2hhciBzZXApOwpjb25zdCBjaGFyKiBkYnVmX2xhc3RfbGluZShEeW5CdWYqLCBzaXplX3QqKTsKaW50IGRidWZfcHJlcGVuZChEeW5CdWYqLCBjb25zdCB1aW50OF90Kiwgc2l6ZV90IGxlbik7CnZvaWQgZGJ1Zl9wdXRfY29sb3JzdHIoRHluQnVmKiwgY29uc3QgY2hhciosIGNvbnN0IGNoYXIqIGNvbG9yLCBpbnQgd2l0aF9jb2xvcik7CnZvaWQgZGJ1Zl9wdXRfZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkX3RhYmxlKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBjb25zdCBjaGFyIHRhYmxlWzI1Nl0pOwp2b2lkIGRidWZfcHV0X3VuZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuKTsKdm9pZCBkYnVmX3B1dF92YWx1ZShEeW5CdWYqLCBKU0NvbnRleHQqLCBKU1ZhbHVlIHZhbHVlKTsKaW50IGRidWZfcmVzZXJ2ZV9zdGFydChEeW5CdWYqLCBzaXplX3QpOwpzaXplX3QgZGJ1Zl90b2tlbl9wb3AoRHluQnVmKiwgY2hhcik7CnNpemVfdCBkYnVmX3Rva2VuX3B1c2goRHluQnVmKiwgY29uc3QgY2hhciosIHNpemVfdCBsZW4sIGNoYXIgZGVsaW0pOwpKU1ZhbHVlIGRidWZfdG9zdHJpbmdfZnJlZShEeW5CdWYqLCBKU0NvbnRleHQqKTsKc3NpemVfdCBkYnVmX2xvYWQoRHluQnVmKiwgY29uc3QgY2hhciopOwoKc3RhdGljIGlubGluZSBpbnQKZGJ1Zl9wdXRtKER5bkJ1ZiogZGIsIC4uLikgewogIGludCByID0gMDsKICB2YV9saXN0IGE7CiAgY29uc3QgY2hhciogczsKICB2YV9zdGFydChhLCBkYik7CiAgd2hpbGUoKHMgPSB2YV9hcmcoYSwgY2hhciopKSkKICAgIGlmKGRidWZfcHV0c3RyKGRiLCBzKSkKICAgICAgcmV0dXJuIC0xOwogIHZhX2VuZChhKTsKICByZXR1cm4gcjsKfQoKI2RlZmluZSBkYnVmX2FwcGVuZChkLCB4LCBuKSBkYnVmX3B1dCgoZCksIChjb25zdCB1aW50OF90KikoeCksIChuKSkKCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfY291bnQoRHluQnVmKiBkYiwgaW50IGNoKSB7CiAgcmV0dXJuIGJ5dGVfY291bnQoZGItPmJ1ZiwgZGItPnNpemUsIGNoKTsKfQoKc3RhdGljIGlubGluZSB2b2lkCmRidWZfMChEeW5CdWYqIGRiKSB7CiAgZGJ1Zl9wdXRjKGRiLCAnXDAnKTsKICBkYi0+c2l6ZS0tOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQKZGJ1Zl96ZXJvKER5bkJ1ZiogZGIpIHsKICBkYnVmX3JlYWxsb2MoZGIsIDApOwp9CgpzdGF0aWMgaW5saW5lIGludDMyX3QKZGJ1Zl9nZXRfY29sdW1uKER5bkJ1ZiogZGIpIHsKICBzaXplX3QgbGVuOwogIGNvbnN0IGNoYXIqIHN0cjsKICBpZihkYi0+c2l6ZSkgewogICAgc3RyID0gZGJ1Zl9sYXN0X2xpbmUoZGIsICZsZW4pOwogICAgcmV0dXJuIGFuc2lfbGVuZ3RoKHN0ciwgbGVuKTsKICB9CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfYml0ZmxhZ3MoRHluQnVmKiBkYiwgdWludDMyX3QgYml0cywgY29uc3QgY2hhciogY29uc3QgbmFtZXNbXSkgewogIHNpemVfdCBpLCBuID0gMDsKICBmb3IoaSA9IDA7IGkgPCBzaXplb2YoYml0cykgKiA4OyBpKyspIHsKICAgIGlmKGJpdHMgJiAoMSA8PCBpKSkgewogICAgICBzaXplX3QgbGVuID0gc3RybGVuKG5hbWVzW2ldKTsKICAgICAgaWYobikgewogICAgICAgIG4rKzsKICAgICAgICBkYnVmX3B1dHN0cihkYiwgInwiKTsKICAgICAgfQogICAgICBkYnVmX2FwcGVuZChkYiwgbmFtZXNbaV0sIGxlbik7CiAgICAgIG4gKz0gbGVuOwogICAgfQogIH0KICByZXR1cm4gbjsKfQoKc3RydWN0IG1lbW9yeV9ibG9jazsKc3RydWN0IHBvaW50ZXJfcmFuZ2U7CnN0cnVjdCBvZmZzZXRfbGVuZ3RoOwoKdHlwZWRlZiBzdHJ1Y3QgbWVtb3J5X2Jsb2NrIHsKICB1aW50OF90KiBiYXNlOwogIHNpemVfdCBzaXplOwp9IE1lbW9yeUJsb2NrOwoKc3RhdGljIGlubGluZSB2b2lkCmJsb2NrX2luaXQoTWVtb3J5QmxvY2sqIG1iKSB7CiAgbWItPmJhc2UgPSAwOwogIG1iLT5zaXplID0gMDsKfQoKc3RhdGljIGlubGluZSB2b2lkKgpibG9ja19kYXRhKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+YmFzZTsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKYmxvY2tfbGVuZ3RoKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+c2l6ZTsKfQoKCnN0YXRpYyBpbmxpbmUgQk9PTApibG9ja19hcnJheWJ1ZmZlcihNZW1vcnlCbG9jayogbWIsIEpTVmFsdWVDb25zdCBhYiwgSlNDb250ZXh0KiBjdHgpIHsKICByZXR1cm4gISEobWItPmJhc2UgPSBKU19HZXRBcnJheUJ1ZmZlcihjdHgsICZtYi0+c2l6ZSwgYWIpKTsKfQoKdHlwZWRlZiBzdHJ1Y3QgcG9pbnRlcl9yYW5nZSB7CiAgdWludDhfdCAqc3RhcnQsICplbmQ7Cn0gUG9pbnRlclJhbmdlOwoKc3RhdGljIGlubGluZSB2b2lkCnJhbmdlX2luaXQoUG9pbnRlclJhbmdlKiBwcikgewogIHByLT5lbmQgPSBwci0+c3RhcnQgPSAwOwp9CgpzdGF0aWMgaW5saW5lIFBvaW50ZXJSYW5nZQpyYW5nZV9mcm9tKGNvbnN0IE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiAoUG9pbnRlclJhbmdlKXttYi0+YmFzZSwgbWItPmJhc2UgKyBtYi0+c2l6ZX07Cn0KCnR5cGVkZWYgc3RydWN0IG9mZnNldF9sZW5ndGggewogIGludDY0X3Qgb2Zmc2V0LCBsZW5ndGg7Cn0gT2Zmc2V0TGVuZ3RoOwoKc3RhdGljIGlubGluZSB2b2lkCm9mZnNldF9pbml0KE9mZnNldExlbmd0aCogb2wpIHsKICBvbC0+b2Zmc2V0ID0gMDsKICBvbC0+bGVuZ3RoID0gSU5UNjRfTUFYOwp9CgpzdGF0aWMgaW5saW5lIEJPT0wKb2Zmc2V0X2lzX2RlZmF1bHQoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCkgewogIHJldHVybiBvbC0+b2Zmc2V0ID09IDAgJiYgb2wtPmxlbmd0aCA9PSBJTlQ2NF9NQVg7Cn0KCnN0YXRpYyBpbmxpbmUgdWludDhfdCoKb2Zmc2V0X2RhdGEoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCwgY29uc3Qgdm9pZCogeCkgewogIHJldHVybiAodWludDhfdCopeCArIG9sLT5vZmZzZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90Cm9mZnNldF9zaXplKGNvbnN0IE9mZnNldExlbmd0aCogb2wsIHNpemVfdCBuKSB7CiAgcmV0dXJuIE1JTl9OVU0ob2wtPmxlbmd0aCwgbiAtIG9sLT5vZmZzZXQpOwp9CgpzdGF0aWMgaW5saW5lIE1lbW9yeUJsb2NrCm9mZnNldF9ibG9jayhjb25zdCBPZmZzZXRMZW5ndGgqIG9sLCBjb25zdCB2b2lkKiB4LCBzaXplX3QgbikgewogIHJldHVybiAoTWVtb3J5QmxvY2spe29mZnNldF9kYXRhKG9sLCB4KSwgb2Zmc2V0X3NpemUob2wsIG4pfTsKfQoKc3RhdGljIGlubGluZSBQb2ludGVyUmFuZ2UKb2Zmc2V0X3JhbmdlKGNvbnN0IE9mZnNldExlbmd0aCogb2wsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBuKSB7CiAgTWVtb3J5QmxvY2sgbWIgPSBvZmZzZXRfYmxvY2sob2wsIHgsIG4pOwogIHJldHVybiByYW5nZV9mcm9tKCZtYik7Cn0KCnN0YXRpYyBpbmxpbmUgT2Zmc2V0TGVuZ3RoCm9mZnNldF9zbGljZShjb25zdCBPZmZzZXRMZW5ndGggb2wsIGludDY0X3Qgc3RhcnQsIGludDY0X3QgZW5kKSB7CiAgaWYoc3RhcnQgPCAwKQogICAgc3RhcnQgPSBvbC5sZW5ndGggKyAoc3RhcnQgJSBvbC5sZW5ndGgpOwogIGVsc2UgaWYoc3RhcnQgPiBvbC5sZW5ndGgpCiAgICBzdGFydCA9IG9sLmxlbmd0aDsKICBpZihlbmQgPCAwKQogICAgZW5kID0gb2wubGVuZ3RoICsgKGVuZCAlIG9sLmxlbmd0aCk7CiAgZWxzZSBpZihlbmQgPiBvbC5sZW5ndGgpCiAgICBlbmQgPSBvbC5sZW5ndGg7CgogIHJldHVybiAoT2Zmc2V0TGVuZ3RoKXtzdGFydCwgZW5kIC0gc3RhcnR9Owp9CgpzdGF0aWMgaW5saW5lIE9mZnNldExlbmd0aApvZmZzZXRfb2Zmc2V0KGNvbnN0IE9mZnNldExlbmd0aCogb2wsIGNvbnN0IE9mZnNldExlbmd0aCogYnkpIHsKICBPZmZzZXRMZW5ndGggcmV0OwogIHJldC5vZmZzZXQgPSBvbC0+b2Zmc2V0ICsgYnktPm9mZnNldDsKICByZXQubGVuZ3RoID0gTUlOX05VTShieS0+bGVuZ3RoLCBvbC0+bGVuZ3RoIC0gYnktPm9mZnNldCk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBNZW1vcnlCbG9jawpibG9ja19yYW5nZShjb25zdCBNZW1vcnlCbG9jayogbWIsIHN0cnVjdCBvZmZzZXRfbGVuZ3RoKiByYW5nZSkgewogIE1lbW9yeUJsb2NrIHJldDsKICByZXQuYmFzZSA9IG1iLT5iYXNlICsgcmFuZ2UtPm9mZnNldDsKICByZXQuc2l6ZSA9IE1JTl9OVU0ocmFuZ2UtPmxlbmd0aCwgbWItPnNpemUgLSByYW5nZS0+b2Zmc2V0KTsKICByZXR1cm4gcmV0Owp9Cgp0eXBlZGVmIHN0cnVjdCBJbnB1dEJ1ZmZlciB7CiAgdWludDhfdCogZGF0YTsKICBzaXplX3QgcG9zLCBzaXplOwogIHZvaWQgKCpmcmVlKShKU0NvbnRleHQqLCBjb25zdCBjaGFyKiwgSlNWYWx1ZSk7CiAgSlNWYWx1ZSB2YWx1ZTsKICBPZmZzZXRMZW5ndGggcmFuZ2U7Cn0gSW5wdXRCdWZmZXI7CgpzdGF0aWMgaW5saW5lIHZvaWQKaW5wdXRfYnVmZmVyX2ZyZWVfZGVmYXVsdChKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogc3RyLCBKU1ZhbHVlIHZhbCkgewogIGlmKEpTX0lzU3RyaW5nKHZhbCkpCiAgICBKU19GcmVlQ1N0cmluZyhjdHgsIHN0cik7CgogIGlmKCFKU19Jc1VuZGVmaW5lZCh2YWwpKQogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsKTsKfQoKSW5wdXRCdWZmZXIganNfaW5wdXRfYnVmZmVyKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwpJbnB1dEJ1ZmZlciBqc19pbnB1dF9jaGFycyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKSW5wdXRCdWZmZXIgaW5wdXRfYnVmZmVyX2Nsb25lKGNvbnN0IElucHV0QnVmZmVyKiBpbiwgSlNDb250ZXh0KiBjdHgpOwpCT09MIGlucHV0X2J1ZmZlcl92YWxpZChjb25zdCBJbnB1dEJ1ZmZlciogaW4pOwp2b2lkIGlucHV0X2J1ZmZlcl9kdW1wKGNvbnN0IElucHV0QnVmZmVyKiBpbiwgRHluQnVmKiBkYik7CnZvaWQgaW5wdXRfYnVmZmVyX2ZyZWUoSW5wdXRCdWZmZXIqIGluLCBKU0NvbnRleHQqIGN0eCk7CgpzdGF0aWMgaW5saW5lIHVpbnQ4X3QqCmlucHV0X2J1ZmZlcl9kYXRhKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbi0+ZGF0YSArIGluLT5yYW5nZS5vZmZzZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmlucHV0X2J1ZmZlcl9sZW5ndGgoY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIE1JTl9OVU0oaW4tPnJhbmdlLmxlbmd0aCwgaW4tPnNpemUpOwp9CgpzdGF0aWMgaW5saW5lIE1lbW9yeUJsb2NrCmlucHV0X2J1ZmZlcl9ibG9jayhJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gKE1lbW9yeUJsb2NrKXtpbnB1dF9idWZmZXJfZGF0YShpbiksIGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pfTsKfQoKc3RhdGljIGlubGluZSBJbnB1dEJ1ZmZlcgppbnB1dF9idWZmZXJfb2Zmc2V0KElucHV0QnVmZmVyIGluLCBPZmZzZXRMZW5ndGggb2ZmKSB7CiAgSW5wdXRCdWZmZXIgcmV0ID0gaW47CgogIHJldC5kYXRhICs9IG9mZi5vZmZzZXQ7CiAgcmV0LnNpemUgLT0gb2ZmLm9mZnNldDsKCiAgaWYocmV0LnNpemUgPiBvZmYubGVuZ3RoKQogICAgcmV0LnNpemUgPSBvZmYubGVuZ3RoOwoKICByZXR1cm4gcmV0Owp9Cgpjb25zdCB1aW50OF90KiBpbnB1dF9idWZmZXJfZ2V0KElucHV0QnVmZmVyKiBpbiwgc2l6ZV90KiBsZW5wKTsKY29uc3QgdWludDhfdCogaW5wdXRfYnVmZmVyX3BlZWsoSW5wdXRCdWZmZXIqIGluLCBzaXplX3QqIGxlbnApOwpjb25zdCBjaGFyKiBpbnB1dF9idWZmZXJfY3VycmVudGxpbmUoSW5wdXRCdWZmZXIqLCBzaXplX3QqIGxlbik7CnNpemVfdCBpbnB1dF9idWZmZXJfY29sdW1uKElucHV0QnVmZmVyKiwgc2l6ZV90KiBsZW4pOwoKc3RhdGljIGludAppbnB1dF9idWZmZXJfcGVla2MoSW5wdXRCdWZmZXIqIGluLCBzaXplX3QqIGxlbnApIHsKICBjb25zdCB1aW50OF90ICpwb3MsICplbmQsICpuZXh0OwogIGludCBjcDsKICBwb3MgPSBpbnB1dF9idWZmZXJfZGF0YShpbikgKyBpbi0+cG9zOwogIGVuZCA9IGlucHV0X2J1ZmZlcl9kYXRhKGluKSArIGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pOwogIGNwID0gdW5pY29kZV9mcm9tX3V0ZjgocG9zLCBlbmQgLSBwb3MsICZuZXh0KTsKICBpZihsZW5wKQogICAgKmxlbnAgPSBuZXh0IC0gcG9zOwoKICByZXR1cm4gY3A7Cn0KCnN0YXRpYyBpbmxpbmUgaW50CmlucHV0X2J1ZmZlcl9nZXRjKElucHV0QnVmZmVyKiBpbikgewogIHNpemVfdCBuOwogIGludCByZXQ7CiAgcmV0ID0gaW5wdXRfYnVmZmVyX3BlZWtjKGluLCAmbik7CiAgaW4tPnBvcyArPSBuOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgdWludDhfdCoKaW5wdXRfYnVmZmVyX2JlZ2luKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbnB1dF9idWZmZXJfZGF0YShpbik7Cn0Kc3RhdGljIGlubGluZSB1aW50OF90KgppbnB1dF9idWZmZXJfZW5kKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbnB1dF9idWZmZXJfZGF0YShpbikgKyBpbnB1dF9idWZmZXJfbGVuZ3RoKGluKTsKfQpzdGF0aWMgaW5saW5lIEJPT0wKaW5wdXRfYnVmZmVyX2VvZihjb25zdCBJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gaW4tPnBvcyA9PSBpbnB1dF9idWZmZXJfbGVuZ3RoKGluKTsKfQpzdGF0aWMgaW5saW5lIHNpemVfdAppbnB1dF9idWZmZXJfcmVtYWluKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbnB1dF9idWZmZXJfbGVuZ3RoKGluKSAtIGluLT5wb3M7Cn0KCk9mZnNldExlbmd0aCBqc19vZmZzZXRfbGVuZ3RoKEpTQ29udGV4dCosIGludDY0X3Qgc2l6ZSwgaW50IGFyZ2MsIEpTVmFsdWUgYXJndltdKTsKCiNlbmRpZiAvKiBkZWZpbmVkKEJVRkZFUl9VVElMUykgKi8KAAAAAAAAAAAzHgAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAADuFAAAAAAAAP0UAAAAAAAAAAAAAAAA8L8"
				],
				[
					9,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAzHgAAI2lmbmRlZiBCVUZGRVJfVVRJTFNfSAojZGVmaW5lIEJVRkZFUl9VVElMU19ICgojaW5jbHVkZSA8cXVpY2tqcy5oPgojaW5jbHVkZSA8Y3V0aWxzLmg+CiNpbmNsdWRlIDxzdGRhcmcuaD4KCiNpbmNsdWRlICJjaGFyLXV0aWxzLmgiCgojaWZuZGVmIE1BWF9OVU0KI2RlZmluZSBNQVhfTlVNKGEsIGIpICgoYSkgPiAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgojaWZuZGVmIE1JTl9OVU0KI2RlZmluZSBNSU5fTlVNKGEsIGIpICgoYSkgPCAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgoKc2l6ZV90IGFuc2lfbGVuZ3RoKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV9za2lwKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV90cnVuY2F0ZShjb25zdCBjaGFyKiwgc2l6ZV90LCBzaXplX3QgbGltaXQpOwppbnQ2NF90IGFycmF5X3NlYXJjaCh2b2lkKiwgc2l6ZV90LCBzaXplX3QgZWxzeiwgdm9pZCogbmVlZGxlKTsKY2hhciogc3RyX2VzY2FwZShjb25zdCBjaGFyKik7CmNoYXIqIGJ5dGVfZXNjYXBlKGNvbnN0IHZvaWQqLCBzaXplX3QpOwpzaXplX3QgYnl0ZV9maW5kYihjb25zdCB2b2lkKiwgc2l6ZV90LCBjb25zdCB2b2lkKiB3aGF0LCBzaXplX3Qgd2xlbik7CnNpemVfdCBieXRlX2ZpbmRzKGNvbnN0IHZvaWQqLCBzaXplX3QsIGNvbnN0IGNoYXIqIHdoYXQpOwpzaXplX3QgYnl0ZV9lcXVhbChjb25zdCB2b2lkKiBzLCBzaXplX3QgbiwgY29uc3Qgdm9pZCogdCk7CmNoYXIqIGRidWZfYXRfbihjb25zdCBEeW5CdWYqLCBzaXplX3QsIHNpemVfdCogbiwgY2hhciBzZXApOwpjb25zdCBjaGFyKiBkYnVmX2xhc3RfbGluZShEeW5CdWYqLCBzaXplX3QqKTsKaW50IGRidWZfcHJlcGVuZChEeW5CdWYqLCBjb25zdCB1aW50OF90Kiwgc2l6ZV90IGxlbik7CnZvaWQgZGJ1Zl9wdXRfY29sb3JzdHIoRHluQnVmKiwgY29uc3QgY2hhciosIGNvbnN0IGNoYXIqIGNvbG9yLCBpbnQgd2l0aF9jb2xvcik7CnZvaWQgZGJ1Zl9wdXRfZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkX3RhYmxlKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBjb25zdCBjaGFyIHRhYmxlWzI1Nl0pOwp2b2lkIGRidWZfcHV0X3VuZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuKTsKdm9pZCBkYnVmX3B1dF92YWx1ZShEeW5CdWYqLCBKU0NvbnRleHQqLCBKU1ZhbHVlIHZhbHVlKTsKaW50IGRidWZfcmVzZXJ2ZV9zdGFydChEeW5CdWYqLCBzaXplX3QpOwpzaXplX3QgZGJ1Zl90b2tlbl9wb3AoRHluQnVmKiwgY2hhcik7CnNpemVfdCBkYnVmX3Rva2VuX3B1c2goRHluQnVmKiwgY29uc3QgY2hhciosIHNpemVfdCBsZW4sIGNoYXIgZGVsaW0pOwpKU1ZhbHVlIGRidWZfdG9zdHJpbmdfZnJlZShEeW5CdWYqLCBKU0NvbnRleHQqKTsKc3NpemVfdCBkYnVmX2xvYWQoRHluQnVmKiwgY29uc3QgY2hhciopOwoKc3RhdGljIGlubGluZSBpbnQKZGJ1Zl9wdXRtKER5bkJ1ZiogZGIsIC4uLikgewogIGludCByID0gMDsKICB2YV9saXN0IGE7CiAgY29uc3QgY2hhciogczsKICB2YV9zdGFydChhLCBkYik7CiAgd2hpbGUoKHMgPSB2YV9hcmcoYSwgY2hhciopKSkKICAgIGlmKGRidWZfcHV0c3RyKGRiLCBzKSkKICAgICAgcmV0dXJuIC0xOwogIHZhX2VuZChhKTsKICByZXR1cm4gcjsKfQoKI2RlZmluZSBkYnVmX2FwcGVuZChkLCB4LCBuKSBkYnVmX3B1dCgoZCksIChjb25zdCB1aW50OF90KikoeCksIChuKSkKCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfY291bnQoRHluQnVmKiBkYiwgaW50IGNoKSB7CiAgcmV0dXJuIGJ5dGVfY291bnQoZGItPmJ1ZiwgZGItPnNpemUsIGNoKTsKfQoKc3RhdGljIGlubGluZSB2b2lkCmRidWZfMChEeW5CdWYqIGRiKSB7CiAgZGJ1Zl9wdXRjKGRiLCAnXDAnKTsKICBkYi0+c2l6ZS0tOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQKZGJ1Zl96ZXJvKER5bkJ1ZiogZGIpIHsKICBkYnVmX3JlYWxsb2MoZGIsIDApOwp9CgpzdGF0aWMgaW5saW5lIGludDMyX3QKZGJ1Zl9nZXRfY29sdW1uKER5bkJ1ZiogZGIpIHsKICBzaXplX3QgbGVuOwogIGNvbnN0IGNoYXIqIHN0cjsKICBpZihkYi0+c2l6ZSkgewogICAgc3RyID0gZGJ1Zl9sYXN0X2xpbmUoZGIsICZsZW4pOwogICAgcmV0dXJuIGFuc2lfbGVuZ3RoKHN0ciwgbGVuKTsKICB9CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfYml0ZmxhZ3MoRHluQnVmKiBkYiwgdWludDMyX3QgYml0cywgY29uc3QgY2hhciogY29uc3QgbmFtZXNbXSkgewogIHNpemVfdCBpLCBuID0gMDsKICBmb3IoaSA9IDA7IGkgPCBzaXplb2YoYml0cykgKiA4OyBpKyspIHsKICAgIGlmKGJpdHMgJiAoMSA8PCBpKSkgewogICAgICBzaXplX3QgbGVuID0gc3RybGVuKG5hbWVzW2ldKTsKICAgICAgaWYobikgewogICAgICAgIG4rKzsKICAgICAgICBkYnVmX3B1dHN0cihkYiwgInwiKTsKICAgICAgfQogICAgICBkYnVmX2FwcGVuZChkYiwgbmFtZXNbaV0sIGxlbik7CiAgICAgIG4gKz0gbGVuOwogICAgfQogIH0KICByZXR1cm4gbjsKfQoKc3RydWN0IG1lbW9yeV9ibG9jazsKc3RydWN0IHBvaW50ZXJfcmFuZ2U7CnN0cnVjdCBvZmZzZXRfbGVuZ3RoOwoKdHlwZWRlZiBzdHJ1Y3QgbWVtb3J5X2Jsb2NrIHsKICB1aW50OF90KiBiYXNlOwogIHNpemVfdCBzaXplOwp9IE1lbW9yeUJsb2NrOwoKc3RhdGljIGlubGluZSB2b2lkCmJsb2NrX2luaXQoTWVtb3J5QmxvY2sqIG1iKSB7CiAgbWItPmJhc2UgPSAwOwogIG1iLT5zaXplID0gMDsKfQoKc3RhdGljIGlubGluZSB2b2lkKgpibG9ja19kYXRhKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+YmFzZTsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKYmxvY2tfbGVuZ3RoKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+c2l6ZTsKfQoKCnN0YXRpYyBpbmxpbmUgQk9PTApibG9ja19hcnJheWJ1ZmZlcihNZW1vcnlCbG9jayogbWIsIEpTVmFsdWVDb25zdCBhYiwgSlNDb250ZXh0KiBjdHgpIHsKICByZXR1cm4gISEobWItPmJhc2UgPSBKU19HZXRBcnJheUJ1ZmZlcihjdHgsICZtYi0+c2l6ZSwgYWIpKTsKfQoKdHlwZWRlZiBzdHJ1Y3QgcG9pbnRlcl9yYW5nZSB7CiAgdWludDhfdCAqc3RhcnQsICplbmQ7Cn0gUG9pbnRlclJhbmdlOwoKc3RhdGljIGlubGluZSB2b2lkCnJhbmdlX2luaXQoUG9pbnRlclJhbmdlKiBwcikgewogIHByLT5lbmQgPSBwci0+c3RhcnQgPSAwOwp9CgpzdGF0aWMgaW5saW5lIFBvaW50ZXJSYW5nZQpyYW5nZV9mcm9tKGNvbnN0IE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiAoUG9pbnRlclJhbmdlKXttYi0+YmFzZSwgbWItPmJhc2UgKyBtYi0+c2l6ZX07Cn0KCnR5cGVkZWYgc3RydWN0IG9mZnNldF9sZW5ndGggewogIGludDY0X3Qgb2Zmc2V0LCBsZW5ndGg7Cn0gT2Zmc2V0TGVuZ3RoOwoKc3RhdGljIGlubGluZSB2b2lkCm9mZnNldF9pbml0KE9mZnNldExlbmd0aCogb2wpIHsKICBvbC0+b2Zmc2V0ID0gMDsKICBvbC0+bGVuZ3RoID0gSU5UNjRfTUFYOwp9CgpzdGF0aWMgaW5saW5lIEJPT0wKb2Zmc2V0X2lzX2RlZmF1bHQoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCkgewogIHJldHVybiBvbC0+b2Zmc2V0ID09IDAgJiYgb2wtPmxlbmd0aCA9PSBJTlQ2NF9NQVg7Cn0KCnN0YXRpYyBpbmxpbmUgdWludDhfdCoKb2Zmc2V0X2RhdGEoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCwgY29uc3Qgdm9pZCogeCkgewogIHJldHVybiAodWludDhfdCopeCArIG9sLT5vZmZzZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90Cm9mZnNldF9zaXplKGNvbnN0IE9mZnNldExlbmd0aCogb2wsIHNpemVfdCBuKSB7CiAgcmV0dXJuIE1JTl9OVU0ob2wtPmxlbmd0aCwgbiAtIG9sLT5vZmZzZXQpOwp9CgpzdGF0aWMgaW5saW5lIE1lbW9yeUJsb2NrCm9mZnNldF9ibG9jayhjb25zdCBPZmZzZXRMZW5ndGgqIG9sLCBjb25zdCB2b2lkKiB4LCBzaXplX3QgbikgewogIHJldHVybiAoTWVtb3J5QmxvY2spe29mZnNldF9kYXRhKG9sLCB4KSwgb2Zmc2V0X3NpemUob2wsIG4pfTsKfQoKc3RhdGljIGlubGluZSBQb2ludGVyUmFuZ2UKb2Zmc2V0X3JhbmdlKGNvbnN0IE9mZnNldExlbmd0aCogb2wsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBuKSB7CiAgTWVtb3J5QmxvY2sgbWIgPSBvZmZzZXRfYmxvY2sob2wsIHgsIG4pOwogIHJldHVybiByYW5nZV9mcm9tKCZtYik7Cn0KCnN0YXRpYyBpbmxpbmUgT2Zmc2V0TGVuZ3RoCm9mZnNldF9zbGljZShjb25zdCBPZmZzZXRMZW5ndGggb2wsIGludDY0X3Qgc3RhcnQsIGludDY0X3QgZW5kKSB7CiAgaWYoc3RhcnQgPCAwKQogICAgc3RhcnQgPSBvbC5sZW5ndGggKyAoc3RhcnQgJSBvbC5sZW5ndGgpOwogIGVsc2UgaWYoc3RhcnQgPiBvbC5sZW5ndGgpCiAgICBzdGFydCA9IG9sLmxlbmd0aDsKICBpZihlbmQgPCAwKQogICAgZW5kID0gb2wubGVuZ3RoICsgKGVuZCAlIG9sLmxlbmd0aCk7CiAgZWxzZSBpZihlbmQgPiBvbC5sZW5ndGgpCiAgICBlbmQgPSBvbC5sZW5ndGg7CgogIHJldHVybiAoT2Zmc2V0TGVuZ3RoKXtzdGFydCwgZW5kIC0gc3RhcnR9Owp9CgpzdGF0aWMgaW5saW5lIE9mZnNldExlbmd0aApvZmZzZXRfb2Zmc2V0KGNvbnN0IE9mZnNldExlbmd0aCogb2wsIGNvbnN0IE9mZnNldExlbmd0aCogYnkpIHsKICBPZmZzZXRMZW5ndGggcmV0OwogIHJldC5vZmZzZXQgPSBvbC0+b2Zmc2V0ICsgYnktPm9mZnNldDsKICByZXQubGVuZ3RoID0gTUlOX05VTShieS0+bGVuZ3RoLCBvbC0+bGVuZ3RoIC0gYnktPm9mZnNldCk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBNZW1vcnlCbG9jawpibG9ja19yYW5nZShjb25zdCBNZW1vcnlCbG9jayogbWIsIHN0cnVjdCBvZmZzZXRfbGVuZ3RoKiByYW5nZSkgewogIE1lbW9yeUJsb2NrIHJldDsKICByZXQuYmFzZSA9IG1iLT5iYXNlICsgcmFuZ2UtPm9mZnNldDsKICByZXQuc2l6ZSA9IE1JTl9OVU0ocmFuZ2UtPmxlbmd0aCwgbWItPnNpemUgLSByYW5nZS0+b2Zmc2V0KTsKICByZXR1cm4gcmV0Owp9Cgp0eXBlZGVmIHN0cnVjdCBJbnB1dEJ1ZmZlciB7CiAgdWludDhfdCogZGF0YTsKICBzaXplX3QgcG9zLCBzaXplOwogIHZvaWQgKCpmcmVlKShKU0NvbnRleHQqLCBjb25zdCBjaGFyKiwgSlNWYWx1ZSk7CiAgSlNWYWx1ZSB2YWx1ZTsKICBPZmZzZXRMZW5ndGggcmFuZ2U7Cn0gSW5wdXRCdWZmZXI7CgpzdGF0aWMgaW5saW5lIHZvaWQKaW5wdXRfYnVmZmVyX2ZyZWVfZGVmYXVsdChKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogc3RyLCBKU1ZhbHVlIHZhbCkgewogIGlmKEpTX0lzU3RyaW5nKHZhbCkpCiAgICBKU19GcmVlQ1N0cmluZyhjdHgsIHN0cik7CgogIGlmKCFKU19Jc1VuZGVmaW5lZCh2YWwpKQogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsKTsKfQoKSW5wdXRCdWZmZXIganNfaW5wdXRfYnVmZmVyKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwpJbnB1dEJ1ZmZlciBqc19pbnB1dF9jaGFycyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKSW5wdXRCdWZmZXIgaW5wdXRfYnVmZmVyX2Nsb25lKGNvbnN0IElucHV0QnVmZmVyKiBpbiwgSlNDb250ZXh0KiBjdHgpOwpCT09MIGlucHV0X2J1ZmZlcl92YWxpZChjb25zdCBJbnB1dEJ1ZmZlciogaW4pOwp2b2lkIGlucHV0X2J1ZmZlcl9kdW1wKGNvbnN0IElucHV0QnVmZmVyKiBpbiwgRHluQnVmKiBkYik7CnZvaWQgaW5wdXRfYnVmZmVyX2ZyZWUoSW5wdXRCdWZmZXIqIGluLCBKU0NvbnRleHQqIGN0eCk7CgpzdGF0aWMgaW5saW5lIHVpbnQ4X3QqCmlucHV0X2J1ZmZlcl9kYXRhKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbi0+ZGF0YSArIGluLT5yYW5nZS5vZmZzZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmlucHV0X2J1ZmZlcl9sZW5ndGgoY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIE1JTl9OVU0oaW4tPnJhbmdlLmxlbmd0aCwgaW4tPnNpemUpOwp9CgpzdGF0aWMgaW5saW5lIE1lbW9yeUJsb2NrCmlucHV0X2J1ZmZlcl9ibG9jayhJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gKE1lbW9yeUJsb2NrKXtpbnB1dF9idWZmZXJfZGF0YShpbiksIGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pfTsKfQoKc3RhdGljIGlubGluZSBJbnB1dEJ1ZmZlcgppbnB1dF9idWZmZXJfb2Zmc2V0KElucHV0QnVmZmVyIGluLCBPZmZzZXRMZW5ndGggb2ZmKSB7CiAgSW5wdXRCdWZmZXIgcmV0ID0gaW47CgogIHJldC5kYXRhICs9IG9mZi5vZmZzZXQ7CiAgcmV0LnNpemUgLT0gb2ZmLm9mZnNldDsKCiAgaWYocmV0LnNpemUgPiBvZmYubGVuZ3RoKQogICAgcmV0LnNpemUgPSBvZmYubGVuZ3RoOwoKICByZXR1cm4gcmV0Owp9Cgpjb25zdCB1aW50OF90KiBpbnB1dF9idWZmZXJfZ2V0KElucHV0QnVmZmVyKiBpbiwgc2l6ZV90KiBsZW5wKTsKY29uc3QgdWludDhfdCogaW5wdXRfYnVmZmVyX3BlZWsoSW5wdXRCdWZmZXIqIGluLCBzaXplX3QqIGxlbnApOwpjb25zdCBjaGFyKiBpbnB1dF9idWZmZXJfY3VycmVudGxpbmUoSW5wdXRCdWZmZXIqLCBzaXplX3QqIGxlbik7CnNpemVfdCBpbnB1dF9idWZmZXJfY29sdW1uKElucHV0QnVmZmVyKiwgc2l6ZV90KiBsZW4pOwoKc3RhdGljIGludAppbnB1dF9idWZmZXJfcGVla2MoSW5wdXRCdWZmZXIqIGluLCBzaXplX3QqIGxlbnApIHsKICBjb25zdCB1aW50OF90ICpwb3MsICplbmQsICpuZXh0OwogIGludCBjcDsKICBwb3MgPSBpbnB1dF9idWZmZXJfZGF0YShpbikgKyBpbi0+cG9zOwogIGVuZCA9IGlucHV0X2J1ZmZlcl9kYXRhKGluKSArIGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pOwogIGNwID0gdW5pY29kZV9mcm9tX3V0ZjgocG9zLCBlbmQgLSBwb3MsICZuZXh0KTsKICBpZihsZW5wKQogICAgKmxlbnAgPSBuZXh0IC0gcG9zOwoKICByZXR1cm4gY3A7Cn0KCnN0YXRpYyBpbmxpbmUgaW50CmlucHV0X2J1ZmZlcl9nZXRjKElucHV0QnVmZmVyKiBpbikgewogIHNpemVfdCBuOwogIGludCByZXQ7CiAgcmV0ID0gaW5wdXRfYnVmZmVyX3BlZWtjKGluLCAmbik7CiAgaW4tPnBvcyArPSBuOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgdWludDhfdCoKaW5wdXRfYnVmZmVyX2JlZ2luKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbnB1dF9idWZmZXJfZGF0YShpbik7Cn0Kc3RhdGljIGlubGluZSB1aW50OF90KgppbnB1dF9idWZmZXJfZW5kKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbnB1dF9idWZmZXJfZGF0YShpbikgKyBpbnB1dF9idWZmZXJfbGVuZ3RoKGluKTsKfQpzdGF0aWMgaW5saW5lIEJPT0wKaW5wdXRfYnVmZmVyX2VvZihjb25zdCBJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gaW4tPnBvcyA9PSBpbnB1dF9idWZmZXJfbGVuZ3RoKGluKTsKfQpzdGF0aWMgaW5saW5lIHNpemVfdAppbnB1dF9idWZmZXJfcmVtYWluKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbnB1dF9idWZmZXJfbGVuZ3RoKGluKSAtIGluLT5wb3M7Cn0KCk9mZnNldExlbmd0aCBqc19vZmZzZXRfbGVuZ3RoKEpTQ29udGV4dCosIGludDY0X3Qgc2l6ZSwgaW50IGFyZ2MsIEpTVmFsdWUgYXJndltdKTsKCiNlbmRpZiAvKiBkZWZpbmVkKEJVRkZFUl9VVElMUykgKi8KAAAAAAAAAAAyHgAAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAADuFAAAAAAAAP0UAAAAAAAAAAAAAAAA8L8"
				],
				[
					10,
					1,
					"revert",
					null,
					"AwAAAAAAAAAAAAAAAAAAAAAAAAAyHgAAI2lmbmRlZiBCVUZGRVJfVVRJTFNfSAojZGVmaW5lIEJVRkZFUl9VVElMU19ICgojaW5jbHVkZSA8cXVpY2tqcy5oPgojaW5jbHVkZSA8Y3V0aWxzLmg+CiNpbmNsdWRlIDxzdGRhcmcuaD4KCiNpbmNsdWRlICJjaGFyLXV0aWxzLmgiCgojaWZuZGVmIE1BWF9OVU0KI2RlZmluZSBNQVhfTlVNKGEsIGIpICgoYSkgPiAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgojaWZuZGVmIE1JTl9OVU0KI2RlZmluZSBNSU5fTlVNKGEsIGIpICgoYSkgPCAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgoKc2l6ZV90IGFuc2lfbGVuZ3RoKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV9za2lwKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV90cnVuY2F0ZShjb25zdCBjaGFyKiwgc2l6ZV90LCBzaXplX3QgbGltaXQpOwppbnQ2NF90IGFycmF5X3NlYXJjaCh2b2lkKiwgc2l6ZV90LCBzaXplX3QgZWxzeiwgdm9pZCogbmVlZGxlKTsKY2hhciogc3RyX2VzY2FwZShjb25zdCBjaGFyKik7CmNoYXIqIGJ5dGVfZXNjYXBlKGNvbnN0IHZvaWQqLCBzaXplX3QpOwpzaXplX3QgYnl0ZV9maW5kYihjb25zdCB2b2lkKiwgc2l6ZV90LCBjb25zdCB2b2lkKiB3aGF0LCBzaXplX3Qgd2xlbik7CnNpemVfdCBieXRlX2ZpbmRzKGNvbnN0IHZvaWQqLCBzaXplX3QsIGNvbnN0IGNoYXIqIHdoYXQpOwpzaXplX3QgYnl0ZV9lcXVhbChjb25zdCB2b2lkKiBzLCBzaXplX3QgbiwgY29uc3Qgdm9pZCogdCk7CmNoYXIqIGRidWZfYXRfbihjb25zdCBEeW5CdWYqLCBzaXplX3QsIHNpemVfdCogbiwgY2hhciBzZXApOwpjb25zdCBjaGFyKiBkYnVmX2xhc3RfbGluZShEeW5CdWYqLCBzaXplX3QqKTsKaW50IGRidWZfcHJlcGVuZChEeW5CdWYqLCBjb25zdCB1aW50OF90Kiwgc2l6ZV90IGxlbik7CnZvaWQgZGJ1Zl9wdXRfY29sb3JzdHIoRHluQnVmKiwgY29uc3QgY2hhciosIGNvbnN0IGNoYXIqIGNvbG9yLCBpbnQgd2l0aF9jb2xvcik7CnZvaWQgZGJ1Zl9wdXRfZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkX3RhYmxlKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBjb25zdCBjaGFyIHRhYmxlWzI1Nl0pOwp2b2lkIGRidWZfcHV0X3VuZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuKTsKdm9pZCBkYnVmX3B1dF92YWx1ZShEeW5CdWYqLCBKU0NvbnRleHQqLCBKU1ZhbHVlIHZhbHVlKTsKaW50IGRidWZfcmVzZXJ2ZV9zdGFydChEeW5CdWYqLCBzaXplX3QpOwpzaXplX3QgZGJ1Zl90b2tlbl9wb3AoRHluQnVmKiwgY2hhcik7CnNpemVfdCBkYnVmX3Rva2VuX3B1c2goRHluQnVmKiwgY29uc3QgY2hhciosIHNpemVfdCBsZW4sIGNoYXIgZGVsaW0pOwpKU1ZhbHVlIGRidWZfdG9zdHJpbmdfZnJlZShEeW5CdWYqLCBKU0NvbnRleHQqKTsKc3NpemVfdCBkYnVmX2xvYWQoRHluQnVmKiwgY29uc3QgY2hhciopOwoKc3RhdGljIGlubGluZSBpbnQKZGJ1Zl9wdXRtKER5bkJ1ZiogZGIsIC4uLikgewogIGludCByID0gMDsKICB2YV9saXN0IGE7CiAgY29uc3QgY2hhciogczsKICB2YV9zdGFydChhLCBkYik7CiAgd2hpbGUoKHMgPSB2YV9hcmcoYSwgY2hhciopKSkKICAgIGlmKGRidWZfcHV0c3RyKGRiLCBzKSkKICAgICAgcmV0dXJuIC0xOwogIHZhX2VuZChhKTsKICByZXR1cm4gcjsKfQoKI2RlZmluZSBkYnVmX2FwcGVuZChkLCB4LCBuKSBkYnVmX3B1dCgoZCksIChjb25zdCB1aW50OF90KikoeCksIChuKSkKCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfY291bnQoRHluQnVmKiBkYiwgaW50IGNoKSB7CiAgcmV0dXJuIGJ5dGVfY291bnQoZGItPmJ1ZiwgZGItPnNpemUsIGNoKTsKfQoKc3RhdGljIGlubGluZSB2b2lkCmRidWZfMChEeW5CdWYqIGRiKSB7CiAgZGJ1Zl9wdXRjKGRiLCAnXDAnKTsKICBkYi0+c2l6ZS0tOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQKZGJ1Zl96ZXJvKER5bkJ1ZiogZGIpIHsKICBkYnVmX3JlYWxsb2MoZGIsIDApOwp9CgpzdGF0aWMgaW5saW5lIGludDMyX3QKZGJ1Zl9nZXRfY29sdW1uKER5bkJ1ZiogZGIpIHsKICBzaXplX3QgbGVuOwogIGNvbnN0IGNoYXIqIHN0cjsKICBpZihkYi0+c2l6ZSkgewogICAgc3RyID0gZGJ1Zl9sYXN0X2xpbmUoZGIsICZsZW4pOwogICAgcmV0dXJuIGFuc2lfbGVuZ3RoKHN0ciwgbGVuKTsKICB9CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfYml0ZmxhZ3MoRHluQnVmKiBkYiwgdWludDMyX3QgYml0cywgY29uc3QgY2hhciogY29uc3QgbmFtZXNbXSkgewogIHNpemVfdCBpLCBuID0gMDsKICBmb3IoaSA9IDA7IGkgPCBzaXplb2YoYml0cykgKiA4OyBpKyspIHsKICAgIGlmKGJpdHMgJiAoMSA8PCBpKSkgewogICAgICBzaXplX3QgbGVuID0gc3RybGVuKG5hbWVzW2ldKTsKICAgICAgaWYobikgewogICAgICAgIG4rKzsKICAgICAgICBkYnVmX3B1dHN0cihkYiwgInwiKTsKICAgICAgfQogICAgICBkYnVmX2FwcGVuZChkYiwgbmFtZXNbaV0sIGxlbik7CiAgICAgIG4gKz0gbGVuOwogICAgfQogIH0KICByZXR1cm4gbjsKfQoKc3RydWN0IG1lbW9yeV9ibG9jazsKc3RydWN0IHBvaW50ZXJfcmFuZ2U7CnN0cnVjdCBvZmZzZXRfbGVuZ3RoOwoKdHlwZWRlZiBzdHJ1Y3QgbWVtb3J5X2Jsb2NrIHsKICB1aW50OF90KiBiYXNlOwogIHNpemVfdCBzaXplOwp9IE1lbW9yeUJsb2NrOwoKc3RhdGljIGlubGluZSB2b2lkCmJsb2NrX2luaXQoTWVtb3J5QmxvY2sqIG1iKSB7CiAgbWItPmJhc2UgPSAwOwogIG1iLT5zaXplID0gMDsKfQoKc3RhdGljIGlubGluZSB2b2lkKgpibG9ja19kYXRhKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+YmFzZTsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKYmxvY2tfbGVuZ3RoKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+c2l6ZTsKfQoKc3RhdGljIGlubGluZSBCT09MCmJsb2NrX2FycmF5YnVmZmVyKE1lbW9yeUJsb2NrKiBtYiwgSlNWYWx1ZUNvbnN0IGFiLCBKU0NvbnRleHQqIGN0eCkgewogIHJldHVybiAhIShtYi0+YmFzZSA9IEpTX0dldEFycmF5QnVmZmVyKGN0eCwgJm1iLT5zaXplLCBhYikpOwp9Cgp0eXBlZGVmIHN0cnVjdCBwb2ludGVyX3JhbmdlIHsKICB1aW50OF90ICpzdGFydCwgKmVuZDsKfSBQb2ludGVyUmFuZ2U7CgpzdGF0aWMgaW5saW5lIHZvaWQKcmFuZ2VfaW5pdChQb2ludGVyUmFuZ2UqIHByKSB7CiAgcHItPmVuZCA9IHByLT5zdGFydCA9IDA7Cn0KCnN0YXRpYyBpbmxpbmUgUG9pbnRlclJhbmdlCnJhbmdlX2Zyb20oY29uc3QgTWVtb3J5QmxvY2sqIG1iKSB7CiAgcmV0dXJuIChQb2ludGVyUmFuZ2Upe21iLT5iYXNlLCBtYi0+YmFzZSArIG1iLT5zaXplfTsKfQoKdHlwZWRlZiBzdHJ1Y3Qgb2Zmc2V0X2xlbmd0aCB7CiAgaW50NjRfdCBvZmZzZXQsIGxlbmd0aDsKfSBPZmZzZXRMZW5ndGg7CgpzdGF0aWMgaW5saW5lIHZvaWQKb2Zmc2V0X2luaXQoT2Zmc2V0TGVuZ3RoKiBvbCkgewogIG9sLT5vZmZzZXQgPSAwOwogIG9sLT5sZW5ndGggPSBJTlQ2NF9NQVg7Cn0KCnN0YXRpYyBpbmxpbmUgQk9PTApvZmZzZXRfaXNfZGVmYXVsdChjb25zdCBPZmZzZXRMZW5ndGgqIG9sKSB7CiAgcmV0dXJuIG9sLT5vZmZzZXQgPT0gMCAmJiBvbC0+bGVuZ3RoID09IElOVDY0X01BWDsKfQoKc3RhdGljIGlubGluZSB1aW50OF90KgpvZmZzZXRfZGF0YShjb25zdCBPZmZzZXRMZW5ndGgqIG9sLCBjb25zdCB2b2lkKiB4KSB7CiAgcmV0dXJuICh1aW50OF90Kil4ICsgb2wtPm9mZnNldDsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKb2Zmc2V0X3NpemUoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCwgc2l6ZV90IG4pIHsKICByZXR1cm4gTUlOX05VTShvbC0+bGVuZ3RoLCBuIC0gb2wtPm9mZnNldCk7Cn0KCnN0YXRpYyBpbmxpbmUgTWVtb3J5QmxvY2sKb2Zmc2V0X2Jsb2NrKGNvbnN0IE9mZnNldExlbmd0aCogb2wsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBuKSB7CiAgcmV0dXJuIChNZW1vcnlCbG9jayl7b2Zmc2V0X2RhdGEob2wsIHgpLCBvZmZzZXRfc2l6ZShvbCwgbil9Owp9CgpzdGF0aWMgaW5saW5lIFBvaW50ZXJSYW5nZQpvZmZzZXRfcmFuZ2UoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCwgY29uc3Qgdm9pZCogeCwgc2l6ZV90IG4pIHsKICBNZW1vcnlCbG9jayBtYiA9IG9mZnNldF9ibG9jayhvbCwgeCwgbik7CiAgcmV0dXJuIHJhbmdlX2Zyb20oJm1iKTsKfQoKc3RhdGljIGlubGluZSBPZmZzZXRMZW5ndGgKb2Zmc2V0X3NsaWNlKGNvbnN0IE9mZnNldExlbmd0aCBvbCwgaW50NjRfdCBzdGFydCwgaW50NjRfdCBlbmQpIHsKICBpZihzdGFydCA8IDApCiAgICBzdGFydCA9IG9sLmxlbmd0aCArIChzdGFydCAlIG9sLmxlbmd0aCk7CiAgZWxzZSBpZihzdGFydCA+IG9sLmxlbmd0aCkKICAgIHN0YXJ0ID0gb2wubGVuZ3RoOwogIGlmKGVuZCA8IDApCiAgICBlbmQgPSBvbC5sZW5ndGggKyAoZW5kICUgb2wubGVuZ3RoKTsKICBlbHNlIGlmKGVuZCA+IG9sLmxlbmd0aCkKICAgIGVuZCA9IG9sLmxlbmd0aDsKCiAgcmV0dXJuIChPZmZzZXRMZW5ndGgpe3N0YXJ0LCBlbmQgLSBzdGFydH07Cn0KCnN0YXRpYyBpbmxpbmUgT2Zmc2V0TGVuZ3RoCm9mZnNldF9vZmZzZXQoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCwgY29uc3QgT2Zmc2V0TGVuZ3RoKiBieSkgewogIE9mZnNldExlbmd0aCByZXQ7CiAgcmV0Lm9mZnNldCA9IG9sLT5vZmZzZXQgKyBieS0+b2Zmc2V0OwogIHJldC5sZW5ndGggPSBNSU5fTlVNKGJ5LT5sZW5ndGgsIG9sLT5sZW5ndGggLSBieS0+b2Zmc2V0KTsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW5saW5lIE1lbW9yeUJsb2NrCmJsb2NrX3JhbmdlKGNvbnN0IE1lbW9yeUJsb2NrKiBtYiwgc3RydWN0IG9mZnNldF9sZW5ndGgqIHJhbmdlKSB7CiAgTWVtb3J5QmxvY2sgcmV0OwogIHJldC5iYXNlID0gbWItPmJhc2UgKyByYW5nZS0+b2Zmc2V0OwogIHJldC5zaXplID0gTUlOX05VTShyYW5nZS0+bGVuZ3RoLCBtYi0+c2l6ZSAtIHJhbmdlLT5vZmZzZXQpOwogIHJldHVybiByZXQ7Cn0KCnR5cGVkZWYgc3RydWN0IElucHV0QnVmZmVyIHsKICB1aW50OF90KiBkYXRhOwogIHNpemVfdCBwb3MsIHNpemU7CiAgdm9pZCAoKmZyZWUpKEpTQ29udGV4dCosIGNvbnN0IGNoYXIqLCBKU1ZhbHVlKTsKICBKU1ZhbHVlIHZhbHVlOwogIE9mZnNldExlbmd0aCByYW5nZTsKfSBJbnB1dEJ1ZmZlcjsKCnN0YXRpYyBpbmxpbmUgdm9pZAppbnB1dF9idWZmZXJfZnJlZV9kZWZhdWx0KEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBzdHIsIEpTVmFsdWUgdmFsKSB7CiAgaWYoSlNfSXNTdHJpbmcodmFsKSkKICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgc3RyKTsKCiAgaWYoIUpTX0lzVW5kZWZpbmVkKHZhbCkpCiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWwpOwp9CgpJbnB1dEJ1ZmZlciBqc19pbnB1dF9idWZmZXIoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CklucHV0QnVmZmVyIGpzX2lucHV0X2NoYXJzKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwpJbnB1dEJ1ZmZlciBpbnB1dF9idWZmZXJfY2xvbmUoY29uc3QgSW5wdXRCdWZmZXIqIGluLCBKU0NvbnRleHQqIGN0eCk7CkJPT0wgaW5wdXRfYnVmZmVyX3ZhbGlkKGNvbnN0IElucHV0QnVmZmVyKiBpbik7CnZvaWQgaW5wdXRfYnVmZmVyX2R1bXAoY29uc3QgSW5wdXRCdWZmZXIqIGluLCBEeW5CdWYqIGRiKTsKdm9pZCBpbnB1dF9idWZmZXJfZnJlZShJbnB1dEJ1ZmZlciogaW4sIEpTQ29udGV4dCogY3R4KTsKCnN0YXRpYyBpbmxpbmUgdWludDhfdCoKaW5wdXRfYnVmZmVyX2RhdGEoY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIGluLT5kYXRhICsgaW4tPnJhbmdlLm9mZnNldDsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKaW5wdXRfYnVmZmVyX2xlbmd0aChjb25zdCBJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gTUlOX05VTShpbi0+cmFuZ2UubGVuZ3RoLCBpbi0+c2l6ZSk7Cn0KCnN0YXRpYyBpbmxpbmUgTWVtb3J5QmxvY2sKaW5wdXRfYnVmZmVyX2Jsb2NrKElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiAoTWVtb3J5QmxvY2spe2lucHV0X2J1ZmZlcl9kYXRhKGluKSwgaW5wdXRfYnVmZmVyX2xlbmd0aChpbil9Owp9CgpzdGF0aWMgaW5saW5lIElucHV0QnVmZmVyCmlucHV0X2J1ZmZlcl9vZmZzZXQoSW5wdXRCdWZmZXIgaW4sIE9mZnNldExlbmd0aCBvZmYpIHsKICBJbnB1dEJ1ZmZlciByZXQgPSBpbjsKCiAgcmV0LmRhdGEgKz0gb2ZmLm9mZnNldDsKICByZXQuc2l6ZSAtPSBvZmYub2Zmc2V0OwoKICBpZihyZXQuc2l6ZSA+IG9mZi5sZW5ndGgpCiAgICByZXQuc2l6ZSA9IG9mZi5sZW5ndGg7CgogIHJldHVybiByZXQ7Cn0KCmNvbnN0IHVpbnQ4X3QqIGlucHV0X2J1ZmZlcl9nZXQoSW5wdXRCdWZmZXIqIGluLCBzaXplX3QqIGxlbnApOwpjb25zdCB1aW50OF90KiBpbnB1dF9idWZmZXJfcGVlayhJbnB1dEJ1ZmZlciogaW4sIHNpemVfdCogbGVucCk7CmNvbnN0IGNoYXIqIGlucHV0X2J1ZmZlcl9jdXJyZW50bGluZShJbnB1dEJ1ZmZlciosIHNpemVfdCogbGVuKTsKc2l6ZV90IGlucHV0X2J1ZmZlcl9jb2x1bW4oSW5wdXRCdWZmZXIqLCBzaXplX3QqIGxlbik7CgpzdGF0aWMgaW50CmlucHV0X2J1ZmZlcl9wZWVrYyhJbnB1dEJ1ZmZlciogaW4sIHNpemVfdCogbGVucCkgewogIGNvbnN0IHVpbnQ4X3QgKnBvcywgKmVuZCwgKm5leHQ7CiAgaW50IGNwOwogIHBvcyA9IGlucHV0X2J1ZmZlcl9kYXRhKGluKSArIGluLT5wb3M7CiAgZW5kID0gaW5wdXRfYnVmZmVyX2RhdGEoaW4pICsgaW5wdXRfYnVmZmVyX2xlbmd0aChpbik7CiAgY3AgPSB1bmljb2RlX2Zyb21fdXRmOChwb3MsIGVuZCAtIHBvcywgJm5leHQpOwogIGlmKGxlbnApCiAgICAqbGVucCA9IG5leHQgLSBwb3M7CgogIHJldHVybiBjcDsKfQoKc3RhdGljIGlubGluZSBpbnQKaW5wdXRfYnVmZmVyX2dldGMoSW5wdXRCdWZmZXIqIGluKSB7CiAgc2l6ZV90IG47CiAgaW50IHJldDsKICByZXQgPSBpbnB1dF9idWZmZXJfcGVla2MoaW4sICZuKTsKICBpbi0+cG9zICs9IG47CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSB1aW50OF90KgppbnB1dF9idWZmZXJfYmVnaW4oY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIGlucHV0X2J1ZmZlcl9kYXRhKGluKTsKfQpzdGF0aWMgaW5saW5lIHVpbnQ4X3QqCmlucHV0X2J1ZmZlcl9lbmQoY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIGlucHV0X2J1ZmZlcl9kYXRhKGluKSArIGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pOwp9CnN0YXRpYyBpbmxpbmUgQk9PTAppbnB1dF9idWZmZXJfZW9mKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbi0+cG9zID09IGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pOwp9CnN0YXRpYyBpbmxpbmUgc2l6ZV90CmlucHV0X2J1ZmZlcl9yZW1haW4oY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pIC0gaW4tPnBvczsKfQoKT2Zmc2V0TGVuZ3RoIGpzX29mZnNldF9sZW5ndGgoSlNDb250ZXh0KiwgaW50NjRfdCBzaXplLCBpbnQgYXJnYywgSlNWYWx1ZSBhcmd2W10pOwoKI2VuZGlmIC8qIGRlZmluZWQoQlVGRkVSX1VUSUxTKSAqLwoAAAAAAAAAADIeAAAAAAAAAAAAAAAAAAAAAAAAMh4AAAAAAAAAAAAA",
					"AgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAADuFAAAAAAAAP0UAAAAAAAAAAAAAAAA8L8"
				],
				[
					1,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAyHgAAI2lmbmRlZiBCVUZGRVJfVVRJTFNfSAojZGVmaW5lIEJVRkZFUl9VVElMU19ICgojaW5jbHVkZSA8cXVpY2tqcy5oPgojaW5jbHVkZSA8Y3V0aWxzLmg+CiNpbmNsdWRlIDxzdGRhcmcuaD4KCiNpbmNsdWRlICJjaGFyLXV0aWxzLmgiCgojaWZuZGVmIE1BWF9OVU0KI2RlZmluZSBNQVhfTlVNKGEsIGIpICgoYSkgPiAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgojaWZuZGVmIE1JTl9OVU0KI2RlZmluZSBNSU5fTlVNKGEsIGIpICgoYSkgPCAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgoKc2l6ZV90IGFuc2lfbGVuZ3RoKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV9za2lwKGNvbnN0IGNoYXIqLCBzaXplX3QpOwpzaXplX3QgYW5zaV90cnVuY2F0ZShjb25zdCBjaGFyKiwgc2l6ZV90LCBzaXplX3QgbGltaXQpOwppbnQ2NF90IGFycmF5X3NlYXJjaCh2b2lkKiwgc2l6ZV90LCBzaXplX3QgZWxzeiwgdm9pZCogbmVlZGxlKTsKY2hhciogc3RyX2VzY2FwZShjb25zdCBjaGFyKik7CmNoYXIqIGJ5dGVfZXNjYXBlKGNvbnN0IHZvaWQqLCBzaXplX3QpOwpzaXplX3QgYnl0ZV9maW5kYihjb25zdCB2b2lkKiwgc2l6ZV90LCBjb25zdCB2b2lkKiB3aGF0LCBzaXplX3Qgd2xlbik7CnNpemVfdCBieXRlX2ZpbmRzKGNvbnN0IHZvaWQqLCBzaXplX3QsIGNvbnN0IGNoYXIqIHdoYXQpOwpzaXplX3QgYnl0ZV9lcXVhbChjb25zdCB2b2lkKiBzLCBzaXplX3QgbiwgY29uc3Qgdm9pZCogdCk7CmNoYXIqIGRidWZfYXRfbihjb25zdCBEeW5CdWYqLCBzaXplX3QsIHNpemVfdCogbiwgY2hhciBzZXApOwpjb25zdCBjaGFyKiBkYnVmX2xhc3RfbGluZShEeW5CdWYqLCBzaXplX3QqKTsKaW50IGRidWZfcHJlcGVuZChEeW5CdWYqLCBjb25zdCB1aW50OF90Kiwgc2l6ZV90IGxlbik7CnZvaWQgZGJ1Zl9wdXRfY29sb3JzdHIoRHluQnVmKiwgY29uc3QgY2hhciosIGNvbnN0IGNoYXIqIGNvbG9yLCBpbnQgd2l0aF9jb2xvcik7CnZvaWQgZGJ1Zl9wdXRfZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkX3RhYmxlKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBjb25zdCBjaGFyIHRhYmxlWzI1Nl0pOwp2b2lkIGRidWZfcHV0X3VuZXNjYXBlZF9wcmVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuLCBpbnQgKCpwcmVkKShpbnQpKTsKdm9pZCBkYnVmX3B1dF9lc2NhcGVkKER5bkJ1ZiosIGNvbnN0IGNoYXIqLCBzaXplX3QgbGVuKTsKdm9pZCBkYnVmX3B1dF92YWx1ZShEeW5CdWYqLCBKU0NvbnRleHQqLCBKU1ZhbHVlIHZhbHVlKTsKaW50IGRidWZfcmVzZXJ2ZV9zdGFydChEeW5CdWYqLCBzaXplX3QpOwpzaXplX3QgZGJ1Zl90b2tlbl9wb3AoRHluQnVmKiwgY2hhcik7CnNpemVfdCBkYnVmX3Rva2VuX3B1c2goRHluQnVmKiwgY29uc3QgY2hhciosIHNpemVfdCBsZW4sIGNoYXIgZGVsaW0pOwpKU1ZhbHVlIGRidWZfdG9zdHJpbmdfZnJlZShEeW5CdWYqLCBKU0NvbnRleHQqKTsKc3NpemVfdCBkYnVmX2xvYWQoRHluQnVmKiwgY29uc3QgY2hhciopOwoKc3RhdGljIGlubGluZSBpbnQKZGJ1Zl9wdXRtKER5bkJ1ZiogZGIsIC4uLikgewogIGludCByID0gMDsKICB2YV9saXN0IGE7CiAgY29uc3QgY2hhciogczsKICB2YV9zdGFydChhLCBkYik7CiAgd2hpbGUoKHMgPSB2YV9hcmcoYSwgY2hhciopKSkKICAgIGlmKGRidWZfcHV0c3RyKGRiLCBzKSkKICAgICAgcmV0dXJuIC0xOwogIHZhX2VuZChhKTsKICByZXR1cm4gcjsKfQoKI2RlZmluZSBkYnVmX2FwcGVuZChkLCB4LCBuKSBkYnVmX3B1dCgoZCksIChjb25zdCB1aW50OF90KikoeCksIChuKSkKCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfY291bnQoRHluQnVmKiBkYiwgaW50IGNoKSB7CiAgcmV0dXJuIGJ5dGVfY291bnQoZGItPmJ1ZiwgZGItPnNpemUsIGNoKTsKfQoKc3RhdGljIGlubGluZSB2b2lkCmRidWZfMChEeW5CdWYqIGRiKSB7CiAgZGJ1Zl9wdXRjKGRiLCAnXDAnKTsKICBkYi0+c2l6ZS0tOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQKZGJ1Zl96ZXJvKER5bkJ1ZiogZGIpIHsKICBkYnVmX3JlYWxsb2MoZGIsIDApOwp9CgpzdGF0aWMgaW5saW5lIGludDMyX3QKZGJ1Zl9nZXRfY29sdW1uKER5bkJ1ZiogZGIpIHsKICBzaXplX3QgbGVuOwogIGNvbnN0IGNoYXIqIHN0cjsKICBpZihkYi0+c2l6ZSkgewogICAgc3RyID0gZGJ1Zl9sYXN0X2xpbmUoZGIsICZsZW4pOwogICAgcmV0dXJuIGFuc2lfbGVuZ3RoKHN0ciwgbGVuKTsKICB9CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90CmRidWZfYml0ZmxhZ3MoRHluQnVmKiBkYiwgdWludDMyX3QgYml0cywgY29uc3QgY2hhciogY29uc3QgbmFtZXNbXSkgewogIHNpemVfdCBpLCBuID0gMDsKICBmb3IoaSA9IDA7IGkgPCBzaXplb2YoYml0cykgKiA4OyBpKyspIHsKICAgIGlmKGJpdHMgJiAoMSA8PCBpKSkgewogICAgICBzaXplX3QgbGVuID0gc3RybGVuKG5hbWVzW2ldKTsKICAgICAgaWYobikgewogICAgICAgIG4rKzsKICAgICAgICBkYnVmX3B1dHN0cihkYiwgInwiKTsKICAgICAgfQogICAgICBkYnVmX2FwcGVuZChkYiwgbmFtZXNbaV0sIGxlbik7CiAgICAgIG4gKz0gbGVuOwogICAgfQogIH0KICByZXR1cm4gbjsKfQoKc3RydWN0IG1lbW9yeV9ibG9jazsKc3RydWN0IHBvaW50ZXJfcmFuZ2U7CnN0cnVjdCBvZmZzZXRfbGVuZ3RoOwoKdHlwZWRlZiBzdHJ1Y3QgbWVtb3J5X2Jsb2NrIHsKICB1aW50OF90KiBiYXNlOwogIHNpemVfdCBzaXplOwp9IE1lbW9yeUJsb2NrOwoKc3RhdGljIGlubGluZSB2b2lkCmJsb2NrX2luaXQoTWVtb3J5QmxvY2sqIG1iKSB7CiAgbWItPmJhc2UgPSAwOwogIG1iLT5zaXplID0gMDsKfQoKc3RhdGljIGlubGluZSB2b2lkKgpibG9ja19kYXRhKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+YmFzZTsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKYmxvY2tfbGVuZ3RoKE1lbW9yeUJsb2NrKiBtYikgewogIHJldHVybiBtYi0+c2l6ZTsKfQoKc3RhdGljIGlubGluZSBCT09MCmJsb2NrX2FycmF5YnVmZmVyKE1lbW9yeUJsb2NrKiBtYiwgSlNWYWx1ZUNvbnN0IGFiLCBKU0NvbnRleHQqIGN0eCkgewogIHJldHVybiAhIShtYi0+YmFzZSA9IEpTX0dldEFycmF5QnVmZmVyKGN0eCwgJm1iLT5zaXplLCBhYikpOwp9Cgp0eXBlZGVmIHN0cnVjdCBwb2ludGVyX3JhbmdlIHsKICB1aW50OF90ICpzdGFydCwgKmVuZDsKfSBQb2ludGVyUmFuZ2U7CgpzdGF0aWMgaW5saW5lIHZvaWQKcmFuZ2VfaW5pdChQb2ludGVyUmFuZ2UqIHByKSB7CiAgcHItPmVuZCA9IHByLT5zdGFydCA9IDA7Cn0KCnN0YXRpYyBpbmxpbmUgUG9pbnRlclJhbmdlCnJhbmdlX2Zyb20oY29uc3QgTWVtb3J5QmxvY2sqIG1iKSB7CiAgcmV0dXJuIChQb2ludGVyUmFuZ2Upe21iLT5iYXNlLCBtYi0+YmFzZSArIG1iLT5zaXplfTsKfQoKdHlwZWRlZiBzdHJ1Y3Qgb2Zmc2V0X2xlbmd0aCB7CiAgaW50NjRfdCBvZmZzZXQsIGxlbmd0aDsKfSBPZmZzZXRMZW5ndGg7CgpzdGF0aWMgaW5saW5lIHZvaWQKb2Zmc2V0X2luaXQoT2Zmc2V0TGVuZ3RoKiBvbCkgewogIG9sLT5vZmZzZXQgPSAwOwogIG9sLT5sZW5ndGggPSBJTlQ2NF9NQVg7Cn0KCnN0YXRpYyBpbmxpbmUgQk9PTApvZmZzZXRfaXNfZGVmYXVsdChjb25zdCBPZmZzZXRMZW5ndGgqIG9sKSB7CiAgcmV0dXJuIG9sLT5vZmZzZXQgPT0gMCAmJiBvbC0+bGVuZ3RoID09IElOVDY0X01BWDsKfQoKc3RhdGljIGlubGluZSB1aW50OF90KgpvZmZzZXRfZGF0YShjb25zdCBPZmZzZXRMZW5ndGgqIG9sLCBjb25zdCB2b2lkKiB4KSB7CiAgcmV0dXJuICh1aW50OF90Kil4ICsgb2wtPm9mZnNldDsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKb2Zmc2V0X3NpemUoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCwgc2l6ZV90IG4pIHsKICByZXR1cm4gTUlOX05VTShvbC0+bGVuZ3RoLCBuIC0gb2wtPm9mZnNldCk7Cn0KCnN0YXRpYyBpbmxpbmUgTWVtb3J5QmxvY2sKb2Zmc2V0X2Jsb2NrKGNvbnN0IE9mZnNldExlbmd0aCogb2wsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBuKSB7CiAgcmV0dXJuIChNZW1vcnlCbG9jayl7b2Zmc2V0X2RhdGEob2wsIHgpLCBvZmZzZXRfc2l6ZShvbCwgbil9Owp9CgpzdGF0aWMgaW5saW5lIFBvaW50ZXJSYW5nZQpvZmZzZXRfcmFuZ2UoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCwgY29uc3Qgdm9pZCogeCwgc2l6ZV90IG4pIHsKICBNZW1vcnlCbG9jayBtYiA9IG9mZnNldF9ibG9jayhvbCwgeCwgbik7CiAgcmV0dXJuIHJhbmdlX2Zyb20oJm1iKTsKfQoKc3RhdGljIGlubGluZSBPZmZzZXRMZW5ndGgKb2Zmc2V0X3NsaWNlKGNvbnN0IE9mZnNldExlbmd0aCBvbCwgaW50NjRfdCBzdGFydCwgaW50NjRfdCBlbmQpIHsKICBpZihzdGFydCA8IDApCiAgICBzdGFydCA9IG9sLmxlbmd0aCArIChzdGFydCAlIG9sLmxlbmd0aCk7CiAgZWxzZSBpZihzdGFydCA+IG9sLmxlbmd0aCkKICAgIHN0YXJ0ID0gb2wubGVuZ3RoOwogIGlmKGVuZCA8IDApCiAgICBlbmQgPSBvbC5sZW5ndGggKyAoZW5kICUgb2wubGVuZ3RoKTsKICBlbHNlIGlmKGVuZCA+IG9sLmxlbmd0aCkKICAgIGVuZCA9IG9sLmxlbmd0aDsKCiAgcmV0dXJuIChPZmZzZXRMZW5ndGgpe3N0YXJ0LCBlbmQgLSBzdGFydH07Cn0KCnN0YXRpYyBpbmxpbmUgT2Zmc2V0TGVuZ3RoCm9mZnNldF9vZmZzZXQoY29uc3QgT2Zmc2V0TGVuZ3RoKiBvbCwgY29uc3QgT2Zmc2V0TGVuZ3RoKiBieSkgewogIE9mZnNldExlbmd0aCByZXQ7CiAgcmV0Lm9mZnNldCA9IG9sLT5vZmZzZXQgKyBieS0+b2Zmc2V0OwogIHJldC5sZW5ndGggPSBNSU5fTlVNKGJ5LT5sZW5ndGgsIG9sLT5sZW5ndGggLSBieS0+b2Zmc2V0KTsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW5saW5lIE1lbW9yeUJsb2NrCmJsb2NrX3JhbmdlKGNvbnN0IE1lbW9yeUJsb2NrKiBtYiwgc3RydWN0IG9mZnNldF9sZW5ndGgqIHJhbmdlKSB7CiAgTWVtb3J5QmxvY2sgcmV0OwogIHJldC5iYXNlID0gbWItPmJhc2UgKyByYW5nZS0+b2Zmc2V0OwogIHJldC5zaXplID0gTUlOX05VTShyYW5nZS0+bGVuZ3RoLCBtYi0+c2l6ZSAtIHJhbmdlLT5vZmZzZXQpOwogIHJldHVybiByZXQ7Cn0KCnR5cGVkZWYgc3RydWN0IElucHV0QnVmZmVyIHsKICB1aW50OF90KiBkYXRhOwogIHNpemVfdCBwb3MsIHNpemU7CiAgdm9pZCAoKmZyZWUpKEpTQ29udGV4dCosIGNvbnN0IGNoYXIqLCBKU1ZhbHVlKTsKICBKU1ZhbHVlIHZhbHVlOwogIE9mZnNldExlbmd0aCByYW5nZTsKfSBJbnB1dEJ1ZmZlcjsKCnN0YXRpYyBpbmxpbmUgdm9pZAppbnB1dF9idWZmZXJfZnJlZV9kZWZhdWx0KEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBzdHIsIEpTVmFsdWUgdmFsKSB7CiAgaWYoSlNfSXNTdHJpbmcodmFsKSkKICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgc3RyKTsKCiAgaWYoIUpTX0lzVW5kZWZpbmVkKHZhbCkpCiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWwpOwp9CgpJbnB1dEJ1ZmZlciBqc19pbnB1dF9idWZmZXIoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CklucHV0QnVmZmVyIGpzX2lucHV0X2NoYXJzKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwpJbnB1dEJ1ZmZlciBpbnB1dF9idWZmZXJfY2xvbmUoY29uc3QgSW5wdXRCdWZmZXIqIGluLCBKU0NvbnRleHQqIGN0eCk7CkJPT0wgaW5wdXRfYnVmZmVyX3ZhbGlkKGNvbnN0IElucHV0QnVmZmVyKiBpbik7CnZvaWQgaW5wdXRfYnVmZmVyX2R1bXAoY29uc3QgSW5wdXRCdWZmZXIqIGluLCBEeW5CdWYqIGRiKTsKdm9pZCBpbnB1dF9idWZmZXJfZnJlZShJbnB1dEJ1ZmZlciogaW4sIEpTQ29udGV4dCogY3R4KTsKCnN0YXRpYyBpbmxpbmUgdWludDhfdCoKaW5wdXRfYnVmZmVyX2RhdGEoY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIGluLT5kYXRhICsgaW4tPnJhbmdlLm9mZnNldDsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKaW5wdXRfYnVmZmVyX2xlbmd0aChjb25zdCBJbnB1dEJ1ZmZlciogaW4pIHsKICByZXR1cm4gTUlOX05VTShpbi0+cmFuZ2UubGVuZ3RoLCBpbi0+c2l6ZSk7Cn0KCnN0YXRpYyBpbmxpbmUgTWVtb3J5QmxvY2sKaW5wdXRfYnVmZmVyX2Jsb2NrKElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiAoTWVtb3J5QmxvY2spe2lucHV0X2J1ZmZlcl9kYXRhKGluKSwgaW5wdXRfYnVmZmVyX2xlbmd0aChpbil9Owp9CgpzdGF0aWMgaW5saW5lIElucHV0QnVmZmVyCmlucHV0X2J1ZmZlcl9vZmZzZXQoSW5wdXRCdWZmZXIgaW4sIE9mZnNldExlbmd0aCBvZmYpIHsKICBJbnB1dEJ1ZmZlciByZXQgPSBpbjsKCiAgcmV0LmRhdGEgKz0gb2ZmLm9mZnNldDsKICByZXQuc2l6ZSAtPSBvZmYub2Zmc2V0OwoKICBpZihyZXQuc2l6ZSA+IG9mZi5sZW5ndGgpCiAgICByZXQuc2l6ZSA9IG9mZi5sZW5ndGg7CgogIHJldHVybiByZXQ7Cn0KCmNvbnN0IHVpbnQ4X3QqIGlucHV0X2J1ZmZlcl9nZXQoSW5wdXRCdWZmZXIqIGluLCBzaXplX3QqIGxlbnApOwpjb25zdCB1aW50OF90KiBpbnB1dF9idWZmZXJfcGVlayhJbnB1dEJ1ZmZlciogaW4sIHNpemVfdCogbGVucCk7CmNvbnN0IGNoYXIqIGlucHV0X2J1ZmZlcl9jdXJyZW50bGluZShJbnB1dEJ1ZmZlciosIHNpemVfdCogbGVuKTsKc2l6ZV90IGlucHV0X2J1ZmZlcl9jb2x1bW4oSW5wdXRCdWZmZXIqLCBzaXplX3QqIGxlbik7CgpzdGF0aWMgaW50CmlucHV0X2J1ZmZlcl9wZWVrYyhJbnB1dEJ1ZmZlciogaW4sIHNpemVfdCogbGVucCkgewogIGNvbnN0IHVpbnQ4X3QgKnBvcywgKmVuZCwgKm5leHQ7CiAgaW50IGNwOwogIHBvcyA9IGlucHV0X2J1ZmZlcl9kYXRhKGluKSArIGluLT5wb3M7CiAgZW5kID0gaW5wdXRfYnVmZmVyX2RhdGEoaW4pICsgaW5wdXRfYnVmZmVyX2xlbmd0aChpbik7CiAgY3AgPSB1bmljb2RlX2Zyb21fdXRmOChwb3MsIGVuZCAtIHBvcywgJm5leHQpOwogIGlmKGxlbnApCiAgICAqbGVucCA9IG5leHQgLSBwb3M7CgogIHJldHVybiBjcDsKfQoKc3RhdGljIGlubGluZSBpbnQKaW5wdXRfYnVmZmVyX2dldGMoSW5wdXRCdWZmZXIqIGluKSB7CiAgc2l6ZV90IG47CiAgaW50IHJldDsKICByZXQgPSBpbnB1dF9idWZmZXJfcGVla2MoaW4sICZuKTsKICBpbi0+cG9zICs9IG47CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSB1aW50OF90KgppbnB1dF9idWZmZXJfYmVnaW4oY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIGlucHV0X2J1ZmZlcl9kYXRhKGluKTsKfQpzdGF0aWMgaW5saW5lIHVpbnQ4X3QqCmlucHV0X2J1ZmZlcl9lbmQoY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIGlucHV0X2J1ZmZlcl9kYXRhKGluKSArIGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pOwp9CnN0YXRpYyBpbmxpbmUgQk9PTAppbnB1dF9idWZmZXJfZW9mKGNvbnN0IElucHV0QnVmZmVyKiBpbikgewogIHJldHVybiBpbi0+cG9zID09IGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pOwp9CnN0YXRpYyBpbmxpbmUgc2l6ZV90CmlucHV0X2J1ZmZlcl9yZW1haW4oY29uc3QgSW5wdXRCdWZmZXIqIGluKSB7CiAgcmV0dXJuIGlucHV0X2J1ZmZlcl9sZW5ndGgoaW4pIC0gaW4tPnBvczsKfQoKT2Zmc2V0TGVuZ3RoIGpzX29mZnNldF9sZW5ndGgoSlNDb250ZXh0KiwgaW50NjRfdCBzaXplLCBpbnQgYXJnYywgSlNWYWx1ZSBhcmd2W10pOwoKI2VuZGlmIC8qIGRlZmluZWQoQlVGRkVSX1VUSUxTKSAqLwoAAAAAAAAAADIeAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA7hQAAAAAAAD9FAAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"contents": "#include \"char-utils.h\"\n#include \"buffer-utils.h\"\n#include \"utils.h\"\n\nsize_t\nansi_length(const char* str, size_t len) {\n  size_t i, n = 0, p;\n  for(i = 0; i < len;) {\n    if(str[i] == 0x1b && (p = ansi_skip(&str[i], len - i)) > 0) {\n      i += p;\n      continue;\n    }\n    n++;\n    i++;\n  }\n  return n;\n}\n\nsize_t\nansi_skip(const char* str, size_t len) {\n  size_t pos = 0;\n  if(str[pos] == 0x1b) {\n    if(++pos < len && str[pos] == '[') {\n      while(++pos < len)\n        if(is_alphanumeric_char(str[pos]))\n          break;\n      if(++pos < len && str[pos] == '~')\n        ++pos;\n      return pos;\n    }\n  }\n  return 0;\n}\n\nsize_t\nansi_truncate(const char* str, size_t len, size_t limit) {\n  size_t i, n = 0, p;\n  for(i = 0; i < len;) {\n    if((p = ansi_skip(&str[i], len - i)) > 0) {\n      i += p;\n      continue;\n    }\n    n += is_escape_char(str[i]) ? 2 : 1;\n\n    i++;\n    if(n > limit)\n      break;\n  }\n  return i;\n}\n\nint64_t\narray_search(void* a, size_t m, size_t elsz, void* needle) {\n  char* ptr = a;\n  int64_t n, ret;\n  n = m / elsz;\n  for(ret = 0; ret < n; ret++) {\n    if(!memcmp(ptr, needle, elsz))\n      return ret;\n\n    ptr += elsz;\n  }\n  return -1;\n}\n\nchar*\nstr_escape(const char* s) {\n  DynBuf dbuf;\n  dbuf_init2(&dbuf, 0, 0);\n  dbuf_put_escaped(&dbuf, s, strlen(s));\n  dbuf_0(&dbuf);\n  return (char*)dbuf.buf;\n}\n\nchar*\nbyte_escape(const void* s, size_t n) {\n  DynBuf dbuf;\n  dbuf_init2(&dbuf, 0, 0);\n  dbuf_put_escaped(&dbuf, s, n);\n  dbuf_0(&dbuf);\n  return (char*)dbuf.buf;\n}\n\nsize_t\nbyte_findb(const void* haystack, size_t hlen, const void* what, size_t wlen) {\n  size_t i, last;\n  const char* s = (const char*)haystack;\n  if(hlen < wlen)\n    return hlen;\n  last = hlen - wlen;\n  for(i = 0; i <= last; i++) {\n    if(byte_equal(s, wlen, what))\n      return i;\n    s++;\n  }\n  return hlen;\n}\n\nsize_t\nbyte_finds(const void* haystack, size_t hlen, const char* what) {\n  return byte_findb(haystack, hlen, what, strlen(what));\n}\n\nsize_t\nbyte_equal(const void* s, size_t n, const void* t) {\n  return memcmp(s, t, n) == 0;\n}\n\nchar*\ndbuf_at_n(const DynBuf* db, size_t i, size_t* n, char sep) {\n  size_t p, l = 0;\n  for(p = 0; p < db->size; ++p) {\n    if(l == i) {\n      *n = byte_chr((const char*)&db->buf[p], db->size - p, sep);\n      return (char*)&db->buf[p];\n    }\n    if(db->buf[p] == sep)\n      ++l;\n  }\n  *n = 0;\n  return 0;\n}\n\nconst char*\ndbuf_last_line(DynBuf* db, size_t* len) {\n  size_t i;\n\n  if((i = byte_rchr(db->buf, db->size, '\\n')) < db->size)\n    i++;\n  else\n    i = 0;\n\n  if(len)\n    *len = db->size - i;\n\n  return (const char*)&db->buf[i];\n}\n\nint\ndbuf_prepend(DynBuf* s, const uint8_t* data, size_t len) {\n  int ret;\n  if(!(ret = dbuf_reserve_start(s, len)))\n    memcpy(s->buf, data, len);\n\n  return 0;\n}\n\nvoid\ndbuf_put_colorstr(DynBuf* db, const char* str, const char* color, int with_color) {\n  if(with_color)\n    dbuf_putstr(db, color);\n\n  dbuf_putstr(db, str);\n  if(with_color)\n    dbuf_putstr(db, COLOR_NONE);\n}\n\nvoid\ndbuf_put_escaped_pred(DynBuf* db, const char* str, size_t len, int (*pred)(int)) {\n  size_t i = 0, j;\n  char c;\n  while(i < len) {\n    if((j = predicate_find(&str[i], len - i, pred))) {\n      dbuf_append(db, (const uint8_t*)&str[i], j);\n      i += j;\n    }\n    if(i == len)\n      break;\n    dbuf_putc(db, '\\\\');\n\n    if(str[i] == 0x1b) {\n      dbuf_append(db, (const uint8_t*)\"x1b\", 3);\n    } else {\n      int r = pred(str[i]);\n\n      dbuf_putc(db, (r > 1 && r <= 127) ? r : (c = escape_char_letter(str[i])) ? c : str[i]);\n\n      if(r == 'u' || r == 'x')\n        dbuf_printf(db, r == 'u' ? \"%04x\" : \"%02x\", str[i]);\n    }\n    i++;\n  }\n}\n\nvoid\ndbuf_put_escaped_table(DynBuf* db, const char* str, size_t len, const char table[256]) {\n  size_t i = 0, j;\n  char c;\n  while(i < len) {\n    if((j = lookup_find(&str[i], len - i, table))) {\n      dbuf_append(db, (const uint8_t*)&str[i], j);\n      i += j;\n    }\n    if(i == len)\n      break;\n    dbuf_putc(db, '\\\\');\n\n    if(str[i] == 0x1b) {\n      dbuf_append(db, (const uint8_t*)\"x1b\", 3);\n    } else {\n      int r = table[(unsigned char)str[i]];\n\n      dbuf_putc(db, (r > 1 && r <= 127) ? r : (c = escape_char_letter(str[i])) ? c : str[i]);\n\n      if(r == 'u' || r == 'x')\n        dbuf_printf(db, r == 'u' ? \"%04x\" : \"%02x\", str[i]);\n    }\n    i++;\n  }\n}\n\nvoid\ndbuf_put_unescaped_pred(DynBuf* db, const char* str, size_t len, int (*pred)(int)) {\n  size_t i = 0, j;\n  char c;\n  int r;\n  while(i < len) {\n    if((j = byte_chr(&str[i], len - i, '\\\\'))) {\n      dbuf_append(db, (const uint8_t*)&str[i], j);\n      i += j;\n    }\n    if(i == len)\n      break;\n\n    if(!(r = pred(str[++i])))\n      dbuf_putc(db, '\\\\');\n\n    dbuf_putc(db, (r > 1 && r < 256) ? r : str[i]);\n    i++;\n  }\n}\n\nvoid\ndbuf_put_escaped(DynBuf* db, const char* str, size_t len) {\n  static const char tab[256] = {\n      'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 0x62, 0x74, 0x6e, 0x76, 0x66, 0x72, 'x',  'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x',\n      'x', 'x', 'x', 'x', 'x', 'x', 0,   0,   0,    0,    0,    0,    0,    0x27, 0,    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,   0,    0,    0,    0,    0,    0,    0,    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,   0,    0,    0,    0,    0,    0,    0x5c, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,   0,    0,    0,    0,    0,    0,    0,    0,   0,   0,   0,   0,   0,   0,   0,   'x', 0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,   0,    0,    0,    0,    0,    0,    0,    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,   0,    0,    0,    0,    0,    0,    0,    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,   0,    0,    0,    0,    0,    0,    0,    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,   0,    0,    0,    0,    0,    0,    0,    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n      0,   0,   0,   0,   0,   0,   0,   0,   0,    0,    0,    0,    0,    0,    0,    0,   0,   0,   0,   0,   0,   0,\n  };\n\n  return dbuf_put_escaped_table(db, str, len, tab);\n}\n\nvoid\ndbuf_put_value(DynBuf* db, JSContext* ctx, JSValueConst value) {\n  const char* str;\n  size_t len;\n  str = JS_ToCStringLen(ctx, &len, value);\n  dbuf_append(db, str, len);\n  js_cstring_free(ctx, str);\n}\n\nint\ndbuf_reserve_start(DynBuf* s, size_t len) {\n  if(unlikely((s->size + len) > s->allocated_size)) {\n    if(dbuf_realloc(s, s->size + len))\n      return -1;\n  }\n  if(s->size > 0)\n    memcpy(s->buf + len, s->buf, s->size);\n\n  s->size += len;\n  return 0;\n}\n\nsize_t\ndbuf_token_pop(DynBuf* db, char delim) {\n  size_t n, p, len;\n  len = db->size;\n  for(n = db->size; n > 0;) {\n    if((p = byte_rchr(db->buf, n, delim)) == n) {\n      db->size = 0;\n      break;\n    }\n    if(p > 0 && db->buf[p - 1] == '\\\\') {\n      n = p - 1;\n      continue;\n    }\n    db->size = p;\n    break;\n  }\n  return len - db->size;\n}\n\nsize_t\ndbuf_token_push(DynBuf* db, const char* str, size_t len, char delim) {\n  size_t pos;\n  if(db->size)\n    dbuf_putc(db, delim);\n\n  pos = db->size;\n  dbuf_put_escaped_pred(db, str, len, is_dot_char);\n  return db->size - pos;\n}\n\nJSValue\ndbuf_tostring_free(DynBuf* s, JSContext* ctx) {\n  JSValue r;\n  r = JS_NewStringLen(ctx, s->buf ? (const char*)s->buf : \"\", s->buf ? s->size : 0);\n  dbuf_free(s);\n  return r;\n}\n\nssize_t\ndbuf_load(DynBuf* s, const char* filename) {\n  FILE* fp;\n  size_t nbytes = 0;\n  if((fp = fopen(filename, \"rb\"))) {\n    char buf[4096];\n    size_t r;\n    while(!feof(fp)) {\n      if((r = fread(buf, 1, sizeof(buf), fp)) == 0)\n        return -1;\n      dbuf_put(s, (uint8_t const*)buf, r);\n      nbytes += r;\n    }\n    fclose(fp);\n  }\n  return nbytes;\n}\n\nInputBuffer\njs_input_buffer(JSContext* ctx, JSValueConst value) {\n  InputBuffer ret = {0, 0, 0, &input_buffer_free_default, JS_UNDEFINED};\n  int64_t offset = 0, length = INT64_MAX;\n\n  offset_init(&ret.range);\n\n  if(js_is_typedarray(value) || js_is_dataview(ctx, value)) {\n    JSValue arraybuf, byteoffs, bytelen;\n    arraybuf = JS_GetPropertyStr(ctx, value, \"buffer\");\n    bytelen = JS_GetPropertyStr(ctx, value, \"byteLength\");\n    if(JS_IsNumber(bytelen))\n      JS_ToInt64(ctx, &length, bytelen);\n    JS_FreeValue(ctx, bytelen);\n    byteoffs = JS_GetPropertyStr(ctx, value, \"byteOffset\");\n    if(JS_IsNumber(byteoffs))\n      JS_ToInt64(ctx, &offset, byteoffs);\n    JS_FreeValue(ctx, byteoffs);\n    value = arraybuf;\n  }\n\n  if(js_value_isclass(ctx, value, JS_CLASS_ARRAY_BUFFER) || js_is_arraybuffer(ctx, value)) {\n    ret.value = JS_DupValue(ctx, value);\n    ret.data = JS_GetArrayBuffer(ctx, &ret.size, ret.value);\n  } else {\n    ret.value = JS_EXCEPTION;\n    // JS_ThrowTypeError(ctx, \"Invalid type for input buffer\");\n  }\n\n  if(offset < 0)\n    ret.range.offset = ret.size + offset % ret.size;\n  else if(offset > ret.size)\n    ret.range.offset = ret.size;\n  else\n    ret.range.offset = offset;\n\n  if(length >= 0 && length < ret.size)\n    ret.range.length = length;\n\n  return ret;\n}\n\nInputBuffer\njs_input_chars(JSContext* ctx, JSValueConst value) {\n  InputBuffer ret = {0, 0, 0, &input_buffer_free_default, JS_UNDEFINED};\n  int64_t offset = 0, length = INT64_MAX;\n\n  offset_init(&ret.range);\n\n  if(JS_IsString(value)) {\n    ret.data = (uint8_t*)JS_ToCStringLen(ctx, &ret.size, value);\n    ret.value = JS_DupValue(ctx, value);\n    ret.free = &input_buffer_free_default;\n  } else {\n    ret = js_input_buffer(ctx, value);\n  }\n\n  return ret;\n}\n\nBOOL\ninput_buffer_valid(const InputBuffer* in) {\n  return !JS_IsException(in->value);\n}\n\nInputBuffer\ninput_buffer_clone(const InputBuffer* in, JSContext* ctx) {\n  InputBuffer ret = js_input_buffer(ctx, in->value);\n\n  ret.pos = in->pos;\n  ret.size = in->size;\n  ret.free = in->free;\n\n  return ret;\n}\n\nvoid\ninput_buffer_dump(const InputBuffer* in, DynBuf* db) {\n  dbuf_printf(db, \"(InputBuffer){ .data = %p, .size = %zu, .pos = %zu, .free = %p }\", in->data, in->size, in->pos, in->free);\n}\n\nvoid\ninput_buffer_free(InputBuffer* in, JSContext* ctx) {\n  if(in->data) {\n    in->free(ctx, (const char*)in->data, in->value);\n    in->data = 0;\n    in->size = 0;\n    in->pos = 0;\n    in->value = JS_UNDEFINED;\n  }\n}\n\nconst uint8_t*\ninput_buffer_peek(InputBuffer* in, size_t* lenp) {\n  input_buffer_peekc(in, lenp);\n  return input_buffer_data(in) + in->pos;\n}\n\nconst uint8_t*\ninput_buffer_get(InputBuffer* in, size_t* lenp) {\n  size_t n;\n  const uint8_t* ret;\n  if(lenp == 0)\n    lenp = &n;\n  ret = input_buffer_peek(in, lenp);\n  in->pos += *lenp;\n  return ret;\n}\n\nconst char*\ninput_buffer_currentline(InputBuffer* in, size_t* len) {\n  size_t i;\n\n  if((i = byte_rchr(input_buffer_data(in), in->pos, '\\n')) < in->pos)\n    i++;\n\n  if(len)\n    *len = in->pos - i;\n\n  return (const char*)&input_buffer_data(in)[i];\n}\n\nsize_t\ninput_buffer_column(InputBuffer* in, size_t* len) {\n  size_t i;\n\n  if((i = byte_rchr(input_buffer_data(in), in->pos, '\\n')) < in->pos)\n    i++;\n\n  return in->pos - i;\n}\n\nOffsetLength\njs_offset_length(JSContext* ctx, int64_t size, int argc, JSValueConst argv[]) {\n  int64_t off = 0, len = size;\n\n  if(argc >= 1 && JS_IsNumber(argv[0]))\n    JS_ToInt64(ctx, &off, argv[0]);\n  if(argc >= 2 && JS_IsNumber(argv[1]))\n    JS_ToInt64(ctx, &len, argv[1]);\n\n  /* if(off >= 0)\n     off = MIN_NUM(off, size);\n   else\n  */\n  off = ((off % size) + off) % size;\n\n  if(len >= 0)\n    len = MIN_NUM(len, size - off);\n  else\n    len = size - off;\n\n  return (OffsetLength){off, len};\n}\n",
			"file": "buffer-utils.c",
			"file_size": 11531,
			"file_write_time": 132770140952334745,
			"settings":
			{
				"buffer_size": 11531,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/roman/Sources/plot-cv/quickjs/qjs-modules/ringbuffer.h",
			"settings":
			{
				"buffer_size": 2386,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					1,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAsEQAAI2lmbmRlZiBSSU5HQlVGRkVSX0gKI2RlZmluZSBSSU5HQlVGRkVSX0gKCiNpbmNsdWRlICJ2ZWN0b3IuaCIKCnR5cGVkZWYgdW5pb24gcmluZ2J1ZmZlciB7CiAgc3RydWN0IHsKICAgIHVpbnQ4X3QqIGRhdGE7CiAgICBzaXplX3Qgc2l6ZSwgY2FwYWNpdHk7CiAgICBCT09MIGVycm9yOwogICAgRHluQnVmUmVhbGxvY0Z1bmMqIHJlYWxsb2NfZnVuYzsKICAgIHZvaWQqIG9wYXF1ZTsKICAgIHZvbGF0aWxlIHVpbnQzMl90IHRhaWwsIGhlYWQ7CiAgfTsKICBEeW5CdWYgZGJ1ZjsKICBWZWN0b3IgdmVjOwoKfSBSaW5nQnVmZmVyOwoKI2RlZmluZSBSSU5HQlVGRkVSX0lOSVQoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgeyAwLCAwLCAwLCAwLCAmcmluZ2J1ZmZlcl9kZWZhdWx0X3JlYWxsb2MsIDAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICB9CgojZGVmaW5lIHJpbmdidWZmZXJfaW5pdChyYiwgY3R4KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICB2ZWN0b3JfaW5pdCgmKHJiKS0+dmVjLCBjdHgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgdmVjdG9yX2FsbG9jYXRlKCYocmIpLT52ZWMsIDEsIDEwMjMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICB9IHdoaWxlKDApCiNkZWZpbmUgcmluZ2J1ZmZlcl9pbml0X3J0KHJiLCBydCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgIHZlY3Rvcl9pbml0X3J0KCYocmIpLT52ZWMsIHJ0KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICB2ZWN0b3JfYWxsb2NhdGUoJihyYiktPnZlYywgMSwgMTAyMyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIH0gd2hpbGUoMCkKI2RlZmluZSBSSU5HQlVGRkVSKGN0eCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgKFJpbmdCdWZmZXIpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgeyAwLCAwLCAwLCAwLCAoRHluQnVmUmVhbGxvY0Z1bmMqKSZqc19yZWFsbG9jLCBjdHgsIDAsIDAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICB9CiNkZWZpbmUgUklOR0JVRkZFUl9SVChydCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIChSaW5nQnVmZmVyKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgIHsgMCwgMCwgMCwgMCwgKER5bkJ1ZlJlYWxsb2NGdW5jKikmanNfcmVhbGxvY19ydCwgcnQgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgfQojZGVmaW5lIHJpbmdidWZmZXJfZnJlZShyYikgdmVjdG9yX2ZyZWUoJihyYiktPnZlYykKI2RlZmluZSByaW5nYnVmZmVyX2JlZ2luKHJiKSAmcmluZ2J1ZmZlcl90YWlsKHJiKQojZGVmaW5lIHJpbmdidWZmZXJfZW5kKHJiKSAmcmluZ2J1ZmZlcl9oZWFkKHJiKQojZGVmaW5lIHJpbmdidWZmZXJfaGVhZChyYikgKHJiKS0+ZGF0YVsocmIpLT5oZWFkXQojZGVmaW5lIHJpbmdidWZmZXJfdGFpbChyYikgKHJiKS0+ZGF0YVsocmIpLT50YWlsXQoKI2RlZmluZSByaW5nYnVmZmVyX2VtcHR5KHJiKSAoKHJiKS0+dGFpbCA9PSAocmIpLT5oZWFkKQojZGVmaW5lIHJpbmdidWZmZXJfZnVsbChyYikgKChyYiktPnNpemUgPT0gKHJiKS0+aGVhZCAtIChyYiktPnRhaWwpCiNkZWZpbmUgcmluZ2J1ZmZlcl93cmFwcGVkKHJiKSAoKHJiKS0+aGVhZCA8IChyYiktPnRhaWwpCiNkZWZpbmUgcmluZ2J1ZmZlcl9jb250aW51b3VzKHJiKSAoKHJiKS0+aGVhZCA+PSAocmIpLT50YWlsKQoKdm9pZCByaW5nYnVmZmVyX3Jlc2V0KFJpbmdCdWZmZXIqKTsKdm9pZCByaW5nYnVmZmVyX3F1ZXVlKFJpbmdCdWZmZXIqLCB1aW50OF90IGRhdGEpOwpCT09MIHJpbmdidWZmZXJfZGVxdWV1ZShSaW5nQnVmZmVyKiwgdWludDhfdCogZGF0YSk7CnNzaXplX3QgcmluZ2J1ZmZlcl93cml0ZShSaW5nQnVmZmVyKiwgY29uc3Qgdm9pZCogeCwgc2l6ZV90IGxlbik7CnNzaXplX3QgcmluZ2J1ZmZlcl9yZWFkKFJpbmdCdWZmZXIqLCB2b2lkKiB4LCBzaXplX3QgbGVuKTsKdWludDhfdCogcmluZ2J1ZmZlcl9wZWVrKFJpbmdCdWZmZXIqLCBzaXplX3QgaW5kZXgpOwp2b2lkIHJpbmdidWZmZXJfbm9ybWFsaXplKFJpbmdCdWZmZXIqKTsKQk9PTCByaW5nYnVmZmVyX3Jlc2l6ZShSaW5nQnVmZmVyKiwgc2l6ZV90KTsKQk9PTCByaW5nYnVmZmVyX2FsbG9jYXRlKFJpbmdCdWZmZXIqLCBzaXplX3QpOwoKc3RhdGljIGlubGluZSBzaXplX3QKcmluZ2J1ZmZlcl9sZW5ndGgoUmluZ0J1ZmZlciogcmIpIHsKICBpZihyaW5nYnVmZmVyX2NvbnRpbnVvdXMocmIpKQogICAgcmV0dXJuIHJiLT5oZWFkIC0gcmItPnRhaWw7CgogIHJldHVybiAocmItPnNpemUgLSByYi0+dGFpbCkgKyByYi0+aGVhZDsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKcmluZ2J1ZmZlcl9jb250aW51b3VzX2xlbmd0aChSaW5nQnVmZmVyKiByYikgewogIGlmKHJpbmdidWZmZXJfd3JhcHBlZChyYikpCiAgICByZXR1cm4gcmItPnNpemUgLSByYi0+dGFpbDsKCiAgcmV0dXJuIHJpbmdidWZmZXJfbGVuZ3RoKHJiKTsKfQoKc3RhdGljIGlubGluZSB1aW50MzJfdApyaW5nYnVmZmVyX2F2YWlsKFJpbmdCdWZmZXIqIHJiKSB7CiAgLyppZihyaW5nYnVmZmVyX2NvbnRpbnVvdXMocmIpKQogICAgcmV0dXJuIHJiLT5oZWFkIC0gcmItPnRhaWw7Ki8KCiAgcmV0dXJuIHJiLT5zaXplIC0gcmluZ2J1ZmZlcl9sZW5ndGgocmIpOwp9CgojZW5kaWYgLyogZGVmaW5lZChSSU5HQlVGRkVSX0gpICovCgAAAAAAAAAALBEAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAWwAAAAAAAABbAAAAAAAAAAAAAAAAAPC/"
				],
				[
					2,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAsEQAAI2lmbmRlZiBSSU5HQlVGRkVSX0gKI2RlZmluZSBSSU5HQlVGRkVSX0gKCiNpbmNsdWRlICJ2ZWN0b3IuaCIKCnR5cGVkZWYgdW5pb24gcmluZ2J1ZmZlciB7CiAgc3RydWN0IHsKICAgIHVpbnQ4X3QqIGRhdGE7CiAgICBzaXplX3Qgc2l6ZSwgY2FwYWNpdHk7CiAgICBCT09MIGVycm9yOwogICAgRHluQnVmUmVhbGxvY0Z1bmMqIHJlYWxsb2NfZnVuYzsKICAgIHZvaWQqIG9wYXF1ZTsKICAgIHZvbGF0aWxlIHVpbnQzMl90IHRhaWwsIGhlYWQ7CiAgfTsKICBEeW5CdWYgZGJ1ZjsKICBWZWN0b3IgdmVjOwoKfSBSaW5nQnVmZmVyOwoKI2RlZmluZSBSSU5HQlVGRkVSX0lOSVQoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgeyAwLCAwLCAwLCAwLCAmcmluZ2J1ZmZlcl9kZWZhdWx0X3JlYWxsb2MsIDAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICB9CgojZGVmaW5lIHJpbmdidWZmZXJfaW5pdChyYiwgY3R4KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICB2ZWN0b3JfaW5pdCgmKHJiKS0+dmVjLCBjdHgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgdmVjdG9yX2FsbG9jYXRlKCYocmIpLT52ZWMsIDEsIDEwMjMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICB9IHdoaWxlKDApCiNkZWZpbmUgcmluZ2J1ZmZlcl9pbml0X3J0KHJiLCBydCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgIHZlY3Rvcl9pbml0X3J0KCYocmIpLT52ZWMsIHJ0KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICB2ZWN0b3JfYWxsb2NhdGUoJihyYiktPnZlYywgMSwgMTAyMyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIH0gd2hpbGUoMCkKI2RlZmluZSBSSU5HQlVGRkVSKGN0eCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgKFJpbmdCdWZmZXIpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgeyAwLCAwLCAwLCAwLCAoRHluQnVmUmVhbGxvY0Z1bmMqKSZqc19yZWFsbG9jLCBjdHgsIDAsIDAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICB9CiNkZWZpbmUgUklOR0JVRkZFUl9SVChydCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIChSaW5nQnVmZmVyKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgIHsgMCwgMCwgMCwgMCwgKER5bkJ1ZlJlYWxsb2NGdW5jKikmanNfcmVhbGxvY19ydCwgcnQgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgfQojZGVmaW5lIHJpbmdidWZmZXJfZnJlZShyYikgdmVjdG9yX2ZyZWUoJihyYiktPnZlYykKI2RlZmluZSByaW5nYnVmZmVyX2JlZ2luKHJiKSAmcmluZ2J1ZmZlcl90YWlsKHJiKQojZGVmaW5lIHJpbmdidWZmZXJfZW5kKHJiKSAmcmluZ2J1ZmZlcl9oZWFkKHJiKQojZGVmaW5lIHJpbmdidWZmZXJfaGVhZChyYikgKHJiKS0+ZGF0YVsocmIpLT5oZWFkXQojZGVmaW5lIHJpbmdidWZmZXJfdGFpbChyYikgKHJiKS0+ZGF0YVsocmIpLT50YWlsXQoKI2RlZmluZSByaW5nYnVmZmVyX2VtcHR5KHJiKSAoKHJiKS0+dGFpbCA9PSAocmIpLT5oZWFkKQojZGVmaW5lIHJpbmdidWZmZXJfZnVsbChyYikgKChyYiktPnNpemUgPT0gKHJiKS0+aGVhZCAtIChyYiktPnRhaWwpCiNkZWZpbmUgcmluZ2J1ZmZlcl93cmFwcGVkKHJiKSAoKHJiKS0+aGVhZCA8IChyYiktPnRhaWwpCiNkZWZpbmUgcmluZ2J1ZmZlcl9jb250aW51b3VzKHJiKSAoKHJiKS0+aGVhZCA+PSAocmIpLT50YWlsKQoKdm9pZCByaW5nYnVmZmVyX3Jlc2V0KFJpbmdCdWZmZXIqKTsKdm9pZCByaW5nYnVmZmVyX3F1ZXVlKFJpbmdCdWZmZXIqLCB1aW50OF90IGRhdGEpOwpCT09MIHJpbmdidWZmZXJfZGVxdWV1ZShSaW5nQnVmZmVyKiwgdWludDhfdCogZGF0YSk7CnNzaXplX3QgcmluZ2J1ZmZlcl93cml0ZShSaW5nQnVmZmVyKiwgY29uc3Qgdm9pZCogeCwgc2l6ZV90IGxlbik7CnNzaXplX3QgcmluZ2J1ZmZlcl9yZWFkKFJpbmdCdWZmZXIqLCB2b2lkKiB4LCBzaXplX3QgbGVuKTsKdWludDhfdCogcmluZ2J1ZmZlcl9wZWVrKFJpbmdCdWZmZXIqLCBzaXplX3QgaW5kZXgpOwp2b2lkIHJpbmdidWZmZXJfbm9ybWFsaXplKFJpbmdCdWZmZXIqKTsKQk9PTCByaW5nYnVmZmVyX3Jlc2l6ZShSaW5nQnVmZmVyKiwgc2l6ZV90KTsKQk9PTCByaW5nYnVmZmVyX2FsbG9jYXRlKFJpbmdCdWZmZXIqLCBzaXplX3QpOwoKc3RhdGljIGlubGluZSBzaXplX3QKcmluZ2J1ZmZlcl9sZW5ndGgoUmluZ0J1ZmZlciogcmIpIHsKICBpZihyaW5nYnVmZmVyX2NvbnRpbnVvdXMocmIpKQogICAgcmV0dXJuIHJiLT5oZWFkIC0gcmItPnRhaWw7CgogIHJldHVybiAocmItPnNpemUgLSByYi0+dGFpbCkgKyByYi0+aGVhZDsKfQoKc3RhdGljIGlubGluZSBzaXplX3QKcmluZ2J1ZmZlcl9jb250aW51b3VzX2xlbmd0aChSaW5nQnVmZmVyKiByYikgewogIGlmKHJpbmdidWZmZXJfd3JhcHBlZChyYikpCiAgICByZXR1cm4gcmItPnNpemUgLSByYi0+dGFpbDsKCiAgcmV0dXJuIHJpbmdidWZmZXJfbGVuZ3RoKHJiKTsKfQoKc3RhdGljIGlubGluZSB1aW50MzJfdApyaW5nYnVmZmVyX2F2YWlsKFJpbmdCdWZmZXIqIHJiKSB7CiAgLyppZihyaW5nYnVmZmVyX2NvbnRpbnVvdXMocmIpKQogICAgcmV0dXJuIHJiLT5oZWFkIC0gcmItPnRhaWw7Ki8KCiAgcmV0dXJuIHJiLT5zaXplIC0gcmluZ2J1ZmZlcl9sZW5ndGgocmIpOwp9CgojZW5kaWYgLyogZGVmaW5lZChSSU5HQlVGRkVSX0gpICovCgAAAAAAAAAAUgkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAWwAAAAAAAABbAAAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "utils.c",
			"settings":
			{
				"buffer_size": 55408,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					2,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAB82AAAI3VuZGVmIF9JU09DOTlfU09VUkNFCiNkZWZpbmUgX0lTT0M5OV9TT1VSQ0UgMQoKI2luY2x1ZGUgInV0aWxzLmgiCiNpbmNsdWRlICJsaXN0LmgiCiNpbmNsdWRlICJjdXRpbHMuaCIKI2luY2x1ZGUgInZlY3Rvci5oIgojaW5jbHVkZSAibGlicmVnZXhwLmgiCiNpbmNsdWRlICJxdWlja2pzLWludGVybmFsLmgiCiNpbmNsdWRlICJidWZmZXItdXRpbHMuaCIKI2luY2x1ZGUgPHRpbWUuaD4KI2luY2x1ZGUgPG1hdGguaD4KI2luY2x1ZGUgPGVycm5vLmg+CiNpbmNsdWRlIDxzaWduYWwuaD4KI2luY2x1ZGUgPHN5cy9zdGF0Lmg+CiNpbmNsdWRlIDxzeXMvdGltZS5oPgojaW5jbHVkZSA8cXVpY2tqcy1saWJjLmg+Cgp2b2lkIHFzb3J0X3Iodm9pZCogYmFzZSwgc2l6ZV90IG5tZW1iLCBzaXplX3Qgc2l6ZSwgaW50ICgqY29tcGFyKShjb25zdCB2b2lkKiwgY29uc3Qgdm9pZCosIHZvaWQqKSwgdm9pZCogcHRyKTsKCiNpZm5kZWYgSU5GSU5JVFkKI2RlZmluZSBJTkZJTklUWSBfX2J1aWx0aW5faW5mKCkKI2VuZGlmCgpWSVNJQkxFIGNvbnN0IGNoYXIqIGpzX2RlZmF1bHRfbW9kdWxlX3BhdGggPSAiLiIKI2lmZGVmIENPTkZJR19QUkVGSVgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjoiIENPTkZJR19QUkVGSVggIi9saWIvcXVpY2tqcyIKI2VuZGlmCiAgICA7CgojaWZkZWYgVVNFX1dPUktFUgojaW5jbHVkZSA8cHRocmVhZC5oPgojaW5jbHVkZSA8c3RkYXRvbWljLmg+CgpzdGF0aWMgaW50CmF0b21pY19hZGRfaW50KGludCogcHRyLCBpbnQgdikgewogIHJldHVybiBhdG9taWNfZmV0Y2hfYWRkKChfQXRvbWljKHVpbnQzMl90KSopcHRyLCB2KSArIHY7Cn0KI2VuZGlmCgojaWYgZGVmaW5lZChfX2xpbnV4X18pIHx8IGRlZmluZWQoX19BUFBMRV9fKQp1aW50NjRfdAp0aW1lX3VzKHZvaWQpIHsKICBzdHJ1Y3QgdGltZXNwZWMgdHM7CiAgY2xvY2tfZ2V0dGltZShDTE9DS19NT05PVE9OSUMsICZ0cyk7CiAgcmV0dXJuICh1aW50NjRfdCl0cy50dl9zZWMgKiAxMDAwMDAwICsgKHRzLnR2X25zZWMgLyAxMDAwKTsKfQojZWxzZQovKiBtb3JlIHBvcnRhYmxlLCBidXQgZG9lcyBub3Qgd29yayBpZiB0aGUgZGF0ZSBpcyB1cGRhdGVkICovCnVpbnQ2NF90CnRpbWVfdXModm9pZCkgewogIHN0cnVjdCB0aW1ldmFsIHR2OwogIGdldHRpbWVvZmRheSgmdHYsIDApOwogIHJldHVybiAoaW50NjRfdCl0di50dl9zZWMgKiAxMDAwMDAwICsgdHYudHZfdXNlYzsKfQojZW5kaWYKCmludApyZWdleHBfZmxhZ3NfZnJvbXN0cmluZyhjb25zdCBjaGFyKiBzKSB7CiAgaW50IGZsYWdzID0gMDsKCiAgaWYoc3RyX2NvbnRhaW5zKHMsICdnJykpCiAgICBmbGFncyB8PSBMUkVfRkxBR19HTE9CQUw7CiAgaWYoc3RyX2NvbnRhaW5zKHMsICdpJykpCiAgICBmbGFncyB8PSBMUkVfRkxBR19JR05PUkVDQVNFOwogIGlmKHN0cl9jb250YWlucyhzLCAnbScpKQogICAgZmxhZ3MgfD0gTFJFX0ZMQUdfTVVMVElMSU5FOwogIGlmKHN0cl9jb250YWlucyhzLCAncycpKQogICAgZmxhZ3MgfD0gTFJFX0ZMQUdfRE9UQUxMOwogIGlmKHN0cl9jb250YWlucyhzLCAndScpKQogICAgZmxhZ3MgfD0gTFJFX0ZMQUdfVVRGMTY7CiAgaWYoc3RyX2NvbnRhaW5zKHMsICd5JykpCiAgICBmbGFncyB8PSBMUkVfRkxBR19TVElDS1k7CgogIHJldHVybiBmbGFnczsKfQoKaW50CnJlZ2V4cF9mbGFnc190b3N0cmluZyhpbnQgZmxhZ3MsIGNoYXIqIGJ1ZikgewogIGNoYXIqIG91dCA9IGJ1ZjsKCiAgaWYoZmxhZ3MgJiBMUkVfRkxBR19HTE9CQUwpCiAgICAqb3V0KysgPSAnZyc7CiAgaWYoZmxhZ3MgJiBMUkVfRkxBR19JR05PUkVDQVNFKQogICAgKm91dCsrID0gJ2knOwogIGlmKGZsYWdzICYgTFJFX0ZMQUdfTVVMVElMSU5FKQogICAgKm91dCsrID0gJ20nOwogIGlmKGZsYWdzICYgTFJFX0ZMQUdfRE9UQUxMKQogICAgKm91dCsrID0gJ3MnOwogIGlmKGZsYWdzICYgTFJFX0ZMQUdfVVRGMTYpCiAgICAqb3V0KysgPSAndSc7CiAgaWYoZmxhZ3MgJiBMUkVfRkxBR19TVElDS1kpCiAgICAqb3V0KysgPSAneSc7CgogICpvdXQgPSAnXDAnOwogIHJldHVybiBvdXQgLSBidWY7Cn0KClJlZ0V4cApyZWdleHBfZnJvbV9hcmd2KGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdLCBKU0NvbnRleHQqIGN0eCkgewogIFJlZ0V4cCByZSA9IHswLCAwLCAwfTsKICBjb25zdCBjaGFyKiBmbGFnc3RyOwogIGFzc2VydChhcmdjID4gMCk7CiAgaWYoanNfaXNfcmVnZXhwKGN0eCwgYXJndlswXSkpIHsKICAgIHJlLnNvdXJjZSA9IGpzX2dldF9wcm9wZXJ0eXN0cl9zdHJpbmdsZW4oY3R4LCBhcmd2WzBdLCAic291cmNlIiwgJnJlLmxlbik7CiAgICByZS5mbGFncyA9IHJlZ2V4cF9mbGFnc19mcm9tc3RyaW5nKChmbGFnc3RyID0ganNfZ2V0X3Byb3BlcnR5c3RyX2NzdHJpbmcoY3R4LCBhcmd2WzBdLCAiZmxhZ3MiKSkpOwogICAganNfY3N0cmluZ19mcmVlKGN0eCwgZmxhZ3N0cik7CiAgfSBlbHNlIHsKICAgIHJlLnNvdXJjZSA9IGpzX3Rvc3RyaW5nbGVuKGN0eCwgJnJlLmxlbiwgYXJndlswXSk7CiAgICBpZihhcmdjID4gMSAmJiBKU19Jc1N0cmluZyhhcmd2WzFdKSkgewogICAgICByZS5mbGFncyA9IHJlZ2V4cF9mbGFnc19mcm9tc3RyaW5nKChmbGFnc3RyID0gSlNfVG9DU3RyaW5nKGN0eCwgYXJndlsxXSkpKTsKICAgICAganNfY3N0cmluZ19mcmVlKGN0eCwgZmxhZ3N0cik7CiAgICB9CiAgfQogIHJldHVybiByZTsKfQoKUmVnRXhwCnJlZ2V4cF9mcm9tX2RidWYoRHluQnVmKiBkYnVmLCBpbnQgZmxhZ3MpIHsKICBSZWdFeHAgcmUgPSB7KGNoYXIqKWRidWYtPmJ1ZiwgZGJ1Zi0+c2l6ZSwgZmxhZ3N9OwogIGRidWYtPmJ1ZiA9IDA7CiAgZGJ1Zi0+YWxsb2NhdGVkX3NpemUgPSAwOwogIGRidWYtPnNpemUgPSAwOwogIHJldHVybiByZTsKfQoKdWludDhfdCoKcmVnZXhwX2NvbXBpbGUoUmVnRXhwIHJlLCBKU0NvbnRleHQqIGN0eCkgewogIGNoYXIgZXJyb3JfbXNnWzY0XTsKICBpbnQgbGVuID0gMDsKICB1aW50OF90KiBieXRlY29kZTsKICBpZighKGJ5dGVjb2RlID0gbHJlX2NvbXBpbGUoJmxlbiwgZXJyb3JfbXNnLCBzaXplb2YoZXJyb3JfbXNnKSwgcmUuc291cmNlLCByZS5sZW4sIHJlLmZsYWdzLCBjdHgpKSkKICAgIEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJFcnJvciBjb21waWxpbmcgcmVnZXggLyUuKnMvOiAlcyIsIChpbnQpcmUubGVuLCByZS5zb3VyY2UsIGVycm9yX21zZyk7CgogIHJldHVybiBieXRlY29kZTsKfQoKSlNWYWx1ZQpyZWdleHBfdG9fdmFsdWUoUmVnRXhwIHJlLCBKU0NvbnRleHQqIGN0eCkgewogIGNoYXIgZmxhZ3N0clszMl0gPSB7MH07CiAgc2l6ZV90IGZsYWdsZW4gPSByZWdleHBfZmxhZ3NfdG9zdHJpbmcocmUuZmxhZ3MsIGZsYWdzdHIpOwogIEpTVmFsdWVDb25zdCBhcmdzWzJdID0ge0pTX05ld1N0cmluZ0xlbihjdHgsIHJlLnNvdXJjZSwgcmUubGVuKSwgSlNfTmV3U3RyaW5nTGVuKGN0eCwgZmxhZ3N0ciwgZmxhZ2xlbil9OwogIEpTVmFsdWUgcmVnZXgsIGN0b3IgPSBqc19nbG9iYWxfZ2V0KGN0eCwgIlJlZ0V4cCIpOwogIHJlZ2V4ID0gSlNfQ2FsbENvbnN0cnVjdG9yKGN0eCwgY3RvciwgMiwgYXJncyk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgYXJnc1swXSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgYXJnc1sxXSk7CiAgcmV0dXJuIHJlZ2V4Owp9CgppbnQ2NF90CmpzX2FycmF5X2xlbmd0aChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IGFycmF5KSB7CiAgaW50NjRfdCBsZW4gPSAtMTsKICBpZihKU19Jc0FycmF5KGN0eCwgYXJyYXkpIHx8IGpzX2lzX3R5cGVkYXJyYXkoYXJyYXkpKSB7CiAgICBKU1ZhbHVlIGxlbmd0aCA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgYXJyYXksICJsZW5ndGgiKTsKICAgIEpTX1RvSW50NjQoY3R4LCAmbGVuLCBsZW5ndGgpOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgbGVuZ3RoKTsKICB9CiAgcmV0dXJuIGxlbjsKfQoKdm9pZApqc19hcnJheV9jbGVhcihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IGFycmF5KSB7CiAgaW50NjRfdCBsZW4gPSBqc19hcnJheV9sZW5ndGgoY3R4LCBhcnJheSk7CiAgSlNWYWx1ZSByZXQ7CiAgSlNBdG9tIHNwbGljZSA9IEpTX05ld0F0b20oY3R4LCAic3BsaWNlIik7CiAgSlNWYWx1ZUNvbnN0IGFyZ3NbMl0gPSB7SlNfTmV3SW50NjQoY3R4LCAwKSwgSlNfTmV3SW50NjQoY3R4LCBsZW4pfTsKCiAgcmV0ID0gSlNfSW52b2tlKGN0eCwgYXJyYXksIHNwbGljZSwgMiwgYXJncyk7CiAgSlNfRnJlZUF0b20oY3R4LCBzcGxpY2UpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHJldCk7CgogIGFzc2VydChqc19hcnJheV9sZW5ndGgoY3R4LCBhcnJheSkgPT0gMCk7Cn0KCmNoYXIqKgpqc19hcnJheV90b19hcmd2KEpTQ29udGV4dCogY3R4LCBpbnQqIGFyZ2NwLCBKU1ZhbHVlQ29uc3QgYXJyYXkpIHsKICBpbnQgaSwgbGVuID0ganNfYXJyYXlfbGVuZ3RoKGN0eCwgYXJyYXkpOwogIGNoYXIqKiByZXQgPSBqc19tYWxsb2N6KGN0eCwgc2l6ZW9mKGNoYXIqKSAqIChsZW4gKyAxKSk7CiAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgIEpTVmFsdWUgaXRlbSA9IEpTX0dldFByb3BlcnR5VWludDMyKGN0eCwgYXJyYXksIGkpOwogICAgcmV0W2ldID0ganNfdG9zdHJpbmcoY3R4LCBpdGVtKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGl0ZW0pOwogIH0KICBpZihhcmdjcCkKICAgICphcmdjcCA9IGxlbjsKICByZXR1cm4gcmV0Owp9CgppbnQKanNfYXJyYXlfY29weXMoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBhcnJheSwgaW50IG4sIGNoYXIqKiBzdHJhKSB7CiAgaW50IGksIGxlbiA9IE1JTl9OVU0obiwganNfYXJyYXlfbGVuZ3RoKGN0eCwgYXJyYXkpKTsKICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgSlNWYWx1ZSBpdGVtID0gSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCBhcnJheSwgaSk7CiAgICBpZihzdHJhW2ldKQogICAgICBqc19mcmVlKGN0eCwgc3RyYVtpXSk7CiAgICBzdHJhW2ldID0ganNfdG9zdHJpbmcoY3R4LCBpdGVtKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGl0ZW0pOwogIH0KICByZXR1cm4gaTsKfQoKaW50CmpzX3N0cnZfY29weXMoSlNDb250ZXh0KiBjdHgsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbiwgY2hhcioqIHN0cmEpIHsKICBpbnQgaSwgbGVuID0gTUlOX05VTShuLCBhcmdjKTsKICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgaWYoIUpTX0lzTnVsbChhcmd2W2ldKSAmJiAhSlNfSXNVbmRlZmluZWQoYXJndltpXSkpCiAgICAgIHN0cmFbaV0gPSBqc190b3N0cmluZyhjdHgsIGFyZ3ZbaV0pOwogICAgZWxzZQogICAgICBzdHJhW2ldID0gMDsKICB9CiAgZm9yKDsgaSA8IG47IGkrKykgc3RyYVtpXSA9IDA7CgogIHJldHVybiBpOwp9Cgp2b2lkCmpzX2F0b21fZHVtcChKU0NvbnRleHQqIGN0eCwgSlNBdG9tIGF0b20sIER5bkJ1ZiogZGIsIEJPT0wgY29sb3IpIHsKICBjb25zdCBjaGFyKiBzdHI7CiAgQk9PTCBpc19pbnQ7CiAgc3RyID0gSlNfQXRvbVRvQ1N0cmluZyhjdHgsIGF0b20pOwogIGlzX2ludCA9IGpzX2F0b21faXNpbnQoYXRvbSkgfHwgaXNfaW50ZWdlcihzdHIpOwogIGlmKGNvbG9yKQogICAgZGJ1Zl9wdXRzdHIoZGIsIGlzX2ludCA/ICJceDFiWzMzbSIgOiAiXHgxYlsxOzMwbSIpOwoKICBkYnVmX3B1dHN0cihkYiwgc3RyKTsKICBpZihjb2xvcikKICAgIGRidWZfcHV0c3RyKGRiLCAiXHgxYlsxOzM2bSIpOwoKICBpZighaXNfaW50KQogICAgZGJ1Zl9wcmludGYoZGIsICIoMHgleCkiLCBqc19hdG9tX3RvYmluYXJ5KGF0b20pKTsKCiAgaWYoY29sb3IpCiAgICBkYnVmX3B1dHN0cihkYiwgIlx4MWJbbSIpOwp9Cgp1bnNpZ25lZCBpbnQKanNfYXRvbV90b2JpbmFyeShKU0F0b20gYXRvbSkgewogIHNzaXplX3QgcmV0OwogIGlmKGpzX2F0b21faXNpbnQoYXRvbSkpIHsKICAgIHJldCA9IGpzX2F0b21fdG9pbnQoYXRvbSk7CiAgICByZXQgPSAtcmV0OwogIH0gZWxzZSB7CiAgICByZXQgPSBhdG9tOwogIH0KICByZXR1cm4gcmV0Owp9Cgpjb25zdCBjaGFyKgpqc19hdG9tX3RvX2NzdHJpbmdsZW4oSlNDb250ZXh0KiBjdHgsIHNpemVfdCogbGVuLCBKU0F0b20gYXRvbSkgewogIEpTVmFsdWUgdjsKICBjb25zdCBjaGFyKiBzOwogIHYgPSBKU19BdG9tVG9WYWx1ZShjdHgsIGF0b20pOwogIHMgPSBKU19Ub0NTdHJpbmdMZW4oY3R4LCBsZW4sIHYpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHYpOwogIHJldHVybiBzOwp9CgppbnQzMl90CmpzX2F0b21fdG9pbnQzMihKU0NvbnRleHQqIGN0eCwgSlNBdG9tIGF0b20pIHsKICBpZighanNfYXRvbV9pc2ludChhdG9tKSkgewogICAgaW50NjRfdCBpID0gSU5UNjRfTUlOOwogICAganNfYXRvbV90b2ludDY0KGN0eCwgJmksIGF0b20pOwogICAgcmV0dXJuIGk7CiAgfQogIHJldHVybiAtYXRvbTsKfQoKaW50CmpzX2F0b21fdG9pbnQ2NChKU0NvbnRleHQqIGN0eCwgaW50NjRfdCogaSwgSlNBdG9tIGF0b20pIHsKICBpbnQgcmV0OwogIEpTVmFsdWUgdmFsdWU7CiAgKmkgPSBJTlQ2NF9NQVg7CiAgdmFsdWUgPSBKU19BdG9tVG9WYWx1ZShjdHgsIGF0b20pOwogIHJldCA9ICFKU19Ub0ludDY0KGN0eCwgaSwgdmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICByZXR1cm4gcmV0Owp9CgpCT09MCmpzX2F0b21faXNfaW5kZXgoSlNDb250ZXh0KiBjdHgsIGludDY0X3QqIHB2YWwsIEpTQXRvbSBhdG9tKSB7CiAgSlNWYWx1ZSB2YWx1ZTsKICBCT09MIHJldCA9IEZBTFNFOwogIGludDY0X3QgaW5kZXg7CgogIGlmKGF0b20gJiAoMVUgPDwgMzEpKSB7CiAgICAqcHZhbCA9IGF0b20gJiAofigxVSA8PCAzMSkpOwogICAgcmV0dXJuIFRSVUU7CiAgfQoKICB2YWx1ZSA9IEpTX0F0b21Ub1ZhbHVlKGN0eCwgYXRvbSk7CgogIGlmKEpTX0lzTnVtYmVyKHZhbHVlKSkgewogICAgSlNfVG9JbnQ2NChjdHgsICZpbmRleCwgdmFsdWUpOwogICAgcmV0ID0gVFJVRTsKICB9IGVsc2UgaWYoSlNfSXNTdHJpbmcodmFsdWUpKSB7CiAgICBjb25zdCBjaGFyKiBzID0gSlNfVG9DU3RyaW5nKGN0eCwgdmFsdWUpOwogICAgaWYoc1swXSA9PSAnLScgJiYgaXNfZGlnaXRfY2hhcihzW3NbMF0gPT0gJy0nXSkpIHsKICAgICAgaW5kZXggPSBhdG9pKHMpOwogICAgICByZXQgPSBUUlVFOwogICAgfQogICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBzKTsKICB9CgogIGlmKHJldCA9PSBUUlVFKQogICAgKnB2YWwgPSBpbmRleDsKCiAgcmV0dXJuIHJldDsKfQoKQk9PTApqc19hdG9tX2lzX2xlbmd0aChKU0NvbnRleHQqIGN0eCwgSlNBdG9tIGF0b20pIHsKICBjb25zdCBjaGFyKiBzdHIgPSBKU19BdG9tVG9DU3RyaW5nKGN0eCwgYXRvbSk7CiAgQk9PTCByZXQgPSAhc3RyY21wKHN0ciwgImxlbmd0aCIpOwogIEpTX0ZyZWVDU3RyaW5nKGN0eCwgc3RyKTsKICByZXR1cm4gcmV0Owp9Cgpjb25zdCBjaGFyKgpqc19mdW5jdGlvbl9uYW1lKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBKU0F0b20gYXRvbTsKICBKU1ZhbHVlIHN0ciwgbmFtZSwgYXJnc1syXSwgaWR4OwogIGNvbnN0IGNoYXIqIHMgPSAwOwogIGludDMyX3QgaSA9IC0xOwogIHN0ciA9IGpzX3ZhbHVlX3Rvc3RyaW5nKGN0eCwgIkZ1bmN0aW9uIiwgdmFsdWUpOwogIGF0b20gPSBKU19OZXdBdG9tKGN0eCwgImluZGV4T2YiKTsKICBhcmdzWzBdID0gSlNfTmV3U3RyaW5nKGN0eCwgImZ1bmN0aW9uICIpOwogIGlkeCA9IEpTX0ludm9rZShjdHgsIHN0ciwgYXRvbSwgMSwgYXJncyk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgYXJnc1swXSk7CiAgSlNfVG9JbnQzMihjdHgsICZpLCBpZHgpOwogIGlmKGkgIT0gMCkgewogICAgSlNfRnJlZUF0b20oY3R4LCBhdG9tKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHN0cik7CiAgICByZXR1cm4gMDsKICB9CiAgYXJnc1swXSA9IEpTX05ld1N0cmluZyhjdHgsICIoIik7CiAgaWR4ID0gSlNfSW52b2tlKGN0eCwgc3RyLCBhdG9tLCAxLCBhcmdzKTsKICBKU19GcmVlVmFsdWUoY3R4LCBhcmdzWzBdKTsKICBKU19GcmVlQXRvbShjdHgsIGF0b20pOwogIGF0b20gPSBKU19OZXdBdG9tKGN0eCwgInN1YnN0cmluZyIpOwogIGFyZ3NbMF0gPSBKU19OZXdVaW50MzIoY3R4LCA5KTsKICBhcmdzWzFdID0gaWR4OwogIG5hbWUgPSBKU19JbnZva2UoY3R4LCBzdHIsIGF0b20sIDIsIGFyZ3MpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGFyZ3NbMF0pOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGFyZ3NbMV0pOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHN0cik7CiAgSlNfRnJlZUF0b20oY3R4LCBhdG9tKTsKICBzID0gSlNfVG9DU3RyaW5nKGN0eCwgbmFtZSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgbmFtZSk7CiAgcmV0dXJuIHM7Cn0KCmludApqc19mdW5jdGlvbl9hcmdjKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICByZXR1cm4ganNfZ2V0X3Byb3BlcnR5c3RyX2ludDMyKGN0eCwgdmFsdWUsICJsZW5ndGgiKTsKfQoKSlNWYWx1ZQpqc19nbG9iYWxfZ2V0KEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBwcm9wKSB7CiAgSlNWYWx1ZSBnbG9iYWxfb2JqLCByZXQ7CiAgZ2xvYmFsX29iaiA9IEpTX0dldEdsb2JhbE9iamVjdChjdHgpOwogIHJldCA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgZ2xvYmFsX29iaiwgcHJvcCk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgZ2xvYmFsX29iaik7CiAgcmV0dXJuIHJldDsKfQoKSlNWYWx1ZQpqc19nbG9iYWxfcHJvdG90eXBlKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBjbGFzc19uYW1lKSB7CiAgSlNWYWx1ZSBjdG9yLCByZXQ7CiAgY3RvciA9IGpzX2dsb2JhbF9nZXQoY3R4LCBjbGFzc19uYW1lKTsKICByZXQgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIGN0b3IsICJwcm90b3R5cGUiKTsKICBKU19GcmVlVmFsdWUoY3R4LCBjdG9yKTsKICByZXR1cm4gcmV0Owp9CgpKU1ZhbHVlCmpzX2l0ZXJhdG9yX21ldGhvZChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaikgewogIEpTQXRvbSBhdG9tOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwogIGF0b20gPSBqc19zeW1ib2xfc3RhdGljX2F0b20oY3R4LCAiaXRlcmF0b3IiKTsKICBpZihKU19IYXNQcm9wZXJ0eShjdHgsIG9iaiwgYXRvbSkpCiAgICByZXQgPSBKU19HZXRQcm9wZXJ0eShjdHgsIG9iaiwgYXRvbSk7CgogIEpTX0ZyZWVBdG9tKGN0eCwgYXRvbSk7CiAgaWYoIUpTX0lzRnVuY3Rpb24oY3R4LCByZXQpKSB7CiAgICBhdG9tID0ganNfc3ltYm9sX3N0YXRpY19hdG9tKGN0eCwgImFzeW5jSXRlcmF0b3IiKTsKICAgIGlmKEpTX0hhc1Byb3BlcnR5KGN0eCwgb2JqLCBhdG9tKSkKICAgICAgcmV0ID0gSlNfR2V0UHJvcGVydHkoY3R4LCBvYmosIGF0b20pOwoKICAgIEpTX0ZyZWVBdG9tKGN0eCwgYXRvbSk7CiAgfQogIHJldHVybiByZXQ7Cn0KCkpTVmFsdWUKanNfaXRlcmF0b3JfbmV3KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqKSB7CiAgSlNWYWx1ZSBmbiwgcmV0OwogIGZuID0ganNfaXRlcmF0b3JfbWV0aG9kKGN0eCwgb2JqKTsKICByZXQgPSBKU19DYWxsKGN0eCwgZm4sIG9iaiwgMCwgMCk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgZm4pOwogIHJldHVybiByZXQ7Cn0KCkpTVmFsdWUKanNfaXRlcmF0b3JfbmV4dChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgQk9PTCogZG9uZV9wKSB7CiAgSlNWYWx1ZSBmbiwgcmVzdWx0LCBkb25lLCB2YWx1ZTsKICBmbiA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqLCAibmV4dCIpOwogIHJlc3VsdCA9IEpTX0NhbGwoY3R4LCBmbiwgb2JqLCAwLCAwKTsKICBKU19GcmVlVmFsdWUoY3R4LCBmbik7CiAgZG9uZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgcmVzdWx0LCAiZG9uZSIpOwogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCByZXN1bHQsICJ2YWx1ZSIpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHJlc3VsdCk7CiAgKmRvbmVfcCA9IEpTX1RvQm9vbChjdHgsIGRvbmUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGRvbmUpOwogIHJldHVybiB2YWx1ZTsKfQoKSlNWYWx1ZQpqc19vYmplY3RfY29uc3RydWN0b3IoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIEpTVmFsdWUgY3RvciA9IEpTX1VOREVGSU5FRDsKICBpZihKU19Jc09iamVjdCh2YWx1ZSkpCiAgICBjdG9yID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCB2YWx1ZSwgImNvbnN0cnVjdG9yIik7CiAgcmV0dXJuIGN0b3I7Cn0KCmNoYXIqCmpzX29iamVjdF9jbGFzc25hbWUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIEpTVmFsdWUgcHJvdG8sIGN0b3I7CiAgY29uc3QgY2hhciogc3RyOwogIGNoYXIqIG5hbWUgPSAwOwogIGludCBuYW1lbGVuOwogIGN0b3IgPSBqc19vYmplY3RfY29uc3RydWN0b3IoY3R4LCB2YWx1ZSk7CiAgaWYoIUpTX0lzRnVuY3Rpb24oY3R4LCBjdG9yKSkgewogICAgcHJvdG8gPSBKU19HZXRQcm90b3R5cGUoY3R4LCB2YWx1ZSk7CiAgICBjdG9yID0ganNfb2JqZWN0X2NvbnN0cnVjdG9yKGN0eCwgcHJvdG8pOwogIH0KICBpZigoc3RyID0gSlNfVG9DU3RyaW5nKGN0eCwgY3RvcikpKSB7CiAgICBpZighc3RybmNtcChzdHIsICJmdW5jdGlvbiAiLCA5KSkgewogICAgICBuYW1lbGVuID0gYnl0ZV9jaHIoc3RyICsgOSwgc3RybGVuKHN0cikgLSA5LCAnKCcpOwogICAgICBuYW1lID0ganNfc3RybmR1cChjdHgsIHN0ciArIDksIG5hbWVsZW4pOwogICAgfQogIH0KICBpZighbmFtZSkgewogICAgaWYoc3RyKQogICAgICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBzdHIpOwogICAgaWYoKHN0ciA9IEpTX1RvQ1N0cmluZyhjdHgsIEpTX0dldFByb3BlcnR5U3RyKGN0eCwgY3RvciwgIm5hbWUiKSkpKQogICAgICBuYW1lID0ganNfc3RyZHVwKGN0eCwgc3RyKTsKICB9CiAgaWYoc3RyKQogICAganNfY3N0cmluZ19mcmVlKGN0eCwgc3RyKTsKICByZXR1cm4gbmFtZTsKfQoKQk9PTApqc19vYmplY3RfZXF1YWxzKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgYSwgSlNWYWx1ZUNvbnN0IGIpIHsKICBKU1Byb3BlcnR5RW51bSAqYXRvbXNfYSwgKmF0b21zX2I7CiAgdWludDMyX3QgaSwgbmF0b21zX2EsIG5hdG9tc19iOwogIGludDMyX3QgdGEsIHRiOwogIHRhID0ganNfdmFsdWVfdHlwZShjdHgsIGEpOwogIHRiID0ganNfdmFsdWVfdHlwZShjdHgsIGIpOwogIGFzc2VydCh0YSA9PSBUWVBFX09CSkVDVCk7CiAgYXNzZXJ0KHRiID09IFRZUEVfT0JKRUNUKTsKICBpZihKU19HZXRPd25Qcm9wZXJ0eU5hbWVzKGN0eCwgJmF0b21zX2EsICZuYXRvbXNfYSwgYSwgSlNfR1BOX1NUUklOR19NQVNLIHwgSlNfR1BOX1NZTUJPTF9NQVNLIHwgSlNfR1BOX0VOVU1fT05MWSkpCiAgICByZXR1cm4gRkFMU0U7CgogIGlmKEpTX0dldE93blByb3BlcnR5TmFtZXMoY3R4LCAmYXRvbXNfYiwgJm5hdG9tc19iLCBiLCBKU19HUE5fU1RSSU5HX01BU0sgfCBKU19HUE5fU1lNQk9MX01BU0sgfCBKU19HUE5fRU5VTV9PTkxZKSkKICAgIHJldHVybiBGQUxTRTsKCiAgaWYobmF0b21zX2EgIT0gbmF0b21zX2IpCiAgICByZXR1cm4gRkFMU0U7CgogIHFzb3J0X3IoJmF0b21zX2EsIG5hdG9tc19hLCBzaXplb2YoSlNQcm9wZXJ0eUVudW0pLCAmanNfcHJvcGVudW1fY21wLCBjdHgpOwogIHFzb3J0X3IoJmF0b21zX2IsIG5hdG9tc19iLCBzaXplb2YoSlNQcm9wZXJ0eUVudW0pLCAmanNfcHJvcGVudW1fY21wLCBjdHgpOwogIGZvcihpID0gMDsgaSA8IG5hdG9tc19hOyBpKyspCiAgICBpZihhdG9tc19hW2ldLmF0b20gIT0gYXRvbXNfYltpXS5hdG9tKQogICAgICByZXR1cm4gRkFMU0U7CiAgcmV0dXJuIFRSVUU7Cn0KCmludApqc19vYmplY3RfaXMoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSwgY29uc3QgY2hhciogY21wKSB7CiAgaW50IHJldDsKICBjb25zdCBjaGFyKiBzdHI7CiAgc3RyID0ganNfb2JqZWN0X3Rvc3RyaW5nKGN0eCwgdmFsdWUpOwogIHJldCA9IHN0cmNtcChzdHIsIGNtcCkgPT0gMDsKICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBzdHIpOwogIHJldHVybiByZXQ7Cn0KCkpTVmFsdWUKanNfb2JqZWN0X2NvbnN0cnVjdChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IGN0b3IpIHsKICBKU1ZhbHVlQ29uc3QgYXJnc1tdID0ge0pTX1VOREVGSU5FRH07CiAgcmV0dXJuIEpTX0NhbGxDb25zdHJ1Y3RvcihjdHgsIGN0b3IsIDAsIGFyZ3MpOwp9CgpKU1ZhbHVlCmpzX29iamVjdF9lcnJvcihKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogbWVzc2FnZSkgewogIEpTVmFsdWVDb25zdCBhcmdzW10gPSB7SlNfTmV3U3RyaW5nKGN0eCwgbWVzc2FnZSl9OwogIEpTVmFsdWUgcmV0ID0ganNfb2JqZWN0X25ldyhjdHgsICJFcnJvciIsIDEsIGFyZ3MpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGFyZ3NbMF0pOwogIHJldHVybiByZXQ7Cn0KCkpTVmFsdWUKanNfb2JqZWN0X3N0YWNrKEpTQ29udGV4dCogY3R4KSB7CiAgSlNWYWx1ZSBlcnJvciA9IGpzX29iamVjdF9lcnJvcihjdHgsICIiKTsKICBKU1ZhbHVlIHN0YWNrID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBlcnJvciwgInN0YWNrIik7CiAgSlNfRnJlZVZhbHVlKGN0eCwgZXJyb3IpOwogIHJldHVybiBzdGFjazsKfQoKSlNWYWx1ZQpqc19vYmplY3RfbmV3KEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBjbGFzc19uYW1lLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSkgewogIEpTVmFsdWUgY3RvciA9IGpzX2dsb2JhbF9nZXQoY3R4LCBjbGFzc19uYW1lKTsKICBKU1ZhbHVlIG9iaiA9IEpTX0NhbGxDb25zdHJ1Y3RvcihjdHgsIGN0b3IsIGFyZ2MsIGFyZ3YpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGN0b3IpOwogIHJldHVybiBvYmo7Cn0KCkJPT0wKanNfaGFzX3Byb3BlcnR5c3RyKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBjb25zdCBjaGFyKiBzdHIpIHsKICBKU0F0b20gYXRvbTsKICBCT09MIHJldCA9IEZBTFNFOwogIGF0b20gPSBKU19OZXdBdG9tKGN0eCwgc3RyKTsKICByZXQgPSBKU19IYXNQcm9wZXJ0eShjdHgsIG9iaiwgYXRvbSk7CiAgSlNfRnJlZUF0b20oY3R4LCBhdG9tKTsKICByZXR1cm4gcmV0Owp9CgpCT09MCmpzX2dldF9wcm9wZXJ0eXN0cl9ib29sKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBjb25zdCBjaGFyKiBzdHIpIHsKICBCT09MIHJldCA9IEZBTFNFOwogIEpTVmFsdWUgdmFsdWU7CiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgc3RyKTsKICBpZighSlNfSXNFeGNlcHRpb24odmFsdWUpKQogICAgcmV0ID0gSlNfVG9Cb29sKGN0eCwgdmFsdWUpOwoKICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgcmV0dXJuIHJldDsKfQoKY29uc3QgY2hhcioKanNfZ2V0X3Byb3BlcnR5c3RyX2NzdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3ApIHsKICBKU1ZhbHVlIHZhbHVlOwogIGNvbnN0IGNoYXIqIHJldDsKICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqLCBwcm9wKTsKICBpZihKU19Jc1VuZGVmaW5lZCh2YWx1ZSkgfHwgSlNfSXNFeGNlcHRpb24odmFsdWUpKQogICAgcmV0dXJuIDA7CgogIHJldCA9IEpTX1RvQ1N0cmluZyhjdHgsIHZhbHVlKTsKICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgcmV0dXJuIHJldDsKfQoKY29uc3QgY2hhcioKanNfZ2V0X3Byb3BlcnR5c3RyX2NzdHJpbmdsZW4oSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3AsIHNpemVfdCogbGVucCkgewogIEpTVmFsdWUgdmFsdWU7CiAgY29uc3QgY2hhciogcmV0OwogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmosIHByb3ApOwogIGlmKEpTX0lzVW5kZWZpbmVkKHZhbHVlKSB8fCBKU19Jc0V4Y2VwdGlvbih2YWx1ZSkpCiAgICByZXR1cm4gMDsKCiAgcmV0ID0gSlNfVG9DU3RyaW5nTGVuKGN0eCwgbGVucCwgdmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICByZXR1cm4gcmV0Owp9Cgpjb25zdCBjaGFyKgpqc19nZXRfcHJvcGVydHlpbnRfY3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgdWludDMyX3QgcHJvcCkgewogIEpTVmFsdWUgdmFsdWU7CiAgY2hhciogcmV0OwogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCBvYmosIHByb3ApOwogIC8qIGlmKEpTX0lzVW5kZWZpbmVkKHZhbHVlKSB8fCBKU19Jc0V4Y2VwdGlvbih2YWx1ZSkpCiAgICAgcmV0dXJuIDA7Ki8KCiAgcmV0ID0ganNfdG9zdHJpbmcoY3R4LCB2YWx1ZSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIHJldHVybiByZXQ7Cn0KCmludDMyX3QKanNfZ2V0X3Byb3BlcnR5aW50X2ludDMyKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCB1aW50MzJfdCBwcm9wKSB7CiAgaW50MzJfdCByZXQ7CiAgSlNWYWx1ZSB2YWx1ZSA9IEpTX0dldFByb3BlcnR5VWludDMyKGN0eCwgb2JqLCBwcm9wKTsKICBKU19Ub0ludDMyKGN0eCwgJnJldCwgdmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICByZXR1cm4gcmV0Owp9CgpjaGFyKgpqc19nZXRfcHJvcGVydHlzdHJfc3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBjb25zdCBjaGFyKiBwcm9wKSB7CiAgSlNWYWx1ZSB2YWx1ZTsKICBjaGFyKiByZXQ7CiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgcHJvcCk7CiAgaWYoSlNfSXNVbmRlZmluZWQodmFsdWUpIHx8IEpTX0lzRXhjZXB0aW9uKHZhbHVlKSkKICAgIHJldHVybiAwOwoKICByZXQgPSBqc190b3N0cmluZyhjdHgsIHZhbHVlKTsKICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgcmV0dXJuIHJldDsKfQoKY2hhcioKanNfZ2V0X3Byb3BlcnR5c3RyX3N0cmluZ2xlbihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgY29uc3QgY2hhciogcHJvcCwgc2l6ZV90KiBsZW5wKSB7CiAgSlNWYWx1ZSB2YWx1ZTsKICBjaGFyKiByZXQ7CiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgcHJvcCk7CiAgaWYoSlNfSXNVbmRlZmluZWQodmFsdWUpIHx8IEpTX0lzRXhjZXB0aW9uKHZhbHVlKSkKICAgIHJldHVybiAwOwoKICByZXQgPSBqc190b3N0cmluZ2xlbihjdHgsIGxlbnAsIHZhbHVlKTsKICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgcmV0dXJuIHJldDsKfQoKaW50MzJfdApqc19nZXRfcHJvcGVydHlzdHJfaW50MzIoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3ApIHsKICBKU1ZhbHVlIHZhbHVlOwogIGludDMyX3QgcmV0OwogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmosIHByb3ApOwogIGlmKEpTX0lzVW5kZWZpbmVkKHZhbHVlKSB8fCBKU19Jc0V4Y2VwdGlvbih2YWx1ZSkpCiAgICByZXR1cm4gMDsKICBKU19Ub0ludDMyKGN0eCwgJnJldCwgdmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICByZXR1cm4gcmV0Owp9Cgp1aW50NjRfdApqc19nZXRfcHJvcGVydHlzdHJfdWludDY0KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBjb25zdCBjaGFyKiBwcm9wKSB7CiAgSlNWYWx1ZSB2YWx1ZTsKICB1aW50NjRfdCByZXQ7CiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgcHJvcCk7CiAgaWYoSlNfSXNVbmRlZmluZWQodmFsdWUpIHx8IEpTX0lzRXhjZXB0aW9uKHZhbHVlKSkKICAgIHJldHVybiAwOwogIEpTX1RvSW5kZXgoY3R4LCAmcmV0LCB2YWx1ZSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIHJldHVybiByZXQ7Cn0KCnZvaWQKanNfc2V0X3Byb3BlcnR5aW50X3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgdWludDMyX3QgaSwgY29uc3QgY2hhciogc3RyKSB7CiAgSlNWYWx1ZSB2YWx1ZTsKICB2YWx1ZSA9IEpTX05ld1N0cmluZyhjdHgsIHN0cik7CiAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCBvYmosIGksIHZhbHVlKTsKfQoKdm9pZApqc19zZXRfcHJvcGVydHlpbnRfaW50KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCB1aW50MzJfdCBpLCBpbnQzMl90IHZhbHVlKSB7CiAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCBvYmosIGksIEpTX05ld0ludDMyKGN0eCwgdmFsdWUpKTsKfQoKdm9pZApqc19zZXRfcHJvcGVydHlzdHJfc3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBjb25zdCBjaGFyKiBwcm9wLCBjb25zdCBjaGFyKiBzdHIpIHsKICBKU1ZhbHVlIHZhbHVlOwogIHZhbHVlID0gSlNfTmV3U3RyaW5nKGN0eCwgc3RyKTsKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgcHJvcCwgdmFsdWUpOwp9Cgp2b2lkCmpzX3NldF9wcm9wZXJ0eXN0cl9zdHJpbmdsZW4oSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3AsIGNvbnN0IGNoYXIqIHN0ciwgc2l6ZV90IGxlbikgewogIEpTVmFsdWUgdmFsdWU7CiAgdmFsdWUgPSBKU19OZXdTdHJpbmdMZW4oY3R4LCBzdHIsIGxlbik7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCBvYmosIHByb3AsIHZhbHVlKTsKfQoKaW50CmpzX2dldF9wcm9wZXJ0eWRlc2NyaXB0b3IoSlNDb250ZXh0KiBjdHgsIEpTUHJvcGVydHlEZXNjcmlwdG9yKiBkZXNjLCBKU1ZhbHVlQ29uc3QgdmFsdWUsIEpTQXRvbSBwcm9wKSB7CiAgSlNWYWx1ZSBvYmosIHByb3RvOwogIG9iaiA9IEpTX0R1cFZhbHVlKGN0eCwgdmFsdWUpOwogIGRvIHsKICAgIGlmKEpTX0dldE93blByb3BlcnR5KGN0eCwgZGVzYywgb2JqLCBwcm9wKSA9PSBUUlVFKQogICAgICByZXR1cm4gVFJVRTsKICAgIHByb3RvID0gSlNfR2V0UHJvdG90eXBlKGN0eCwgb2JqKTsKICAgIGlmKEpTX1ZBTFVFX0dFVF9PQkoocHJvdG8pID09IEpTX1ZBTFVFX0dFVF9PQkoob2JqKSkKICAgICAgYnJlYWs7CiAgICBKU19GcmVlVmFsdWUoY3R4LCBvYmopOwogICAgb2JqID0gcHJvdG87CiAgfSB3aGlsZShKU19Jc09iamVjdChvYmopKTsKICByZXR1cm4gRkFMU0U7Cn0KCkpTQ2xhc3NJRApqc19jbGFzc19pZChKU0NvbnRleHQqIGN0eCwgaW50IGlkKSB7CiAgcmV0dXJuIGN0eC0+cnQtPmNsYXNzX2FycmF5W2lkXS5jbGFzc19pZDsKfQoKSlNDbGFzc0lECmpzX2NsYXNzX25ld2lkKHZvaWQpIHsKICBKU0NsYXNzSUQgaWQ7CiAgSlNfTmV3Q2xhc3NJRCgmaWQpOwogIHJldHVybiBpZDsKfQoKSlNDbGFzcyoKanNfY2xhc3NfZ2V0KEpTQ29udGV4dCogY3R4LCBKU0NsYXNzSUQgaWQpIHsKICBKU0NsYXNzKiByZXQgPSAmY3R4LT5ydC0+Y2xhc3NfYXJyYXlbaWRdOwogIHJldHVybiByZXQtPmNsYXNzX2lkID09IGlkID8gcmV0IDogMDsKfQoKSlNBdG9tCmpzX2NsYXNzX2F0b20oSlNDb250ZXh0KiBjdHgsIEpTQ2xhc3NJRCBpZCkgewogIEpTQXRvbSBhdG9tID0gMDsKICBpZihpZCA+IDAgJiYgaWQgPCAoSlNDbGFzc0lEKWN0eC0+cnQtPmNsYXNzX2NvdW50KQogICAgYXRvbSA9IGN0eC0+cnQtPmNsYXNzX2FycmF5W2lkXS5jbGFzc19uYW1lOwogIHJldHVybiBhdG9tOwp9Cgpjb25zdCBjaGFyKgpqc19jbGFzc19uYW1lKEpTQ29udGV4dCogY3R4LCBKU0NsYXNzSUQgaWQpIHsKICBKU0F0b20gYXRvbSA9IGN0eC0+cnQtPmNsYXNzX2FycmF5W2lkXS5jbGFzc19uYW1lOwogIHJldHVybiBKU19BdG9tVG9DU3RyaW5nKGN0eCwgYXRvbSk7Cn0KCmNvbnN0IGNoYXIqCmpzX29iamVjdF90b3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgSlNWYWx1ZSBzdHIgPSBqc192YWx1ZV90b3N0cmluZyhjdHgsICJPYmplY3QiLCB2YWx1ZSk7CiAgY29uc3QgY2hhciogcyA9IEpTX1RvQ1N0cmluZyhjdHgsIHN0cik7CiAgSlNfRnJlZVZhbHVlKGN0eCwgc3RyKTsKICByZXR1cm4gczsKfQoKY29uc3QgY2hhcioKanNfZnVuY3Rpb25fdG9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIEpTVmFsdWUgc3RyID0ganNfdmFsdWVfdG9zdHJpbmcoY3R4LCAiRnVuY3Rpb24iLCB2YWx1ZSk7CiAgY29uc3QgY2hhciogcyA9IEpTX1RvQ1N0cmluZyhjdHgsIHN0cik7CiAgSlNfRnJlZVZhbHVlKGN0eCwgc3RyKTsKICByZXR1cm4gczsKfQoKQk9PTApqc19mdW5jdGlvbl9pc25hdGl2ZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgY29uc3QgY2hhciogZm4gPSBqc19mdW5jdGlvbl90b3N0cmluZyhjdHgsIHZhbHVlKTsKICBCT09MIHJldCA9ICEhc3Ryc3RyKGZuLCAiXG4gICAgW25hdGl2ZSBjb2RlXVxuIik7CiAgSlNfRnJlZUNTdHJpbmcoY3R4LCBmbik7CiAgcmV0dXJuIHJldDsKfQoKQk9PTApqc19pc19pbnB1dChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgcmV0dXJuIEpTX0lzU3RyaW5nKHZhbHVlKSB8fCBqc192YWx1ZV9pc2NsYXNzKGN0eCwgdmFsdWUsIEpTX0NMQVNTX0FSUkFZX0JVRkZFUik7Cn0KCmludApqc19wcm9wZW51bV9jbXAoY29uc3Qgdm9pZCogYSwgY29uc3Qgdm9pZCogYiwgdm9pZCogcHRyKSB7CiAgSlNDb250ZXh0KiBjdHggPSBwdHI7CiAgY29uc3QgY2hhciAqc3RyYSwgKnN0cmI7CiAgaW50IHJldDsKICBzdHJhID0gSlNfQXRvbVRvQ1N0cmluZyhjdHgsICgoY29uc3QgSlNQcm9wZXJ0eUVudW0qKWEpLT5hdG9tKTsKICBzdHJiID0gSlNfQXRvbVRvQ1N0cmluZyhjdHgsICgoY29uc3QgSlNQcm9wZXJ0eUVudW0qKWIpLT5hdG9tKTsKICByZXQgPSBzdHJ2ZXJzY21wKHN0cmEsIHN0cmIpOwogIGpzX2NzdHJpbmdfZnJlZShjdHgsIHN0cmEpOwogIGpzX2NzdHJpbmdfZnJlZShjdHgsIHN0cmIpOwogIHJldHVybiByZXQ7Cn0KCnZvaWQKanNfcHJvcGVydHllbnVtc19mcmVlKEpTQ29udGV4dCogY3R4LCBKU1Byb3BlcnR5RW51bSogcHJvcHMsIHNpemVfdCBsZW4pIHsKICB1aW50MzJfdCBpOwogIGZvcihpID0gMDsgaSA8IGxlbjsgaSsrKSBKU19GcmVlQXRvbShjdHgsIHByb3BzW2ldLmF0b20pOwogIC8vIGpzX2ZyZWUoY3R4LCBwcm9wcyk7Cn0KCnZvaWQKanNfc3Rydl9mcmVlX24oSlNDb250ZXh0KiBjdHgsIGludCBuLCBjaGFyKiBhcmd2W10pIHsKICBpbnQgaTsKICBmb3IoaSA9IDA7IGkgPCBuOyBpKyspIHsKICAgIGlmKGFyZ3ZbaV0pIHsKICAgICAganNfZnJlZShjdHgsIGFyZ3ZbaV0pOwogICAgICBhcmd2W2ldID0gMDsKICAgIH0KICB9Cn0KCnZvaWQKanNfc3Rydl9mcmVlKEpTQ29udGV4dCogY3R4LCBjaGFyKiogc3RydikgewogIHNpemVfdCBpOwogIGlmKHN0cnYgPT0gMCkKICAgIHJldHVybjsKCiAgZm9yKGkgPSAwOyBzdHJ2W2ldOyBpKyspIHsganNfZnJlZShjdHgsIHN0cnZbaV0pOyB9CiAganNfZnJlZShjdHgsIHN0cnYpOwp9Cgp2b2lkCmpzX3N0cnZfZnJlZV9ydChKU1J1bnRpbWUqIHJ0LCBjaGFyKiogc3RydikgewogIHNpemVfdCBpOwogIGlmKHN0cnYgPT0gMCkKICAgIHJldHVybjsKCiAgZm9yKGkgPSAwOyBzdHJ2W2ldOyBpKyspIHsganNfZnJlZV9ydChydCwgc3RydltpXSk7IH0KICBqc19mcmVlX3J0KHJ0LCBzdHJ2KTsKfQoKSlNWYWx1ZQpqc19zdHJ2X3RvX2FycmF5KEpTQ29udGV4dCogY3R4LCBjaGFyKiogc3RydikgewogIEpTVmFsdWUgcmV0ID0gSlNfTmV3QXJyYXkoY3R4KTsKICBpZihzdHJ2KSB7CiAgICBzaXplX3QgaTsKICAgIGZvcihpID0gMDsgc3RydltpXTsgaSsrKSBKU19TZXRQcm9wZXJ0eVVpbnQzMihjdHgsIHJldCwgaSwgSlNfTmV3U3RyaW5nKGN0eCwgc3RydltpXSkpOwogIH0KICByZXR1cm4gcmV0Owp9CgpzaXplX3QKanNfc3Rydl9sZW5ndGgoY2hhcioqIHN0cnYpIHsKICBzaXplX3QgaTsKICBmb3IoaSA9IDA7IHN0cnZbaV07IGkrKykge30KICByZXR1cm4gaTsKfQoKY2hhcioqCmpzX3N0cnZfZHVwKEpTQ29udGV4dCogY3R4LCBjaGFyKiogc3RydikgewogIGNoYXIqKiByZXQ7CiAgc2l6ZV90IGksIGxlbiA9IGpzX3N0cnZfbGVuZ3RoKHN0cnYpOwogIHJldCA9IGpzX21hbGxvYyhjdHgsIChsZW4gKyAxKSAqIHNpemVvZihjaGFyKikpOwogIGZvcihpID0gMDsgaSA8IGxlbjsgaSsrKSB7IHJldFtpXSA9IGpzX3N0cmR1cChjdHgsIHN0cnZbaV0pOyB9CiAgcmV0W2ldID0gMDsKICByZXR1cm4gcmV0Owp9CgpKU1ZhbHVlCmpzX2ludHZfdG9fYXJyYXkoSlNDb250ZXh0KiBjdHgsIGludCogaW50dikgewogIEpTVmFsdWUgcmV0ID0gSlNfTmV3QXJyYXkoY3R4KTsKICBpZihpbnR2KSB7CiAgICBzaXplX3QgaTsKICAgIGZvcihpID0gMDsgaW50dltpXTsgaSsrKSBKU19TZXRQcm9wZXJ0eVVpbnQzMihjdHgsIHJldCwgaSwgSlNfTmV3SW50MzIoY3R4LCBpbnR2W2ldKSk7CiAgfQogIHJldHVybiByZXQ7Cn0KCkpTQXRvbQpqc19zeW1ib2xfc3RhdGljX2F0b20oSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIG5hbWUpIHsKICBKU1ZhbHVlIHN5bSA9IGpzX3N5bWJvbF9zdGF0aWNfdmFsdWUoY3R4LCBuYW1lKTsKICBKU0F0b20gcmV0ID0gSlNfVmFsdWVUb0F0b20oY3R4LCBzeW0pOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHN5bSk7CiAgcmV0dXJuIHJldDsKfQoKSlNWYWx1ZQpqc19zeW1ib2xfc3RhdGljX3ZhbHVlKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBuYW1lKSB7CiAgSlNWYWx1ZSBzeW1ib2xfY3RvciwgcmV0OwogIHN5bWJvbF9jdG9yID0ganNfc3ltYm9sX2N0b3IoY3R4KTsKICByZXQgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIHN5bWJvbF9jdG9yLCBuYW1lKTsKICBKU19GcmVlVmFsdWUoY3R4LCBzeW1ib2xfY3Rvcik7CiAgcmV0dXJuIHJldDsKfQoKSlNWYWx1ZQpqc19zeW1ib2xfY3RvcihKU0NvbnRleHQqIGN0eCkgewogIHJldHVybiBqc19nbG9iYWxfZ2V0KGN0eCwgIlN5bWJvbCIpOwp9CgpKU1ZhbHVlCmpzX3N5bWJvbF9pbnZva2Vfc3RhdGljKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBuYW1lLCBKU1ZhbHVlQ29uc3QgYXJnKSB7CiAgSlNWYWx1ZSByZXQ7CiAgSlNBdG9tIG1ldGhvZF9uYW1lID0gSlNfTmV3QXRvbShjdHgsIG5hbWUpOwogIHJldCA9IEpTX0ludm9rZShjdHgsIGpzX3N5bWJvbF9jdG9yKGN0eCksIG1ldGhvZF9uYW1lLCAxLCAmYXJnKTsKICBKU19GcmVlQXRvbShjdHgsIG1ldGhvZF9uYW1lKTsKICByZXR1cm4gcmV0Owp9CgpKU1ZhbHVlCmpzX3N5bWJvbF9mb3IoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIHN5bV9mb3IpIHsKICBKU1ZhbHVlIGtleSwgc3ltOwogIEpTQXRvbSBhdG9tOwogIGtleSA9IEpTX05ld1N0cmluZyhjdHgsIHN5bV9mb3IpOwogIHN5bSA9IGpzX3N5bWJvbF9pbnZva2Vfc3RhdGljKGN0eCwgImZvciIsIGtleSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwga2V5KTsKICByZXR1cm4gc3ltOwp9CgpKU0F0b20KanNfc3ltYm9sX2Zvcl9hdG9tKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBzeW1fZm9yKSB7CiAgSlNWYWx1ZSBzeW0gPSBqc19zeW1ib2xfZm9yKGN0eCwgc3ltX2Zvcik7CiAgSlNBdG9tIGF0b20gPSBKU19WYWx1ZVRvQXRvbShjdHgsIHN5bSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgc3ltKTsKICByZXR1cm4gYXRvbTsKfQoKSlNWYWx1ZQpqc19zeW1ib2xfdG9fc3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgc3ltKSB7CiAgSlNWYWx1ZSB2YWx1ZSwgc3RyOwogIEpTQXRvbSBhdG9tOwogIHZhbHVlID0ganNfc3ltYm9sX2ludm9rZV9zdGF0aWMoY3R4LCAia2V5Rm9yIiwgc3ltKTsKICBpZighSlNfSXNVbmRlZmluZWQodmFsdWUpKQogICAgcmV0dXJuIHZhbHVlOwoKICBhdG9tID0gSlNfVmFsdWVUb0F0b20oY3R4LCBzeW0pOwogIHN0ciA9IEpTX0F0b21Ub1N0cmluZyhjdHgsIGF0b20pOwogIEpTX0ZyZWVBdG9tKGN0eCwgYXRvbSk7CiAgcmV0dXJuIHN0cjsKfQoKY29uc3QgY2hhcioKanNfc3ltYm9sX3RvX2NzdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBzeW0pIHsKICBKU1ZhbHVlIHZhbHVlID0ganNfc3ltYm9sX3RvX3N0cmluZyhjdHgsIHN5bSk7CiAgY29uc3QgY2hhciogc3RyOwogIHN0ciA9IEpTX1RvQ1N0cmluZyhjdHgsIHZhbHVlKTsKICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgcmV0dXJuIHN0cjsKfQoKSlNWYWx1ZSoKanNfdmFsdWVzX2R1cChKU0NvbnRleHQqIGN0eCwgaW50IG52YWx1ZXMsIEpTVmFsdWVDb25zdCogdmFsdWVzKSB7CiAgSlNWYWx1ZSogcmV0ID0ganNfbWFsbG9jel9ydChjdHgtPnJ0LCBzaXplb2YoSlNWYWx1ZSkgKiBudmFsdWVzKTsKICBpbnQgaTsKICBmb3IoaSA9IDA7IGkgPCBudmFsdWVzOyBpKyspIHJldFtpXSA9IEpTX0R1cFZhbHVlUlQoY3R4LT5ydCwgdmFsdWVzW2ldKTsKICByZXR1cm4gcmV0Owp9Ci8qCnZvaWQKanNfdmFsdWVzX2ZyZWUoSlNDb250ZXh0KiBjdHgsIGludCBudmFsdWVzLCBKU1ZhbHVlQ29uc3QqIHZhbHVlcykgewogIGludCBpOwogIGZvcihpID0gMDsgaSA8IG52YWx1ZXM7IGkrKykgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWVzW2ldKTsKICBqc19mcmVlKGN0eCwgdmFsdWVzKTsKfQoqLwp2b2lkCmpzX3ZhbHVlc19mcmVlKEpTUnVudGltZSogcnQsIGludCBudmFsdWVzLCBKU1ZhbHVlQ29uc3QqIHZhbHVlcykgewogIGludCBpOwogIGZvcihpID0gMDsgaSA8IG52YWx1ZXM7IGkrKykgSlNfRnJlZVZhbHVlUlQocnQsIHZhbHVlc1tpXSk7CiAganNfZnJlZV9ydChydCwgdmFsdWVzKTsKfQoKSlNWYWx1ZQpqc192YWx1ZXNfdG9hcnJheShKU0NvbnRleHQqIGN0eCwgaW50IG52YWx1ZXMsIEpTVmFsdWVDb25zdCogdmFsdWVzKSB7CiAgaW50IGk7CiAgSlNWYWx1ZSByZXQgPSBKU19OZXdBcnJheShjdHgpOwogIGZvcihpID0gMDsgaSA8IG52YWx1ZXM7IGkrKykgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCByZXQsIGksIEpTX0R1cFZhbHVlKGN0eCwgdmFsdWVzW2ldKSk7CiAgcmV0dXJuIHJldDsKfQoKY29uc3QgY2hhcioKanNfdmFsdWVfdHlwZV9uYW1lKGludDMyX3QgdHlwZSkgewogIGludDMyX3QgZmxhZyA9IGpzX3ZhbHVlX3R5cGUyZmxhZyh0eXBlKTsKICBjb25zdCBjaGFyKiBjb25zdCB0eXBlc1tdID0gewogICAgICAiVU5ERUZJTkVEIiwgICAgICIwIiwKICAgICAgIkJPT0wiLCAgICAgICAgICAiSU5UIiwKICAgICAgIk9CSkVDVCIsICAgICAgICAiU1RSSU5HIiwKICAgICAgIlNZTUJPTCIsICAgICAgICAiQklHX0ZMT0FUIiwKICAgICAgIkJJR19JTlQiLCAgICAgICAiQklHX0RFQ0lNQUwiLAogICAgICAiRkxPQVQ2NCIsICAgICAgICJOQU4iLAogICAgICAiRlVOQ1RJT04iLCAgICAgICJBUlJBWSIsCiAgICAgICJNT0RVTEUiLCAgICAgICAgIkZVTkNUSU9OX0JZVEVDT0RFIiwKICAgICAgIlVOSU5JVElBTElaRUQiLCAiQ0FUQ0hfT0ZGU0VUIiwKICAgICAgIkVYQ0VQVElPTiIsCiAgfTsKICBpZihmbGFnID49IDAgJiYgZmxhZyA8IGNvdW50b2YodHlwZXMpKQogICAgcmV0dXJuIHR5cGVzW2ZsYWddOwogIHJldHVybiAwOwp9Cgpjb25zdCBjaGFyKgpqc192YWx1ZV90eXBlc3RyKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBpbnQzMl90IHR5cGUgPSBqc192YWx1ZV90eXBlKGN0eCwgdmFsdWUpOwogIHJldHVybiBqc192YWx1ZV90eXBlX25hbWUodHlwZSk7Cn0KCkJPT0wKanNfdmFsdWVfaGFzX3JlZl9jb3VudChKU1ZhbHVlIHYpIHsKICByZXR1cm4gKCh1bnNpZ25lZClqc192YWx1ZV90YWcodikgPj0gKHVuc2lnbmVkKUpTX1RBR19GSVJTVCk7Cn0KCmVudW0gdmFsdWVfbWFzawpqc192YWx1ZV90eXBlKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBpbnQzMl90IGZsYWc7CiAgdWludDMyX3QgdHlwZSA9IDA7CiAgaWYoKGZsYWcgPSBqc192YWx1ZV90eXBlX2dldChjdHgsIHZhbHVlKSkgPT0gLTEpCiAgICByZXR1cm4gMDsKCiAgaWYoZmxhZyA9PSBGTEFHX0FSUkFZIC8qfHwgZmxhZyA9PSBGTEFHX0ZVTkNUSU9OKi8pCiAgICB0eXBlIHw9IFRZUEVfT0JKRUNUOwoKICB0eXBlIHw9IDEgPDwgZmxhZzsKCiAgcmV0dXJuIHR5cGU7Cn0KCmludDMyX3QKanNfdmFsdWVfdHlwZV9nZXQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIGlmKEpTX0lzQXJyYXkoY3R4LCB2YWx1ZSkpCiAgICByZXR1cm4gRkxBR19BUlJBWTsKCiAgaWYoSlNfSXNGdW5jdGlvbihjdHgsIHZhbHVlKSkKICAgIHJldHVybiBGTEFHX0ZVTkNUSU9OOwoKICBpZihKU19WQUxVRV9JU19OQU4odmFsdWUpKQogICAgcmV0dXJuIEZMQUdfTkFOOwoKICByZXR1cm4ganNfdmFsdWVfdHlwZV9mbGFnKHZhbHVlKTsKfQoKaW50MzJfdApqc192YWx1ZV90eXBlX2ZsYWcoSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgc3dpdGNoKEpTX1ZBTFVFX0dFVF9UQUcodmFsdWUpKSB7CiAgICBjYXNlIEpTX1RBR19CSUdfREVDSU1BTDogcmV0dXJuIEZMQUdfQklHX0RFQ0lNQUw7CiAgICBjYXNlIEpTX1RBR19CSUdfSU5UOiByZXR1cm4gRkxBR19CSUdfSU5UOwogICAgY2FzZSBKU19UQUdfQklHX0ZMT0FUOiByZXR1cm4gRkxBR19CSUdfRkxPQVQ7CiAgICBjYXNlIEpTX1RBR19TWU1CT0w6IHJldHVybiBGTEFHX1NZTUJPTDsKICAgIGNhc2UgSlNfVEFHX1NUUklORzogcmV0dXJuIEZMQUdfU1RSSU5HOwogICAgY2FzZSBKU19UQUdfTU9EVUxFOiByZXR1cm4gRkxBR19NT0RVTEU7CiAgICBjYXNlIEpTX1RBR19GVU5DVElPTl9CWVRFQ09ERTogcmV0dXJuIEZMQUdfRlVOQ1RJT05fQllURUNPREU7CiAgICBjYXNlIEpTX1RBR19PQkpFQ1Q6IHJldHVybiBGTEFHX09CSkVDVDsKICAgIGNhc2UgSlNfVEFHX0lOVDogcmV0dXJuIEZMQUdfSU5UOwogICAgY2FzZSBKU19UQUdfQk9PTDogcmV0dXJuIEZMQUdfQk9PTDsKICAgIGNhc2UgSlNfVEFHX05VTEw6IHJldHVybiBGTEFHX05VTEw7CiAgICBjYXNlIEpTX1RBR19VTkRFRklORUQ6IHJldHVybiBGTEFHX1VOREVGSU5FRDsKICAgIGNhc2UgSlNfVEFHX1VOSU5JVElBTElaRUQ6IHJldHVybiBGTEFHX1VOSU5JVElBTElaRUQ7CiAgICBjYXNlIEpTX1RBR19DQVRDSF9PRkZTRVQ6IHJldHVybiBGTEFHX0NBVENIX09GRlNFVDsKICAgIGNhc2UgSlNfVEFHX0VYQ0VQVElPTjogcmV0dXJuIEZMQUdfRVhDRVBUSU9OOwogICAgY2FzZSBKU19UQUdfRkxPQVQ2NDogcmV0dXJuIEZMQUdfRkxPQVQ2NDsKICB9CiAgcmV0dXJuIC0xOwp9Cgp2b2lkCmpzX3ZhbHVlX2ZyZWUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWUgdikgewogIGlmKGpzX3ZhbHVlX2hhc19yZWZfY291bnQodikpIHsKICAgIEpTUmVmQ291bnRIZWFkZXIqIHAgPSAoSlNSZWZDb3VudEhlYWRlciopanNfdmFsdWVfcHRyKHYpOwogICAgaWYocC0+cmVmX2NvdW50ID4gMCkgewogICAgICAtLXAtPnJlZl9jb3VudDsKICAgICAgaWYocC0+cmVmX2NvdW50ID09IDApCiAgICAgICAgX19KU19GcmVlVmFsdWUoY3R4LCB2KTsKICAgIH0KICB9Cn0KCkpTVmFsdWUKanNfdmFsdWVfY2xvbmUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIGVudW0gdmFsdWVfbWFzayB0eXBlID0gMSA8PCBqc192YWx1ZV90eXBlX2dldChjdHgsIHZhbHVlKTsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKICBzd2l0Y2godHlwZSkgewogICAgLypjYXNlIFRZUEVfU1RSSU5HOiB7CiAgICAgc2l6ZV90IGxlbjsKICAgICBjb25zdCBjaGFyKiBzdHI7CiAgICAgc3RyID0gSlNfVG9DU3RyaW5nTGVuKGN0eCwgJmxlbiwgdmFsdWUpOwogICAgIHJldCA9IEpTX05ld1N0cmluZ0xlbihjdHgsIHN0ciwgbGVuKTsKICAgICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBzdHIpOwogICAgIGJyZWFrOwogICAgIH0qLwogICAgY2FzZSBUWVBFX0lOVDogewogICAgICByZXQgPSBKU19OZXdJbnQzMihjdHgsIEpTX1ZBTFVFX0dFVF9JTlQodmFsdWUpKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIFRZUEVfRkxPQVQ2NDogewogICAgICByZXQgPSBKU19OZXdGbG9hdDY0KGN0eCwgSlNfVkFMVUVfR0VUX0ZMT0FUNjQodmFsdWUpKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIFRZUEVfQk9PTDogewogICAgICByZXQgPSBKU19OZXdCb29sKGN0eCwgSlNfVkFMVUVfR0VUX0JPT0wodmFsdWUpKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIFRZUEVfRlVOQ1RJT046CiAgICBjYXNlIFRZUEVfQVJSQVk6CiAgICBjYXNlIFRZUEVfT0JKRUNUOiB7CiAgICAgIEpTUHJvcGVydHlFbnVtKiB0YWJfYXRvbTsKICAgICAgdWludDMyX3QgdGFiX2F0b21fbGVuOwogICAgICByZXQgPSBKU19Jc0FycmF5KGN0eCwgdmFsdWUpID8gSlNfTmV3QXJyYXkoY3R4KSA6IEpTX05ld09iamVjdChjdHgpOwogICAgICBpZighSlNfR2V0T3duUHJvcGVydHlOYW1lcyhjdHgsICZ0YWJfYXRvbSwgJnRhYl9hdG9tX2xlbiwgdmFsdWUsIEpTX0dQTl9TVFJJTkdfTUFTSyB8IEpTX0dQTl9TWU1CT0xfTUFTSyB8IEpTX0dQTl9FTlVNX09OTFkpKSB7CiAgICAgICAgdWludDMyX3QgaTsKICAgICAgICBmb3IoaSA9IDA7IGkgPCB0YWJfYXRvbV9sZW47IGkrKykgewogICAgICAgICAgSlNWYWx1ZSBwcm9wOwogICAgICAgICAgcHJvcCA9IEpTX0dldFByb3BlcnR5KGN0eCwgdmFsdWUsIHRhYl9hdG9tW2ldLmF0b20pOwogICAgICAgICAgSlNfU2V0UHJvcGVydHkoY3R4LCByZXQsIHRhYl9hdG9tW2ldLmF0b20sIGpzX3ZhbHVlX2Nsb25lKGN0eCwgcHJvcCkpOwogICAgICAgIH0KICAgICAgfQogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgVFlQRV9VTkRFRklORUQ6CiAgICBjYXNlIFRZUEVfTlVMTDoKICAgIGNhc2UgVFlQRV9TVFJJTkc6CiAgICBjYXNlIFRZUEVfU1lNQk9MOgogICAgY2FzZSBUWVBFX0JJR19ERUNJTUFMOgogICAgY2FzZSBUWVBFX0JJR19JTlQ6CiAgICBjYXNlIFRZUEVfQklHX0ZMT0FUOiB7CiAgICAgIHJldCA9IEpTX0R1cFZhbHVlKGN0eCwgdmFsdWUpOwogICAgICBicmVhazsKICAgIH0KICAgIGRlZmF1bHQ6IHsKICAgICAgcmV0ID0gSlNfVGhyb3dUeXBlRXJyb3IoY3R4LCAiTm8gc3VjaCB0eXBlOiAlcyAoMHglMDh4KVxuIiwganNfdmFsdWVfdHlwZV9uYW1lKHR5cGUpLCB0eXBlKTsKICAgICAgYnJlYWs7CiAgICB9CiAgfQogIHJldHVybiByZXQ7Cn0KCnZvaWQKanNfdmFsdWVfZndyaXRlKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsLCBGSUxFKiBmKSB7CiAgRHluQnVmIGRidWYgPSB7MH07CiAgc2l6ZV90IG47CiAganNfZGJ1Zl9pbml0KGN0eCwgJmRidWYpOwogIGpzX3ZhbHVlX2R1bXAoY3R4LCB2YWwsICZkYnVmKTsKICBkYnVmX3B1dGMoJmRidWYsICdcbicpOwogIG4gPSBkYnVmLnNpemU7CiAgZGJ1Zl8wKCZkYnVmKTsKICBmd3JpdGUoZGJ1Zi5idWYsIDEsIG4sIGYpOwogIGZmbHVzaChmKTsKICBkYnVmX2ZyZWUoJmRidWYpOwp9Cgp2b2lkCmpzX3ZhbHVlX2R1bXAoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSwgRHluQnVmKiBkYikgewogIGNvbnN0IGNoYXIqIHN0cjsKICBzaXplX3QgbGVuOwogIGlmKEpTX0lzT2JqZWN0KHZhbHVlKSkgewogICAgY29uc3QgY2hhciogc3RyID0ganNfb2JqZWN0X3Rvc3RyaW5nKGN0eCwgdmFsdWUpOwogICAgZGJ1Zl9wdXRzdHIoZGIsIHN0cik7CiAgICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBzdHIpOwogICAgaWYoZGItPnNpemUgJiYgZGItPmJ1ZltkYi0+c2l6ZSAtIDFdID09ICdcbicpCiAgICAgIGRiLT5zaXplLS07CiAgfSBlbHNlIHsKICAgIGludCBpc19zdHJpbmcgPSBKU19Jc1N0cmluZyh2YWx1ZSk7CgogICAgaWYoaXNfc3RyaW5nKQogICAgICBkYnVmX3B1dGMoZGIsICciJyk7CgogICAgc3RyID0gSlNfVG9DU3RyaW5nTGVuKGN0eCwgJmxlbiwgdmFsdWUpOwogICAgZGJ1Zl9hcHBlbmQoZGIsIChjb25zdCB1aW50OF90KilzdHIsIGxlbik7CgogICAganNfY3N0cmluZ19mcmVlKGN0eCwgc3RyKTsKCiAgICBpZihpc19zdHJpbmcpCiAgICAgIGRidWZfcHV0YyhkYiwgJyInKTsKICAgIGVsc2UgaWYoSlNfSXNCaWdGbG9hdCh2YWx1ZSkpCiAgICAgIGRidWZfcHV0YyhkYiwgJ2wnKTsKICAgIGVsc2UgaWYoSlNfSXNCaWdEZWNpbWFsKHZhbHVlKSkKICAgICAgZGJ1Zl9wdXRjKGRiLCAnbScpOwogICAgZWxzZSBpZihKU19Jc0JpZ0ludChjdHgsIHZhbHVlKSkKICAgICAgZGJ1Zl9wdXRjKGRiLCAnbicpOwogIH0KfQoKQk9PTApqc192YWx1ZV9lcXVhbHMoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBhLCBKU1ZhbHVlQ29uc3QgYikgewogIGludDMyX3QgdGEsIHRiOwogIEJPT0wgcmV0ID0gRkFMU0U7CiAgdGEgPSBqc192YWx1ZV90eXBlKGN0eCwgYSk7CiAgdGIgPSBqc192YWx1ZV90eXBlKGN0eCwgYik7CgogIGlmKHRhICE9IHRiKSB7CiAgICByZXQgPSBGQUxTRTsKICB9IGVsc2UgaWYodGEgJiB0YiAmIChUWVBFX05VTEwgfCBUWVBFX1VOREVGSU5FRCB8IFRZUEVfTkFOKSkgewogICAgcmV0ID0gVFJVRTsKICB9IGVsc2UgaWYodGEgJiB0YiAmIChUWVBFX0JJR19JTlQgfCBUWVBFX0JJR19GTE9BVCB8IFRZUEVfQklHX0RFQ0lNQUwpKSB7CiAgICBjb25zdCBjaGFyICphc3RyLCAqYnN0cjsKCiAgICBhc3RyID0gSlNfVG9DU3RyaW5nKGN0eCwgYSk7CiAgICBic3RyID0gSlNfVG9DU3RyaW5nKGN0eCwgYik7CgogICAgcmV0ID0gIXN0cmNtcChhc3RyLCBic3RyKTsKCiAgICBKU19GcmVlQ1N0cmluZyhjdHgsIGFzdHIpOwogICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBic3RyKTsKCiAgfSBlbHNlIGlmKHRhICYgVFlQRV9JTlQpIHsKICAgIGludDMyX3QgaW50YSwgaW50YjsKCiAgICBpbnRhID0gSlNfVkFMVUVfR0VUX0lOVChhKTsKICAgIGludGIgPSBKU19WQUxVRV9HRVRfSU5UKGIpOwogICAgcmV0ID0gaW50YSA9PSBpbnRiOwogIH0gZWxzZSBpZih0YSAmIFRZUEVfQk9PTCkgewogICAgQk9PTCBib29sYSwgYm9vbGI7CgogICAgYm9vbGEgPSAhIUpTX1ZBTFVFX0dFVF9CT09MKGEpOwogICAgYm9vbGIgPSAhIUpTX1ZBTFVFX0dFVF9CT09MKGIpOwogICAgcmV0ID0gYm9vbGEgPT0gYm9vbGI7CgogIH0gZWxzZSBpZih0YSAmIFRZUEVfRkxPQVQ2NCkgewogICAgZG91YmxlIGZsdGEsIGZsdGI7CgogICAgZmx0YSA9IEpTX1ZBTFVFX0dFVF9GTE9BVDY0KGEpOwogICAgZmx0YiA9IEpTX1ZBTFVFX0dFVF9GTE9BVDY0KGIpOwogICAgcmV0ID0gZmx0YSA9PSBmbHRiOwoKICB9IGVsc2UgaWYodGEgJiBUWVBFX09CSkVDVCkgewogICAgcmV0ID0ganNfb2JqZWN0X2VxdWFscyhjdHgsIGEsIGIpOwogICAgLyp2b2lkICpvYmphLCAqb2JqYjsKCiAgICBvYmphID0gSlNfVkFMVUVfR0VUX09CSihhKTsKICAgIG9iamIgPSBKU19WQUxVRV9HRVRfT0JKKGIpOwoKICAgIHJldCA9IG9iamEgPT0gb2JqYjsqLwogIH0gZWxzZSBpZih0YSAmIFRZUEVfU1RSSU5HKSB7CiAgICBjb25zdCBjaGFyICpzdHJhLCAqc3RyYjsKCiAgICBzdHJhID0gSlNfVG9DU3RyaW5nKGN0eCwgYSk7CiAgICBzdHJiID0gSlNfVG9DU3RyaW5nKGN0eCwgYik7CgogICAgcmV0ID0gIXN0cmNtcChzdHJhLCBzdHJiKTsKCiAgICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBzdHJhKTsKICAgIGpzX2NzdHJpbmdfZnJlZShjdHgsIHN0cmIpOwogIH0KCiAgcmV0dXJuIHJldDsKfQoKSlNWYWx1ZQpqc192YWx1ZV9mcm9tX2NoYXIoSlNDb250ZXh0KiBjdHgsIGludCBjKSB7CiAgdWludDhfdCBidWZbMTZdOwogIHNpemVfdCBsZW4gPSB1bmljb2RlX3RvX3V0ZjgoYnVmLCBjKTsKICByZXR1cm4gSlNfTmV3U3RyaW5nTGVuKGN0eCwgKGNvbnN0IGNoYXIqKWJ1ZiwgbGVuKTsKfQoKdm9pZApqc192YWx1ZV9wcmludChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgRHluQnVmIGRidWY7CiAganNfZGJ1Zl9pbml0KGN0eCwgJmRidWYpOwogIGpzX3ZhbHVlX2R1bXAoY3R4LCB2YWx1ZSwgJmRidWYpOwogIGRidWZfMCgmZGJ1Zik7CiAgZnB1dHMoKGNvbnN0IGNoYXIqKWRidWYuYnVmLCBzdGRvdXQpOwogIGRidWZfZnJlZSgmZGJ1Zik7Cn0KCmludApqc192YWx1ZV90b3NpemUoSlNDb250ZXh0KiBjdHgsIHNpemVfdCogc3osIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIHVpbnQ2NF90IHU2NCA9IDA7CiAgaW50IHI7CiAgciA9IEpTX1RvSW5kZXgoY3R4LCAmdTY0LCB2YWx1ZSk7CiAgKnN6ID0gdTY0OwogIHJldHVybiByOwp9Cgp2b2lkCmpzX3ZhbHVlX2ZyZWVfcnQoSlNSdW50aW1lKiBydCwgSlNWYWx1ZSB2KSB7CiAgaWYoanNfdmFsdWVfaGFzX3JlZl9jb3VudCh2KSkgewogICAgSlNSZWZDb3VudEhlYWRlciogcCA9IChKU1JlZkNvdW50SGVhZGVyKilqc192YWx1ZV9wdHIodik7CiAgICAtLXAtPnJlZl9jb3VudDsKICAgIGlmKHAtPnJlZl9jb3VudCA9PSAwKQogICAgICBfX0pTX0ZyZWVWYWx1ZVJUKHJ0LCB2KTsKICB9Cn0KCmNoYXIqCmpzX2NzdHJpbmdfcHRyKEpTVmFsdWVDb25zdCB2KSB7CiAgSlNTdHJpbmcqIHA7CgogIGlmKEpTX0lzU3RyaW5nKHYpKSB7CiAgICBwID0gSlNfVkFMVUVfR0VUX1BUUih2KTsKICAgIHJldHVybiAoY2hhciopcC0+dS5zdHI4OwogIH0KICByZXR1cm4gMDsKfQpjaGFyKgpqc19jc3RyaW5nX2R1cChKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogc3RyKSB7CiAgSlNTdHJpbmcqIHA7CiAgaWYoIXN0cikKICAgIHJldHVybiAwOwogIC8qIHB1cnBvc2VseSByZW1vdmluZyBjb25zdG5lc3MgKi8KICBwID0gKEpTU3RyaW5nKikodm9pZCopKHN0ciAtIG9mZnNldG9mKEpTU3RyaW5nLCB1KSk7CiAgSlNfRHVwVmFsdWUoY3R4LCBKU19NS1BUUihKU19UQUdfU1RSSU5HLCBwKSk7CiAgcmV0dXJuIChjaGFyKilzdHI7Cn0KCkpTVmFsdWVDb25zdApqc19jc3RyaW5nX3ZhbHVlKGNvbnN0IGNoYXIqIHB0cikgewogIEpTU3RyaW5nKiBwOwogIGlmKCFwdHIpCiAgICByZXR1cm4gSlNfVU5ERUZJTkVEOwoKICBwID0gKEpTU3RyaW5nKikodm9pZCopKHB0ciAtIG9mZnNldG9mKEpTU3RyaW5nLCB1KSk7CiAgcmV0dXJuIEpTX01LUFRSKEpTX1RBR19TVFJJTkcsIHApOwp9Cgp2b2lkCmpzX2NzdHJpbmdfZHVtcChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlLCBEeW5CdWYqIGRiKSB7CiAgY29uc3QgY2hhciogc3RyOwogIHNpemVfdCBsZW47CgogIHN0ciA9IEpTX1RvQ1N0cmluZ0xlbihjdHgsICZsZW4sIHZhbHVlKTsKICBkYnVmX2FwcGVuZChkYiwgKGNvbnN0IHVpbnQ4X3QqKXN0ciwgbGVuKTsKCiAganNfY3N0cmluZ19mcmVlKGN0eCwgc3RyKTsKfQoKSlNWYWx1ZQpqc19tYXBfbmV3KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgZW50cmllcykgewogIEpTVmFsdWUgbWFwLCBjdG9yID0ganNfZ2xvYmFsX2dldChjdHgsICJNYXAiKTsKICBtYXAgPSBKU19DYWxsQ29uc3RydWN0b3IoY3R4LCBjdG9yLCAxLCAmZW50cmllcyk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgY3Rvcik7CiAgcmV0dXJuIG1hcDsKfQoKSlNWYWx1ZQptb2R1bGVfbmFtZShKU0NvbnRleHQqIGN0eCwgSlNNb2R1bGVEZWYqIG1vZHVsZSkgewogIGlmKG1vZHVsZS0+bW9kdWxlX25hbWUgPCBjdHgtPnJ0LT5hdG9tX2NvdW50KQogICAgcmV0dXJuIEpTX0F0b21Ub1ZhbHVlKGN0eCwgbW9kdWxlLT5tb2R1bGVfbmFtZSk7CgogIHJldHVybiBKU19VTkRFRklORUQ7Cn0KCmNoYXIqCm1vZHVsZV9uYW1lc3RyKEpTQ29udGV4dCogY3R4LCBKU01vZHVsZURlZiogbW9kdWxlKSB7CiAgY29uc3QgY2hhciAgKm5hbWUgPSBKU19BdG9tVG9DU3RyaW5nKGN0eCwgbW9kdWxlLT5tb2R1bGVfbmFtZSk7CiBjaGFyKiBzdHIgPSBqc19zdHJkdXAoY3R4LCBuYW1lKTsKICBKU19GcmVlQ1N0cmluZyhjdHgsIG5hbWUpOwogIHJldHVybiBzdHI7Cn0KCnN0YXRpYyBKU1ZhbHVlCmNhbGxfbW9kdWxlX2Z1bmMoSlNDb250ZXh0ICpjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCAqYXJndiwgaW50IG1hZ2ljLCBKU1ZhbHVlICpkYXRhKSB7CiAgdW5pb24gewogICAgSlNNb2R1bGVJbml0RnVuYyogaW5pdF9mdW5jOwogICAgaW50MzJfdCBpWzJdOwogIH0gdTsKCiAgdS5pWzBdID0gSlNfVkFMVUVfR0VUX0lOVChkYXRhWzBdKTsKICB1LmlbMV0gPSBKU19WQUxVRV9HRVRfSU5UKGRhdGFbMV0pOwoKICBpZihhcmdjID49IDEgJiYgSlNfSXNNb2R1bGUoYXJndlswXSkpCiAgICByZXR1cm4gSlNfTmV3SW50MzIoY3R4LCB1LmluaXRfZnVuYyhjdHgsIEpTX1ZBTFVFX0dFVF9QVFIoYXJndlswXSkpKTsKCiAgcmV0dXJuIEpTX1Rocm93VHlwZUVycm9yKGN0eCwgImFyZ3VtZW50IDEgbW9kdWxlIGV4cGVjdGVkIik7Cn0KCkpTVmFsdWUKbW9kdWxlX2Z1bmMoSlNDb250ZXh0KiBjdHgsIEpTTW9kdWxlRGVmKiBtb2R1bGUpIHsKICBKU1ZhbHVlIGZ1bmMgPSBKU19VTkRFRklORUQ7CiAgaWYoSlNfSXNGdW5jdGlvbihjdHgsIG1vZHVsZS0+ZnVuY19vYmopKSB7CiAgICBmdW5jID0gSlNfRHVwVmFsdWUoY3R4LCBtb2R1bGUtPmZ1bmNfb2JqKTsKICB9IGVsc2UgaWYobW9kdWxlLT5pbml0X2Z1bmMpIHsKICAgIHVuaW9uIHsKICAgICAgSlNNb2R1bGVJbml0RnVuYyogaW5pdF9mdW5jOwogICAgICBpbnQzMl90IGlbMl07CiAgICB9IHUgPSB7bW9kdWxlLT5pbml0X2Z1bmN9OwogICAgSlNWYWx1ZUNvbnN0IGRhdGFbMl0gPSB7CiAgICAgICAgSlNfTUtWQUwoSlNfVEFHX0lOVCwgdS5pWzBdKSwKICAgICAgICBKU19NS1ZBTChKU19UQUdfSU5ULCB1LmlbMV0pLAogICAgfTsKICAgIGZ1bmMgPSBKU19OZXdDRnVuY3Rpb25EYXRhKGN0eCwgY2FsbF9tb2R1bGVfZnVuYywgMSwgMCwgMiwgZGF0YSk7CiAgfQogIHJldHVybiBmdW5jOwp9CgpKU1ZhbHVlCm1vZHVsZV9ucyhKU0NvbnRleHQqIGN0eCwgSlNNb2R1bGVEZWYqIG1vZHVsZSkgewogIHJldHVybiBKU19EdXBWYWx1ZShjdHgsIG1vZHVsZS0+bW9kdWxlX25zKTsKfQoKdm9pZApnZXRfbW9kdWxlX2V4cG9ydHMoSlNDb250ZXh0KiBjdHgsIEpTTW9kdWxlRGVmKiBtb2R1bGUsIEJPT0wgcmVuYW1lX2RlZmF1bHQsIEpTVmFsdWVDb25zdCBleHBvcnRzKSB7CiAgSlNBdG9tIGRlZiA9IEpTX05ld0F0b20oY3R4LCAiZGVmYXVsdCIpOwoKICBzaXplX3QgaTsKICBmb3IoaSA9IDA7IGkgPCBtb2R1bGUtPmV4cG9ydF9lbnRyaWVzX2NvdW50OyBpKyspIHsKICAgIEpTRXhwb3J0RW50cnkqIGVudHJ5ID0gJm1vZHVsZS0+ZXhwb3J0X2VudHJpZXNbaV07CiAgICBKU1ZhclJlZiogcmVmID0gZW50cnktPnUubG9jYWwudmFyX3JlZjsKICAgIGlmKHJlZikgewogICAgICBKU1ZhbHVlIGV4cG9ydCA9IEpTX0R1cFZhbHVlKGN0eCwgcmVmLT5wdmFsdWUgPyAqcmVmLT5wdmFsdWUgOiByZWYtPnZhbHVlKTsKICAgICAgSlNBdG9tIG5hbWUgPSBlbnRyeS0+ZXhwb3J0X25hbWU7CiAgICAgIGlmKHJlbmFtZV9kZWZhdWx0ICYmIG5hbWUgPT0gZGVmKQogICAgICAgIG5hbWUgPSBtb2R1bGUtPm1vZHVsZV9uYW1lOwogICAgICBKU19TZXRQcm9wZXJ0eShjdHgsIGV4cG9ydHMsIG5hbWUsIGV4cG9ydCk7CiAgICB9CiAgfQogIEpTX0ZyZWVBdG9tKGN0eCwgZGVmKTsKfQoKSlNWYWx1ZQptb2R1bGVfZXhwb3J0cyhKU0NvbnRleHQqIGN0eCwgSlNNb2R1bGVEZWYqIG1vZHVsZSkgewogIEpTVmFsdWUgZXhwb3J0cyA9IEpTX05ld09iamVjdChjdHgpOwogIGdldF9tb2R1bGVfZXhwb3J0cyhjdHgsIG1vZHVsZSwgRkFMU0UsIGV4cG9ydHMpOwogIHJldHVybiBleHBvcnRzOwp9CgpzdHJ1Y3QgbGlzdF9oZWFkKgpqc19tb2R1bGVzX2xpc3QoSlNDb250ZXh0KiBjdHgpIHsKICByZXR1cm4gJmN0eC0+bG9hZGVkX21vZHVsZXM7Cn0KCkpTVmFsdWUKanNfbW9kdWxlc19hcnJheShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgbWFnaWMpIHsKICBzdHJ1Y3QgbGlzdF9oZWFkKiBlbDsKICBKU1ZhbHVlIHJldCA9IEpTX05ld0FycmF5KGN0eCk7CiAgdWludDMyX3QgaSA9IDA7CiAgbGlzdF9mb3JfZWFjaChlbCwgJmN0eC0+bG9hZGVkX21vZHVsZXMpIHsKICAgIEpTTW9kdWxlRGVmKiBkZWYgPSBsaXN0X2VudHJ5KGVsLCBKU01vZHVsZURlZiwgbGluayk7CiAgICAgIGNoYXIqIHN0ciA9IG1vZHVsZV9uYW1lc3RyKGN0eCwgZGVmKTsKICAgIEpTVmFsdWUgZW50cnkgPSBtYWdpYyA/IG1vZHVsZV9lbnRyeShjdHgsIGRlZikgOiBtb2R1bGVfdmFsdWUoY3R4LCBkZWYpOwogICAgaWYoc3RyWzBdICE9ICc8JykKICAgICAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCByZXQsIGkrKywgZW50cnkpOwogICAgZWxzZQogICAgICBKU19GcmVlVmFsdWUoY3R4LCBlbnRyeSk7CiAgICBqc19mcmVlKGN0eCwgc3RyKTsKICB9CiAgcmV0dXJuIHJldDsKfQoKSlNWYWx1ZQpqc19tb2R1bGVzX2VudHJpZXMoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IG1hZ2ljKSB7CiAgc3RydWN0IGxpc3RfaGVhZCogZWw7CiAgSlNWYWx1ZSByZXQgPSBKU19OZXdBcnJheShjdHgpOwogIHVpbnQzMl90IGkgPSAwOwogIGxpc3RfZm9yX2VhY2goZWwsICZjdHgtPmxvYWRlZF9tb2R1bGVzKSB7CiAgICBKU01vZHVsZURlZiogZGVmID0gbGlzdF9lbnRyeShlbCwgSlNNb2R1bGVEZWYsIGxpbmspOwogICAgICBjaGFyKiBuYW1lID0gbW9kdWxlX25hbWVzdHIoY3R4LCBkZWYpOwogICAgSlNWYWx1ZSBlbnRyeSA9IEpTX05ld0FycmF5KGN0eCk7CiAgICBKU19TZXRQcm9wZXJ0eVVpbnQzMihjdHgsIGVudHJ5LCAwLCBKU19OZXdTdHJpbmcoY3R4LCAvKmJhc2VuYW1lKi8gKG5hbWUpKSk7CiAgICBKU19TZXRQcm9wZXJ0eVVpbnQzMihjdHgsIGVudHJ5LCAxLCBtYWdpYyA/IG1vZHVsZV9lbnRyeShjdHgsIGRlZikgOiBtb2R1bGVfdmFsdWUoY3R4LCBkZWYpKTsKICAgIGlmKG5hbWVbMF0gIT0gJzwnKQogICAgICBKU19TZXRQcm9wZXJ0eVVpbnQzMihjdHgsIHJldCwgaSsrLCBlbnRyeSk7CiAgICBlbHNlCiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGVudHJ5KTsKICAgIGpzX2ZyZWUoY3R4LCBuYW1lKTsKICB9CiAgcmV0dXJuIHJldDsKfQoKSlNWYWx1ZQpqc19tb2R1bGVzX21hcChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgbWFnaWMpIHsKICBKU1ZhbHVlIG1hcCwgZW50cmllcyA9IGpzX21vZHVsZXNfZW50cmllcyhjdHgsIHRoaXNfdmFsLCBtYWdpYyk7CiAgbWFwID0ganNfbWFwX25ldyhjdHgsIGVudHJpZXMpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGVudHJpZXMpOwogIHJldHVybiBtYXA7Cn0KCkpTVmFsdWUKanNfbW9kdWxlc19vYmplY3QoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IG1hZ2ljKSB7CiAgc3RydWN0IGxpc3RfaGVhZCogaXQ7CiAgSlNWYWx1ZSBvYmogPSBKU19OZXdPYmplY3QoY3R4KTsKICBsaXN0X2Zvcl9lYWNoKGl0LCAmY3R4LT5sb2FkZWRfbW9kdWxlcykgewogICAgSlNNb2R1bGVEZWYqIGRlZiA9IGxpc3RfZW50cnkoaXQsIEpTTW9kdWxlRGVmLCBsaW5rKTsKICAgICAgY2hhciogbmFtZSA9IG1vZHVsZV9uYW1lc3RyKGN0eCwgZGVmKTsKICAgIEpTVmFsdWUgZW50cnkgPSBtYWdpYyA/IG1vZHVsZV9lbnRyeShjdHgsIGRlZikgOiBtb2R1bGVfdmFsdWUoY3R4LCBkZWYpOwogICAgaWYobmFtZVswXSAhPSAnPCcpCiAgICAgIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgb2JqLCBiYXNlbmFtZShuYW1lKSwgZW50cnkpOwogICAgZWxzZQogICAgICBKU19GcmVlVmFsdWUoY3R4LCBlbnRyeSk7CiAgICBqc19mcmVlKGN0eCwgbmFtZSk7CiAgfQogIHJldHVybiBvYmo7Cn0KCkpTVmFsdWUKbW9kdWxlX3ZhbHVlKEpTQ29udGV4dCogY3R4LCBKU01vZHVsZURlZiogZGVmKSB7CiAgcmV0dXJuIEpTX0R1cFZhbHVlKGN0eCwgSlNfTUtQVFIoSlNfVEFHX01PRFVMRSwgZGVmKSk7Cn0KCkpTVmFsdWUKbW9kdWxlX2VudHJ5KEpTQ29udGV4dCogY3R4LCBKU01vZHVsZURlZiogZGVmKSB7CiAgSlNWYWx1ZSBlbnRyeSA9IEpTX05ld0FycmF5KGN0eCk7CiAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCBlbnRyeSwgMCwgbW9kdWxlX25zKGN0eCwgZGVmKSk7CiAgSlNfU2V0UHJvcGVydHlVaW50MzIoY3R4LCBlbnRyeSwgMSwgbW9kdWxlX2V4cG9ydHMoY3R4LCBkZWYpKTsKICBKU19TZXRQcm9wZXJ0eVVpbnQzMihjdHgsIGVudHJ5LCAyLCBtb2R1bGVfZnVuYyhjdHgsIGRlZikpOwogIHJldHVybiBlbnRyeTsKfQoKSlNWYWx1ZQptb2R1bGVfb2JqZWN0KEpTQ29udGV4dCogY3R4LCBKU01vZHVsZURlZiogZGVmKSB7CiAgSlNWYWx1ZSBucywgZXhwb3J0cywgZnVuYywgb2JqID0gSlNfTmV3T2JqZWN0KGN0eCk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCBvYmosICJuYW1lIiwgbW9kdWxlX25hbWUoY3R4LCBkZWYpKTsKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgInJlc29sdmVkIiwgSlNfTmV3Qm9vbChjdHgsIGRlZi0+cmVzb2x2ZWQpKTsKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgImZ1bmNfY3JlYXRlZCIsIEpTX05ld0Jvb2woY3R4LCBkZWYtPmZ1bmNfY3JlYXRlZCkpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgb2JqLCAiaW5zdGFudGlhdGVkIiwgSlNfTmV3Qm9vbChjdHgsIGRlZi0+aW5zdGFudGlhdGVkKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCBvYmosICJldmFsdWF0ZWQiLCBKU19OZXdCb29sKGN0eCwgZGVmLT5ldmFsdWF0ZWQpKTsKCiAgbnMgPSBtb2R1bGVfbnMoY3R4LCBkZWYpOwogIGlmKCFKU19Jc1VuZGVmaW5lZChucykpCiAgICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIG9iaiwgIm5zIiwgbnMpOwogIGV4cG9ydHMgPSBtb2R1bGVfZXhwb3J0cyhjdHgsIGRlZik7CiAgaWYoIUpTX0lzVW5kZWZpbmVkKGV4cG9ydHMpKQogICAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCBvYmosICJleHBvcnRzIiwgbW9kdWxlX2V4cG9ydHMoY3R4LCBkZWYpKTsKICBmdW5jID0gbW9kdWxlX2Z1bmMoY3R4LCBkZWYpOwogIGlmKCFKU19Jc1VuZGVmaW5lZChmdW5jKSkKICAgIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgb2JqLCAiZnVuYyIsIGZ1bmMpOwogIHJldHVybiBvYmo7Cn0KCmNoYXIqCmpzX21vZHVsZV9zZWFyY2goSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqc2VhcmNoX3BhdGgsIGNvbnN0IGNoYXIqIG1vZHVsZSkgewogIHNpemVfdCBsZW47CiAgY2hhcipwYXRoID0gMDsKCiAgd2hpbGUoIXN0cm5jbXAobW9kdWxlLCAiLi8iLCAyKSkgbW9kdWxlID0gdHJpbV9kb3RzbGFzaChtb2R1bGUpOwogIGxlbiA9IHN0cmxlbihtb2R1bGUpOwoKICBpZighc3RyX2NvbnRhaW5zKG1vZHVsZSwgJy8nKSB8fCBzdHJfZW5kcyhtb2R1bGUsICIuc28iKSkKICAgIHBhdGggPSBqc19tb2R1bGVfc2VhcmNoX2V4dChjdHgsc2VhcmNoX3BhdGgsICBtb2R1bGUsICIuc28iKTsKCiAgaWYoIXBhdGgpCiAgICBwYXRoID0ganNfbW9kdWxlX3NlYXJjaF9leHQoY3R4LCBzZWFyY2hfcGF0aCwgbW9kdWxlLCAiLmpzIik7CgogIHJldHVybiBwYXRoOwp9CgpjaGFyKgpqc19tb2R1bGVfc2VhcmNoX2V4dChKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogcGF0aCwgY29uc3QgY2hhciogbmFtZSwgY29uc3QgY2hhciogZXh0KSB7CiAgY29uc3QgY2hhciAgKnAsICpxOwogIGNoYXIqIGZpbGUgPSAwOwogIHNpemVfdCBpLCBqOwogIHN0cnVjdCBzdGF0IHN0OwoKICAgIGZvcihwID0gcGF0aDsgKnA7IHAgPSBxKSB7CiAgICBpZigocSA9IHN0cmNocihwLCAnOicpKSA9PSAwKQogICAgICBxID0gcCArIHN0cmxlbihwKTsKICAgIGkgPSBxIC0gcDsKICAgIGZpbGUgPSBqc19tYWxsb2MoY3R4LCBpICsgMSArIHN0cmxlbihuYW1lKSArIDMgKyAxKTsKICAgIHN0cm5jcHkoZmlsZSwgcCwgaSk7CiAgICBmaWxlW2ldID0gJy8nOwogICAgc3RyY3B5KCZmaWxlW2kgKyAxXSwgbmFtZSk7CiAgICBqID0gc3RybGVuKG5hbWUpOwogICAgaWYoIShqID49IDMgJiYgIXN0cmNtcCgmbmFtZVtqIC0gM10sIGV4dCkpKQogICAgICBzdHJjcHkoJmZpbGVbaSArIDEgKyBqXSwgZXh0KTsKICAgIGlmKCFzdGF0KGZpbGUsICZzdCkpCiAgICAgIHJldHVybiBmaWxlOwogICAganNfZnJlZShjdHgsIGZpbGUpOwogICAgaWYoKnEgPT0gJzonKQogICAgICArK3E7CiAgfQogIHJldHVybiAwOwp9CgpjaGFyKgpqc19tb2R1bGVfbm9ybWFsaXplKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBwYXRoLCBjb25zdCBjaGFyKiBuYW1lLCB2b2lkKiBvcGFxdWUpIHsKICBzaXplX3QgcDsKICBjb25zdCBjaGFyKiByOwogIER5bkJ1ZiBmaWxlID0gezAsIDAsIDB9OwogIHNpemVfdCBuOwogIGlmKG5hbWVbMF0gIT0gJy4nKQogICAgcmV0dXJuIGpzX3N0cmR1cChjdHgsIG5hbWUpOwogIGpzX2RidWZfaW5pdChjdHgsICZmaWxlKTsKICBuID0gcGF0aFsocCA9IHN0cl9yY2hyKHBhdGgsICcvJykpXSA/IHAgOiAwOwogIGRidWZfcHV0KCZmaWxlLCAoY29uc3QgdWludDhfdCopcGF0aCwgbik7CiAgZGJ1Zl8wKCZmaWxlKTsKICBmb3IociA9IG5hbWU7OykgewogICAgaWYoclswXSA9PSAnLicgJiYgclsxXSA9PSAnLycpIHsKICAgICAgciArPSAyOwogICAgfSBlbHNlIGlmKHJbMF0gPT0gJy4nICYmIHJbMV0gPT0gJy4nICYmIHJbMl0gPT0gJy8nKSB7CiAgICAgIGlmKGZpbGUuc2l6ZSA9PSAwKQogICAgICAgIGJyZWFrOwogICAgICBpZigocCA9IGJ5dGVfcmNocihmaWxlLmJ1ZiwgZmlsZS5zaXplLCAnLycpKSA8IGZpbGUuc2l6ZSkKICAgICAgICBwKys7CiAgICAgIGVsc2UKICAgICAgICBwID0gMDsKICAgICAgaWYoIXN0cmNtcCgoY29uc3QgY2hhciopJmZpbGUuYnVmW3BdLCAiLiIpIHx8ICFzdHJjbXAoKGNvbnN0IGNoYXIqKSZmaWxlLmJ1ZltwXSwgIi4uIikpCiAgICAgICAgYnJlYWs7CiAgICAgIGlmKHAgPiAwKQogICAgICAgIHAtLTsKICAgICAgZmlsZS5zaXplID0gcDsKICAgICAgciArPSAzOwogICAgfSBlbHNlIHsKICAgICAgYnJlYWs7CiAgICB9CiAgfQogIGlmKGZpbGUuc2l6ZSA9PSAwKQogICAgZGJ1Zl9wdXRjKCZmaWxlLCAnLicpOwogIGRidWZfcHV0YygmZmlsZSwgJy8nKTsKICBkYnVmX3B1dHN0cigmZmlsZSwgcik7CiAgZGJ1Zl8wKCZmaWxlKTsKICByZXR1cm4gKGNoYXIqKWZpbGUuYnVmOwp9CgpKU01vZHVsZURlZioKanNfbW9kdWxlX2RlZihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgSlNNb2R1bGVEZWYqIGRlZiA9IDA7CiAgaWYoSlNfSXNTdHJpbmcodmFsdWUpKSB7CiAgICBjb25zdCBjaGFyKiBuYW1lID0gSlNfVG9DU3RyaW5nKGN0eCwgdmFsdWUpOwogICAgZGVmID0ganNfbW9kdWxlX2ZpbmQoY3R4LCBuYW1lKTsKICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgbmFtZSk7CiAgfSBlbHNlIGlmKEpTX1ZBTFVFX0dFVF9UQUcodmFsdWUpID09IEpTX1RBR19NT0RVTEUpIHsKICAgIGRlZiA9IEpTX1ZBTFVFX0dFVF9QVFIodmFsdWUpOwogIH0KICByZXR1cm4gZGVmOwp9CgpKU01vZHVsZURlZioKanNfbW9kdWxlX2ZpbmQoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIG5hbWUpIHsKICBzdHJ1Y3QgbGlzdF9oZWFkKiBlbDsKICBzaXplX3QgbmFtZWxlbiA9IHN0cmxlbihuYW1lKTsKICBsaXN0X2Zvcl9lYWNoKGVsLCAmY3R4LT5sb2FkZWRfbW9kdWxlcykgewogICAgSlNNb2R1bGVEZWYqIG1vZCA9IGxpc3RfZW50cnkoZWwsIEpTTW9kdWxlRGVmLCBsaW5rKTsKICAgICAgY2hhciAqbiwgKnN0ciA9IG1vZHVsZV9uYW1lc3RyKGN0eCwgbW9kKTsKICAgIHNpemVfdCBsZW47CiAgICBuID0gYmFzZW5hbWUoc3RyKTsKICAgIGxlbiA9IHN0cl9yY2hyKG4sICcuJyk7CiAgICBpZighc3RyY21wKHN0ciwgbmFtZSkgfHwgIXN0cmNtcChuLCBuYW1lKSB8fCAobGVuID09IG5hbWVsZW4gJiYgIXN0cm5jbXAobiwgbmFtZSwgbGVuKSkpCiAgICAgIHJldHVybiBtb2Q7CiAgICBqc19mcmVlKGN0eCwgc3RyKTsKICB9CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkCmpzX2ltcG9ydF9kaXJlY3RpdmUoSlNDb250ZXh0KiBjdHgsIEltcG9ydERpcmVjdGl2ZSBpbXAsIER5bkJ1ZiogZGIpIHsKICBCT09MIGhhc19wcm9wID0gaW1wLnByb3AgJiYgaW1wLnByb3BbMF07CiAgQk9PTCBpc19ucyA9IGltcC5zcGVjICYmIGltcC5zcGVjWzBdID09ICcqJzsKICBjb25zdCBjaGFyKiB2YXIsICogYmFzZSA9IGJhc2VuYW1lKGltcC5wYXRoKTsKICBzaXplX3QgYmxlbiA9IHN0cl9jaHIoYmFzZSwgJy4nKTsKICBkYnVmX3B1dHN0cihkYiwgImltcG9ydCAiKTsKICBpZihpbXAuc3BlYykgewogICAgZGJ1Zl9wdXRzdHIoZGIsIGltcC5zcGVjKTsKICAgIGlmKGlzX25zKSB7CiAgICAgIGlmKCFpbXAubnMpCiAgICAgICAgaW1wLm5zID0ganNfc3RybmR1cChjdHgsIGJhc2UsIGJsZW4pOwogICAgICBkYnVmX3B1dHN0cihkYiwgIiBhcyAiKTsKICAgIH0KICB9CiAgaWYoaW1wLnNwZWMgPT0gMCB8fCBzdHJfZXF1YWwoaW1wLnNwZWMsICJkZWZhdWx0IikpIHsKICAgIGlmKCFpbXAubnMpCiAgICAgIGltcC5ucyA9IGpzX3N0cm5kdXAoY3R4LCBiYXNlLCBibGVuKTsKICB9CiAgaWYoaW1wLm5zKQogICAgZGJ1Zl9wdXRtKGRiLCBpbXAubnMsIDApOwogIGlmKGltcC5wYXRoKQogICAgZGJ1Zl9wdXRtKGRiLCAiIGZyb20gJyIsIGltcC5wYXRoLCAiJyIsIDApOwogIGlmKCEodmFyID0gaW1wLnZhcikpCiAgICBpZighKHZhciA9IGltcC5ucykpCiAgICAgIHZhciA9IGltcC5zcGVjOwogIGRidWZfcHV0c3RyKGRiLCAiO1xuIik7CgogIGlmKChoYXNfcHJvcCB8fCBpc19ucykgJiYgdmFyWzBdICE9ICcqJykgewogICAgZGJ1Zl9wdXRtKGRiLCAiZ2xvYmFsVGhpcy4iLCB2YXIsICIgPSAiLCBpbXAubnMgPyBpbXAubnMgOiBpbXAuc3BlYywgaW1wLnByb3AgJiYgKmltcC5wcm9wID8gIi4iIDogMCwgaW1wLnByb3AsIDApOwogIH0gZWxzZSB7CiAgICBkYnVmX3B1dG0oZGIsICJPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsICIsIGltcC5ucyA/IGltcC5ucyA6IGltcC5zcGVjLCAwKTsKICAgIGRidWZfcHV0YyhkYiwgJyknKTsKICB9CiAgZGJ1Zl9wdXRtKGRiLCAiOyIsIDApOwogIGRidWZfMChkYik7Cn0KCkpTVmFsdWUKanNfaW1wb3J0X2V2YWwoSlNDb250ZXh0KiBjdHgsIEltcG9ydERpcmVjdGl2ZSBpbXApIHsKICBEeW5CdWYgYnVmOwogIGNoYXIqIGNvZGU7CiAganNfZGJ1Zl9pbml0KGN0eCwgJmJ1Zik7CiAganNfaW1wb3J0X2RpcmVjdGl2ZShjdHgsIGltcCwgJmJ1Zik7CiAgY29kZSA9IHN0cl9lc2NhcGUoKGNvbnN0IGNoYXIqKWJ1Zi5idWYpOwogIHByaW50ZigianNfaW1wb3J0X2V2YWw6ICclcydcbiIsIGNvZGUpOwogIGZyZWUoY29kZSk7CiAgcmV0dXJuIGpzX2V2YWxfYnVmKGN0eCwgYnVmLmJ1ZiwgYnVmLnNpemUsIDAsIEpTX0VWQUxfVFlQRV9NT0RVTEUpOwp9CgpKU01vZHVsZURlZioKanNfbW9kdWxlX2ltcG9ydF9kZWZhdWx0KEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBwYXRoLCBjb25zdCBjaGFyKiB2YXIpIHsKICBqc19pbXBvcnRfZXZhbChjdHgsCiAgICAgICAgICAgICAgICAgKEltcG9ydERpcmVjdGl2ZSl7CiAgICAgICAgICAgICAgICAgICAgIC5wYXRoID0gcGF0aCwKICAgICAgICAgICAgICAgICAgICAgLnNwZWMgPSAiZGVmYXVsdCIsCiAgICAgICAgICAgICAgICAgICAgIC5ucyA9IDAsCiAgICAgICAgICAgICAgICAgICAgIC5wcm9wID0gImRlZmF1bHQiLAogICAgICAgICAgICAgICAgICAgICAudmFyID0gMCwKICAgICAgICAgICAgICAgICB9KTsKICAvLyBwcmludGYoImpzX2ltcG9ydF9ldmFsOiAnJS4qcydcbiIsIGJ1Zi5zaXplLCBidWYuYnVmKTsKICByZXR1cm4ganNfbW9kdWxlX2ZpbmQoY3R4LCBwYXRoKTsKfQoKSlNNb2R1bGVEZWYqCmpzX21vZHVsZV9pbXBvcnRfbmFtZXNwYWNlKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBwYXRoLCBjb25zdCBjaGFyKiBucykgewogIGpzX2ltcG9ydF9ldmFsKGN0eCwKICAgICAgICAgICAgICAgICAoSW1wb3J0RGlyZWN0aXZlKXsKICAgICAgICAgICAgICAgICAgICAgLnBhdGggPSBwYXRoLAogICAgICAgICAgICAgICAgICAgICAuc3BlYyA9ICIqIiwKICAgICAgICAgICAgICAgICAgICAgLm5zID0gbnMsCiAgICAgICAgICAgICAgICAgICAgIC5wcm9wID0gMCwKICAgICAgICAgICAgICAgICAgICAgLnZhciA9IDAsCiAgICAgICAgICAgICAgICAgfSk7CiAgLy8ganNfbW9kdWxlX2ltcG9ydChjdHgsIHBhdGgsIG5zLCAwLCAwKTsKCiAgcmV0dXJuIGpzX21vZHVsZV9maW5kKGN0eCwgcGF0aCk7Cn0KCkpTVmFsdWUKanNfbW9kdWxlX2ltcG9ydChKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogcGF0aCwgY29uc3QgY2hhciogbnMsIGNvbnN0IGNoYXIqIHZhciwgY29uc3QgY2hhciogcHJvcCkgewogIER5bkJ1ZiBidWY7CiAgY29uc3QgY2hhciogbmFtZTsKICBzaXplX3QgbGVuLCBuc2xlbjsKICBuYW1lID0gYmFzZW5hbWUocGF0aCk7CiAgbGVuID0gMDsKICB3aGlsZShuYW1lW2xlbl0gJiYgaXNfaWRlbnRpZmllcl9jaGFyKG5hbWVbbGVuXSkpICsrbGVuOwogIG5zbGVuID0gbnMgPyBzdHJsZW4obnMpIDogbGVuOwogIG5zID0gbnMgPyBqc19zdHJkdXAoY3R4LCBucykgOiBqc19zdHJuZHVwKGN0eCwgbmFtZSwgbGVuKTsKICBqc19kYnVmX2luaXQoY3R4LCAmYnVmKTsKICBkYnVmX3ByaW50ZigmYnVmLCAiaW1wb3J0ICVzJXMgZnJvbSAnJXMnOyBnbG9iYWxUaGlzLiVzID0gJXMiLCBucyA/ICIqIGFzICIgOiAiIiwgbnMsIHBhdGgsIHZhciA/IHZhciA6IG5zLCBucyk7CgogIGlmKHByb3AgJiYgKnByb3ApIHsKICAgIGRidWZfcHV0YygmYnVmLCAnLicpOwogICAgZGJ1Zl9wdXRzdHIoJmJ1ZiwgcHJvcCk7CiAgfQogIGRidWZfcHV0YygmYnVmLCAnOycpOwogIGRidWZfMCgmYnVmKTsKICBwcmludGYoImpzX21vZHVsZV9pbXBvcnQ6ICclcydcbiIsIGJ1Zi5idWYpOwogIHJldHVybiBqc19ldmFsX2J1ZihjdHgsIGJ1Zi5idWYsIGJ1Zi5zaXplLCAwLCBKU19FVkFMX1RZUEVfTU9EVUxFKTsKfQoKLypKU01vZHVsZURlZioKanNfbW9kdWxlX2xvYWRlcl9zbyhKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogbW9kdWxlKSB7CiAgSlNNb2R1bGVEZWYqIGRlZjsKICBKU01vZHVsZUxvYWRlckZ1bmMqIGluaXQ7CiAgdm9pZCogaGQ7CiAgY2hhciogZmlsZTsKICBzdGF0aWMgY29uc3QgY2hhciogZXJyb3JzWzNdID0geyJkbG9wZW4oKSBmYWlsZWQiLCAianNfaW5pdF9tb2R1bGUgbm90IGZvdW5kIiwgImluaXRpYWxpemF0aW9uIGVycm9yIn07CiAgaWYoIXN0cmNocihtb2R1bGUsICcvJykpIHsKICAgIGlmKCEoZmlsZSA9IGpzX21hbGxvYyhjdHgsIHN0cmxlbihtb2R1bGUpICsgMiArIDEpKSkKICAgICAgcmV0dXJuIDA7CiAgICBzdHJjcHkoZmlsZSwgIi4vIik7CiAgICBzdHJjcHkoZmlsZSArIDIsIG1vZHVsZSk7CiAgfSBlbHNlIHsKICAgIGZpbGUgPSAoY2hhciopbW9kdWxlOwogIH0KICBoZCA9IGRsb3BlbihmaWxlLCBSVExEX05PVyB8IFJUTERfTE9DQUwpOwogIGlmKGZpbGUgIT0gbW9kdWxlKQogICAganNfZnJlZShjdHgsIGZpbGUpOwogIGlmKGhkKSB7CiAgICBpZigoaW5pdCA9IGRsc3ltKGhkLCAianNfaW5pdF9tb2R1bGUiKSkpIHsKICAgICAgaWYoIShkZWYgPSBpbml0KGN0eCwgbW9kdWxlLCAwKSkpIHsKICAgICAgICBKU19UaHJvd1JlZmVyZW5jZUVycm9yKGN0eCwgImNvdWxkIG5vdCBsb2FkIG1vZHVsZSBmaWxlICclcyc6ICVzIiwgZXJyb3JzWzJdKTsKICAgICAgICBnb3RvIGZhaWw7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIEpTX1Rocm93UmVmZXJlbmNlRXJyb3IoY3R4LCAiY291bGQgbm90IGxvYWQgbW9kdWxlIGZpbGUgJyVzJzogJXMiLCBlcnJvcnNbMV0pOwogICAgICBnb3RvIGZhaWw7CiAgICB9CiAgfSBlbHNlIHsKICAgIEpTX1Rocm93UmVmZXJlbmNlRXJyb3IoY3R4LCAiY291bGQgbm90IGxvYWQgbW9kdWxlIGZpbGUgJyVzJzogJXM6ICVzIiwgbW9kdWxlLCBlcnJvcnNbMF0sIGRsZXJyb3IoKSk7CiAgICBnb3RvIGZhaWw7CiAgfQogIHJldHVybiBkZWY7CmZhaWw6CiAgaWYoaGQpCiAgICBkbGNsb3NlKGhkKTsKICByZXR1cm4gMDsKfSovCgpCT09MCmpzX2lzX2FycmF5YnVmZmVyKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBCT09MIHJldCA9IEZBTFNFOwogIGlmKCFKU19Jc09iamVjdCh2YWx1ZSkpCiAgICByZXR1cm4gcmV0OwogIGlmKCFyZXQpCiAgICByZXQgfD0ganNfdmFsdWVfaXNjbGFzcyhjdHgsIHZhbHVlLCBKU19DTEFTU19BUlJBWV9CVUZGRVIpOwogIGlmKCFyZXQpCiAgICByZXQgfD0ganNfb2JqZWN0X2lzKGN0eCwgdmFsdWUsICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpOwogIC8qICBpZighcmV0KSB7CiAgICAgIEpTT2JqZWN0KiBvYmo7CiAgICAgIGlmKChvYmogPSBqc192YWx1ZV9vYmoodmFsdWUpKSAmJiBvYmotPmNsYXNzX2lkKSB7CiAgICAgICAgSlNWYWx1ZSBjdG9yID0ganNfZ2xvYmFsX2dldChjdHgsICJBcnJheUJ1ZmZlciIpOwogICAgICAgIHJldCA9IEpTX0lzSW5zdGFuY2VPZihjdHgsIHZhbHVlLCBjdG9yKTsKICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBjdG9yKTsKICAgICAgfQogICAgfSovCiAgcmV0dXJuIHJldDsKfQoKQk9PTApqc19pc19zaGFyZWRhcnJheWJ1ZmZlcihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgcmV0dXJuIEpTX0lzT2JqZWN0KHZhbHVlKSAmJiAoanNfdmFsdWVfaXNjbGFzcyhjdHgsIHZhbHVlLCBKU19DTEFTU19TSEFSRURfQVJSQVlfQlVGRkVSKS8qIHx8CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNfb2JqZWN0X2lzKGN0eCwgdmFsdWUsICJbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXSIpKi8pOwp9CgpCT09MCmpzX2lzX21hcChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgcmV0dXJuIEpTX0lzT2JqZWN0KHZhbHVlKSAmJiAoanNfdmFsdWVfaXNjbGFzcyhjdHgsIHZhbHVlLCBKU19DTEFTU19NQVApIC8qfHwganNfb2JqZWN0X2lzKGN0eCwgdmFsdWUsICJbb2JqZWN0IE1hcF0iKSovKTsKfQoKQk9PTApqc19pc19zZXQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIHJldHVybiBKU19Jc09iamVjdCh2YWx1ZSkgJiYgKGpzX3ZhbHVlX2lzY2xhc3MoY3R4LCB2YWx1ZSwgSlNfQ0xBU1NfU0VUKSAvKiB8fCBqc19vYmplY3RfaXMoY3R4LCB2YWx1ZSwgIltvYmplY3QgU2V0XSIpKi8pOwp9CgpCT09MCmpzX2lzX2dlbmVyYXRvcihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgcmV0dXJuIEpTX0lzT2JqZWN0KHZhbHVlKSAmJiAoanNfdmFsdWVfaXNjbGFzcyhjdHgsIHZhbHVlLCBKU19DTEFTU19HRU5FUkFUT1IpIC8qfHwganNfb2JqZWN0X2lzKGN0eCwgdmFsdWUsICJbb2JqZWN0IEdlbmVyYXRvcl0iKSovKTsKfQoKQk9PTApqc19pc19yZWdleHAoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIHJldHVybiBKU19Jc09iamVjdCh2YWx1ZSkgJiYgKGpzX3ZhbHVlX2lzY2xhc3MoY3R4LCB2YWx1ZSwgSlNfQ0xBU1NfUkVHRVhQKSAvKnx8IGpzX29iamVjdF9pcyhjdHgsIHZhbHVlLCAiW29iamVjdCBSZWdFeHBdIikqLyk7Cn0KCkJPT0wKanNfaXNfcHJvbWlzZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgcmV0dXJuIEpTX0lzT2JqZWN0KHZhbHVlKSAmJiAoanNfdmFsdWVfaXNjbGFzcyhjdHgsIHZhbHVlLCBKU19DTEFTU19QUk9NSVNFKSB8fCBqc19vYmplY3RfaXMoY3R4LCB2YWx1ZSwgIltvYmplY3QgUHJvbWlzZV0iKSk7Cn0KCkJPT0wKanNfaXNfZGF0YXZpZXcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIHJldHVybiBKU19Jc09iamVjdCh2YWx1ZSkgJiYgKGpzX3ZhbHVlX2lzY2xhc3MoY3R4LCB2YWx1ZSwgSlNfQ0xBU1NfREFUQVZJRVcpIC8qfHwganNfb2JqZWN0X2lzKGN0eCwgdmFsdWUsICJbb2JqZWN0IERhdGFWaWV3XSIpKi8pOwp9CgpCT09MCmpzX2lzX2l0ZXJhYmxlKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqKSB7CiAgSlNBdG9tIGF0b207CiAgQk9PTCByZXQgPSBGQUxTRTsKICBhdG9tID0ganNfc3ltYm9sX3N0YXRpY19hdG9tKGN0eCwgIml0ZXJhdG9yIik7CiAgaWYoSlNfSGFzUHJvcGVydHkoY3R4LCBvYmosIGF0b20pKQogICAgcmV0ID0gVFJVRTsKCiAgSlNfRnJlZUF0b20oY3R4LCBhdG9tKTsKICBpZighcmV0KSB7CiAgICBhdG9tID0ganNfc3ltYm9sX3N0YXRpY19hdG9tKGN0eCwgImFzeW5jSXRlcmF0b3IiKTsKICAgIGlmKEpTX0hhc1Byb3BlcnR5KGN0eCwgb2JqLCBhdG9tKSkKICAgICAgcmV0ID0gVFJVRTsKCiAgICBKU19GcmVlQXRvbShjdHgsIGF0b20pOwogIH0KICByZXR1cm4gcmV0Owp9CgpCT09MCmpzX2lzX2l0ZXJhdG9yKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqKSB7CiAgaWYoSlNfSXNPYmplY3Qob2JqKSkgewogICAgSlNWYWx1ZSBuZXh0ID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmosICJuZXh0Iik7CgogICAgaWYoSlNfSXNGdW5jdGlvbihjdHgsIG5leHQpKQogICAgICByZXR1cm4gVFJVRTsKICB9CiAgcmV0dXJuIEZBTFNFOwp9CgpKU1ZhbHVlCmpzX3R5cGVkYXJyYXlfcHJvdG90eXBlKEpTQ29udGV4dCogY3R4KSB7CiAgSlNWYWx1ZSB1OGFycl9wcm90byA9IGpzX2dsb2JhbF9wcm90b3R5cGUoY3R4LCAiVWludDhBcnJheSIpOwogIEpTVmFsdWUgdHlwZWRhcnJfcHJvdG8gPSBKU19HZXRQcm90b3R5cGUoY3R4LCB1OGFycl9wcm90byk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdThhcnJfcHJvdG8pOwogIHJldHVybiB0eXBlZGFycl9wcm90bzsKfQoKSlNWYWx1ZQpqc190eXBlZGFycmF5X2NvbnN0cnVjdG9yKEpTQ29udGV4dCogY3R4KSB7CiAgSlNWYWx1ZSB0eXBlZGFycl9wcm90byA9IGpzX3R5cGVkYXJyYXlfcHJvdG90eXBlKGN0eCk7CiAgSlNWYWx1ZSB0eXBlZGFycl9jdG9yID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCB0eXBlZGFycl9wcm90bywgImNvbnN0cnVjdG9yIik7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdHlwZWRhcnJfcHJvdG8pOwogIHJldHVybiB0eXBlZGFycl9jdG9yOwp9CgpKU1ZhbHVlCmpzX2ludm9rZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfb2JqLCBjb25zdCBjaGFyKiBtZXRob2QsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgSlNBdG9tIGF0b207CiAgSlNWYWx1ZSByZXQ7CiAgYXRvbSA9IEpTX05ld0F0b20oY3R4LCBtZXRob2QpOwogIHJldCA9IEpTX0ludm9rZShjdHgsIHRoaXNfb2JqLCBhdG9tLCBhcmdjLCBhcmd2KTsKICBKU19GcmVlQXRvbShjdHgsIGF0b20pOwogIHJldHVybiByZXQ7Cn0KCkpTVmFsdWUKanNfc3ltYm9sX29wZXJhdG9yc2V0X3ZhbHVlKEpTQ29udGV4dCogY3R4KSB7CiAgcmV0dXJuIGpzX3N5bWJvbF9zdGF0aWNfdmFsdWUoY3R4LCAib3BlcmF0b3JTZXQiKTsKfQoKSlNBdG9tCmpzX3N5bWJvbF9vcGVyYXRvcnNldF9hdG9tKEpTQ29udGV4dCogY3R4KSB7CiAgSlNWYWx1ZSBvcGVyYXRvcl9zZXQgPSBqc19zeW1ib2xfb3BlcmF0b3JzZXRfdmFsdWUoY3R4KTsKICBKU0F0b20gYXRvbSA9IEpTX1ZhbHVlVG9BdG9tKGN0eCwgb3BlcmF0b3Jfc2V0KTsKICBKU19GcmVlVmFsdWUoY3R4LCBvcGVyYXRvcl9zZXQpOwogIHJldHVybiBhdG9tOwp9CgpKU1ZhbHVlCmpzX29wZXJhdG9yc19jcmVhdGUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWUqIHRoaXNfb2JqKSB7CiAgSlNWYWx1ZSBvcGVyYXRvcnMgPSBqc19nbG9iYWxfZ2V0KGN0eCwgIk9wZXJhdG9ycyIpOwogIEpTVmFsdWUgY3JlYXRlX2Z1biA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb3BlcmF0b3JzLCAiY3JlYXRlIik7CiAgaWYodGhpc19vYmopCiAgICAqdGhpc19vYmogPSBvcGVyYXRvcnM7CiAgZWxzZQogICAgSlNfRnJlZVZhbHVlKGN0eCwgb3BlcmF0b3JzKTsKICByZXR1cm4gY3JlYXRlX2Z1bjsKfQoKSlNWYWx1ZQpqc19udW1iZXJfbmV3KEpTQ29udGV4dCogY3R4LCBpbnQzMl90IG4pIHsKICBpZihuID09IElOVDMyX01BWCkKICAgIHJldHVybiBKU19OZXdGbG9hdDY0KGN0eCwgSU5GSU5JVFkpOwoKICByZXR1cm4gSlNfTmV3SW50MzIoY3R4LCBuKTsKfQoKSlNWYWx1ZQpqc19kYXRlX25ldyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IGFyZykgewogIEpTVmFsdWUgY3RvciA9IGpzX2dsb2JhbF9nZXQoY3R4LCAiRGF0ZSIpOwogIEpTVmFsdWUgcmV0ID0gSlNfQ2FsbENvbnN0cnVjdG9yKGN0eCwgY3RvciwgMSwgJmFyZyk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgY3Rvcik7CiAgcmV0dXJuIHJldDsKfQoKSlNWYWx1ZQpqc19kYXRlX2Zyb21fbXMoSlNDb250ZXh0KiBjdHgsIGludDY0X3QgbXMpIHsKICBKU1ZhbHVlIGFyZyA9IEpTX05ld0ludDY0KGN0eCwgbXMpOwogIEpTVmFsdWUgcmV0ID0ganNfZGF0ZV9uZXcoY3R4LCBhcmcpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGFyZyk7CiAgcmV0dXJuIHJldDsKfQoKSlNWYWx1ZQpqc19kYXRlX2Zyb21fdGltZV9ucyhKU0NvbnRleHQqIGN0eCwgdGltZV90IHQsIGxvbmcgbnMpIHsKICByZXR1cm4ganNfZGF0ZV9mcm9tX21zKGN0eCwgdCAqIDEwMDB1bGwgKyBucyAvIDEwMDAwMDB1bGwpOwp9CgpKU1ZhbHVlCmpzX2RhdGVfZnJvbV90aW1lc3BlYyhKU0NvbnRleHQqIGN0eCwgY29uc3Qgc3RydWN0IHRpbWVzcGVjIHRzKSB7CiAgcmV0dXJuIGpzX2RhdGVfZnJvbV90aW1lX25zKGN0eCwgdHMudHZfc2VjLCB0cy50dl9uc2VjKTsKfQoKaW50NjRfdApqc19kYXRlX2dldHRpbWUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBhcmcpIHsKICBpbnQ2NF90IHIgPSAtMTsKICBKU0F0b20gbWV0aG9kID0gSlNfTmV3QXRvbShjdHgsICJnZXRUaW1lIik7CiAgSlNWYWx1ZSB2YWx1ZSA9IEpTX0ludm9rZShjdHgsIGFyZywgbWV0aG9kLCAwLCAwKTsKICBKU19GcmVlQXRvbShjdHgsIG1ldGhvZCk7CiAgaWYoSlNfSXNOdW1iZXIodmFsdWUpKQogICAgSlNfVG9JbnQ2NChjdHgsICZyLCB2YWx1ZSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIHJldHVybiByOwp9CgppbnQ2NF90CmpzX2RhdGVfdGltZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZSBhcmcpIHsKICBpbnQ2NF90IHIgPSAtMTsKICBpZihKU19Jc09iamVjdChhcmcpKQogICAgciA9IGpzX2RhdGVfZ2V0dGltZShjdHgsIGFyZyk7CiAgZWxzZSBpZighanNfaXNfbnVsbGlzaChjdHgsIGFyZykpCiAgICBKU19Ub0ludDY0KGN0eCwgJnIsIGFyZyk7CiAgcmV0dXJuIHI7Cn0KCnN0cnVjdCB0aW1lc3BlYwpqc19kYXRlX3RpbWVzcGVjKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlIGFyZykgewogIHN0cnVjdCB0aW1lc3BlYyB0czsKICBpbnQ2NF90IHIgPSBqc19kYXRlX3RpbWUoY3R4LCBhcmcpOwogIHRzLnR2X3NlYyA9IHIgLyAxMDAwdWxsOwogIHRzLnR2X25zZWMgPSAociAtIHRzLnR2X3NlYykgKiAxMDAwMDAwdWxsOwogIHJldHVybiB0czsKfQoKdm9pZApqc19hcnJheWJ1ZmZlcl9mcmVldmFsdWUoSlNSdW50aW1lKiBydCwgdm9pZCogb3BhcXVlLCB2b2lkKiBwdHIpIHsKICBKU1ZhbHVlKiB2YWxwdHIgPSBvcGFxdWU7CiAgSlNfRnJlZVZhbHVlUlQocnQsICp2YWxwdHIpOwogIGpzX2ZyZWVfcnQocnQsIG9wYXF1ZSk7Cn0KCkpTVmFsdWUKanNfYXJyYXlidWZmZXJfZnJvbXZhbHVlKEpTQ29udGV4dCogY3R4LCAgIHZvaWQqIHgsIHNpemVfdCBuLCBKU1ZhbHVlQ29uc3QgdmFsKSB7CiAgSlNWYWx1ZSogdmFscHRyOwogIGlmKCEodmFscHRyID0ganNfbWFsbG9jKGN0eCwgc2l6ZW9mKEpTVmFsdWUpKSkpCiAgICByZXR1cm4gSlNfVGhyb3dPdXRPZk1lbW9yeShjdHgpOwogICp2YWxwdHIgPSBKU19EdXBWYWx1ZShjdHgsIHZhbCk7CiAgcmV0dXJuIEpTX05ld0FycmF5QnVmZmVyKGN0eCwgeCwgbiwganNfYXJyYXlidWZmZXJfZnJlZXZhbHVlLCB2YWxwdHIsIEZBTFNFKTsKfQoKaW50NjRfdApqc19hcnJheWJ1ZmZlcl9ieXRlbGVuZ3RoKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBpbnQ2NF90IGxlbiA9IC0xOwogIGlmKGpzX2lzX2FycmF5YnVmZmVyKGN0eCwgdmFsdWUpKSB7CiAgICBKU1ZhbHVlIGxlbmd0aCA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgdmFsdWUsICJieXRlTGVuZ3RoIik7CiAgICBKU19Ub0ludDY0KGN0eCwgJmxlbiwgbGVuZ3RoKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGxlbmd0aCk7CiAgfQogIHJldHVybiBsZW47Cn0KCkpTVmFsdWUKanNfZXZhbF9tb2R1bGUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIEJPT0wgbG9hZF9vbmx5KSB7CiAgSlNWYWx1ZSByZXQgPSBKU19VTkRFRklORUQ7CiAgaW50IHRhZyA9IEpTX1ZBTFVFX0dFVF9UQUcob2JqKTsKICBpZih0YWcgPT0gSlNfVEFHX01PRFVMRSkgewogICAgaWYoIWxvYWRfb25seSAmJiBKU19SZXNvbHZlTW9kdWxlKGN0eCwgb2JqKSA8IDApIHsKICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgb2JqKTsKICAgICAgcmV0dXJuIEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJGYWlsZWQgcmVzb2x2aW5nIG1vZHVsZSIpOwogICAgfQogICAganNfbW9kdWxlX3NldF9pbXBvcnRfbWV0YShjdHgsIG9iaiwgRkFMU0UsICFsb2FkX29ubHkpOwogICAgcmV0dXJuIGxvYWRfb25seSA/IEpTX0R1cFZhbHVlKGN0eCwgb2JqKSA6IEpTX0V2YWxGdW5jdGlvbihjdHgsIG9iaik7CiAgfQogIHJldHVybiBKU19UaHJvd0ludGVybmFsRXJyb3IoY3R4LCAiaW52YWxpZCB0YWcgJWkiLCB0YWcpOwp9CgpKU1ZhbHVlCmpzX2V2YWxfYmluYXJ5KEpTQ29udGV4dCogY3R4LCBjb25zdCB1aW50OF90KiBidWYsIHNpemVfdCBidWZfbGVuLCBCT09MIGxvYWRfb25seSkgewogIEpTVmFsdWUgb2JqID0gSlNfUmVhZE9iamVjdChjdHgsIGJ1ZiwgYnVmX2xlbiwgSlNfUkVBRF9PQkpfQllURUNPREUpOwogIGlmKEpTX0lzRXhjZXB0aW9uKG9iaikpCiAgICByZXR1cm4gb2JqOwogIC8vIHByaW50ZigianNfZXZhbF9iaW5hcnkgb2JqPSVzXG4iLCBqc192YWx1ZV90eXBlc3RyKGN0eCwgb2JqKSk7CiAgaWYoIWxvYWRfb25seSkgewogICAgSlNWYWx1ZSB0bXAgPSBqc19ldmFsX21vZHVsZShjdHgsIG9iaiwgbG9hZF9vbmx5KTsKICAgIGludCB0YWcgPSBKU19WQUxVRV9HRVRfVEFHKHRtcCk7CiAgICAvLyBwcmludGYoImpzX2V2YWxfYmluYXJ5IHRtcD0lc1xuIiwganNfdmFsdWVfdHlwZXN0cihjdHgsIHRtcCkpOwogICAgaWYoIUpTX0lzRXhjZXB0aW9uKHRtcCkgJiYgIUpTX0lzVW5kZWZpbmVkKHRtcCkpCiAgICAgIGlmKHRhZyA+PSBKU19UQUdfRklSU1QgJiYgdGFnIDw9IEpTX1RBR19GTE9BVDY0KQogICAgICAgIHJldHVybiB0bXA7CiAgfQogIHJldHVybiBvYmo7Cn0KCkpTVmFsdWUKanNfZXZhbF9idWYoSlNDb250ZXh0KiBjdHgsIGNvbnN0IHZvaWQqIGJ1ZiwgaW50IGJ1Zl9sZW4sIGNvbnN0IGNoYXIqIGZpbGVuYW1lLCBpbnQgZXZhbF9mbGFncykgewogIEpTVmFsdWUgdmFsOwoKICBpZigoZXZhbF9mbGFncyAmIEpTX0VWQUxfVFlQRV9NQVNLKSA9PSBKU19FVkFMX1RZUEVfTU9EVUxFKSB7CiAgICAvKiBmb3IgdGhlIG1vZHVsZXMsIHdlIGNvbXBpbGUgdGhlbiBydW4gdG8gYmUgYWJsZSB0byBzZXQgaW1wb3J0Lm1ldGEgKi8KICAgIHZhbCA9IEpTX0V2YWwoY3R4LCBidWYsIGJ1Zl9sZW4sIGZpbGVuYW1lID8gZmlsZW5hbWUgOiAiPGlucHV0PiIsIGV2YWxfZmxhZ3MgfCBKU19FVkFMX0ZMQUdfQ09NUElMRV9PTkxZKTsKICAgIGlmKCFKU19Jc0V4Y2VwdGlvbih2YWwpKSB7CiAgICAgIGpzX21vZHVsZV9zZXRfaW1wb3J0X21ldGEoY3R4LCB2YWwsICEhZmlsZW5hbWUsIFRSVUUpOwogICAgICAvKnZhbCA9ICovIEpTX0V2YWxGdW5jdGlvbihjdHgsIHZhbCk7CiAgICB9CiAgfSBlbHNlIHsKICAgIHZhbCA9IEpTX0V2YWwoY3R4LCBidWYsIGJ1Zl9sZW4sIGZpbGVuYW1lLCBldmFsX2ZsYWdzKTsKICB9CiAgaWYoSlNfSXNFeGNlcHRpb24odmFsKSkKICAgIGpzX2Vycm9yX3ByaW50KGN0eCwgSlNfR2V0RXhjZXB0aW9uKGN0eCkpOwogIHJldHVybiB2YWw7Cn0KCmludApqc19ldmFsX3N0cihKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogc3RyLCBjb25zdCBjaGFyKiBmaWxlLCBpbnQgZmxhZ3MpIHsKICBKU1ZhbHVlIHZhbCA9IGpzX2V2YWxfYnVmKGN0eCwgc3RyLCBzdHJsZW4oc3RyKSwgZmlsZSwgZmxhZ3MpOwogIGludDMyX3QgcmV0ID0gLTE7CiAgaWYoSlNfSXNOdW1iZXIodmFsKSkKICAgIEpTX1RvSW50MzIoY3R4LCAmcmV0LCB2YWwpOwogIHJldHVybiByZXQ7Cn0KCnRocmVhZF9sb2NhbCB1aW50NjRfdCBqc19wZW5kaW5nX3NpZ25hbHMgPSAwOwoKaW50NjRfdApqc190aW1lX21zKHZvaWQpIHsKICBzdHJ1Y3QgdGltZXNwZWMgdHM7CiAgY2xvY2tfZ2V0dGltZShDTE9DS19NT05PVE9OSUMsICZ0cyk7CiAgcmV0dXJuICh1aW50NjRfdCl0cy50dl9zZWMgKiAxMDAwICsgKHRzLnR2X25zZWMgLyAxMDAwMDAwKTsKfQoKaW50CmpzX2ludGVycnVwdF9oYW5kbGVyKEpTUnVudGltZSogcnQsIHZvaWQqIG9wYXF1ZSkgewogIHJldHVybiAoanNfcGVuZGluZ19zaWduYWxzID4+IFNJR0lOVCkgJiAxOwp9Cgp2b2lkCmpzX3RpbWVyX3VubGluayhKU1J1bnRpbWUqIHJ0LCBKU09TVGltZXIqIHRoKSB7CiAgaWYodGgtPmxpbmsucHJldikgewogICAgbGlzdF9kZWwoJnRoLT5saW5rKTsKICAgIHRoLT5saW5rLnByZXYgPSB0aC0+bGluay5uZXh0ID0gMDsKICB9Cn0KCnZvaWQKanNfdGltZXJfZnJlZShKU1J1bnRpbWUqIHJ0LCBKU09TVGltZXIqIHRoKSB7CiAgSlNfRnJlZVZhbHVlUlQocnQsIHRoLT5mdW5jKTsKICBqc19mcmVlX3J0KHJ0LCB0aCk7Cn0KCnZvaWQKanNfY2FsbF9oYW5kbGVyKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgZnVuYykgewogIEpTVmFsdWUgcmV0LCBmdW5jMTsKICBmdW5jMSA9IEpTX0R1cFZhbHVlKGN0eCwgZnVuYyk7CiAgcmV0ID0gSlNfQ2FsbChjdHgsIGZ1bmMxLCBKU19VTkRFRklORUQsIDAsIDApOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGZ1bmMxKTsKICBpZihKU19Jc0V4Y2VwdGlvbihyZXQpKQogICAganNfc3RkX2R1bXBfZXJyb3IoY3R4KTsKICBKU19GcmVlVmFsdWUoY3R4LCByZXQpOwp9CnZvaWQqCmpzX3NhYl9hbGxvYyh2b2lkKiBvcGFxdWUsIHNpemVfdCBzaXplKSB7CiAgSlNTQUJIZWFkZXIqIHNhYjsKICBzYWIgPSBtYWxsb2Moc2l6ZW9mKEpTU0FCSGVhZGVyKSArIHNpemUpOwogIGlmKCFzYWIpCiAgICByZXR1cm4gMDsKICBzYWItPnJlZl9jb3VudCA9IDE7CiAgcmV0dXJuIHNhYi0+YnVmOwp9CnZvaWQKanNfc2FiX2ZyZWUodm9pZCogb3BhcXVlLCB2b2lkKiBwdHIpIHsKICBKU1NBQkhlYWRlciogc2FiOwogIGludCByZWZfY291bnQ7CiAgc2FiID0gKEpTU0FCSGVhZGVyKikoKHVpbnQ4X3QqKXB0ciAtIHNpemVvZihKU1NBQkhlYWRlcikpOwogIHJlZl9jb3VudCA9IGF0b21pY19hZGRfaW50KCZzYWItPnJlZl9jb3VudCwgLTEpOwogIGFzc2VydChyZWZfY291bnQgPj0gMCk7CiAgaWYocmVmX2NvdW50ID09IDApIHsKICAgIGZyZWUoc2FiKTsKICB9Cn0KCnZvaWQKanNfc2FiX2R1cCh2b2lkKiBvcGFxdWUsIHZvaWQqIHB0cikgewogIEpTU0FCSGVhZGVyKiBzYWI7CiAgc2FiID0gKEpTU0FCSGVhZGVyKikoKHVpbnQ4X3QqKXB0ciAtIHNpemVvZihKU1NBQkhlYWRlcikpOwogIGF0b21pY19hZGRfaW50KCZzYWItPnJlZl9jb3VudCwgMSk7Cn0KCnZvaWQKanNfZXJyb3JfZHVtcChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IGVycm9yLCBEeW5CdWYqIGRiKSB7CiAgY29uc3QgY2hhciAqc3RyLCAqc3RhY2sgPSAwOwogIGlmKEpTX0lzT2JqZWN0KGVycm9yKSkgewogICAgSlNWYWx1ZSBzdCA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgZXJyb3IsICJzdGFjayIpOwogICAgaWYoIUpTX0lzVW5kZWZpbmVkKHN0KSkKICAgICAgc3RhY2sgPSBKU19Ub0NTdHJpbmcoY3R4LCBzdCk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCBzdCk7CiAgfQogIGlmKChzdHIgPSBKU19Ub0NTdHJpbmcoY3R4LCBlcnJvcikpKSB7CiAgICBjb25zdCBjaGFyKiB0eXBlID0gSlNfSXNPYmplY3QoZXJyb3IpID8ganNfb2JqZWN0X2NsYXNzbmFtZShjdHgsIGVycm9yKSA6IGpzX3ZhbHVlX3R5cGVzdHIoY3R4LCBlcnJvcik7CgogICAgaWYoIXN0cl9zdGFydChzdHIsIHR5cGUpKSB7CiAgICAgIGRidWZfcHV0c3RyKGRiLCB0eXBlKTsKICAgICAgZGJ1Zl9wdXRzdHIoZGIsICI6ICIpOwogICAgfQogICAgZGJ1Zl9wdXRzdHIoZGIsIHN0cik7CiAgICBkYnVmX3B1dGMoZGIsICdcbicpOwogICAgaWYoc3RhY2spIHsKICAgICAgZGJ1Zl9wdXRzdHIoZGIsICJTVEFDS1xuIik7CiAgICAgIGRidWZfcHV0c3RyKGRiLCBzdGFjayk7CiAgICAgIGRidWZfcHV0YyhkYiwgJ1xuJyk7CiAgICB9CiAgICBkYnVmXzAoZGIpOwogIH0KICBpZihzdGFjaykKICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgc3RhY2spOwogIEpTX0ZyZWVDU3RyaW5nKGN0eCwgc3RyKTsKfQoKY2hhcioKanNfZXJyb3JfdG9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBlcnJvcikgewogIER5bkJ1ZiBkYjsKICBqc19kYnVmX2luaXQoY3R4LCAmZGIpOwogIGpzX2Vycm9yX2R1bXAoY3R4LCBlcnJvciwgJmRiKTsKICByZXR1cm4gKGNoYXIqKWRiLmJ1ZjsKfQoKdm9pZApqc19lcnJvcl9wcmludChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IGVycm9yKSB7CiAgY29uc3QgY2hhciAqc3RyLCAqc3RhY2sgPSAwOwoKICBpZihKU19Jc09iamVjdChlcnJvcikpIHsKICAgIEpTVmFsdWUgc3QgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIGVycm9yLCAic3RhY2siKTsKCiAgICBpZighSlNfSXNVbmRlZmluZWQoc3QpKQogICAgICBzdGFjayA9IEpTX1RvQ1N0cmluZyhjdHgsIHN0KTsKCiAgICBKU19GcmVlVmFsdWUoY3R4LCBzdCk7CiAgfQoKICBpZigoc3RyID0gSlNfVG9DU3RyaW5nKGN0eCwgZXJyb3IpKSkgewogICAgY29uc3QgY2hhciogdHlwZSA9IEpTX0lzT2JqZWN0KGVycm9yKSA/IGpzX29iamVjdF9jbGFzc25hbWUoY3R4LCBlcnJvcikgOiBqc192YWx1ZV90eXBlc3RyKGN0eCwgZXJyb3IpOwogICAgY29uc3QgY2hhciogZXhjZXB0aW9uID0gc3RyOwogICAgc2l6ZV90IHR5cGVsZW4gPSBzdHJsZW4odHlwZSk7CgogICAgaWYoIXN0cm5jbXAoZXhjZXB0aW9uLCB0eXBlLCB0eXBlbGVuKSAmJiBleGNlcHRpb25bdHlwZWxlbl0gPT0gJzonKSB7CiAgICAgIGV4Y2VwdGlvbiArPSB0eXBlbGVuICsgMjsKICAgIH0KICAgIHByaW50ZigiJXM6ICVzXG4iLCB0eXBlLCBleGNlcHRpb24pOwogICAgaWYoc3RhY2spCiAgICAgIHByaW50ZigiU1RBQ0s9XG4lc1xuIiwgc3RhY2spOwogICAgZmZsdXNoKHN0ZG91dCk7CiAgfQogIGlmKHN0YWNrKQogICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBzdGFjayk7CiAgSlNfRnJlZUNTdHJpbmcoY3R4LCBzdHIpOwp9CgAAAAAAAAAAcNgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA8MIAAAAAAAAKxAAAAAAAAAAAAAAAAPC/"
				]
			]
		}
	],
	"build_system": "Packages/Makefile/Make.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Build all",
					""
				],
				[
					"Build tests",
					""
				],
				[
					"List",
					""
				],
				[
					"Rebuild CTags",
					""
				],
				[
					"clang-format",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				]
			],
			[
				"Packages/Makefile/Make.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"outli",
				"Browse Mode: Outline (Right)"
			],
			[
				"outline",
				"Browse Mode: Outline (Right)"
			],
			[
				"out",
				"Browse Mode: Outline (Right)"
			],
			[
				"outlin",
				"Browse Mode: Outline (Right)"
			],
			[
				"scheme",
				"Color Scheme Editor: Edit current color scheme"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"INSTALL",
				"Package Control: Install Package"
			],
			[
				"edit",
				"SchemeEditor: Edit Current Scheme"
			],
			[
				"",
				"Arithmetic"
			],
			[
				"disable",
				"Package Control: Disable Package"
			],
			[
				"Package Control: disable",
				"Package Control: Disable Package"
			],
			[
				"Package Control: ",
				"Package Control: Disable Package"
			],
			[
				"adap",
				"Debugger: Install Adapters"
			],
			[
				"install ada",
				"Debugger: Install Adapters"
			],
			[
				"adapter",
				"Debugger: Install Adapters"
			],
			[
				"debug",
				"Debugger: Install Adapters"
			],
			[
				"Package Control: remove",
				"Package Control: Remove Package"
			],
			[
				"debu",
				"Debugger: Install Adapters"
			],
			[
				"add re",
				"Package Control: Add Repository"
			],
			[
				"instal",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 393.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules"
	],
	"file_history":
	[
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/predicate.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-lexer.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/path.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-location.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/property-enumeration.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/predicate.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/predicate.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-predicate.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-stringdecoder.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-blob.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-inspect.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-deep.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-sockets.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-sockets.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/qjsm.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/CMakeLists.txt",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-syscallerror.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/cmake/QuickJSModule.cmake",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/char-utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/char-utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-syscallerror.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/buffer-utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/buffer-utils.h",
		"/home/roman/Projects/plot-cv/quickjs/quickjs.h",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/vector.h",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/qjsm.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/child-process.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/path.h",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-path.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/cmake/FindQuickJS.cmake",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/cmake/QuickJSModule.cmake",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-internal.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/util.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/fs.js",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/repl.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/qjsm",
		"/home/roman/Sources/plot-cv/quickjs/quickjs.c",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-repeater.c",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-inspect.c",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-predicate.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-blob.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-bjson.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-archive.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/repl.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/stack.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-location.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-pointer.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-pointer.c",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/lexer.c",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/property-enumeration.h",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-lexer.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-predicate.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/console.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/property-enumeration.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lexer.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lexer.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-lexer.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/location.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/location.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/socklen_t.js",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-sockets.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_sockets.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/parser.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/fd_set.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/timeval.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_misc.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_parser.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/vector.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-gpio.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.h",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/cmake/FindQuickJS.cmake",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/.clang-format",
		"/home/roman/Sources/plot-cv/quickjs/quickjs.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-internal.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/CMakeCache.txt",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_lexer.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/bc-socklen_t.c",
		"/home/roman/Projects/plot-cv/quickjs/cutils.h",
		"/home/roman/Projects/plot-cv/quickjs/cutils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/require.js",
		"/home/roman/Projects/plot-cv/quickjs/list.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-stringdecoder.h",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-deep.c",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-pointer.c",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/vector.h",
		"/home/roman/Sources/plot-cv/quickjs/quickjs-libc.c",
		"/home/roman/Sources/plot-cv/quickjs/quickjs-libc.h",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/test-socklen_t.c",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-sockets.h",
		"/home/roman/Projects/plot-cv/quickjs/quickjs.c",
		"/home/roman/Projects/plot-cv/quickjs/quickjs-libc.h",
		"/home/roman/Projects/plot-cv/quickjs/quickjs-libc.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/.prettierrc",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/bc-fd_set.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-fdset.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_location.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/pointer.c",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-blob.c",
		"/usr/include/x86_64-linux-gnu/bits/syscall.h",
		"/usr/include/x86_64-linux-gnu/sys/syscall.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-repeater.c",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/buffer-utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs.c",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/char-utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_pointer.js",
		"/home/roman/Projects/plot-cv/quickjs/libregexp.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/jslexer.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_inspect.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_path.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_blob.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_qjsm.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-xml.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/cmake/Findpigpio.cmake",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/pigpio/pigpio.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/pigpio/CMakeLists.txt",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/pigpio/README",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_stringdecoder.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/child-process.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/ringbuffer.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/README.md",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/ringbuffer.h"
	],
	"find":
	{
		"height": 40.0
	},
	"find_in_files":
	{
		"height": 130.0,
		"where_history":
		[
			"/home/roman/Sources/plot-cv/quickjs/qjs-modules,*.c,*.h,*.js,-*/build/*,*.cmake,CMakeLists.txt",
			"/home/roman/Sources/plot-cv/quickjs/modules,*.c,*.h,*.js,-*/build/*,*.cmake,CMakeLists.txt",
			"/home/roman/Sources/plot-cv/quickjs/modules,*.c,*.h,*.js,*.cmake,CMakeLists.txt",
			"/home/roman/Sources/plot-cv/quickjs/modules,*.c,*.h,*.js",
			"/home/roman/Sources/plot-cv/quickjs,*.c,*.h,*.js",
			"/home/roman/Sources/plot-cv/quickjs/modules,*.c,*.h,*.js"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"number_base",
			"ArrayBuffer",
			"JS_NewInt64",
			"^(struct |)(Memory_?Block|pointer_?range|input_*buffer)",
			"^(struct |)(Memory_?Block|pointer_?range)",
			"^(struct |)MemoryBlock",
			"struct",
			"^MemoryBlock",
			"MemoryBlock",
			"vector",
			"struct",
			"js_arraybuffer_",
			" free\\(",
			"free\\(",
			"stat\\(",
			"\"setsockopt",
			"PRECEDEN",
			"predicate_[a-z]*_num_args",
			"predicate_direct_num_args",
			"js_func",
			"BAND:",
			"ATAN2:",
			"PREDICATE_BOR",
			"PREDICATE_SQRT",
			"SetModuleLoader",
			"^js_[^ ]*module",
			"sockaddr_addr",
			"loader_so",
			"load_so",
			"qsort_r",
			"js_arraybuffer_fromvalue",
			"JSCFunctionData",
			"JS_NewCFunctionData",
			"byte_escape",
			"^#",
			"ImportDirective",
			"js_module_import_",
			"ImportDirective",
			"qsort_r",
			"^",
			"INCLUDE_DIR",
			"loader_so",
			"module_loader_so",
			"\"realpath",
			"realpath\\(",
			"getuid",
			"^",
			"HAVE_ISATTY",
			"path_is",
			"path_isabs",
			"WINDOWS",
			"PATHSEP_S_MIXED",
			"issep",
			"realpath\\(",
			"FUNC_GETPID",
			"#endif\n#ifndef __wasi__",
			"getuid\"",
			"realpath\\(",
			"\"realpath",
			"\"getpid",
			"HAVE_SYS_MMAN_H",
			"HAVE_WAITPID",
			"HAVE_SYS_WAIT_H",
			"HAVE_THREADS_H",
			"qjs-misc",
			"JSWorker",
			"->mutex",
			"QUICKJS_MODULE_PATH",
			"^js_module_loader",
			"js_module_loader",
			"GET_MODULE_OBJECT",
			"\"getModuleObject",
			"Unhandled",
			"unhandled",
			"JSModuleInitFunc",
			"JSCFunctionData",
			"JS_NewCFunctionData",
			"JS_SetPropertyStr",
			"JSModuleInitFunc",
			"JSReqModule",
			"struct JSReqModule",
			"struct JSModuleDef",
			"js_eval_buf",
			"printStatus",
			"LOAD.MODULE",
			"Throw:",
			"Tthrow:",
			"throw:",
			"LOAD_MODULE",
			"historyFile",
			"historySave",
			"cleanup",
			"historyLoad",
			"History",
			"exename",
			"JSModuleDef",
			"JS_[^ ]*odule",
			"module_exports",
			"JSVarRef",
			"GET_MODULE_EXPORTS",
			"include_list",
			"'I'",
			"stack",
			"js_object_error",
			"js_object_c",
			"js_object_new",
			"^js_object",
			"proto_chain",
			"protoChain",
			"COLOR_LIGHTRED",
			"toStringTag",
			"function.this_obj",
			"nextarg",
			"_shift",
			"PRECEDENCE_EQUALITY",
			"js_function_tostring",
			"PREDICATE_FUNC",
			"lerngth",
			"js_get_propertystr_int",
			"PREDICATE_SHIFT",
			"this_arg",
			"js_token_toprimitive",
			"js_token_tostring",
			"property_enumeration_circular",
			"input_skip",
			"location_clone",
			"location_copy",
			"js_location_new"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"# ",
			"#",
			"HAVE_REALPATH",
			"",
			"HAVE_TERMIOS_H",
			"HAVE_MMAP",
			"HAVE_SYS_MMAN_H",
			"HAVE_SYS_WAIT_H",
			"length",
			"loc->",
			"ret->",
			"arg",
			" ",
			"",
			"\"\\\\t",
			"\"\\t",
			"imp.",
			"ctx,",
			"",
			"JSValueConst)",
			"",
			"jsm_module_loader",
			"js_module_loader_so",
			"js_eval_file",
			"js_eval_buf",
			"js_load_script",
			"jsm_eval_script",
			"js_eval_file",
			"js_load_module",
			"js_eval_str",
			"js_module_get",
			"JSValueConst)",
			"js_module_search",
			"jsm_module_find",
			"js_module_find",
			"js_load_",
			"js_load_module",
			"js_eval_buf",
			"js_load_script",
			"js_std_dump_error",
			"js_module_exports",
			"fdset",
			" ",
			"js_input_buffer",
			"\\1(\\2, sock",
			"\\1(",
			"",
			"JS_CGETSET_MAGIC_DEF",
			"off.",
			"} else if(",
			"port",
			".buf",
			"'",
			"",
			"socket_send",
			"0x00",
			" 0x00,",
			"0x78,",
			"0x78",
			" 0x00,",
			"0x78",
			"JS_CGETSET_MAGIC_DEF",
			"socket_syscalls_size",
			"js_syscallerror_get, js_syscallerror_set,",
			"js_socket_get, js_socket_set, ",
			"e",
			"js_syscallerror_proto_funcs",
			"s.fd",
			"js_socket_proto_funcs",
			"\"",
			"SYSCALLERROR_VALUEOF",
			"s, ",
			"JS_SOCKETCALL",
			"JS_SOCKETCALL_RETURN",
			"js_socket_data2(ctx",
			"sa->family",
			"QUICKJS_SYSCALLERROR_H",
			"data2",
			"js_syscallerror_data2",
			"QUICKJS_MISC_H",
			"js_sockets_defines",
			"js_sockaddr_data2",
			"js_sockaddr_data",
			"SockAddr",
			"struct sockaddr*",
			"sockets_init",
			"argv[i]",
			"pigpio",
			"CHAR_UTILS",
			"${util_SOURCES}",
			"ol.",
			"range_from",
			".range.length",
			".range.offset",
			"input_buffer_length(in)",
			"input_buffer_data(in)",
			"blob",
			"location->vec",
			"location",
			"Location",
			"r->data\\1",
			" this.fs.",
			"stringdecoder",
			"js_stringdecoder_set",
			"js_stringdecoder_get",
			"stringdecoder",
			"\\1if(gpio->debug) fprintf",
			"struct gpio",
			"struct GPIO",
			"struct GPIO*",
			"ctx->rt",
			"",
			": ",
			"\"",
			"ret = \\1;",
			"->errnum",
			"(",
			"error",
			"JS_NewInt32",
			"",
			",",
			"left, right",
			"predicate_nextarg(ctx, &args)",
			"predicate_nextarg(ctx, &args),predicate_nextarg(ctx, &args))",
			"predicate_argument_shift(ctx, &args)",
			"js_arguments_shift(&args)",
			"",
			"ret = PRECEDENCE_"
		],
		"reverse": false,
		"scrollbar_highlights": true,
		"show_context": true,
		"use_buffer2": true,
		"use_gitignore": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"sheets":
			[
				{
					"buffer": 0,
					"selected": true,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2034,
						"regions":
						{
						},
						"selection":
						[
						],
						"settings":
						{
							"current_file": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
							"outline_rename_mode": false,
							"symkeys":
							[
								[
									644,
									663
								],
								[
									691,
									705
								],
								[
									817,
									831
								],
								[
									1140,
									1152
								],
								[
									1216,
									1232
								],
								[
									1329,
									1362
								],
								[
									1841,
									1862
								],
								[
									1943,
									1962
								],
								[
									2094,
									2118
								],
								[
									2257,
									2273
								],
								[
									2925,
									2942
								],
								[
									3474,
									3495
								],
								[
									4363,
									4385
								],
								[
									5061,
									5086
								],
								[
									5856,
									5881
								],
								[
									6555,
									6580
								],
								[
									8146,
									8175
								],
								[
									8414,
									8430
								],
								[
									9311,
									9327
								],
								[
									10430,
									10455
								],
								[
									10899,
									10913
								],
								[
									12047,
									12062
								],
								[
									12533,
									12546
								],
								[
									13140,
									13152
								],
								[
									13558,
									13570
								],
								[
									13985,
									14000
								],
								[
									15081,
									15101
								],
								[
									15440,
									15459
								],
								[
									15678,
									15690
								],
								[
									17943,
									17960
								],
								[
									18558,
									18576
								],
								[
									19788,
									19808
								],
								[
									20269,
									20290
								],
								[
									20764,
									20779
								],
								[
									21272,
									21292
								],
								[
									21751,
									21763
								],
								[
									22482,
									22497
								],
								[
									23996,
									24021
								],
								[
									24560,
									24585
								],
								[
									25837,
									25851
								],
								[
									26764,
									26778
								],
								[
									27070,
									27083
								],
								[
									29462,
									29475
								],
								[
									30382,
									30392
								],
								[
									38797,
									38809
								],
								[
									39339,
									39353
								],
								[
									39383,
									39397
								]
							],
							"symlist":
							[
								"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
								"\tⓉ  pcg32_random_t ; — typedef",
								"—Ⓕ– pcg32_random_r ( ) { … } — function",
								"—Ⓕ– pcg32_random ( ) { … } — function",
								"—Ⓕ– pcg32_init_state ( ) { … } — function",
								"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
								"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
								"—Ⓕ– js_string_free_func ( ) { … } — function",
								"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
								"—Ⓕ– js_misc_tostring ( ) { … } — function",
								"—Ⓕ– js_misc_topointer ( ) { … } — function",
								"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
								"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
								"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
								"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
								"—Ⓕ– js_misc_searcharraybuffer ( ) { … } — function",
								"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
								"—Ⓕ– js_misc_proclink ( ) { … } — function",
								"—Ⓕ– js_misc_procread ( ) { … } — function",
								"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
								"—Ⓕ– js_misc_hrtime ( ) { … } — function",
								"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
								"—Ⓕ– js_misc_uname ( ) { … } — function",
								"—Ⓕ– js_misc_btoa ( ) { … } — function",
								"—Ⓕ– js_misc_atob ( ) { … } — function",
								"—Ⓕ– js_misc_compile ( ) { … } — function",
								"—Ⓕ– js_misc_write_object ( ) { … } — function",
								"—Ⓕ– js_misc_read_object ( ) { … } — function",
								"—Ⓕ– js_misc_getx ( ) { … } — function",
								"—Ⓕ– js_misc_valuetype ( ) { … } — function",
								"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
								"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
								"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
								"—Ⓕ– js_misc_opcodes ( ) { … } — function",
								"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
								"—Ⓕ– js_misc_atom ( ) { … } — function",
								"—Ⓕ– js_misc_classid ( ) { … } — function",
								"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
								"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
								"—Ⓕ– js_misc_random ( ) { … } — function",
								"—Ⓕ– js_misc_escape ( ) { … } — function",
								"—Ⓕ– js_misc_quote ( ) { … } — function",
								"—Ⓕ– js_misc_error ( ) { … } — function",
								"—Ⓕ– js_misc_is ( ) { … } — function",
								"—Ⓕ– js_misc_init ( ) { … } — function",
								"\tⓂ  JS_INIT_MODULE … — macro object",
								"\tⓂ  JS_INIT_MODULE … — macro object"
							],
							"syntax": "Packages/Outline/outline.hidden-tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1632546871.65,
							"tabs_extra_last_activated_sheet_index": 0,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"stack_multiselect": false,
					"type": "text"
				}
			]
		},
		{
			"sheets":
			[
				{
					"buffer": 1,
					"file": "buffer-utils.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7730,
						"regions":
						{
						},
						"selection":
						[
							[
								2573,
								2573
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1632546903.82,
							"tabs_extra_last_activated_sheet_index": 0,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1710.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "quickjs-blob.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8259,
						"regions":
						{
						},
						"selection":
						[
							[
								1371,
								1371
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1632546908.82,
							"tabs_extra_last_activated_sheet_index": 1,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 969.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "qjsm.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 28329,
						"regions":
						{
						},
						"selection":
						[
							[
								26468,
								26479
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1632523725.85,
							"tabs_extra_last_activated_sheet_index": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 17723.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "quickjs-inspect.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 34538,
						"regions":
						{
						},
						"selection":
						[
							[
								16192,
								16192
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1632546866.59,
							"tabs_extra_last_activated_sheet_index": 3,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9324.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "quickjs-misc.c",
					"selected": true,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 39830,
						"regions":
						{
						},
						"selection":
						[
							[
								6996,
								6996
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1632548824.65,
							"tabs_extra_last_activated_sheet_index": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4854.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "quickjs-location.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 997,
						"regions":
						{
						},
						"selection":
						[
							[
								893,
								916
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tabs_extra_last_activated": 1632546856.59,
							"tabs_extra_last_activated_sheet_index": 5
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "quickjs-location.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11602,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1632546859.32,
							"tabs_extra_last_activated_sheet_index": 6,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "lib/util.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20821,
						"regions":
						{
						},
						"selection":
						[
							[
								20501,
								20501
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1632546780.73,
							"tabs_extra_last_activated_sheet_index": 5,
							"translate_tabs_to_spaces": true,
							"word_wrap": true
						},
						"translation.x": 0.0,
						"translation.y": 14854.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "/home/roman/Projects/plot-cv/quickjs/quickjs.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 42482,
						"regions":
						{
						},
						"selection":
						[
							[
								30536,
								30553
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 4,
							"tabs_extra_last_activated": 1632547734.61,
							"tabs_extra_last_activated_sheet_index": 8,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 15271.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "utils.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 28549,
						"regions":
						{
						},
						"selection":
						[
							[
								28549,
								28549
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1632532610.15,
							"tabs_extra_last_activated_sheet_index": 5,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 15481.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 11,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1104676,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions": "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",
								"scope": ""
							}
						},
						"selection":
						[
							[
								1100634,
								1100634
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 5,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage",
							"tabs_extra_last_activated": 1632532668.92,
							"tabs_extra_last_activated_sheet_index": 6,
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 676134.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "/home/roman/Sources/plot-cv/quickjs/qjs-modules/buffer-utils.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7730,
						"regions":
						{
						},
						"selection":
						[
							[
								5358,
								5373
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1632532671.43,
							"tabs_extra_last_activated_sheet_index": 7,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3814.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "buffer-utils.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11531,
						"regions":
						{
						},
						"selection":
						[
							[
								8695,
								8695
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1632532707.44,
							"tabs_extra_last_activated_sheet_index": 8,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6208.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "/home/roman/Sources/plot-cv/quickjs/qjs-modules/ringbuffer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2386,
						"regions":
						{
						},
						"selection":
						[
							[
								91,
								91
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1632532543.37,
							"tabs_extra_last_activated_sheet_index": 7,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 57.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "utils.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 55408,
						"regions":
						{
							"col_00DDDDFF":
							{
								"flags": 16,
								"regions":
								[
									[
										5742,
										5752
									]
								],
								"scope": "col_00DDDDFF"
							},
							"col_00DDDDFF_icon":
							{
								"flags": 16,
								"icon": "Packages/User/Color Highlight.cache/col_00DDDDFF_circle.png",
								"regions":
								[
									[
										5721,
										5721
									]
								],
								"scope": "col_gutter"
							},
							"col_010101FF":
							{
								"flags": 16,
								"regions":
								[
									[
										5670,
										5680
									]
								],
								"scope": "col_010101FF"
							},
							"col_010101FF_icon":
							{
								"flags": 16,
								"icon": "Packages/User/Color Highlight.cache/col_010101FF_circle.png",
								"regions":
								[
									[
										5627,
										5627
									]
								],
								"scope": "col_gutter"
							},
							"col_808000FF":
							{
								"flags": 16,
								"regions":
								[
									[
										5657,
										5665
									]
								],
								"scope": "col_808000FF"
							},
							"col_808000FF_icon":
							{
								"flags": 16,
								"icon": "Packages/User/Color Highlight.cache/col_808000FF_circle.png",
								"regions":
								[
									[
										5627,
										5627
									]
								],
								"scope": "col_gutter"
							}
						},
						"selection":
						[
							[
								49904,
								50186
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1632532515.33,
							"tabs_extra_last_activated_sheet_index": 6,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 36913.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"stack_multiselect": false,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 28.0
	},
	"input":
	{
		"height": 42.0
	},
	"layout":
	{
		"cells":
		[
			[
				2,
				0,
				3,
				2
			],
			[
				0,
				0,
				2,
				2
			]
		],
		"cols":
		[
			0.0,
			0.2,
			0.721299893573,
			1.0
		],
		"rows":
		[
			0.0,
			0.5,
			1.0
		]
	},
	"menu_visible": true,
	"output.Debugger":
	{
		"height": 139.0
	},
	"output.exec":
	{
		"height": 120.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.unsaved_changes":
	{
		"height": 108.0
	},
	"pinned_build_system": "",
	"project": "modules.sublime-project",
	"replace":
	{
		"height": 52.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"quickjs.h",
				"~/Projects/plot-cv/quickjs/quickjs.h"
			],
			[
				"utils.c",
				"utils.c"
			],
			[
				"sockets.c",
				"quickjs-sockets.c"
			],
			[
				"quickjs-m",
				"quickjs-misc.c"
			],
			[
				"redicate.c",
				"predicate.c"
			],
			[
				"sockets.h",
				"quickjs-sockets.h"
			],
			[
				"qjsm.c",
				"qjsm.c"
			],
			[
				"quickjs-pat",
				"quickjs-path.c"
			],
			[
				"quickjs-misc",
				"quickjs-misc.c"
			],
			[
				"fs.js",
				"lib/fs.js"
			],
			[
				"",
				"quickjs-inspect.c"
			],
			[
				"utils.h",
				"utils.h"
			],
			[
				"test_sock",
				"tests/test_sockets.js"
			],
			[
				"buffer-u",
				"buffer-utils.c"
			],
			[
				"buffer-",
				"buffer-utils.h"
			],
			[
				"parser.js",
				"lib/parser.js"
			],
			[
				"char-",
				"char-utils.h"
			],
			[
				"test_par",
				"tests/test_parser.js"
			],
			[
				"test_misc",
				"tests/test_misc.js"
			],
			[
				"qjsm",
				"qjsm.c"
			],
			[
				"conso",
				"lib/console.js"
			],
			[
				"clang-f",
				".clang-format"
			],
			[
				"util",
				"lib/util.js"
			],
			[
				"test_mi",
				"tests/test_misc.js"
			],
			[
				"ockets.",
				"quickjs-sockets.h"
			],
			[
				"quickjs-ar",
				"quickjs-archive.c"
			],
			[
				"fd_set",
				"lib/fd_set.js"
			],
			[
				"clang-fo",
				".clang-format"
			],
			[
				"buffer-ut",
				"buffer-utils.c"
			],
			[
				"misc.",
				"quickjs-misc.h"
			],
			[
				"misc.c",
				"quickjs-misc.c"
			],
			[
				"qjsm.",
				"qjsm.c"
			],
			[
				"cmakelists",
				"CMakeLists.txt"
			],
			[
				"quickjs-mi",
				"quickjs-misc.c"
			],
			[
				"socklen_t.js",
				"lib/socklen_t.js"
			],
			[
				"str.h",
				"quickjs-stringdecoder.h"
			],
			[
				"quickjs-libc",
				"~/Sources/plot-cv/quickjs/quickjs-libc.h"
			],
			[
				"quickjs-sock",
				"quickjs-sockets.c"
			],
			[
				"sockets",
				"quickjs-sockets.c"
			],
			[
				"test_so",
				"tests/test_sockets.js"
			],
			[
				"test_loca",
				"tests/test_location.js"
			],
			[
				"inspect.c",
				"quickjs-inspect.c"
			],
			[
				".clang-fo",
				".clang-format"
			],
			[
				"buff",
				"buffer-utils.c"
			],
			[
				"buffer-util",
				"buffer-utils.c"
			],
			[
				"buffer-utils.c",
				"buffer-utils.c"
			],
			[
				"util.js",
				"lib/util.js"
			],
			[
				"quickjs-so",
				"quickjs-sockets.c"
			],
			[
				"quickjs-socket",
				"quickjs-sockets.c"
			],
			[
				"quickjs-insp",
				"quickjs-inspect.c"
			],
			[
				"test_soc",
				"tests/test_sockets.js"
			],
			[
				"test_lexer",
				"tests/test_lexer.js"
			],
			[
				"quickjs-lex",
				"quickjs-lexer.c"
			],
			[
				"test_qjsm",
				"tests/test_qjsm.js"
			],
			[
				"buffer-tu",
				"buffer-utils.c"
			],
			[
				"quickjs-in",
				"quickjs-inspect.c"
			],
			[
				"repl.",
				"lib/repl.js"
			],
			[
				"quickjs-ins",
				"quickjs-inspect.c"
			],
			[
				"quickjs-blo",
				"quickjs-blob.c"
			],
			[
				"cmake",
				"CMakeLists.txt"
			],
			[
				"test_mis",
				"tests/test_misc.js"
			],
			[
				"test_blob",
				"tests/test_blob.js"
			],
			[
				"test_string",
				"tests/test_stringdecoder.js"
			],
			[
				"test_str",
				"tests/test_stringdecoder.js"
			],
			[
				"quickjs-blb",
				"quickjs-blob.h"
			],
			[
				"vector.h",
				"vector.h"
			],
			[
				"ringbuffer.h",
				"ringbuffer.h"
			],
			[
				"repl.js",
				"lib/repl.js"
			],
			[
				"quickjsmo",
				"cmake/QuickJSModule.cmake"
			],
			[
				"inspe",
				"quickjs-inspect.c"
			],
			[
				"misc",
				"quickjs-misc.c"
			],
			[
				"deep",
				"quickjs-deep.c"
			],
			[
				"terminal.",
				"lib/terminal.js"
			],
			[
				"tty.js",
				"lib/tty.js"
			],
			[
				"intern",
				"quickjs-internal.h"
			],
			[
				"test_chil",
				"tests/test_childprocess.js"
			],
			[
				"pointer.h",
				"pointer.h"
			],
			[
				"stack",
				"lib/stack.js"
			],
			[
				"test_lex",
				"tests/test_lexer.js"
			],
			[
				"quickjs.c",
				"~/Projects/plot-cv/quickjs/quickjs.c"
			],
			[
				"pointer.c",
				"pointer.c"
			],
			[
				"-insp",
				"quickjs-inspect.c"
			],
			[
				"test_op",
				"tests/test_op_overloading.js"
			],
			[
				"lexer.c",
				"lexer.c"
			],
			[
				"quickjs-lexer",
				"quickjs-lexer.c"
			],
			[
				"test_qjs",
				"tests/test_qjsm.js"
			],
			[
				"quickjs-pre",
				"quickjs-predicate.c"
			],
			[
				"pred",
				"predicate.c"
			],
			[
				"dee",
				"quickjs-deep.c"
			],
			[
				"test_qj",
				"tests/test_qjsm.js"
			],
			[
				"quicksj-in",
				"quickjs-internal.h"
			],
			[
				"property",
				"property-enumeration.c"
			],
			[
				"pointer.",
				"pointer.c"
			],
			[
				"quickjs",
				"quickjs-inspect.c"
			],
			[
				"util.j",
				"lib/util.js"
			],
			[
				"jsm.c",
				"qjsm.c"
			],
			[
				"test_point",
				"tests/test_pointer.js"
			],
			[
				"bnflex",
				"lib/bnflexer.js"
			],
			[
				"bnf.y",
				"~/Projects/plot-cv/lib/grammars/bnf.y"
			],
			[
				"grammar.ki",
				"grammar.kison"
			],
			[
				"test_pat",
				"tests/test_path.js"
			],
			[
				"exten",
				"lib/extendArray.js"
			],
			[
				"test_parse",
				"tests/test_parser.js"
			],
			[
				"test_path",
				"tests/test_path.js"
			],
			[
				"lexer.h",
				"lexer.h"
			],
			[
				"test_tree",
				"tests/test_treewalker.js"
			],
			[
				"tree.h",
				"src/tree.h"
			],
			[
				"scan_ulongn",
				"lib/scan/scan_ulongn.c"
			],
			[
				"term_rest",
				"src/term/term_restore.c"
			],
			[
				"parse.h",
				"src/parse.h"
			],
			[
				"cmakeli",
				"CMakeLists.txt"
			],
			[
				"byte.h",
				"lib/byte.h"
			],
			[
				"buffer.h",
				"lib/buffer.h"
			],
			[
				"shell.h",
				"lib/shell.h"
			],
			[
				"mmap_file",
				"lib/stralloc/mmap_filename.c"
			],
			[
				"uffer.h",
				"lib/buffer.h"
			],
			[
				"scan.h",
				"lib/scan.h"
			],
			[
				"stralloc.h",
				"lib/stralloc.h"
			],
			[
				"path.h",
				"lib/path.h"
			],
			[
				"scan.",
				"lib/scan.h"
			],
			[
				"debug_char",
				"src/debug/debug_char.c"
			],
			[
				"source_pop",
				"src/source/source_pop.c"
			],
			[
				"builtin.h",
				"src/builtin.h"
			],
			[
				"debug_node",
				"src/debug/debug_node.c"
			],
			[
				"sig_in",
				"lib/sig_internal.h"
			],
			[
				"term_",
				"src/term/term_attr.c"
			],
			[
				"glob.h",
				"lib/glob.h"
			],
			[
				"source.h",
				"src/source.h"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"~/Projects/plot-cv/plot-cv.sublime-project"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 370.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"WS"
			]
		],
		"width": 970.0
	},
	"selected_group": 1,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 236.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
