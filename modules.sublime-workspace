{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"STRING",
				"STRINGDECODER_ENCODING"
			],
			[
				"STRINGDECODER_EN",
				"STRINGDECODER_ENCODING"
			],
			[
				"STRINGDE",
				"STRINGDECODER_END"
			],
			[
				"JS_Throw",
				"JS_ThrowInternalError"
			],
			[
				"JS_Free",
				"JS_FreeCString"
			],
			[
				"JS_Get",
				"JS_GetPropertyStr"
			],
			[
				"JS_New",
				"JS_NewStringLen"
			],
			[
				"JS_T",
				"JS_ThrowOutOfMemory"
			],
			[
				"JS_",
				"JS_GetPropertyUint32"
			],
			[
				"JS_GetP",
				"JS_GetPropertyStr"
			],
			[
				"ringbuffer_",
				"ringbuffer_continuous_length"
			],
			[
				"JS_Th",
				"JS_ThrowOutOfMemory"
			],
			[
				"string",
				"stringdecoder_proto"
			],
			[
				"get",
				"getOwnPropertyNames"
			],
			[
				"JS_SetP",
				"JS_SetPropertyStr"
			],
			[
				"JS_Thr",
				"JS_ThrowInternalError"
			],
			[
				"ringbuffer_res",
				"ringbuffer_resize"
			],
			[
				"ringb",
				"ringbuffer_normalize"
			],
			[
				"ringbuffer",
				"ringbuffer_length"
			],
			[
				"ring",
				"ringbuffer_full"
			],
			[
				"STRINGDEC",
				"STRINGDECODER_END"
			],
			[
				"Ar",
				"ArchiveEntryRef"
			],
			[
				"js_archive",
				"js_archiveentry_data"
			],
			[
				"ARC",
				"ARCHIVE_METHOD_READ"
			],
			[
				"CMAKE_CURREN",
				"CMAKE_CURRENT_BINARY_DIR"
			],
			[
				"getCommand",
				"getCommandExecutable"
			],
			[
				"SYS",
				"SYSCALLERROR_ERRNO"
			],
			[
				"SYSCALL",
				"SYSCALLERROR_SYSCALL"
			],
			[
				"js_sys",
				"js_syscallerror_data"
			],
			[
				"FUNC_",
				"FUNC_GETUID"
			],
			[
				"predi",
				"predicates"
			],
			[
				"int64_t",
				"uint64_t"
			],
			[
				"PRECEDENCE_LOG",
				"PRECEDENCE_LOGICAL_NOT"
			],
			[
				"js_is",
				"js_is_null_or_undefined"
			],
			[
				"js_set_to",
				"js_set_tostringtag_value"
			],
			[
				"Predicate",
				"PredicateOperatorSet"
			],
			[
				"Predi",
				"PredicateOperatorSet"
			],
			[
				"JS_P",
				"JS_PROP_CONFIGURABLE"
			],
			[
				"operat",
				"operators_set"
			],
			[
				"JS_SetProp",
				"JS_SetPropertyUint32"
			],
			[
				"break",
				"stringBreakNewline"
			],
			[
				"define",
				"defineProperty"
			],
			[
				"Event",
				"EventEmitter"
			],
			[
				"sy",
				"syntaxerror_ctor"
			],
			[
				"child_pr",
				"child_process_proto"
			],
			[
				"targtet_",
				"target_compile_definitions"
			],
			[
				"jsm_module",
				"jsm_module_loader_so"
			],
			[
				"base",
				"base_name"
			],
			[
				"ATOM",
				"ATOM_TO_VALUE"
			],
			[
				"prop",
				"propenum_tab"
			],
			[
				"JS_Set",
				"JS_SetPropertyUint32"
			],
			[
				"js_loca",
				"js_location_data"
			],
			[
				"loca",
				"location_proto"
			],
			[
				"HAVE_QUI",
				"HAVE_QUICKJS_LIBRARY"
			],
			[
				"jsm_load",
				"jsm_load_packages_json"
			],
			[
				"js_sy",
				"js_syntaxerror_class_id"
			],
			[
				"synta",
				"syntaxerror_proto"
			],
			[
				"property_",
				"property_enumeration_key"
			],
			[
				"jsm_mo",
				"jsm_module_loader_path"
			],
			[
				"inspe",
				"inspect_custom_node"
			],
			[
				"inspect",
				"inspect_custom_node"
			],
			[
				"property",
				"property_enumeration_circular"
			],
			[
				"Reg",
				"RegExpCompare"
			],
			[
				"property_enum",
				"property_enumeration_length"
			],
			[
				"Opera",
				"OperatorsObjects"
			],
			[
				"else",
				"elseif"
			],
			[
				"ABC",
				"ABCDEF"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "  Ⓜ  _GNU_SOURCE … — macro object\n—Ⓜ– max ( ) … — macro function\n—Ⓕ– blob_init ( ) { … } — function\n—Ⓕ– blob_new ( ) { … } — function\n—Ⓕ– blob_write ( ) { … } — function\n—Ⓕ– blob_free ( ) { … } — function\n—Ⓕ– blob_free_rt ( ) { … } — function\n—Ⓕ– blob_input ( ) { … } — function\n—Ⓕ– js_blob_free_func ( ) { … } — function\n—Ⓕ– js_blob_wrap ( ) { … } — function\n—Ⓕ– js_blob_new ( ) { … } — function\n—Ⓕ– js_blob_get ( ) { … } — function\n—Ⓕ– js_blob_constructor ( ) { … } — function\n—Ⓕ– js_blob_method ( ) { … } — function\n—Ⓕ– js_blob_inspect ( ) { … } — function\n—Ⓕ– js_blob_finalizer ( ) { … } — function\n—Ⓕ– js_blob_init ( ) { … } — function\n  Ⓜ  JS_INIT_MODULE … — macro object\n  Ⓜ  JS_INIT_MODULE … — macro object",
			"settings":
			{
				"buffer_size": 714,
				"line_ending": "Unix",
				"name": "𝌆 Outline",
				"scratch": true
			},
			"undo_stack":
			[
				[
					420,
					2,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/qjsm.c",
						"symkeys":
						[
							[
								28,
								39
							],
							[
								1755,
								1769
							],
							[
								2033,
								2044
							],
							[
								2159,
								2172
							],
							[
								2259,
								2288
							],
							[
								2405,
								2423
							],
							[
								2450,
								2463
							],
							[
								2525,
								2543
							],
							[
								2944,
								2962
							],
							[
								2973,
								2991
							],
							[
								3001,
								3019
							],
							[
								3025,
								3043
							],
							[
								3057,
								3075
							],
							[
								3086,
								3104
							],
							[
								3112,
								3130
							],
							[
								3141,
								3159
							],
							[
								3166,
								3184
							],
							[
								3214,
								3232
							],
							[
								3283,
								3317
							],
							[
								3360,
								3378
							],
							[
								3628,
								3639
							],
							[
								3778,
								3799
							],
							[
								3885,
								3901
							],
							[
								4035,
								4049
							],
							[
								4144,
								4160
							],
							[
								4555,
								4567
							],
							[
								4820,
								4836
							],
							[
								5100,
								5125
							],
							[
								6753,
								6774
							],
							[
								7166,
								7184
							],
							[
								7641,
								7656
							],
							[
								8203,
								8217
							],
							[
								8546,
								8561
							],
							[
								9105,
								9117
							],
							[
								9349,
								9368
							],
							[
								9727,
								9745
							],
							[
								10170,
								10189
							],
							[
								10986,
								11001
							],
							[
								11440,
								11460
							],
							[
								12591,
								12611
							],
							[
								13784,
								13806
							],
							[
								16033,
								16048
							],
							[
								16585,
								16597
							],
							[
								17323,
								17335
							],
							[
								17582,
								17595
							],
							[
								18257,
								18272
							],
							[
								18752,
								18767
							],
							[
								19108,
								19124
							],
							[
								19467,
								19482
							],
							[
								19773,
								19790
							],
							[
								20287,
								20302
							],
							[
								20319,
								20334
							],
							[
								20352,
								20369
							],
							[
								20405,
								20416
							],
							[
								20759,
								20786
							],
							[
								20947,
								20975
							],
							[
								21571,
								21594
							],
							[
								22282,
								22303
							],
							[
								22380,
								22396
							],
							[
								22829,
								22843
							],
							[
								23067,
								23084
							],
							[
								24381,
								24390
							],
							[
								24404,
								24412
							],
							[
								25513,
								25527
							],
							[
								26742,
								26756
							],
							[
								30589,
								30593
							],
							[
								36388,
								36406
							],
							[
								37023,
								37043
							]
						],
						"symlist":
						[
							" Ⓜ  _GNU_SOURCE … — macro object",
							"—Ⓕ– atomic_add_int ( ) { … } — function",
							"—Ⓒ– pollhandler { … } ; — type",
							" Ⓣ  pollhandler_t ; — typedef",
							" ⒡  js_std_set_module_loader_func ( ) ; — function declaration",
							" ⒡  malloc_usable_size ( ) ; — function declaration",
							"—Ⓜ– trim_dotslash ( ) … — macro function",
							"—Ⓜ– jsm_declare_module ( ) … — macro function",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  js_std_set_worker_new_context_func ( ) ; — function declaration",
							" ⒡  jsm_std_dump_error ( ) ; — function declaration",
							"—Ⓕ– jsm_time_ms ( ) { … } — function",
							"—Ⓕ– jsm_interrupt_handler ( ) { … } — function",
							"—Ⓕ– jsm_unlink_timer ( ) { … } — function",
							"—Ⓕ– jsm_free_timer ( ) { … } — function",
							"—Ⓕ– jsm_call_handler ( ) { … } — function",
							"—Ⓕ– jsm_sab_free ( ) { … } — function",
							"—Ⓕ– jsm_free_message ( ) { … } — function",
							"—Ⓕ– jsm_handle_posted_message ( ) { … } — function",
							"—Ⓕ– jsm_load_package_json ( ) { … } — function",
							"—Ⓕ– jsm_module_exports ( ) { … } — function",
							"—Ⓕ– jsm_module_find ( ) { … } — function",
							"—Ⓕ– jsm_module_get ( ) { … } — function",
							"—Ⓕ– jsm_module_list ( ) { … } — function",
							"—Ⓕ– jsm_dump_obj ( ) { … } — function",
							"—Ⓕ– jsm_std_dump_error1 ( ) { … } — function",
							"—Ⓕ– jsm_std_dump_error ( ) { … } — function",
							"—Ⓕ– jsm_find_module_ext ( ) { … } — function",
							"—Ⓕ– jsm_find_module ( ) { … } — function",
							"—Ⓕ– jsm_normalize_module ( ) { … } — function",
							"—Ⓕ– jsm_module_loader_so ( ) { … } — function",
							"—Ⓕ– jsm_module_loader_path ( ) { … } — function",
							"—Ⓕ– jsm_eval_binary ( ) { … } — function",
							"—Ⓕ– jsm_eval_buf ( ) { … } — function",
							"—Ⓕ– jsm_eval_str ( ) { … } — function",
							"—Ⓕ– jsm_eval_file ( ) { … } — function",
							"—Ⓕ– jsm_load_script ( ) { … } — function",
							"—Ⓕ– jsm_load_module ( ) { … } — function",
							"—Ⓕ– jsm_list_modules ( ) { … } — function",
							"—Ⓕ– jsm_context_new ( ) { … } — function",
							"—Ⓜ– jsm_module_native ( ) … — macro function",
							" Ⓜ  MALLOC_OVERHEAD … — macro object",
							" Ⓜ  MALLOC_OVERHEAD … — macro object",
							"—Ⓒ– trace_malloc_data { … } ; — type",
							"—Ⓕ– dump_vector ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_ptr_offset ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_usable_size ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_printf ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_init ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc ( ) { … } — function",
							"—Ⓕ– jsm_trace_free ( ) { … } — function",
							"—Ⓕ– jsm_trace_realloc ( ) { … } — function",
							" Ⓜ  PROG_NAME … — macro object",
							"—Ⓕ– jsm_help ( ) { … } — function",
							"—Ⓕ– js_eval_script ( ) { … } — function",
							"—Ⓕ– js_module_func ( ) { … } — function",
							"—Ⓕ– main ( ) { … } — function",
							"—Ⓜ– jsm_builtin_native ( ) … — macro function",
							"—Ⓜ– jsm_builtin_compiled ( ) … — macro function"
						]
					},
					"BAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAICDik4IgIF9HTlVfU09VUkNFIOKApiDigJQgbWFjcm8gb2JqZWN0CuKAlOKSu+KAkyBhdG9taWNfYWRkX2ludCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK44oCTIHBvbGxoYW5kbGVyIHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcG9sbGhhbmRsZXJfdCA7IOKAlCB0eXBlZGVmCiAg4pKhICBqc19zdGRfc2V0X21vZHVsZV9sb2FkZXJfZnVuYyAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIG1hbGxvY191c2FibGVfc2l6ZSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4oCU4pOC4oCTIHRyaW1fZG90c2xhc2ggKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIGpzbV9kZWNsYXJlX21vZHVsZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNfc3RkX3NldF93b3JrZXJfbmV3X2NvbnRleHRfZnVuYyAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIGpzbV9zdGRfZHVtcF9lcnJvciAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4oCU4pK74oCTIGpzbV90aW1lX21zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2ludGVycnVwdF9oYW5kbGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3VubGlua190aW1lciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9mcmVlX3RpbWVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2NhbGxfaGFuZGxlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9zYWJfZnJlZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9mcmVlX21lc3NhZ2UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21faGFuZGxlX3Bvc3RlZF9tZXNzYWdlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2xvYWRfcGFja2FnZV9qc29uICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9leHBvcnRzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9maW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9nZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fbW9kdWxlX2xpc3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fZHVtcF9vYmogKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fc3RkX2R1bXBfZXJyb3IxICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3N0ZF9kdW1wX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2ZpbmRfbW9kdWxlX2V4dCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9maW5kX21vZHVsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9ub3JtYWxpemVfbW9kdWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9sb2FkZXJfc28gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fbW9kdWxlX2xvYWRlcl9wYXRoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfYnVmICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfc3RyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfZmlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9sb2FkX3NjcmlwdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9sb2FkX21vZHVsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9saXN0X21vZHVsZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fY29udGV4dF9uZXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKTguKAkyBqc21fbW9kdWxlX25hdGl2ZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgogIOKTgiAgTUFMTE9DX09WRVJIRUFEIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBNQUxMT0NfT1ZFUkhFQUQg4oCmIOKAlCBtYWNybyBvYmplY3QK4oCU4pK44oCTIHRyYWNlX21hbGxvY19kYXRhIHsg4oCmIH0gOyDigJQgdHlwZQrigJTikrvigJMgZHVtcF92ZWN0b3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX3B0cl9vZmZzZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3RyYWNlX21hbGxvY19wcmludGYgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3RyYWNlX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfcmVhbGxvYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIFBST0dfTkFNRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTikrvigJMganNtX2hlbHAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ldmFsX3NjcmlwdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21vZHVsZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbWFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pOC4oCTIGpzbV9idWlsdGluX25hdGl2ZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTik4LigJMganNtX2J1aWx0aW5fY29tcGlsZWQgKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24AAAAAAAAAAMILAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAICDik4IgIF9HTlVfU09VUkNFIOKApiDigJQgbWFjcm8gb2JqZWN0CuKAlOKSu+KAkyBhdG9taWNfYWRkX2ludCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK44oCTIHBvbGxoYW5kbGVyIHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcG9sbGhhbmRsZXJfdCA7IOKAlCB0eXBlZGVmCiAg4pKhICBqc19zdGRfc2V0X21vZHVsZV9sb2FkZXJfZnVuYyAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIG1hbGxvY191c2FibGVfc2l6ZSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4oCU4pOC4oCTIHRyaW1fZG90c2xhc2ggKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIGpzbV9kZWNsYXJlX21vZHVsZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNfc3RkX3NldF93b3JrZXJfbmV3X2NvbnRleHRfZnVuYyAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIGpzbV9zdGRfZHVtcF9lcnJvciAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4oCU4pK74oCTIGpzbV90aW1lX21zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2ludGVycnVwdF9oYW5kbGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3VubGlua190aW1lciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9mcmVlX3RpbWVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2NhbGxfaGFuZGxlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9zYWJfZnJlZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9mcmVlX21lc3NhZ2UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21faGFuZGxlX3Bvc3RlZF9tZXNzYWdlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2xvYWRfcGFja2FnZV9qc29uICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9leHBvcnRzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9maW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9nZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fbW9kdWxlX2xpc3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fZHVtcF9vYmogKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fc3RkX2R1bXBfZXJyb3IxICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3N0ZF9kdW1wX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2ZpbmRfbW9kdWxlX2V4dCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9maW5kX21vZHVsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9ub3JtYWxpemVfbW9kdWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9sb2FkZXJfc28gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fbW9kdWxlX2xvYWRlcl9wYXRoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfYnVmICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfc3RyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfZmlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9sb2FkX3NjcmlwdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9sb2FkX21vZHVsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9saXN0X21vZHVsZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fY29udGV4dF9uZXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKTguKAkyBqc21fbW9kdWxlX25hdGl2ZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgogIOKTgiAgTUFMTE9DX09WRVJIRUFEIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBNQUxMT0NfT1ZFUkhFQUQg4oCmIOKAlCBtYWNybyBvYmplY3QK4oCU4pK44oCTIHRyYWNlX21hbGxvY19kYXRhIHsg4oCmIH0gOyDigJQgdHlwZQrigJTikrvigJMgZHVtcF92ZWN0b3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX3B0cl9vZmZzZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3RyYWNlX21hbGxvY19wcmludGYgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3RyYWNlX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfcmVhbGxvYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIFBST0dfTkFNRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTikrvigJMganNtX2hlbHAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ldmFsX3NjcmlwdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21vZHVsZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbWFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pOC4oCTIGpzbV9idWlsdGluX25hdGl2ZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTik4LigJMganNtX2J1aWx0aW5fY29tcGlsZWQgKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24AAAAAAAAAAMILAAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					421,
					2,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/qjsm.c",
						"symkeys":
						[
							[
								28,
								39
							],
							[
								1755,
								1769
							],
							[
								2033,
								2044
							],
							[
								2159,
								2172
							],
							[
								2259,
								2288
							],
							[
								2405,
								2423
							],
							[
								2450,
								2463
							],
							[
								2525,
								2543
							],
							[
								2944,
								2962
							],
							[
								2973,
								2991
							],
							[
								3001,
								3019
							],
							[
								3025,
								3043
							],
							[
								3057,
								3075
							],
							[
								3086,
								3104
							],
							[
								3112,
								3130
							],
							[
								3141,
								3159
							],
							[
								3166,
								3184
							],
							[
								3214,
								3232
							],
							[
								3283,
								3317
							],
							[
								3360,
								3378
							],
							[
								3628,
								3639
							],
							[
								3778,
								3799
							],
							[
								3885,
								3901
							],
							[
								4035,
								4049
							],
							[
								4144,
								4160
							],
							[
								4555,
								4567
							],
							[
								4820,
								4836
							],
							[
								5100,
								5125
							],
							[
								6753,
								6774
							],
							[
								7166,
								7184
							],
							[
								7641,
								7656
							],
							[
								8203,
								8217
							],
							[
								8546,
								8561
							],
							[
								9105,
								9117
							],
							[
								9349,
								9368
							],
							[
								9727,
								9745
							],
							[
								10170,
								10189
							],
							[
								10986,
								11001
							],
							[
								11440,
								11460
							],
							[
								12591,
								12611
							],
							[
								13784,
								13806
							],
							[
								16033,
								16048
							],
							[
								16585,
								16597
							],
							[
								17323,
								17335
							],
							[
								17582,
								17595
							],
							[
								18256,
								18271
							],
							[
								18751,
								18766
							],
							[
								19107,
								19123
							],
							[
								19466,
								19481
							],
							[
								19772,
								19789
							],
							[
								20286,
								20301
							],
							[
								20318,
								20333
							],
							[
								20351,
								20368
							],
							[
								20404,
								20415
							],
							[
								20758,
								20785
							],
							[
								20946,
								20974
							],
							[
								21570,
								21593
							],
							[
								22281,
								22302
							],
							[
								22379,
								22395
							],
							[
								22828,
								22842
							],
							[
								23066,
								23083
							],
							[
								24380,
								24389
							],
							[
								24403,
								24411
							],
							[
								25512,
								25526
							],
							[
								26741,
								26755
							],
							[
								30588,
								30592
							],
							[
								36387,
								36405
							],
							[
								37022,
								37042
							]
						],
						"symlist":
						[
							" Ⓜ  _GNU_SOURCE … — macro object",
							"—Ⓕ– atomic_add_int ( ) { … } — function",
							"—Ⓒ– pollhandler { … } ; — type",
							" Ⓣ  pollhandler_t ; — typedef",
							" ⒡  js_std_set_module_loader_func ( ) ; — function declaration",
							" ⒡  malloc_usable_size ( ) ; — function declaration",
							"—Ⓜ– trim_dotslash ( ) … — macro function",
							"—Ⓜ– jsm_declare_module ( ) … — macro function",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  js_std_set_worker_new_context_func ( ) ; — function declaration",
							" ⒡  jsm_std_dump_error ( ) ; — function declaration",
							"—Ⓕ– jsm_time_ms ( ) { … } — function",
							"—Ⓕ– jsm_interrupt_handler ( ) { … } — function",
							"—Ⓕ– jsm_unlink_timer ( ) { … } — function",
							"—Ⓕ– jsm_free_timer ( ) { … } — function",
							"—Ⓕ– jsm_call_handler ( ) { … } — function",
							"—Ⓕ– jsm_sab_free ( ) { … } — function",
							"—Ⓕ– jsm_free_message ( ) { … } — function",
							"—Ⓕ– jsm_handle_posted_message ( ) { … } — function",
							"—Ⓕ– jsm_load_package_json ( ) { … } — function",
							"—Ⓕ– jsm_module_exports ( ) { … } — function",
							"—Ⓕ– jsm_module_find ( ) { … } — function",
							"—Ⓕ– jsm_module_get ( ) { … } — function",
							"—Ⓕ– jsm_module_list ( ) { … } — function",
							"—Ⓕ– jsm_dump_obj ( ) { … } — function",
							"—Ⓕ– jsm_std_dump_error1 ( ) { … } — function",
							"—Ⓕ– jsm_std_dump_error ( ) { … } — function",
							"—Ⓕ– jsm_find_module_ext ( ) { … } — function",
							"—Ⓕ– jsm_find_module ( ) { … } — function",
							"—Ⓕ– jsm_normalize_module ( ) { … } — function",
							"—Ⓕ– jsm_module_loader_so ( ) { … } — function",
							"—Ⓕ– jsm_module_loader_path ( ) { … } — function",
							"—Ⓕ– jsm_eval_binary ( ) { … } — function",
							"—Ⓕ– jsm_eval_buf ( ) { … } — function",
							"—Ⓕ– jsm_eval_str ( ) { … } — function",
							"—Ⓕ– jsm_eval_file ( ) { … } — function",
							"—Ⓕ– jsm_load_script ( ) { … } — function",
							"—Ⓕ– jsm_load_module ( ) { … } — function",
							"—Ⓕ– jsm_list_modules ( ) { … } — function",
							"—Ⓕ– jsm_context_new ( ) { … } — function",
							"—Ⓜ– jsm_module_native ( ) … — macro function",
							" Ⓜ  MALLOC_OVERHEAD … — macro object",
							" Ⓜ  MALLOC_OVERHEAD … — macro object",
							"—Ⓒ– trace_malloc_data { … } ; — type",
							"—Ⓕ– dump_vector ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_ptr_offset ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_usable_size ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_printf ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_init ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc ( ) { … } — function",
							"—Ⓕ– jsm_trace_free ( ) { … } — function",
							"—Ⓕ– jsm_trace_realloc ( ) { … } — function",
							" Ⓜ  PROG_NAME … — macro object",
							"—Ⓕ– jsm_help ( ) { … } — function",
							"—Ⓕ– js_eval_script ( ) { … } — function",
							"—Ⓕ– js_module_func ( ) { … } — function",
							"—Ⓕ– main ( ) { … } — function",
							"—Ⓜ– jsm_builtin_native ( ) … — macro function",
							"—Ⓜ– jsm_builtin_compiled ( ) … — macro function"
						]
					},
					"BAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAICDik4IgIF9HTlVfU09VUkNFIOKApiDigJQgbWFjcm8gb2JqZWN0CuKAlOKSu+KAkyBhdG9taWNfYWRkX2ludCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK44oCTIHBvbGxoYW5kbGVyIHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcG9sbGhhbmRsZXJfdCA7IOKAlCB0eXBlZGVmCiAg4pKhICBqc19zdGRfc2V0X21vZHVsZV9sb2FkZXJfZnVuYyAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIG1hbGxvY191c2FibGVfc2l6ZSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4oCU4pOC4oCTIHRyaW1fZG90c2xhc2ggKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIGpzbV9kZWNsYXJlX21vZHVsZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNfc3RkX3NldF93b3JrZXJfbmV3X2NvbnRleHRfZnVuYyAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIGpzbV9zdGRfZHVtcF9lcnJvciAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4oCU4pK74oCTIGpzbV90aW1lX21zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2ludGVycnVwdF9oYW5kbGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3VubGlua190aW1lciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9mcmVlX3RpbWVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2NhbGxfaGFuZGxlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9zYWJfZnJlZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9mcmVlX21lc3NhZ2UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21faGFuZGxlX3Bvc3RlZF9tZXNzYWdlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2xvYWRfcGFja2FnZV9qc29uICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9leHBvcnRzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9maW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9nZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fbW9kdWxlX2xpc3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fZHVtcF9vYmogKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fc3RkX2R1bXBfZXJyb3IxICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3N0ZF9kdW1wX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2ZpbmRfbW9kdWxlX2V4dCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9maW5kX21vZHVsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9ub3JtYWxpemVfbW9kdWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9sb2FkZXJfc28gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fbW9kdWxlX2xvYWRlcl9wYXRoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfYnVmICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfc3RyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfZmlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9sb2FkX3NjcmlwdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9sb2FkX21vZHVsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9saXN0X21vZHVsZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fY29udGV4dF9uZXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKTguKAkyBqc21fbW9kdWxlX25hdGl2ZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgogIOKTgiAgTUFMTE9DX09WRVJIRUFEIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBNQUxMT0NfT1ZFUkhFQUQg4oCmIOKAlCBtYWNybyBvYmplY3QK4oCU4pK44oCTIHRyYWNlX21hbGxvY19kYXRhIHsg4oCmIH0gOyDigJQgdHlwZQrigJTikrvigJMgZHVtcF92ZWN0b3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX3B0cl9vZmZzZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3RyYWNlX21hbGxvY19wcmludGYgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3RyYWNlX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfcmVhbGxvYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIFBST0dfTkFNRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTikrvigJMganNtX2hlbHAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ldmFsX3NjcmlwdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21vZHVsZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbWFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pOC4oCTIGpzbV9idWlsdGluX25hdGl2ZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTik4LigJMganNtX2J1aWx0aW5fY29tcGlsZWQgKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24AAAAAAAAAAMILAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAICDik4IgIF9HTlVfU09VUkNFIOKApiDigJQgbWFjcm8gb2JqZWN0CuKAlOKSu+KAkyBhdG9taWNfYWRkX2ludCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK44oCTIHBvbGxoYW5kbGVyIHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcG9sbGhhbmRsZXJfdCA7IOKAlCB0eXBlZGVmCiAg4pKhICBqc19zdGRfc2V0X21vZHVsZV9sb2FkZXJfZnVuYyAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIG1hbGxvY191c2FibGVfc2l6ZSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4oCU4pOC4oCTIHRyaW1fZG90c2xhc2ggKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIGpzbV9kZWNsYXJlX21vZHVsZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNfc3RkX3NldF93b3JrZXJfbmV3X2NvbnRleHRfZnVuYyAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIGpzbV9zdGRfZHVtcF9lcnJvciAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4oCU4pK74oCTIGpzbV90aW1lX21zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2ludGVycnVwdF9oYW5kbGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3VubGlua190aW1lciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9mcmVlX3RpbWVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2NhbGxfaGFuZGxlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9zYWJfZnJlZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9mcmVlX21lc3NhZ2UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21faGFuZGxlX3Bvc3RlZF9tZXNzYWdlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2xvYWRfcGFja2FnZV9qc29uICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9leHBvcnRzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9maW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9nZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fbW9kdWxlX2xpc3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fZHVtcF9vYmogKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fc3RkX2R1bXBfZXJyb3IxICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3N0ZF9kdW1wX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2ZpbmRfbW9kdWxlX2V4dCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9maW5kX21vZHVsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9ub3JtYWxpemVfbW9kdWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9sb2FkZXJfc28gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fbW9kdWxlX2xvYWRlcl9wYXRoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfYnVmICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfc3RyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfZmlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9sb2FkX3NjcmlwdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9sb2FkX21vZHVsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9saXN0X21vZHVsZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fY29udGV4dF9uZXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKTguKAkyBqc21fbW9kdWxlX25hdGl2ZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgogIOKTgiAgTUFMTE9DX09WRVJIRUFEIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBNQUxMT0NfT1ZFUkhFQUQg4oCmIOKAlCBtYWNybyBvYmplY3QK4oCU4pK44oCTIHRyYWNlX21hbGxvY19kYXRhIHsg4oCmIH0gOyDigJQgdHlwZQrigJTikrvigJMgZHVtcF92ZWN0b3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX3B0cl9vZmZzZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3RyYWNlX21hbGxvY19wcmludGYgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3RyYWNlX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfcmVhbGxvYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIFBST0dfTkFNRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTikrvigJMganNtX2hlbHAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ldmFsX3NjcmlwdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21vZHVsZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbWFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pOC4oCTIGpzbV9idWlsdGluX25hdGl2ZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTik4LigJMganNtX2J1aWx0aW5fY29tcGlsZWQgKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24AAAAAAAAAAMILAAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					422,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAADgAAICDik4IgIF9HTlVfU09VUkNFIOKApiDigJQgbWFjcm8gb2JqZWN0CuKAlOKSu+KAkyBhdG9taWNfYWRkX2ludCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK44oCTIHBvbGxoYW5kbGVyIHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcG9sbGhhbmRsZXJfdCA7IOKAlCB0eXBlZGVmCiAg4pKhICBqc19zdGRfc2V0X21vZHVsZV9sb2FkZXJfZnVuYyAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIG1hbGxvY191c2FibGVfc2l6ZSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4oCU4pOC4oCTIHRyaW1fZG90c2xhc2ggKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIGpzbV9kZWNsYXJlX21vZHVsZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNfc3RkX3NldF93b3JrZXJfbmV3X2NvbnRleHRfZnVuYyAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIGpzbV9zdGRfZHVtcF9lcnJvciAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4oCU4pK74oCTIGpzbV90aW1lX21zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2ludGVycnVwdF9oYW5kbGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3VubGlua190aW1lciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9mcmVlX3RpbWVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2NhbGxfaGFuZGxlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9zYWJfZnJlZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9mcmVlX21lc3NhZ2UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21faGFuZGxlX3Bvc3RlZF9tZXNzYWdlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2xvYWRfcGFja2FnZV9qc29uICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9leHBvcnRzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9maW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9nZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fbW9kdWxlX2xpc3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fZHVtcF9vYmogKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fc3RkX2R1bXBfZXJyb3IxICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3N0ZF9kdW1wX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2ZpbmRfbW9kdWxlX2V4dCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9maW5kX21vZHVsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9ub3JtYWxpemVfbW9kdWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9sb2FkZXJfc28gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fbW9kdWxlX2xvYWRlcl9wYXRoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfYnVmICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfc3RyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfZmlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9sb2FkX3NjcmlwdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9sb2FkX21vZHVsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9saXN0X21vZHVsZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fY29udGV4dF9uZXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKTguKAkyBqc21fbW9kdWxlX25hdGl2ZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgogIOKTgiAgTUFMTE9DX09WRVJIRUFEIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBNQUxMT0NfT1ZFUkhFQUQg4oCmIOKAlCBtYWNybyBvYmplY3QK4oCU4pK44oCTIHRyYWNlX21hbGxvY19kYXRhIHsg4oCmIH0gOyDigJQgdHlwZQrigJTikrvigJMgZHVtcF92ZWN0b3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX3B0cl9vZmZzZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3RyYWNlX21hbGxvY19wcmludGYgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3RyYWNlX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfcmVhbGxvYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIFBST0dfTkFNRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTikrvigJMganNtX2hlbHAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ldmFsX3NjcmlwdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21vZHVsZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbWFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pOC4oCTIGpzbV9idWlsdGluX25hdGl2ZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTik4LigJMganNtX2J1aWx0aW5fY29tcGlsZWQgKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					423,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/qjsm.c",
						"symkeys":
						[
							[
								28,
								39
							],
							[
								1755,
								1769
							],
							[
								2033,
								2044
							],
							[
								2159,
								2172
							],
							[
								2259,
								2288
							],
							[
								2405,
								2423
							],
							[
								2450,
								2463
							],
							[
								2525,
								2543
							],
							[
								2944,
								2962
							],
							[
								2973,
								2991
							],
							[
								3001,
								3019
							],
							[
								3025,
								3043
							],
							[
								3057,
								3075
							],
							[
								3086,
								3104
							],
							[
								3112,
								3130
							],
							[
								3141,
								3159
							],
							[
								3166,
								3184
							],
							[
								3214,
								3232
							],
							[
								3283,
								3317
							],
							[
								3360,
								3378
							],
							[
								3628,
								3639
							],
							[
								3778,
								3799
							],
							[
								3885,
								3901
							],
							[
								4035,
								4049
							],
							[
								4144,
								4160
							],
							[
								4555,
								4567
							],
							[
								4820,
								4836
							],
							[
								5100,
								5125
							],
							[
								6753,
								6774
							],
							[
								7166,
								7184
							],
							[
								7641,
								7656
							],
							[
								8203,
								8217
							],
							[
								8546,
								8561
							],
							[
								9105,
								9117
							],
							[
								9349,
								9368
							],
							[
								9727,
								9745
							],
							[
								10170,
								10189
							],
							[
								10986,
								11001
							],
							[
								11440,
								11460
							],
							[
								12591,
								12611
							],
							[
								13784,
								13806
							],
							[
								16033,
								16048
							],
							[
								16585,
								16597
							],
							[
								17323,
								17335
							],
							[
								17582,
								17595
							],
							[
								18256,
								18271
							],
							[
								18751,
								18766
							],
							[
								19107,
								19123
							],
							[
								19466,
								19481
							],
							[
								19772,
								19789
							],
							[
								20286,
								20301
							],
							[
								20318,
								20333
							],
							[
								20351,
								20368
							],
							[
								20404,
								20415
							],
							[
								20758,
								20785
							],
							[
								20946,
								20974
							],
							[
								21570,
								21593
							],
							[
								22281,
								22302
							],
							[
								22379,
								22395
							],
							[
								22828,
								22842
							],
							[
								23066,
								23083
							],
							[
								24380,
								24389
							],
							[
								24403,
								24411
							],
							[
								25512,
								25526
							],
							[
								26741,
								26755
							],
							[
								30588,
								30592
							],
							[
								36387,
								36405
							],
							[
								37022,
								37042
							]
						],
						"symlist":
						[
							" Ⓜ  _GNU_SOURCE … — macro object",
							"—Ⓕ– atomic_add_int ( ) { … } — function",
							"—Ⓒ– pollhandler { … } ; — type",
							" Ⓣ  pollhandler_t ; — typedef",
							" ⒡  js_std_set_module_loader_func ( ) ; — function declaration",
							" ⒡  malloc_usable_size ( ) ; — function declaration",
							"—Ⓜ– trim_dotslash ( ) … — macro function",
							"—Ⓜ– jsm_declare_module ( ) … — macro function",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  js_std_set_worker_new_context_func ( ) ; — function declaration",
							" ⒡  jsm_std_dump_error ( ) ; — function declaration",
							"—Ⓕ– jsm_time_ms ( ) { … } — function",
							"—Ⓕ– jsm_interrupt_handler ( ) { … } — function",
							"—Ⓕ– jsm_unlink_timer ( ) { … } — function",
							"—Ⓕ– jsm_free_timer ( ) { … } — function",
							"—Ⓕ– jsm_call_handler ( ) { … } — function",
							"—Ⓕ– jsm_sab_free ( ) { … } — function",
							"—Ⓕ– jsm_free_message ( ) { … } — function",
							"—Ⓕ– jsm_handle_posted_message ( ) { … } — function",
							"—Ⓕ– jsm_load_package_json ( ) { … } — function",
							"—Ⓕ– jsm_module_exports ( ) { … } — function",
							"—Ⓕ– jsm_module_find ( ) { … } — function",
							"—Ⓕ– jsm_module_get ( ) { … } — function",
							"—Ⓕ– jsm_module_list ( ) { … } — function",
							"—Ⓕ– jsm_dump_obj ( ) { … } — function",
							"—Ⓕ– jsm_std_dump_error1 ( ) { … } — function",
							"—Ⓕ– jsm_std_dump_error ( ) { … } — function",
							"—Ⓕ– jsm_find_module_ext ( ) { … } — function",
							"—Ⓕ– jsm_find_module ( ) { … } — function",
							"—Ⓕ– jsm_normalize_module ( ) { … } — function",
							"—Ⓕ– jsm_module_loader_so ( ) { … } — function",
							"—Ⓕ– jsm_module_loader_path ( ) { … } — function",
							"—Ⓕ– jsm_eval_binary ( ) { … } — function",
							"—Ⓕ– jsm_eval_buf ( ) { … } — function",
							"—Ⓕ– jsm_eval_str ( ) { … } — function",
							"—Ⓕ– jsm_eval_file ( ) { … } — function",
							"—Ⓕ– jsm_load_script ( ) { … } — function",
							"—Ⓕ– jsm_load_module ( ) { … } — function",
							"—Ⓕ– jsm_list_modules ( ) { … } — function",
							"—Ⓕ– jsm_context_new ( ) { … } — function",
							"—Ⓜ– jsm_module_native ( ) … — macro function",
							" Ⓜ  MALLOC_OVERHEAD … — macro object",
							" Ⓜ  MALLOC_OVERHEAD … — macro object",
							"—Ⓒ– trace_malloc_data { … } ; — type",
							"—Ⓕ– dump_vector ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_ptr_offset ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_usable_size ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_printf ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_init ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc ( ) { … } — function",
							"—Ⓕ– jsm_trace_free ( ) { … } — function",
							"—Ⓕ– jsm_trace_realloc ( ) { … } — function",
							" Ⓜ  PROG_NAME … — macro object",
							"—Ⓕ– jsm_help ( ) { … } — function",
							"—Ⓕ– js_eval_script ( ) { … } — function",
							"—Ⓕ– js_module_func ( ) { … } — function",
							"—Ⓕ– main ( ) { … } — function",
							"—Ⓜ– jsm_builtin_native ( ) … — macro function",
							"—Ⓜ– jsm_builtin_compiled ( ) … — macro function"
						]
					},
					"AQAAAAAAAAAAAAAAwgsAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					424,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAADgAAICDik4IgIF9HTlVfU09VUkNFIOKApiDigJQgbWFjcm8gb2JqZWN0CuKAlOKSu+KAkyBhdG9taWNfYWRkX2ludCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK44oCTIHBvbGxoYW5kbGVyIHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcG9sbGhhbmRsZXJfdCA7IOKAlCB0eXBlZGVmCiAg4pKhICBqc19zdGRfc2V0X21vZHVsZV9sb2FkZXJfZnVuYyAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIG1hbGxvY191c2FibGVfc2l6ZSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4oCU4pOC4oCTIHRyaW1fZG90c2xhc2ggKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIGpzbV9kZWNsYXJlX21vZHVsZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNfc3RkX3NldF93b3JrZXJfbmV3X2NvbnRleHRfZnVuYyAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIGpzbV9zdGRfZHVtcF9lcnJvciAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4oCU4pK74oCTIGpzbV90aW1lX21zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2ludGVycnVwdF9oYW5kbGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3VubGlua190aW1lciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9mcmVlX3RpbWVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2NhbGxfaGFuZGxlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9zYWJfZnJlZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9mcmVlX21lc3NhZ2UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21faGFuZGxlX3Bvc3RlZF9tZXNzYWdlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2xvYWRfcGFja2FnZV9qc29uICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9leHBvcnRzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9maW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9nZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fbW9kdWxlX2xpc3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fZHVtcF9vYmogKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fc3RkX2R1bXBfZXJyb3IxICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3N0ZF9kdW1wX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2ZpbmRfbW9kdWxlX2V4dCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9maW5kX21vZHVsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9ub3JtYWxpemVfbW9kdWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9sb2FkZXJfc28gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fbW9kdWxlX2xvYWRlcl9wYXRoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfYnVmICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfc3RyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfZmlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9sb2FkX3NjcmlwdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9sb2FkX21vZHVsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9saXN0X21vZHVsZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fY29udGV4dF9uZXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKTguKAkyBqc21fbW9kdWxlX25hdGl2ZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgogIOKTgiAgTUFMTE9DX09WRVJIRUFEIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBNQUxMT0NfT1ZFUkhFQUQg4oCmIOKAlCBtYWNybyBvYmplY3QK4oCU4pK44oCTIHRyYWNlX21hbGxvY19kYXRhIHsg4oCmIH0gOyDigJQgdHlwZQrigJTikrvigJMgZHVtcF92ZWN0b3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX3B0cl9vZmZzZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3RyYWNlX21hbGxvY19wcmludGYgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3RyYWNlX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfcmVhbGxvYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIFBST0dfTkFNRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTikrvigJMganNtX2hlbHAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ldmFsX3NjcmlwdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21vZHVsZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbWFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pOC4oCTIGpzbV9idWlsdGluX25hdGl2ZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTik4LigJMganNtX2J1aWx0aW5fY29tcGlsZWQgKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					425,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_blob.js",
						"symkeys":
						[
							[
								180,
								202
							]
						],
						"symlist":
						[
							"function main(...args)"
						]
					},
					"AQAAAAAAAAAAAAAADwAAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					426,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
						"symkeys":
						[
							[
								28,
								39
							],
							[
								323,
								326
							],
							[
								365,
								368
							],
							[
								751,
								770
							],
							[
								798,
								812
							],
							[
								924,
								938
							],
							[
								1247,
								1259
							],
							[
								1323,
								1339
							],
							[
								1407,
								1440
							],
							[
								3982,
								3991
							],
							[
								4105,
								4115
							],
							[
								4290,
								4311
							],
							[
								4392,
								4411
							],
							[
								4543,
								4567
							],
							[
								4711,
								4728
							],
							[
								5630,
								5642
							],
							[
								5659,
								5679
							],
							[
								5826,
								5853
							],
							[
								7166,
								7185
							],
							[
								8088,
								8109
							],
							[
								8255,
								8275
							],
							[
								8781,
								8803
							],
							[
								9286,
								9309
							],
							[
								10232,
								10251
							],
							[
								11848,
								11873
							],
							[
								12213,
								12229
							],
							[
								12879,
								12896
							],
							[
								13428,
								13449
							],
							[
								14311,
								14333
							],
							[
								15002,
								15027
							],
							[
								15797,
								15822
							],
							[
								16496,
								16525
							],
							[
								16764,
								16780
							],
							[
								17704,
								17720
							],
							[
								18810,
								18835
							],
							[
								19251,
								19265
							],
							[
								20073,
								20088
							],
							[
								20559,
								20572
							],
							[
								21166,
								21178
							],
							[
								21585,
								21597
							],
							[
								22013,
								22033
							],
							[
								22763,
								22783
							],
							[
								23122,
								23141
							],
							[
								23361,
								23373
							],
							[
								25277,
								25294
							],
							[
								25892,
								25910
							],
							[
								27002,
								27022
							],
							[
								27483,
								27504
							],
							[
								27978,
								27993
							],
							[
								28561,
								28581
							],
							[
								29033,
								29045
							],
							[
								29751,
								29766
							],
							[
								31269,
								31294
							],
							[
								31833,
								31858
							],
							[
								33036,
								33050
							],
							[
								33827,
								33841
							],
							[
								38049,
								38061
							],
							[
								39363,
								39377
							],
							[
								39407,
								39421
							]
						],
						"symlist":
						[
							" Ⓜ  _GNU_SOURCE … — macro object",
							"—Ⓜ– max ( ) … — macro function",
							"—Ⓜ– min ( ) … — macro function",
							"—Ⓒ– pcg_state_setseq_64 { … } ; — type",
							" Ⓣ  pcg32_random_t ; — typedef",
							"—Ⓕ– pcg32_random_r ( ) { … } — function",
							"—Ⓕ– pcg32_random ( ) { … } — function",
							"—Ⓕ– pcg32_init_state ( ) { … } — function",
							"—Ⓕ– pcg32_random_bounded_divisionless ( ) { … } — function",
							"—Ⓕ– get_error ( ) { … } — function",
							"—Ⓕ– find_error ( ) { … } — function",
							"—Ⓕ– js_bytecode_free_func ( ) { … } — function",
							"—Ⓕ– js_string_free_func ( ) { … } — function",
							"—Ⓕ– js_arraybuffer_free_func ( ) { … } — function",
							"—Ⓕ– get_offset_length ( ) { … } — function",
							" Ⓣ  SyscallError ; — typedef",
							"—Ⓕ– js_syscallerror_data ( ) { … } — function",
							"—Ⓕ– js_syscallerror_constructor ( ) { … } — function",
							"—Ⓕ– js_syscallerror_new ( ) { … } — function",
							"—Ⓕ– js_syscallerror_throw ( ) { … } — function",
							"—Ⓕ– js_syscallerror_dump ( ) { … } — function",
							"—Ⓕ– js_syscallerror_method ( ) { … } — function",
							"—Ⓕ– js_syscallerror_inspect ( ) { … } — function",
							"—Ⓕ– js_syscallerror_get ( ) { … } — function",
							"—Ⓕ– js_syscallerror_finalizer ( ) { … } — function",
							"—Ⓕ– js_misc_tostring ( ) { … } — function",
							"—Ⓕ– js_misc_topointer ( ) { … } — function",
							"—Ⓕ– js_misc_toarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_duparraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_resizearraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_concatarraybuffer ( ) { … } — function",
							"—Ⓕ– js_misc_getperformancecounter ( ) { … } — function",
							"—Ⓕ– js_misc_proclink ( ) { … } — function",
							"—Ⓕ– js_misc_procread ( ) { … } — function",
							"—Ⓕ– js_misc_getprototypechain ( ) { … } — function",
							"—Ⓕ– js_misc_hrtime ( ) { … } — function",
							"—Ⓕ– js_misc_fnmatch ( ) { … } — function",
							"—Ⓕ– js_misc_uname ( ) { … } — function",
							"—Ⓕ– js_misc_btoa ( ) { … } — function",
							"—Ⓕ– js_misc_atob ( ) { … } — function",
							"—Ⓕ– js_misc_compile_file ( ) { … } — function",
							"—Ⓕ– js_misc_write_object ( ) { … } — function",
							"—Ⓕ– js_misc_read_object ( ) { … } — function",
							"—Ⓕ– js_misc_getx ( ) { … } — function",
							"—Ⓕ– js_misc_valuetype ( ) { … } — function",
							"—Ⓕ– js_misc_evalbinary ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_array ( ) { … } — function",
							"—Ⓕ– js_misc_opcode_object ( ) { … } — function",
							"—Ⓕ– js_misc_opcodes ( ) { … } — function",
							"—Ⓕ– js_misc_get_bytecode ( ) { … } — function",
							"—Ⓕ– js_misc_atom ( ) { … } — function",
							"—Ⓕ– js_misc_classid ( ) { … } — function",
							"—Ⓕ– js_misc_bitfield_to_array ( ) { … } — function",
							"—Ⓕ– js_misc_array_to_bitfield ( ) { … } — function",
							"—Ⓕ– js_misc_random ( ) { … } — function",
							"—Ⓕ– js_misc_escape ( ) { … } — function",
							"—Ⓕ– js_misc_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAPAAAAICBtYWluKC4uLmFyZ3MpAAAAAAAAAADwCQAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					427,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/CMakeLists.txt",
						"symkeys":
						[
							[
								67,
								91
							],
							[
								126,
								150
							],
							[
								187,
								211
							],
							[
								250,
								274
							],
							[
								462,
								486
							],
							[
								512,
								536
							],
							[
								603,
								619
							],
							[
								652,
								665
							],
							[
								709,
								729
							],
							[
								805,
								827
							],
							[
								865,
								881
							],
							[
								975,
								999
							],
							[
								1042,
								1066
							],
							[
								1158,
								1182
							],
							[
								1284,
								1299
							],
							[
								1469,
								1478
							],
							[
								1489,
								1503
							],
							[
								1506,
								1514
							],
							[
								1518,
								1527
							],
							[
								1542,
								1554
							],
							[
								1649,
								1670
							],
							[
								1759,
								1771
							],
							[
								1806,
								1818
							],
							[
								1924,
								1936
							],
							[
								2060,
								2075
							],
							[
								2112,
								2124
							],
							[
								2210,
								2229
							],
							[
								2320,
								2332
							],
							[
								2339,
								2350
							],
							[
								2433,
								2445
							],
							[
								2462,
								2474
							],
							[
								2491,
								2503
							],
							[
								2510,
								2527
							],
							[
								2572,
								2584
							],
							[
								2591,
								2606
							],
							[
								2629,
								2641
							],
							[
								2648,
								2661
							],
							[
								2702,
								2714
							],
							[
								2814,
								2826
							],
							[
								2829,
								2841
							],
							[
								2848,
								2864
							],
							[
								2867,
								2879
							],
							[
								2886,
								2902
							],
							[
								3005,
								3017
							],
							[
								3038,
								3050
							],
							[
								3057,
								3078
							],
							[
								3181,
								3193
							],
							[
								3200,
								3212
							],
							[
								3288,
								3304
							],
							[
								3308,
								3329
							],
							[
								3336,
								3348
							],
							[
								3389,
								3403
							],
							[
								3406,
								3420
							],
							[
								3468,
								3491
							],
							[
								3498,
								3515
							],
							[
								3518,
								3538
							],
							[
								3546,
								3564
							],
							[
								3567,
								3583
							],
							[
								3774,
								3788
							],
							[
								3797,
								3817
							],
							[
								4222,
								4241
							],
							[
								4269,
								4288
							],
							[
								4292,
								4311
							],
							[
								4386,
								4405
							],
							[
								4516,
								4535
							],
							[
								4565,
								4584
							],
							[
								4588,
								4607
							],
							[
								4684,
								4703
							],
							[
								4823,
								4842
							],
							[
								4874,
								4893
							],
							[
								4897,
								4916
							],
							[
								4995,
								5014
							],
							[
								5161,
								5181
							],
							[
								5389,
								5406
							],
							[
								5578,
								5602
							],
							[
								5607,
								5612
							],
							[
								5664,
								5669
							],
							[
								5693,
								5697
							],
							[
								5739,
								5743
							],
							[
								5775,
								5779
							],
							[
								5838,
								5862
							],
							[
								5866,
								5890
							],
							[
								5903,
								5906
							],
							[
								5921,
								5925
							],
							[
								5955,
								5979
							],
							[
								6015,
								6019
							],
							[
								6082,
								6106
							],
							[
								6110,
								6134
							],
							[
								6147,
								6151
							],
							[
								6181,
								6185
							],
							[
								6193,
								6197
							],
							[
								6211,
								6235
							],
							[
								6239,
								6243
							],
							[
								6273,
								6297
							],
							[
								6317,
								6321
							],
							[
								6345,
								6350
							],
							[
								6782,
								6797
							],
							[
								6837,
								6851
							],
							[
								6901,
								6912
							],
							[
								6916,
								6940
							],
							[
								6965,
								6980
							],
							[
								6999,
								7008
							],
							[
								7057,
								7066
							],
							[
								7098,
								7109
							],
							[
								7138,
								7153
							],
							[
								7454,
								7467
							],
							[
								7509,
								7522
							],
							[
								7561,
								7585
							],
							[
								7591,
								7602
							],
							[
								7629,
								7640
							],
							[
								7666,
								7675
							],
							[
								7703,
								7714
							],
							[
								7749,
								7773
							],
							[
								7803,
								7816
							],
							[
								7839,
								7863
							],
							[
								7953,
								7958
							],
							[
								7975,
								7994
							],
							[
								8011,
								8022
							],
							[
								8141,
								8152
							],
							[
								8327,
								8338
							],
							[
								8409,
								8419
							],
							[
								8449,
								8460
							],
							[
								8476,
								8500
							],
							[
								8523,
								8543
							],
							[
								8546,
								8570
							],
							[
								8589,
								8609
							],
							[
								8635,
								8655
							],
							[
								8722,
								8733
							],
							[
								8759,
								8763
							],
							[
								8782,
								8793
							],
							[
								8822,
								8846
							],
							[
								8876,
								8885
							],
							[
								8911,
								8935
							],
							[
								9017,
								9041
							],
							[
								9065,
								9077
							],
							[
								9114,
								9125
							],
							[
								9142,
								9153
							],
							[
								9173,
								9184
							],
							[
								9204,
								9215
							],
							[
								9234,
								9245
							],
							[
								9265,
								9276
							],
							[
								9291,
								9302
							],
							[
								9325,
								9336
							],
							[
								9356,
								9367
							],
							[
								9383,
								9394
							],
							[
								9411,
								9429
							],
							[
								9447,
								9471
							],
							[
								9531,
								9543
							],
							[
								9556,
								9568
							],
							[
								9582,
								9606
							],
							[
								9642,
								9666
							],
							[
								9700,
								9718
							],
							[
								9775,
								9799
							],
							[
								9870,
								9882
							],
							[
								9968,
								9986
							],
							[
								10207,
								10218
							],
							[
								10248,
								10272
							],
							[
								10314,
								10324
							],
							[
								10328,
								10338
							],
							[
								10342,
								10346
							],
							[
								10374,
								10379
							],
							[
								10383,
								10392
							],
							[
								10456,
								10467
							],
							[
								10518,
								10540
							],
							[
								10622,
								10637
							],
							[
								10688,
								10710
							],
							[
								10786,
								10810
							]
						],
						"symlist":
						[
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"CMAKE_C_COMPILER",
							"CMAKE_SYSROOT",
							"CMAKE_TOOLCHAIN_FILE",
							"CMAKE_VERBOSE_MAKEFILE",
							"CMAKE_BUILD_TYPE",
							"CMAKE_CURRENT_BINARY_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QUICKJS_MODULES",
							"QUICKJS_H",
							"COMMON_HEADERS",
							"CUTILS_H",
							"QUICKJS_H",
							"util_SOURCES",
							"child_process_SOURCES",
							"util_SOURCES",
							"deep_SOURCES",
							"util_SOURCES",
							"inspect_SOURCES",
							"util_SOURCES",
							"tree_walker_SOURCES",
							"util_SOURCES",
							"xml_SOURCES",
							"util_SOURCES",
							"path_SOURCES",
							"util_SOURCES",
							"predicate_SOURCES",
							"util_SOURCES",
							"pointer_SOURCES",
							"util_SOURCES",
							"lexer_SOURCES",
							"util_SOURCES",
							"mmap_SOURCES",
							"util_SOURCES",
							"repeater_SOURCES",
							"util_SOURCES",
							"location_SOURCES",
							"blob_SOURCES",
							"util_SOURCES",
							"stringdecoder_SOURCES",
							"util_SOURCES",
							"misc_SOURCES",
							"location_SOURCES",
							"stringdecoder_SOURCES",
							"gpio_SOURCES",
							"gpio_LIBRARIES",
							"pigpio_LIBRARY",
							"LibArchive_INCLUDE_DIRS",
							"archive_LIBRARIES",
							"LibArchive_LIBRARIES",
							"QJSM_EXTRA_SOURCES",
							"location_SOURCES",
							"QUICKJS_PREFIX",
							"CMAKE_REQUIRED_QUIET",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_REQUIRED_QUIET",
							"HAVE_POSIX_SPAWNP",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TESTS",
							"TESTS",
							"TEST",
							"BASE",
							"BASE",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QJS",
							"TEST",
							"CMAKE_CURRENT_SOURCE_DIR",
							"BASE",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QJSC",
							"NAME",
							"BASE",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TEST",
							"CMAKE_CURRENT_BINARY_DIR",
							"TEST",
							"TESTS",
							"QUICKJS_MODULES",
							"SHARED_TARGETS",
							"QJSM_LIBDIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QUICKJS_MODULES",
							"JS_MODULE",
							"JS_MODULE",
							"QJSM_MODULE",
							"QUICKJS_MODULES",
							"TESTS_SOURCES",
							"TESTS_SOURCES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TEST_SOURCE",
							"TEST_SOURCE",
							"TEST_NAME",
							"TEST_SOURCE",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TESTS_SOURCES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"LIBJS",
							"QUICKJS_LIBRARY_DIR",
							"LIB_MODULES",
							"LIB_MODULES",
							"LIB_MODULES",
							"LIB_MODULE",
							"LIB_MODULES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QUICKJS_SOURCES_ROOT",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QUICKJS_SOURCES_ROOT",
							"QUICKJS_SOURCES_ROOT",
							"MODULES_DIR",
							"QJSC",
							"MODULES_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QJSC_DEPS",
							"CMAKE_CURRENT_BINARY_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QJSM_SOURCES",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"QJSM_EXTRA_SOURCES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QJSM_SOURCES",
							"QJSM_SOURCES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TRANSPORT_PLATFORM",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QJSM_SOURCES",
							"QJS_MODULES_STATIC",
							"QJSM_LIBDIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QJSM_LDADD",
							"LIBPTHREAD",
							"LIBM",
							"LIBDL",
							"LIBWS2_32",
							"LINK_EXPORT",
							"QUICKJS_INSTALL_PREFIX",
							"QUICKJS_VERSION",
							"QUICKJS_INSTALL_PREFIX",
							"CMAKE_CURRENT_SOURCE_DIR"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAmDAAAICDik4IgIF9HTlVfU09VUkNFIOKApiDigJQgbWFjcm8gb2JqZWN0CuKAlOKTguKAkyBtYXggKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIG1pbiAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTikrjigJMgcGNnX3N0YXRlX3NldHNlcV82NCB7IOKApiB9IDsg4oCUIHR5cGUKICDik4kgIHBjZzMyX3JhbmRvbV90IDsg4oCUIHR5cGVkZWYK4oCU4pK74oCTIHBjZzMyX3JhbmRvbV9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcGNnMzJfcmFuZG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgcGNnMzJfaW5pdF9zdGF0ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHBjZzMyX3JhbmRvbV9ib3VuZGVkX2RpdmlzaW9ubGVzcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGdldF9lcnJvciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGZpbmRfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ieXRlY29kZV9mcmVlX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdHJpbmdfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfYXJyYXlidWZmZXJfZnJlZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgZ2V0X29mZnNldF9sZW5ndGggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCiAg4pOJICBTeXNjYWxsRXJyb3IgOyDigJQgdHlwZWRlZgrigJTikrvigJMganNfc3lzY2FsbGVycm9yX2RhdGEgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zeXNjYWxsZXJyb3JfY29uc3RydWN0b3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zeXNjYWxsZXJyb3JfbmV3ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3lzY2FsbGVycm9yX3Rocm93ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3lzY2FsbGVycm9yX2R1bXAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zeXNjYWxsZXJyb3JfbWV0aG9kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3lzY2FsbGVycm9yX2luc3BlY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zeXNjYWxsZXJyb3JfZ2V0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3lzY2FsbGVycm9yX2ZpbmFsaXplciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9zdHJpbmcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3RvcG9pbnRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfdG9hcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZHVwYXJyYXlidWZmZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3Jlc2l6ZWFycmF5YnVmZmVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb25jYXRhcnJheWJ1ZmZlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZ2V0cGVyZm9ybWFuY2Vjb3VudGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19wcm9jbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcHJvY3JlYWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHByb3RvdHlwZWNoYWluICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19ocnRpbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2ZubWF0Y2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3VuYW1lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19idG9hICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hdG9iICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19jb21waWxlX2ZpbGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3dyaXRlX29iamVjdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmVhZF9vYmplY3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2dldHggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX3ZhbHVldHlwZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfZXZhbGJpbmFyeSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2Nfb3Bjb2RlX2FycmF5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19vcGNvZGVfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19vcGNvZGVzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19nZXRfYnl0ZWNvZGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2F0b20gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2NsYXNzaWQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2JpdGZpZWxkX3RvX2FycmF5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19hcnJheV90b19iaXRmaWVsZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21pc2NfcmFuZG9tICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbWlzY19lc2NhcGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19taXNjX2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCiAg4pOCICBKU19JTklUX01PRFVMRSDigKYg4oCUIG1hY3JvIG9iamVjdAogIOKTgiAgSlNfSU5JVF9NT0RVTEUg4oCmIOKAlCBtYWNybyBvYmplY3QAAAAAAAAAAMAKAAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					428,
					2,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/CMakeLists.txt",
						"symkeys":
						[
							[
								67,
								91
							],
							[
								126,
								150
							],
							[
								187,
								211
							],
							[
								250,
								274
							],
							[
								462,
								486
							],
							[
								512,
								536
							],
							[
								603,
								619
							],
							[
								652,
								665
							],
							[
								709,
								729
							],
							[
								805,
								827
							],
							[
								865,
								881
							],
							[
								975,
								999
							],
							[
								1042,
								1066
							],
							[
								1158,
								1182
							],
							[
								1284,
								1299
							],
							[
								1469,
								1478
							],
							[
								1489,
								1503
							],
							[
								1506,
								1514
							],
							[
								1518,
								1527
							],
							[
								1542,
								1554
							],
							[
								1649,
								1670
							],
							[
								1759,
								1771
							],
							[
								1806,
								1818
							],
							[
								1924,
								1936
							],
							[
								2060,
								2075
							],
							[
								2112,
								2124
							],
							[
								2210,
								2229
							],
							[
								2320,
								2332
							],
							[
								2339,
								2350
							],
							[
								2433,
								2445
							],
							[
								2462,
								2474
							],
							[
								2491,
								2503
							],
							[
								2510,
								2527
							],
							[
								2572,
								2584
							],
							[
								2591,
								2606
							],
							[
								2629,
								2641
							],
							[
								2648,
								2661
							],
							[
								2702,
								2714
							],
							[
								2814,
								2826
							],
							[
								2829,
								2841
							],
							[
								2848,
								2864
							],
							[
								2867,
								2879
							],
							[
								2886,
								2902
							],
							[
								3005,
								3017
							],
							[
								3038,
								3050
							],
							[
								3057,
								3078
							],
							[
								3181,
								3193
							],
							[
								3200,
								3212
							],
							[
								3288,
								3304
							],
							[
								3311,
								3323
							],
							[
								3364,
								3378
							],
							[
								3381,
								3395
							],
							[
								3443,
								3466
							],
							[
								3473,
								3490
							],
							[
								3493,
								3513
							],
							[
								3521,
								3539
							],
							[
								3542,
								3558
							],
							[
								3749,
								3763
							],
							[
								3772,
								3792
							],
							[
								4197,
								4216
							],
							[
								4244,
								4263
							],
							[
								4267,
								4286
							],
							[
								4361,
								4380
							],
							[
								4491,
								4510
							],
							[
								4540,
								4559
							],
							[
								4563,
								4582
							],
							[
								4659,
								4678
							],
							[
								4798,
								4817
							],
							[
								4849,
								4868
							],
							[
								4872,
								4891
							],
							[
								4970,
								4989
							],
							[
								5136,
								5156
							],
							[
								5364,
								5381
							],
							[
								5553,
								5577
							],
							[
								5582,
								5587
							],
							[
								5639,
								5644
							],
							[
								5668,
								5672
							],
							[
								5714,
								5718
							],
							[
								5750,
								5754
							],
							[
								5813,
								5837
							],
							[
								5841,
								5865
							],
							[
								5878,
								5881
							],
							[
								5896,
								5900
							],
							[
								5930,
								5954
							],
							[
								5990,
								5994
							],
							[
								6057,
								6081
							],
							[
								6085,
								6109
							],
							[
								6122,
								6126
							],
							[
								6156,
								6160
							],
							[
								6168,
								6172
							],
							[
								6186,
								6210
							],
							[
								6214,
								6218
							],
							[
								6248,
								6272
							],
							[
								6292,
								6296
							],
							[
								6320,
								6325
							],
							[
								6757,
								6772
							],
							[
								6812,
								6826
							],
							[
								6876,
								6887
							],
							[
								6891,
								6915
							],
							[
								6940,
								6955
							],
							[
								6974,
								6983
							],
							[
								7032,
								7041
							],
							[
								7073,
								7084
							],
							[
								7113,
								7128
							],
							[
								7429,
								7442
							],
							[
								7484,
								7497
							],
							[
								7536,
								7560
							],
							[
								7566,
								7577
							],
							[
								7604,
								7615
							],
							[
								7641,
								7650
							],
							[
								7678,
								7689
							],
							[
								7724,
								7748
							],
							[
								7778,
								7791
							],
							[
								7814,
								7838
							],
							[
								7928,
								7933
							],
							[
								7950,
								7969
							],
							[
								7986,
								7997
							],
							[
								8116,
								8127
							],
							[
								8302,
								8313
							],
							[
								8384,
								8394
							],
							[
								8424,
								8435
							],
							[
								8451,
								8475
							],
							[
								8498,
								8518
							],
							[
								8521,
								8545
							],
							[
								8564,
								8584
							],
							[
								8610,
								8630
							],
							[
								8697,
								8708
							],
							[
								8734,
								8738
							],
							[
								8757,
								8768
							],
							[
								8797,
								8821
							],
							[
								8851,
								8860
							],
							[
								8886,
								8910
							],
							[
								8992,
								9016
							],
							[
								9040,
								9052
							],
							[
								9089,
								9100
							],
							[
								9117,
								9128
							],
							[
								9148,
								9159
							],
							[
								9179,
								9190
							],
							[
								9209,
								9220
							],
							[
								9240,
								9251
							],
							[
								9266,
								9277
							],
							[
								9300,
								9311
							],
							[
								9331,
								9342
							],
							[
								9358,
								9369
							],
							[
								9386,
								9404
							],
							[
								9422,
								9446
							],
							[
								9506,
								9518
							],
							[
								9531,
								9543
							],
							[
								9557,
								9581
							],
							[
								9617,
								9641
							],
							[
								9675,
								9693
							],
							[
								9750,
								9774
							],
							[
								9845,
								9857
							],
							[
								9943,
								9961
							],
							[
								10182,
								10193
							],
							[
								10223,
								10247
							],
							[
								10289,
								10299
							],
							[
								10303,
								10313
							],
							[
								10317,
								10321
							],
							[
								10349,
								10354
							],
							[
								10358,
								10367
							],
							[
								10431,
								10442
							],
							[
								10493,
								10515
							],
							[
								10597,
								10612
							],
							[
								10663,
								10685
							],
							[
								10761,
								10785
							]
						],
						"symlist":
						[
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"CMAKE_C_COMPILER",
							"CMAKE_SYSROOT",
							"CMAKE_TOOLCHAIN_FILE",
							"CMAKE_VERBOSE_MAKEFILE",
							"CMAKE_BUILD_TYPE",
							"CMAKE_CURRENT_BINARY_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QUICKJS_MODULES",
							"QUICKJS_H",
							"COMMON_HEADERS",
							"CUTILS_H",
							"QUICKJS_H",
							"util_SOURCES",
							"child_process_SOURCES",
							"util_SOURCES",
							"deep_SOURCES",
							"util_SOURCES",
							"inspect_SOURCES",
							"util_SOURCES",
							"tree_walker_SOURCES",
							"util_SOURCES",
							"xml_SOURCES",
							"util_SOURCES",
							"path_SOURCES",
							"util_SOURCES",
							"predicate_SOURCES",
							"util_SOURCES",
							"pointer_SOURCES",
							"util_SOURCES",
							"lexer_SOURCES",
							"util_SOURCES",
							"mmap_SOURCES",
							"util_SOURCES",
							"repeater_SOURCES",
							"util_SOURCES",
							"location_SOURCES",
							"blob_SOURCES",
							"util_SOURCES",
							"stringdecoder_SOURCES",
							"util_SOURCES",
							"misc_SOURCES",
							"location_SOURCES",
							"gpio_SOURCES",
							"gpio_LIBRARIES",
							"pigpio_LIBRARY",
							"LibArchive_INCLUDE_DIRS",
							"archive_LIBRARIES",
							"LibArchive_LIBRARIES",
							"QJSM_EXTRA_SOURCES",
							"location_SOURCES",
							"QUICKJS_PREFIX",
							"CMAKE_REQUIRED_QUIET",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_REQUIRED_QUIET",
							"HAVE_POSIX_SPAWNP",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TESTS",
							"TESTS",
							"TEST",
							"BASE",
							"BASE",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QJS",
							"TEST",
							"CMAKE_CURRENT_SOURCE_DIR",
							"BASE",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QJSC",
							"NAME",
							"BASE",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TEST",
							"CMAKE_CURRENT_BINARY_DIR",
							"TEST",
							"TESTS",
							"QUICKJS_MODULES",
							"SHARED_TARGETS",
							"QJSM_LIBDIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QUICKJS_MODULES",
							"JS_MODULE",
							"JS_MODULE",
							"QJSM_MODULE",
							"QUICKJS_MODULES",
							"TESTS_SOURCES",
							"TESTS_SOURCES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TEST_SOURCE",
							"TEST_SOURCE",
							"TEST_NAME",
							"TEST_SOURCE",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TESTS_SOURCES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"LIBJS",
							"QUICKJS_LIBRARY_DIR",
							"LIB_MODULES",
							"LIB_MODULES",
							"LIB_MODULES",
							"LIB_MODULE",
							"LIB_MODULES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QUICKJS_SOURCES_ROOT",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QUICKJS_SOURCES_ROOT",
							"QUICKJS_SOURCES_ROOT",
							"MODULES_DIR",
							"QJSC",
							"MODULES_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QJSC_DEPS",
							"CMAKE_CURRENT_BINARY_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QJSM_SOURCES",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"QJSM_EXTRA_SOURCES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QJSM_SOURCES",
							"QJSM_SOURCES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TRANSPORT_PLATFORM",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QJSM_SOURCES",
							"QJS_MODULES_STATIC",
							"QJSM_LIBDIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QJSM_LDADD",
							"LIBPTHREAD",
							"LIBM",
							"LIBDL",
							"LIBWS2_32",
							"LINK_EXPORT",
							"QUICKJS_INSTALL_PREFIX",
							"QUICKJS_VERSION",
							"QUICKJS_INSTALL_PREFIX",
							"CMAKE_CURRENT_SOURCE_DIR"
						]
					},
					"BAAAAAAAAAAAAAAAAAAAAAAAAADACgAAQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKQ01BS0VfQ19DT01QSUxFUgpDTUFLRV9TWVNST09UCkNNQUtFX1RPT0xDSEFJTl9GSUxFCkNNQUtFX1ZFUkJPU0VfTUFLRUZJTEUKQ01BS0VfQlVJTERfVFlQRQpDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfQklOQVJZX0RJUgpRVUlDS0pTX01PRFVMRVMKUVVJQ0tKU19ICkNPTU1PTl9IRUFERVJTCkNVVElMU19IClFVSUNLSlNfSAogIHV0aWxfU09VUkNFUwogIGNoaWxkX3Byb2Nlc3NfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIGRlZXBfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIGluc3BlY3RfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIHRyZWVfd2Fsa2VyX1NPVVJDRVMKICB1dGlsX1NPVVJDRVMKICB4bWxfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIHBhdGhfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIHByZWRpY2F0ZV9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgcG9pbnRlcl9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgbGV4ZXJfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIG1tYXBfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIHJlcGVhdGVyX1NPVVJDRVMKICB1dGlsX1NPVVJDRVMKICBsb2NhdGlvbl9TT1VSQ0VTCiAgYmxvYl9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgc3RyaW5nZGVjb2Rlcl9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgbWlzY19TT1VSQ0VTCiAgbG9jYXRpb25fU09VUkNFUwogIHN0cmluZ2RlY29kZXJfU09VUkNFUwogIGdwaW9fU09VUkNFUwogIGdwaW9fTElCUkFSSUVTCiAgcGlncGlvX0xJQlJBUlkKTGliQXJjaGl2ZV9JTkNMVURFX0RJUlMKICBhcmNoaXZlX0xJQlJBUklFUwpMaWJBcmNoaXZlX0xJQlJBUklFUwpRSlNNX0VYVFJBX1NPVVJDRVMKICBsb2NhdGlvbl9TT1VSQ0VTClFVSUNLSlNfUFJFRklYCkNNQUtFX1JFUVVJUkVEX1FVSUVUCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX1JFUVVJUkVEX1FVSUVUCkhBVkVfUE9TSVhfU1BBV05QCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpURVNUUwpURVNUUwpURVNUCkJBU0UKQkFTRQpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKQ01BS0VfQ1VSUkVOVF9CSU5BUllfRElSClFKUwpURVNUCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpCQVNFCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKUUpTQwpOQU1FCkJBU0UKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClRFU1QKQ01BS0VfQ1VSUkVOVF9CSU5BUllfRElSClRFU1QKVEVTVFMKUVVJQ0tKU19NT0RVTEVTClNIQVJFRF9UQVJHRVRTClFKU01fTElCRElSCkNNQUtFX0NVUlJFTlRfQklOQVJZX0RJUgpRVUlDS0pTX01PRFVMRVMKSlNfTU9EVUxFCkpTX01PRFVMRQpRSlNNX01PRFVMRQpRVUlDS0pTX01PRFVMRVMKVEVTVFNfU09VUkNFUwpURVNUU19TT1VSQ0VTCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpURVNUX1NPVVJDRQpURVNUX1NPVVJDRQpURVNUX05BTUUKVEVTVF9TT1VSQ0UKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClRFU1RTX1NPVVJDRVMKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkxJQkpTClFVSUNLSlNfTElCUkFSWV9ESVIKTElCX01PRFVMRVMKTElCX01PRFVMRVMKTElCX01PRFVMRVMKTElCX01PRFVMRQpMSUJfTU9EVUxFUwpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKUVVJQ0tKU19TT1VSQ0VTX1JPT1QKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFVSUNLSlNfU09VUkNFU19ST09UClFVSUNLSlNfU09VUkNFU19ST09UCk1PRFVMRVNfRElSClFKU0MKTU9EVUxFU19ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFKU0NfREVQUwpDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFKU01fU09VUkNFUwpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpRSlNNX0VYVFJBX1NPVVJDRVMKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFKU01fU09VUkNFUwpRSlNNX1NPVVJDRVMKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpUUkFOU1BPUlRfUExBVEZPUk0KQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFKU01fU09VUkNFUwpRSlNfTU9EVUxFU19TVEFUSUMKUUpTTV9MSUJESVIKQ01BS0VfQ1VSUkVOVF9CSU5BUllfRElSClFKU01fTERBREQKTElCUFRIUkVBRApMSUJNCkxJQkRMCkxJQldTMl8zMgpMSU5LX0VYUE9SVApRVUlDS0pTX0lOU1RBTExfUFJFRklYClFVSUNLSlNfVkVSU0lPTgpRVUlDS0pTX0lOU1RBTExfUFJFRklYCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgAAAAAAAAAAqAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKgKAABDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfQklOQVJZX0RJUgpDTUFLRV9DX0NPTVBJTEVSCkNNQUtFX1NZU1JPT1QKQ01BS0VfVE9PTENIQUlOX0ZJTEUKQ01BS0VfVkVSQk9TRV9NQUtFRklMRQpDTUFLRV9CVUlMRF9UWVBFCkNNQUtFX0NVUlJFTlRfQklOQVJZX0RJUgpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKQ01BS0VfQ1VSUkVOVF9CSU5BUllfRElSClFVSUNLSlNfTU9EVUxFUwpRVUlDS0pTX0gKQ09NTU9OX0hFQURFUlMKQ1VUSUxTX0gKUVVJQ0tKU19ICiAgdXRpbF9TT1VSQ0VTCiAgY2hpbGRfcHJvY2Vzc19TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgZGVlcF9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgaW5zcGVjdF9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgdHJlZV93YWxrZXJfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIHhtbF9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgcGF0aF9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgcHJlZGljYXRlX1NPVVJDRVMKICB1dGlsX1NPVVJDRVMKICBwb2ludGVyX1NPVVJDRVMKICB1dGlsX1NPVVJDRVMKICBsZXhlcl9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgbW1hcF9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgcmVwZWF0ZXJfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIGxvY2F0aW9uX1NPVVJDRVMKICBibG9iX1NPVVJDRVMKICB1dGlsX1NPVVJDRVMKICBzdHJpbmdkZWNvZGVyX1NPVVJDRVMKICB1dGlsX1NPVVJDRVMKICBtaXNjX1NPVVJDRVMKICBsb2NhdGlvbl9TT1VSQ0VTCiAgZ3Bpb19TT1VSQ0VTCiAgZ3Bpb19MSUJSQVJJRVMKICBwaWdwaW9fTElCUkFSWQpMaWJBcmNoaXZlX0lOQ0xVREVfRElSUwogIGFyY2hpdmVfTElCUkFSSUVTCkxpYkFyY2hpdmVfTElCUkFSSUVTClFKU01fRVhUUkFfU09VUkNFUwogIGxvY2F0aW9uX1NPVVJDRVMKUVVJQ0tKU19QUkVGSVgKQ01BS0VfUkVRVUlSRURfUVVJRVQKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfUkVRVUlSRURfUVVJRVQKSEFWRV9QT1NJWF9TUEFXTlAKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClRFU1RTClRFU1RTClRFU1QKQkFTRQpCQVNFCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKUUpTClRFU1QKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkJBU0UKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfQklOQVJZX0RJUgpRSlNDCk5BTUUKQkFTRQpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKVEVTVApDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKVEVTVApURVNUUwpRVUlDS0pTX01PRFVMRVMKU0hBUkVEX1RBUkdFVFMKUUpTTV9MSUJESVIKQ01BS0VfQ1VSUkVOVF9CSU5BUllfRElSClFVSUNLSlNfTU9EVUxFUwpKU19NT0RVTEUKSlNfTU9EVUxFClFKU01fTU9EVUxFClFVSUNLSlNfTU9EVUxFUwpURVNUU19TT1VSQ0VTClRFU1RTX1NPVVJDRVMKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClRFU1RfU09VUkNFClRFU1RfU09VUkNFClRFU1RfTkFNRQpURVNUX1NPVVJDRQpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKVEVTVFNfU09VUkNFUwpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKTElCSlMKUVVJQ0tKU19MSUJSQVJZX0RJUgpMSUJfTU9EVUxFUwpMSUJfTU9EVUxFUwpMSUJfTU9EVUxFUwpMSUJfTU9EVUxFCkxJQl9NT0RVTEVTCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpRVUlDS0pTX1NPVVJDRVNfUk9PVApDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKUVVJQ0tKU19TT1VSQ0VTX1JPT1QKUVVJQ0tKU19TT1VSQ0VTX1JPT1QKTU9EVUxFU19ESVIKUUpTQwpNT0RVTEVTX0RJUgpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKUUpTQ19ERVBTCkNNQUtFX0NVUlJFTlRfQklOQVJZX0RJUgpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKUUpTTV9TT1VSQ0VTCk1PRFVMRVNfRElSCk1PRFVMRVNfRElSCk1PRFVMRVNfRElSCk1PRFVMRVNfRElSCk1PRFVMRVNfRElSCk1PRFVMRVNfRElSCk1PRFVMRVNfRElSCk1PRFVMRVNfRElSCk1PRFVMRVNfRElSCk1PRFVMRVNfRElSClFKU01fRVhUUkFfU09VUkNFUwpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKUUpTTV9TT1VSQ0VTClFKU01fU09VUkNFUwpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClRSQU5TUE9SVF9QTEFURk9STQpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKUUpTTV9TT1VSQ0VTClFKU19NT0RVTEVTX1NUQVRJQwpRSlNNX0xJQkRJUgpDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKUUpTTV9MREFERApMSUJQVEhSRUFECkxJQk0KTElCREwKTElCV1MyXzMyCkxJTktfRVhQT1JUClFVSUNLSlNfSU5TVEFMTF9QUkVGSVgKUVVJQ0tKU19WRVJTSU9OClFVSUNLSlNfSU5TVEFMTF9QUkVGSVgKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSAAAAAAAAAACoCgAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					429,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/CMakeLists.txt",
						"symkeys":
						[
							[
								67,
								91
							],
							[
								126,
								150
							],
							[
								187,
								211
							],
							[
								250,
								274
							],
							[
								458,
								482
							],
							[
								504,
								528
							],
							[
								589,
								605
							],
							[
								632,
								645
							],
							[
								683,
								703
							],
							[
								788,
								810
							],
							[
								842,
								858
							],
							[
								943,
								967
							],
							[
								1010,
								1034
							],
							[
								1126,
								1150
							],
							[
								1252,
								1267
							],
							[
								1429,
								1438
							],
							[
								1449,
								1463
							],
							[
								1466,
								1474
							],
							[
								1478,
								1487
							],
							[
								1502,
								1514
							],
							[
								1592,
								1613
							],
							[
								1694,
								1706
							],
							[
								1741,
								1753
							],
							[
								1851,
								1863
							],
							[
								1983,
								1998
							],
							[
								2031,
								2043
							],
							[
								2125,
								2144
							],
							[
								2211,
								2223
							],
							[
								2230,
								2241
							],
							[
								2308,
								2320
							],
							[
								2337,
								2349
							],
							[
								2366,
								2378
							],
							[
								2385,
								2402
							],
							[
								2447,
								2459
							],
							[
								2466,
								2481
							],
							[
								2504,
								2516
							],
							[
								2523,
								2536
							],
							[
								2577,
								2589
							],
							[
								2671,
								2683
							],
							[
								2686,
								2698
							],
							[
								2705,
								2721
							],
							[
								2724,
								2736
							],
							[
								2743,
								2759
							],
							[
								2841,
								2853
							],
							[
								2874,
								2886
							],
							[
								2893,
								2914
							],
							[
								2991,
								3003
							],
							[
								3010,
								3022
							],
							[
								3081,
								3097
							],
							[
								3104,
								3116
							],
							[
								3157,
								3171
							],
							[
								3174,
								3188
							],
							[
								3236,
								3259
							],
							[
								3266,
								3283
							],
							[
								3286,
								3306
							],
							[
								3314,
								3332
							],
							[
								3335,
								3351
							],
							[
								3497,
								3511
							],
							[
								3520,
								3540
							],
							[
								3940,
								3959
							],
							[
								3987,
								4006
							],
							[
								4010,
								4029
							],
							[
								4094,
								4113
							],
							[
								4224,
								4243
							],
							[
								4273,
								4292
							],
							[
								4296,
								4315
							],
							[
								4382,
								4401
							],
							[
								4521,
								4540
							],
							[
								4572,
								4591
							],
							[
								4595,
								4614
							],
							[
								4683,
								4702
							],
							[
								4849,
								4869
							],
							[
								5077,
								5094
							],
							[
								5266,
								5290
							],
							[
								5295,
								5300
							],
							[
								5352,
								5357
							],
							[
								5381,
								5385
							],
							[
								5427,
								5431
							],
							[
								5456,
								5460
							],
							[
								5497,
								5521
							],
							[
								5525,
								5549
							],
							[
								5554,
								5557
							],
							[
								5572,
								5576
							],
							[
								5600,
								5624
							],
							[
								5653,
								5657
							],
							[
								5698,
								5722
							],
							[
								5726,
								5750
							],
							[
								5755,
								5759
							],
							[
								5789,
								5793
							],
							[
								5801,
								5805
							],
							[
								5811,
								5835
							],
							[
								5839,
								5843
							],
							[
								5889,
								5913
							],
							[
								5927,
								5931
							],
							[
								5955,
								5960
							],
							[
								6390,
								6405
							],
							[
								6445,
								6459
							],
							[
								6509,
								6520
							],
							[
								6524,
								6548
							],
							[
								6573,
								6588
							],
							[
								6607,
								6616
							],
							[
								6665,
								6674
							],
							[
								6706,
								6717
							],
							[
								6746,
								6761
							],
							[
								7062,
								7075
							],
							[
								7117,
								7130
							],
							[
								7169,
								7193
							],
							[
								7199,
								7210
							],
							[
								7237,
								7248
							],
							[
								7274,
								7283
							],
							[
								7311,
								7322
							],
							[
								7346,
								7370
							],
							[
								7400,
								7413
							],
							[
								7436,
								7460
							],
							[
								7550,
								7555
							],
							[
								7572,
								7591
							],
							[
								7608,
								7619
							],
							[
								7738,
								7749
							],
							[
								7924,
								7935
							],
							[
								8006,
								8016
							],
							[
								8046,
								8057
							],
							[
								8073,
								8097
							],
							[
								8120,
								8140
							],
							[
								8143,
								8167
							],
							[
								8186,
								8206
							],
							[
								8232,
								8252
							],
							[
								8314,
								8325
							],
							[
								8347,
								8351
							],
							[
								8370,
								8381
							],
							[
								8398,
								8422
							],
							[
								8448,
								8457
							],
							[
								8479,
								8503
							],
							[
								8590,
								8614
							],
							[
								8638,
								8650
							],
							[
								8669,
								8680
							],
							[
								8691,
								8702
							],
							[
								8716,
								8727
							],
							[
								8741,
								8752
							],
							[
								8765,
								8776
							],
							[
								8790,
								8801
							],
							[
								8810,
								8821
							],
							[
								8838,
								8849
							],
							[
								8882,
								8893
							],
							[
								8903,
								8914
							],
							[
								8925,
								8943
							],
							[
								8961,
								8985
							],
							[
								9045,
								9057
							],
							[
								9060,
								9072
							],
							[
								9076,
								9100
							],
							[
								9126,
								9150
							],
							[
								9184,
								9202
							],
							[
								9252,
								9276
							],
							[
								9347,
								9359
							],
							[
								9445,
								9463
							],
							[
								9684,
								9695
							],
							[
								9699,
								9723
							],
							[
								9765,
								9775
							],
							[
								9779,
								9789
							],
							[
								9793,
								9797
							],
							[
								9801,
								9806
							],
							[
								9810,
								9819
							],
							[
								9878,
								9889
							],
							[
								9920,
								9942
							],
							[
								10019,
								10034
							],
							[
								10068,
								10090
							],
							[
								10166,
								10190
							]
						],
						"symlist":
						[
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"CMAKE_C_COMPILER",
							"CMAKE_SYSROOT",
							"CMAKE_TOOLCHAIN_FILE",
							"CMAKE_VERBOSE_MAKEFILE",
							"CMAKE_BUILD_TYPE",
							"CMAKE_CURRENT_BINARY_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QUICKJS_MODULES",
							"QUICKJS_H",
							"COMMON_HEADERS",
							"CUTILS_H",
							"QUICKJS_H",
							"util_SOURCES",
							"child_process_SOURCES",
							"util_SOURCES",
							"deep_SOURCES",
							"util_SOURCES",
							"inspect_SOURCES",
							"util_SOURCES",
							"tree_walker_SOURCES",
							"util_SOURCES",
							"xml_SOURCES",
							"util_SOURCES",
							"path_SOURCES",
							"util_SOURCES",
							"predicate_SOURCES",
							"util_SOURCES",
							"pointer_SOURCES",
							"util_SOURCES",
							"lexer_SOURCES",
							"util_SOURCES",
							"mmap_SOURCES",
							"util_SOURCES",
							"repeater_SOURCES",
							"util_SOURCES",
							"location_SOURCES",
							"blob_SOURCES",
							"util_SOURCES",
							"stringdecoder_SOURCES",
							"util_SOURCES",
							"misc_SOURCES",
							"location_SOURCES",
							"gpio_SOURCES",
							"gpio_LIBRARIES",
							"pigpio_LIBRARY",
							"LibArchive_INCLUDE_DIRS",
							"archive_LIBRARIES",
							"LibArchive_LIBRARIES",
							"QJSM_EXTRA_SOURCES",
							"location_SOURCES",
							"QUICKJS_PREFIX",
							"CMAKE_REQUIRED_QUIET",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_C_FLAGS_DEBUG",
							"CMAKE_REQUIRED_QUIET",
							"HAVE_POSIX_SPAWNP",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TESTS",
							"TESTS",
							"TEST",
							"BASE",
							"BASE",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QJS",
							"TEST",
							"CMAKE_CURRENT_SOURCE_DIR",
							"BASE",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QJSC",
							"NAME",
							"BASE",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TEST",
							"CMAKE_CURRENT_BINARY_DIR",
							"TEST",
							"TESTS",
							"QUICKJS_MODULES",
							"SHARED_TARGETS",
							"QJSM_LIBDIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QUICKJS_MODULES",
							"JS_MODULE",
							"JS_MODULE",
							"QJSM_MODULE",
							"QUICKJS_MODULES",
							"TESTS_SOURCES",
							"TESTS_SOURCES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TEST_SOURCE",
							"TEST_SOURCE",
							"TEST_NAME",
							"TEST_SOURCE",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TESTS_SOURCES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"LIBJS",
							"QUICKJS_LIBRARY_DIR",
							"LIB_MODULES",
							"LIB_MODULES",
							"LIB_MODULES",
							"LIB_MODULE",
							"LIB_MODULES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QUICKJS_SOURCES_ROOT",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QUICKJS_SOURCES_ROOT",
							"QUICKJS_SOURCES_ROOT",
							"MODULES_DIR",
							"QJSC",
							"MODULES_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QJSC_DEPS",
							"CMAKE_CURRENT_BINARY_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QJSM_SOURCES",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"MODULES_DIR",
							"QJSM_EXTRA_SOURCES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QJSM_SOURCES",
							"QJSM_SOURCES",
							"CMAKE_CURRENT_SOURCE_DIR",
							"CMAKE_CURRENT_SOURCE_DIR",
							"TRANSPORT_PLATFORM",
							"CMAKE_CURRENT_SOURCE_DIR",
							"QJSM_SOURCES",
							"QJS_MODULES_STATIC",
							"QJSM_LIBDIR",
							"CMAKE_CURRENT_BINARY_DIR",
							"QJSM_LDADD",
							"LIBPTHREAD",
							"LIBM",
							"LIBDL",
							"LIBWS2_32",
							"LINK_EXPORT",
							"QUICKJS_INSTALL_PREFIX",
							"QUICKJS_VERSION",
							"QUICKJS_INSTALL_PREFIX",
							"CMAKE_CURRENT_SOURCE_DIR"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACoCgAAQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKQ01BS0VfQ19DT01QSUxFUgpDTUFLRV9TWVNST09UCkNNQUtFX1RPT0xDSEFJTl9GSUxFCkNNQUtFX1ZFUkJPU0VfTUFLRUZJTEUKQ01BS0VfQlVJTERfVFlQRQpDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfQklOQVJZX0RJUgpRVUlDS0pTX01PRFVMRVMKUVVJQ0tKU19ICkNPTU1PTl9IRUFERVJTCkNVVElMU19IClFVSUNLSlNfSAogIHV0aWxfU09VUkNFUwogIGNoaWxkX3Byb2Nlc3NfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIGRlZXBfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIGluc3BlY3RfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIHRyZWVfd2Fsa2VyX1NPVVJDRVMKICB1dGlsX1NPVVJDRVMKICB4bWxfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIHBhdGhfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIHByZWRpY2F0ZV9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgcG9pbnRlcl9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgbGV4ZXJfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIG1tYXBfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIHJlcGVhdGVyX1NPVVJDRVMKICB1dGlsX1NPVVJDRVMKICBsb2NhdGlvbl9TT1VSQ0VTCiAgYmxvYl9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgc3RyaW5nZGVjb2Rlcl9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgbWlzY19TT1VSQ0VTCiAgbG9jYXRpb25fU09VUkNFUwogIGdwaW9fU09VUkNFUwogIGdwaW9fTElCUkFSSUVTCiAgcGlncGlvX0xJQlJBUlkKTGliQXJjaGl2ZV9JTkNMVURFX0RJUlMKICBhcmNoaXZlX0xJQlJBUklFUwpMaWJBcmNoaXZlX0xJQlJBUklFUwpRSlNNX0VYVFJBX1NPVVJDRVMKICBsb2NhdGlvbl9TT1VSQ0VTClFVSUNLSlNfUFJFRklYCkNNQUtFX1JFUVVJUkVEX1FVSUVUCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX1JFUVVJUkVEX1FVSUVUCkhBVkVfUE9TSVhfU1BBV05QCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpURVNUUwpURVNUUwpURVNUCkJBU0UKQkFTRQpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKQ01BS0VfQ1VSUkVOVF9CSU5BUllfRElSClFKUwpURVNUCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpCQVNFCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKUUpTQwpOQU1FCkJBU0UKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClRFU1QKQ01BS0VfQ1VSUkVOVF9CSU5BUllfRElSClRFU1QKVEVTVFMKUVVJQ0tKU19NT0RVTEVTClNIQVJFRF9UQVJHRVRTClFKU01fTElCRElSCkNNQUtFX0NVUlJFTlRfQklOQVJZX0RJUgpRVUlDS0pTX01PRFVMRVMKSlNfTU9EVUxFCkpTX01PRFVMRQpRSlNNX01PRFVMRQpRVUlDS0pTX01PRFVMRVMKVEVTVFNfU09VUkNFUwpURVNUU19TT1VSQ0VTCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpURVNUX1NPVVJDRQpURVNUX1NPVVJDRQpURVNUX05BTUUKVEVTVF9TT1VSQ0UKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClRFU1RTX1NPVVJDRVMKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkxJQkpTClFVSUNLSlNfTElCUkFSWV9ESVIKTElCX01PRFVMRVMKTElCX01PRFVMRVMKTElCX01PRFVMRVMKTElCX01PRFVMRQpMSUJfTU9EVUxFUwpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKUVVJQ0tKU19TT1VSQ0VTX1JPT1QKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFVSUNLSlNfU09VUkNFU19ST09UClFVSUNLSlNfU09VUkNFU19ST09UCk1PRFVMRVNfRElSClFKU0MKTU9EVUxFU19ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFKU0NfREVQUwpDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFKU01fU09VUkNFUwpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpRSlNNX0VYVFJBX1NPVVJDRVMKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFKU01fU09VUkNFUwpRSlNNX1NPVVJDRVMKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpUUkFOU1BPUlRfUExBVEZPUk0KQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFKU01fU09VUkNFUwpRSlNfTU9EVUxFU19TVEFUSUMKUUpTTV9MSUJESVIKQ01BS0VfQ1VSUkVOVF9CSU5BUllfRElSClFKU01fTERBREQKTElCUFRIUkVBRApMSUJNCkxJQkRMCkxJQldTMl8zMgpMSU5LX0VYUE9SVApRVUlDS0pTX0lOU1RBTExfUFJFRklYClFVSUNLSlNfVkVSU0lPTgpRVUlDS0pTX0lOU1RBTExfUFJFRklYCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgAAAAAAAAAAqAoAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					430,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/vector.c",
						"symkeys":
						[
							[
								28,
								39
							],
							[
								196,
								208
							],
							[
								369,
								376
							],
							[
								794,
								805
							],
							[
								948,
								962
							],
							[
								1156,
								1167
							],
							[
								1397,
								1409
							],
							[
								1622,
								1632
							],
							[
								1914,
								1927
							],
							[
								2385,
								2396
							],
							[
								2622,
								2642
							],
							[
								2814,
								2833
							],
							[
								3486,
								3497
							]
						],
						"symlist":
						[
							" Ⓜ  _GNU_SOURCE … — macro object",
							" Ⓜ  HAVE_UINT128 … — macro object",
							"—Ⓕ– umult64 ( ) { … } — function",
							"—Ⓕ– vector_free ( ) { … } — function",
							"—Ⓕ– vector_indexof ( ) { … } — function",
							"—Ⓕ– vector_find ( ) { … } — function",
							"—Ⓕ– vector_finds ( ) { … } — function",
							"—Ⓕ– vector_put ( ) { … } — function",
							"—Ⓕ– vector_printf ( ) { … } — function",
							"—Ⓕ– vector_diff ( ) { … } — function",
							"—Ⓕ– vector_symmetricdiff ( ) { … } — function",
							"—Ⓕ– vector_intersection ( ) { … } — function",
							"—Ⓕ– vector_copy ( ) { … } — function"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACoCgAAQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKQ01BS0VfQ19DT01QSUxFUgpDTUFLRV9TWVNST09UCkNNQUtFX1RPT0xDSEFJTl9GSUxFCkNNQUtFX1ZFUkJPU0VfTUFLRUZJTEUKQ01BS0VfQlVJTERfVFlQRQpDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfQklOQVJZX0RJUgpRVUlDS0pTX01PRFVMRVMKUVVJQ0tKU19ICkNPTU1PTl9IRUFERVJTCkNVVElMU19IClFVSUNLSlNfSAogIHV0aWxfU09VUkNFUwogIGNoaWxkX3Byb2Nlc3NfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIGRlZXBfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIGluc3BlY3RfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIHRyZWVfd2Fsa2VyX1NPVVJDRVMKICB1dGlsX1NPVVJDRVMKICB4bWxfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIHBhdGhfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIHByZWRpY2F0ZV9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgcG9pbnRlcl9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgbGV4ZXJfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIG1tYXBfU09VUkNFUwogIHV0aWxfU09VUkNFUwogIHJlcGVhdGVyX1NPVVJDRVMKICB1dGlsX1NPVVJDRVMKICBsb2NhdGlvbl9TT1VSQ0VTCiAgYmxvYl9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgc3RyaW5nZGVjb2Rlcl9TT1VSQ0VTCiAgdXRpbF9TT1VSQ0VTCiAgbWlzY19TT1VSQ0VTCiAgbG9jYXRpb25fU09VUkNFUwogIGdwaW9fU09VUkNFUwogIGdwaW9fTElCUkFSSUVTCiAgcGlncGlvX0xJQlJBUlkKTGliQXJjaGl2ZV9JTkNMVURFX0RJUlMKICBhcmNoaXZlX0xJQlJBUklFUwpMaWJBcmNoaXZlX0xJQlJBUklFUwpRSlNNX0VYVFJBX1NPVVJDRVMKICBsb2NhdGlvbl9TT1VSQ0VTClFVSUNLSlNfUFJFRklYCkNNQUtFX1JFUVVJUkVEX1FVSUVUCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX0NfRkxBR1NfREVCVUcKQ01BS0VfQ19GTEFHU19ERUJVRwpDTUFLRV9DX0ZMQUdTX0RFQlVHCkNNQUtFX1JFUVVJUkVEX1FVSUVUCkhBVkVfUE9TSVhfU1BBV05QCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpURVNUUwpURVNUUwpURVNUCkJBU0UKQkFTRQpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKQ01BS0VfQ1VSUkVOVF9CSU5BUllfRElSClFKUwpURVNUCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpCQVNFCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKUUpTQwpOQU1FCkJBU0UKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClRFU1QKQ01BS0VfQ1VSUkVOVF9CSU5BUllfRElSClRFU1QKVEVTVFMKUVVJQ0tKU19NT0RVTEVTClNIQVJFRF9UQVJHRVRTClFKU01fTElCRElSCkNNQUtFX0NVUlJFTlRfQklOQVJZX0RJUgpRVUlDS0pTX01PRFVMRVMKSlNfTU9EVUxFCkpTX01PRFVMRQpRSlNNX01PRFVMRQpRVUlDS0pTX01PRFVMRVMKVEVTVFNfU09VUkNFUwpURVNUU19TT1VSQ0VTCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpURVNUX1NPVVJDRQpURVNUX1NPVVJDRQpURVNUX05BTUUKVEVTVF9TT1VSQ0UKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClRFU1RTX1NPVVJDRVMKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkxJQkpTClFVSUNLSlNfTElCUkFSWV9ESVIKTElCX01PRFVMRVMKTElCX01PRFVMRVMKTElCX01PRFVMRVMKTElCX01PRFVMRQpMSUJfTU9EVUxFUwpDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVIKUVVJQ0tKU19TT1VSQ0VTX1JPT1QKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFVSUNLSlNfU09VUkNFU19ST09UClFVSUNLSlNfU09VUkNFU19ST09UCk1PRFVMRVNfRElSClFKU0MKTU9EVUxFU19ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFKU0NfREVQUwpDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVIKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFKU01fU09VUkNFUwpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpNT0RVTEVTX0RJUgpRSlNNX0VYVFJBX1NPVVJDRVMKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFKU01fU09VUkNFUwpRSlNNX1NPVVJDRVMKQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgpUUkFOU1BPUlRfUExBVEZPUk0KQ01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSClFKU01fU09VUkNFUwpRSlNfTU9EVUxFU19TVEFUSUMKUUpTTV9MSUJESVIKQ01BS0VfQ1VSUkVOVF9CSU5BUllfRElSClFKU01fTERBREQKTElCUFRIUkVBRApMSUJNCkxJQkRMCkxJQldTMl8zMgpMSU5LX0VYUE9SVApRVUlDS0pTX0lOU1RBTExfUFJFRklYClFVSUNLSlNfVkVSU0lPTgpRVUlDS0pTX0lOU1RBTExfUFJFRklYCkNNQUtFX0NVUlJFTlRfU09VUkNFX0RJUgAAAAAAAAAA7QEAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					431,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/vector.h",
						"symkeys":
						[
							[
								25,
								33
							],
							[
								63,
								74
							],
							[
								256,
								263
							],
							[
								360,
								366
							],
							[
								527,
								533
							],
							[
								544,
								555
							],
							[
								912,
								923
							],
							[
								976,
								990
							],
							[
								1044,
								1050
							],
							[
								1411,
								1420
							],
							[
								1778,
								1790
							],
							[
								1827,
								1837
							],
							[
								1889,
								1905
							],
							[
								1976,
								1990
							],
							[
								2287,
								2294
							],
							[
								2425,
								2432
							],
							[
								2587,
								2594
							],
							[
								2649,
								2663
							],
							[
								2716,
								2727
							],
							[
								2780,
								2792
							],
							[
								2836,
								2846
							],
							[
								2897,
								2908
							],
							[
								2928,
								2941
							],
							[
								2979,
								2998
							],
							[
								3052,
								3063
							],
							[
								3117,
								3137
							],
							[
								3199,
								3210
							],
							[
								3253,
								3264
							],
							[
								3340,
								3355
							],
							[
								3989,
								4002
							],
							[
								4242,
								4253
							],
							[
								4535,
								4544
							],
							[
								4772,
								4794
							],
							[
								4890,
								4901
							],
							[
								4984,
								4996
							],
							[
								5066,
								5078
							],
							[
								5185,
								5196
							],
							[
								5343,
								5355
							],
							[
								5411,
								5425
							],
							[
								5556,
								5566
							],
							[
								5730,
								5741
							],
							[
								5833,
								5844
							],
							[
								5916,
								5927
							],
							[
								5993,
								6007
							],
							[
								6205,
								6218
							],
							[
								6299,
								6310
							],
							[
								6493,
								6507
							]
						],
						"symlist":
						[
							" Ⓜ  VECTOR_H … — macro object",
							" Ⓜ  _GNU_SOURCE … — macro object",
							"—Ⓜ– roundto ( ) … — macro function",
							"—Ⓒ– Vector { … } ; — type",
							" Ⓣ  Vector ; — typedef",
							"—Ⓜ– VECTOR_INIT ( ) … — macro function",
							"—Ⓜ– vector_init ( ) … — macro function",
							"—Ⓜ– vector_init_rt ( ) … — macro function",
							"—Ⓜ– VECTOR ( ) … — macro function",
							"—Ⓜ– VECTOR_RT ( ) … — macro function",
							"—Ⓜ– vector_begin ( ) … — macro function",
							"—Ⓜ– vector_end ( ) … — macro function",
							"—Ⓜ– vector_foreach_t ( ) … — macro function",
							"—Ⓜ– vector_foreach ( ) … — macro function",
							"—Ⓕ– umult64 ( ) { … } — function",
							"—Ⓕ– umult64 ( ) { … } — function",
							" ⒡  umult64 ( ) ; — function declaration",
							" ⒡  vector_indexof ( ) ; — function declaration",
							" ⒡  vector_find ( ) ; — function declaration",
							" ⒡  vector_finds ( ) ; — function declaration",
							" ⒡  vector_put ( ) ; — function declaration",
							" ⒡  vector_free ( ) ; — function declaration",
							" ⒡  vector_printf ( ) ; — function declaration",
							" ⒡  vector_intersection ( ) ; — function declaration",
							" ⒡  vector_diff ( ) ; — function declaration",
							" ⒡  vector_symmetricdiff ( ) ; — function declaration",
							" ⒡  vector_copy ( ) ; — function declaration",
							"—Ⓜ– vector_push ( ) … — macro function",
							"—Ⓕ– vector_allocate ( ) { … } — function",
							"—Ⓕ– vector_shrink ( ) { … } — function",
							"—Ⓕ– vector_grow ( ) { … } — function",
							"—Ⓕ– vector_at ( ) { … } — function",
							"—Ⓕ– vector_default_realloc ( ) { … } — function",
							"—Ⓕ– vector_size ( ) { … } — function",
							"—Ⓕ– vector_empty ( ) { … } — function",
							"—Ⓕ– vector_front ( ) { … } — function",
							"—Ⓕ– vector_back ( ) { … } — function",
							"—Ⓕ– vector_clear ( ) { … } — function",
							"—Ⓕ– vector_emplace ( ) { … } — function",
							"—Ⓕ– vector_pop ( ) { … } — function",
							"—Ⓕ– vector_puts ( ) { … } — function",
							"—Ⓕ– vector_putc ( ) { … } — function",
							"—Ⓕ– vector_put0 ( ) { … } — function",
							"—Ⓕ– vector_putlong ( ) { … } — function",
							"—Ⓕ– vector_putptr ( ) { … } — function",
							"—Ⓕ– vector_sort ( ) { … } — function",
							"—Ⓕ– vector_catlong ( ) { … } — function"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAABnAgAAICDik4IgIF9HTlVfU09VUkNFIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBIQVZFX1VJTlQxMjgg4oCmIOKAlCBtYWNybyBvYmplY3QK4oCU4pK74oCTIHVtdWx0NjQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfZnJlZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9pbmRleG9mICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2ZpbmQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfZmluZHMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfcHV0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX3ByaW50ZiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9kaWZmICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX3N5bW1ldHJpY2RpZmYgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfaW50ZXJzZWN0aW9uICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2NvcHkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uAAAAAAAAAABIBwAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					432,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/qjsm.c",
						"symkeys":
						[
							[
								28,
								39
							],
							[
								1755,
								1769
							],
							[
								2033,
								2044
							],
							[
								2159,
								2172
							],
							[
								2259,
								2288
							],
							[
								2405,
								2423
							],
							[
								2450,
								2463
							],
							[
								2525,
								2543
							],
							[
								2944,
								2962
							],
							[
								2973,
								2991
							],
							[
								3001,
								3019
							],
							[
								3025,
								3043
							],
							[
								3057,
								3075
							],
							[
								3086,
								3104
							],
							[
								3112,
								3130
							],
							[
								3141,
								3159
							],
							[
								3166,
								3184
							],
							[
								3214,
								3232
							],
							[
								3283,
								3317
							],
							[
								3360,
								3378
							],
							[
								3628,
								3639
							],
							[
								3778,
								3799
							],
							[
								3885,
								3901
							],
							[
								4035,
								4049
							],
							[
								4144,
								4160
							],
							[
								4555,
								4567
							],
							[
								4820,
								4836
							],
							[
								5100,
								5125
							],
							[
								6753,
								6774
							],
							[
								7166,
								7184
							],
							[
								7641,
								7656
							],
							[
								8203,
								8217
							],
							[
								8546,
								8561
							],
							[
								9105,
								9117
							],
							[
								9349,
								9368
							],
							[
								9727,
								9745
							],
							[
								10170,
								10189
							],
							[
								10986,
								11001
							],
							[
								11440,
								11460
							],
							[
								12591,
								12611
							],
							[
								13784,
								13806
							],
							[
								16033,
								16048
							],
							[
								16585,
								16597
							],
							[
								17323,
								17335
							],
							[
								17582,
								17595
							],
							[
								18256,
								18271
							],
							[
								18751,
								18766
							],
							[
								19107,
								19123
							],
							[
								19466,
								19481
							],
							[
								19772,
								19789
							],
							[
								20286,
								20301
							],
							[
								20318,
								20333
							],
							[
								20351,
								20368
							],
							[
								20404,
								20415
							],
							[
								20758,
								20785
							],
							[
								20946,
								20974
							],
							[
								21570,
								21593
							],
							[
								22281,
								22302
							],
							[
								22379,
								22395
							],
							[
								22828,
								22842
							],
							[
								23066,
								23083
							],
							[
								24380,
								24389
							],
							[
								24403,
								24411
							],
							[
								25512,
								25526
							],
							[
								26741,
								26755
							],
							[
								30588,
								30592
							],
							[
								36387,
								36405
							],
							[
								37022,
								37042
							]
						],
						"symlist":
						[
							" Ⓜ  _GNU_SOURCE … — macro object",
							"—Ⓕ– atomic_add_int ( ) { … } — function",
							"—Ⓒ– pollhandler { … } ; — type",
							" Ⓣ  pollhandler_t ; — typedef",
							" ⒡  js_std_set_module_loader_func ( ) ; — function declaration",
							" ⒡  malloc_usable_size ( ) ; — function declaration",
							"—Ⓜ– trim_dotslash ( ) … — macro function",
							"—Ⓜ– jsm_declare_module ( ) … — macro function",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  jsm_declare_module ( ) ; — function declaration",
							" ⒡  js_std_set_worker_new_context_func ( ) ; — function declaration",
							" ⒡  jsm_std_dump_error ( ) ; — function declaration",
							"—Ⓕ– jsm_time_ms ( ) { … } — function",
							"—Ⓕ– jsm_interrupt_handler ( ) { … } — function",
							"—Ⓕ– jsm_unlink_timer ( ) { … } — function",
							"—Ⓕ– jsm_free_timer ( ) { … } — function",
							"—Ⓕ– jsm_call_handler ( ) { … } — function",
							"—Ⓕ– jsm_sab_free ( ) { … } — function",
							"—Ⓕ– jsm_free_message ( ) { … } — function",
							"—Ⓕ– jsm_handle_posted_message ( ) { … } — function",
							"—Ⓕ– jsm_load_package_json ( ) { … } — function",
							"—Ⓕ– jsm_module_exports ( ) { … } — function",
							"—Ⓕ– jsm_module_find ( ) { … } — function",
							"—Ⓕ– jsm_module_get ( ) { … } — function",
							"—Ⓕ– jsm_module_list ( ) { … } — function",
							"—Ⓕ– jsm_dump_obj ( ) { … } — function",
							"—Ⓕ– jsm_std_dump_error1 ( ) { … } — function",
							"—Ⓕ– jsm_std_dump_error ( ) { … } — function",
							"—Ⓕ– jsm_find_module_ext ( ) { … } — function",
							"—Ⓕ– jsm_find_module ( ) { … } — function",
							"—Ⓕ– jsm_normalize_module ( ) { … } — function",
							"—Ⓕ– jsm_module_loader_so ( ) { … } — function",
							"—Ⓕ– jsm_module_loader_path ( ) { … } — function",
							"—Ⓕ– jsm_eval_binary ( ) { … } — function",
							"—Ⓕ– jsm_eval_buf ( ) { … } — function",
							"—Ⓕ– jsm_eval_str ( ) { … } — function",
							"—Ⓕ– jsm_eval_file ( ) { … } — function",
							"—Ⓕ– jsm_load_script ( ) { … } — function",
							"—Ⓕ– jsm_load_module ( ) { … } — function",
							"—Ⓕ– jsm_list_modules ( ) { … } — function",
							"—Ⓕ– jsm_context_new ( ) { … } — function",
							"—Ⓜ– jsm_module_native ( ) … — macro function",
							" Ⓜ  MALLOC_OVERHEAD … — macro object",
							" Ⓜ  MALLOC_OVERHEAD … — macro object",
							"—Ⓒ– trace_malloc_data { … } ; — type",
							"—Ⓕ– dump_vector ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_ptr_offset ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_usable_size ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_printf ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc_init ( ) { … } — function",
							"—Ⓕ– jsm_trace_malloc ( ) { … } — function",
							"—Ⓕ– jsm_trace_free ( ) { … } — function",
							"—Ⓕ– jsm_trace_realloc ( ) { … } — function",
							" Ⓜ  PROG_NAME … — macro object",
							"—Ⓕ– jsm_help ( ) { … } — function",
							"—Ⓕ– js_eval_script ( ) { … } — function",
							"—Ⓕ– js_module_func ( ) { … } — function",
							"—Ⓕ– main ( ) { … } — function",
							"—Ⓜ– jsm_builtin_native ( ) … — macro function",
							"—Ⓜ– jsm_builtin_compiled ( ) … — macro function"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAADOCAAAICDik4IgIFZFQ1RPUl9IIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBfR05VX1NPVVJDRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTik4LigJMgcm91bmR0byAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTikrjigJMgVmVjdG9yIHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgVmVjdG9yIDsg4oCUIHR5cGVkZWYK4oCU4pOC4oCTIFZFQ1RPUl9JTklUICggKSDigKYg4oCUIG1hY3JvIGZ1bmN0aW9uCuKAlOKTguKAkyB2ZWN0b3JfaW5pdCAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTik4LigJMgdmVjdG9yX2luaXRfcnQgKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIFZFQ1RPUiAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTik4LigJMgVkVDVE9SX1JUICggKSDigKYg4oCUIG1hY3JvIGZ1bmN0aW9uCuKAlOKTguKAkyB2ZWN0b3JfYmVnaW4gKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIHZlY3Rvcl9lbmQgKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIHZlY3Rvcl9mb3JlYWNoX3QgKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIHZlY3Rvcl9mb3JlYWNoICggKSDigKYg4oCUIG1hY3JvIGZ1bmN0aW9uCuKAlOKSu+KAkyB1bXVsdDY0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdW11bHQ2NCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDikqEgIHVtdWx0NjQgKCApIDsg4oCUIGZ1bmN0aW9uIGRlY2xhcmF0aW9uCiAg4pKhICB2ZWN0b3JfaW5kZXhvZiAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIHZlY3Rvcl9maW5kICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAgdmVjdG9yX2ZpbmRzICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAgdmVjdG9yX3B1dCAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIHZlY3Rvcl9mcmVlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAgdmVjdG9yX3ByaW50ZiAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIHZlY3Rvcl9pbnRlcnNlY3Rpb24gKCApIDsg4oCUIGZ1bmN0aW9uIGRlY2xhcmF0aW9uCiAg4pKhICB2ZWN0b3JfZGlmZiAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIHZlY3Rvcl9zeW1tZXRyaWNkaWZmICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAgdmVjdG9yX2NvcHkgKCApIDsg4oCUIGZ1bmN0aW9uIGRlY2xhcmF0aW9uCuKAlOKTguKAkyB2ZWN0b3JfcHVzaCAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2FsbG9jYXRlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX3NocmluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9ncm93ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2F0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2RlZmF1bHRfcmVhbGxvYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9zaXplICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2VtcHR5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2Zyb250ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2JhY2sgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfY2xlYXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfZW1wbGFjZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9wb3AgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfcHV0cyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9wdXRjICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX3B1dDAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfcHV0bG9uZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9wdXRwdHIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3Jfc29ydCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9jYXRsb25nICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgAAAAAAAAAAwgsAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					433,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/vector.h",
						"symkeys":
						[
							[
								25,
								33
							],
							[
								63,
								74
							],
							[
								256,
								263
							],
							[
								360,
								366
							],
							[
								527,
								533
							],
							[
								544,
								555
							],
							[
								912,
								923
							],
							[
								976,
								990
							],
							[
								1044,
								1050
							],
							[
								1411,
								1420
							],
							[
								1778,
								1790
							],
							[
								1827,
								1837
							],
							[
								1889,
								1905
							],
							[
								1976,
								1990
							],
							[
								2287,
								2294
							],
							[
								2425,
								2432
							],
							[
								2587,
								2594
							],
							[
								2649,
								2663
							],
							[
								2716,
								2727
							],
							[
								2780,
								2792
							],
							[
								2836,
								2846
							],
							[
								2897,
								2908
							],
							[
								2928,
								2941
							],
							[
								2979,
								2998
							],
							[
								3052,
								3063
							],
							[
								3117,
								3137
							],
							[
								3199,
								3210
							],
							[
								3253,
								3264
							],
							[
								3340,
								3355
							],
							[
								3989,
								4002
							],
							[
								4242,
								4253
							],
							[
								4535,
								4544
							],
							[
								4772,
								4794
							],
							[
								4890,
								4901
							],
							[
								4984,
								4996
							],
							[
								5066,
								5078
							],
							[
								5185,
								5196
							],
							[
								5343,
								5355
							],
							[
								5411,
								5425
							],
							[
								5556,
								5566
							],
							[
								5730,
								5741
							],
							[
								5833,
								5844
							],
							[
								5916,
								5927
							],
							[
								5993,
								6007
							],
							[
								6205,
								6218
							],
							[
								6299,
								6310
							],
							[
								6493,
								6507
							]
						],
						"symlist":
						[
							" Ⓜ  VECTOR_H … — macro object",
							" Ⓜ  _GNU_SOURCE … — macro object",
							"—Ⓜ– roundto ( ) … — macro function",
							"—Ⓒ– Vector { … } ; — type",
							" Ⓣ  Vector ; — typedef",
							"—Ⓜ– VECTOR_INIT ( ) … — macro function",
							"—Ⓜ– vector_init ( ) … — macro function",
							"—Ⓜ– vector_init_rt ( ) … — macro function",
							"—Ⓜ– VECTOR ( ) … — macro function",
							"—Ⓜ– VECTOR_RT ( ) … — macro function",
							"—Ⓜ– vector_begin ( ) … — macro function",
							"—Ⓜ– vector_end ( ) … — macro function",
							"—Ⓜ– vector_foreach_t ( ) … — macro function",
							"—Ⓜ– vector_foreach ( ) … — macro function",
							"—Ⓕ– umult64 ( ) { … } — function",
							"—Ⓕ– umult64 ( ) { … } — function",
							" ⒡  umult64 ( ) ; — function declaration",
							" ⒡  vector_indexof ( ) ; — function declaration",
							" ⒡  vector_find ( ) ; — function declaration",
							" ⒡  vector_finds ( ) ; — function declaration",
							" ⒡  vector_put ( ) ; — function declaration",
							" ⒡  vector_free ( ) ; — function declaration",
							" ⒡  vector_printf ( ) ; — function declaration",
							" ⒡  vector_intersection ( ) ; — function declaration",
							" ⒡  vector_diff ( ) ; — function declaration",
							" ⒡  vector_symmetricdiff ( ) ; — function declaration",
							" ⒡  vector_copy ( ) ; — function declaration",
							"—Ⓜ– vector_push ( ) … — macro function",
							"—Ⓕ– vector_allocate ( ) { … } — function",
							"—Ⓕ– vector_shrink ( ) { … } — function",
							"—Ⓕ– vector_grow ( ) { … } — function",
							"—Ⓕ– vector_at ( ) { … } — function",
							"—Ⓕ– vector_default_realloc ( ) { … } — function",
							"—Ⓕ– vector_size ( ) { … } — function",
							"—Ⓕ– vector_empty ( ) { … } — function",
							"—Ⓕ– vector_front ( ) { … } — function",
							"—Ⓕ– vector_back ( ) { … } — function",
							"—Ⓕ– vector_clear ( ) { … } — function",
							"—Ⓕ– vector_emplace ( ) { … } — function",
							"—Ⓕ– vector_pop ( ) { … } — function",
							"—Ⓕ– vector_puts ( ) { … } — function",
							"—Ⓕ– vector_putc ( ) { … } — function",
							"—Ⓕ– vector_put0 ( ) { … } — function",
							"—Ⓕ– vector_putlong ( ) { … } — function",
							"—Ⓕ– vector_putptr ( ) { … } — function",
							"—Ⓕ– vector_sort ( ) { … } — function",
							"—Ⓕ– vector_catlong ( ) { … } — function"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAADgAAICDik4IgIF9HTlVfU09VUkNFIOKApiDigJQgbWFjcm8gb2JqZWN0CuKAlOKSu+KAkyBhdG9taWNfYWRkX2ludCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK44oCTIHBvbGxoYW5kbGVyIHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgcG9sbGhhbmRsZXJfdCA7IOKAlCB0eXBlZGVmCiAg4pKhICBqc19zdGRfc2V0X21vZHVsZV9sb2FkZXJfZnVuYyAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIG1hbGxvY191c2FibGVfc2l6ZSAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4oCU4pOC4oCTIHRyaW1fZG90c2xhc2ggKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIGpzbV9kZWNsYXJlX21vZHVsZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNtX2RlY2xhcmVfbW9kdWxlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAganNfc3RkX3NldF93b3JrZXJfbmV3X2NvbnRleHRfZnVuYyAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIGpzbV9zdGRfZHVtcF9lcnJvciAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24K4oCU4pK74oCTIGpzbV90aW1lX21zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2ludGVycnVwdF9oYW5kbGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3VubGlua190aW1lciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9mcmVlX3RpbWVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2NhbGxfaGFuZGxlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9zYWJfZnJlZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9mcmVlX21lc3NhZ2UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21faGFuZGxlX3Bvc3RlZF9tZXNzYWdlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2xvYWRfcGFja2FnZV9qc29uICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9leHBvcnRzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9maW5kICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9nZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fbW9kdWxlX2xpc3QgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fZHVtcF9vYmogKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fc3RkX2R1bXBfZXJyb3IxICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3N0ZF9kdW1wX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2ZpbmRfbW9kdWxlX2V4dCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9maW5kX21vZHVsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9ub3JtYWxpemVfbW9kdWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX21vZHVsZV9sb2FkZXJfc28gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fbW9kdWxlX2xvYWRlcl9wYXRoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfYmluYXJ5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfYnVmICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfc3RyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX2V2YWxfZmlsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9sb2FkX3NjcmlwdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9sb2FkX21vZHVsZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzbV9saXN0X21vZHVsZXMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fY29udGV4dF9uZXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKTguKAkyBqc21fbW9kdWxlX25hdGl2ZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgogIOKTgiAgTUFMTE9DX09WRVJIRUFEIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBNQUxMT0NfT1ZFUkhFQUQg4oCmIOKAlCBtYWNybyBvYmplY3QK4oCU4pK44oCTIHRyYWNlX21hbGxvY19kYXRhIHsg4oCmIH0gOyDigJQgdHlwZQrigJTikrvigJMgZHVtcF92ZWN0b3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX3B0cl9vZmZzZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3RyYWNlX21hbGxvY19wcmludGYgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jX2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfbWFsbG9jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNtX3RyYWNlX2ZyZWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc21fdHJhY2VfcmVhbGxvYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4IgIFBST0dfTkFNRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTikrvigJMganNtX2hlbHAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ldmFsX3NjcmlwdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21vZHVsZV9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgbWFpbiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pOC4oCTIGpzbV9idWlsdGluX25hdGl2ZSAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTik4LigJMganNtX2J1aWx0aW5fY29tcGlsZWQgKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24AAAAAAAAAAEgHAAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					434,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/vector.c",
						"symkeys":
						[
							[
								28,
								39
							],
							[
								196,
								208
							],
							[
								369,
								376
							],
							[
								794,
								805
							],
							[
								948,
								962
							],
							[
								1156,
								1167
							],
							[
								1397,
								1409
							],
							[
								1622,
								1632
							],
							[
								1914,
								1927
							],
							[
								2385,
								2396
							],
							[
								2622,
								2642
							],
							[
								2814,
								2833
							],
							[
								3486,
								3497
							]
						],
						"symlist":
						[
							" Ⓜ  _GNU_SOURCE … — macro object",
							" Ⓜ  HAVE_UINT128 … — macro object",
							"—Ⓕ– umult64 ( ) { … } — function",
							"—Ⓕ– vector_free ( ) { … } — function",
							"—Ⓕ– vector_indexof ( ) { … } — function",
							"—Ⓕ– vector_find ( ) { … } — function",
							"—Ⓕ– vector_finds ( ) { … } — function",
							"—Ⓕ– vector_put ( ) { … } — function",
							"—Ⓕ– vector_printf ( ) { … } — function",
							"—Ⓕ– vector_diff ( ) { … } — function",
							"—Ⓕ– vector_symmetricdiff ( ) { … } — function",
							"—Ⓕ– vector_intersection ( ) { … } — function",
							"—Ⓕ– vector_copy ( ) { … } — function"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAADOCAAAICDik4IgIFZFQ1RPUl9IIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBfR05VX1NPVVJDRSDigKYg4oCUIG1hY3JvIG9iamVjdArigJTik4LigJMgcm91bmR0byAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTikrjigJMgVmVjdG9yIHsg4oCmIH0gOyDigJQgdHlwZQogIOKTiSAgVmVjdG9yIDsg4oCUIHR5cGVkZWYK4oCU4pOC4oCTIFZFQ1RPUl9JTklUICggKSDigKYg4oCUIG1hY3JvIGZ1bmN0aW9uCuKAlOKTguKAkyB2ZWN0b3JfaW5pdCAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTik4LigJMgdmVjdG9yX2luaXRfcnQgKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIFZFQ1RPUiAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTik4LigJMgVkVDVE9SX1JUICggKSDigKYg4oCUIG1hY3JvIGZ1bmN0aW9uCuKAlOKTguKAkyB2ZWN0b3JfYmVnaW4gKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIHZlY3Rvcl9lbmQgKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIHZlY3Rvcl9mb3JlYWNoX3QgKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24K4oCU4pOC4oCTIHZlY3Rvcl9mb3JlYWNoICggKSDigKYg4oCUIG1hY3JvIGZ1bmN0aW9uCuKAlOKSu+KAkyB1bXVsdDY0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdW11bHQ2NCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDikqEgIHVtdWx0NjQgKCApIDsg4oCUIGZ1bmN0aW9uIGRlY2xhcmF0aW9uCiAg4pKhICB2ZWN0b3JfaW5kZXhvZiAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIHZlY3Rvcl9maW5kICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAgdmVjdG9yX2ZpbmRzICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAgdmVjdG9yX3B1dCAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIHZlY3Rvcl9mcmVlICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAgdmVjdG9yX3ByaW50ZiAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIHZlY3Rvcl9pbnRlcnNlY3Rpb24gKCApIDsg4oCUIGZ1bmN0aW9uIGRlY2xhcmF0aW9uCiAg4pKhICB2ZWN0b3JfZGlmZiAoICkgOyDigJQgZnVuY3Rpb24gZGVjbGFyYXRpb24KICDikqEgIHZlY3Rvcl9zeW1tZXRyaWNkaWZmICggKSA7IOKAlCBmdW5jdGlvbiBkZWNsYXJhdGlvbgogIOKSoSAgdmVjdG9yX2NvcHkgKCApIDsg4oCUIGZ1bmN0aW9uIGRlY2xhcmF0aW9uCuKAlOKTguKAkyB2ZWN0b3JfcHVzaCAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2FsbG9jYXRlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX3NocmluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9ncm93ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2F0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2RlZmF1bHRfcmVhbGxvYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9zaXplICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2VtcHR5ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2Zyb250ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2JhY2sgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfY2xlYXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfZW1wbGFjZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9wb3AgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfcHV0cyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9wdXRjICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX3B1dDAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfcHV0bG9uZyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9wdXRwdHIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3Jfc29ydCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9jYXRsb25nICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgAAAAAAAAAA7QEAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				],
				[
					435,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-blob.c",
						"symkeys":
						[
							[
								28,
								39
							],
							[
								128,
								131
							],
							[
								403,
								412
							],
							[
								623,
								631
							],
							[
								836,
								846
							],
							[
								1002,
								1011
							],
							[
								1129,
								1141
							],
							[
								1260,
								1270
							],
							[
								1435,
								1452
							],
							[
								1532,
								1544
							],
							[
								1709,
								1720
							],
							[
								1933,
								1944
							],
							[
								2324,
								2343
							],
							[
								4567,
								4581
							],
							[
								5755,
								5770
							],
							[
								6205,
								6222
							],
							[
								7012,
								7024
							],
							[
								7883,
								7897
							],
							[
								7927,
								7941
							]
						],
						"symlist":
						[
							" Ⓜ  _GNU_SOURCE … — macro object",
							"—Ⓜ– max ( ) … — macro function",
							"—Ⓕ– blob_init ( ) { … } — function",
							"—Ⓕ– blob_new ( ) { … } — function",
							"—Ⓕ– blob_write ( ) { … } — function",
							"—Ⓕ– blob_free ( ) { … } — function",
							"—Ⓕ– blob_free_rt ( ) { … } — function",
							"—Ⓕ– blob_input ( ) { … } — function",
							"—Ⓕ– js_blob_free_func ( ) { … } — function",
							"—Ⓕ– js_blob_wrap ( ) { … } — function",
							"—Ⓕ– js_blob_new ( ) { … } — function",
							"—Ⓕ– js_blob_get ( ) { … } — function",
							"—Ⓕ– js_blob_constructor ( ) { … } — function",
							"—Ⓕ– js_blob_method ( ) { … } — function",
							"—Ⓕ– js_blob_inspect ( ) { … } — function",
							"—Ⓕ– js_blob_finalizer ( ) { … } — function",
							"—Ⓕ– js_blob_init ( ) { … } — function",
							" Ⓜ  JS_INIT_MODULE … — macro object",
							" Ⓜ  JS_INIT_MODULE … — macro object"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAABnAgAAICDik4IgIF9HTlVfU09VUkNFIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBIQVZFX1VJTlQxMjgg4oCmIOKAlCBtYWNybyBvYmplY3QK4oCU4pK74oCTIHVtdWx0NjQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfZnJlZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9pbmRleG9mICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2ZpbmQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfZmluZHMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfcHV0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX3ByaW50ZiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHZlY3Rvcl9kaWZmICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX3N5bW1ldHJpY2RpZmYgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB2ZWN0b3JfaW50ZXJzZWN0aW9uICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdmVjdG9yX2NvcHkgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uAAAAAAAAAADKAgAAAAAAAAAAAAA",
					"AQAAAAAAAAAAAAAA"
				]
			]
		},
		{
			"file": "quickjs-blob.c",
			"settings":
			{
				"buffer_size": 8279,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					28,
					1,
					"insert",
					{
						"characters": "\nif"
					},
					"BAAAABkEAAAAAAAAGgQAAAAAAAAAAAAAGgQAAAAAAAAcBAAAAAAAAAAAAAAcBAAAAAAAAB0EAAAAAAAAAAAAAB0EAAAAAAAAHgQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAGQQAAAAAAAAZBAAAAAAAAAAAAAAAAPC/"
				],
				[
					29,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAB4EAAAAAAAAIAQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAHgQAAAAAAAAeBAAAAAAAAAAAAAAAAPC/"
				],
				[
					30,
					1,
					"insert",
					{
						"characters": "blob->va"
					},
					"CAAAAB8EAAAAAAAAIAQAAAAAAAAAAAAAIAQAAAAAAAAhBAAAAAAAAAAAAAAhBAAAAAAAACIEAAAAAAAAAAAAACIEAAAAAAAAIwQAAAAAAAAAAAAAIwQAAAAAAAAkBAAAAAAAAAAAAAAkBAAAAAAAACUEAAAAAAAAAAAAACUEAAAAAAAAJgQAAAAAAAAAAAAAJgQAAAAAAAAnBAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAHwQAAAAAAAAfBAAAAAAAAAAAAAAAAPC/"
				],
				[
					31,
					1,
					"left_delete",
					null,
					"AQAAACYEAAAAAAAAJgQAAAAAAAABAAAAYQ",
					"AQAAAAAAAAABAAAAJwQAAAAAAAAnBAAAAAAAAAAAAAAAAPC/"
				],
				[
					32,
					1,
					"insert",
					{
						"characters": "ec.data"
					},
					"BwAAACYEAAAAAAAAJwQAAAAAAAAAAAAAJwQAAAAAAAAoBAAAAAAAAAAAAAAoBAAAAAAAACkEAAAAAAAAAAAAACkEAAAAAAAAKgQAAAAAAAAAAAAAKgQAAAAAAAArBAAAAAAAAAAAAAArBAAAAAAAACwEAAAAAAAAAAAAACwEAAAAAAAALQQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAJgQAAAAAAAAmBAAAAAAAAAAAAAAAAPC/"
				],
				[
					35,
					1,
					"cut",
					null,
					"AQAAABwEAAAAAAAAHAQAAAAAAAASAAAAaWYoYmxvYi0+dmVjLmRhdGEp",
					"AQAAAAAAAAABAAAALgQAAAAAAAAcBAAAAAAAAAAAAAAAADRA"
				],
				[
					36,
					1,
					"paste",
					null,
					"AQAAABwEAAAAAAAALgQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAHAQAAAAAAAAcBAAAAAAAAAAAAAAAAPC/"
				],
				[
					39,
					1,
					"paste",
					null,
					"AQAAALIDAAAAAAAAxAMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAsgMAAAAAAACyAwAAAAAAAAAAAAAAADRA"
				],
				[
					40,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAMQDAAAAAAAAxQMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAxAMAAAAAAADEAwAAAAAAAAAAAAAAAPC/"
				],
				[
					43,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAdHwAAI2lmbmRlZiBfR05VX1NPVVJDRQojZGVmaW5lIF9HTlVfU09VUkNFCiNlbmRpZgoKI2luY2x1ZGUgInF1aWNranMtYmxvYi5oIgojaW5jbHVkZSAidXRpbHMuaCIKI2luY2x1ZGUgImJ1ZmZlci11dGlscy5oIgoKI2RlZmluZSBtYXgoYSwgYikgKChhKSA+IChiKSA/IChhKSA6IChiKSkKCnRocmVhZF9sb2NhbCBWSVNJQkxFIEpTQ2xhc3NJRCBqc19ibG9iX2NsYXNzX2lkID0gMDsKdGhyZWFkX2xvY2FsIEpTVmFsdWUgYmxvYl9wcm90byA9IHtKU19UQUdfVU5ERUZJTkVEfSwgYmxvYl9jdG9yID0ge0pTX1RBR19VTkRFRklORUR9OwoKZW51bSB7IEJMT0JfU0laRSwgQkxPQl9UWVBFIH07CmVudW0geyBCTE9CX0FSUkFZQlVGRkVSLCBCTE9CX1NMSUNFLCBCTE9CX1NUUkVBTSwgQkxPQl9URVhUIH07CgpCbG9iKgpibG9iX25ldyhKU0NvbnRleHQqIGN0eCwgY29uc3Qgdm9pZCogeCwgc2l6ZV90IGxlbiwgY29uc3QgY2hhciogdHlwZSkgewogIEJsb2IqIGJsb2I7CgogIGlmKCEoYmxvYiA9IGpzX21hbGxvY3ooY3R4LCBzaXplb2YoQmxvYikpKSkKICAgIHJldHVybiAwOwoKICBibG9iLT52ZWMgPSBWRUNUT1IoY3R4KTsKICBpZih4KSB7CiAgICB2ZWN0b3JfYWxsb2NhdGUoJmJsb2ItPnZlYywgMSwgbGVuIC0gMSk7CiAgICBtZW1jcHkoYmxvYi0+dmVjLmRhdGEsIHgsIGxlbik7CiAgfQoKICBibG9iLT50eXBlID0ganNfc3RyZHVwKGN0eCwgdHlwZSk7CiAgcmV0dXJuIGJsb2I7Cn0KCnNzaXplX3QKYmxvYl93cml0ZShKU0NvbnRleHQqIGN0eCwgQmxvYiogYmxvYiwgY29uc3Qgdm9pZCogeCwgc2l6ZV90IGxlbikgewogIHVpbnQ4X3QqIHB0cjsKICBpZigocHRyID0gdmVjdG9yX3B1dCgmYmxvYi0+dmVjLCB4LCBsZW4pKSkKICAgIHJldHVybiBsZW47CiAgcmV0dXJuIC0xOwp9Cgp2b2lkCmJsb2JfZnJlZShKU0NvbnRleHQqIGN0eCwgQmxvYiogYmxvYikgewogIGlmKGJsb2ItPnZlYy5kYXRhKSB2ZWN0b3JfZnJlZSgmYmxvYi0+dmVjKTsKICBqc19mcmVlKGN0eCwgYmxvYik7Cn0KCnN0YXRpYyB2b2lkCmJsb2JfZnJlZV9ydChKU1J1bnRpbWUqIHJ0LCBCbG9iKiBibG9iKSB7CiAgaWYoYmxvYi0+dmVjLmRhdGEpCiAgdmVjdG9yX2ZyZWUoJmJsb2ItPnZlYyk7CiAganNfZnJlZV9ydChydCwgYmxvYik7Cn0KCklucHV0QnVmZmVyCmJsb2JfaW5wdXQoSlNDb250ZXh0KiBjdHgsIEJsb2IqIGJsb2IpIHsKICBJbnB1dEJ1ZmZlciByZXQgPSB7YmxvYi0+ZGF0YSwgMCwgYmxvYi0+c2l6ZSwgJmlucHV0X2J1ZmZlcl9mcmVlX2RlZmF1bHQsIEpTX1VOREVGSU5FRCwgMCwgSU5UNjRfTUFYfTsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgdm9pZApqc19ibG9iX2ZyZWVfZnVuYyhKU1J1bnRpbWUqIHJ0LCB2b2lkKiBvcGFxdWUsIHZvaWQqIHB0cikgewogIC8vIGpzX2ZyZWVfcnQocnQsIHB0cik7Cn0KCkpTVmFsdWUKanNfYmxvYl93cmFwKEpTQ29udGV4dCogY3R4LCBCbG9iKiBibG9iKSB7CiAgSlNWYWx1ZSBvYmo7CiAgb2JqID0gSlNfTmV3T2JqZWN0UHJvdG9DbGFzcyhjdHgsIGJsb2JfcHJvdG8sIGpzX2Jsb2JfY2xhc3NfaWQpOwogIEpTX1NldE9wYXF1ZShvYmosIGJsb2IpOwogIHJldHVybiBvYmo7Cn0KCkpTVmFsdWUKanNfYmxvYl9uZXcoSlNDb250ZXh0KiBjdHgsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBsZW4sIGNvbnN0IGNoYXIqIHR5cGUpIHsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBibG9iX25ldyhjdHgsIHgsIGxlbiwgdHlwZSkpKQogICAgcmV0dXJuIEpTX1Rocm93T3V0T2ZNZW1vcnkoY3R4KTsKCiAgcmV0dXJuIGpzX2Jsb2Jfd3JhcChjdHgsIGJsb2IpOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc19ibG9iX2dldChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgbWFnaWMpIHsKICBCbG9iKiBibG9iOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwogIGlmKCEoYmxvYiA9IGpzX2Jsb2JfZGF0YShjdHgsIHRoaXNfdmFsKSkpCiAgICByZXR1cm4gcmV0OwogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBCTE9CX1NJWkU6IHsKICAgICAgcmV0ID0gSlNfTmV3VWludDMyKGN0eCwgYmxvYi0+c2l6ZSk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgQkxPQl9UWVBFOiB7CiAgICAgIHJldCA9IEpTX05ld1N0cmluZyhjdHgsIGJsb2ItPnR5cGUpOwogICAgICBicmVhazsKICAgIH0KICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNfYmxvYl9jb25zdHJ1Y3RvcihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG5ld190YXJnZXQsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgSlNWYWx1ZSBvYmogPSBKU19VTkRFRklORUQ7CiAgSlNWYWx1ZSBwcm90bzsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBqc19tYWxsb2N6KGN0eCwgc2l6ZW9mKEJsb2IpKSkpCiAgICByZXR1cm4gSlNfVGhyb3dPdXRPZk1lbW9yeShjdHgpOwoKICAvKiB1c2luZyBuZXdfdGFyZ2V0IHRvIGdldCB0aGUgcHJvdG90eXBlIGlzIG5lY2Vzc2FyeSB3aGVuIHRoZQogICAgIGNsYXNzIGlzIGV4dGVuZGVkLiAqLwogIHByb3RvID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBuZXdfdGFyZ2V0LCAicHJvdG90eXBlIik7CiAgaWYoSlNfSXNFeGNlcHRpb24ocHJvdG8pKQogICAgZ290byBmYWlsOwogIGlmKCFKU19Jc09iamVjdChwcm90bykpCiAgICBwcm90byA9IGJsb2JfcHJvdG87CgogIC8qIHVzaW5nIG5ld190YXJnZXQgdG8gZ2V0IHRoZSBwcm90b3R5cGUgaXMgbmVjZXNzYXJ5IHdoZW4gdGhlCiAgICAgY2xhc3MgaXMgZXh0ZW5kZWQuICovCiAgb2JqID0gSlNfTmV3T2JqZWN0UHJvdG9DbGFzcyhjdHgsIHByb3RvLCBqc19ibG9iX2NsYXNzX2lkKTsKICBpZihKU19Jc0V4Y2VwdGlvbihvYmopKQogICAgZ290byBmYWlsOwoKICBibG9iLT52ZWMgPSBWRUNUT1IoY3R4KTsKCiAgewogICAgdWludDhfdCogcHRyOwogICAgc2l6ZV90IHNpemUgPSAwLCBvZmZzID0gMDsKICAgIGJsb2ItPnR5cGUgPSAwOwoKICAgIGlmKGFyZ2MgPj0gMSkgewogICAgICB1aW50MzJfdCBpLCBsZW4gPSBqc19hcnJheV9sZW5ndGgoY3R4LCBhcmd2WzBdKTsKICAgICAgSW5wdXRCdWZmZXIqIHBhcnRzID0ganNfbWFsbG9jKGN0eCwgc2l6ZW9mKElucHV0QnVmZmVyKSAqIGxlbik7CgogICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgIEJsb2IqIG90aGVyOwogICAgICAgIEpTVmFsdWUgaXRlbSA9IEpTX0dldFByb3BlcnR5VWludDMyKGN0eCwgYXJndlswXSwgaSk7CiAgICAgICAgcGFydHNbaV0gPSAob3RoZXIgPSBqc19ibG9iX2RhdGEoY3R4LCBpdGVtKSkgPyBibG9iX2lucHV0KGN0eCwgb3RoZXIpIDoganNfaW5wdXRfYnVmZmVyKGN0eCwgaXRlbSk7CiAgICAgICAgc2l6ZSArPSBwYXJ0c1tpXS5zaXplOwogICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGl0ZW0pOwogICAgICB9CgogICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgIGlmKGJsb2Jfd3JpdGUoY3R4LCBibG9iLCBpbnB1dF9idWZmZXJfZGF0YSgmcGFydHNbaV0pLCBpbnB1dF9idWZmZXJfbGVuZ3RoKCZwYXJ0c1tpXSkpID09IC0xKSB7CiAgICAgICAgICB3aGlsZShpIDwgbGVuKSBpbnB1dF9idWZmZXJfZnJlZSgmcGFydHNbaSsrXSwgY3R4KTsKICAgICAgICAgIGJsb2JfZnJlZShjdHgsIGJsb2IpOwogICAgICAgICAgcmV0dXJuIEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJibG9iX3dyaXRlIHJldHVybmVkIC0xIik7CiAgICAgICAgfQoKICAgICAgICBpbnB1dF9idWZmZXJfZnJlZSgmcGFydHNbaV0sIGN0eCk7CiAgICAgIH0KICAgICAganNfZnJlZShjdHgsIHBhcnRzKTsKICAgIH0KCiAgICBpZihhcmdjID49IDIgJiYgSlNfSXNPYmplY3QoYXJndlsxXSkpIHsKICAgICAgSlNWYWx1ZSB0eXBlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBhcmd2WzFdLCAidHlwZSIpOwoKICAgICAgaWYoSlNfSXNTdHJpbmcodHlwZSkpCiAgICAgICAgYmxvYi0+dHlwZSA9IGpzX3Rvc3RyaW5nKGN0eCwgdHlwZSk7CiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHR5cGUpOwogICAgfQogICAgaWYoYmxvYi0+dHlwZSA9PSAwKQogICAgICBibG9iLT50eXBlID0ganNfc3RyZHVwKGN0eCwgImFwcGxpY2F0aW9uL2JpbmFyeSIpOwogIH0KCiAgSlNfU2V0T3BhcXVlKG9iaiwgYmxvYik7CgogIHJldHVybiBvYmo7CgpmYWlsOgogIGpzX2ZyZWUoY3R4LCBibG9iKTsKICBKU19GcmVlVmFsdWUoY3R4LCBvYmopOwogIHJldHVybiBKU19FWENFUFRJT047Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzX2Jsb2JfbWV0aG9kKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbWFnaWMpIHsKICBCbG9iKiBibG9iOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwoKICBpZighKGJsb2IgPSBqc19ibG9iX2RhdGEoY3R4LCB0aGlzX3ZhbCkpKQogICAgcmV0dXJuIEpTX0VYQ0VQVElPTjsKCiAgc3dpdGNoKG1hZ2ljKSB7CiAgICBjYXNlIEJMT0JfQVJSQVlCVUZGRVI6IHsKICAgICAgcmV0ID0ganNfYXJyYXlidWZmZXJfZnJvbXZhbHVlKGN0eCwgYmxvYi0+ZGF0YSwgYmxvYi0+c2l6ZSwgdGhpc192YWwpOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgQkxPQl9TTElDRTogewogICAgICBpbnQ2NF90IG4gPSBibG9iLT5zaXplLCBzID0gMCwgZSA9IElOVDY0X01BWDsKICAgICAgY2hhciogdHlwZSA9IDA7CgogICAgICBpZihhcmdjID49IDEpIHsKICAgICAgICBKU19Ub0ludDY0KGN0eCwgJnMsIGFyZ3ZbMF0pOwogICAgICAgIGlmKHMgPCAwKQogICAgICAgICAgcyA9IG4gKyBzICUgbjsKICAgICAgICBlbHNlIGlmKHMgPiBuKQogICAgICAgICAgcyA9IG47CgogICAgICAgIGlmKGFyZ2MgPj0gMikgewogICAgICAgICAgSlNfVG9JbnQ2NChjdHgsICZlLCBhcmd2WzFdKTsKICAgICAgICAgIGlmKGUgPCAwKQogICAgICAgICAgICBlID0gbiArIGUgJSBuOwogICAgICAgICAgZWxzZSBpZihlID4gbikKICAgICAgICAgICAgZSA9IG47CgogICAgICAgICAgaWYoYXJnYyA+PSAzKQogICAgICAgICAgICB0eXBlID0ganNfdG9zdHJpbmcoY3R4LCBhcmd2WzJdKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldCA9IGpzX2Jsb2JfbmV3KGN0eCwgJmJsb2ItPmRhdGFbc10sIGUgLSBzLCB0eXBlID8gdHlwZSA6IGJsb2ItPnR5cGUpOwogICAgICBpZih0eXBlKQogICAgICAgIGpzX2ZyZWUoY3R4LCB0eXBlKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEJMT0JfU1RSRUFNOiB7CiAgICAgIHJldCA9IEpTX1VOREVGSU5FRDsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEJMT0JfVEVYVDogewogICAgICByZXQgPSBKU19OZXdTdHJpbmdMZW4oY3R4LCBibG9iLT5kYXRhLCBibG9iLT5zaXplKTsKICAgICAgYnJlYWs7CiAgICB9CiAgfQogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzX2Jsb2JfaW5zcGVjdChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSkgewogIEJsb2IqIGJsb2I7CgogIGlmKCEoYmxvYiA9IGpzX2Jsb2JfZGF0YShjdHgsIHRoaXNfdmFsKSkpCiAgICByZXR1cm4gSlNfRVhDRVBUSU9OOwoKICBKU1ZhbHVlIG9iaiA9IEpTX05ld09iamVjdFByb3RvKGN0eCwgYmxvYl9wcm90byk7CiAgSlNfRGVmaW5lUHJvcGVydHlWYWx1ZVN0cihjdHgsIG9iaiwgInNpemUiLCBKU19OZXdVaW50MzIoY3R4LCBibG9iLT5zaXplKSwgSlNfUFJPUF9FTlVNRVJBQkxFKTsKICBKU19EZWZpbmVQcm9wZXJ0eVZhbHVlU3RyKGN0eCwgb2JqLCAidHlwZSIsIEpTX05ld1N0cmluZyhjdHgsIGJsb2ItPnR5cGUpLCBKU19QUk9QX0VOVU1FUkFCTEUpOwogIHJldHVybiBvYmo7Cn0KCnN0YXRpYyB2b2lkCmpzX2Jsb2JfZmluYWxpemVyKEpTUnVudGltZSogcnQsIEpTVmFsdWUgdmFsKSB7CiAgQmxvYiogYmxvYiA9IEpTX0dldE9wYXF1ZSh2YWwsIGpzX2Jsb2JfY2xhc3NfaWQpOwogIGlmKGJsb2IpIHsKICAgIGJsb2JfZnJlZV9ydChydCwgYmxvYik7CiAgfQogIEpTX0ZyZWVWYWx1ZVJUKHJ0LCB2YWwpOwp9CgpzdGF0aWMgSlNDbGFzc0RlZiBqc19ibG9iX2NsYXNzID0gewogICAgLmNsYXNzX25hbWUgPSAiQmxvYiIsCiAgICAuZmluYWxpemVyID0ganNfYmxvYl9maW5hbGl6ZXIsCn07CgpzdGF0aWMgY29uc3QgSlNDRnVuY3Rpb25MaXN0RW50cnkganNfYmxvYl9mdW5jc1tdID0gewogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJhcnJheUJ1ZmZlciIsIDAsIGpzX2Jsb2JfbWV0aG9kLCBCTE9CX0FSUkFZQlVGRkVSKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigic3RyZWFtIiwgMCwganNfYmxvYl9tZXRob2QsIEJMT0JfU1RSRUFNKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigic2xpY2UiLCAwLCBqc19ibG9iX21ldGhvZCwgQkxPQl9TTElDRSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoInRleHQiLCAwLCBqc19ibG9iX21ldGhvZCwgQkxPQl9URVhUKSwKICAgIEpTX0NHRVRTRVRfTUFHSUNfREVGKCJzaXplIiwganNfYmxvYl9nZXQsIDAsIEJMT0JfU0laRSksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigidHlwZSIsIGpzX2Jsb2JfZ2V0LCAwLCBCTE9CX1RZUEUpLAogICAgSlNfUFJPUF9TVFJJTkdfREVGKCJbU3ltYm9sLnRvU3RyaW5nVGFnXSIsICJCbG9iIiwgSlNfUFJPUF9DT05GSUdVUkFCTEUpLAp9OwoKaW50CmpzX2Jsb2JfaW5pdChKU0NvbnRleHQqIGN0eCwgSlNNb2R1bGVEZWYqIG0pIHsKCiAgaWYoanNfYmxvYl9jbGFzc19pZCA9PSAwKSB7CiAgICBKU19OZXdDbGFzc0lEKCZqc19ibG9iX2NsYXNzX2lkKTsKICAgIEpTX05ld0NsYXNzKEpTX0dldFJ1bnRpbWUoY3R4KSwganNfYmxvYl9jbGFzc19pZCwgJmpzX2Jsb2JfY2xhc3MpOwoKICAgIGJsb2JfY3RvciA9IEpTX05ld0NGdW5jdGlvbjIoY3R4LCBqc19ibG9iX2NvbnN0cnVjdG9yLCAiQmxvYiIsIDEsIEpTX0NGVU5DX2NvbnN0cnVjdG9yLCAwKTsKICAgIGJsb2JfcHJvdG8gPSBKU19OZXdPYmplY3QoY3R4KTsKCiAgICBKU19TZXRQcm9wZXJ0eUZ1bmN0aW9uTGlzdChjdHgsIGJsb2JfcHJvdG8sIGpzX2Jsb2JfZnVuY3MsIGNvdW50b2YoanNfYmxvYl9mdW5jcykpOwogICAgSlNfU2V0Q2xhc3NQcm90byhjdHgsIGpzX2Jsb2JfY2xhc3NfaWQsIGJsb2JfcHJvdG8pOwoKICAgIGpzX3NldF9pbnNwZWN0X21ldGhvZChjdHgsIGJsb2JfcHJvdG8sIGpzX2Jsb2JfaW5zcGVjdCk7CiAgfQoKICBpZihtKSB7CiAgICBKU19TZXRNb2R1bGVFeHBvcnQoY3R4LCBtLCAiQmxvYiIsIGJsb2JfY3Rvcik7CgogICAgY29uc3QgY2hhciogbW9kdWxlX25hbWUgPSBKU19BdG9tVG9DU3RyaW5nKGN0eCwgbS0+bW9kdWxlX25hbWUpOwoKICAgIGlmKCFzdHJjbXAobW9kdWxlX25hbWUsICJibG9iIikpCiAgICAgIEpTX1NldE1vZHVsZUV4cG9ydChjdHgsIG0sICJkZWZhdWx0IiwgYmxvYl9jdG9yKTsKCiAgICBKU19GcmVlQ1N0cmluZyhjdHgsIG1vZHVsZV9uYW1lKTsKICB9CgogIHJldHVybiAwOwp9CgojaWZkZWYgSlNfQkxPQl9NT0RVTEUKI2RlZmluZSBKU19JTklUX01PRFVMRSBqc19pbml0X21vZHVsZQojZWxzZQojZGVmaW5lIEpTX0lOSVRfTU9EVUxFIGpzX2luaXRfbW9kdWxlX2Jsb2IKI2VuZGlmCgpWSVNJQkxFIEpTTW9kdWxlRGVmKgpKU19JTklUX01PRFVMRShKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogbW9kdWxlX25hbWUpIHsKICBKU01vZHVsZURlZiogbTsKICBpZighKG0gPSBKU19OZXdDTW9kdWxlKGN0eCwgbW9kdWxlX25hbWUsICZqc19ibG9iX2luaXQpKSkKICAgIHJldHVybiBtOwogIEpTX0FkZE1vZHVsZUV4cG9ydChjdHgsIG0sICJCbG9iIik7CiAgaWYoIXN0cmNtcChtb2R1bGVfbmFtZSwgImJsb2IiKSkKICAgIEpTX0FkZE1vZHVsZUV4cG9ydChjdHgsIG0sICJkZWZhdWx0Iik7CiAgcmV0dXJuIG07Cn0KAAAAAAAAAAAjHwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAxQMAAAAAAADFAwAAAAAAAAAAAAAAAPC/"
				],
				[
					85,
					1,
					"insert",
					{
						"characters": "/"
					},
					"AQAAAJ0XAAAAAAAAnhcAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAnRcAAAAAAACdFwAAAAAAAAAAAAAAAPC/"
				],
				[
					86,
					1,
					"left_delete",
					null,
					"AQAAAJ0XAAAAAAAAnRcAAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAAnhcAAAAAAACeFwAAAAAAAAAAAAAAAPC/"
				],
				[
					91,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAALwXAAAAAAAAvRcAAAAAAAAAAAAAvRcAAAAAAAC+FwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAvBcAAAAAAAC8FwAAAAAAAAAAAAAAADRA"
				],
				[
					95,
					2,
					"left_delete",
					null,
					"AgAAAL0XAAAAAAAAvRcAAAAAAAABAAAAL7wXAAAAAAAAvBcAAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAAvhcAAAAAAAC+FwAAAAAAAAAAAAAAAPC/"
				],
				[
					114,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAACYcAAAAAAAAJxwAAAAAAAAAAAAAJxwAAAAAAAAoHAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAJhwAAAAAAAAmHAAAAAAAAAAAAAAAAD5A"
				],
				[
					122,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAAMseAAAAAAAAzB4AAAAAAAAAAAAAzB4AAAAAAADOHgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAyx4AAAAAAADLHgAAAAAAAAAAAAAAAPC/"
				],
				[
					124,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAABwfAAAAAAAAHR8AAAAAAAAAAAAAHR8AAAAAAAAfHwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAHB8AAAAAAAAcHwAAAAAAAAAAAAAAADRA"
				],
				[
					262,
					1,
					"cut",
					null,
					"AQAAAOgOAAAAAAAA6A4AAAAAAAAbAAAAICAgICAganNfZnJlZShjdHgsIHBhcnRzKTsK",
					"AQAAAAAAAAABAAAA6A4AAAAAAAADDwAAAAAAAAAAAAAAAPC/"
				],
				[
					263,
					1,
					"paste",
					null,
					"AQAAAOgOAAAAAAAAAw8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA6A4AAAAAAADoDgAAAAAAAAAAAAAAAPC/"
				],
				[
					266,
					1,
					"paste",
					null,
					"AQAAAGoOAAAAAAAAhQ4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAag4AAAAAAABqDgAAAAAAAAAAAAAAAPC/"
				],
				[
					499,
					1,
					"cut",
					null,
					"AQAAAOoLAAAAAAAA6gsAAAAAAAAgAAAAID0ganNfYXJyYXlfbGVuZ3RoKGN0eCwgYXJndlswXSk",
					"AQAAAAAAAAABAAAA6gsAAAAAAAAKDAAAAAAAAAAAAAAAAPC/"
				],
				[
					500,
					1,
					"paste",
					null,
					"AQAAAOoLAAAAAAAACgwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA6gsAAAAAAADqCwAAAAAAAAAAAAAAAPC/"
				],
				[
					522,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAANsLAAAAAAAA3AsAAAAAAAAAAAAA3AsAAAAAAADiCwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA2wsAAAAAAADbCwAAAAAAAAAAAAAAAPC/"
				],
				[
					524,
					1,
					"insert",
					{
						"characters": "if"
					},
					"AgAAANsLAAAAAAAA3AsAAAAAAAAAAAAA3AsAAAAAAADdCwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA2wsAAAAAAADbCwAAAAAAAAAAAAAAAE5A"
				],
				[
					525,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAN0LAAAAAAAA3wsAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA3QsAAAAAAADdCwAAAAAAAAAAAAAAAPC/"
				],
				[
					526,
					1,
					"insert",
					{
						"characters": "JS_i"
					},
					"BAAAAN4LAAAAAAAA3wsAAAAAAAAAAAAA3wsAAAAAAADgCwAAAAAAAAAAAADgCwAAAAAAAOELAAAAAAAAAAAAAOELAAAAAAAA4gsAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA3gsAAAAAAADeCwAAAAAAAAAAAAAAAPC/"
				],
				[
					527,
					1,
					"left_delete",
					null,
					"AQAAAOELAAAAAAAA4QsAAAAAAAABAAAAaQ",
					"AQAAAAAAAAABAAAA4gsAAAAAAADiCwAAAAAAAAAAAAAAAPC/"
				],
				[
					528,
					1,
					"insert",
					{
						"characters": "IsA"
					},
					"AwAAAOELAAAAAAAA4gsAAAAAAAAAAAAA4gsAAAAAAADjCwAAAAAAAAAAAADjCwAAAAAAAOQLAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA4QsAAAAAAADhCwAAAAAAAAAAAAAAAPC/"
				],
				[
					529,
					6,
					"left_delete",
					null,
					"BgAAAOMLAAAAAAAA4wsAAAAAAAABAAAAQeILAAAAAAAA4gsAAAAAAAABAAAAc+ELAAAAAAAA4QsAAAAAAAABAAAASeALAAAAAAAA4AsAAAAAAAABAAAAX98LAAAAAAAA3wsAAAAAAAABAAAAU94LAAAAAAAA3gsAAAAAAAABAAAASg",
					"AQAAAAAAAAABAAAA5AsAAAAAAADkCwAAAAAAAAAAAAAAAPC/"
				],
				[
					534,
					1,
					"paste",
					null,
					"AQAAAN4LAAAAAAAA6QsAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA3gsAAAAAAADeCwAAAAAAAAAAAAAAAPC/"
				],
				[
					535,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAOkLAAAAAAAA6wsAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA6QsAAAAAAADpCwAAAAAAAAAAAAAAAPC/"
				],
				[
					536,
					1,
					"insert",
					{
						"characters": "ctx,"
					},
					"BAAAAOoLAAAAAAAA6wsAAAAAAAAAAAAA6wsAAAAAAADsCwAAAAAAAAAAAADsCwAAAAAAAO0LAAAAAAAAAAAAAO0LAAAAAAAA7gsAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA6gsAAAAAAADqCwAAAAAAAAAAAAAAAPC/"
				],
				[
					537,
					1,
					"insert",
					{
						"characters": " argv"
					},
					"BQAAAO4LAAAAAAAA7wsAAAAAAAAAAAAA7wsAAAAAAADwCwAAAAAAAAAAAADwCwAAAAAAAPELAAAAAAAAAAAAAPELAAAAAAAA8gsAAAAAAAAAAAAA8gsAAAAAAADzCwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA7gsAAAAAAADuCwAAAAAAAAAAAAAAAPC/"
				],
				[
					538,
					1,
					"insert_snippet",
					{
						"contents": "[$0]"
					},
					"AQAAAPMLAAAAAAAA9QsAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA8wsAAAAAAADzCwAAAAAAAAAAAAAAAPC/"
				],
				[
					539,
					1,
					"insert",
					{
						"characters": "0"
					},
					"AQAAAPQLAAAAAAAA9QsAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA9AsAAAAAAAD0CwAAAAAAAAAAAAAAAPC/"
				],
				[
					541,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAPgLAAAAAAAA+QsAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA+AsAAAAAAAD4CwAAAAAAAAAAAAAAAPC/"
				],
				[
					542,
					1,
					"insert_snippet",
					{
						"contents": "{$0}"
					},
					"AQAAAPkLAAAAAAAA+wsAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA+QsAAAAAAAD5CwAAAAAAAAAAAAAAAPC/"
				],
				[
					543,
					1,
					"right_delete",
					null,
					"AQAAAPoLAAAAAAAA+gsAAAAAAAABAAAAfQ",
					"AQAAAAAAAAABAAAA+gsAAAAAAAD6CwAAAAAAAAAAAAAAAPC/"
				],
				[
					548,
					1,
					"insert",
					{
						"characters": "\n}"
					},
					"BQAAAEMPAAAAAAAARA8AAAAAAAAAAAAARA8AAAAAAABKDwAAAAAAAAAAAABKDwAAAAAAAEsPAAAAAAAAAAAAAEQPAAAAAAAARA8AAAAAAAAGAAAAICAgICAgRA8AAAAAAABIDwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAQw8AAAAAAABDDwAAAAAAAAAAAAAAAPC/"
				],
				[
					549,
					1,
					"insert",
					{
						"characters": " else"
					},
					"BQAAAEkPAAAAAAAASg8AAAAAAAAAAAAASg8AAAAAAABLDwAAAAAAAAAAAABLDwAAAAAAAEwPAAAAAAAAAAAAAEwPAAAAAAAATQ8AAAAAAAAAAAAATQ8AAAAAAABODwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAASQ8AAAAAAABJDwAAAAAAAAAAAAAAAPC/"
				],
				[
					550,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAE4PAAAAAAAATw8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATg8AAAAAAABODwAAAAAAAAAAAAAAAPC/"
				],
				[
					551,
					1,
					"insert_snippet",
					{
						"contents": "{$0}"
					},
					"AQAAAE8PAAAAAAAAUQ8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATw8AAAAAAABPDwAAAAAAAAAAAAAAAPC/"
				],
				[
					552,
					1,
					"run_macro_file",
					{
						"file": "res://Packages/Default/Add Line in Braces.sublime-macro"
					},
					"BgAAAFAPAAAAAAAAUQ8AAAAAAAAAAAAAUQ8AAAAAAABVDwAAAAAAAAAAAABVDwAAAAAAAFYPAAAAAAAAAAAAAFYPAAAAAAAAWg8AAAAAAAAAAAAAUQ8AAAAAAABRDwAAAAAAAAQAAAAgICAgUQ8AAAAAAABXDwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAUA8AAAAAAABQDwAAAAAAAAAAAAAAAPC/"
				],
				[
					553,
					1,
					"insert",
					{
						"characters": "JS_ThrowInternal"
					},
					"EAAAAFcPAAAAAAAAWA8AAAAAAAAAAAAAWA8AAAAAAABZDwAAAAAAAAAAAABZDwAAAAAAAFoPAAAAAAAAAAAAAFoPAAAAAAAAWw8AAAAAAAAAAAAAWw8AAAAAAABcDwAAAAAAAAAAAABcDwAAAAAAAF0PAAAAAAAAAAAAAF0PAAAAAAAAXg8AAAAAAAAAAAAAXg8AAAAAAABfDwAAAAAAAAAAAABfDwAAAAAAAGAPAAAAAAAAAAAAAGAPAAAAAAAAYQ8AAAAAAAAAAAAAYQ8AAAAAAABiDwAAAAAAAAAAAABiDwAAAAAAAGMPAAAAAAAAAAAAAGMPAAAAAAAAZA8AAAAAAAAAAAAAZA8AAAAAAABlDwAAAAAAAAAAAABlDwAAAAAAAGYPAAAAAAAAAAAAAGYPAAAAAAAAZw8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAVw8AAAAAAABXDwAAAAAAAAAAAAAAAPC/"
				],
				[
					554,
					1,
					"insert",
					{
						"characters": "Error"
					},
					"BQAAAGcPAAAAAAAAaA8AAAAAAAAAAAAAaA8AAAAAAABpDwAAAAAAAAAAAABpDwAAAAAAAGoPAAAAAAAAAAAAAGoPAAAAAAAAaw8AAAAAAAAAAAAAaw8AAAAAAABsDwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAZw8AAAAAAABnDwAAAAAAAAAAAAAAAPC/"
				],
				[
					555,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAGwPAAAAAAAAbg8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbA8AAAAAAABsDwAAAAAAAAAAAAAAAPC/"
				],
				[
					556,
					1,
					"insert",
					{
						"characters": "ctx,"
					},
					"BAAAAG0PAAAAAAAAbg8AAAAAAAAAAAAAbg8AAAAAAABvDwAAAAAAAAAAAABvDwAAAAAAAHAPAAAAAAAAAAAAAHAPAAAAAAAAcQ8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbQ8AAAAAAABtDwAAAAAAAAAAAAAAAPC/"
				],
				[
					557,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAHEPAAAAAAAAcg8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcQ8AAAAAAABxDwAAAAAAAAAAAAAAAPC/"
				],
				[
					558,
					1,
					"insert_snippet",
					{
						"contents": "\"$0\""
					},
					"AQAAAHIPAAAAAAAAdA8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcg8AAAAAAAByDwAAAAAAAAAAAAAAAPC/"
				],
				[
					559,
					1,
					"insert",
					{
						"characters": "Blob"
					},
					"BAAAAHMPAAAAAAAAdA8AAAAAAAAAAAAAdA8AAAAAAAB1DwAAAAAAAAAAAAB1DwAAAAAAAHYPAAAAAAAAAAAAAHYPAAAAAAAAdw8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcw8AAAAAAABzDwAAAAAAAAAAAAAAAPC/"
				],
				[
					560,
					1,
					"insert",
					{
						"characters": " constructor:"
					},
					"DQAAAHcPAAAAAAAAeA8AAAAAAAAAAAAAeA8AAAAAAAB5DwAAAAAAAAAAAAB5DwAAAAAAAHoPAAAAAAAAAAAAAHoPAAAAAAAAew8AAAAAAAAAAAAAew8AAAAAAAB8DwAAAAAAAAAAAAB8DwAAAAAAAH0PAAAAAAAAAAAAAH0PAAAAAAAAfg8AAAAAAAAAAAAAfg8AAAAAAAB/DwAAAAAAAAAAAAB/DwAAAAAAAIAPAAAAAAAAAAAAAIAPAAAAAAAAgQ8AAAAAAAAAAAAAgQ8AAAAAAACCDwAAAAAAAAAAAACCDwAAAAAAAIMPAAAAAAAAAAAAAIMPAAAAAAAAhA8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAdw8AAAAAAAB3DwAAAAAAAAAAAAAAAPC/"
				],
				[
					561,
					1,
					"insert",
					{
						"characters": " argu"
					},
					"BQAAAIQPAAAAAAAAhQ8AAAAAAAAAAAAAhQ8AAAAAAACGDwAAAAAAAAAAAACGDwAAAAAAAIcPAAAAAAAAAAAAAIcPAAAAAAAAiA8AAAAAAAAAAAAAiA8AAAAAAACJDwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAhA8AAAAAAACEDwAAAAAAAAAAAAAAAPC/"
				],
				[
					562,
					22,
					"left_delete",
					null,
					"FgAAAIgPAAAAAAAAiA8AAAAAAAABAAAAdYcPAAAAAAAAhw8AAAAAAAABAAAAZ4YPAAAAAAAAhg8AAAAAAAABAAAAcoUPAAAAAAAAhQ8AAAAAAAABAAAAYYQPAAAAAAAAhA8AAAAAAAABAAAAIIMPAAAAAAAAgw8AAAAAAAABAAAAOoIPAAAAAAAAgg8AAAAAAAABAAAAcoEPAAAAAAAAgQ8AAAAAAAABAAAAb4APAAAAAAAAgA8AAAAAAAABAAAAdH8PAAAAAAAAfw8AAAAAAAABAAAAY34PAAAAAAAAfg8AAAAAAAABAAAAdX0PAAAAAAAAfQ8AAAAAAAABAAAAcnwPAAAAAAAAfA8AAAAAAAABAAAAdHsPAAAAAAAAew8AAAAAAAABAAAAc3oPAAAAAAAAeg8AAAAAAAABAAAAbnkPAAAAAAAAeQ8AAAAAAAABAAAAb3gPAAAAAAAAeA8AAAAAAAABAAAAY3cPAAAAAAAAdw8AAAAAAAABAAAAIHYPAAAAAAAAdg8AAAAAAAABAAAAYnUPAAAAAAAAdQ8AAAAAAAABAAAAb3QPAAAAAAAAdA8AAAAAAAABAAAAbHMPAAAAAAAAcw8AAAAAAAABAAAAQg",
					"AQAAAAAAAAABAAAAiQ8AAAAAAACJDwAAAAAAAAAAAAAAAPC/"
				],
				[
					563,
					1,
					"run_macro_file",
					{
						"file": "res://Packages/Default/Delete Left Right.sublime-macro"
					},
					"AgAAAHIPAAAAAAAAcg8AAAAAAAABAAAAInIPAAAAAAAAcg8AAAAAAAABAAAAIg",
					"AQAAAAAAAAABAAAAcw8AAAAAAABzDwAAAAAAAAAAAAAAAPC/"
				],
				[
					564,
					1,
					"insert",
					{
						"characters": "a"
					},
					"AQAAAHIPAAAAAAAAcw8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcg8AAAAAAAByDwAAAAAAAAAAAAAAAPC/"
				],
				[
					565,
					1,
					"left_delete",
					null,
					"AQAAAHIPAAAAAAAAcg8AAAAAAAABAAAAYQ",
					"AQAAAAAAAAABAAAAcw8AAAAAAABzDwAAAAAAAAAAAAAAAPC/"
				],
				[
					566,
					1,
					"insert_snippet",
					{
						"contents": "\"$0\""
					},
					"AQAAAHIPAAAAAAAAdA8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcg8AAAAAAAByDwAAAAAAAAAAAAAAAPC/"
				],
				[
					567,
					1,
					"insert",
					{
						"characters": "argument"
					},
					"CAAAAHMPAAAAAAAAdA8AAAAAAAAAAAAAdA8AAAAAAAB1DwAAAAAAAAAAAAB1DwAAAAAAAHYPAAAAAAAAAAAAAHYPAAAAAAAAdw8AAAAAAAAAAAAAdw8AAAAAAAB4DwAAAAAAAAAAAAB4DwAAAAAAAHkPAAAAAAAAAAAAAHkPAAAAAAAAeg8AAAAAAAAAAAAAeg8AAAAAAAB7DwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcw8AAAAAAABzDwAAAAAAAAAAAAAAAPC/"
				],
				[
					568,
					1,
					"insert",
					{
						"characters": " 1"
					},
					"AgAAAHsPAAAAAAAAfA8AAAAAAAAAAAAAfA8AAAAAAAB9DwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAew8AAAAAAAB7DwAAAAAAAAAAAAAAAPC/"
				],
				[
					569,
					1,
					"insert",
					{
						"characters": " must"
					},
					"BQAAAH0PAAAAAAAAfg8AAAAAAAAAAAAAfg8AAAAAAAB/DwAAAAAAAAAAAAB/DwAAAAAAAIAPAAAAAAAAAAAAAIAPAAAAAAAAgQ8AAAAAAAAAAAAAgQ8AAAAAAACCDwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAfQ8AAAAAAAB9DwAAAAAAAAAAAAAAAPC/"
				],
				[
					570,
					1,
					"insert",
					{
						"characters": " be"
					},
					"AwAAAIIPAAAAAAAAgw8AAAAAAAAAAAAAgw8AAAAAAACEDwAAAAAAAAAAAACEDwAAAAAAAIUPAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAgg8AAAAAAACCDwAAAAAAAAAAAAAAAPC/"
				],
				[
					571,
					1,
					"insert",
					{
						"characters": " array"
					},
					"BgAAAIUPAAAAAAAAhg8AAAAAAAAAAAAAhg8AAAAAAACHDwAAAAAAAAAAAACHDwAAAAAAAIgPAAAAAAAAAAAAAIgPAAAAAAAAiQ8AAAAAAAAAAAAAiQ8AAAAAAACKDwAAAAAAAAAAAACKDwAAAAAAAIsPAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAhQ8AAAAAAACFDwAAAAAAAAAAAAAAAPC/"
				],
				[
					572,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAIsPAAAAAAAAjA8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAiw8AAAAAAACLDwAAAAAAAAAAAAAAAPC/"
				],
				[
					573,
					1,
					"left_delete",
					null,
					"AQAAAIsPAAAAAAAAiw8AAAAAAAABAAAAIA",
					"AQAAAAAAAAABAAAAjA8AAAAAAACMDwAAAAAAAAAAAAAAAPC/"
				],
				[
					575,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAAI0PAAAAAAAAjg8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAjQ8AAAAAAACNDwAAAAAAAAAAAAAAAPC/"
				],
				[
					576,
					1,
					"insert",
					{
						"characters": "\ngoto"
					},
					"BgAAAI4PAAAAAAAAjw8AAAAAAAAAAAAAjw8AAAAAAACVDwAAAAAAAAAAAACVDwAAAAAAAJYPAAAAAAAAAAAAAJYPAAAAAAAAlw8AAAAAAAAAAAAAlw8AAAAAAACYDwAAAAAAAAAAAACYDwAAAAAAAJkPAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAjg8AAAAAAACODwAAAAAAAAAAAAAAAPC/"
				],
				[
					577,
					1,
					"insert",
					{
						"characters": " fail;"
					},
					"BgAAAJkPAAAAAAAAmg8AAAAAAAAAAAAAmg8AAAAAAACbDwAAAAAAAAAAAACbDwAAAAAAAJwPAAAAAAAAAAAAAJwPAAAAAAAAnQ8AAAAAAAAAAAAAnQ8AAAAAAACeDwAAAAAAAAAAAACeDwAAAAAAAJ8PAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmQ8AAAAAAACZDwAAAAAAAAAAAAAAAPC/"
				],
				[
					581,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAADOHwAAI2lmbmRlZiBfR05VX1NPVVJDRQojZGVmaW5lIF9HTlVfU09VUkNFCiNlbmRpZgoKI2luY2x1ZGUgInF1aWNranMtYmxvYi5oIgojaW5jbHVkZSAidXRpbHMuaCIKI2luY2x1ZGUgImJ1ZmZlci11dGlscy5oIgoKI2RlZmluZSBtYXgoYSwgYikgKChhKSA+IChiKSA/IChhKSA6IChiKSkKCnRocmVhZF9sb2NhbCBWSVNJQkxFIEpTQ2xhc3NJRCBqc19ibG9iX2NsYXNzX2lkID0gMDsKdGhyZWFkX2xvY2FsIEpTVmFsdWUgYmxvYl9wcm90byA9IHtKU19UQUdfVU5ERUZJTkVEfSwgYmxvYl9jdG9yID0ge0pTX1RBR19VTkRFRklORUR9OwoKZW51bSB7IEJMT0JfU0laRSwgQkxPQl9UWVBFIH07CmVudW0geyBCTE9CX0FSUkFZQlVGRkVSLCBCTE9CX1NMSUNFLCBCTE9CX1NUUkVBTSwgQkxPQl9URVhUIH07CgpCbG9iKgpibG9iX25ldyhKU0NvbnRleHQqIGN0eCwgY29uc3Qgdm9pZCogeCwgc2l6ZV90IGxlbiwgY29uc3QgY2hhciogdHlwZSkgewogIEJsb2IqIGJsb2I7CgogIGlmKCEoYmxvYiA9IGpzX21hbGxvY3ooY3R4LCBzaXplb2YoQmxvYikpKSkKICAgIHJldHVybiAwOwoKICBibG9iLT52ZWMgPSBWRUNUT1IoY3R4KTsKICBpZih4KSB7CiAgICB2ZWN0b3JfYWxsb2NhdGUoJmJsb2ItPnZlYywgMSwgbGVuIC0gMSk7CiAgICBtZW1jcHkoYmxvYi0+dmVjLmRhdGEsIHgsIGxlbik7CiAgfQoKICBibG9iLT50eXBlID0ganNfc3RyZHVwKGN0eCwgdHlwZSk7CiAgcmV0dXJuIGJsb2I7Cn0KCnNzaXplX3QKYmxvYl93cml0ZShKU0NvbnRleHQqIGN0eCwgQmxvYiogYmxvYiwgY29uc3Qgdm9pZCogeCwgc2l6ZV90IGxlbikgewogIHVpbnQ4X3QqIHB0cjsKICBpZigocHRyID0gdmVjdG9yX3B1dCgmYmxvYi0+dmVjLCB4LCBsZW4pKSkKICAgIHJldHVybiBsZW47CiAgcmV0dXJuIC0xOwp9Cgp2b2lkCmJsb2JfZnJlZShKU0NvbnRleHQqIGN0eCwgQmxvYiogYmxvYikgewogIGlmKGJsb2ItPnZlYy5kYXRhKQogICAgdmVjdG9yX2ZyZWUoJmJsb2ItPnZlYyk7CiAganNfZnJlZShjdHgsIGJsb2IpOwp9CgpzdGF0aWMgdm9pZApibG9iX2ZyZWVfcnQoSlNSdW50aW1lKiBydCwgQmxvYiogYmxvYikgewogIGlmKGJsb2ItPnZlYy5kYXRhKQogICAgdmVjdG9yX2ZyZWUoJmJsb2ItPnZlYyk7CiAganNfZnJlZV9ydChydCwgYmxvYik7Cn0KCklucHV0QnVmZmVyCmJsb2JfaW5wdXQoSlNDb250ZXh0KiBjdHgsIEJsb2IqIGJsb2IpIHsKICBJbnB1dEJ1ZmZlciByZXQgPSB7YmxvYi0+ZGF0YSwgMCwgYmxvYi0+c2l6ZSwgJmlucHV0X2J1ZmZlcl9mcmVlX2RlZmF1bHQsIEpTX1VOREVGSU5FRCwgMCwgSU5UNjRfTUFYfTsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgdm9pZApqc19ibG9iX2ZyZWVfZnVuYyhKU1J1bnRpbWUqIHJ0LCB2b2lkKiBvcGFxdWUsIHZvaWQqIHB0cikgewogIC8vIGpzX2ZyZWVfcnQocnQsIHB0cik7Cn0KCkpTVmFsdWUKanNfYmxvYl93cmFwKEpTQ29udGV4dCogY3R4LCBCbG9iKiBibG9iKSB7CiAgSlNWYWx1ZSBvYmo7CiAgb2JqID0gSlNfTmV3T2JqZWN0UHJvdG9DbGFzcyhjdHgsIGJsb2JfcHJvdG8sIGpzX2Jsb2JfY2xhc3NfaWQpOwogIEpTX1NldE9wYXF1ZShvYmosIGJsb2IpOwogIHJldHVybiBvYmo7Cn0KCkpTVmFsdWUKanNfYmxvYl9uZXcoSlNDb250ZXh0KiBjdHgsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBsZW4sIGNvbnN0IGNoYXIqIHR5cGUpIHsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBibG9iX25ldyhjdHgsIHgsIGxlbiwgdHlwZSkpKQogICAgcmV0dXJuIEpTX1Rocm93T3V0T2ZNZW1vcnkoY3R4KTsKCiAgcmV0dXJuIGpzX2Jsb2Jfd3JhcChjdHgsIGJsb2IpOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc19ibG9iX2dldChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgbWFnaWMpIHsKICBCbG9iKiBibG9iOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwogIGlmKCEoYmxvYiA9IGpzX2Jsb2JfZGF0YShjdHgsIHRoaXNfdmFsKSkpCiAgICByZXR1cm4gcmV0OwogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBCTE9CX1NJWkU6IHsKICAgICAgcmV0ID0gSlNfTmV3VWludDMyKGN0eCwgYmxvYi0+c2l6ZSk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgQkxPQl9UWVBFOiB7CiAgICAgIHJldCA9IEpTX05ld1N0cmluZyhjdHgsIGJsb2ItPnR5cGUpOwogICAgICBicmVhazsKICAgIH0KICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNfYmxvYl9jb25zdHJ1Y3RvcihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG5ld190YXJnZXQsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgSlNWYWx1ZSBvYmogPSBKU19VTkRFRklORUQ7CiAgSlNWYWx1ZSBwcm90bzsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBqc19tYWxsb2N6KGN0eCwgc2l6ZW9mKEJsb2IpKSkpCiAgICByZXR1cm4gSlNfVGhyb3dPdXRPZk1lbW9yeShjdHgpOwoKICAvKiB1c2luZyBuZXdfdGFyZ2V0IHRvIGdldCB0aGUgcHJvdG90eXBlIGlzIG5lY2Vzc2FyeSB3aGVuIHRoZQogICAgIGNsYXNzIGlzIGV4dGVuZGVkLiAqLwogIHByb3RvID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBuZXdfdGFyZ2V0LCAicHJvdG90eXBlIik7CiAgaWYoSlNfSXNFeGNlcHRpb24ocHJvdG8pKQogICAgZ290byBmYWlsOwogIGlmKCFKU19Jc09iamVjdChwcm90bykpCiAgICBwcm90byA9IGJsb2JfcHJvdG87CgogIC8qIHVzaW5nIG5ld190YXJnZXQgdG8gZ2V0IHRoZSBwcm90b3R5cGUgaXMgbmVjZXNzYXJ5IHdoZW4gdGhlCiAgICAgY2xhc3MgaXMgZXh0ZW5kZWQuICovCiAgb2JqID0gSlNfTmV3T2JqZWN0UHJvdG9DbGFzcyhjdHgsIHByb3RvLCBqc19ibG9iX2NsYXNzX2lkKTsKICBpZihKU19Jc0V4Y2VwdGlvbihvYmopKQogICAgZ290byBmYWlsOwoKICBibG9iLT52ZWMgPSBWRUNUT1IoY3R4KTsKCiAgewogICAgdWludDhfdCogcHRyOwogICAgc2l6ZV90IHNpemUgPSAwLCBvZmZzID0gMDsKICAgIGJsb2ItPnR5cGUgPSAwOwoKICAgIGlmKGFyZ2MgPj0gMSkgewogICAgICBpZihqc19pc19hcnJheShjdHgsIGFyZ3ZbMF0pKSB7CiAgICAgIHVpbnQzMl90IGksIGxlbiA9IGpzX2FycmF5X2xlbmd0aChjdHgsIGFyZ3ZbMF0pOwogICAgICBJbnB1dEJ1ZmZlciogcGFydHMgPSBqc19tYWxsb2MoY3R4LCBzaXplb2YoSW5wdXRCdWZmZXIpICogbGVuKTsKCiAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgQmxvYiogb3RoZXI7CiAgICAgICAgSlNWYWx1ZSBpdGVtID0gSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCBhcmd2WzBdLCBpKTsKICAgICAgICBwYXJ0c1tpXSA9IChvdGhlciA9IGpzX2Jsb2JfZGF0YShjdHgsIGl0ZW0pKSA/IGJsb2JfaW5wdXQoY3R4LCBvdGhlcikgOiBqc19pbnB1dF9idWZmZXIoY3R4LCBpdGVtKTsKICAgICAgICBzaXplICs9IHBhcnRzW2ldLnNpemU7CiAgICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgaXRlbSk7CiAgICAgIH0KCiAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgaWYoYmxvYl93cml0ZShjdHgsIGJsb2IsIGlucHV0X2J1ZmZlcl9kYXRhKCZwYXJ0c1tpXSksIGlucHV0X2J1ZmZlcl9sZW5ndGgoJnBhcnRzW2ldKSkgPT0gLTEpIHsKICAgICAgICAgIHdoaWxlKGkgPCBsZW4pIGlucHV0X2J1ZmZlcl9mcmVlKCZwYXJ0c1tpKytdLCBjdHgpOwogICAgICAgICAgYmxvYl9mcmVlKGN0eCwgYmxvYik7CiAgICAgICAgICAgICBqc19mcmVlKGN0eCwgcGFydHMpOwogICByZXR1cm4gSlNfVGhyb3dJbnRlcm5hbEVycm9yKGN0eCwgImJsb2Jfd3JpdGUgcmV0dXJuZWQgLTEiKTsKICAgICAgICB9CgogICAgICAgIGlucHV0X2J1ZmZlcl9mcmVlKCZwYXJ0c1tpXSwgY3R4KTsKICAgICAgfQogICAgICBqc19mcmVlKGN0eCwgcGFydHMpOwogICAgfSBlbHNlIHsKICAgICAgSlNfVGhyb3dJbnRlcm5hbEVycm9yKGN0eCwgImFyZ3VtZW50IDEgbXVzdCBiZSBhcnJheSIpOwogICAgICBnb3RvIGZhaWw7CiAgICB9CiAgICB9CgogICAgaWYoYXJnYyA+PSAyICYmIEpTX0lzT2JqZWN0KGFyZ3ZbMV0pKSB7CiAgICAgIEpTVmFsdWUgdHlwZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgYXJndlsxXSwgInR5cGUiKTsKCiAgICAgIGlmKEpTX0lzU3RyaW5nKHR5cGUpKQogICAgICAgIGJsb2ItPnR5cGUgPSBqc190b3N0cmluZyhjdHgsIHR5cGUpOwogICAgICBKU19GcmVlVmFsdWUoY3R4LCB0eXBlKTsKICAgIH0KICAgIGlmKGJsb2ItPnR5cGUgPT0gMCkKICAgICAgYmxvYi0+dHlwZSA9IGpzX3N0cmR1cChjdHgsICJhcHBsaWNhdGlvbi9iaW5hcnkiKTsKICB9CgogIEpTX1NldE9wYXF1ZShvYmosIGJsb2IpOwoKICByZXR1cm4gb2JqOwoKZmFpbDoKICBqc19mcmVlKGN0eCwgYmxvYik7CiAgSlNfRnJlZVZhbHVlKGN0eCwgb2JqKTsKICByZXR1cm4gSlNfRVhDRVBUSU9OOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc19ibG9iX21ldGhvZChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSwgaW50IG1hZ2ljKSB7CiAgQmxvYiogYmxvYjsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKCiAgaWYoIShibG9iID0ganNfYmxvYl9kYXRhKGN0eCwgdGhpc192YWwpKSkKICAgIHJldHVybiBKU19FWENFUFRJT047CgogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBCTE9CX0FSUkFZQlVGRkVSOiB7CiAgICAgIHJldCA9IGpzX2FycmF5YnVmZmVyX2Zyb212YWx1ZShjdHgsIGJsb2ItPmRhdGEsIGJsb2ItPnNpemUsIHRoaXNfdmFsKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEJMT0JfU0xJQ0U6IHsKICAgICAgaW50NjRfdCBuID0gYmxvYi0+c2l6ZSwgcyA9IDAsIGUgPSBJTlQ2NF9NQVg7CiAgICAgIGNoYXIqIHR5cGUgPSAwOwoKICAgICAgaWYoYXJnYyA+PSAxKSB7CiAgICAgICAgSlNfVG9JbnQ2NChjdHgsICZzLCBhcmd2WzBdKTsKICAgICAgICBpZihzIDwgMCkKICAgICAgICAgIHMgPSBuICsgcyAlIG47CiAgICAgICAgZWxzZSBpZihzID4gbikKICAgICAgICAgIHMgPSBuOwoKICAgICAgICBpZihhcmdjID49IDIpIHsKICAgICAgICAgIEpTX1RvSW50NjQoY3R4LCAmZSwgYXJndlsxXSk7CiAgICAgICAgICBpZihlIDwgMCkKICAgICAgICAgICAgZSA9IG4gKyBlICUgbjsKICAgICAgICAgIGVsc2UgaWYoZSA+IG4pCiAgICAgICAgICAgIGUgPSBuOwoKICAgICAgICAgIGlmKGFyZ2MgPj0gMykKICAgICAgICAgICAgdHlwZSA9IGpzX3Rvc3RyaW5nKGN0eCwgYXJndlsyXSk7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXQgPSBqc19ibG9iX25ldyhjdHgsICZibG9iLT5kYXRhW3NdLCBlIC0gcywgdHlwZSA/IHR5cGUgOiBibG9iLT50eXBlKTsKICAgICAgaWYodHlwZSkKICAgICAgICBqc19mcmVlKGN0eCwgdHlwZSk7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBCTE9CX1NUUkVBTTogewogICAgICByZXQgPSBKU19VTkRFRklORUQ7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBCTE9CX1RFWFQ6IHsKICAgICAgcmV0ID0gSlNfTmV3U3RyaW5nTGVuKGN0eCwgYmxvYi0+ZGF0YSwgYmxvYi0+c2l6ZSk7CiAgICAgIGJyZWFrOwogICAgfQogIH0KICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgSlNWYWx1ZQpqc19ibG9iX2luc3BlY3QoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10pIHsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBqc19ibG9iX2RhdGEoY3R4LCB0aGlzX3ZhbCkpKQogICAgcmV0dXJuIEpTX0VYQ0VQVElPTjsKCiAgSlNWYWx1ZSBvYmogPSBKU19OZXdPYmplY3RQcm90byhjdHgsIGJsb2JfcHJvdG8pOwogIEpTX0RlZmluZVByb3BlcnR5VmFsdWVTdHIoY3R4LCBvYmosICJzaXplIiwgSlNfTmV3VWludDMyKGN0eCwgYmxvYi0+c2l6ZSksIEpTX1BST1BfRU5VTUVSQUJMRSk7CiAgSlNfRGVmaW5lUHJvcGVydHlWYWx1ZVN0cihjdHgsIG9iaiwgInR5cGUiLCBKU19OZXdTdHJpbmcoY3R4LCBibG9iLT50eXBlKSwgSlNfUFJPUF9FTlVNRVJBQkxFKTsKICByZXR1cm4gb2JqOwp9CgpzdGF0aWMgdm9pZApqc19ibG9iX2ZpbmFsaXplcihKU1J1bnRpbWUqIHJ0LCBKU1ZhbHVlIHZhbCkgewogIEJsb2IqIGJsb2IgPSBKU19HZXRPcGFxdWUodmFsLCBqc19ibG9iX2NsYXNzX2lkKTsKICBpZihibG9iKSB7CiAgICBibG9iX2ZyZWVfcnQocnQsIGJsb2IpOwogIH0KICBKU19GcmVlVmFsdWVSVChydCwgdmFsKTsKfQoKc3RhdGljIEpTQ2xhc3NEZWYganNfYmxvYl9jbGFzcyA9IHsKICAgIC5jbGFzc19uYW1lID0gIkJsb2IiLAogICAgLmZpbmFsaXplciA9IGpzX2Jsb2JfZmluYWxpemVyLAp9OwoKc3RhdGljIGNvbnN0IEpTQ0Z1bmN0aW9uTGlzdEVudHJ5IGpzX2Jsb2JfZnVuY3NbXSA9IHsKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiYXJyYXlCdWZmZXIiLCAwLCBqc19ibG9iX21ldGhvZCwgQkxPQl9BUlJBWUJVRkZFUiksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoInN0cmVhbSIsIDAsIGpzX2Jsb2JfbWV0aG9kLCBCTE9CX1NUUkVBTSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoInNsaWNlIiwgMCwganNfYmxvYl9tZXRob2QsIEJMT0JfU0xJQ0UpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJ0ZXh0IiwgMCwganNfYmxvYl9tZXRob2QsIEJMT0JfVEVYVCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigic2l6ZSIsIGpzX2Jsb2JfZ2V0LCAwLCBCTE9CX1NJWkUpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoInR5cGUiLCBqc19ibG9iX2dldCwgMCwgQkxPQl9UWVBFKSwKICAgIEpTX1BST1BfU1RSSU5HX0RFRigiW1N5bWJvbC50b1N0cmluZ1RhZ10iLCAiQmxvYiIsIEpTX1BST1BfQ09ORklHVVJBQkxFKSwKfTsKCmludApqc19ibG9iX2luaXQoSlNDb250ZXh0KiBjdHgsIEpTTW9kdWxlRGVmKiBtKSB7CgogIGlmKGpzX2Jsb2JfY2xhc3NfaWQgPT0gMCkgewogICAgSlNfTmV3Q2xhc3NJRCgmanNfYmxvYl9jbGFzc19pZCk7CiAgICBKU19OZXdDbGFzcyhKU19HZXRSdW50aW1lKGN0eCksIGpzX2Jsb2JfY2xhc3NfaWQsICZqc19ibG9iX2NsYXNzKTsKCiAgICBibG9iX2N0b3IgPSBKU19OZXdDRnVuY3Rpb24yKGN0eCwganNfYmxvYl9jb25zdHJ1Y3RvciwgIkJsb2IiLCAxLCBKU19DRlVOQ19jb25zdHJ1Y3RvciwgMCk7CiAgICBibG9iX3Byb3RvID0gSlNfTmV3T2JqZWN0KGN0eCk7CgogICAgSlNfU2V0UHJvcGVydHlGdW5jdGlvbkxpc3QoY3R4LCBibG9iX3Byb3RvLCBqc19ibG9iX2Z1bmNzLCBjb3VudG9mKGpzX2Jsb2JfZnVuY3MpKTsKICAgIEpTX1NldENsYXNzUHJvdG8oY3R4LCBqc19ibG9iX2NsYXNzX2lkLCBibG9iX3Byb3RvKTsKCiAgIC8vIGpzX3NldF9pbnNwZWN0X21ldGhvZChjdHgsIGJsb2JfcHJvdG8sIGpzX2Jsb2JfaW5zcGVjdCk7CiAgfQoKICBpZihtKSB7CiAgICBKU19TZXRNb2R1bGVFeHBvcnQoY3R4LCBtLCAiQmxvYiIsIGJsb2JfY3Rvcik7CgogICAgY29uc3QgY2hhciogbW9kdWxlX25hbWUgPSBKU19BdG9tVG9DU3RyaW5nKGN0eCwgbS0+bW9kdWxlX25hbWUpOwoKICAgIGlmKCFzdHJjbXAobW9kdWxlX25hbWUsICJibG9iIikpCiAgICAgIEpTX1NldE1vZHVsZUV4cG9ydChjdHgsIG0sICJkZWZhdWx0IiwgYmxvYl9jdG9yKTsKCiAgICBKU19GcmVlQ1N0cmluZyhjdHgsIG1vZHVsZV9uYW1lKTsKICB9CgogIHJldHVybiAwOwp9CgojaWZkZWYgSlNfQkxPQl9NT0RVTEUKI2RlZmluZSBKU19JTklUX01PRFVMRSBqc19pbml0X21vZHVsZQojZWxzZQojZGVmaW5lIEpTX0lOSVRfTU9EVUxFIGpzX2luaXRfbW9kdWxlX2Jsb2IKI2VuZGlmCgpWSVNJQkxFIEpTTW9kdWxlRGVmKgpKU19JTklUX01PRFVMRShKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogbW9kdWxlX25hbWUpIHsKICBKU01vZHVsZURlZiogbTsKICBpZighKG0gPSBKU19OZXdDTW9kdWxlKGN0eCwgbW9kdWxlX25hbWUsICZqc19ibG9iX2luaXQpKSkKICAgIHJldHVybiBtOwogIEpTX0FkZE1vZHVsZUV4cG9ydChjdHgsIG0sICJCbG9iIik7CiAgCiAgaWYoIXN0cmNtcChtb2R1bGVfbmFtZSwgImJsb2IiKSkKICAgIEpTX0FkZE1vZHVsZUV4cG9ydChjdHgsIG0sICJkZWZhdWx0Iik7CiAgCiAgcmV0dXJuIG07Cn0KAAAAAAAAAAD9HwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAUA8AAAAAAABQDwAAAAAAAAAAAAAAAGRA"
				],
				[
					620,
					3,
					"left_delete",
					null,
					"AwAAAE4CAAAAAAAATgIAAAAAAABPAAAAICAgdmVjdG9yX2FsbG9jYXRlKCZibG9iLT52ZWMsIDEsIGxlbiAtIDEpOwogICAgbWVtY3B5KGJsb2ItPnZlYy5kYXRhLCB4LCBsZW4pO00CAAAAAAAATQIAAAAAAAABAAAAIEwCAAAAAAAATAIAAAAAAAABAAAACg",
					"AQAAAAAAAAABAAAATgIAAAAAAACdAgAAAAAAAAAAAAAAAPC/"
				],
				[
					622,
					1,
					"insert",
					{
						"characters": " %"
					},
					"AgAAAEkCAAAAAAAASgIAAAAAAAAAAAAASgIAAAAAAABLAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAASQIAAAAAAABJAgAAAAAAAAAAAAAAAPC/"
				],
				[
					623,
					1,
					"left_delete",
					null,
					"AQAAAEoCAAAAAAAASgIAAAAAAAABAAAAJQ",
					"AQAAAAAAAAABAAAASwIAAAAAAABLAgAAAAAAAAAAAAAAAPC/"
				],
				[
					624,
					1,
					"insert",
					{
						"characters": "&&"
					},
					"AgAAAEoCAAAAAAAASwIAAAAAAAAAAAAASwIAAAAAAABMAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAASgIAAAAAAABKAgAAAAAAAAAAAAAAAPC/"
				],
				[
					625,
					1,
					"insert",
					{
						"characters": " len"
					},
					"BAAAAEwCAAAAAAAATQIAAAAAAAAAAAAATQIAAAAAAABOAgAAAAAAAAAAAABOAgAAAAAAAE8CAAAAAAAAAAAAAE8CAAAAAAAAUAIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATAIAAAAAAABMAgAAAAAAAAAAAAAAAPC/"
				],
				[
					628,
					1,
					"insert",
					{
						"characters": "blob_wreite"
					},
					"DAAAAFICAAAAAAAAUwIAAAAAAAAAAAAAUwIAAAAAAABTAgAAAAAAAAUAAAB7CiAgfVMCAAAAAAAAVAIAAAAAAAAAAAAAVAIAAAAAAABVAgAAAAAAAAAAAABVAgAAAAAAAFYCAAAAAAAAAAAAAFYCAAAAAAAAVwIAAAAAAAAAAAAAVwIAAAAAAABYAgAAAAAAAAAAAABYAgAAAAAAAFkCAAAAAAAAAAAAAFkCAAAAAAAAWgIAAAAAAAAAAAAAWgIAAAAAAABbAgAAAAAAAAAAAABbAgAAAAAAAFwCAAAAAAAAAAAAAFwCAAAAAAAAXQIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAUgIAAAAAAABXAgAAAAAAAAAAAAAAwGJA"
				],
				[
					629,
					4,
					"left_delete",
					null,
					"BAAAAFwCAAAAAAAAXAIAAAAAAAABAAAAZVsCAAAAAAAAWwIAAAAAAAABAAAAdFoCAAAAAAAAWgIAAAAAAAABAAAAaVkCAAAAAAAAWQIAAAAAAAABAAAAZQ",
					"AQAAAAAAAAABAAAAXQIAAAAAAABdAgAAAAAAAAAAAAAAAPC/"
				],
				[
					630,
					1,
					"insert",
					{
						"characters": "ite"
					},
					"AwAAAFkCAAAAAAAAWgIAAAAAAAAAAAAAWgIAAAAAAABbAgAAAAAAAAAAAABbAgAAAAAAAFwCAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAWQIAAAAAAABZAgAAAAAAAAAAAAAAAPC/"
				],
				[
					631,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAFwCAAAAAAAAXgIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAXAIAAAAAAABcAgAAAAAAAAAAAAAAAPC/"
				],
				[
					632,
					1,
					"insert",
					{
						"characters": "ctx,"
					},
					"BAAAAF0CAAAAAAAAXgIAAAAAAAAAAAAAXgIAAAAAAABfAgAAAAAAAAAAAABfAgAAAAAAAGACAAAAAAAAAAAAAGACAAAAAAAAYQIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAXQIAAAAAAABdAgAAAAAAAAAAAAAAAPC/"
				],
				[
					633,
					1,
					"insert",
					{
						"characters": " x"
					},
					"AgAAAGECAAAAAAAAYgIAAAAAAAAAAAAAYgIAAAAAAABjAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAYQIAAAAAAABhAgAAAAAAAAAAAAAAAPC/"
				],
				[
					634,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAGMCAAAAAAAAZAIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAYwIAAAAAAABjAgAAAAAAAAAAAAAAAPC/"
				],
				[
					635,
					2,
					"left_delete",
					null,
					"AgAAAGMCAAAAAAAAYwIAAAAAAAABAAAAIGICAAAAAAAAYgIAAAAAAAABAAAAeA",
					"AQAAAAAAAAABAAAAZAIAAAAAAABkAgAAAAAAAAAAAAAAAPC/"
				],
				[
					636,
					1,
					"insert",
					{
						"characters": "blob,"
					},
					"BQAAAGICAAAAAAAAYwIAAAAAAAAAAAAAYwIAAAAAAABkAgAAAAAAAAAAAABkAgAAAAAAAGUCAAAAAAAAAAAAAGUCAAAAAAAAZgIAAAAAAAAAAAAAZgIAAAAAAABnAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAYgIAAAAAAABiAgAAAAAAAAAAAAAAAPC/"
				],
				[
					637,
					1,
					"insert",
					{
						"characters": " x,"
					},
					"AwAAAGcCAAAAAAAAaAIAAAAAAAAAAAAAaAIAAAAAAABpAgAAAAAAAAAAAABpAgAAAAAAAGoCAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAZwIAAAAAAABnAgAAAAAAAAAAAAAAAPC/"
				],
				[
					638,
					1,
					"insert",
					{
						"characters": " len"
					},
					"BAAAAGoCAAAAAAAAawIAAAAAAAAAAAAAawIAAAAAAABsAgAAAAAAAAAAAABsAgAAAAAAAG0CAAAAAAAAAAAAAG0CAAAAAAAAbgIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAagIAAAAAAABqAgAAAAAAAAAAAAAAAPC/"
				],
				[
					640,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAAG8CAAAAAAAAcAIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbwIAAAAAAABvAgAAAAAAAAAAAAAAAPC/"
				],
				[
					645,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAAEQCAAAAAAAARQIAAAAAAAAAAAAARQIAAAAAAABGAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAARAIAAAAAAABEAgAAAAAAAAAAAAAAAPC/"
				],
				[
					652,
					1,
					"cut",
					null,
					"AQAAAHQCAAAAAAAAdAIAAAAAAAAlAAAAICBibG9iLT50eXBlID0ganNfc3RyZHVwKGN0eCwgdHlwZSk7Cg",
					"AQAAAAAAAAABAAAAdAIAAAAAAACZAgAAAAAAAAAAAAAAAAAA"
				],
				[
					654,
					1,
					"paste",
					null,
					"AQAAAEMCAAAAAAAAaAIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAQwIAAAAAAABDAgAAAAAAAAAAAAAAAAAA"
				],
				[
					732,
					1,
					"insert",
					{
						"characters": "rty"
					},
					"AwAAAFICAAAAAAAAUwIAAAAAAAAAAAAAUwIAAAAAAABUAgAAAAAAAAAAAABUAgAAAAAAAFUCAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAUgIAAAAAAABSAgAAAAAAAAAAAAAAAPC/"
				],
				[
					733,
					3,
					"left_delete",
					null,
					"AwAAAFQCAAAAAAAAVAIAAAAAAAABAAAAeVMCAAAAAAAAUwIAAAAAAAABAAAAdFICAAAAAAAAUgIAAAAAAAABAAAAcg",
					"AQAAAAAAAAABAAAAVQIAAAAAAABVAgAAAAAAAAAAAAAAAPC/"
				],
				[
					734,
					1,
					"insert",
					{
						"characters": "type"
					},
					"BAAAAFICAAAAAAAAUwIAAAAAAAAAAAAAUwIAAAAAAABUAgAAAAAAAAAAAABUAgAAAAAAAFUCAAAAAAAAAAAAAFUCAAAAAAAAVgIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAUgIAAAAAAABSAgAAAAAAAAAAAAAAAPC/"
				],
				[
					735,
					1,
					"insert",
					{
						"characters": " ?"
					},
					"AgAAAFYCAAAAAAAAVwIAAAAAAAAAAAAAVwIAAAAAAABYAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAVgIAAAAAAABWAgAAAAAAAAAAAAAAAPC/"
				],
				[
					736,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAFgCAAAAAAAAWQIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAWAIAAAAAAABYAgAAAAAAAAAAAAAAAPC/"
				],
				[
					741,
					1,
					"insert",
					{
						"characters": " :"
					},
					"AgAAAG0CAAAAAAAAbgIAAAAAAAAAAAAAbgIAAAAAAABvAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbQIAAAAAAABtAgAAAAAAAAAAAAAAAPC/"
				],
				[
					742,
					1,
					"insert",
					{
						"characters": " type"
					},
					"BQAAAG8CAAAAAAAAcAIAAAAAAAAAAAAAcAIAAAAAAABxAgAAAAAAAAAAAABxAgAAAAAAAHICAAAAAAAAAAAAAHICAAAAAAAAcwIAAAAAAAAAAAAAcwIAAAAAAAB0AgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbwIAAAAAAABvAgAAAAAAAAAAAAAAAPC/"
				],
				[
					748,
					4,
					"left_delete",
					null,
					"BAAAAHMCAAAAAAAAcwIAAAAAAAABAAAAZXICAAAAAAAAcgIAAAAAAAABAAAAcHECAAAAAAAAcQIAAAAAAAABAAAAeXACAAAAAAAAcAIAAAAAAAABAAAAdA",
					"AQAAAAAAAAABAAAAdAIAAAAAAAB0AgAAAAAAAAAAAAAAoH5A"
				],
				[
					749,
					1,
					"insert",
					{
						"characters": "0"
					},
					"AQAAAHACAAAAAAAAcQIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcAIAAAAAAABwAgAAAAAAAAAAAAAAAPC/"
				],
				[
					844,
					1,
					"cut",
					null,
					"AQAAAI0BAAAAAAAAjQEAAAAAAAAoAQAACkJsb2IqCmJsb2JfbmV3KEpTQ29udGV4dCogY3R4LCBjb25zdCB2b2lkKiB4LCBzaXplX3QgbGVuLCBjb25zdCBjaGFyKiB0eXBlKSB7CiAgQmxvYiogYmxvYjsKCiAgaWYoIShibG9iID0ganNfbWFsbG9jeihjdHgsIHNpemVvZihCbG9iKSkpKQogICAgcmV0dXJuIDA7CgogIGJsb2ItPnZlYyA9IFZFQ1RPUihjdHgpOwogIGJsb2ItPnR5cGUgPSB0eXBlID8ganNfc3RyZHVwKGN0eCwgdHlwZSkgOiAwOwogCiAgaWYoeCAmJiBsZW4pIGJsb2Jfd3JpdGUoY3R4LCBibG9iLCB4LCBsZW4pOwoKICByZXR1cm4gYmxvYjsKfQo",
					"AQAAAAAAAAABAAAAjQEAAAAAAAC1AgAAAAAAAAAAAAAAAPC/"
				],
				[
					845,
					2,
					"paste",
					null,
					"AgAAAI0BAAAAAAAAtQIAAAAAAAAAAAAAtQIAAAAAAADdAwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAjQEAAAAAAACNAQAAAAAAAAAAAAAAAPC/"
				],
				[
					849,
					1,
					"insert",
					{
						"characters": "init"
					},
					"BQAAAJkBAAAAAAAAmgEAAAAAAAAAAAAAmgEAAAAAAACaAQAAAAAAAAMAAABuZXeaAQAAAAAAAJsBAAAAAAAAAAAAAJsBAAAAAAAAnAEAAAAAAAAAAAAAnAEAAAAAAACdAQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmQEAAAAAAACcAQAAAAAAAAAAAAAAAPC/"
				],
				[
					857,
					1,
					"paste",
					null,
					"AQAAAK0BAAAAAAAAsgEAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAArQEAAAAAAACtAQAAAAAAAAAAAAAAAPC/"
				],
				[
					858,
					1,
					"insert",
					{
						"characters": "böp"
					},
					"AwAAALIBAAAAAAAAswEAAAAAAAAAAAAAswEAAAAAAAC0AQAAAAAAAAAAAAC0AQAAAAAAALUBAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAsgEAAAAAAACyAQAAAAAAAAAAAAAAAPC/"
				],
				[
					859,
					2,
					"left_delete",
					null,
					"AgAAALQBAAAAAAAAtAEAAAAAAAABAAAAcLMBAAAAAAAAswEAAAAAAAACAAAAw7Y",
					"AQAAAAAAAAABAAAAtQEAAAAAAAC1AQAAAAAAAAAAAAAAAPC/"
				],
				[
					860,
					1,
					"insert",
					{
						"characters": "lob,"
					},
					"BAAAALMBAAAAAAAAtAEAAAAAAAAAAAAAtAEAAAAAAAC1AQAAAAAAAAAAAAC1AQAAAAAAALYBAAAAAAAAAAAAALYBAAAAAAAAtwEAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAswEAAAAAAACzAQAAAAAAAAAAAAAAAPC/"
				],
				[
					864,
					1,
					"left_delete",
					null,
					"AQAAAOkBAAAAAAAA6QEAAAAAAABMAAAAQmxvYiogYmxvYjsKCiAgaWYoIShibG9iID0ganNfbWFsbG9jeihjdHgsIHNpemVvZihCbG9iKSkpKQogICAgcmV0dXJuIDA7CgogIA",
					"AQAAAAAAAAABAAAA6QEAAAAAAAA1AgAAAAAAAAAAAAAAADRA"
				],
				[
					868,
					1,
					"left_delete",
					null,
					"AQAAAGICAAAAAAAAYgIAAAAAAAAQAAAACiAgcmV0dXJuIGJsb2I7Cg",
					"AQAAAAAAAAABAAAAYgIAAAAAAAByAgAAAAAAAAAAAAAAAAAA"
				],
				[
					871,
					1,
					"insert",
					{
						"characters": "void"
					},
					"BQAAAI4BAAAAAAAAjwEAAAAAAAAAAAAAjwEAAAAAAACPAQAAAAAAAAUAAABCbG9iKo8BAAAAAAAAkAEAAAAAAAAAAAAAkAEAAAAAAACRAQAAAAAAAAAAAACRAQAAAAAAAJIBAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAjgEAAAAAAACTAQAAAAAAAP///////+9/"
				],
				[
					876,
					1,
					"insert",
					{
						"characters": "\nblob_init"
					},
					"CgAAAP0CAAAAAAAA/gIAAAAAAAAAAAAA/gIAAAAAAAD/AgAAAAAAAAAAAAD/AgAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAQMAAAAAAAAAAAAAAQMAAAAAAAACAwAAAAAAAAAAAAACAwAAAAAAAAMDAAAAAAAAAAAAAAMDAAAAAAAABAMAAAAAAAAAAAAABAMAAAAAAAAFAwAAAAAAAAAAAAAFAwAAAAAAAAYDAAAAAAAAAAAAAAYDAAAAAAAABwMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA/QIAAAAAAAD9AgAAAAAAAAAAAAAAAPC/"
				],
				[
					877,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAAcDAAAAAAAACQMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAABwMAAAAAAAAHAwAAAAAAAAAAAAAAAPC/"
				],
				[
					878,
					1,
					"insert",
					{
						"characters": "ctx,"
					},
					"BAAAAAgDAAAAAAAACQMAAAAAAAAAAAAACQMAAAAAAAAKAwAAAAAAAAAAAAAKAwAAAAAAAAsDAAAAAAAAAAAAAAsDAAAAAAAADAMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAACAMAAAAAAAAIAwAAAAAAAAAAAAAAAPC/"
				],
				[
					879,
					1,
					"insert",
					{
						"characters": " blob,"
					},
					"BgAAAAwDAAAAAAAADQMAAAAAAAAAAAAADQMAAAAAAAAOAwAAAAAAAAAAAAAOAwAAAAAAAA8DAAAAAAAAAAAAAA8DAAAAAAAAEAMAAAAAAAAAAAAAEAMAAAAAAAARAwAAAAAAAAAAAAARAwAAAAAAABIDAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAADAMAAAAAAAAMAwAAAAAAAAAAAAAAAPC/"
				],
				[
					880,
					1,
					"insert",
					{
						"characters": " x,"
					},
					"AwAAABIDAAAAAAAAEwMAAAAAAAAAAAAAEwMAAAAAAAAUAwAAAAAAAAAAAAAUAwAAAAAAABUDAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAEgMAAAAAAAASAwAAAAAAAAAAAAAAAPC/"
				],
				[
					881,
					1,
					"insert",
					{
						"characters": " lenm,t"
					},
					"BwAAABUDAAAAAAAAFgMAAAAAAAAAAAAAFgMAAAAAAAAXAwAAAAAAAAAAAAAXAwAAAAAAABgDAAAAAAAAAAAAABgDAAAAAAAAGQMAAAAAAAAAAAAAGQMAAAAAAAAaAwAAAAAAAAAAAAAaAwAAAAAAABsDAAAAAAAAAAAAABsDAAAAAAAAHAMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAFQMAAAAAAAAVAwAAAAAAAAAAAAAAAPC/"
				],
				[
					882,
					3,
					"left_delete",
					null,
					"AwAAABsDAAAAAAAAGwMAAAAAAAABAAAAdBoDAAAAAAAAGgMAAAAAAAABAAAALBkDAAAAAAAAGQMAAAAAAAABAAAAbQ",
					"AQAAAAAAAAABAAAAHAMAAAAAAAAcAwAAAAAAAAAAAAAAAPC/"
				],
				[
					883,
					1,
					"insert",
					{
						"characters": ",type"
					},
					"BQAAABkDAAAAAAAAGgMAAAAAAAAAAAAAGgMAAAAAAAAbAwAAAAAAAAAAAAAbAwAAAAAAABwDAAAAAAAAAAAAABwDAAAAAAAAHQMAAAAAAAAAAAAAHQMAAAAAAAAeAwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAGQMAAAAAAAAZAwAAAAAAAAAAAAAAAPC/"
				],
				[
					885,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAAB8DAAAAAAAAIAMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAHwMAAAAAAAAfAwAAAAAAAAAAAAAAAPC/"
				],
				[
					888,
					1,
					"left_delete",
					null,
					"AQAAACEDAAAAAAAAIQMAAAAAAAB7AAAAICBibG9iLT52ZWMgPSBWRUNUT1IoY3R4KTsKICBibG9iLT50eXBlID0gdHlwZSA/IGpzX3N0cmR1cChjdHgsIHR5cGUpIDogMDsKIAogIGlmKHggJiYgbGVuKSBibG9iX3dyaXRlKGN0eCwgYmxvYiwgeCwgbGVuKTsK",
					"AQAAAAAAAAABAAAAIQMAAAAAAACcAwAAAAAAAAAAAAAAAAAA"
				],
				[
					937,
					1,
					"insert",
					{
						"characters": "blob_new"
					},
					"CQAAALYJAAAAAAAAtwkAAAAAAAAAAAAAtwkAAAAAAAC3CQAAAAAAAAoAAABqc19tYWxsb2N6twkAAAAAAAC4CQAAAAAAAAAAAAC4CQAAAAAAALkJAAAAAAAAAAAAALkJAAAAAAAAugkAAAAAAAAAAAAAugkAAAAAAAC7CQAAAAAAAAAAAAC7CQAAAAAAALwJAAAAAAAAAAAAALwJAAAAAAAAvQkAAAAAAAAAAAAAvQkAAAAAAAC+CQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAwAkAAAAAAAC2CQAAAAAAAAAAAAAAAPC/"
				],
				[
					939,
					1,
					"insert",
					{
						"characters": "0,0,0)"
					},
					"BgAAAMMJAAAAAAAAxAkAAAAAAAAAAAAAxAkAAAAAAADFCQAAAAAAAAAAAADFCQAAAAAAAMYJAAAAAAAAAAAAAMYJAAAAAAAAxwkAAAAAAAAAAAAAxwkAAAAAAADICQAAAAAAAAAAAADICQAAAAAAAMkJAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAwwkAAAAAAADDCQAAAAAAAAAAAAAAAPC/"
				],
				[
					942,
					1,
					"left_delete",
					null,
					"AQAAAMkJAAAAAAAAyQkAAAAAAAAPAAAAIHNpemVvZihCbG9iKSkp",
					"AQAAAAAAAAABAAAAyQkAAAAAAADYCQAAAAAAAAAAAAAAAPC/"
				],
				[
					944,
					1,
					"insert",
					{
						"characters": ")"
					},
					"AQAAAMoJAAAAAAAAywkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAygkAAAAAAADKCQAAAAAAAAAAAAAAAPC/"
				],
				[
					949,
					1,
					"left_delete",
					null,
					"AQAAAKsLAAAAAAAAqwsAAAAAAAAcAAAAICBibG9iLT52ZWMgPSBWRUNUT1IoY3R4KTsKCg",
					"AQAAAAAAAAABAAAAqwsAAAAAAADHCwAAAAAAAAAAAAAAAAAA"
				],
				[
					1037,
					1,
					"insert",
					{
						"characters": " "
					},
					"AgAAAC0dAAAAAAAALh0AAAAAAAAAAAAALh0AAAAAAAAuHQAAAAAAAAUAAAAgICAvLw",
					"AQAAAAAAAAABAAAAMh0AAAAAAAAtHQAAAAAAAAAAAAAAAPC/"
				],
				[
					1044,
					1,
					"toggle_comment",
					{
						"block": true
					},
					"AgAAAHQeAAAAAAAAdh4AAAAAAAAAAAAAqh0AAAAAAACsHQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAqh0AAAAAAAB0HgAAAAAAAAAAAAAAAPC/"
				],
				[
					1047,
					1,
					"toggle_comment",
					{
						"block": true
					},
					"AgAAACEgAAAAAAAAIyAAAAAAAAAAAAAA1R8AAAAAAADXHwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA1R8AAAAAAAAhIAAAAAAAAAAAAAAAAPC/"
				],
				[
					1050,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAA1IAAAI2lmbmRlZiBfR05VX1NPVVJDRQojZGVmaW5lIF9HTlVfU09VUkNFCiNlbmRpZgoKI2luY2x1ZGUgInF1aWNranMtYmxvYi5oIgojaW5jbHVkZSAidXRpbHMuaCIKI2luY2x1ZGUgImJ1ZmZlci11dGlscy5oIgoKI2RlZmluZSBtYXgoYSwgYikgKChhKSA+IChiKSA/IChhKSA6IChiKSkKCnRocmVhZF9sb2NhbCBWSVNJQkxFIEpTQ2xhc3NJRCBqc19ibG9iX2NsYXNzX2lkID0gMDsKdGhyZWFkX2xvY2FsIEpTVmFsdWUgYmxvYl9wcm90byA9IHtKU19UQUdfVU5ERUZJTkVEfSwgYmxvYl9jdG9yID0ge0pTX1RBR19VTkRFRklORUR9OwoKZW51bSB7IEJMT0JfU0laRSwgQkxPQl9UWVBFIH07CmVudW0geyBCTE9CX0FSUkFZQlVGRkVSLCBCTE9CX1NMSUNFLCBCTE9CX1NUUkVBTSwgQkxPQl9URVhUIH07Cgp2b2lkCmJsb2JfaW5pdChKU0NvbnRleHQqIGN0eCxCbG9iKmJsb2IsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBsZW4sIGNvbnN0IGNoYXIqIHR5cGUpIHsKICBibG9iLT52ZWMgPSBWRUNUT1IoY3R4KTsKICBibG9iLT50eXBlID0gdHlwZSA/IGpzX3N0cmR1cChjdHgsIHR5cGUpIDogMDsKIAogIGlmKHggJiYgbGVuKSBibG9iX3dyaXRlKGN0eCwgYmxvYiwgeCwgbGVuKTsKfQoKQmxvYioKYmxvYl9uZXcoSlNDb250ZXh0KiBjdHgsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBsZW4sIGNvbnN0IGNoYXIqIHR5cGUpIHsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBqc19tYWxsb2N6KGN0eCwgc2l6ZW9mKEJsb2IpKSkpCiAgICByZXR1cm4gMDsKCmJsb2JfaW5pdChjdHgsIGJsb2IsIHgsIGxlbix0eXBlKTsKCiAgcmV0dXJuIGJsb2I7Cn0KCnNzaXplX3QKYmxvYl93cml0ZShKU0NvbnRleHQqIGN0eCwgQmxvYiogYmxvYiwgY29uc3Qgdm9pZCogeCwgc2l6ZV90IGxlbikgewogIHVpbnQ4X3QqIHB0cjsKICBpZigocHRyID0gdmVjdG9yX3B1dCgmYmxvYi0+dmVjLCB4LCBsZW4pKSkKICAgIHJldHVybiBsZW47CiAgcmV0dXJuIC0xOwp9Cgp2b2lkCmJsb2JfZnJlZShKU0NvbnRleHQqIGN0eCwgQmxvYiogYmxvYikgewogIGlmKGJsb2ItPnZlYy5kYXRhKQogICAgdmVjdG9yX2ZyZWUoJmJsb2ItPnZlYyk7CiAganNfZnJlZShjdHgsIGJsb2IpOwp9CgpzdGF0aWMgdm9pZApibG9iX2ZyZWVfcnQoSlNSdW50aW1lKiBydCwgQmxvYiogYmxvYikgewogIGlmKGJsb2ItPnZlYy5kYXRhKQogICAgdmVjdG9yX2ZyZWUoJmJsb2ItPnZlYyk7CiAganNfZnJlZV9ydChydCwgYmxvYik7Cn0KCklucHV0QnVmZmVyCmJsb2JfaW5wdXQoSlNDb250ZXh0KiBjdHgsIEJsb2IqIGJsb2IpIHsKICBJbnB1dEJ1ZmZlciByZXQgPSB7YmxvYi0+ZGF0YSwgMCwgYmxvYi0+c2l6ZSwgJmlucHV0X2J1ZmZlcl9mcmVlX2RlZmF1bHQsIEpTX1VOREVGSU5FRCwgMCwgSU5UNjRfTUFYfTsKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgdm9pZApqc19ibG9iX2ZyZWVfZnVuYyhKU1J1bnRpbWUqIHJ0LCB2b2lkKiBvcGFxdWUsIHZvaWQqIHB0cikgewogIC8vIGpzX2ZyZWVfcnQocnQsIHB0cik7Cn0KCkpTVmFsdWUKanNfYmxvYl93cmFwKEpTQ29udGV4dCogY3R4LCBCbG9iKiBibG9iKSB7CiAgSlNWYWx1ZSBvYmo7CiAgb2JqID0gSlNfTmV3T2JqZWN0UHJvdG9DbGFzcyhjdHgsIGJsb2JfcHJvdG8sIGpzX2Jsb2JfY2xhc3NfaWQpOwogIEpTX1NldE9wYXF1ZShvYmosIGJsb2IpOwogIHJldHVybiBvYmo7Cn0KCkpTVmFsdWUKanNfYmxvYl9uZXcoSlNDb250ZXh0KiBjdHgsIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBsZW4sIGNvbnN0IGNoYXIqIHR5cGUpIHsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBibG9iX25ldyhjdHgsIHgsIGxlbiwgdHlwZSkpKQogICAgcmV0dXJuIEpTX1Rocm93T3V0T2ZNZW1vcnkoY3R4KTsKCiAgcmV0dXJuIGpzX2Jsb2Jfd3JhcChjdHgsIGJsb2IpOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc19ibG9iX2dldChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgbWFnaWMpIHsKICBCbG9iKiBibG9iOwogIEpTVmFsdWUgcmV0ID0gSlNfVU5ERUZJTkVEOwogIGlmKCEoYmxvYiA9IGpzX2Jsb2JfZGF0YShjdHgsIHRoaXNfdmFsKSkpCiAgICByZXR1cm4gcmV0OwogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBCTE9CX1NJWkU6IHsKICAgICAgcmV0ID0gSlNfTmV3VWludDMyKGN0eCwgYmxvYi0+c2l6ZSk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgQkxPQl9UWVBFOiB7CiAgICAgIHJldCA9IEpTX05ld1N0cmluZyhjdHgsIGJsb2ItPnR5cGUpOwogICAgICBicmVhazsKICAgIH0KICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNfYmxvYl9jb25zdHJ1Y3RvcihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG5ld190YXJnZXQsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgSlNWYWx1ZSBvYmogPSBKU19VTkRFRklORUQ7CiAgSlNWYWx1ZSBwcm90bzsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBibG9iX25ldyhjdHgsMCwwLDApKSkKICAgIHJldHVybiBKU19UaHJvd091dE9mTWVtb3J5KGN0eCk7CgogIC8qIHVzaW5nIG5ld190YXJnZXQgdG8gZ2V0IHRoZSBwcm90b3R5cGUgaXMgbmVjZXNzYXJ5IHdoZW4gdGhlCiAgICAgY2xhc3MgaXMgZXh0ZW5kZWQuICovCiAgcHJvdG8gPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG5ld190YXJnZXQsICJwcm90b3R5cGUiKTsKICBpZihKU19Jc0V4Y2VwdGlvbihwcm90bykpCiAgICBnb3RvIGZhaWw7CiAgaWYoIUpTX0lzT2JqZWN0KHByb3RvKSkKICAgIHByb3RvID0gYmxvYl9wcm90bzsKCiAgLyogdXNpbmcgbmV3X3RhcmdldCB0byBnZXQgdGhlIHByb3RvdHlwZSBpcyBuZWNlc3Nhcnkgd2hlbiB0aGUKICAgICBjbGFzcyBpcyBleHRlbmRlZC4gKi8KICBvYmogPSBKU19OZXdPYmplY3RQcm90b0NsYXNzKGN0eCwgcHJvdG8sIGpzX2Jsb2JfY2xhc3NfaWQpOwogIGlmKEpTX0lzRXhjZXB0aW9uKG9iaikpCiAgICBnb3RvIGZhaWw7CgogIHsKICAgIHVpbnQ4X3QqIHB0cjsKICAgIHNpemVfdCBzaXplID0gMCwgb2ZmcyA9IDA7CiAgICBibG9iLT50eXBlID0gMDsKCiAgICBpZihhcmdjID49IDEpIHsKICAgICAgaWYoanNfaXNfYXJyYXkoY3R4LCBhcmd2WzBdKSkgewogICAgICAgIHVpbnQzMl90IGksIGxlbiA9IGpzX2FycmF5X2xlbmd0aChjdHgsIGFyZ3ZbMF0pOwogICAgICAgIElucHV0QnVmZmVyKiBwYXJ0cyA9IGpzX21hbGxvYyhjdHgsIHNpemVvZihJbnB1dEJ1ZmZlcikgKiBsZW4pOwoKICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgQmxvYiogb3RoZXI7CiAgICAgICAgICBKU1ZhbHVlIGl0ZW0gPSBKU19HZXRQcm9wZXJ0eVVpbnQzMihjdHgsIGFyZ3ZbMF0sIGkpOwogICAgICAgICAgcGFydHNbaV0gPSAob3RoZXIgPSBqc19ibG9iX2RhdGEoY3R4LCBpdGVtKSkgPyBibG9iX2lucHV0KGN0eCwgb3RoZXIpIDoganNfaW5wdXRfYnVmZmVyKGN0eCwgaXRlbSk7CiAgICAgICAgICBzaXplICs9IHBhcnRzW2ldLnNpemU7CiAgICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBpdGVtKTsKICAgICAgICB9CgogICAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICBpZihibG9iX3dyaXRlKGN0eCwgYmxvYiwgaW5wdXRfYnVmZmVyX2RhdGEoJnBhcnRzW2ldKSwgaW5wdXRfYnVmZmVyX2xlbmd0aCgmcGFydHNbaV0pKSA9PSAtMSkgewogICAgICAgICAgICB3aGlsZShpIDwgbGVuKSBpbnB1dF9idWZmZXJfZnJlZSgmcGFydHNbaSsrXSwgY3R4KTsKICAgICAgICAgICAgYmxvYl9mcmVlKGN0eCwgYmxvYik7CiAgICAgICAgICAgIGpzX2ZyZWUoY3R4LCBwYXJ0cyk7CiAgICAgICAgICAgIHJldHVybiBKU19UaHJvd0ludGVybmFsRXJyb3IoY3R4LCAiYmxvYl93cml0ZSByZXR1cm5lZCAtMSIpOwogICAgICAgICAgfQoKICAgICAgICAgIGlucHV0X2J1ZmZlcl9mcmVlKCZwYXJ0c1tpXSwgY3R4KTsKICAgICAgICB9CiAgICAgICAganNfZnJlZShjdHgsIHBhcnRzKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBKU19UaHJvd0ludGVybmFsRXJyb3IoY3R4LCAiYXJndW1lbnQgMSBtdXN0IGJlIGFycmF5Iik7CiAgICAgICAgZ290byBmYWlsOwogICAgICB9CiAgICB9CgogICAgaWYoYXJnYyA+PSAyICYmIEpTX0lzT2JqZWN0KGFyZ3ZbMV0pKSB7CiAgICAgIEpTVmFsdWUgdHlwZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgYXJndlsxXSwgInR5cGUiKTsKCiAgICAgIGlmKEpTX0lzU3RyaW5nKHR5cGUpKQogICAgICAgIGJsb2ItPnR5cGUgPSBqc190b3N0cmluZyhjdHgsIHR5cGUpOwogICAgICBKU19GcmVlVmFsdWUoY3R4LCB0eXBlKTsKICAgIH0KICAgIGlmKGJsb2ItPnR5cGUgPT0gMCkKICAgICAgYmxvYi0+dHlwZSA9IGpzX3N0cmR1cChjdHgsICJhcHBsaWNhdGlvbi9iaW5hcnkiKTsKICB9CgogIEpTX1NldE9wYXF1ZShvYmosIGJsb2IpOwoKICByZXR1cm4gb2JqOwoKZmFpbDoKICBqc19mcmVlKGN0eCwgYmxvYik7CiAgSlNfRnJlZVZhbHVlKGN0eCwgb2JqKTsKICByZXR1cm4gSlNfRVhDRVBUSU9OOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc19ibG9iX21ldGhvZChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSwgaW50IG1hZ2ljKSB7CiAgQmxvYiogYmxvYjsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKCiAgaWYoIShibG9iID0ganNfYmxvYl9kYXRhKGN0eCwgdGhpc192YWwpKSkKICAgIHJldHVybiBKU19FWENFUFRJT047CgogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSBCTE9CX0FSUkFZQlVGRkVSOiB7CiAgICAgIHJldCA9IGpzX2FycmF5YnVmZmVyX2Zyb212YWx1ZShjdHgsIGJsb2ItPmRhdGEsIGJsb2ItPnNpemUsIHRoaXNfdmFsKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEJMT0JfU0xJQ0U6IHsKICAgICAgaW50NjRfdCBuID0gYmxvYi0+c2l6ZSwgcyA9IDAsIGUgPSBJTlQ2NF9NQVg7CiAgICAgIGNoYXIqIHR5cGUgPSAwOwoKICAgICAgaWYoYXJnYyA+PSAxKSB7CiAgICAgICAgSlNfVG9JbnQ2NChjdHgsICZzLCBhcmd2WzBdKTsKICAgICAgICBpZihzIDwgMCkKICAgICAgICAgIHMgPSBuICsgcyAlIG47CiAgICAgICAgZWxzZSBpZihzID4gbikKICAgICAgICAgIHMgPSBuOwoKICAgICAgICBpZihhcmdjID49IDIpIHsKICAgICAgICAgIEpTX1RvSW50NjQoY3R4LCAmZSwgYXJndlsxXSk7CiAgICAgICAgICBpZihlIDwgMCkKICAgICAgICAgICAgZSA9IG4gKyBlICUgbjsKICAgICAgICAgIGVsc2UgaWYoZSA+IG4pCiAgICAgICAgICAgIGUgPSBuOwoKICAgICAgICAgIGlmKGFyZ2MgPj0gMykKICAgICAgICAgICAgdHlwZSA9IGpzX3Rvc3RyaW5nKGN0eCwgYXJndlsyXSk7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXQgPSBqc19ibG9iX25ldyhjdHgsICZibG9iLT5kYXRhW3NdLCBlIC0gcywgdHlwZSA/IHR5cGUgOiBibG9iLT50eXBlKTsKICAgICAgaWYodHlwZSkKICAgICAgICBqc19mcmVlKGN0eCwgdHlwZSk7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBCTE9CX1NUUkVBTTogewogICAgICByZXQgPSBKU19VTkRFRklORUQ7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBCTE9CX1RFWFQ6IHsKICAgICAgcmV0ID0gSlNfTmV3U3RyaW5nTGVuKGN0eCwgYmxvYi0+ZGF0YSwgYmxvYi0+c2l6ZSk7CiAgICAgIGJyZWFrOwogICAgfQogIH0KICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgSlNWYWx1ZQpqc19ibG9iX2luc3BlY3QoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCwgaW50IGFyZ2MsIEpTVmFsdWVDb25zdCBhcmd2W10pIHsKICBCbG9iKiBibG9iOwoKICBpZighKGJsb2IgPSBqc19ibG9iX2RhdGEoY3R4LCB0aGlzX3ZhbCkpKQogICAgcmV0dXJuIEpTX0VYQ0VQVElPTjsKCiAgSlNWYWx1ZSBvYmogPSBKU19OZXdPYmplY3RQcm90byhjdHgsIGJsb2JfcHJvdG8pOwogIEpTX0RlZmluZVByb3BlcnR5VmFsdWVTdHIoY3R4LCBvYmosICJzaXplIiwgSlNfTmV3VWludDMyKGN0eCwgYmxvYi0+c2l6ZSksIEpTX1BST1BfRU5VTUVSQUJMRSk7CiAgSlNfRGVmaW5lUHJvcGVydHlWYWx1ZVN0cihjdHgsIG9iaiwgInR5cGUiLCBKU19OZXdTdHJpbmcoY3R4LCBibG9iLT50eXBlKSwgSlNfUFJPUF9FTlVNRVJBQkxFKTsKICByZXR1cm4gb2JqOwp9CgpzdGF0aWMgdm9pZApqc19ibG9iX2ZpbmFsaXplcihKU1J1bnRpbWUqIHJ0LCBKU1ZhbHVlIHZhbCkgewogIEJsb2IqIGJsb2IgPSBKU19HZXRPcGFxdWUodmFsLCBqc19ibG9iX2NsYXNzX2lkKTsKICBpZihibG9iKSB7CiAgICBibG9iX2ZyZWVfcnQocnQsIGJsb2IpOwogIH0KICBKU19GcmVlVmFsdWVSVChydCwgdmFsKTsKfQoKc3RhdGljIEpTQ2xhc3NEZWYganNfYmxvYl9jbGFzcyA9IHsKICAgIC5jbGFzc19uYW1lID0gIkJsb2IiLAogICAgLmZpbmFsaXplciA9IGpzX2Jsb2JfZmluYWxpemVyLAp9OwoKc3RhdGljIGNvbnN0IEpTQ0Z1bmN0aW9uTGlzdEVudHJ5IGpzX2Jsb2JfZnVuY3NbXSA9IHsKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiYXJyYXlCdWZmZXIiLCAwLCBqc19ibG9iX21ldGhvZCwgQkxPQl9BUlJBWUJVRkZFUiksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoInN0cmVhbSIsIDAsIGpzX2Jsb2JfbWV0aG9kLCBCTE9CX1NUUkVBTSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoInNsaWNlIiwgMCwganNfYmxvYl9tZXRob2QsIEJMT0JfU0xJQ0UpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJ0ZXh0IiwgMCwganNfYmxvYl9tZXRob2QsIEJMT0JfVEVYVCksCiAgICBKU19DR0VUU0VUX01BR0lDX0RFRigic2l6ZSIsIGpzX2Jsb2JfZ2V0LCAwLCBCTE9CX1NJWkUpLAogICAgSlNfQ0dFVFNFVF9NQUdJQ19ERUYoInR5cGUiLCBqc19ibG9iX2dldCwgMCwgQkxPQl9UWVBFKSwKICAgIEpTX1BST1BfU1RSSU5HX0RFRigiW1N5bWJvbC50b1N0cmluZ1RhZ10iLCAiQmxvYiIsIEpTX1BST1BfQ09ORklHVVJBQkxFKSwKfTsKCmludApqc19ibG9iX2luaXQoSlNDb250ZXh0KiBjdHgsIEpTTW9kdWxlRGVmKiBtKSB7CgogIGlmKGpzX2Jsb2JfY2xhc3NfaWQgPT0gMCkgewogICAgSlNfTmV3Q2xhc3NJRCgmanNfYmxvYl9jbGFzc19pZCk7CiAgICBKU19OZXdDbGFzcyhKU19HZXRSdW50aW1lKGN0eCksIGpzX2Jsb2JfY2xhc3NfaWQsICZqc19ibG9iX2NsYXNzKTsKCiAgICBibG9iX2N0b3IgPSBKU19OZXdDRnVuY3Rpb24yKGN0eCwganNfYmxvYl9jb25zdHJ1Y3RvciwgIkJsb2IiLCAxLCBKU19DRlVOQ19jb25zdHJ1Y3RvciwgMCk7CiAgICBibG9iX3Byb3RvID0gSlNfTmV3T2JqZWN0KGN0eCk7CgogICAgSlNfU2V0UHJvcGVydHlGdW5jdGlvbkxpc3QoY3R4LCBibG9iX3Byb3RvLCBqc19ibG9iX2Z1bmNzLCBjb3VudG9mKGpzX2Jsb2JfZnVuY3MpKTsKICAgIEpTX1NldENsYXNzUHJvdG8oY3R4LCBqc19ibG9iX2NsYXNzX2lkLCBibG9iX3Byb3RvKTsKCiAgIGpzX3NldF9pbnNwZWN0X21ldGhvZChjdHgsIGJsb2JfcHJvdG8sIGpzX2Jsb2JfaW5zcGVjdCk7CiAgfQoKICBpZihtKSB7CiAgICBKU19TZXRNb2R1bGVFeHBvcnQoY3R4LCBtLCAiQmxvYiIsIGJsb2JfY3Rvcik7Ci8qCiAgICBjb25zdCBjaGFyKiBtb2R1bGVfbmFtZSA9IEpTX0F0b21Ub0NTdHJpbmcoY3R4LCBtLT5tb2R1bGVfbmFtZSk7CgogICAgaWYoIXN0cmNtcChtb2R1bGVfbmFtZSwgImJsb2IiKSkKICAgICAgSlNfU2V0TW9kdWxlRXhwb3J0KGN0eCwgbSwgImRlZmF1bHQiLCBibG9iX2N0b3IpOwoKICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgbW9kdWxlX25hbWUpOyovCiAgfQoKICByZXR1cm4gMDsKfQoKI2lmZGVmIEpTX0JMT0JfTU9EVUxFCiNkZWZpbmUgSlNfSU5JVF9NT0RVTEUganNfaW5pdF9tb2R1bGUKI2Vsc2UKI2RlZmluZSBKU19JTklUX01PRFVMRSBqc19pbml0X21vZHVsZV9ibG9iCiNlbmRpZgoKVklTSUJMRSBKU01vZHVsZURlZioKSlNfSU5JVF9NT0RVTEUoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIG1vZHVsZV9uYW1lKSB7CiAgSlNNb2R1bGVEZWYqIG07CiAgaWYoIShtID0gSlNfTmV3Q01vZHVsZShjdHgsIG1vZHVsZV9uYW1lLCAmanNfYmxvYl9pbml0KSkpCiAgICByZXR1cm4gbTsKICBKU19BZGRNb2R1bGVFeHBvcnQoY3R4LCBtLCAiQmxvYiIpOwoKIC8qIGlmKCFzdHJjbXAobW9kdWxlX25hbWUsICJibG9iIikpCiAgICBKU19BZGRNb2R1bGVFeHBvcnQoY3R4LCBtLCAiZGVmYXVsdCIpOyovCgogIHJldHVybiBtOwp9CgAAAAAAAAAAVyAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA1x8AAAAAAAAjIAAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "qjsm.c",
			"redo_stack":
			[
				[
					390,
					1,
					"insert",
					{
						"characters": "BOOL"
					},
					"BQAAAOVEAAAAAAAA5UQAAAAAAAABAAAATOREAAAAAAAA5EQAAAAAAAABAAAAT+NEAAAAAAAA40QAAAAAAAABAAAAT+NEAAAAAAAA5kQAAAAAAAAAAAAA4kQAAAAAAADiRAAAAAAAAAEAAABC",
					"AQAAAAAAAAABAAAA5kQAAAAAAADmRAAAAAAAAAAAAAAAAPC/"
				]
			],
			"settings":
			{
				"buffer_size": 40565,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					10,
					1,
					"left_delete",
					null,
					"AQAAAHaUAAAAAAAAdpQAAAAAAAAbAAAAIgogICAgICAgICAgICAgICAgICAgICAgICAi",
					"AQAAAAAAAAABAAAAdpQAAAAAAACRlAAAAAAAAAAAAAAAAPC/"
				],
				[
					30,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAADznQAAI2lmbmRlZiBfR05VX1NPVVJDRQojZGVmaW5lIF9HTlVfU09VUkNFCiNlbmRpZgoKLyoKICogUXVpY2tKUyBzdGFuZCBhbG9uZSBpbnRlcnByZXRlcgogKgogKiBDb3B5cmlnaHQgKGMpIDIwMTctMjAyMSBGYWJyaWNlIEJlbGxhcmQKICogQ29weXJpZ2h0IChjKSAyMDE3LTIwMjEgQ2hhcmxpZSBHb3Jkb24KICoKICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weQogKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAiU29mdHdhcmUiKSwgdG8gZGVhbAogKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzCiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwKICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzCiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHN0YXRlczoKICoKICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4KICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCiAqCiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SCiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLAogKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTAogKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUgogKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLAogKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOCiAqIFRIRSBTT0ZUV0FSRS4KICovCiNpbmNsdWRlIDxzdGRsaWIuaD4KI2luY2x1ZGUgPHN0ZGlvLmg+CiNpbmNsdWRlIDxzdGRhcmcuaD4KI2luY2x1ZGUgPGludHR5cGVzLmg+CiNpbmNsdWRlIDxzdHJpbmcuaD4KI2luY2x1ZGUgPGFzc2VydC5oPgojaW5jbHVkZSA8dW5pc3RkLmg+CiNpbmNsdWRlIDxlcnJuby5oPgojaW5jbHVkZSA8ZmNudGwuaD4KI2luY2x1ZGUgPGRsZmNuLmg+CiNpbmNsdWRlIDx0aW1lLmg+CiNpbmNsdWRlIDxzaWduYWwuaD4KI2luY2x1ZGUgPHN5cy9wb2xsLmg+CiNpZiBkZWZpbmVkKF9fQVBQTEVfXykKI2luY2x1ZGUgPG1hbGxvYy9tYWxsb2MuaD4KI2VsaWYgZGVmaW5lZChfX2xpbnV4X18pCiNpbmNsdWRlIDxtYWxsb2MuaD4KI2VuZGlmCgojaWYgMSAvLyBkZWYgSEFWRV9RVUlDS0pTX0NPTkZJR19ICiNpbmNsdWRlICJxdWlja2pzLWNvbmZpZy5oIgojZW5kaWYKCiNpZmRlZiBVU0VfV09SS0VSCiNpbmNsdWRlIDxwdGhyZWFkLmg+CiNpbmNsdWRlIDxzdGRhdG9taWMuaD4KCnN0YXRpYyBpbnQKYXRvbWljX2FkZF9pbnQoaW50KiBwdHIsIGludCB2KSB7CiAgcmV0dXJuIGF0b21pY19mZXRjaF9hZGQoKF9BdG9taWModWludDMyX3QpKilwdHIsIHYpICsgdjsKfQojZW5kaWYKCiNpbmNsdWRlICJsaXN0LmgiCiNpbmNsdWRlICJjdXRpbHMuaCIKI2luY2x1ZGUgInV0aWxzLmgiCiNpbmNsdWRlICJ2ZWN0b3IuaCIKI2luY2x1ZGUgInF1aWNranMtbGliYy5oIgojaW5jbHVkZSAicXVpY2tqcy1pbnRlcm5hbC5oIgojaW5jbHVkZSAiYnVmZmVyLXV0aWxzLmgiCgp0eXBlZGVmIHN0cnVjdCBwb2xsaGFuZGxlciB7CiAgc3RydWN0IHBvbGxmZCBwZjsKICB2b2lkICgqaGFuZGxlcikodm9pZCogb3BhcXVlLCBzdHJ1Y3QgcG9sbGZkKik7CiAgdm9pZCogb3BhcXVlOwogIHN0cnVjdCBsaXN0X2hlYWQgbGluazsKfSBwb2xsaGFuZGxlcl90OwoKdGhyZWFkX2xvY2FsIHVpbnQ2NF90IGpzbV9wZW5kaW5nX3NpZ25hbHMgPSAwOwpzdHJ1Y3QgbGlzdF9oZWFkIHBvbGxoYW5kbGVyczsKCnZvaWQganNfc3RkX3NldF9tb2R1bGVfbG9hZGVyX2Z1bmMoSlNNb2R1bGVMb2FkZXJGdW5jKiBmdW5jKTsKCiNpZmRlZiBIQVZFX01BTExPQ19VU0FCTEVfU0laRQojaWZuZGVmIEhBVkVfTUFMTE9DX1VTQUJMRV9TSVpFX0RFRklOSVRJT04KZXh0ZXJuIHNpemVfdCBtYWxsb2NfdXNhYmxlX3NpemUoKTsKI2VuZGlmCiNlbmRpZgoKI2RlZmluZSB0cmltX2RvdHNsYXNoKHN0cikgKCFzdHJuY21wKChzdHIpLCAiLi8iLCAyKSA/IChzdHIpICsgMiA6IChzdHIpKQoKI2RlZmluZSBqc21fZGVjbGFyZV9tb2R1bGUobmFtZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgZXh0ZXJuIGNvbnN0IHVpbnQ4X3QgcWpzY18jI25hbWVbXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIGV4dGVybiBjb25zdCB1aW50MzJfdCBxanNjXyMjbmFtZSMjX3NpemU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICBKU01vZHVsZURlZioganNfaW5pdF9tb2R1bGVfIyNuYW1lKEpTQ29udGV4dCosIGNvbnN0IGNoYXIqKTsKCmpzbV9kZWNsYXJlX21vZHVsZShjb25zb2xlKTsKanNtX2RlY2xhcmVfbW9kdWxlKGV2ZW50cyk7CmpzbV9kZWNsYXJlX21vZHVsZShmcyk7CmpzbV9kZWNsYXJlX21vZHVsZShwZXJmX2hvb2tzKTsKanNtX2RlY2xhcmVfbW9kdWxlKHByb2Nlc3MpOwpqc21fZGVjbGFyZV9tb2R1bGUocmVwbCk7CmpzbV9kZWNsYXJlX21vZHVsZShyZXF1aXJlKTsKanNtX2RlY2xhcmVfbW9kdWxlKHR0eSk7CmpzbV9kZWNsYXJlX21vZHVsZSh1dGlsKTsKCiNpZmRlZiBDT05GSUdfQklHTlVNCmpzbV9kZWNsYXJlX21vZHVsZShxanNjYWxjKTsKc3RhdGljIGludCBiaWdudW1fZXh0ID0gMTsKI2VuZGlmCgp2b2lkIGpzX3N0ZF9zZXRfd29ya2VyX25ld19jb250ZXh0X2Z1bmMoSlNDb250ZXh0KiAoKmZ1bmMpKEpTUnVudGltZSogcnQpKTsKCnZvaWQganNtX3N0ZF9kdW1wX2Vycm9yKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlIGV4Y2VwdGlvbl92YWwpOwoKc3RhdGljIEJPT0wgZGVidWdfbW9kdWxlX2xvYWRlciA9IEZBTFNFOwoKc3RhdGljIFZlY3RvciBtb2R1bGVfZGVidWcgPSBWRUNUT1JfSU5JVCgpOwpzdGF0aWMgVmVjdG9yIG1vZHVsZV9saXN0ID0gVkVDVE9SX0lOSVQoKTsKc3RhdGljIFZlY3RvciBidWlsdGlucyA9IFZFQ1RPUl9JTklUKCk7CgpKU1ZhbHVlIHBhY2thZ2VfanNvbjsKCnN0YXRpYyBpbnQ2NF90CmpzbV90aW1lX21zKHZvaWQpIHsKICBzdHJ1Y3QgdGltZXNwZWMgdHM7CiAgY2xvY2tfZ2V0dGltZShDTE9DS19NT05PVE9OSUMsICZ0cyk7CiAgcmV0dXJuICh1aW50NjRfdCl0cy50dl9zZWMgKiAxMDAwICsgKHRzLnR2X25zZWMgLyAxMDAwMDAwKTsKfQoKaW50CmpzbV9pbnRlcnJ1cHRfaGFuZGxlcihKU1J1bnRpbWUqIHJ0LCB2b2lkKiBvcGFxdWUpIHsKICByZXR1cm4gKGpzbV9wZW5kaW5nX3NpZ25hbHMgPj4gU0lHSU5UKSAmIDE7Cn0KCnZvaWQKanNtX3VubGlua190aW1lcihKU1J1bnRpbWUqIHJ0LCBKU09TVGltZXIqIHRoKSB7CiAgaWYodGgtPmxpbmsucHJldikgewogICAgbGlzdF9kZWwoJnRoLT5saW5rKTsKICAgIHRoLT5saW5rLnByZXYgPSB0aC0+bGluay5uZXh0ID0gTlVMTDsKICB9Cn0KCnZvaWQKanNtX2ZyZWVfdGltZXIoSlNSdW50aW1lKiBydCwgSlNPU1RpbWVyKiB0aCkgewogIEpTX0ZyZWVWYWx1ZVJUKHJ0LCB0aC0+ZnVuYyk7CiAganNfZnJlZV9ydChydCwgdGgpOwp9Cgp2b2lkCmpzbV9jYWxsX2hhbmRsZXIoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBmdW5jKSB7CiAgSlNWYWx1ZSByZXQsIGZ1bmMxOwogIC8qICdmdW5jJyBtaWdodCBiZSBkZXN0cm95ZWQgd2hlbiBjYWxsaW5nIGl0c2VsZiAoaWYgaXQgZnJlZXMgdGhlCiAgICAgaGFuZGxlciksIHNvIG11c3QgdGFrZSBleHRyYSBjYXJlICovCiAgZnVuYzEgPSBKU19EdXBWYWx1ZShjdHgsIGZ1bmMpOwogIHJldCA9IEpTX0NhbGwoY3R4LCBmdW5jMSwgSlNfVU5ERUZJTkVELCAwLCBOVUxMKTsKICBKU19GcmVlVmFsdWUoY3R4LCBmdW5jMSk7CiAgaWYoSlNfSXNFeGNlcHRpb24ocmV0KSkKICAgIGpzbV9zdGRfZHVtcF9lcnJvcihjdHgsIEpTX0dldEV4Y2VwdGlvbihjdHgpKTsKICBKU19GcmVlVmFsdWUoY3R4LCByZXQpOwp9Cgp2b2lkCmpzbV9zYWJfZnJlZSh2b2lkKiBvcGFxdWUsIHZvaWQqIHB0cikgewogIEpTU0FCSGVhZGVyKiBzYWI7CiAgaW50IHJlZl9jb3VudDsKICBzYWIgPSAoSlNTQUJIZWFkZXIqKSgodWludDhfdCopcHRyIC0gc2l6ZW9mKEpTU0FCSGVhZGVyKSk7CiAgcmVmX2NvdW50ID0gYXRvbWljX2FkZF9pbnQoJnNhYi0+cmVmX2NvdW50LCAtMSk7CiAgYXNzZXJ0KHJlZl9jb3VudCA+PSAwKTsKICBpZihyZWZfY291bnQgPT0gMCkgewogICAgZnJlZShzYWIpOwogIH0KfQoKdm9pZApqc21fZnJlZV9tZXNzYWdlKEpTV29ya2VyTWVzc2FnZSogbXNnKSB7CiAgc2l6ZV90IGk7CiAgLyogZnJlZSB0aGUgU0FCICovCiAgZm9yKGkgPSAwOyBpIDwgbXNnLT5zYWJfdGFiX2xlbjsgaSsrKSB7IGpzbV9zYWJfZnJlZShOVUxMLCBtc2ctPnNhYl90YWJbaV0pOyB9CiAgZnJlZShtc2ctPnNhYl90YWIpOwogIGZyZWUobXNnLT5kYXRhKTsKICBmcmVlKG1zZyk7Cn0KCi8qIHJldHVybiAxIGlmIGEgbWVzc2FnZSB3YXMgaGFuZGxlZCwgMCBpZiBubyBtZXNzYWdlICovCnN0YXRpYyBpbnQKanNtX2hhbmRsZV9wb3N0ZWRfbWVzc2FnZShKU1J1bnRpbWUqIHJ0LCBKU0NvbnRleHQqIGN0eCwgSlNXb3JrZXJNZXNzYWdlSGFuZGxlciogcG9ydCkgewogIEpTV29ya2VyTWVzc2FnZVBpcGUqIHBzID0gcG9ydC0+cmVjdl9waXBlOwogIGludCByZXQ7CiAgc3RydWN0IGxpc3RfaGVhZCogZWw7CiAgSlNXb3JrZXJNZXNzYWdlKiBtc2c7CiAgSlNWYWx1ZSBvYmosIGRhdGFfb2JqLCBmdW5jLCByZXR2YWw7CgogIHB0aHJlYWRfbXV0ZXhfbG9jaygmcHMtPm11dGV4KTsKICBpZighbGlzdF9lbXB0eSgmcHMtPm1zZ19xdWV1ZSkpIHsKICAgIGVsID0gcHMtPm1zZ19xdWV1ZS5uZXh0OwogICAgbXNnID0gbGlzdF9lbnRyeShlbCwgSlNXb3JrZXJNZXNzYWdlLCBsaW5rKTsKCiAgICAvKiByZW1vdmUgdGhlIG1lc3NhZ2UgZnJvbSB0aGUgcXVldWUgKi8KICAgIGxpc3RfZGVsKCZtc2ctPmxpbmspOwoKICAgIGlmKGxpc3RfZW1wdHkoJnBzLT5tc2dfcXVldWUpKSB7CiAgICAgIHVpbnQ4X3QgYnVmWzE2XTsKICAgICAgaW50IHJldDsKICAgICAgZm9yKDs7KSB7CiAgICAgICAgcmV0ID0gcmVhZChwcy0+cmVhZF9mZCwgYnVmLCBzaXplb2YoYnVmKSk7CiAgICAgICAgaWYocmV0ID49IDApCiAgICAgICAgICBicmVhazsKICAgICAgICBpZihlcnJubyAhPSBFQUdBSU4gJiYgZXJybm8gIT0gRUlOVFIpCiAgICAgICAgICBicmVhazsKICAgICAgfQogICAgfQoKICAgIHB0aHJlYWRfbXV0ZXhfdW5sb2NrKCZwcy0+bXV0ZXgpOwoKICAgIGRhdGFfb2JqID0gSlNfUmVhZE9iamVjdChjdHgsIG1zZy0+ZGF0YSwgbXNnLT5kYXRhX2xlbiwgSlNfUkVBRF9PQkpfU0FCIHwgSlNfUkVBRF9PQkpfUkVGRVJFTkNFKTsKCiAgICBqc21fZnJlZV9tZXNzYWdlKG1zZyk7CgogICAgaWYoSlNfSXNFeGNlcHRpb24oZGF0YV9vYmopKQogICAgICBnb3RvIGZhaWw7CiAgICBvYmogPSBKU19OZXdPYmplY3QoY3R4KTsKICAgIGlmKEpTX0lzRXhjZXB0aW9uKG9iaikpIHsKICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgZGF0YV9vYmopOwogICAgICBnb3RvIGZhaWw7CiAgICB9CiAgICBKU19EZWZpbmVQcm9wZXJ0eVZhbHVlU3RyKGN0eCwgb2JqLCAiZGF0YSIsIGRhdGFfb2JqLCBKU19QUk9QX0NfV19FKTsKCiAgICAvKiAnZnVuYycgbWlnaHQgYmUgZGVzdHJveWVkIHdoZW4gY2FsbGluZyBpdHNlbGYgKGlmIGl0IGZyZWVzIHRoZQogICAgICAgaGFuZGxlciksIHNvIG11c3QgdGFrZSBleHRyYSBjYXJlICovCiAgICBmdW5jID0gSlNfRHVwVmFsdWUoY3R4LCBwb3J0LT5vbl9tZXNzYWdlX2Z1bmMpOwogICAgcmV0dmFsID0gSlNfQ2FsbChjdHgsIGZ1bmMsIEpTX1VOREVGSU5FRCwgMSwgKEpTVmFsdWVDb25zdCopJm9iaik7CiAgICBKU19GcmVlVmFsdWUoY3R4LCBvYmopOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgZnVuYyk7CiAgICBpZihKU19Jc0V4Y2VwdGlvbihyZXR2YWwpKSB7CiAgICBmYWlsOgogICAgICBqc19zdGRfZHVtcF9lcnJvcihjdHgpOwogICAgfSBlbHNlIHsKICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgcmV0dmFsKTsKICAgIH0KICAgIHJldCA9IDE7CiAgfSBlbHNlIHsKICAgIHB0aHJlYWRfbXV0ZXhfdW5sb2NrKCZwcy0+bXV0ZXgpOwogICAgcmV0ID0gMDsKICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNtX2xvYWRfcGFja2FnZV9qc29uKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBmaWxlbmFtZSkgewogIGlmKEpTX0lzVW5kZWZpbmVkKHBhY2thZ2VfanNvbikpIHsKICAgIHVpbnQ4X3QqIGJ1ZjsKICAgIHNpemVfdCBidWZfbGVuOwogICAgaWYoZmlsZW5hbWUgPT0gMCkKICAgICAgZmlsZW5hbWUgPSAicGFja2FnZS5qc29uIjsKICAgIGlmKCEoYnVmID0ganNfbG9hZF9maWxlKGN0eCwgJmJ1Zl9sZW4sIGZpbGVuYW1lKSkpCiAgICAgIHBhY2thZ2VfanNvbiA9IEpTX05VTEw7CiAgICBlbHNlCiAgICAgIHBhY2thZ2VfanNvbiA9IEpTX1BhcnNlSlNPTihjdHgsIGJ1ZiwgYnVmX2xlbiwgZmlsZW5hbWUpOwogIH0KICByZXR1cm4gSlNfRHVwVmFsdWUoY3R4LCBwYWNrYWdlX2pzb24pOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc21fbW9kdWxlX2V4cG9ydHMoSlNDb250ZXh0KiBjdHgsIEpTTW9kdWxlRGVmKiBtb2R1bGUpIHsKICBKU1ZhbHVlIGV4cG9ydHMgPSBKU19OZXdPYmplY3QoY3R4KTsKICBzaXplX3QgaTsKCiAgZm9yKGkgPSAwOyBpIDwgbW9kdWxlLT5leHBvcnRfZW50cmllc19jb3VudDsgaSsrKSB7CiAgICBKU0V4cG9ydEVudHJ5KiBlbnRyeSA9ICZtb2R1bGUtPmV4cG9ydF9lbnRyaWVzW2ldOwogICAgSlNWYXJSZWYqIHJlZiA9IGVudHJ5LT51LmxvY2FsLnZhcl9yZWY7CgogICAgaWYocmVmKSB7CiAgICAgIEpTVmFsdWUgZXhwb3J0ID0gSlNfRHVwVmFsdWUoY3R4LCByZWYtPnB2YWx1ZSA/ICpyZWYtPnB2YWx1ZSA6IHJlZi0+dmFsdWUpOwogICAgICBKU19TZXRQcm9wZXJ0eShjdHgsIGV4cG9ydHMsIGVudHJ5LT5leHBvcnRfbmFtZSwgZXhwb3J0KTsKICAgIH0KICB9CiAgcmV0dXJuIGV4cG9ydHM7Cn0KCnN0YXRpYyBKU01vZHVsZURlZioKanNtX21vZHVsZV9maW5kKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBuYW1lKSB7CiAgc3RydWN0IGxpc3RfaGVhZCogZWw7CiAgc2l6ZV90IG5hbWVsZW4gPSBzdHJsZW4obmFtZSk7CiAgbGlzdF9mb3JfZWFjaChlbCwgJmN0eC0+bG9hZGVkX21vZHVsZXMpIHsKICAgIEpTTW9kdWxlRGVmKiBtID0gbGlzdF9lbnRyeShlbCwgSlNNb2R1bGVEZWYsIGxpbmspOwogICAgY29uc3QgY2hhciAqbiwgKnN0ciA9IEpTX0F0b21Ub0NTdHJpbmcoY3R4LCBtLT5tb2R1bGVfbmFtZSk7CiAgICBzaXplX3QgbGVuOwogICAgbiA9IGJhc2VuYW1lKHN0cik7CiAgICBsZW4gPSBzdHJfcmNocihuLCAnLicpOwogICAgLy8gcHJpbnRmKCJqc21fbW9kdWxlX2ZpbmQgJXNcbiIsIG4pOwogICAgaWYoIXN0cmNtcChzdHIsIG5hbWUpIHx8ICFzdHJjbXAobiwgbmFtZSkgfHwgKGxlbiA9PSBuYW1lbGVuICYmICFzdHJuY21wKG4sIG5hbWUsIGxlbikpKQogICAgICByZXR1cm4gbTsKCiAgICBKU19GcmVlQ1N0cmluZyhjdHgsIHN0cik7CiAgfQogIHJldHVybiAwOwp9CgpzdGF0aWMgSlNNb2R1bGVEZWYqCmpzbV9tb2R1bGVfZ2V0KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBKU01vZHVsZURlZiogbSA9IDA7CiAgaWYoSlNfSXNTdHJpbmcodmFsdWUpKSB7CiAgICBjb25zdCBjaGFyKiBuYW1lID0gSlNfVG9DU3RyaW5nKGN0eCwgdmFsdWUpOwoKICAgIG0gPSBqc21fbW9kdWxlX2ZpbmQoY3R4LCBuYW1lKTsKCiAgICBKU19GcmVlQ1N0cmluZyhjdHgsIG5hbWUpOwogIH0gZWxzZSBpZihKU19WQUxVRV9HRVRfVEFHKHZhbHVlKSA9PSBKU19UQUdfTU9EVUxFKSB7CiAgICBtID0gSlNfVkFMVUVfR0VUX1BUUih2YWx1ZSk7CiAgfQogIHJldHVybiBtOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc21fbW9kdWxlX2xpc3QoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX3ZhbCkgewogIHN0cnVjdCBsaXN0X2hlYWQqIGVsOwogIEpTVmFsdWUgcmV0ID0gSlNfTmV3QXJyYXkoY3R4KTsKICB1aW50MzJfdCBpID0gMDsKICBsaXN0X2Zvcl9lYWNoKGVsLCAmY3R4LT5sb2FkZWRfbW9kdWxlcykgewogICAgSlNNb2R1bGVEZWYqIG0gPSBsaXN0X2VudHJ5KGVsLCBKU01vZHVsZURlZiwgbGluayk7CiAgICBKU1ZhbHVlIG1vZHVsZU5hbWUgPSBKU19BdG9tVG9WYWx1ZShjdHgsIG0tPm1vZHVsZV9uYW1lKTsKICAgIGNvbnN0IGNoYXIqIHN0ciA9IEpTX1RvQ1N0cmluZyhjdHgsIG1vZHVsZU5hbWUpOwoKICAgIGlmKHN0clswXSAhPSAnPCcpCiAgICAgIEpTX1NldFByb3BlcnR5VWludDMyKGN0eCwgcmV0LCBpKyssIEpTX0R1cFZhbHVlKGN0eCwgSlNfTUtQVFIoSlNfVEFHX01PRFVMRSwgbSkpKTsKCiAgICBKU19GcmVlQ1N0cmluZyhjdHgsIHN0cik7CiAgICBKU19GcmVlVmFsdWUoY3R4LCBtb2R1bGVOYW1lKTsKICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQKanNtX2R1bXBfb2JqKEpTQ29udGV4dCogY3R4LCBGSUxFKiBmLCBKU1ZhbHVlQ29uc3QgdmFsKSB7CiAgY29uc3QgY2hhciogc3RyOwoKICBzdHIgPSBKU19Ub0NTdHJpbmcoY3R4LCB2YWwpOwogIGlmKHN0cikgewogICAgZnByaW50ZihmLCAiJXNcbiIsIHN0cik7CiAgICBKU19GcmVlQ1N0cmluZyhjdHgsIHN0cik7CiAgfSBlbHNlIHsKICAgIGZwcmludGYoZiwgIltleGNlcHRpb25dXG4iKTsKICB9Cn0KCnN0YXRpYyB2b2lkCmpzbV9zdGRfZHVtcF9lcnJvcjEoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBleGNlcHRpb25fdmFsKSB7CiAgSlNWYWx1ZSB2YWw7CiAgQk9PTCBpc19lcnJvcjsKCiAgaXNfZXJyb3IgPSBKU19Jc0Vycm9yKGN0eCwgZXhjZXB0aW9uX3ZhbCk7CiAganNtX2R1bXBfb2JqKGN0eCwgc3RkZXJyLCBleGNlcHRpb25fdmFsKTsKICBpZihpc19lcnJvcikgewogICAgdmFsID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBleGNlcHRpb25fdmFsLCAic3RhY2siKTsKICAgIGlmKCFKU19Jc1VuZGVmaW5lZCh2YWwpKSB7CiAgICAgIGpzbV9kdW1wX29iaihjdHgsIHN0ZGVyciwgdmFsKTsKICAgIH0KICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbCk7CiAgfQp9Cgp2b2lkCmpzbV9zdGRfZHVtcF9lcnJvcihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZSBleGNlcHRpb25fdmFsKSB7CgogIGlmKCFKU19Jc051bGwoZXhjZXB0aW9uX3ZhbCkpCiAgICBqc21fc3RkX2R1bXBfZXJyb3IxKGN0eCwgZXhjZXB0aW9uX3ZhbCk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgZXhjZXB0aW9uX3ZhbCk7Cn0KCiNpbmNsdWRlICJxdWlja2pzLmgiCiNpbmNsdWRlICJxdWlja2pzLWxpYmMuaCIKI2luY2x1ZGUgPHN0ZGxpYi5oPgojaW5jbHVkZSA8c3RyaW5nLmg+CiNpbmNsdWRlIDxzeXMvc3RhdC5oPgoKY29uc3QgY2hhciBqc21fZGVmYXVsdF9tb2R1bGVfcGF0aFtdID0gIi4iCiNpZmRlZiBDT05GSUdfUFJFRklYCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICI6IiBDT05GSUdfUFJFRklYICIvbGliL3F1aWNranMiCiNlbmRpZgogICAgOwoKY2hhcioKanNtX2ZpbmRfbW9kdWxlX2V4dChKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogbW9kdWxlX25hbWUsIGNvbnN0IGNoYXIqIGV4dCkgewogIGNvbnN0IGNoYXIgKm1vZHVsZV9wYXRoLCAqcCwgKnE7CiAgY2hhciogZmlsZW5hbWUgPSBOVUxMOwogIHNpemVfdCBuLCBtOwogIHN0cnVjdCBzdGF0IHN0OwoKICBpZigobW9kdWxlX3BhdGggPSBnZXRlbnYoIlFVSUNLSlNfTU9EVUxFX1BBVEgiKSkgPT0gTlVMTCkKICAgIG1vZHVsZV9wYXRoID0ganNtX2RlZmF1bHRfbW9kdWxlX3BhdGg7CgogIGZvcihwID0gbW9kdWxlX3BhdGg7ICpwOyBwID0gcSkgewogICAgaWYoKHEgPSBzdHJjaHIocCwgJzonKSkgPT0gTlVMTCkKICAgICAgcSA9IHAgKyBzdHJsZW4ocCk7CiAgICBuID0gcSAtIHA7CiAgICBmaWxlbmFtZSA9IGpzX21hbGxvYyhjdHgsIG4gKyAxICsgc3RybGVuKG1vZHVsZV9uYW1lKSArIDMgKyAxKTsKICAgIHN0cm5jcHkoZmlsZW5hbWUsIHAsIG4pOwogICAgZmlsZW5hbWVbbl0gPSAnLyc7CiAgICBzdHJjcHkoJmZpbGVuYW1lW24gKyAxXSwgbW9kdWxlX25hbWUpOwogICAgbSA9IHN0cmxlbihtb2R1bGVfbmFtZSk7CiAgICBpZighKG0gPj0gMyAmJiAhc3RyY21wKCZtb2R1bGVfbmFtZVttIC0gM10sIGV4dCkpKQogICAgICBzdHJjcHkoJmZpbGVuYW1lW24gKyAxICsgbV0sIGV4dCk7CiAgICBpZighc3RhdChmaWxlbmFtZSwgJnN0KSkKICAgICAgcmV0dXJuIGZpbGVuYW1lOwogICAganNfZnJlZShjdHgsIGZpbGVuYW1lKTsKICAgIGlmKCpxID09ICc6JykKICAgICAgKytxOwogIH0KICByZXR1cm4gTlVMTDsKfQoKY2hhcioKanNtX2ZpbmRfbW9kdWxlKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBtb2R1bGVfbmFtZSkgewogIGNoYXIqIHJldCA9IE5VTEw7CiAgc2l6ZV90IGxlbjsKCiAgd2hpbGUoIXN0cm5jbXAobW9kdWxlX25hbWUsICIuLyIsIDIpKSBtb2R1bGVfbmFtZSA9IHRyaW1fZG90c2xhc2gobW9kdWxlX25hbWUpOwogIGxlbiA9IHN0cmxlbihtb2R1bGVfbmFtZSk7CgogIGlmKHN0cmNocihtb2R1bGVfbmFtZSwgJy8nKSA9PSBOVUxMIHx8IChsZW4gPj0gMyAmJiAhc3RyY21wKCZtb2R1bGVfbmFtZVtsZW4gLSAzXSwgIi5zbyIpKSkKICAgIHJldCA9IGpzbV9maW5kX21vZHVsZV9leHQoY3R4LCBtb2R1bGVfbmFtZSwgIi5zbyIpOwoKICBpZihyZXQgPT0gTlVMTCkKICAgIHJldCA9IGpzbV9maW5kX21vZHVsZV9leHQoY3R4LCBtb2R1bGVfbmFtZSwgIi5qcyIpOwogIHJldHVybiByZXQ7Cn0KCmNoYXIqCmpzbV9ub3JtYWxpemVfbW9kdWxlKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBiYXNlX25hbWUsIGNvbnN0IGNoYXIqIG5hbWUsIHZvaWQqIG9wYXF1ZSkgewogIHNpemVfdCBwOwogIGNvbnN0IGNoYXIqIHI7CiAgRHluQnVmIGZpbGUgPSB7MCwgMCwgMH07CiAgc2l6ZV90IG47CiAgaWYobmFtZVswXSAhPSAnLicpCiAgICByZXR1cm4ganNfc3RyZHVwKGN0eCwgbmFtZSk7CgogIGpzX2RidWZfaW5pdChjdHgsICZmaWxlKTsKCiAgbiA9IGJhc2VfbmFtZVsocCA9IHN0cl9yY2hyKGJhc2VfbmFtZSwgJy8nKSldID8gcCA6IDA7CgogIGRidWZfcHV0KCZmaWxlLCBiYXNlX25hbWUsIG4pOwogIGRidWZfMCgmZmlsZSk7CgogIGZvcihyID0gbmFtZTs7KSB7CiAgICBpZihyWzBdID09ICcuJyAmJiByWzFdID09ICcvJykgewogICAgICByICs9IDI7CiAgICB9IGVsc2UgaWYoclswXSA9PSAnLicgJiYgclsxXSA9PSAnLicgJiYgclsyXSA9PSAnLycpIHsKICAgICAgLyogcmVtb3ZlIHRoZSBsYXN0IHBhdGggZWxlbWVudCBvZiBmaWxlLCBleGNlcHQgaWYgIi4iIG9yICIuLiIgKi8KICAgICAgaWYoZmlsZS5zaXplID09IDApCiAgICAgICAgYnJlYWs7CiAgICAgIGlmKChwID0gYnl0ZV9yY2hyKGZpbGUuYnVmLCBmaWxlLnNpemUsICcvJykpIDwgZmlsZS5zaXplKQogICAgICAgIHArKzsKICAgICAgZWxzZQogICAgICAgIHAgPSAwOwogICAgICBpZighc3RyY21wKCZmaWxlLmJ1ZltwXSwgIi4iKSB8fCAhc3RyY21wKCZmaWxlLmJ1ZltwXSwgIi4uIikpCiAgICAgICAgYnJlYWs7CiAgICAgIGlmKHAgPiAwKQogICAgICAgIHAtLTsKICAgICAgZmlsZS5zaXplID0gcDsKICAgICAgciArPSAzOwogICAgfSBlbHNlIHsKICAgICAgYnJlYWs7CiAgICB9CiAgfQogIGlmKGZpbGUuc2l6ZSA9PSAwKQogICAgZGJ1Zl9wdXRjKCZmaWxlLCAnLicpOwoKICBkYnVmX3B1dGMoJmZpbGUsICcvJyk7CiAgZGJ1Zl9wdXRzdHIoJmZpbGUsIHIpOwogIGRidWZfMCgmZmlsZSk7CgogIC8vIHByaW50ZigianNtX25vcm1hbGl6ZV9tb2R1bGVceDFiWzE7NDg7NTsyN20oMSlceDFiWzBtICUtNDBzICUtNDBzIC0+ICVzXG4iLCBiYXNlX25hbWUsIG5hbWUsIGZpbGUuYnVmKTsKCiAgcmV0dXJuIGZpbGUuYnVmOwp9CnN0YXRpYyBKU01vZHVsZURlZioKanNtX21vZHVsZV9sb2FkZXJfc28oSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIG1vZHVsZV9uYW1lKSB7CiAgSlNNb2R1bGVEZWYqIG07CiAgdm9pZCogaGQ7CiAgSlNNb2R1bGVEZWYqICgqaW5pdCkoSlNDb250ZXh0KiwgY29uc3QgY2hhciopOwogIGNoYXIqIGZpbGVuYW1lOwoKICBpZighc3RyY2hyKG1vZHVsZV9uYW1lLCAnLycpKSB7CiAgICAvKiBtdXN0IGFkZCBhICcvJyBzbyB0aGF0IHRoZSBETEwgaXMgbm90IHNlYXJjaGVkIGluIHRoZQogICAgICAgc3lzdGVtIGxpYnJhcnkgcGF0aHMgKi8KICAgIGZpbGVuYW1lID0ganNfbWFsbG9jKGN0eCwgc3RybGVuKG1vZHVsZV9uYW1lKSArIDIgKyAxKTsKICAgIGlmKCFmaWxlbmFtZSkKICAgICAgcmV0dXJuIE5VTEw7CiAgICBzdHJjcHkoZmlsZW5hbWUsICIuLyIpOwogICAgc3RyY3B5KGZpbGVuYW1lICsgMiwgbW9kdWxlX25hbWUpOwogIH0gZWxzZSB7CiAgICBmaWxlbmFtZSA9IChjaGFyKiltb2R1bGVfbmFtZTsKICB9CiAgLyogQyBtb2R1bGUgKi8KICBoZCA9IGRsb3BlbihmaWxlbmFtZSwgUlRMRF9OT1cgfCBSVExEX0xPQ0FMKTsKICBpZihmaWxlbmFtZSAhPSBtb2R1bGVfbmFtZSkKICAgIGpzX2ZyZWUoY3R4LCBmaWxlbmFtZSk7CiAgaWYoIWhkKSB7CiAgICBKU19UaHJvd1JlZmVyZW5jZUVycm9yKGN0eCwgImNvdWxkIG5vdCBsb2FkIG1vZHVsZSBmaWxlbmFtZSAnJXMnIGFzIHNoYXJlZCBsaWJyYXJ5OiAlcyIsIG1vZHVsZV9uYW1lLCBkbGVycm9yKCkpOwogICAgZ290byBmYWlsOwogIH0KCiAgaW5pdCA9IGRsc3ltKGhkLCAianNfaW5pdF9tb2R1bGUiKTsKICBpZighaW5pdCkgewogICAgSlNfVGhyb3dSZWZlcmVuY2VFcnJvcihjdHgsICJjb3VsZCBub3QgbG9hZCBtb2R1bGUgZmlsZW5hbWUgJyVzJzoganNfaW5pdF9tb2R1bGUgbm90IGZvdW5kIiwgbW9kdWxlX25hbWUpOwogICAgZ290byBmYWlsOwogIH0KCiAgbSA9IGluaXQoY3R4LCBtb2R1bGVfbmFtZSk7CiAgaWYoIW0pIHsKICAgIEpTX1Rocm93UmVmZXJlbmNlRXJyb3IoY3R4LCAiY291bGQgbm90IGxvYWQgbW9kdWxlIGZpbGVuYW1lICclcyc6IGluaXRpYWxpemF0aW9uIGVycm9yIiwgbW9kdWxlX25hbWUpOwogIGZhaWw6CiAgICBpZihoZCkKICAgICAgZGxjbG9zZShoZCk7CiAgICByZXR1cm4gTlVMTDsKICB9CiAgcmV0dXJuIG07Cn0KCkpTTW9kdWxlRGVmKgpqc21fbW9kdWxlX2xvYWRlcl9wYXRoKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBuYW1lLCB2b2lkKiBvcGFxdWUpIHsKICBjaGFyICptb2R1bGUsICpmaWxlID0gMDsKICBKU01vZHVsZURlZiogcmV0ID0gTlVMTDsKICBtb2R1bGUgPSBqc19zdHJkdXAoY3R4LCB0cmltX2RvdHNsYXNoKG5hbWUpKTsKICBmb3IoOzspIHsKICAgIGlmKCFzdHJjaHIobW9kdWxlLCAnLycpICYmIChyZXQgPSBqc21fbW9kdWxlX2ZpbmQoY3R4LCBtb2R1bGUpKSkgewogICAgICBnb3RvIGVuZDsKICAgIH0KICAgIGlmKGRlYnVnX21vZHVsZV9sb2FkZXIpIHsKICAgICAgaWYoZmlsZSkKICAgICAgICBwcmludGYoImpzbV9tb2R1bGVfbG9hZGVyX3BhdGhbJXhdIFx4MWJbNDg7NTsyMjBtKDIpXHgxYlswbSAlLTIwcyAnJXMnXG4iLAogICAgICAgICAgICAgICBwdGhyZWFkX3NlbGYoKSwKICAgICAgICAgICAgICAgdHJpbV9kb3RzbGFzaChuYW1lKSwKICAgICAgICAgICAgICAgZmlsZSk7CiAgICAgIC8qICBlbHNlICBwcmludGYoImpzbV9tb2R1bGVfbG9hZGVyX3BhdGhbJXhdIFx4MWJbNDg7NTsxMjRtKDEpXHgxYlswbSAlLTIwcyAtPiAlc1xuIiwgcHRocmVhZF9zZWxmKCksCiAgICAgICAqIHRyaW1fZG90c2xhc2gobmFtZSksIHRyaW1fZG90c2xhc2gobW9kdWxlKSk7Ki8KICAgIH0KICAgIGlmKCFoYXNfc3VmZml4KG5hbWUsICIuc28iKSAmJiAhZmlsZSkgewogICAgICBKU1ZhbHVlIHBhY2thZ2UgPSBqc21fbG9hZF9wYWNrYWdlX2pzb24oY3R4LCAwKTsKICAgICAgaWYoIUpTX0lzTnVsbChwYWNrYWdlKSkgewogICAgICAgIEpTVmFsdWUgYWxpYXNlcyA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgcGFja2FnZSwgIl9tb2R1bGVBbGlhc2VzIik7CiAgICAgICAgSlNWYWx1ZSB0YXJnZXQgPSBKU19VTkRFRklORUQ7CiAgICAgICAgaWYoIUpTX0lzVW5kZWZpbmVkKGFsaWFzZXMpKSB7CiAgICAgICAgICB0YXJnZXQgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIGFsaWFzZXMsIG1vZHVsZSk7CiAgICAgICAgfQogICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGFsaWFzZXMpOwogICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHBhY2thZ2UpOwogICAgICAgIGlmKCFKU19Jc1VuZGVmaW5lZCh0YXJnZXQpKSB7CiAgICAgICAgICBjb25zdCBjaGFyKiBzdHIgPSBKU19Ub0NTdHJpbmcoY3R4LCB0YXJnZXQpOwogICAgICAgICAgaWYoc3RyKSB7CiAgICAgICAgICAgIGpzX2ZyZWUoY3R4LCBtb2R1bGUpOwogICAgICAgICAgICBtb2R1bGUgPSBqc19zdHJkdXAoY3R4LCBzdHIpOwogICAgICAgICAgICBKU19GcmVlQ1N0cmluZyhjdHgsIHN0cik7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQogICAgaWYoIWZpbGUpIHsKICAgICAgaWYoc3RyY2hyKCIuLyIsIG1vZHVsZVswXSkpCiAgICAgICAgZmlsZSA9IGpzX3N0cmR1cChjdHgsIG1vZHVsZSk7CiAgICAgIGVsc2UgaWYoIShmaWxlID0ganNtX2ZpbmRfbW9kdWxlKGN0eCwgbW9kdWxlKSkpCiAgICAgICAgYnJlYWs7CiAgICAgIGNvbnRpbnVlOwogICAgfQogICAgYnJlYWs7CiAgfQogIGlmKGZpbGUpIHsKICAgIGlmKGRlYnVnX21vZHVsZV9sb2FkZXIpCiAgICAgIGlmKHN0cmNtcCh0cmltX2RvdHNsYXNoKG5hbWUpLCB0cmltX2RvdHNsYXNoKGZpbGUpKSkKICAgICAgICBwcmludGYoImpzbV9tb2R1bGVfbG9hZGVyX3BhdGhbJXhdIFx4MWJbNDg7NTsyOG0oMylceDFiWzBtICUtMjBzIC0+ICVzXG4iLCBwdGhyZWFkX3NlbGYoKSwgbW9kdWxlLCBmaWxlKTsKICAgIHJldCA9IGhhc19zdWZmaXgoZmlsZSwgIi5zbyIpID8ganNtX21vZHVsZV9sb2FkZXJfc28oY3R4LCBmaWxlKSA6IGpzX21vZHVsZV9sb2FkZXIoY3R4LCBmaWxlLCBvcGFxdWUpOwogIH0KZW5kOgogIGlmKHZlY3Rvcl9maW5kcygmbW9kdWxlX2RlYnVnLCAiaW1wb3J0IikgIT0gLTEpIHsKICAgIGZwcmludGYoc3RkZXJyLCAoIWZpbGUgfHwgc3RyY21wKG1vZHVsZSwgZmlsZSkpID8gIiEhISBJTVBPUlQgJXMgLT4gJXNcbiIgOiAiISEhIElNUE9SVCAlc1xuIiwgbW9kdWxlLCBmaWxlKTsKICB9CiAgaWYoIXJldCkKICAgIHByaW50ZigianNtX21vZHVsZV9sb2FkZXJfcGF0aChcIiVzXCIpID0gJXBcbiIsIG5hbWUsIHJldCk7CiAgaWYobW9kdWxlKQogICAganNfZnJlZShjdHgsIG1vZHVsZSk7CiAgaWYoZmlsZSkKICAgIGpzX2ZyZWUoY3R4LCBmaWxlKTsKICByZXR1cm4gcmV0Owp9CgpKU1ZhbHVlCmpzbV9ldmFsX2JpbmFyeShKU0NvbnRleHQqIGN0eCwgY29uc3QgdWludDhfdCogYnVmLCBzaXplX3QgYnVmX2xlbiwgaW50IGxvYWRfb25seSkgewogIEpTVmFsdWUgb2JqLCB2YWw7CiAgb2JqID0gSlNfUmVhZE9iamVjdChjdHgsIGJ1ZiwgYnVmX2xlbiwgSlNfUkVBRF9PQkpfQllURUNPREUpOwoKICBpZihKU19Jc0V4Y2VwdGlvbihvYmopKQogICAgcmV0dXJuIG9iajsKCiAgaWYoSlNfVkFMVUVfR0VUX1RBRyhvYmopID09IEpTX1RBR19NT0RVTEUpIHsKICAgIGlmKCFsb2FkX29ubHkgJiYgSlNfUmVzb2x2ZU1vZHVsZShjdHgsIG9iaikgPCAwKSB7CiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIG9iaik7CiAgICAgIHJldHVybiBKU19UaHJvd0ludGVybmFsRXJyb3IoY3R4LCAiRmFpbGVkIHJlc29sdmluZyBtb2R1bGUiKTsKICAgIH0KICAgIGpzX21vZHVsZV9zZXRfaW1wb3J0X21ldGEoY3R4LCBvYmosIEZBTFNFLCAhbG9hZF9vbmx5KTsKICAgIHZhbCA9IEpTX0V2YWxGdW5jdGlvbihjdHgsIG9iaik7CiAgfQogIHJldHVybiBvYmo7Cn0KCnN0YXRpYyBKU1ZhbHVlCmpzbV9ldmFsX2J1ZihKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogYnVmLCBpbnQgYnVmX2xlbiwgY29uc3QgY2hhciogZmlsZW5hbWUsIGludCBtb2R1bGUpIHsKICBKU1ZhbHVlIHZhbDsKCiAgaWYobW9kdWxlKSB7CiAgICAvKiBmb3IgdGhlIG1vZHVsZXMsIHdlIGNvbXBpbGUgdGhlbiBydW4gdG8gYmUgYWJsZSB0byBzZXQKICAgICAgIGltcG9ydC5tZXRhICovCiAgICB2YWwgPSBKU19FdmFsKGN0eCwgYnVmLCBidWZfbGVuLCBmaWxlbmFtZSwgSlNfRVZBTF9UWVBFX01PRFVMRSB8IEpTX0VWQUxfRkxBR19DT01QSUxFX09OTFkpOwoKICAgIGlmKEpTX0lzRXhjZXB0aW9uKHZhbCkpIHsKICAgICAgaWYoSlNfSXNOdWxsKEpTX0dldFJ1bnRpbWUoY3R4KS0+Y3VycmVudF9leGNlcHRpb24pKSB7CiAgICAgICAgSlNfR2V0RXhjZXB0aW9uKGN0eCk7CiAgICAgICAgdmFsID0gSlNfVU5ERUZJTkVEOwogICAgICB9CiAgICB9CgogICAgaWYoIUpTX0lzRXhjZXB0aW9uKHZhbCkpIHsKICAgICAganNfbW9kdWxlX3NldF9pbXBvcnRfbWV0YShjdHgsIHZhbCwgRkFMU0UsIFRSVUUpOwogICAgICAvKnZhbCA9Ki9KU19FdmFsRnVuY3Rpb24oY3R4LCB2YWwpOwogICAgfQogIH0gZWxzZSB7CiAgICB2YWwgPSBKU19FdmFsKGN0eCwgYnVmLCBidWZfbGVuLCBmaWxlbmFtZSwgbW9kdWxlICYgKH4oSlNfRVZBTF9UWVBFX01PRFVMRSkpKTsKICB9CgogIHJldHVybiB2YWw7Cn0KCnN0YXRpYyBpbnQKanNtX2V2YWxfc3RyKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBzdHIsIGNvbnN0IGNoYXIqIGZpbGVuYW1lLCBpbnQgbW9kdWxlKSB7CiAgSlNWYWx1ZSB2YWwgPSBqc21fZXZhbF9idWYoY3R4LCBzdHIsIHN0cmxlbihzdHIpLCBmaWxlbmFtZSwgbW9kdWxlKTsKICBpbnQzMl90IHJldCA9IC0xOwoKICBpZihKU19Jc051bWJlcih2YWwpKQogICAgSlNfVG9JbnQzMihjdHgsICZyZXQsIHZhbCk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIEpTVmFsdWUKanNtX2V2YWxfZmlsZShKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogZmlsZW5hbWUsIGludCBtb2R1bGUpIHsKICB1aW50OF90KiBidWY7CiAgc2l6ZV90IGJ1Zl9sZW47CiAgaW50IGV2YWxfZmxhZ3M7CgogIGlmKCEoYnVmID0ganNfbG9hZF9maWxlKGN0eCwgJmJ1Zl9sZW4sIGZpbGVuYW1lKSkpIHsKICAgIGZwcmludGYoc3RkZXJyLCAiRmFpbGVkIGxvYWRpbmcgJyVzJzogJXNcbiIsIGZpbGVuYW1lLCBzdHJlcnJvcihlcnJubykpOwogICAgcmV0dXJuIEpTX1Rocm93SW50ZXJuYWxFcnJvcihjdHgsICJGYWlsZWQgbG9hZGluZyAnJXMnOiAlcyIsIGZpbGVuYW1lLCBzdHJlcnJvcihlcnJubykpOwogICAgLyogcGVycm9yKGZpbGVuYW1lKTsKICAgICBleGl0KDEpOyovCiAgfQoKICBpZihtb2R1bGUgPCAwKQogICAgbW9kdWxlID0gKGhhc19zdWZmaXgoZmlsZW5hbWUsICIubWpzIikgfHwgSlNfRGV0ZWN0TW9kdWxlKChjb25zdCBjaGFyKilidWYsIGJ1Zl9sZW4pKTsKCiAgaWYobW9kdWxlKQogICAgZXZhbF9mbGFncyA9IEpTX0VWQUxfVFlQRV9NT0RVTEU7CiAgZWxzZQogICAgZXZhbF9mbGFncyA9IEpTX0VWQUxfVFlQRV9HTE9CQUw7CgogIHJldHVybiBqc21fZXZhbF9idWYoY3R4LCBidWYsIGJ1Zl9sZW4sIGZpbGVuYW1lLCBldmFsX2ZsYWdzKTsKfQoKc3RhdGljIGludApqc21fbG9hZF9zY3JpcHQoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIGZpbGVuYW1lLCBpbnQgbW9kdWxlKSB7CiAgSlNWYWx1ZSB2YWw7CiAgaW50MzJfdCByZXQgPSAwOwogIHZhbCA9IGpzbV9ldmFsX2ZpbGUoY3R4LCBmaWxlbmFtZSwgbW9kdWxlKTsKICBpZihKU19Jc0V4Y2VwdGlvbih2YWwpKSB7CiAgICBqc21fZHVtcF9vYmooY3R4LCBzdGRlcnIsIHZhbCk7CgogICAgLy8gICAganNtX3N0ZF9kdW1wX2Vycm9yKGN0eCwgSlNfR2V0RXhjZXB0aW9uKGN0eCkpOwogICAgcmV0dXJuIC0xOwogIH0KICBpZihKU19Jc051bWJlcih2YWwpKQogICAgSlNfVG9JbnQzMihjdHgsICZyZXQsIHZhbCk7CiAgaWYoSlNfVkFMVUVfR0VUX1RBRyh2YWwpICE9IEpTX1RBR19NT0RVTEUpCiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWwpOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBKU01vZHVsZURlZioKanNtX2xvYWRfbW9kdWxlKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBuYW1lKSB7CiAgRHluQnVmIGJ1ZjsKICBKU01vZHVsZURlZiogbTsKICBqc19kYnVmX2luaXQoY3R4LCAmYnVmKTsKICBkYnVmX3ByaW50ZigmYnVmLCAiaW1wb3J0ICogYXMgJXMgZnJvbSAnJXMnOyBnbG9iYWxUaGlzLiVzID0gJXM7IiwgbmFtZSwgbmFtZSwgbmFtZSwgbmFtZSk7CiAgZGJ1Zl8wKCZidWYpOwogIGpzbV9ldmFsX2J1ZihjdHgsIGJ1Zi5idWYsIGJ1Zi5zaXplLCAiPGlucHV0PiIsIFRSVUUpOwoKICBtID0ganNtX21vZHVsZV9maW5kKGN0eCwgbmFtZSk7CgogIHJldHVybiBtOwp9CgpzdGF0aWMgdm9pZApqc21fbGlzdF9tb2R1bGVzKEpTQ29udGV4dCogY3R4KSB7CiAgc3RydWN0IGxpc3RfaGVhZCogZWw7CiAgbGlzdF9mb3JfZWFjaChlbCwgJmN0eC0+bG9hZGVkX21vZHVsZXMpIHsKICAgIEpTTW9kdWxlRGVmKiBtID0gbGlzdF9lbnRyeShlbCwgSlNNb2R1bGVEZWYsIGxpbmspOwogICAgY29uc3QgY2hhciAqbiwgKnN0ciA9IEpTX0F0b21Ub0NTdHJpbmcoY3R4LCBtLT5tb2R1bGVfbmFtZSk7CiAgICBzaXplX3QgbGVuID0gc3RybGVuKHN0cik7CgogICAgSlNfRnJlZUNTdHJpbmcoY3R4LCBzdHIpOwogIH0KfQoKLyogYWxzbyB1c2VkIHRvIGluaXRpYWxpemUgdGhlIHdvcmtlciBjb250ZXh0ICovCnN0YXRpYyBKU0NvbnRleHQqCmpzbV9jb250ZXh0X25ldyhKU1J1bnRpbWUqIHJ0KSB7CiAgSlNDb250ZXh0KiBjdHg7CiAgY3R4ID0gSlNfTmV3Q29udGV4dChydCk7CiAgaWYoIWN0eCkKICAgIHJldHVybiBOVUxMOwojaWZkZWYgQ09ORklHX0JJR05VTQogIGlmKGJpZ251bV9leHQpIHsKICAgIEpTX0FkZEludHJpbnNpY0JpZ0Zsb2F0KGN0eCk7CiAgICBKU19BZGRJbnRyaW5zaWNCaWdEZWNpbWFsKGN0eCk7CiAgICBKU19BZGRJbnRyaW5zaWNPcGVyYXRvcnMoY3R4KTsKICAgIEpTX0VuYWJsZUJpZ251bUV4dChjdHgsIFRSVUUpOwogIH0KI2VuZGlmCgojZGVmaW5lIGpzbV9tb2R1bGVfbmF0aXZlKG5hbWUpIGpzX2luaXRfbW9kdWxlXyMjbmFtZShjdHgsICNuYW1lKTsKCiAganNtX21vZHVsZV9uYXRpdmUoc3RkKTsKICBqc21fbW9kdWxlX25hdGl2ZShvcyk7CiAganNtX21vZHVsZV9uYXRpdmUoY2hpbGRfcHJvY2Vzcyk7CiAganNtX21vZHVsZV9uYXRpdmUoZGVlcCk7CiAganNtX21vZHVsZV9uYXRpdmUoaW5zcGVjdCk7CiAganNtX21vZHVsZV9uYXRpdmUobGV4ZXIpOwogIGpzbV9tb2R1bGVfbmF0aXZlKG1pc2MpOwogIGpzbV9tb2R1bGVfbmF0aXZlKG1tYXApOwogIGpzbV9tb2R1bGVfbmF0aXZlKHBhdGgpOwogIGpzbV9tb2R1bGVfbmF0aXZlKHBvaW50ZXIpOwogIGpzbV9tb2R1bGVfbmF0aXZlKHByZWRpY2F0ZSk7CiAganNtX21vZHVsZV9uYXRpdmUocmVwZWF0ZXIpOwogIGpzbV9tb2R1bGVfbmF0aXZlKHRyZWVfd2Fsa2VyKTsKICBqc21fbW9kdWxlX25hdGl2ZSh4bWwpOwogIHJldHVybiBjdHg7Cn0KCiNpZiBkZWZpbmVkKF9fQVBQTEVfXykKI2RlZmluZSBNQUxMT0NfT1ZFUkhFQUQgMAojZWxzZQojZGVmaW5lIE1BTExPQ19PVkVSSEVBRCA4CiNlbmRpZgoKc3RydWN0IHRyYWNlX21hbGxvY19kYXRhIHsKICB1aW50OF90KiBiYXNlOwp9OwoKc3RhdGljIHZvaWQKZHVtcF92ZWN0b3IoY29uc3QgVmVjdG9yKiB2ZWMsIHNpemVfdCBzdGFydCkgewogIHNpemVfdCBpLCBsZW4gPSB2ZWN0b3Jfc2l6ZSh2ZWMsIHNpemVvZihjaGFyKikpOwogIGZvcihpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykgewogICAgY29uc3QgY2hhciogc3RyID0gKihjaGFyKiopdmVjdG9yX2F0KHZlYywgc2l6ZW9mKGNoYXIqKSwgaSk7CiAgICBmcHV0cyhpID4gc3RhcnQgPyAiJyxcbiAgJyIgOiAiW1xuICAnIiwgc3Rkb3V0KTsKICAgIGZwdXRzKHN0ciwgc3Rkb3V0KTsKICAgIGlmKGkgKyAxID09IGxlbikKICAgICAgcHV0cygiJ1xuXSIpOwogIH0KfQoKc3RhdGljIGlubGluZSB1bnNpZ25lZCBsb25nIGxvbmcKanNtX3RyYWNlX21hbGxvY19wdHJfb2Zmc2V0KHVpbnQ4X3QqIHB0ciwgc3RydWN0IHRyYWNlX21hbGxvY19kYXRhKiBkcCkgewogIHJldHVybiBwdHIgLSBkcC0+YmFzZTsKfQoKLyogZGVmYXVsdCBtZW1vcnkgYWxsb2NhdGlvbiBmdW5jdGlvbnMgd2l0aCBtZW1vcnkgbGltaXRhdGlvbiAqLwpzdGF0aWMgaW5saW5lIHNpemVfdApqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplKHZvaWQqIHB0cikgewojaWYgZGVmaW5lZChfX0FQUExFX18pCiAgcmV0dXJuIG1hbGxvY19zaXplKHB0cik7CiNlbGlmIGRlZmluZWQoX1dJTjMyKQogIHJldHVybiBfbXNpemUocHRyKTsKI2VsaWYgZGVmaW5lZChFTVNDUklQVEVOKSB8fCBkZWZpbmVkKF9fZGlldGxpYmNfXykgfHwgZGVmaW5lZChfX01TWVNfXykgfHwgZGVmaW5lZChET05UX0hBVkVfTUFMTE9DX1VTQUJMRV9TSVpFKQogIHJldHVybiAwOwojZWxpZiBkZWZpbmVkKF9fbGludXhfXykgfHwgZGVmaW5lZChIQVZFX01BTExPQ19VU0FCTEVfU0laRSkKICByZXR1cm4gbWFsbG9jX3VzYWJsZV9zaXplKHB0cik7CiNlbHNlCiAgLyogY2hhbmdlIHRoaXMgdG8gYHJldHVybiAwO2AgaWYgY29tcGlsYXRpb24gZmFpbHMgKi8KICByZXR1cm4gbWFsbG9jX3VzYWJsZV9zaXplKHB0cik7CiNlbmRpZgp9CgpzdGF0aWMgdm9pZAojaWZkZWYgX1dJTjMyCiAgICAvKiBtaW5ndyBwcmludGYgaXMgdXNlZCAqLwogICAgX19hdHRyaWJ1dGVfXygoZm9ybWF0KGdudV9wcmludGYsIDIsIDMpKSkKI2Vsc2UKICAgIF9fYXR0cmlidXRlX18oKGZvcm1hdChwcmludGYsIDIsIDMpKSkKI2VuZGlmCiAgICBqc21fdHJhY2VfbWFsbG9jX3ByaW50ZihKU01hbGxvY1N0YXRlKiBzLCBjb25zdCBjaGFyKiBmbXQsIC4uLikgewogIHZhX2xpc3QgYXA7CiAgaW50IGM7CgogIHZhX3N0YXJ0KGFwLCBmbXQpOwogIHdoaWxlKChjID0gKmZtdCsrKSAhPSAnXDAnKSB7CiAgICBpZihjID09ICclJykgewogICAgICAvKiBvbmx5IGhhbmRsZSAlcCBhbmQgJXpkICovCiAgICAgIGlmKCpmbXQgPT0gJ3AnKSB7CiAgICAgICAgdWludDhfdCogcHRyID0gdmFfYXJnKGFwLCB2b2lkKik7CiAgICAgICAgaWYocHRyID09IE5VTEwpIHsKICAgICAgICAgIHByaW50ZigiTlVMTCIpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBwcmludGYoIkglKzA2bGxkLiV6ZCIsIGpzbV90cmFjZV9tYWxsb2NfcHRyX29mZnNldChwdHIsIHMtPm9wYXF1ZSksIGpzbV90cmFjZV9tYWxsb2NfdXNhYmxlX3NpemUocHRyKSk7CiAgICAgICAgfQogICAgICAgIGZtdCsrOwogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICAgIGlmKGZtdFswXSA9PSAneicgJiYgZm10WzFdID09ICdkJykgewogICAgICAgIHNpemVfdCBzeiA9IHZhX2FyZyhhcCwgc2l6ZV90KTsKICAgICAgICBwcmludGYoIiV6ZCIsIHN6KTsKICAgICAgICBmbXQgKz0gMjsKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgfQogICAgcHV0YyhjLCBzdGRvdXQpOwogIH0KICB2YV9lbmQoYXApOwp9CgpzdGF0aWMgdm9pZApqc21fdHJhY2VfbWFsbG9jX2luaXQoc3RydWN0IHRyYWNlX21hbGxvY19kYXRhKiBzKSB7CiAgZnJlZShzLT5iYXNlID0gbWFsbG9jKDgpKTsKfQoKc3RhdGljIHZvaWQqCmpzbV90cmFjZV9tYWxsb2MoSlNNYWxsb2NTdGF0ZSogcywgc2l6ZV90IHNpemUpIHsKICB2b2lkKiBwdHI7CgogIC8qIERvIG5vdCBhbGxvY2F0ZSB6ZXJvIGJ5dGVzOiBiZWhhdmlvciBpcyBwbGF0Zm9ybSBkZXBlbmRlbnQgKi8KICBhc3NlcnQoc2l6ZSAhPSAwKTsKCiAgaWYodW5saWtlbHkocy0+bWFsbG9jX3NpemUgKyBzaXplID4gcy0+bWFsbG9jX2xpbWl0KSkKICAgIHJldHVybiBOVUxMOwogIHB0ciA9IG1hbGxvYyhzaXplKTsKICBqc21fdHJhY2VfbWFsbG9jX3ByaW50ZihzLCAiQSAlemQgLT4gJXBcbiIsIHNpemUsIHB0cik7CiAgaWYocHRyKSB7CiAgICBzLT5tYWxsb2NfY291bnQrKzsKICAgIHMtPm1hbGxvY19zaXplICs9IGpzbV90cmFjZV9tYWxsb2NfdXNhYmxlX3NpemUocHRyKSArIE1BTExPQ19PVkVSSEVBRDsKICB9CiAgcmV0dXJuIHB0cjsKfQoKc3RhdGljIHZvaWQKanNtX3RyYWNlX2ZyZWUoSlNNYWxsb2NTdGF0ZSogcywgdm9pZCogcHRyKSB7CiAgaWYoIXB0cikKICAgIHJldHVybjsKCiAganNtX3RyYWNlX21hbGxvY19wcmludGYocywgIkYgJXBcbiIsIHB0cik7CiAgcy0+bWFsbG9jX2NvdW50LS07CiAgcy0+bWFsbG9jX3NpemUgLT0ganNtX3RyYWNlX21hbGxvY191c2FibGVfc2l6ZShwdHIpICsgTUFMTE9DX09WRVJIRUFEOwogIGZyZWUocHRyKTsKfQoKc3RhdGljIHZvaWQqCmpzbV90cmFjZV9yZWFsbG9jKEpTTWFsbG9jU3RhdGUqIHMsIHZvaWQqIHB0ciwgc2l6ZV90IHNpemUpIHsKICBzaXplX3Qgb2xkX3NpemU7CgogIGlmKCFwdHIpIHsKICAgIGlmKHNpemUgPT0gMCkKICAgICAgcmV0dXJuIE5VTEw7CiAgICByZXR1cm4ganNtX3RyYWNlX21hbGxvYyhzLCBzaXplKTsKICB9CiAgb2xkX3NpemUgPSBqc21fdHJhY2VfbWFsbG9jX3VzYWJsZV9zaXplKHB0cik7CiAgaWYoc2l6ZSA9PSAwKSB7CiAgICBqc21fdHJhY2VfbWFsbG9jX3ByaW50ZihzLCAiUiAlemQgJXBcbiIsIHNpemUsIHB0cik7CiAgICBzLT5tYWxsb2NfY291bnQtLTsKICAgIHMtPm1hbGxvY19zaXplIC09IG9sZF9zaXplICsgTUFMTE9DX09WRVJIRUFEOwogICAgZnJlZShwdHIpOwogICAgcmV0dXJuIE5VTEw7CiAgfQogIGlmKHMtPm1hbGxvY19zaXplICsgc2l6ZSAtIG9sZF9zaXplID4gcy0+bWFsbG9jX2xpbWl0KQogICAgcmV0dXJuIE5VTEw7CgogIGpzbV90cmFjZV9tYWxsb2NfcHJpbnRmKHMsICJSICV6ZCAlcCIsIHNpemUsIHB0cik7CgogIHB0ciA9IHJlYWxsb2MocHRyLCBzaXplKTsKICBqc21fdHJhY2VfbWFsbG9jX3ByaW50ZihzLCAiIC0+ICVwXG4iLCBwdHIpOwogIGlmKHB0cikgewogICAgcy0+bWFsbG9jX3NpemUgKz0ganNtX3RyYWNlX21hbGxvY191c2FibGVfc2l6ZShwdHIpIC0gb2xkX3NpemU7CiAgfQogIHJldHVybiBwdHI7Cn0KCnN0YXRpYyBjb25zdCBKU01hbGxvY0Z1bmN0aW9ucyB0cmFjZV9tZiA9IHsKICAgIGpzbV90cmFjZV9tYWxsb2MsCiAgICBqc21fdHJhY2VfZnJlZSwKICAgIGpzbV90cmFjZV9yZWFsbG9jLAojaWYgZGVmaW5lZChfX0FQUExFX18pCiAgICBtYWxsb2Nfc2l6ZSwKI2VsaWYgZGVmaW5lZChfV0lOMzIpCiAgICAoc2l6ZV90KCopKGNvbnN0IHZvaWQqKSlfbXNpemUsCiNlbGlmIGRlZmluZWQoRU1TQ1JJUFRFTikgfHwgZGVmaW5lZChfX2RpZXRsaWJjX18pIHx8IGRlZmluZWQoX19NU1lTX18pIHx8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgZGVmaW5lZChET05UX0hBVkVfTUFMTE9DX1VTQUJMRV9TSVpFX0RFRklOSVRJT04pCiAgICBOVUxMLAojZWxpZiBkZWZpbmVkKF9fbGludXhfXykgfHwgZGVmaW5lZChIQVZFX01BTExPQ19VU0FCTEVfU0laRSkKICAgIChzaXplX3QoKikoY29uc3Qgdm9pZCopKW1hbGxvY191c2FibGVfc2l6ZSwKI2Vsc2UKICAgIC8qIGNoYW5nZSB0aGlzIHRvIGBOVUxMLGAgaWYgY29tcGlsYXRpb24gZmFpbHMgKi8KICAgIG1hbGxvY191c2FibGVfc2l6ZSwKI2VuZGlmCn07CgojZGVmaW5lIFBST0dfTkFNRSAicWpzbSIKCnZvaWQKanNtX2hlbHAodm9pZCkgewogIHByaW50ZigiUXVpY2tKUyB2ZXJzaW9uICIgQ09ORklHX1ZFUlNJT04gIlxuIgogICAgICAgICAidXNhZ2U6ICIgUFJPR19OQU1FICIgW29wdGlvbnNdIFtmaWxlIFthcmdzXV1cbiIKICAgICAgICAgIi1oICAtLWhlbHAgICAgICAgICBsaXN0IG9wdGlvbnNcbiIKICAgICAgICAgIi1lICAtLWV2YWwgRVhQUiAgICBldmFsdWF0ZSBFWFBSXG4iCiAgICAgICAgICItaSAgLS1pbnRlcmFjdGl2ZSAgZ28gdG8gaW50ZXJhY3RpdmUgbW9kZVxuIgogICAgICAgICAiLW0gIC0tbW9kdWxlIE5BTUUgIGxvYWQgYW4gRVM2IG1vZHVsZVxuIgogICAgICAgICAiLUkgIC0taW5jbHVkZSBmaWxlIGluY2x1ZGUgYW4gYWRkaXRpb25hbCBmaWxlXG4iCiAgICAgICAgICIgICAgLS1zdGQgICAgICAgICAgbWFrZSAnc3RkJyBhbmQgJ29zJyBhdmFpbGFibGUgdG8gdGhlIGxvYWRlZCBzY3JpcHRcbiIKI2lmZGVmIENPTkZJR19CSUdOVU0KICAgICAgICAgIiAgICAtLW5vLWJpZ251bSAgICBkaXNhYmxlIHRoZSBiaWdudW0gZXh0ZW5zaW9ucyAoQmlnRmxvYXQsIEJpZ0RlY2ltYWwpXG4iCiAgICAgICAgICIgICAgLS1xanNjYWxjICAgICAgbG9hZCB0aGUgUUpTQ2FsYyBydW50aW1lIChkZWZhdWx0IGlmIGludm9rZWQgYXMgcWpzY2FsYylcbiIKI2VuZGlmCiAgICAgICAgICItVCAgLS10cmFjZSAgICAgICAgdHJhY2UgbWVtb3J5IGFsbG9jYXRpb25cbiIKICAgICAgICAgIi1kICAtLWR1bXAgICAgICAgICBkdW1wIHRoZSBtZW1vcnkgdXNhZ2Ugc3RhdHNcbiIKICAgICAgICAgIiAgICAtLW1lbW9yeS1saW1pdCBuICAgICAgIGxpbWl0IHRoZSBtZW1vcnkgdXNhZ2UgdG8gJ24nIGJ5dGVzXG4iCiAgICAgICAgICIgICAgLS1zdGFjay1zaXplIG4gICAgICAgICBsaW1pdCB0aGUgc3RhY2sgc2l6ZSB0byAnbicgYnl0ZXNcbiIKICAgICAgICAgIiAgICAtLXVuaGFuZGxlZC1yZWplY3Rpb24gIGR1bXAgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uc1xuIgogICAgICAgICAiLXEgIC0tcXVpdCAgICAgICAgIGp1c3QgaW5zdGFudGlhdGUgdGhlIGludGVycHJldGVyIGFuZCBxdWl0XG4iKTsKICBleGl0KDEpOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc19ldmFsX3NjcmlwdChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHRoaXNfdmFsLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSwgaW50IG1hZ2ljKSB7CiAgY29uc3QgY2hhciogc3RyOwogIHNpemVfdCBsZW47CiAgSlNWYWx1ZSByZXQ7CiAgaW50MzJfdCBtb2R1bGU7CiAgc3RyID0gSlNfVG9DU3RyaW5nTGVuKGN0eCwgJmxlbiwgYXJndlswXSk7CiAgaWYoYXJnYyA+IDEpCiAgICBKU19Ub0ludDMyKGN0eCwgJm1vZHVsZSwgYXJndlsxXSk7CiAgZWxzZQogICAgbW9kdWxlID0gc3RyX2VuZHMoc3RyLCAiLm1qcyIpOwogIHN3aXRjaChtYWdpYykgewogICAgY2FzZSAwOiB7CiAgICAgIHJldCA9IGpzbV9ldmFsX2ZpbGUoY3R4LCBzdHIsIG1vZHVsZSk7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSAxOiB7CiAgICAgIHJldCA9IGpzbV9ldmFsX2J1ZihjdHgsIHN0ciwgbGVuLCAiPGlucHV0PiIsIG1vZHVsZSk7CiAgICAgIGJyZWFrOwogICAgfQogIH0KICBpZihKU19Jc0V4Y2VwdGlvbihyZXQpKSB7CiAgICBpZihKU19Jc051bGwoSlNfR2V0UnVudGltZShjdHgpLT5jdXJyZW50X2V4Y2VwdGlvbikpIHsKICAgICAgSlNfR2V0RXhjZXB0aW9uKGN0eCk7CiAgICAgIHJldCA9IEpTX1VOREVGSU5FRDsKICAgIH0KICB9CiAgaWYoSlNfVkFMVUVfR0VUX1RBRyhyZXQpID09IEpTX1RBR19NT0RVTEUpIHsKICAgIEpTTW9kdWxlRGVmKiBtb2R1bGUgPSBKU19WQUxVRV9HRVRfUFRSKHJldCk7CiAgICBKU1ZhbHVlIGV4cG9ydHMsIG9iaiA9IEpTX05ld09iamVjdChjdHgpOwogICAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCBvYmosICJuYW1lIiwganNfbW9kdWxlX25hbWUoY3R4LCByZXQpKTsKICAgIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgb2JqLCAiZXhwb3J0cyIsIGpzbV9tb2R1bGVfZXhwb3J0cyhjdHgsIG1vZHVsZSkpOwogICAgcmV0ID0gb2JqOwogIH0KICBKU19GcmVlQ1N0cmluZyhjdHgsIHN0cik7CiAgcmV0dXJuIHJldDsKfQoKZW51bSB7CiAgRklORF9NT0RVTEUsCiAgTE9BRF9NT0RVTEUsCiAgUkVTT0xWRV9NT0RVTEUsCiAgR0VUX01PRFVMRV9OQU1FLAogIEdFVF9NT0RVTEVfT0JKRUNULAogIEdFVF9NT0RVTEVfRVhQT1JUUywKICBHRVRfTU9EVUxFX05BTUVTUEFDRSwKICBHRVRfTU9EVUxFX0ZVTkNUSU9OLAogIEdFVF9NT0RVTEVfRVhDRVBUSU9OLAogIEdFVF9NT0RVTEVfTUVUQV9PQkoKfTsKCnN0YXRpYyBKU1ZhbHVlCmpzX21vZHVsZV9mdW5jKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdLCBpbnQgbWFnaWMpIHsKICBKU1ZhbHVlIHJldCA9IEpTX0VYQ0VQVElPTjsKICBKU01vZHVsZURlZiogbTsKICBzd2l0Y2gobWFnaWMpIHsKCiAgICBjYXNlIEZJTkRfTU9EVUxFOiB7CiAgICAgIGNvbnN0IGNoYXIqIG5hbWUgPSBKU19Ub0NTdHJpbmcoY3R4LCBhcmd2WzBdKTsKICAgICAgbSA9IGpzbV9tb2R1bGVfZmluZChjdHgsIG5hbWUpOwogICAgICBKU19GcmVlQ1N0cmluZyhjdHgsIG5hbWUpOwogICAgICByZXQgPSBKU19EdXBWYWx1ZShjdHgsIEpTX01LUFRSKEpTX1RBR19NT0RVTEUsIG0pKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIExPQURfTU9EVUxFOiB7CiAgICAgIGNvbnN0IGNoYXIqIG5hbWUgPSBKU19Ub0NTdHJpbmcoY3R4LCBhcmd2WzBdKTsKICAgICAgSlNNb2R1bGVEZWYqIG07CgogICAgICBpZigobSA9IGpzbV9sb2FkX21vZHVsZShjdHgsIG5hbWUpKSkKICAgICAgICByZXQgPSBKU19NS1BUUihKU19UQUdfTU9EVUxFLCBtKTsKCiAgICAgIEpTX0ZyZWVDU3RyaW5nKGN0eCwgbmFtZSk7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBSRVNPTFZFX01PRFVMRTogewogICAgICByZXQgPSBKU19OZXdJbnQzMihjdHgsIEpTX1Jlc29sdmVNb2R1bGUoY3R4LCBhcmd2WzBdKSk7CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBHRVRfTU9EVUxFX05BTUU6IHsKICAgICAgaWYoKG0gPSBqc21fbW9kdWxlX2dldChjdHgsIGFyZ3ZbMF0pKSkKICAgICAgICByZXQgPSBqc19tb2R1bGVfbmFtZShjdHgsIGFyZ3ZbMF0pOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgR0VUX01PRFVMRV9PQkpFQ1Q6IHsKICAgICAgaWYoKG0gPSBqc21fbW9kdWxlX2dldChjdHgsIGFyZ3ZbMF0pKSkgewogICAgICAgIHJldCA9IEpTX05ld09iamVjdChjdHgpOwoKICAgICAgICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgIm5hbWUiLCBqc19tb2R1bGVfbmFtZShjdHgsIGFyZ3ZbMF0pKTsKICAgICAgICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgInJlc29sdmVkIiwgSlNfTmV3Qm9vbChjdHgsIG0tPnJlc29sdmVkKSk7CiAgICAgICAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJmdW5jX2NyZWF0ZWQiLCBKU19OZXdCb29sKGN0eCwgbS0+ZnVuY19jcmVhdGVkKSk7CiAgICAgICAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJpbnN0YW50aWF0ZWQiLCBKU19OZXdCb29sKGN0eCwgbS0+aW5zdGFudGlhdGVkKSk7CiAgICAgICAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJldmFsdWF0ZWQiLCBKU19OZXdCb29sKGN0eCwgbS0+ZXZhbHVhdGVkKSk7CiAgICAgICAgaWYobS0+ZXZhbF9oYXNfZXhjZXB0aW9uKQogICAgICAgICAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJleGNlcHRpb24iLCBKU19EdXBWYWx1ZShjdHgsIG0tPmV2YWxfZXhjZXB0aW9uKSk7CiAgICAgICAgaWYoIUpTX0lzVW5kZWZpbmVkKG0tPm1vZHVsZV9ucykpCiAgICAgICAgICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgIm5hbWVzcGFjZSIsIEpTX0R1cFZhbHVlKGN0eCwgbS0+bW9kdWxlX25zKSk7CiAgICAgICAgaWYoIUpTX0lzVW5kZWZpbmVkKG0tPmZ1bmNfb2JqKSkKICAgICAgICAgIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAiZnVuYyIsIEpTX0R1cFZhbHVlKGN0eCwgbS0+ZnVuY19vYmopKTsKICAgICAgICBpZighSlNfSXNVbmRlZmluZWQobS0+bWV0YV9vYmopKQogICAgICAgICAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJtZXRhIiwgSlNfRHVwVmFsdWUoY3R4LCBtLT5tZXRhX29iaikpOwogICAgICB9CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBHRVRfTU9EVUxFX0VYUE9SVFM6IHsKICAgICAgaWYoKG0gPSBqc21fbW9kdWxlX2dldChjdHgsIGFyZ3ZbMF0pKSkKICAgICAgICByZXQgPSBqc21fbW9kdWxlX2V4cG9ydHMoY3R4LCBtKTsKICAgICAgYnJlYWs7CiAgICB9CiAgICBjYXNlIEdFVF9NT0RVTEVfTkFNRVNQQUNFOiB7CiAgICAgIGlmKChtID0ganNtX21vZHVsZV9nZXQoY3R4LCBhcmd2WzBdKSkpCiAgICAgICAgcmV0ID0gSlNfRHVwVmFsdWUoY3R4LCBtLT5tb2R1bGVfbnMpOwogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgR0VUX01PRFVMRV9GVU5DVElPTjogewogICAgICBpZigobSA9IGpzbV9tb2R1bGVfZ2V0KGN0eCwgYXJndlswXSkpKSB7CiAgICAgICAgaWYoVFJVRSB8fCBtLT5mdW5jX2NyZWF0ZWQpCiAgICAgICAgICByZXQgPSBKU19EdXBWYWx1ZShjdHgsIG0tPmZ1bmNfb2JqKTsKICAgICAgICBlbHNlCiAgICAgICAgICByZXQgPSBKU19OVUxMOwogICAgICB9CiAgICAgIGJyZWFrOwogICAgfQogICAgY2FzZSBHRVRfTU9EVUxFX0VYQ0VQVElPTjogewogICAgICBpZigobSA9IGpzbV9tb2R1bGVfZ2V0KGN0eCwgYXJndlswXSkpKSB7CiAgICAgICAgaWYobS0+ZXZhbF9oYXNfZXhjZXB0aW9uKQogICAgICAgICAgcmV0ID0gSlNfRHVwVmFsdWUoY3R4LCBtLT5ldmFsX2V4Y2VwdGlvbik7CiAgICAgICAgZWxzZQogICAgICAgICAgcmV0ID0gSlNfTlVMTDsKICAgICAgfQogICAgICBicmVhazsKICAgIH0KICAgIGNhc2UgR0VUX01PRFVMRV9NRVRBX09CSjogewogICAgICBpZigobSA9IGpzbV9tb2R1bGVfZ2V0KGN0eCwgYXJndlswXSkpKQogICAgICAgIHJldCA9IEpTX0R1cFZhbHVlKGN0eCwgbS0+bWV0YV9vYmopOwogICAgICBicmVhazsKICAgIH0KICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGNvbnN0IEpTQ0Z1bmN0aW9uTGlzdEVudHJ5IGpzbV9nbG9iYWxfZnVuY3NbXSA9IHsKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZXZhbEZpbGUiLCAxLCBqc19ldmFsX3NjcmlwdCwgMCksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImV2YWxTY3JpcHQiLCAxLCBqc19ldmFsX3NjcmlwdCwgMSksCiAgICBKU19DR0VUU0VUX0RFRigibW9kdWxlTGlzdCIsIGpzbV9tb2R1bGVfbGlzdCwgMCksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImZpbmRNb2R1bGUiLCAxLCBqc19tb2R1bGVfZnVuYywgRklORF9NT0RVTEUpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJsb2FkTW9kdWxlIiwgMSwganNfbW9kdWxlX2Z1bmMsIExPQURfTU9EVUxFKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigicmVzb2x2ZU1vZHVsZSIsIDEsIGpzX21vZHVsZV9mdW5jLCBSRVNPTFZFX01PRFVMRSksCiAgICBKU19DRlVOQ19NQUdJQ19ERUYoImdldE1vZHVsZU5hbWUiLCAxLCBqc19tb2R1bGVfZnVuYywgR0VUX01PRFVMRV9OQU1FKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0TW9kdWxlT2JqZWN0IiwgMSwganNfbW9kdWxlX2Z1bmMsIEdFVF9NT0RVTEVfT0JKRUNUKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0TW9kdWxlRXhwb3J0cyIsIDEsIGpzX21vZHVsZV9mdW5jLCBHRVRfTU9EVUxFX0VYUE9SVFMpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRNb2R1bGVOYW1lc3BhY2UiLCAxLCBqc19tb2R1bGVfZnVuYywgR0VUX01PRFVMRV9OQU1FU1BBQ0UpLAogICAgSlNfQ0ZVTkNfTUFHSUNfREVGKCJnZXRNb2R1bGVGdW5jdGlvbiIsIDEsIGpzX21vZHVsZV9mdW5jLCBHRVRfTU9EVUxFX0ZVTkNUSU9OKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0TW9kdWxlRXhjZXB0aW9uIiwgMSwganNfbW9kdWxlX2Z1bmMsIEdFVF9NT0RVTEVfRVhDRVBUSU9OKSwKICAgIEpTX0NGVU5DX01BR0lDX0RFRigiZ2V0TW9kdWxlTWV0YU9iamVjdCIsIDEsIGpzX21vZHVsZV9mdW5jLCBHRVRfTU9EVUxFX01FVEFfT0JKKSwKfTsKCmludAptYWluKGludCBhcmdjLCBjaGFyKiogYXJndikgewogIEpTUnVudGltZSogcnQ7CiAgSlNDb250ZXh0KiBjdHg7CiAgc3RydWN0IHRyYWNlX21hbGxvY19kYXRhIHRyYWNlX2RhdGEgPSB7TlVMTH07CiAgaW50IG9wdGluZDsKICBjaGFyKiBleHByID0gTlVMTDsKICBpbnQgaW50ZXJhY3RpdmUgPSAwOwogIGludCBkdW1wX21lbW9yeSA9IDA7CiAgaW50IHRyYWNlX21lbW9yeSA9IDA7CiAgaW50IGVtcHR5X3J1biA9IDA7CiAgaW50IG1vZHVsZSA9IDE7CiAgaW50IGxvYWRfc3RkID0gMTsKICBpbnQgZHVtcF91bmhhbmRsZWRfcHJvbWlzZV9yZWplY3Rpb24gPSAwOwogIHNpemVfdCBtZW1vcnlfbGltaXQgPSAwOwogIGNoYXIqIGluY2x1ZGVfbGlzdFszMl07CiAgaW50IGksIGluY2x1ZGVfY291bnQgPSAwOwojaWZkZWYgQ09ORklHX0JJR05VTQogIGludCBsb2FkX2pzY2FsYzsKI2VuZGlmCiAgc2l6ZV90IHN0YWNrX3NpemUgPSAwOwogIGNvbnN0IGNoYXIqIGV4ZW5hbWU7CgogIHBhY2thZ2VfanNvbiA9IEpTX1VOREVGSU5FRDsKCiAgaW5pdF9saXN0X2hlYWQoJnBvbGxoYW5kbGVycyk7CgogIHsKICAgIGNvbnN0IGNoYXIqIHA7CiAgICBleGVuYW1lID0gYXJndlswXTsKICAgIHAgPSBzdHJyY2hyKGV4ZW5hbWUsICcvJyk7CiAgICBpZihwKQogICAgICBleGVuYW1lID0gcCArIDE7CiAgICAvKiBsb2FkIGpzY2FsYyBydW50aW1lIGlmIGludm9rZWQgYXMgJ3Fqc2NhbGMnICovCiAgICBsb2FkX2pzY2FsYyA9ICFzdHJjbXAoZXhlbmFtZSwgInFqc2NhbGMiKTsKICB9CgogIC8qIGNhbm5vdCB1c2UgZ2V0b3B0IGJlY2F1c2Ugd2Ugd2FudCB0byBwYXNzIHRoZSBjb21tYW5kIGxpbmUgdG8KICAgICB0aGUgc2NyaXB0ICovCiAgb3B0aW5kID0gMTsKICB3aGlsZShvcHRpbmQgPCBhcmdjICYmICphcmd2W29wdGluZF0gPT0gJy0nKSB7CiAgICBjaGFyKiBhcmcgPSBhcmd2W29wdGluZF0gKyAxOwogICAgY29uc3QgY2hhciogbG9uZ29wdCA9ICIiOwogICAgY29uc3QgY2hhciogb3B0YXJnOwoKICAgIC8qIGEgc2luZ2xlIC0gaXMgbm90IGFuIG9wdGlvbiwgaXQgYWxzbyBzdG9wcyBhcmd1bWVudCBzY2FubmluZyAqLwogICAgaWYoISphcmcpCiAgICAgIGJyZWFrOwoKICAgIGlmKGFyZ1sxXSkgewogICAgICBvcHRhcmcgPSAmYXJnWzFdOwogICAgfSBlbHNlIHsKICAgICAgb3B0YXJnID0gYXJndlsrK29wdGluZF07CiAgICB9CgogICAgaWYoKmFyZyA9PSAnLScpIHsKICAgICAgbG9uZ29wdCA9IGFyZyArIDE7CiAgICAgIGFyZyArPSBzdHJsZW4oYXJnKTsKICAgICAgLyogLS0gc3RvcHMgYXJndW1lbnQgc2Nhbm5pbmcgKi8KICAgICAgaWYoISpsb25nb3B0KQogICAgICAgIGJyZWFrOwogICAgfQogICAgZm9yKDsgKmFyZyB8fCAqbG9uZ29wdDsgbG9uZ29wdCA9ICIiKSB7CiAgICAgIGNoYXIgb3B0ID0gKmFyZzsKICAgICAgaWYob3B0KQogICAgICAgIGFyZysrOwogICAgICBpZihvcHQgPT0gJ2gnIHx8IG9wdCA9PSAnPycgfHwgIXN0cmNtcChsb25nb3B0LCAiaGVscCIpKSB7CiAgICAgICAganNtX2hlbHAoKTsKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICBpZihvcHQgPT0gJ2UnIHx8ICFzdHJjbXAobG9uZ29wdCwgImV2YWwiKSkgewogICAgICAgIGlmKCphcmcpIHsKICAgICAgICAgIGV4cHIgPSBhcmc7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgaWYob3B0aW5kIDwgYXJnYykgewogICAgICAgICAgZXhwciA9IGFyZ3Zbb3B0aW5kKytdOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIGZwcmludGYoc3RkZXJyLCAiJXM6IG1pc3NpbmcgZXhwcmVzc2lvbiBmb3IgLWVcbiIsIGV4ZW5hbWUpOwogICAgICAgIGV4aXQoMik7CiAgICAgIH0KICAgICAgaWYob3B0ID09ICdJJyB8fCAhc3RyY21wKGxvbmdvcHQsICJpbmNsdWRlIikpIHsKICAgICAgICBpZihvcHRpbmQgPj0gYXJnYykgewogICAgICAgICAgZnByaW50ZihzdGRlcnIsICJleHBlY3RpbmcgZmlsZW5hbWUiKTsKICAgICAgICAgIGV4aXQoMSk7CiAgICAgICAgfQogICAgICAgIGlmKGluY2x1ZGVfY291bnQgPj0gY291bnRvZihpbmNsdWRlX2xpc3QpKSB7CiAgICAgICAgICBmcHJpbnRmKHN0ZGVyciwgInRvbyBtYW55IGluY2x1ZGVkIGZpbGVzIik7CiAgICAgICAgICBleGl0KDEpOwogICAgICAgIH0KICAgICAgICBpbmNsdWRlX2xpc3RbaW5jbHVkZV9jb3VudCsrXSA9IG9wdGFyZzsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZihvcHQgPT0gJ2knIHx8ICFzdHJjbXAobG9uZ29wdCwgImludGVyYWN0aXZlIikpIHsKICAgICAgICBpbnRlcmFjdGl2ZSsrOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmKG9wdCA9PSAnbScgfHwgIXN0cmNtcChsb25nb3B0LCAibW9kdWxlIikpIHsKICAgICAgICBjb25zdCBjaGFyKiBtb2R1bGVzID0gYXJndltvcHRpbmRdOwogICAgICAgIHNpemVfdCBpLCBsZW47CgogICAgICAgIGZvcihpID0gMDsgbW9kdWxlc1tpXTsgaSArPSBsZW4pIHsKICAgICAgICAgIGxlbiA9IHN0cl9jaHIoJm1vZHVsZXNbaV0sICcsJyk7CiAgICAgICAgICB2ZWN0b3JfcHV0cHRyKCZtb2R1bGVfbGlzdCwgc3RyX25kdXAoJm1vZHVsZXNbaV0sIGxlbikpOwoKICAgICAgICAgIGlmKG1vZHVsZXNbaSArIGxlbl0gPT0gJywnKQogICAgICAgICAgICBsZW4rKzsKICAgICAgICB9CgogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmKG9wdCA9PSAnZCcgfHwgIXN0cmNtcChsb25nb3B0LCAiZHVtcCIpKSB7CiAgICAgICAgZHVtcF9tZW1vcnkrKzsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZihvcHQgPT0gJ1QnIHx8ICFzdHJjbXAobG9uZ29wdCwgInRyYWNlIikpIHsKICAgICAgICB0cmFjZV9tZW1vcnkrKzsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZighc3RyY21wKGxvbmdvcHQsICJzdGQiKSkgewogICAgICAgIGxvYWRfc3RkID0gMTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZighc3RyY21wKGxvbmdvcHQsICJ1bmhhbmRsZWQtcmVqZWN0aW9uIikpIHsKICAgICAgICBkdW1wX3VuaGFuZGxlZF9wcm9taXNlX3JlamVjdGlvbiA9IDE7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KI2lmZGVmIENPTkZJR19CSUdOVU0KICAgICAgaWYoIXN0cmNtcChsb25nb3B0LCAibm8tYmlnbnVtIikpIHsKICAgICAgICBiaWdudW1fZXh0ID0gMDsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZighc3RyY21wKGxvbmdvcHQsICJiaWdudW0iKSkgewogICAgICAgIGJpZ251bV9leHQgPSAxOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmKCFzdHJjbXAobG9uZ29wdCwgInFqc2NhbGMiKSkgewogICAgICAgIGxvYWRfanNjYWxjID0gMTsKICAgICAgICBicmVhazsKICAgICAgfQojZW5kaWYKICAgICAgaWYob3B0ID09ICdxJyB8fCAhc3RyY21wKGxvbmdvcHQsICJxdWl0IikpIHsKICAgICAgICBlbXB0eV9ydW4rKzsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZighc3RyY21wKGxvbmdvcHQsICJtZW1vcnktbGltaXQiKSkgewogICAgICAgIGlmKG9wdGluZCA+PSBhcmdjKSB7CiAgICAgICAgICBmcHJpbnRmKHN0ZGVyciwgImV4cGVjdGluZyBtZW1vcnkgbGltaXQiKTsKICAgICAgICAgIGV4aXQoMSk7CiAgICAgICAgfQogICAgICAgIG1lbW9yeV9saW1pdCA9IChzaXplX3Qpc3RydG9kKGFyZ3Zbb3B0aW5kKytdLCBOVUxMKTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZighc3RyY21wKGxvbmdvcHQsICJzdGFjay1zaXplIikpIHsKICAgICAgICBpZihvcHRpbmQgPj0gYXJnYykgewogICAgICAgICAgZnByaW50ZihzdGRlcnIsICJleHBlY3Rpbmcgc3RhY2sgc2l6ZSIpOwogICAgICAgICAgZXhpdCgxKTsKICAgICAgICB9CiAgICAgICAgc3RhY2tfc2l6ZSA9IChzaXplX3Qpc3RydG9kKGFyZ3Zbb3B0aW5kKytdLCBOVUxMKTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZihvcHQpIHsKICAgICAgICBmcHJpbnRmKHN0ZGVyciwgIiVzOiB1bmtub3duIG9wdGlvbiAnLSVjJ1xuIiwgZXhlbmFtZSwgb3B0KTsKICAgICAgfSBlbHNlIHsKICAgICAgICBmcHJpbnRmKHN0ZGVyciwgIiVzOiB1bmtub3duIG9wdGlvbiAnLS0lcydcbiIsIGV4ZW5hbWUsIGxvbmdvcHQpOwogICAgICB9CiAgICAgIGpzbV9oZWxwKCk7CiAgICB9CiAgICBvcHRpbmQrKzsKICB9CgogIHsKICAgIGNvbnN0IGNoYXIqIG1vZHVsZXM7CgogICAgaWYoKG1vZHVsZXMgPSBnZXRlbnYoIkRFQlVHIikpKSB7CiAgICAgIHNpemVfdCBpLCBsZW47CiAgICAgIGZvcihpID0gMDsgbW9kdWxlc1tpXTsgaSArPSBsZW4pIHsKICAgICAgICBsZW4gPSBzdHJfY2hyKCZtb2R1bGVzW2ldLCAnLCcpOwogICAgICAgIHZlY3Rvcl9wdXRwdHIoJm1vZHVsZV9kZWJ1Zywgc3RyX25kdXAoJm1vZHVsZXNbaV0sIGxlbikpOwoKICAgICAgICBpZihtb2R1bGVzW2kgKyBsZW5dID09ICcsJykKICAgICAgICAgIGxlbisrOwogICAgICB9CgogICAgICBpZih2ZWN0b3JfZmluZHMoJm1vZHVsZV9kZWJ1ZywgIm1vZHVsZXMiKSAhPSAtMSkKICAgICAgICBkZWJ1Z19tb2R1bGVfbG9hZGVyID0gVFJVRTsKICAgIH0KICB9CgogIGlmKGxvYWRfanNjYWxjKQogICAgYmlnbnVtX2V4dCA9IDE7CgogIGlmKHRyYWNlX21lbW9yeSkgewogICAganNtX3RyYWNlX21hbGxvY19pbml0KCZ0cmFjZV9kYXRhKTsKICAgIHJ0ID0gSlNfTmV3UnVudGltZTIoJnRyYWNlX21mLCAmdHJhY2VfZGF0YSk7CiAgfSBlbHNlIHsKICAgIHJ0ID0gSlNfTmV3UnVudGltZSgpOwogIH0KICBpZighcnQpIHsKICAgIGZwcmludGYoc3RkZXJyLCAiJXM6IGNhbm5vdCBhbGxvY2F0ZSBKUyBydW50aW1lXG4iLCBleGVuYW1lKTsKICAgIGV4aXQoMik7CiAgfQoKICBKU19TZXRNb2R1bGVMb2FkZXJGdW5jKHJ0LCAwLCBqc21fbW9kdWxlX2xvYWRlcl9wYXRoLCAwKTsKCiAgaWYobWVtb3J5X2xpbWl0ICE9IDApCiAgICBKU19TZXRNZW1vcnlMaW1pdChydCwgbWVtb3J5X2xpbWl0KTsKICAvLyBpZiAoc3RhY2tfc2l6ZSAhPSAwKQogIEpTX1NldE1heFN0YWNrU2l6ZShydCwgc3RhY2tfc2l6ZSAhPSAwID8gc3RhY2tfc2l6ZSA6IDI1NiAqIDEwNDg1NzYpOwoKICBqc19zdGRfc2V0X3dvcmtlcl9uZXdfY29udGV4dF9mdW5jKGpzbV9jb250ZXh0X25ldyk7CgogIGpzX3N0ZF9pbml0X2hhbmRsZXJzKHJ0KTsKICBjdHggPSBqc21fY29udGV4dF9uZXcocnQpOwogIGlmKCFjdHgpIHsKICAgIGZwcmludGYoc3RkZXJyLCAiJXM6IGNhbm5vdCBhbGxvY2F0ZSBKUyBjb250ZXh0XG4iLCBleGVuYW1lKTsKICAgIGV4aXQoMik7CiAgfQoKICAvKiBsb2FkZXIgZm9yIEVTNiBtb2R1bGVzICovCiAgSlNfU2V0TW9kdWxlTG9hZGVyRnVuYyhydCwganNtX25vcm1hbGl6ZV9tb2R1bGUsIGpzbV9tb2R1bGVfbG9hZGVyX3BhdGgsIE5VTEwpOwoKICBpZihkdW1wX3VuaGFuZGxlZF9wcm9taXNlX3JlamVjdGlvbikgewogICAgSlNfU2V0SG9zdFByb21pc2VSZWplY3Rpb25UcmFja2VyKHJ0LCBqc19zdGRfcHJvbWlzZV9yZWplY3Rpb25fdHJhY2tlciwgTlVMTCk7CiAgfQoKICBpZighZW1wdHlfcnVuKSB7CiNpZmRlZiBDT05GSUdfQklHTlVNCiAgICBpZihsb2FkX2pzY2FsYykgewogICAgICBqc21fZXZhbF9iaW5hcnkoY3R4LCBxanNjX3Fqc2NhbGMsIHFqc2NfcWpzY2FsY19zaXplLCAwKTsKICAgIH0KI2VuZGlmCiAgICBqc19zdGRfYWRkX2hlbHBlcnMoY3R4LCBhcmdjIC0gb3B0aW5kLCBhcmd2ICsgb3B0aW5kKTsKCiAgICBpbnQgbnVtX25hdGl2ZSwgbnVtX2NvbXBpbGVkOwoKI2RlZmluZSBqc21fYnVpbHRpbl9uYXRpdmUobmFtZSkgdmVjdG9yX3B1dHB0cigmYnVpbHRpbnMsICNuYW1lKQoKICAgIGpzbV9idWlsdGluX25hdGl2ZShzdGQpOwogICAganNtX2J1aWx0aW5fbmF0aXZlKG9zKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShjaGlsZF9wcm9jZXNzKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShkZWVwKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShpbnNwZWN0KTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShsZXhlcik7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUobWlzYyk7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUobW1hcCk7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUocGF0aCk7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUocG9pbnRlcik7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUocHJlZGljYXRlKTsKICAgIGpzbV9idWlsdGluX25hdGl2ZShyZXBlYXRlcik7CiAgICBqc21fYnVpbHRpbl9uYXRpdmUodHJlZV93YWxrZXIpOwogICAganNtX2J1aWx0aW5fbmF0aXZlKHhtbCk7CiAgICBudW1fbmF0aXZlID0gdmVjdG9yX3NpemUoJmJ1aWx0aW5zLCBzaXplb2YoY2hhciopKTsKCiAgICAvLyBwcmludGYoIm5hdGl2ZSBidWlsdGluczogIik7IGR1bXBfdmVjdG9yKCZidWlsdGlucywgMCk7CgojZGVmaW5lIGpzbV9idWlsdGluX2NvbXBpbGVkKG5hbWUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICBqc21fZXZhbF9iaW5hcnkoY3R4LCBxanNjXyMjbmFtZSwgcWpzY18jI25hbWUjI19zaXplLCAwKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgdmVjdG9yX3B1dHB0cigmYnVpbHRpbnMsICNuYW1lKQoKICAgIGpzbV9idWlsdGluX2NvbXBpbGVkKGNvbnNvbGUpOwogICAganNtX2J1aWx0aW5fY29tcGlsZWQoZXZlbnRzKTsKICAgIGpzbV9idWlsdGluX2NvbXBpbGVkKGZzKTsKICAgIGpzbV9idWlsdGluX2NvbXBpbGVkKHBlcmZfaG9va3MpOwogICAganNtX2J1aWx0aW5fY29tcGlsZWQocHJvY2Vzcyk7CiAgICAvLyBqc21fYnVpbHRpbl9jb21waWxlZChyZXBsKTsKICAgIGpzbV9idWlsdGluX2NvbXBpbGVkKHJlcXVpcmUpOwogICAganNtX2J1aWx0aW5fY29tcGlsZWQodHR5KTsKICAgIGpzbV9idWlsdGluX2NvbXBpbGVkKHV0aWwpOwoKICAgIG51bV9jb21waWxlZCA9IHZlY3Rvcl9zaXplKCZidWlsdGlucywgc2l6ZW9mKGNoYXIqKSkgLSBudW1fbmF0aXZlOwoKICAgIHsKICAgICAgY29uc3QgY2hhciogc3RyID0gImltcG9ydCBwcm9jZXNzIGZyb20gJ3Byb2Nlc3MnO1xuZ2xvYmFsVGhpcy5wcm9jZXNzID0gcHJvY2VzcztcbiI7CiAgICAgIGpzbV9ldmFsX3N0cihjdHgsIHN0ciwgIjxpbnB1dD4iLCBUUlVFKTsKICAgIH0KCiAgICBKU19TZXRQcm9wZXJ0eUZ1bmN0aW9uTGlzdChjdHgsIEpTX0dldEdsb2JhbE9iamVjdChjdHgpLCBqc21fZ2xvYmFsX2Z1bmNzLCBjb3VudG9mKGpzbV9nbG9iYWxfZnVuY3MpKTsKICAgIGlmKGxvYWRfc3RkKSB7CiAgICAgIGNvbnN0IGNoYXIqIHN0ciA9ICJpbXBvcnQgKiBhcyBzdGQgZnJvbSAnc3RkJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmdsb2JhbFRoaXMuc3RkID0gc3RkO1xuZ2xvYmFsVGhpcy5vcyA9IG9zO1xuZ2xvYmFsVGhpcy5zZXRUaW1lb3V0ID0gb3Muc2V0VGltZW91dDtcbmdsb2JhbFRoaXMuY2xlYXJUaW1lb3V0ID0gb3MuY2xlYXJUaW1lb3V0O1xuIjsKICAgICAganNtX2V2YWxfc3RyKGN0eCwgc3RyLCAiPGlucHV0PiIsIFRSVUUpOwogICAgfQoKICAgIC8vIGpzbV9saXN0X21vZHVsZXMoY3R4KTsKCiAgICB7CiAgICAgIGNoYXIqKiBuYW1lOwogICAgICBKU01vZHVsZURlZiogbTsKICAgICAgdmVjdG9yX2ZvcmVhY2hfdCgmbW9kdWxlX2xpc3QsIG5hbWUpIHsKICAgICAgICBpZighKG0gPSBqc21fbG9hZF9tb2R1bGUoY3R4LCAqbmFtZSkpKSB7CiAgICAgICAgICBmcHJpbnRmKHN0ZGVyciwgImVycm9yIGxvYWRpbmcgbW9kdWxlICclcydcbiIsICpuYW1lKTsKICAgICAgICAgIGV4aXQoMSk7CiAgICAgICAgfQogICAgICAgIGZyZWUoKm5hbWUpOwogICAgICB9CiAgICAgIHZlY3Rvcl9mcmVlKCZtb2R1bGVfbGlzdCk7CiAgICB9CgogICAgZm9yKGkgPSAwOyBpIDwgaW5jbHVkZV9jb3VudDsgaSsrKSB7CiAgICAgIGlmKGpzbV9sb2FkX3NjcmlwdChjdHgsIGluY2x1ZGVfbGlzdFtpXSwgbW9kdWxlKSA9PSAtMSkKICAgICAgICBnb3RvIGZhaWw7CiAgICB9CgogICAgaWYoZXhwcikgewogICAgICBpZihqc21fZXZhbF9zdHIoY3R4LCBleHByLCAiPGNtZGxpbmU+IiwgMCkgPT0gLTEpCiAgICAgICAgZ290byBmYWlsOwogICAgfSBlbHNlIGlmKG9wdGluZCA+PSBhcmdjKSB7CiAgICAgIC8qIGludGVyYWN0aXZlIG1vZGUgKi8KICAgICAgaW50ZXJhY3RpdmUgPSAxOwogICAgfSBlbHNlIHsKICAgICAgY29uc3QgY2hhciogZmlsZW5hbWU7CiAgICAgIGZpbGVuYW1lID0gYXJndltvcHRpbmRdOwogICAgICBpZihqc21fbG9hZF9zY3JpcHQoY3R4LCBmaWxlbmFtZSwgbW9kdWxlKSA9PSAtMSkgewoKICAgICAgICBqc21fZHVtcF9vYmooY3R4LCBzdGRlcnIsIEpTX0dldEV4Y2VwdGlvbihjdHgpKTsKCiAgICAgICAgZ290byBmYWlsOwogICAgICB9CiAgICB9CiAgICBpZihpbnRlcmFjdGl2ZSkgewogICAgICBjb25zdCBjaGFyKiBzdHIgPSAiaW1wb3J0IFJFUEwgZnJvbSAncmVwbCc7IGdsb2JhbFRoaXMucmVwbCA9IG5ldyBSRVBMKCdxanNtJykucnVuU3luYygpO1xuIjsKICAgICAganNtX2V2YWxfYmluYXJ5KGN0eCwgcWpzY19yZXBsLCBxanNjX3JlcGxfc2l6ZSwgMCk7CiAgICAgIGpzbV9ldmFsX3N0cihjdHgsIHN0ciwgIjxpbnB1dD4iLCBUUlVFKTsKICAgIH0KCiAgICBqc19zdGRfbG9vcChjdHgpOwogIH0KCiAgewoKICAgIEpTVmFsdWUgZXhjZXB0aW9uID0gSlNfR2V0RXhjZXB0aW9uKGN0eCk7CgogICAgaWYoIUpTX0lzTnVsbChleGNlcHRpb24pKSB7CiAgICAgIGpzbV9zdGRfZHVtcF9lcnJvcihjdHgsIGV4Y2VwdGlvbik7CiAgICB9CiAgfQoKICBpZihkdW1wX21lbW9yeSkgewogICAgSlNNZW1vcnlVc2FnZSBzdGF0czsKICAgIEpTX0NvbXB1dGVNZW1vcnlVc2FnZShydCwgJnN0YXRzKTsKICAgIEpTX0R1bXBNZW1vcnlVc2FnZShzdGRvdXQsICZzdGF0cywgcnQpOwogIH0KICBqc19zdGRfZnJlZV9oYW5kbGVycyhydCk7CiAgSlNfRnJlZUNvbnRleHQoY3R4KTsKICBKU19GcmVlUnVudGltZShydCk7CgogIGlmKGVtcHR5X3J1biAmJiBkdW1wX21lbW9yeSkgewogICAgY2xvY2tfdCB0WzVdOwogICAgZG91YmxlIGJlc3RbNV07CiAgICBpbnQgaSwgajsKICAgIGZvcihpID0gMDsgaSA8IDEwMDsgaSsrKSB7CiAgICAgIHRbMF0gPSBjbG9jaygpOwogICAgICBydCA9IEpTX05ld1J1bnRpbWUoKTsKICAgICAgdFsxXSA9IGNsb2NrKCk7CiAgICAgIGN0eCA9IEpTX05ld0NvbnRleHQocnQpOwogICAgICB0WzJdID0gY2xvY2soKTsKICAgICAgSlNfRnJlZUNvbnRleHQoY3R4KTsKICAgICAgdFszXSA9IGNsb2NrKCk7CiAgICAgIEpTX0ZyZWVSdW50aW1lKHJ0KTsKICAgICAgdFs0XSA9IGNsb2NrKCk7CiAgICAgIGZvcihqID0gNDsgaiA+IDA7IGotLSkgewogICAgICAgIGRvdWJsZSBtcyA9IDEwMDAuMCAqICh0W2pdIC0gdFtqIC0gMV0pIC8gQ0xPQ0tTX1BFUl9TRUM7CiAgICAgICAgaWYoaSA9PSAwIHx8IGJlc3Rbal0gPiBtcykKICAgICAgICAgIGJlc3Rbal0gPSBtczsKICAgICAgfQogICAgfQogICAgcHJpbnRmKCJcbkluc3RhbnRpYXRpb24gdGltZXMgKG1zKTogJS4zZiA9ICUuM2YrJS4zZislLjNmKyUuM2ZcbiIsCiAgICAgICAgICAgYmVzdFsxXSArIGJlc3RbMl0gKyBiZXN0WzNdICsgYmVzdFs0XSwKICAgICAgICAgICBiZXN0WzFdLAogICAgICAgICAgIGJlc3RbMl0sCiAgICAgICAgICAgYmVzdFszXSwKICAgICAgICAgICBiZXN0WzRdKTsKICB9CiAgcmV0dXJuIDA7CmZhaWw6CiAganNfc3RkX2ZyZWVfaGFuZGxlcnMocnQpOwogIEpTX0ZyZWVDb250ZXh0KGN0eCk7CiAgSlNfRnJlZVJ1bnRpbWUocnQpOwogIHJldHVybiAxOwp9CgAAAAAAAAAADp4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA1JQAAAAAAAADlQAAAAAAAAAAAAAAAPC/"
				],
				[
					41,
					1,
					"cut",
					null,
					"AQAAAKtIAAAAAAAAq0gAAAAAAAAmAAAASlNfVkFMVUVfR0VUX1RBRyh2YWwpICE9IEpTX1RBR19NT0RVTEU",
					"AQAAAAAAAAABAAAAq0gAAAAAAADRSAAAAAAAAAAAAAAAAPC/"
				],
				[
					42,
					1,
					"paste",
					null,
					"AQAAAKtIAAAAAAAA0UgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAq0gAAAAAAACrSAAAAAAAAAAAAAAAAPC/"
				],
				[
					43,
					1,
					"insert",
					{
						"characters": " %"
					},
					"AgAAANFIAAAAAAAA0kgAAAAAAAAAAAAA0kgAAAAAAADTSAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA0UgAAAAAAADRSAAAAAAAAAAAAAAAAPC/"
				],
				[
					44,
					1,
					"left_delete",
					null,
					"AQAAANJIAAAAAAAA0kgAAAAAAAABAAAAJQ",
					"AQAAAAAAAAABAAAA00gAAAAAAADTSAAAAAAAAAAAAAAAAPC/"
				],
				[
					45,
					1,
					"insert",
					{
						"characters": "&&"
					},
					"AgAAANJIAAAAAAAA00gAAAAAAAAAAAAA00gAAAAAAADUSAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA0kgAAAAAAADSSAAAAAAAAAAAAAAAAPC/"
				],
				[
					46,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAANRIAAAAAAAA1UgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA1EgAAAAAAADUSAAAAAAAAAAAAAAAAPC/"
				],
				[
					47,
					1,
					"paste",
					null,
					"AQAAANVIAAAAAAAA+0gAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA1UgAAAAAAADVSAAAAAAAAAAAAAAAAPC/"
				],
				[
					48,
					6,
					"left_delete",
					null,
					"BgAAAPpIAAAAAAAA+kgAAAAAAAABAAAARflIAAAAAAAA+UgAAAAAAAABAAAATPhIAAAAAAAA+EgAAAAAAAABAAAAVfdIAAAAAAAA90gAAAAAAAABAAAARPZIAAAAAAAA9kgAAAAAAAABAAAAT/VIAAAAAAAA9UgAAAAAAAABAAAATQ",
					"AQAAAAAAAAABAAAA+0gAAAAAAAD7SAAAAAAAAAAAAAAAAPC/"
				],
				[
					49,
					1,
					"insert",
					{
						"characters": "EXCEPTION"
					},
					"CQAAAPVIAAAAAAAA9kgAAAAAAAAAAAAA9kgAAAAAAAD3SAAAAAAAAAAAAAD3SAAAAAAAAPhIAAAAAAAAAAAAAPhIAAAAAAAA+UgAAAAAAAAAAAAA+UgAAAAAAAD6SAAAAAAAAAAAAAD6SAAAAAAAAPtIAAAAAAAAAAAAAPtIAAAAAAAA/EgAAAAAAAAAAAAA/EgAAAAAAAD9SAAAAAAAAAAAAAD9SAAAAAAAAP5IAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA9UgAAAAAAAD1SAAAAAAAAAAAAAAAAPC/"
				],
				[
					60,
					4,
					"left_delete",
					null,
					"BAAAACxIAAAAAAAALEgAAAAAAAABAAAAICtIAAAAAAAAK0gAAAAAAAABAAAAICpIAAAAAAAAKkgAAAAAAAABAAAAIClIAAAAAAAAKUgAAAAAAAABAAAAIA",
					"AQAAAAAAAAABAAAALUgAAAAAAAAtSAAAAAAAAAAAAAAAAFlA"
				],
				[
					62,
					1,
					"left_delete",
					null,
					"AQAAACFIAAAAAAAAIUgAAAAAAAABAAAACg",
					"AQAAAAAAAAABAAAAIkgAAAAAAAAiSAAAAAAAAAAAAAAAAE5A"
				],
				[
					182,
					1,
					"paste",
					null,
					"AgAAAJyTAAAAAAAAr5MAAAAAAAAAAAAAr5MAAAAAAACvkwAAAAAAAAQAAABUUlVF",
					"AQAAAAAAAAABAAAAnJMAAAAAAACgkwAAAAAAAAAAAAAAAPC/"
				],
				[
					186,
					1,
					"paste",
					null,
					"AgAAAE6VAAAAAAAAYZUAAAAAAAAAAAAAYZUAAAAAAABhlQAAAAAAAAQAAABUUlVF",
					"AQAAAAAAAAABAAAATpUAAAAAAABSlQAAAAAAAAAAAAAAAPC/"
				],
				[
					200,
					1,
					"paste",
					null,
					"AgAAAKKZAAAAAAAAtZkAAAAAAAAAAAAAtZkAAAAAAAC1mQAAAAAAAAQAAABUUlVF",
					"AQAAAAAAAAABAAAAppkAAAAAAACimQAAAAAAAAAAAAAAAPC/"
				],
				[
					236,
					1,
					"insert",
					{
						"characters": "flags"
					},
					"BgAAAB5BAAAAAAAAH0EAAAAAAAAAAAAAH0EAAAAAAAAfQQAAAAAAAAYAAABtb2R1bGUfQQAAAAAAACBBAAAAAAAAAAAAACBBAAAAAAAAIUEAAAAAAAAAAAAAIUEAAAAAAAAiQQAAAAAAAAAAAAAiQQAAAAAAACNBAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAHkEAAAAAAAAkQQAAAAAAAAAAAAAAAPC/"
				],
				[
					251,
					1,
					"insert",
					{
						"characters": "flags"
					},
					"BgAAADxBAAAAAAAAPUEAAAAAAAAAAAAAPUEAAAAAAAA9QQAAAAAAAAYAAABtb2R1bGU9QQAAAAAAAD5BAAAAAAAAAAAAAD5BAAAAAAAAP0EAAAAAAAAAAAAAP0EAAAAAAABAQQAAAAAAAAAAAABAQQAAAAAAAEFBAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAPEEAAAAAAABCQQAAAAAAAAAAAAAAAPC/"
				],
				[
					252,
					1,
					"insert",
					{
						"characters": " &"
					},
					"AgAAAEFBAAAAAAAAQkEAAAAAAAAAAAAAQkEAAAAAAABDQQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAQUEAAAAAAABBQQAAAAAAAAAAAAAAAPC/"
				],
				[
					253,
					1,
					"paste",
					null,
					"AQAAAENBAAAAAAAAVkEAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAQ0EAAAAAAABDQQAAAAAAAAAAAAAAAPC/"
				],
				[
					258,
					1,
					"insert",
					{
						"characters": "flags"
					},
					"BgAAAN1BAAAAAAAA3kEAAAAAAAAAAAAA3kEAAAAAAADeQQAAAAAAABMAAABKU19FVkFMX1RZUEVfTU9EVUxF3kEAAAAAAADfQQAAAAAAAAAAAADfQQAAAAAAAOBBAAAAAAAAAAAAAOBBAAAAAAAA4UEAAAAAAAAAAAAA4UEAAAAAAADiQQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA3UEAAAAAAADwQQAAAAAAAAAAAAAAAPC/"
				],
				[
					264,
					1,
					"insert",
					{
						"characters": "flags"
					},
					"BgAAAGdDAAAAAAAAaEMAAAAAAAAAAAAAaEMAAAAAAABoQwAAAAAAAAYAAABtb2R1bGVoQwAAAAAAAGlDAAAAAAAAAAAAAGlDAAAAAAAAakMAAAAAAAAAAAAAakMAAAAAAABrQwAAAAAAAAAAAABrQwAAAAAAAGxDAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbUMAAAAAAABnQwAAAAAAAAAAAAAAAPC/"
				],
				[
					294,
					1,
					"paste",
					null,
					"AgAAAE9KAAAAAAAAW0oAAAAAAAAAAAAAW0oAAAAAAABbSgAAAAAAAAQAAABUUlVF",
					"AQAAAAAAAAABAAAAT0oAAAAAAABTSgAAAAAAAAAAAAAAAPC/"
				],
				[
					295,
					12,
					"left_delete",
					null,
					"DAAAAFpKAAAAAAAAWkoAAAAAAAABAAAAZllKAAAAAAAAWUoAAAAAAAABAAAAdVhKAAAAAAAAWEoAAAAAAAABAAAAYldKAAAAAAAAV0oAAAAAAAABAAAAX1ZKAAAAAAAAVkoAAAAAAAABAAAAbFVKAAAAAAAAVUoAAAAAAAABAAAAYVRKAAAAAAAAVEoAAAAAAAABAAAAdlNKAAAAAAAAU0oAAAAAAAABAAAAZVJKAAAAAAAAUkoAAAAAAAABAAAAX1FKAAAAAAAAUUoAAAAAAAABAAAAbVBKAAAAAAAAUEoAAAAAAAABAAAAc09KAAAAAAAAT0oAAAAAAAABAAAAag",
					"AQAAAAAAAAABAAAAW0oAAAAAAABbSgAAAAAAAAAAAAAAAPC/"
				],
				[
					296,
					1,
					"insert",
					{
						"characters": "JS"
					},
					"AgAAAE9KAAAAAAAAUEoAAAAAAAAAAAAAUEoAAAAAAABRSgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAT0oAAAAAAABPSgAAAAAAAAAAAAAAAPC/"
				],
				[
					297,
					1,
					"insert_completion",
					{
						"completion": "JS_EVAL_TYPE_MODULE",
						"format": "text",
						"keep_prefix": false,
						"must_insert": false,
						"trigger": "JS_EVAL_TYPE_MODULE"
					},
					"AgAAAE9KAAAAAAAAT0oAAAAAAAACAAAASlNPSgAAAAAAAGJKAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAUUoAAAAAAABRSgAAAAAAAAAAAAAAAPC/"
				],
				[
					337,
					1,
					"insert",
					{
						"characters": "fg"
					},
					"AwAAAPNDAAAAAAAA9EMAAAAAAAAAAAAA9EMAAAAAAAD0QwAAAAAAAAYAAABtb2R1bGX0QwAAAAAAAPVDAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA80MAAAAAAAD5QwAAAAAAAAAAAAAAAPC/"
				],
				[
					338,
					2,
					"left_delete",
					null,
					"AgAAAPRDAAAAAAAA9EMAAAAAAAABAAAAZ/NDAAAAAAAA80MAAAAAAAABAAAAZg",
					"AQAAAAAAAAABAAAA9UMAAAAAAAD1QwAAAAAAAAAAAAAAAPC/"
				],
				[
					339,
					1,
					"insert",
					{
						"characters": "flags"
					},
					"BQAAAPNDAAAAAAAA9EMAAAAAAAAAAAAA9EMAAAAAAAD1QwAAAAAAAAAAAAD1QwAAAAAAAPZDAAAAAAAAAAAAAPZDAAAAAAAA90MAAAAAAAAAAAAA90MAAAAAAAD4QwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA80MAAAAAAADzQwAAAAAAAAAAAAAAAPC/"
				],
				[
					347,
					1,
					"paste",
					null,
					"AgAAADpEAAAAAAAAP0QAAAAAAAAAAAAAP0QAAAAAAAA/RAAAAAAAAAYAAABtb2R1bGU",
					"AQAAAAAAAAABAAAAOkQAAAAAAABARAAAAAAAAAAAAAAAAPC/"
				],
				[
					376,
					1,
					"insert",
					{
						"characters": "BP"
					},
					"AwAAAIZHAAAAAAAAh0cAAAAAAAAAAAAAh0cAAAAAAACHRwAAAAAAAAMAAABpbnSHRwAAAAAAAIhHAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAhkcAAAAAAACJRwAAAAAAAAAAAAAAAPC/"
				],
				[
					377,
					1,
					"left_delete",
					null,
					"AQAAAIdHAAAAAAAAh0cAAAAAAAABAAAAUA",
					"AQAAAAAAAAABAAAAiEcAAAAAAACIRwAAAAAAAAAAAAAAAPC/"
				],
				[
					378,
					1,
					"insert",
					{
						"characters": "OOL"
					},
					"AwAAAIdHAAAAAAAAiEcAAAAAAAAAAAAAiEcAAAAAAACJRwAAAAAAAAAAAACJRwAAAAAAAIpHAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAh0cAAAAAAACHRwAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "vector.h",
			"settings":
			{
				"buffer_size": 6717,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
			]
		},
		{
			"file": "vector.c",
			"settings":
			{
				"buffer_size": 3762,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					25,
					1,
					"insert",
					{
						"characters": "vec->"
					},
					"BgAAAEkDAAAAAAAASgMAAAAAAAAAAAAASgMAAAAAAABKAwAAAAAAAAkAAABkYnVmX2ZyZWVKAwAAAAAAAEsDAAAAAAAAAAAAAEsDAAAAAAAATAMAAAAAAAAAAAAATAMAAAAAAABNAwAAAAAAAAAAAABNAwAAAAAAAE4DAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAASQMAAAAAAABSAwAAAAAAAAAAAAAAAPC/"
				],
				[
					26,
					1,
					"paste",
					null,
					"AQAAAE4DAAAAAAAAWgMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATgMAAAAAAABOAwAAAAAAAAAAAAAAAPC/"
				],
				[
					28,
					1,
					"insert",
					{
						"characters": "b"
					},
					"AQAAAFsDAAAAAAAAXAMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAWwMAAAAAAABbAwAAAAAAAAAAAAAAAPC/"
				],
				[
					29,
					1,
					"left_delete",
					null,
					"AQAAAFsDAAAAAAAAWwMAAAAAAAABAAAAYg",
					"AQAAAAAAAAABAAAAXAMAAAAAAABcAwAAAAAAAAAAAAAAAPC/"
				],
				[
					30,
					1,
					"insert",
					{
						"characters": "vec->opaque"
					},
					"CwAAAFsDAAAAAAAAXAMAAAAAAAAAAAAAXAMAAAAAAABdAwAAAAAAAAAAAABdAwAAAAAAAF4DAAAAAAAAAAAAAF4DAAAAAAAAXwMAAAAAAAAAAAAAXwMAAAAAAABgAwAAAAAAAAAAAABgAwAAAAAAAGEDAAAAAAAAAAAAAGEDAAAAAAAAYgMAAAAAAAAAAAAAYgMAAAAAAABjAwAAAAAAAAAAAABjAwAAAAAAAGQDAAAAAAAAAAAAAGQDAAAAAAAAZQMAAAAAAAAAAAAAZQMAAAAAAABmAwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAWwMAAAAAAABbAwAAAAAAAAAAAAAAAPC/"
				],
				[
					31,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAGYDAAAAAAAAZwMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAZgMAAAAAAABmAwAAAAAAAAAAAAAAAPC/"
				],
				[
					32,
					1,
					"left_delete",
					null,
					"AQAAAGYDAAAAAAAAZgMAAAAAAAABAAAAIA",
					"AQAAAAAAAAABAAAAZwMAAAAAAABnAwAAAAAAAAAAAAAAAPC/"
				],
				[
					33,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAGYDAAAAAAAAZwMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAZgMAAAAAAABmAwAAAAAAAAAAAAAAAPC/"
				],
				[
					34,
					1,
					"left_delete",
					null,
					"AQAAAGYDAAAAAAAAZgMAAAAAAAABAAAAIA",
					"AQAAAAAAAAABAAAAZwMAAAAAAABnAwAAAAAAAAAAAAAAAPC/"
				],
				[
					35,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAAGYDAAAAAAAAZwMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAZgMAAAAAAABmAwAAAAAAAAAAAAAAAPC/"
				],
				[
					36,
					1,
					"insert",
					{
						"characters": " vec->da"
					},
					"CAAAAGcDAAAAAAAAaAMAAAAAAAAAAAAAaAMAAAAAAABpAwAAAAAAAAAAAABpAwAAAAAAAGoDAAAAAAAAAAAAAGoDAAAAAAAAawMAAAAAAAAAAAAAawMAAAAAAABsAwAAAAAAAAAAAABsAwAAAAAAAG0DAAAAAAAAAAAAAG0DAAAAAAAAbgMAAAAAAAAAAAAAbgMAAAAAAABvAwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAZwMAAAAAAABnAwAAAAAAAAAAAAAAAPC/"
				],
				[
					37,
					1,
					"insert",
					{
						"characters": "ta,"
					},
					"AwAAAG8DAAAAAAAAcAMAAAAAAAAAAAAAcAMAAAAAAABxAwAAAAAAAAAAAABxAwAAAAAAAHIDAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbwMAAAAAAABvAwAAAAAAAAAAAAAAAPC/"
				],
				[
					38,
					1,
					"insert",
					{
						"characters": " vec-cap"
					},
					"CAAAAHIDAAAAAAAAcwMAAAAAAAAAAAAAcwMAAAAAAAB0AwAAAAAAAAAAAAB0AwAAAAAAAHUDAAAAAAAAAAAAAHUDAAAAAAAAdgMAAAAAAAAAAAAAdgMAAAAAAAB3AwAAAAAAAAAAAAB3AwAAAAAAAHgDAAAAAAAAAAAAAHgDAAAAAAAAeQMAAAAAAAAAAAAAeQMAAAAAAAB6AwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcgMAAAAAAAByAwAAAAAAAAAAAAAAAPC/"
				],
				[
					39,
					3,
					"left_delete",
					null,
					"AwAAAHkDAAAAAAAAeQMAAAAAAAABAAAAcHgDAAAAAAAAeAMAAAAAAAABAAAAYXcDAAAAAAAAdwMAAAAAAAABAAAAYw",
					"AQAAAAAAAAABAAAAegMAAAAAAAB6AwAAAAAAAAAAAAAAAPC/"
				],
				[
					40,
					1,
					"insert",
					{
						"characters": ">"
					},
					"AQAAAHcDAAAAAAAAeAMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAdwMAAAAAAAB3AwAAAAAAAAAAAAAAAPC/"
				],
				[
					41,
					2,
					"left_delete",
					null,
					"AgAAAHcDAAAAAAAAdwMAAAAAAAABAAAAPnYDAAAAAAAAdgMAAAAAAAABAAAALQ",
					"AQAAAAAAAAABAAAAeAMAAAAAAAB4AwAAAAAAAAAAAAAAAPC/"
				],
				[
					42,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAHYDAAAAAAAAdwMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAdgMAAAAAAAB2AwAAAAAAAAAAAAAAAPC/"
				],
				[
					43,
					4,
					"left_delete",
					null,
					"BAAAAHYDAAAAAAAAdgMAAAAAAAABAAAAIHUDAAAAAAAAdQMAAAAAAAABAAAAY3QDAAAAAAAAdAMAAAAAAAABAAAAZXMDAAAAAAAAcwMAAAAAAAABAAAAdg",
					"AQAAAAAAAAABAAAAdwMAAAAAAAB3AwAAAAAAAAAAAAAAAPC/"
				],
				[
					44,
					1,
					"insert",
					{
						"characters": "0);"
					},
					"AwAAAHMDAAAAAAAAdAMAAAAAAAAAAAAAdAMAAAAAAAB1AwAAAAAAAAAAAAB1AwAAAAAAAHYDAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcwMAAAAAAABzAwAAAAAAAAAAAAAAAPC/"
				],
				[
					46,
					1,
					"left_delete",
					null,
					"AQAAAHYDAAAAAAAAdgMAAAAAAAAMAAAAJnZlYy0+ZGJ1Zik7",
					"AQAAAAAAAAABAAAAdgMAAAAAAACCAwAAAAAAAP///////+9/"
				]
			]
		},
		{
			"file": "/home/roman/Projects/plot-cv/quickjs/cutils.h",
			"settings":
			{
				"buffer_size": 7403,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
			]
		},
		{
			"file": "/home/roman/Projects/plot-cv/quickjs/cutils.c",
			"settings":
			{
				"buffer_size": 17551,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
			]
		},
		{
			"file": "utils.h",
			"settings":
			{
				"buffer_size": 26821,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					18,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAADGaAAAI2lmbmRlZiBVVElMU19ICiNkZWZpbmUgVVRJTFNfSAoKI2luY2x1ZGUgInF1aWNranMuaCIKI2luY2x1ZGUgInF1aWNranMtaW50ZXJuYWwuaCIKI2luY2x1ZGUgImN1dGlscy5oIgojaW5jbHVkZSA8c3RyaW5nLmg+CiNpbmNsdWRlIDxtYXRoLmg+CiNpbmNsdWRlIDxzdHJpbmcuaD4KI2luY2x1ZGUgPHN0ZGxpYi5oPgojaW5jbHVkZSA8YXNzZXJ0Lmg+CgojaWZuZGVmIG9mZnNldG9mCiNkZWZpbmUgb2Zmc2V0b2YodHlwZSwgZmllbGQpICgoc2l6ZV90KSAmICgodHlwZSopMCktPmZpZWxkKQojZW5kaWYKCiNpZm5kZWYgaW5yYW5nZQojZGVmaW5lIGlucmFuZ2UodmFsdWUsIG1pbiwgbWF4KSAoKHZhbHVlKSA+PSAobWluKSAmJiAodmFsdWUpIDw9IChtYXgpKQojZW5kaWYKCiNpZiBkZWZpbmVkKF9UaHJlYWRfbG9jYWwpIHx8IChkZWZpbmVkKF9fU1REQ19WRVJTSU9OX18pICYmIChfX1NURENfVkVSU0lPTl9fID49IDIwMTEwMkwpKQojZGVmaW5lIHRocmVhZF9sb2NhbCBfVGhyZWFkX2xvY2FsCiNlbGlmIGRlZmluZWQoX19HTlVDX18pIHx8IGRlZmluZWQoX19JTlRFTF9DT01QSUxFUikgfHwgZGVmaW5lZChfX1NVTlBST19DQykgfHwgZGVmaW5lZChfX0lCTUNQUF9fKQojZGVmaW5lIHRocmVhZF9sb2NhbCBfX3RocmVhZAojZWxpZiBkZWZpbmVkKF9XSU4zMikKI2RlZmluZSB0aHJlYWRfbG9jYWwgX19kZWNsc3BlYyh0aHJlYWQpCiNlbHNlCiNlcnJvciBObyBUTFMgaW1wbGVtZW50YXRpb24gZm91bmQuCiNlbmRpZgoKdHlwZWRlZiBlbnVtIHByZWNlZGVuY2UgewogIFBSRUNFREVOQ0VfQ09NTUFfU0VRVUVOQ0UgPSAxLAogIFBSRUNFREVOQ0VfWUlFTEQsCiAgUFJFQ0VERU5DRV9BU1NJR05NRU5ULAogIFBSRUNFREVOQ0VfVEVSTkFSWSwKICBQUkVDRURFTkNFX05VTExJU0hfQ09BTEVTQ0lORywKICBQUkVDRURFTkNFX0xPR0lDQUxfT1IsCiAgUFJFQ0VERU5DRV9MT0dJQ0FMX0FORCwKICBQUkVDRURFTkNFX0JJVFdJU0VfT1IsCiAgUFJFQ0VERU5DRV9CSVRXSVNFX1hPUiwKICBQUkVDRURFTkNFX0JJVFdJU0VfQU5ELAogIFBSRUNFREVOQ0VfRVFVQUxJVFksCiAgUFJFQ0VERU5DRV9MRVNTX0dSRUFURVJfSU4sCiAgUFJFQ0VERU5DRV9CSVRXSVNFX1NISUZULAogIFBSRUNFREVOQ0VfQURESVRJVkUsCiAgUFJFQ0VERU5DRV9NVUxUSVBMSUNBVElWRSwKICBQUkVDRURFTkNFX0VYUE9ORU5USUFUSU9OLAogIFBSRUNFREVOQ0VfVU5BUlksCiAgUFJFQ0VERU5DRV9QT1NURklYLAogIFBSRUNFREVOQ0VfTkVXLAogIFBSRUNFREVOQ0VfTUVNQkVSX0FDQ0VTUywKICBQUkVDRURFTkNFX0dST1VQSU5HLAp9IEpTUHJlY2VkZW5jZTsKCiNkZWZpbmUgSlNfQ0dFVFNFVF9FTlVNRVJBQkxFX0RFRihwcm9wX25hbWUsIGZnZXR0ZXIsIGZzZXR0ZXIsIG1hZ2ljX251bSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgIC5uYW1lID0gcHJvcF9uYW1lLCAucHJvcF9mbGFncyA9IEpTX1BST1BfRU5VTUVSQUJMRSB8IEpTX1BST1BfQ09ORklHVVJBQkxFLCAuZGVmX3R5cGUgPSBKU19ERUZfQ0dFVFNFVF9NQUdJQywgICAgICBcCiAgICAubWFnaWMgPSBtYWdpY19udW0sIC51ID0geyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgICAuZ2V0c2V0ID0gey5nZXQgPSB7LmdldHRlcl9tYWdpYyA9IGZnZXR0ZXJ9LCAuc2V0ID0gey5zZXR0ZXJfbWFnaWMgPSBmc2V0dGVyfX0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgfQoKI2RlZmluZSBKU19DR0VUU0VUX01BR0lDX0ZMQUdTX0RFRihwcm9wX25hbWUsIGZnZXR0ZXIsIGZzZXR0ZXIsIG1hZ2ljX251bSwgZmxhZ3MpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgLm5hbWUgPSBwcm9wX25hbWUsIC5wcm9wX2ZsYWdzID0gZmxhZ3MsIC5kZWZfdHlwZSA9IEpTX0RFRl9DR0VUU0VUX01BR0lDLCAubWFnaWMgPSBtYWdpY19udW0sIC51ID0geyAgICAgICAgICAgICAgIFwKICAgICAgLmdldHNldCA9IHsuZ2V0ID0gey5nZXR0ZXJfbWFnaWMgPSBmZ2V0dGVyfSwgLnNldCA9IHsuc2V0dGVyX21hZ2ljID0gZnNldHRlcn19ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIH0KCiNkZWZpbmUgSlNfQ0ZVTkNfREVGX0ZMQUdTKHByb3BfbmFtZSwgbGVuZ3RoLCBmdW5jMSwgZmxhZ3MpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgIC5uYW1lID0gcHJvcF9uYW1lLCAucHJvcF9mbGFncyA9IGZsYWdzLCAuZGVmX3R5cGUgPSBKU19ERUZfQ0ZVTkMsIC5tYWdpYyA9IDAsIC51ID0geyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICAgIC5mdW5jID0ge2xlbmd0aCwgSlNfQ0ZVTkNfZ2VuZXJpYywgey5nZW5lcmljID0gZnVuYzF9fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICB9CgojaWYgZGVmaW5lZChfV0lOMzIpIHx8IGRlZmluZWQoX19NSU5HVzMyX18pCiNkZWZpbmUgVklTSUJMRSBfX2RlY2xzcGVjKGRsbGV4cG9ydCkKI2RlZmluZSBISURERU4KI2Vsc2UKI2RlZmluZSBWSVNJQkxFIF9fYXR0cmlidXRlX18oKHZpc2liaWxpdHkoImRlZmF1bHQiKSkpCiNkZWZpbmUgSElEREVOIF9fYXR0cmlidXRlX18oKHZpc2liaWxpdHkoImhpZGRlbiIpKSkKI2VuZGlmCgojaWZuZGVmIE1BWF9OVU0KI2RlZmluZSBNQVhfTlVNKGEsIGIpICgoYSkgPiAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgojaWZuZGVmIE1JTl9OVU0KI2RlZmluZSBNSU5fTlVNKGEsIGIpICgoYSkgPCAoYikgPyAoYSkgOiAoYikpCiNlbmRpZgoKLy8jaW5jbHVkZSAiY2hhci11dGlscy5oIgoKdHlwZWRlZiBzdHJ1Y3QgewogIEJPT0wgZG9uZTsKICBKU1ZhbHVlIHZhbHVlOwp9IEl0ZXJhdG9yVmFsdWU7Cgp0eXBlZGVmIHN0cnVjdCB7CiAgaW50IGM7CiAgY29uc3QgY2hhcioqIHY7Cn0gQXJndW1lbnRzOwoKc3RhdGljIGlubGluZSBBcmd1bWVudHMKYXJndW1lbnRzX25ldyhpbnQgYXJnYywgY29uc3QgY2hhciogYXJndltdKSB7CiAgQXJndW1lbnRzIGFyZ3M7CiAgYXJncy5jID0gYXJnYzsKICBhcmdzLnYgPSBhcmd2OwogIHJldHVybiBhcmdzOwp9CgpzdGF0aWMgaW5saW5lIGNvbnN0IGNoYXIqCmFyZ3VtZW50c19zaGlmdChBcmd1bWVudHMqIGFyZ3MpIHsKICBjb25zdCBjaGFyKiByZXQgPSAwOwogIGlmKGFyZ3MtPmMgPiAwKSB7CiAgICByZXQgPSBhcmdzLT52WzBdOwogICAgYXJncy0+Yy0tOwogICAgYXJncy0+disrOwogIH0KICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW5saW5lIGNvbnN0IGNoYXIqCmFyZ3VtZW50c19hdChBcmd1bWVudHMqIGFyZ3MsIGludCBpKSB7CiAgcmV0dXJuIGkgPj0gMCAmJiBpIDwgYXJncy0+YyA/IGFyZ3MtPnZbaV0gOiAwOwp9CgpzdGF0aWMgaW5saW5lIHVpbnQzMl90CmFyZ3VtZW50c19zaGlmdG4oQXJndW1lbnRzKiBhcmdzLCB1aW50MzJfdCBuKSB7CiAgdWludDMyX3QgaSA9IDA7CgogIHdoaWxlKG4gPiAwKSB7CiAgICBpZighYXJndW1lbnRzX3NoaWZ0KGFyZ3MpKQogICAgICBicmVhazsKICAgIGkrKzsKICAgIG4tLTsKICB9CiAgcmV0dXJuIGk7Cn0KCnR5cGVkZWYgc3RydWN0IHsKICBpbnQgYzsKICBKU1ZhbHVlQ29uc3QqIHY7Cn0gSlNBcmd1bWVudHM7CgpzdGF0aWMgaW5saW5lIEpTQXJndW1lbnRzCmpzX2FyZ3VtZW50c19uZXcoaW50IGFyZ2MsIEpTVmFsdWVDb25zdCogYXJndikgewogIEpTQXJndW1lbnRzIGFyZ3M7CiAgYXJncy5jID0gYXJnYzsKICBhcmdzLnYgPSBhcmd2OwogIHJldHVybiBhcmdzOwp9CgpzdGF0aWMgaW5saW5lIEpTVmFsdWVDb25zdApqc19hcmd1bWVudHNfc2hpZnQoSlNBcmd1bWVudHMqIGFyZ3MpIHsKICBKU1ZhbHVlIHJldCA9IEpTX0VYQ0VQVElPTjsKICBpZihhcmdzLT5jID4gMCkgewogICAgcmV0ID0gYXJncy0+dlswXTsKICAgIGFyZ3MtPmMtLTsKICAgIGFyZ3MtPnYrKzsKICB9CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBKU1ZhbHVlQ29uc3QKanNfYXJndW1lbnRzX2F0KEpTQXJndW1lbnRzKiBhcmdzLCBpbnQgaSkgewogIHJldHVybiBpID49IDAgJiYgaSA8IGFyZ3MtPmMgPyBhcmdzLT52W2ldIDogSlNfVU5ERUZJTkVEOwp9CgpzdGF0aWMgaW5saW5lIHVpbnQzMl90CmpzX2FyZ3VtZW50c19zaGlmdG4oSlNBcmd1bWVudHMqIGFyZ3MsIHVpbnQzMl90IG4pIHsKICB1aW50MzJfdCBpID0gMDsKCiAgd2hpbGUobiA+IDApIHsKICAgIGlmKEpTX0lzRXhjZXB0aW9uKGpzX2FyZ3VtZW50c19zaGlmdChhcmdzKSkpCiAgICAgIGJyZWFrOwogICAgaSsrOwogICAgbi0tOwogIH0KICByZXR1cm4gaTsKfQoKCnN0YXRpYyBpbmxpbmUgc2l6ZV90Cm1pbl9zaXplKHNpemVfdCBhLCBzaXplX3QgYikgewogIGlmKGEgPCBiKQogICAgcmV0dXJuIGE7CiAgZWxzZQogICAgcmV0dXJuIGI7Cn0KCnN0YXRpYyBpbmxpbmUgdWludDY0X3QKYWJzX2ludDY0KGludDY0X3QgYSkgewogIHJldHVybiBhIDwgMCA/IC1hIDogYTsKfQoKc3RhdGljIGlubGluZSB1aW50MzJfdAphYnNfaW50MzIoaW50MzJfdCBpKSB7CiAgcmV0dXJuIGkgPCAwID8gLWkgOiBpOwp9CgpzdGF0aWMgaW5saW5lIGludDMyX3QKc2lnbl9pbnQzMih1aW50MzJfdCBpKSB7CiAgcmV0dXJuIChpICYgMHg4MDAwMDAwMCkgPyAtMSA6IDE7Cn0KCnN0YXRpYyBpbmxpbmUgaW50MzJfdAptb2RfaW50MzIoaW50MzJfdCBhLCBpbnQzMl90IGIpIHsKICBpbnQzMl90IGMgPSBhICUgYjsKICByZXR1cm4gKGMgPCAwKSA/IGMgKyBiIDogYzsKfQoKI2RlZmluZSBDT0xPUl9SRUQgIlx4MWJbMzFtIgojZGVmaW5lIENPTE9SX0dSRUVOICJceDFiWzMybSIKI2RlZmluZSBDT0xPUl9ZRUxMT1cgIlx4MWJbMzNtIgojZGVmaW5lIENPTE9SX0JMVUUgIlx4MWJbMzRtIgojZGVmaW5lIENPTE9SX01BR0VOVEEgIlx4MWJbMzVtIgojZGVmaW5lIENPTE9SX01BUklORSAiXHgxYlszNm0iCiNkZWZpbmUgQ09MT1JfTElHSFRHUkFZICJceDFiWzM3bSIKI2RlZmluZSBDT0xPUl9HUkFZICJceDFiWzE7MzBtIgojZGVmaW5lIENPTE9SX05PTkUgIlx4MWJbbSIKCiNkZWZpbmUgQ09MT1JfTElHSFRSRUQgIlx4MWJbMTszMW0iCiNkZWZpbmUgQ09MT1JfTElHSFRHUkVFTiAiXHgxYlsxOzMybSIKI2RlZmluZSBDT0xPUl9MSUdIVFlFTExPVyAiXHgxYlsxOzMzbSIKI2RlZmluZSBDT0xPUl9MSUdIVEJMVUUgIlx4MWJbMTszNG0iCiNkZWZpbmUgQ09MT1JfTElHSFRNQUdFTlRBICJceDFiWzE7MzVtIgojZGVmaW5lIENPTE9SX0xJR0hUTUFSSU5FICJceDFiWzE7MzZtIgojZGVmaW5lIENPTE9SX1dISVRFICJceDFiWzE7MzdtIgoKdWludDY0X3QgdGltZV91cyh2b2lkKTsKCmludDY0X3QgYXJyYXlfc2VhcmNoKHZvaWQqIGEsIHNpemVfdCBtLCBzaXplX3QgZWxzeiwgdm9pZCogbmVlZGxlKTsKI2RlZmluZSBhcnJheV9jb250YWlucyhhLCBtLCBlbHN6LCBuZWVkbGUpIChhcnJheV9zZWFyY2goKGEpLCAobSksIChlbHN6KSwgKG5lZWRsZSkpICE9IC0xKQoKc3RhdGljIGlubGluZSB2b2lkCmpzX2RidWZfaW5pdF9ydChKU1J1bnRpbWUqIHJ0LCBEeW5CdWYqIHMpIHsKICBkYnVmX2luaXQyKHMsIHJ0LCAoRHluQnVmUmVhbGxvY0Z1bmMqKWpzX3JlYWxsb2NfcnQpOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQKanNfZGJ1Zl9pbml0KEpTQ29udGV4dCogY3R4LCBEeW5CdWYqIHMpIHsKICBkYnVmX2luaXQyKHMsIGN0eCwgKER5bkJ1ZlJlYWxsb2NGdW5jKilqc19yZWFsbG9jKTsKfQoKdHlwZWRlZiBzdHJ1Y3QgewogIGNoYXIqIHNvdXJjZTsKICBzaXplX3QgbGVuOwogIGludCBmbGFnczsKfSBSZWdFeHA7CgppbnQgcmVnZXhwX2ZsYWdzX3Rvc3RyaW5nKGludCwgY2hhciopOwppbnQgcmVnZXhwX2ZsYWdzX2Zyb21zdHJpbmcoY29uc3QgY2hhciopOwpSZWdFeHAgcmVnZXhwX2Zyb21fYXJndihpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSwgSlNDb250ZXh0KiBjdHgpOwpSZWdFeHAgcmVnZXhwX2Zyb21fZGJ1ZihEeW5CdWYqIGRidWYsIGludCBmbGFncyk7CnVpbnQ4X3QqIHJlZ2V4cF9jb21waWxlKFJlZ0V4cCByZSwgSlNDb250ZXh0KiBjdHgpOwpKU1ZhbHVlIHJlZ2V4cF90b192YWx1ZShSZWdFeHAgcmUsIEpTQ29udGV4dCogY3R4KTsKCnN0YXRpYyBpbmxpbmUgdm9pZApyZWdleHBfZnJlZV9ydChSZWdFeHAgcmUsIEpTUnVudGltZSogcnQpIHsKICBqc19mcmVlX3J0KHJ0LCByZS5zb3VyY2UpOwp9CnN0YXRpYyBpbmxpbmUgdm9pZApyZWdleHBfZnJlZShSZWdFeHAgcmUsIEpTQ29udGV4dCogY3R4KSB7CiAgcmVnZXhwX2ZyZWVfcnQocmUsIEpTX0dldFJ1bnRpbWUoY3R4KSk7Cn0KCkpTVmFsdWUganNfZ2xvYmFsX2dldChKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogcHJvcCk7CnN0YXRpYyBpbmxpbmUgSlNWYWx1ZQpqc19nbG9iYWxfbmV3KEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBjbGFzc19uYW1lLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSkgewogIEpTVmFsdWUgY3RvciA9IGpzX2dsb2JhbF9nZXQoY3R4LCBjbGFzc19uYW1lKTsKICBKU1ZhbHVlIG9iaiA9IEpTX0NhbGxDb25zdHJ1Y3RvcihjdHgsIGN0b3IsIGFyZ2MsIGFyZ3YpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGN0b3IpOwogIHJldHVybiBvYmo7Cn0KCkpTVmFsdWUganNfZ2xvYmFsX3Byb3RvdHlwZShKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogY2xhc3NfbmFtZSk7CgplbnVtIHZhbHVlX3R5cGVzIHsKICBGTEFHX1VOREVGSU5FRCA9IDAsCiAgRkxBR19OVUxMLCAgICAgICAgLy8gMQogIEZMQUdfQk9PTCwgICAgICAgIC8vIDIKICBGTEFHX0lOVCwgICAgICAgICAvLyAzCiAgRkxBR19PQkpFQ1QsICAgICAgLy8gNAogIEZMQUdfU1RSSU5HLCAgICAgIC8vIDUKICBGTEFHX1NZTUJPTCwgICAgICAvLyA2CiAgRkxBR19CSUdfRkxPQVQsICAgLy8gNwogIEZMQUdfQklHX0lOVCwgICAgIC8vIDgKICBGTEFHX0JJR19ERUNJTUFMLCAvLyA5CiAgRkxBR19GTE9BVDY0LCAgICAgLy8gMTAKICBGTEFHX05BTiwgICAgICAgICAvLyAxMQogIEZMQUdfRlVOQ1RJT04sICAgIC8vIDEyCiAgRkxBR19BUlJBWSwgICAgICAgLy8gMTMKICBGTEFHX01PRFVMRSwKICBGTEFHX0ZVTkNUSU9OX0JZVEVDT0RFLAogIEZMQUdfVU5JTklUSUFMSVpFRCwKICBGTEFHX0NBVENIX09GRlNFVCwKICBGTEFHX0VYQ0VQVElPTgoKfTsKCmVudW0gdmFsdWVfbWFzayB7CiAgVFlQRV9VTkRFRklORUQgPSAoMSA8PCBGTEFHX1VOREVGSU5FRCksCiAgVFlQRV9OVUxMID0gKDEgPDwgRkxBR19OVUxMKSwKICBUWVBFX0JPT0wgPSAoMSA8PCBGTEFHX0JPT0wpLAogIFRZUEVfSU5UID0gKDEgPDwgRkxBR19JTlQpLAogIFRZUEVfT0JKRUNUID0gKDEgPDwgRkxBR19PQkpFQ1QpLAogIFRZUEVfU1RSSU5HID0gKDEgPDwgRkxBR19TVFJJTkcpLAogIFRZUEVfU1lNQk9MID0gKDEgPDwgRkxBR19TWU1CT0wpLAogIFRZUEVfQklHX0ZMT0FUID0gKDEgPDwgRkxBR19CSUdfRkxPQVQpLAogIFRZUEVfQklHX0lOVCA9ICgxIDw8IEZMQUdfQklHX0lOVCksCiAgVFlQRV9CSUdfREVDSU1BTCA9ICgxIDw8IEZMQUdfQklHX0RFQ0lNQUwpLAogIFRZUEVfRkxPQVQ2NCA9ICgxIDw8IEZMQUdfRkxPQVQ2NCksCiAgVFlQRV9OQU4gPSAoMSA8PCBGTEFHX05BTiksCiAgVFlQRV9OVU1CRVIgPSAoVFlQRV9JTlQgfCBUWVBFX0JJR19GTE9BVCB8IFRZUEVfQklHX0lOVCB8IFRZUEVfQklHX0RFQ0lNQUwgfCBUWVBFX0ZMT0FUNjQpLAogIFRZUEVfUFJJTUlUSVZFID0gKFRZUEVfVU5ERUZJTkVEIHwgVFlQRV9OVUxMIHwgVFlQRV9CT09MIHwgVFlQRV9JTlQgfCBUWVBFX1NUUklORyB8IFRZUEVfU1lNQk9MIHwgVFlQRV9CSUdfRkxPQVQgfAogICAgICAgICAgICAgICAgICAgIFRZUEVfQklHX0lOVCB8IFRZUEVfQklHX0RFQ0lNQUwgfCBUWVBFX05BTiksCiAgVFlQRV9BTEwgPSAoVFlQRV9QUklNSVRJVkUgfCBUWVBFX09CSkVDVCksCiAgVFlQRV9GVU5DVElPTiA9ICgxIDw8IEZMQUdfRlVOQ1RJT04pLAogIFRZUEVfQVJSQVkgPSAoMSA8PCBGTEFHX0FSUkFZKSwKfTsKCmludDMyX3QganNfdmFsdWVfdHlwZV9mbGFnKEpTVmFsdWVDb25zdCB2YWx1ZSk7CmludDMyX3QganNfdmFsdWVfdHlwZV9nZXQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CgpzdGF0aWMgaW5saW5lIGludDMyX3QKanNfdmFsdWVfdHlwZTJmbGFnKHVpbnQzMl90IHR5cGUpIHsKICBpbnQzMl90IGZsYWc7CiAgZm9yKGZsYWcgPSAwOyAodHlwZSA+Pj0gMSk7IGZsYWcrKykge30KICByZXR1cm4gZmxhZzsKfQoKZW51bSB2YWx1ZV9tYXNrIGpzX3ZhbHVlX3R5cGUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CgpzdGF0aWMgaW5saW5lIGNvbnN0IGNoYXIqIGNvbnN0Kgpqc192YWx1ZV90eXBlcygpIHsKICByZXR1cm4gKGNvbnN0IGNoYXIqIGNvbnN0W10pewogICAgICAiVU5ERUZJTkVEIiwgICAgICJOVUxMIiwgICAgICAgICAiQk9PTCIsICAgICAgIklOVCIsICJPQkpFQ1QiLCAgICJTVFJJTkciLCAiU1lNQk9MIiwgIkJJR19GTE9BVCIsCiAgICAgICJCSUdfSU5UIiwgICAgICAgIkJJR19ERUNJTUFMIiwgICJGTE9BVDY0IiwgICAiTkFOIiwgIkZVTkNUSU9OIiwgIkFSUkFZIiwgICJNT0RVTEUiLCAiRlVOQ1RJT05fQllURUNPREUiLAogICAgICAiVU5JTklUSUFMSVpFRCIsICJDQVRDSF9PRkZTRVQiLCAiRVhDRVBUSU9OIiwgMCwKICB9Owp9CgpzdGF0aWMgaW5saW5lIGNvbnN0IGNoYXIqCmpzX3ZhbHVlX3R5cGVvZihKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBpbnQzMl90IGZsYWcgPSBqc192YWx1ZV90eXBlX2ZsYWcodmFsdWUpOwogIHJldHVybiAoKGNvbnN0IGNoYXIqIGNvbnN0W10pewogICAgICAidW5kZWZpbmVkIiwgICAgICJvYmplY3QiLCAgICAgICAiYm9vbGVhbiIsICAgIm51bWJlciIsICJvYmplY3QiLCAgICJzdHJpbmciLCAic3ltYm9sIiwgImJpZ2Zsb2F0IiwKICAgICAgImJpZ2ludCIsICAgICAgICAiYmlnZGVjaW1hbCIsICAgIm51bWJlciIsICAgICJudW1iZXIiLCAiZnVuY3Rpb24iLCAib2JqZWN0IiwgIm1vZHVsZSIsICJmdW5jdGlvbl9ieXRlY29kZSIsCiAgICAgICJ1bmluaXRpYWxpemVkIiwgImNhdGNoX29mZnNldCIsICJleGNlcHRpb24iLCAwLAogIH0pW2ZsYWddOwp9Cgpjb25zdCBjaGFyKiBqc192YWx1ZV90eXBlX25hbWUoaW50MzJfdCB0eXBlKTsKCmNvbnN0IGNoYXIqIGpzX3ZhbHVlX3R5cGVzdHIoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CgpWSVNJQkxFIHZvaWQqIGpzX3ZhbHVlX2dldF9wdHIoSlNWYWx1ZUNvbnN0IHYpOwpWSVNJQkxFIEpTT2JqZWN0KiBqc192YWx1ZV9nZXRfb2JqKEpTVmFsdWVDb25zdCB2KTsKVklTSUJMRSBpbnQzMl90IGpzX3ZhbHVlX2dldF90YWcoSlNWYWx1ZUNvbnN0IHYpOwpCT09MIGpzX3ZhbHVlX2hhc19yZWZfY291bnQoSlNWYWx1ZUNvbnN0IHYpOwoKdm9pZCBqc192YWx1ZV9mcmVlKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlIHYpOwp2b2lkIGpzX3ZhbHVlX2ZyZWVfcnQoSlNSdW50aW1lKiBydCwgSlNWYWx1ZSB2KTsKCkJPT0wganNfdmFsdWVfZXF1YWxzKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgYSwgSlNWYWx1ZUNvbnN0IGIpOwp2b2lkIGpzX3ZhbHVlX2R1bXAoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSwgRHluQnVmKiBkYik7CnZvaWQganNfdmFsdWVfcHJpbnQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CkpTVmFsdWUganNfdmFsdWVfY2xvbmUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWxwZSk7CkpTVmFsdWUqIGpzX3ZhbHVlc19kdXAoSlNDb250ZXh0KiBjdHgsIGludCBudmFsdWVzLCBKU1ZhbHVlQ29uc3QqIHZhbHVlcyk7CnZvaWQganNfdmFsdWVzX2ZyZWUoSlNSdW50aW1lKiBydCwgaW50IG52YWx1ZXMsIEpTVmFsdWVDb25zdCogdmFsdWVzKTsKSlNWYWx1ZSBqc192YWx1ZXNfdG9hcnJheShKU0NvbnRleHQqIGN0eCwgaW50IG52YWx1ZXMsIEpTVmFsdWVDb25zdCogdmFsdWVzKTsKCi8vI2luY2x1ZGUgImJ1ZmZlci11dGlscy5oIgoKY2hhcioganNfY3N0cmluZ19kdXAoSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIHN0cik7CmNoYXIqIGpzX2NzdHJpbmdfcHRyKEpTVmFsdWVDb25zdCB2KTsKSlNWYWx1ZUNvbnN0IGpzX2NzdHJpbmdfdmFsdWUoY29uc3QgY2hhciogcHRyKTsKdm9pZCBqc19jc3RyaW5nX2R1bXAoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSwgRHluQnVmKiBkYik7CgpzdGF0aWMgaW5saW5lIGNvbnN0IGNoYXIqCmpzX2NzdHJpbmdfbmV3KEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBzdHIpIHsKICBKU1ZhbHVlIHYgPSBKU19OZXdTdHJpbmcoY3R4LCBzdHIpOwogIGNvbnN0IGNoYXIqIHMgPSBKU19Ub0NTdHJpbmcoY3R4LCB2KTsKICBKU19GcmVlVmFsdWUoY3R4LCB2KTsKICByZXR1cm4gczsKfQpzdGF0aWMgaW5saW5lIGNvbnN0IGNoYXIqCmpzX2NzdHJpbmdfbmV3bGVuKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBzdHIsIHNpemVfdCBsZW4pIHsKICBKU1ZhbHVlIHYgPSBKU19OZXdTdHJpbmdMZW4oY3R4LCBzdHIsIGxlbik7CiAgY29uc3QgY2hhciogcyA9IEpTX1RvQ1N0cmluZyhjdHgsIHYpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHYpOwogIHJldHVybiBzOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQKanNfY3N0cmluZ19mcmVlKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBwdHIpIHsKICBpZighcHRyKQogICAgcmV0dXJuOwoKICBKU19GcmVlVmFsdWUoY3R4LCBKU19NS1BUUihKU19UQUdfU1RSSU5HLCAodm9pZCopKHB0ciAtIG9mZnNldG9mKEpTU3RyaW5nLCB1KSkpKTsKfQoKc3RhdGljIGlubGluZSBpbnQ2NF90CmpzX3RvaW50NjQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIGludDY0X3QgcmV0ID0gMDsKICBKU19Ub0ludDY0KGN0eCwgJnJldCwgdmFsdWUpOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgY2hhcioKanNfdG9zdHJpbmdsZW4oSlNDb250ZXh0KiBjdHgsIHNpemVfdCogbGVucCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgc2l6ZV90IGxlbjsKICBjb25zdCBjaGFyKiBjc3RyOwogIGNoYXIqIHJldCA9IDA7CiAgaWYoKGNzdHIgPSBKU19Ub0NTdHJpbmdMZW4oY3R4LCAmbGVuLCB2YWx1ZSkpKSB7CiAgICByZXQgPSBqc19zdHJuZHVwKGN0eCwgY3N0ciwgbGVuKTsKICAgIGlmKGxlbnApCiAgICAgICpsZW5wID0gbGVuOwogICAganNfY3N0cmluZ19mcmVlKGN0eCwgY3N0cik7CiAgfQogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgY2hhcioKanNfdG9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIHJldHVybiBqc190b3N0cmluZ2xlbihjdHgsIDAsIHZhbHVlKTsKfQoKc3RhdGljIGlubGluZSB3Y2hhcl90Kgpqc190b3dzdHJpbmdsZW4oSlNDb250ZXh0KiBjdHgsIHNpemVfdCogbGVucCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgc2l6ZV90IGksIGxlbjsKICBjb25zdCBjaGFyKiBjc3RyOwogIHdjaGFyX3QqIHJldCA9IDA7CiAgaWYoKGNzdHIgPSBKU19Ub0NTdHJpbmdMZW4oY3R4LCAmbGVuLCB2YWx1ZSkpKSB7CiAgICByZXQgPSBqc19tYWxsb2N6KGN0eCwgc2l6ZW9mKHdjaGFyX3QpICogKGxlbiArIDEpKTsKICAgIHVpbnQ4X3QgKnB0ciA9ICh1aW50OF90Kiljc3RyLCAqZW5kID0gKHVpbnQ4X3QqKWNzdHIgKyBsZW47CgogICAgZm9yKGkgPSAwOyBwdHIgPCBlbmQ7KSB7IHJldFtpKytdID0gdW5pY29kZV9mcm9tX3V0ZjgocHRyLCBlbmQgLSBwdHIsICZwdHIpOyB9CgogICAgaWYobGVucCkKICAgICAgKmxlbnAgPSBpOwogIH0KICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW5saW5lIHdjaGFyX3QqCmpzX3Rvd3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgcmV0dXJuIGpzX3Rvd3N0cmluZ2xlbihjdHgsIDAsIHZhbHVlKTsKfQoKc3RhdGljIGlubGluZSBKU1ZhbHVlCmpzX3ZhbHVlX3Rvc3RyaW5nKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBjbGFzc19uYW1lLCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBKU0F0b20gYXRvbTsKICBKU1ZhbHVlIHByb3RvLCB0b3N0cmluZywgc3RyOwogIHByb3RvID0ganNfZ2xvYmFsX3Byb3RvdHlwZShjdHgsIGNsYXNzX25hbWUpOwogIGF0b20gPSBKU19OZXdBdG9tKGN0eCwgInRvU3RyaW5nIik7CiAgdG9zdHJpbmcgPSBKU19HZXRQcm9wZXJ0eShjdHgsIHByb3RvLCBhdG9tKTsKICBKU19GcmVlVmFsdWUoY3R4LCBwcm90byk7CiAgSlNfRnJlZUF0b20oY3R4LCBhdG9tKTsKICBzdHIgPSBKU19DYWxsKGN0eCwgdG9zdHJpbmcsIHZhbHVlLCAwLCAwKTsKICBKU19GcmVlVmFsdWUoY3R4LCB0b3N0cmluZyk7CiAgcmV0dXJuIHN0cjsKfQoKaW50IGpzX3ZhbHVlX3Rvc2l6ZShKU0NvbnRleHQqIGN0eCwgc2l6ZV90KiBzeiwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKCnN0YXRpYyBpbmxpbmUgZG91YmxlCmpzX3ZhbHVlX3RvZG91YmxlX2ZyZWUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIGRvdWJsZSByZXQgPSAwOwogIEpTX1RvRmxvYXQ2NChjdHgsICZyZXQsIHZhbHVlKTsKICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBpbnQ2NF90CmpzX3ZhbHVlX3RvaW50NjRfZnJlZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgaW50NjRfdCByZXQgPSAwOwogIEpTX1RvSW50NjQoY3R4LCAmcmV0LCB2YWx1ZSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgQk9PTApqc192YWx1ZV90b2Jvb2xfZnJlZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgQk9PTCByZXQgPSBKU19Ub0Jvb2woY3R4LCB2YWx1ZSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbmxpbmUgSlNBdG9tCmpzX3ZhbHVlX3RvYXRvbV9mcmVlKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBKU0F0b20gYXRvbSA9IEpTX1ZhbHVlVG9BdG9tKGN0eCwgdmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICByZXR1cm4gYXRvbTsKfQoKSlNWYWx1ZSBqc192YWx1ZV9mcm9tX2NoYXIoSlNDb250ZXh0KiBjdHgsIGludCBjKTsKc3RhdGljIGlubGluZSBpbnQKanNfdmFsdWVfY21wc3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUsIGNvbnN0IGNoYXIqIG90aGVyKSB7CiAgY29uc3QgY2hhciogc3RyID0gSlNfVG9DU3RyaW5nKGN0eCwgdmFsdWUpOwogIGludCByZXQgPSBzdHJjbXAoc3RyLCBvdGhlcik7CiAgSlNfRnJlZUNTdHJpbmcoY3R4LCBzdHIpOwogIHJldHVybiByZXQ7Cn0KCiNkZWZpbmUgSlNfVkFMVUVfRlJFRShjdHgsIHZhbHVlKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgIEpTX0ZyZWVWYWx1ZSgoY3R4KSwgKHZhbHVlKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICAodmFsdWUpID0gSlNfVU5ERUZJTkVEOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIH0gd2hpbGUoMCk7CiNkZWZpbmUgSlNfVkFMVUVfRlJFRV9SVChjdHgsIHZhbHVlKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgIEpTX0ZyZWVWYWx1ZVJUKChjdHgpLCAodmFsdWUpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICAodmFsdWUpID0gSlNfVU5ERUZJTkVEOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIH0gd2hpbGUoMCk7CgojZGVmaW5lIGpzX29iamVjdF90bXBtYXJrX3NldCh2YWx1ZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICBkbyB7ICgodWludDhfdCopSlNfVkFMVUVfR0VUX09CSigodmFsdWUpKSlbNV0gfD0gMHg0MDsgfSB3aGlsZSgwKTsKI2RlZmluZSBqc19vYmplY3RfdG1wbWFya19jbGVhcih2YWx1ZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgZG8geyAoKHVpbnQ4X3QqKUpTX1ZBTFVFX0dFVF9PQkooKHZhbHVlKSkpWzVdICY9IH4weDQwOyB9IHdoaWxlKDApOwojZGVmaW5lIGpzX29iamVjdF90bXBtYXJrX2lzc2V0KHZhbHVlKSAoKCh1aW50OF90KilKU19WQUxVRV9HRVRfT0JKKCh2YWx1ZSkpKVs1XSAmIDB4NDApCgojZGVmaW5lIGpzX3J1bnRpbWVfZXhjZXB0aW9uX3NldChydCwgdmFsdWUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICBkbyB7ICooSlNWYWx1ZSopKCh1aW50OF90KikocnQpICsgMjE2KSA9IHZhbHVlOyB9IHdoaWxlKDApOwojZGVmaW5lIGpzX3J1bnRpbWVfZXhjZXB0aW9uX2dldChydCkgKCooSlNWYWx1ZSopKCh1aW50OF90KikocnQpICsgMjE2KSkKI2RlZmluZSBqc19ydW50aW1lX2V4Y2VwdGlvbl9jbGVhcihydCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgaWYoIUpTX0lzTnVsbChqc19ydW50aW1lX2V4Y2VwdGlvbl9nZXQocnQpKSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAgICAgSlNfRnJlZVZhbHVlUlQoKHJ0KSwganNfcnVudGltZV9leGNlcHRpb25fZ2V0KHJ0KSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgICBqc19ydW50aW1lX2V4Y2VwdGlvbl9zZXQocnQsIEpTX05VTEwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogIH0gd2hpbGUoMCkKCnZvaWQganNfcHJvcGVydHllbnVtc19mcmVlKEpTQ29udGV4dCogY3R4LCBKU1Byb3BlcnR5RW51bSogcHJvcHMsIHNpemVfdCBsZW4pOwoKc3RhdGljIGlubGluZSB2b2lkCmpzX3Byb3BlcnR5ZGVzY3JpcHRvcl9mcmVlKEpTQ29udGV4dCogY3R4LCBKU1Byb3BlcnR5RGVzY3JpcHRvciogZGVzYykgewogIEpTX0ZyZWVWYWx1ZShjdHgsIGRlc2MtPnZhbHVlKTsKICBKU19GcmVlVmFsdWUoY3R4LCBkZXNjLT5nZXR0ZXIpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGRlc2MtPnNldHRlcik7Cn0KCkpTVmFsdWUganNfc3ltYm9sX2N0b3IoSlNDb250ZXh0KiBjdHgpOwoKSlNWYWx1ZSBqc19zeW1ib2xfaW52b2tlX3N0YXRpYyhKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogbmFtZSwgSlNWYWx1ZUNvbnN0IGFyZyk7CgpKU1ZhbHVlIGpzX3N5bWJvbF90b19zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBzeW0pOwoKY29uc3QgY2hhcioganNfc3ltYm9sX3RvX2NzdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBzeW0pOwoKSlNWYWx1ZSBqc19zeW1ib2xfc3RhdGljX3ZhbHVlKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBuYW1lKTsKSlNBdG9tIGpzX3N5bWJvbF9zdGF0aWNfYXRvbShKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogbmFtZSk7CkJPT0wganNfaXNfaXRlcmFibGUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmopOwpCT09MIGpzX2lzX2l0ZXJhdG9yKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqKTsKSlNWYWx1ZSBqc19pdGVyYXRvcl9tZXRob2QoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmopOwpKU1ZhbHVlIGpzX2l0ZXJhdG9yX25ldyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaik7CkpTVmFsdWUganNfaXRlcmF0b3JfbmV4dChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgQk9PTCogZG9uZV9wKTsKSlNWYWx1ZSBqc19zeW1ib2xfZm9yKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBzeW1fZm9yKTsKSlNBdG9tIGpzX3N5bWJvbF9mb3JfYXRvbShKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogc3ltX2Zvcik7CgpKU1ZhbHVlIGpzX3N5bWJvbF9vcGVyYXRvcnNldF92YWx1ZShKU0NvbnRleHQqIGN0eCk7CgpKU0F0b20ganNfc3ltYm9sX29wZXJhdG9yc2V0X2F0b20oSlNDb250ZXh0KiBjdHgpOwoKSlNWYWx1ZSBqc19vcGVyYXRvcnNfY3JlYXRlKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlKiB0aGlzX29iaik7CgpzdGF0aWMgaW5saW5lIGludDY0X3QKanNfaW50NjRfZGVmYXVsdChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlLCBpbnQ2NF90IGkpIHsKICBpZihKU19Jc051bWJlcih2YWx1ZSkpCiAgICBKU19Ub0ludDY0KGN0eCwgJmksIHZhbHVlKTsKICByZXR1cm4gaTsKfQoKSlNWYWx1ZSBqc19udW1iZXJfbmV3KEpTQ29udGV4dCogY3R4LCBpbnQzMl90IG4pOwoKc3RhdGljIGlubGluZSBKU1ZhbHVlCmpzX25ld19ib29sX29yX251bWJlcihKU0NvbnRleHQqIGN0eCwgaW50MzJfdCBuKSB7CiAgaWYobiA9PSAwKQogICAgcmV0dXJuIEpTX05ld0Jvb2woY3R4LCBGQUxTRSk7CiAgcmV0dXJuIGpzX251bWJlcl9uZXcoY3R4LCBuKTsKfQoKI2RlZmluZSBKU19BVE9NX1RBR19JTlQgKDFVIDw8IDMxKQojZGVmaW5lIEpTX0FUT01fTUFYX0lOVCAoSlNfQVRPTV9UQUdfSU5UIC0gMSkKCiNkZWZpbmUganNfYXRvbV9pc2ludChpKSAoKEpTQXRvbSkoKGkpJkpTX0FUT01fVEFHX0lOVCkpCiNkZWZpbmUganNfYXRvbV9mcm9taW50KGkpICgoSlNBdG9tKSgoaSkmSlNfQVRPTV9NQVhfSU5UKSB8IEpTX0FUT01fVEFHX0lOVCkKI2RlZmluZSBqc19hdG9tX3RvaW50KGkpICh1bnNpZ25lZCBpbnQpKCgoSlNBdG9tKShpKSAmICh+KEpTX0FUT01fVEFHX0lOVCkpKSkKCmludCBqc19hdG9tX3RvaW50NjQoSlNDb250ZXh0KiBjdHgsIGludDY0X3QqIGksIEpTQXRvbSBhdG9tKTsKaW50MzJfdCBqc19hdG9tX3RvaW50MzIoSlNDb250ZXh0KiBjdHgsIEpTQXRvbSBhdG9tKTsKCnN0YXRpYyBpbmxpbmUgSlNWYWx1ZQpqc19hdG9tX3RvdmFsdWUoSlNDb250ZXh0KiBjdHgsIEpTQXRvbSBhdG9tKSB7CiAgaWYoanNfYXRvbV9pc2ludChhdG9tKSkKICAgIHJldHVybiBKU19NS1ZBTChKU19UQUdfSU5ULCBqc19hdG9tX3RvaW50KGF0b20pKTsKCiAgcmV0dXJuIEpTX0F0b21Ub1ZhbHVlKGN0eCwgYXRvbSk7Cn0KCnVuc2lnbmVkIGludCBqc19hdG9tX3RvYmluYXJ5KEpTQXRvbSBhdG9tKTsKY29uc3QgY2hhcioganNfYXRvbV90b19jc3RyaW5nbGVuKEpTQ29udGV4dCogY3R4LCBzaXplX3QqIGxlbiwgSlNBdG9tIGF0b20pOwp2b2lkIGpzX2F0b21fZHVtcChKU0NvbnRleHQqIGN0eCwgSlNBdG9tIGF0b20sIER5bkJ1ZiogZGIsIEJPT0wgY29sb3IpOwpCT09MIGpzX2F0b21faXNfaW5kZXgoSlNDb250ZXh0KiBjdHgsIGludDY0X3QqIHB2YWwsIEpTQXRvbSBhdG9tKTsKQk9PTCBqc19hdG9tX2lzX2xlbmd0aChKU0NvbnRleHQqIGN0eCwgSlNBdG9tIGF0b20pOwoKY29uc3QgY2hhcioganNfb2JqZWN0X3Rvc3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwpjb25zdCBjaGFyKiBqc19mdW5jdGlvbl9uYW1lKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwpjb25zdCBjaGFyKiBqc19mdW5jdGlvbl90b3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKQk9PTCBqc19mdW5jdGlvbl9pc25hdGl2ZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKCmNoYXIqIGpzX29iamVjdF9jbGFzc25hbWUoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSk7CmludCBqc19vYmplY3RfaXMoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSwgY29uc3QgY2hhciogY21wKTsKSlNWYWx1ZSBqc19vYmplY3RfY29uc3RydWN0KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgY3Rvcik7CkpTVmFsdWUganNfb2JqZWN0X2Vycm9yKEpTQ29udGV4dCogY3R4LCBjb25zdCBjaGFyKiBtZXNzYWdlKTsKSlNWYWx1ZSBqc19vYmplY3Rfc3RhY2soSlNDb250ZXh0KiBjdHgpOwoKc3RhdGljIGlubGluZSBCT09MCmpzX29iamVjdF9zYW1lKEpTVmFsdWVDb25zdCBhLCBKU1ZhbHVlQ29uc3QgYikgewogIEpTT2JqZWN0ICphb2JqLCAqYm9iajsKICBpZighSlNfSXNPYmplY3QoYSkgfHwgIUpTX0lzT2JqZWN0KGIpKQogICAgcmV0dXJuIEZBTFNFOwoKICBhb2JqID0gSlNfVkFMVUVfR0VUX09CSihhKTsKICBib2JqID0gSlNfVkFMVUVfR0VUX09CSihiKTsKICByZXR1cm4gYW9iaiA9PSBib2JqOwp9CgpzdGF0aWMgaW5saW5lIEpTQ2xhc3NJRApqc19nZXRfY2xhc3NpZChKU1ZhbHVlIHYpIHsKICBKU09iamVjdCogcDsKICAvKiBpZihKU19WQUxVRV9HRVRfVEFHKHYpICE9IEpTX1RBR19PQkpFQ1QpCiAgICAgcmV0dXJuIDA7Ki8KICBwID0gSlNfVkFMVUVfR0VUX09CSih2KTsKICBhc3NlcnQocCAhPSAwKTsKICByZXR1cm4gcC0+Y2xhc3NfaWQ7Cn0KCkJPT0wganNfaGFzX3Byb3BlcnR5c3RyKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBjb25zdCBjaGFyKiBzdHIpOwpCT09MIGpzX2dldF9wcm9wZXJ0eXN0cl9ib29sKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBjb25zdCBjaGFyKiBzdHIpOwp2b2lkIGpzX3NldF9wcm9wZXJ0eWludF9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIHVpbnQzMl90IGksIGNvbnN0IGNoYXIqIHN0cik7CnZvaWQganNfc2V0X3Byb3BlcnR5aW50X2ludChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgdWludDMyX3QgaSwgaW50MzJfdCB2YWx1ZSk7CnZvaWQganNfc2V0X3Byb3BlcnR5c3RyX3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgY29uc3QgY2hhciogcHJvcCwgY29uc3QgY2hhciogc3RyKTsKdm9pZCBqc19zZXRfcHJvcGVydHlzdHJfc3RyaW5nbGVuKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBjb25zdCBjaGFyKiBwcm9wLCBjb25zdCBjaGFyKiBzdHIsIHNpemVfdCBsZW4pOwpjb25zdCBjaGFyKiBqc19nZXRfcHJvcGVydHlpbnRfY3N0cmluZyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgdWludDMyX3QgaSk7CmNvbnN0IGNoYXIqIGpzX2dldF9wcm9wZXJ0eXN0cl9jc3RyaW5nKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBjb25zdCBjaGFyKiBwcm9wKTsKY29uc3QgY2hhcioganNfZ2V0X3Byb3BlcnR5c3RyX2NzdHJpbmdsZW4oSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3AsIHNpemVfdCogbGVucCk7CmNoYXIqIGpzX2dldF9wcm9wZXJ0eXN0cl9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3ApOwpjaGFyKiBqc19nZXRfcHJvcGVydHlzdHJfc3RyaW5nbGVuKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3Qgb2JqLCBjb25zdCBjaGFyKiBwcm9wLCBzaXplX3QqIGxlbnApOwppbnQzMl90IGpzX2dldF9wcm9wZXJ0eXN0cl9pbnQzMihKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgY29uc3QgY2hhciogcHJvcCk7CnVpbnQ2NF90IGpzX2dldF9wcm9wZXJ0eXN0cl91aW50NjQoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHByb3ApOwppbnQganNfZ2V0X3Byb3BlcnR5ZGVzY3JpcHRvcihKU0NvbnRleHQqIGN0eCwgSlNQcm9wZXJ0eURlc2NyaXB0b3IqIGRlc2MsIEpTVmFsdWVDb25zdCBvYmosIEpTQXRvbSBwcm9wKTsKc3RhdGljIGlubGluZSB2b2lkCmpzX3NldF9pbnNwZWN0X21ldGhvZChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgSlNDRnVuY3Rpb24qIGZ1bmMpIHsKICBKU0F0b20gaW5zcGVjdF9zeW1ib2wgPSBqc19zeW1ib2xfZm9yX2F0b20oY3R4LCAicXVpY2tqcy5pbnNwZWN0LmN1c3RvbSIpOwogIEpTX0RlZmluZVByb3BlcnR5VmFsdWUoCiAgICAgIGN0eCwgb2JqLCBpbnNwZWN0X3N5bWJvbCwgSlNfTmV3Q0Z1bmN0aW9uKGN0eCwgZnVuYywgImluc3BlY3QiLCAxKSwgSlNfUFJPUF9DT05GSUdVUkFCTEUgfCBKU19QUk9QX1dSSVRBQkxFKTsKICBKU19GcmVlQXRvbShjdHgsIGluc3BlY3Rfc3ltYm9sKTsKfQoKc3RhdGljIGlubGluZSB2b2lkCmpzX3NldF90b3N0cmluZ3RhZ192YWx1ZShKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgSlNWYWx1ZSB2YWx1ZSkgewogIEpTQXRvbSB0b3N0cmluZ190YWcgPSBqc19zeW1ib2xfc3RhdGljX2F0b20oY3R4LCAidG9TdHJpbmdUYWciKTsKICBKU19EZWZpbmVQcm9wZXJ0eVZhbHVlKGN0eCwgb2JqLCB0b3N0cmluZ190YWcsIHZhbHVlLCBKU19QUk9QX0NPTkZJR1VSQUJMRSB8IEpTX1BST1BfV1JJVEFCTEUpOwogIEpTX0ZyZWVBdG9tKGN0eCwgdG9zdHJpbmdfdGFnKTsKfQoKc3RhdGljIGlubGluZSB2b2lkCmpzX3NldF90b3N0cmluZ3RhZ19zdHIoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBvYmosIGNvbnN0IGNoYXIqIHN0cikgewogIGpzX3NldF90b3N0cmluZ3RhZ192YWx1ZShjdHgsIG9iaiwgSlNfTmV3U3RyaW5nKGN0eCwgc3RyKSk7Cn0KCkpTQ2xhc3NJRCBqc19jbGFzc19pZChKU0NvbnRleHQqIGN0eCwgaW50IGlkKTsKSlNDbGFzc0lEIGpzX2NsYXNzX25ld2lkKHZvaWQpOwpKU0NsYXNzKiBqc19jbGFzc19nZXQoSlNDb250ZXh0KiBjdHgsIEpTQ2xhc3NJRCBpZCk7CkpTQXRvbSBqc19jbGFzc19hdG9tKEpTQ29udGV4dCogY3R4LCBKU0NsYXNzSUQgaWQpOwpjb25zdCBjaGFyKiBqc19jbGFzc19uYW1lKEpTQ29udGV4dCogY3R4LCBKU0NsYXNzSUQgaWQpOwoKc3RhdGljIGlubGluZSBCT09MCmpzX29iamVjdF9pc2NsYXNzKEpTVmFsdWUgb2JqLCBpbnQzMl90IGNsYXNzX2lkKSB7CiAgcmV0dXJuIEpTX0dldE9wYXF1ZShvYmosIGNsYXNzX2lkKSAhPSAwOwp9CgpzdGF0aWMgaW5saW5lIEJPT0wKanNfdmFsdWVfaXNjbGFzcyhKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZSBvYmosIGludCBpZCkgewogIGludDMyX3QgY2xhc3NfaWQgPSBqc19jbGFzc19pZChjdHgsIGlkKTsKICByZXR1cm4ganNfb2JqZWN0X2lzY2xhc3Mob2JqLCBjbGFzc19pZCk7Cn0KCkJPT0wganNfaXNfYXJyYXlidWZmZXIoSlNDb250ZXh0KiwgSlNWYWx1ZSk7CkJPT0wganNfaXNfc2hhcmVkYXJyYXlidWZmZXIoSlNDb250ZXh0KiwgSlNWYWx1ZSk7CkJPT0wganNfaXNfbWFwKEpTQ29udGV4dCosIEpTVmFsdWUpOwpCT09MIGpzX2lzX3NldChKU0NvbnRleHQqLCBKU1ZhbHVlKTsKQk9PTCBqc19pc19nZW5lcmF0b3IoSlNDb250ZXh0KiwgSlNWYWx1ZSk7CkJPT0wganNfaXNfcmVnZXhwKEpTQ29udGV4dCosIEpTVmFsdWUpOwpCT09MIGpzX2lzX3Byb21pc2UoSlNDb250ZXh0KiwgSlNWYWx1ZSk7CkJPT0wganNfaXNfZGF0YXZpZXcoSlNDb250ZXh0KiwgSlNWYWx1ZSk7CgpzdGF0aWMgaW5saW5lIEJPT0wKanNfaXNfbnVsbF9vcl91bmRlZmluZWQoSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgcmV0dXJuIEpTX0lzVW5kZWZpbmVkKHZhbHVlKSB8fCBKU19Jc051bGwodmFsdWUpOwp9CgpzdGF0aWMgaW5saW5lIEJPT0wKanNfaXNfZmFsc2lzaChKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBzd2l0Y2goSlNfVkFMVUVfR0VUX1RBRyh2YWx1ZSkpIHsKICAgIGNhc2UgSlNfVEFHX05VTEw6IHJldHVybiBUUlVFOwogICAgY2FzZSBKU19UQUdfVU5ERUZJTkVEOiByZXR1cm4gVFJVRTsKICAgIGNhc2UgSlNfVEFHX0lOVDogcmV0dXJuIEpTX1ZBTFVFX0dFVF9JTlQodmFsdWUpID09IDA7CiAgICBjYXNlIEpTX1RBR19CT09MOiByZXR1cm4gIUpTX1ZBTFVFX0dFVF9CT09MKHZhbHVlKTsKICAgIGNhc2UgSlNfVEFHX0ZMT0FUNjQ6IHJldHVybiBKU19WQUxVRV9HRVRfRkxPQVQ2NCh2YWx1ZSkgPT0gMDsKICAgIGRlZmF1bHQ6IHJldHVybiBGQUxTRTsKICB9Cn0KCnN0YXRpYyBpbmxpbmUgQk9PTApqc19pc190cnVpc2goSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgcmV0dXJuICFqc19pc19mYWxzaXNoKHZhbHVlKTsKfQoKc3RhdGljIGlubGluZSBCT09MCmpzX2lzX251bGxpc2goSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIGludDY0X3QgaSA9IC0xOwoKICBpZihKU19Jc1VuZGVmaW5lZCh2YWx1ZSkgfHwgSlNfSXNOdWxsKHZhbHVlKSkKICAgIHJldHVybiBUUlVFOwogIEpTX1RvSW50NjQoY3R4LCAmaSwgdmFsdWUpOwogIHJldHVybiBpID09IDA7Cn0KCkpTVmFsdWUganNfdHlwZWRhcnJheV9wcm90b3R5cGUoSlNDb250ZXh0KiBjdHgpOwpKU1ZhbHVlIGpzX3R5cGVkYXJyYXlfY29uc3RydWN0b3IoSlNDb250ZXh0KiBjdHgpOwoKc3RhdGljIGlubGluZSBCT09MCmpzX2lzX2Jhc2ljX2FycmF5KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICBKU1ZhbHVlIGN0b3IgPSBqc19nbG9iYWxfZ2V0KGN0eCwgIkFycmF5Iik7CiAgQk9PTCByZXQgPSBKU19Jc0luc3RhbmNlT2YoY3R4LCB2YWx1ZSwgY3Rvcik7CiAgSlNfRnJlZVZhbHVlKGN0eCwgY3Rvcik7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSBCT09MCmpzX2lzX3R5cGVkYXJyYXkoSlNWYWx1ZUNvbnN0IHZhbHVlKSB7CiAgaWYoSlNfSXNPYmplY3QodmFsdWUpKSB7CiAgICBKU0NsYXNzSUQgaWQgPSBqc19nZXRfY2xhc3NpZCh2YWx1ZSk7CiAgICByZXR1cm4gaWQgPj0gSlNfQ0xBU1NfVUlOVDhDX0FSUkFZICYmIGlkIDw9IEpTX0NMQVNTX0ZMT0FUNjRfQVJSQVk7CiAgfQogIHJldHVybiBGQUxTRTsKfQoKc3RhdGljIGlubGluZSBCT09MCmpzX2lzX2FycmF5KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpIHsKICByZXR1cm4gSlNfSXNBcnJheShjdHgsIHZhbHVlKSB8fCBqc19pc190eXBlZGFycmF5KHZhbHVlKTsKfQoKQk9PTCBqc19pc19pbnB1dChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IHZhbHVlKTsKCmludCBqc19wcm9wZW51bV9jbXAoY29uc3Qgdm9pZCogYSwgY29uc3Qgdm9pZCogYiwgdm9pZCogcHRyKTsKQk9PTCBqc19vYmplY3RfZXF1YWxzKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgYSwgSlNWYWx1ZUNvbnN0IGIpOwppbnQ2NF90IGpzX2FycmF5X2xlbmd0aChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IGFycmF5KTsKCnNpemVfdCBqc19hcmd2X2xlbmd0aChjaGFyKiogc3Rydik7CgpjaGFyKioganNfYXJndl9kdXAoSlNDb250ZXh0KiBjdHgsIGNoYXIqKiBzdHJ2KTsKCnZvaWQganNfYXJndl9mcmVlKEpTQ29udGV4dCogY3R4LCBjaGFyKiogc3Rydik7CnZvaWQganNfYXJndl9mcmVlX3J0KEpTUnVudGltZSogcnQsIGNoYXIqKiBzdHJ2KTsKSlNWYWx1ZSBqc19hcmd2X3RvX2FycmF5KEpTQ29udGV4dCogY3R4LCBjaGFyKiogc3Rydik7CkpTVmFsdWUganNfaW50dl90b19hcnJheShKU0NvbnRleHQqIGN0eCwgaW50KiBpbnR2KTsKY2hhcioqIGpzX2FycmF5X3RvX2FyZ3YoSlNDb250ZXh0KiBjdHgsIGludCogYXJnY3AsIEpTVmFsdWVDb25zdCBhcnJheSk7CgpKU1ZhbHVlIGpzX21vZHVsZV9uYW1lKEpTQ29udGV4dCosIEpTVmFsdWVDb25zdCk7CmNoYXIqIGpzX21vZHVsZV9uYW1lc3RyKEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdmFsdWUpOwoKSlNWYWx1ZSBqc19pbnZva2UoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB0aGlzX29iaiwgY29uc3QgY2hhciogbWV0aG9kLCBpbnQgYXJnYywgSlNWYWx1ZUNvbnN0IGFyZ3ZbXSk7CgpzdGF0aWMgaW5saW5lIHNpemVfdApqc19hcnJheWJ1ZmZlcl9sZW5ndGgoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCBidWZmZXIpIHsKICB1aW50OF90KiBwdHI7CiAgc2l6ZV90IGxlbjsKCiAgaWYoSlNfR2V0QXJyYXlCdWZmZXIoY3R4LCAmbGVuLCBidWZmZXIpKQogICAgcmV0dXJuIGxlbjsKICByZXR1cm4gMDsKfQoKc3RhdGljIGlubGluZSBpbnQKanNfZmluZF9jZnVuY3Rpb25fZW50cnkoY29uc3QgSlNDRnVuY3Rpb25MaXN0RW50cnkqIGVudHJpZXMsIHNpemVfdCBuX2VudHJpZXMsIGNvbnN0IGNoYXIqIG5hbWUsIGludCBkZWZfdHlwZSkgewogIHNpemVfdCBpOwogIGZvcihpID0gMDsgaSA8IG5fZW50cmllczsgaSsrKQogICAgaWYoZW50cmllc1tpXS5kZWZfdHlwZSA9PSBkZWZfdHlwZSAmJiAhc3RyY21wKGVudHJpZXNbaV0ubmFtZSwgbmFtZSkpCiAgICAgIHJldHVybiBpOwogIHJldHVybiAtMTsKfQoKc3RhdGljIGlubGluZSBpbnQKanNfZmluZF9jZnVuY3Rpb25fYXRvbSgKICAgIEpTQ29udGV4dCogY3R4LCBjb25zdCBKU0NGdW5jdGlvbkxpc3RFbnRyeSogZW50cmllcywgc2l6ZV90IG5fZW50cmllcywgSlNBdG9tIGF0b20sIGludCBkZWZfdHlwZSkgewogIGNvbnN0IGNoYXIqIG5hbWUgPSBKU19BdG9tVG9DU3RyaW5nKGN0eCwgYXRvbSk7CiAgaW50IGk7CiAgaSA9IGpzX2ZpbmRfY2Z1bmN0aW9uX2VudHJ5KGVudHJpZXMsIG5fZW50cmllcywgbmFtZSwgZGVmX3R5cGUpOwogIEpTX0ZyZWVDU3RyaW5nKGN0eCwgbmFtZSk7CiAgcmV0dXJuIGk7Cn0KCkpTVmFsdWUganNfZGF0ZV9uZXcoSlNDb250ZXh0KiwgSlNWYWx1ZSBhcmcpOwpKU1ZhbHVlIGpzX2RhdGVfZnJvbV9tcyhKU0NvbnRleHQqLCBpbnQ2NF90IG1zKTsKSlNWYWx1ZSBqc19kYXRlX2Zyb21fdGltZV9ucyhKU0NvbnRleHQqLCB0aW1lX3QgdCwgbG9uZyBucyk7CkpTVmFsdWUganNfZGF0ZV9mcm9tX3RpbWVzcGVjKEpTQ29udGV4dCosIGNvbnN0IHN0cnVjdCB0aW1lc3BlYyB0cyk7CmludDY0X3QganNfZGF0ZV9nZXR0aW1lKEpTQ29udGV4dCosIEpTVmFsdWUgYXJnKTsKaW50NjRfdCBqc19kYXRlX3RpbWUoSlNDb250ZXh0KiwgSlNWYWx1ZSBhcmcpOwpzdHJ1Y3QgdGltZXNwZWMganNfZGF0ZV90aW1lc3BlYyhKU0NvbnRleHQqLCBKU1ZhbHVlIGFyZyk7Cgp2b2lkIGpzX2FycmF5YnVmZmVyX2ZyZWV2YWx1ZShKU1J1bnRpbWUqLCB2b2lkKiBvcGFxdWUsIHZvaWQqIHB0cik7CkpTVmFsdWUganNfYXJyYXlidWZmZXJfZnJvbXZhbHVlKEpTQ29udGV4dCosIGNvbnN0IHZvaWQqIHgsIHNpemVfdCBuLCBKU1ZhbHVlIHZhbCk7CgojZW5kaWYgLyogZGVmaW5lZChVVElMU19IKSAqLwoAAAAAAAAAAMVoAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAyF8AAAAAAADTXwAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "tests/test_blob.js",
			"settings":
			{
				"buffer_size": 1715,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					9,
					1,
					"toggle_comment",
					{
						"block": true
					},
					"AgAAABoFAAAAAAAAHAUAAAAAAAAAAAAAvAEAAAAAAAC+AQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAGgUAAAAAAAC8AQAAAAAAAAAAAAAAAAAA"
				],
				[
					15,
					1,
					"cut",
					null,
					"AQAAALwBAAAAAAAAvAEAAAAAAAACAAAALyo",
					"AQAAAAAAAAABAAAAvgEAAAAAAAC8AQAAAAAAAAAAAAAAAPC/"
				],
				[
					18,
					1,
					"paste",
					null,
					"AQAAAOgBAAAAAAAA6gEAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA6AEAAAAAAADoAQAAAAAAAAAAAAAAAPC/"
				],
				[
					30,
					1,
					"toggle_comment",
					{
						"block": true
					},
					"AgAAAJ0BAAAAAAAAnwEAAAAAAAAAAAAAzgAAAAAAAADQAAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAnQEAAAAAAADOAAAAAAAAAAAAAAAAAPC/"
				],
				[
					35,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAAHYAAAAAAAAAdwAAAAAAAAAAAAAAdwAAAAAAAAB4AAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAdgAAAAAAAAB2AAAAAAAAAAAAAAAAAPC/"
				],
				[
					38,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAADYAAAAAAAAANwAAAAAAAAAAAAAANwAAAAAAAAA4AAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAANgAAAAAAAAA2AAAAAAAAAAAAAAAAAAAA"
				],
				[
					49,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAAMQBAAAAAAAAxQEAAAAAAAAAAAAAxQEAAAAAAADGAQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAxAEAAAAAAADEAQAAAAAAAAAAAAAAAPC/"
				],
				[
					52,
					1,
					"doxy_enter",
					null,
					"AQAAAPIBAAAAAAAA8wEAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA8gEAAAAAAADyAQAAAAAAAAAAAAAAAPC/"
				],
				[
					54,
					1,
					"cut",
					null,
					"AQAAAPMBAAAAAAAA8wEAAAAAAAAEAAAALyoKCg",
					"AQAAAAAAAAABAAAA8wEAAAAAAAD3AQAAAAAAAAAAAAAAAAAA"
				],
				[
					58,
					1,
					"insert",
					{
						"characters": "v"
					},
					"AQAAAPcCAAAAAAAA+AIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA9wIAAAAAAAD3AgAAAAAAAAAAAAAAAAAA"
				],
				[
					59,
					1,
					"left_delete",
					null,
					"AQAAAPcCAAAAAAAA9wIAAAAAAAABAAAAdg",
					"AQAAAAAAAAABAAAA+AIAAAAAAAD4AgAAAAAAAAAAAAAAAPC/"
				],
				[
					60,
					1,
					"paste",
					null,
					"AQAAAPcCAAAAAAAA+wIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA9wIAAAAAAAD3AgAAAAAAAAAAAAAAAPC/"
				],
				[
					66,
					1,
					"toggle_comment",
					{
						"block": true
					},
					"AgAAAE4CAAAAAAAAUAIAAAAAAAAAAAAAPAIAAAAAAAA+AgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAPAIAAAAAAABOAgAAAAAAAAAAAAAAAPC/"
				],
				[
					68,
					1,
					"left_delete",
					null,
					"AQAAAHwCAAAAAAAAfAIAAAAAAAABAAAALA",
					"AQAAAAAAAAABAAAAfQIAAAAAAAB9AgAAAAAAAAAAAAAAAPC/"
				],
				[
					70,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAAHMCAAAAAAAAdAIAAAAAAAAAAAAAdAIAAAAAAAB1AgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcwIAAAAAAABzAgAAAAAAAAAAAAAAAE5A"
				],
				[
					72,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAAH4CAAAAAAAAfwIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAfgIAAAAAAAB+AgAAAAAAAP///////+9/"
				],
				[
					79,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAAIYCAAAAAAAAhwIAAAAAAAAAAAAAhwIAAAAAAACIAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAhgIAAAAAAACGAgAAAAAAAAAAAAAAAE5A"
				],
				[
					82,
					1,
					"insert",
					{
						"characters": "i"
					},
					"AgAAAHgAAAAAAAAAeQAAAAAAAAAAAAAAeQAAAAAAAAB5AAAAAAAAAAMAAAAvL2k",
					"AQAAAAAAAAABAAAAewAAAAAAAAB4AAAAAAAAAAAAAAAAAPC/"
				],
				[
					85,
					1,
					"insert",
					{
						"characters": " "
					},
					"AgAAADoCAAAAAAAAOwIAAAAAAAAAAAAAOwIAAAAAAAA7AgAAAAAAAAIAAAAvKg",
					"AQAAAAAAAAABAAAAPAIAAAAAAAA6AgAAAAAAAAAAAAAAAPC/"
				],
				[
					88,
					1,
					"left_delete",
					null,
					"AQAAAE4CAAAAAAAATgIAAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAATgIAAAAAAABPAgAAAAAAAAAAAAAAAPC/"
				],
				[
					89,
					1,
					"left_delete",
					null,
					"AQAAAE0CAAAAAAAATQIAAAAAAAABAAAAKg",
					"AQAAAAAAAAABAAAATgIAAAAAAABOAgAAAAAAAAAAAAAAAPC/"
				],
				[
					92,
					1,
					"left_delete",
					null,
					"AQAAAH8CAAAAAAAAfwIAAAAAAAAEAAAAICAvLw",
					"AQAAAAAAAAABAAAAgwIAAAAAAAB/AgAAAAAAAAAAAAAAAPC/"
				],
				[
					155,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAAKYBAAAAAAAApwEAAAAAAAAAAAAApwEAAAAAAACoAQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAApgEAAAAAAACmAQAAAAAAAAAAAAAAAPC/"
				],
				[
					157,
					1,
					"insert",
					{
						"characters": "c"
					},
					"AQAAAPcCAAAAAAAA+AIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA9wIAAAAAAAD3AgAAAAAAAAAAAAAAAERA"
				],
				[
					158,
					1,
					"left_delete",
					null,
					"AQAAAPcCAAAAAAAA9wIAAAAAAAABAAAAYw",
					"AQAAAAAAAAABAAAA+AIAAAAAAAD4AgAAAAAAAAAAAAAAAPC/"
				],
				[
					159,
					1,
					"insert",
					{
						"characters": "\nconsole.log"
					},
					"DQAAAPcCAAAAAAAA+AIAAAAAAAAAAAAA+AIAAAAAAAD6AgAAAAAAAAAAAAD6AgAAAAAAAPsCAAAAAAAAAAAAAPsCAAAAAAAA/AIAAAAAAAAAAAAA/AIAAAAAAAD9AgAAAAAAAAAAAAD9AgAAAAAAAP4CAAAAAAAAAAAAAP4CAAAAAAAA/wIAAAAAAAAAAAAA/wIAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAEDAAAAAAAAAAAAAAEDAAAAAAAAAgMAAAAAAAAAAAAAAgMAAAAAAAADAwAAAAAAAAAAAAADAwAAAAAAAAQDAAAAAAAAAAAAAAQDAAAAAAAABQMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA9wIAAAAAAAD3AgAAAAAAAAAAAAAAAPC/"
				],
				[
					160,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAAUDAAAAAAAABwMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAABQMAAAAAAAAFAwAAAAAAAAAAAAAAAPC/"
				],
				[
					161,
					1,
					"insert_snippet",
					{
						"contents": "\"$0\""
					},
					"AQAAAAYDAAAAAAAACAMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAABgMAAAAAAAAGAwAAAAAAAAAAAAAAAPC/"
				],
				[
					162,
					1,
					"run_macro_file",
					{
						"file": "res://Packages/Default/Delete Left Right.sublime-macro"
					},
					"AgAAAAYDAAAAAAAABgMAAAAAAAABAAAAIgYDAAAAAAAABgMAAAAAAAABAAAAIg",
					"AQAAAAAAAAABAAAABwMAAAAAAAAHAwAAAAAAAAAAAAAAAPC/"
				],
				[
					163,
					1,
					"insert_snippet",
					{
						"contents": "'$0'"
					},
					"AQAAAAYDAAAAAAAACAMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAABgMAAAAAAAAGAwAAAAAAAAAAAAAAAPC/"
				],
				[
					164,
					1,
					"insert",
					{
						"characters": "blob"
					},
					"BAAAAAcDAAAAAAAACAMAAAAAAAAAAAAACAMAAAAAAAAJAwAAAAAAAAAAAAAJAwAAAAAAAAoDAAAAAAAAAAAAAAoDAAAAAAAACwMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAABwMAAAAAAAAHAwAAAAAAAAAAAAAAAPC/"
				],
				[
					166,
					1,
					"insert",
					{
						"characters": ",blob"
					},
					"BQAAAAwDAAAAAAAADQMAAAAAAAAAAAAADQMAAAAAAAAOAwAAAAAAAAAAAAAOAwAAAAAAAA8DAAAAAAAAAAAAAA8DAAAAAAAAEAMAAAAAAAAAAAAAEAMAAAAAAAARAwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAADAMAAAAAAAAMAwAAAAAAAAAAAAAAAPC/"
				],
				[
					168,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAABIDAAAAAAAAEwMAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAEgMAAAAAAAASAwAAAAAAAAAAAAAAAPC/"
				],
				[
					171,
					2,
					"left_delete",
					null,
					"AgAAABUDAAAAAAAAFQMAAAAAAAABAAAAKhQDAAAAAAAAFAMAAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAAFgMAAAAAAAAWAwAAAAAAAAAAAAAA4HBA"
				],
				[
					175,
					2,
					"left_delete",
					null,
					"AgAAAEMFAAAAAAAAQwUAAAAAAAABAAAAL0IFAAAAAAAAQgUAAAAAAAABAAAAKg",
					"AQAAAAAAAAABAAAARAUAAAAAAABEBQAAAAAAAAAAAAAAAPC/"
				],
				[
					177,
					1,
					"run_macro_file",
					{
						"file": "res://Packages/Default/Add Line in Braces.sublime-macro"
					},
					"BgAAAEEFAAAAAAAAQgUAAAAAAAAAAAAAQgUAAAAAAABEBQAAAAAAAAAAAABEBQAAAAAAAEUFAAAAAAAAAAAAAEUFAAAAAAAARwUAAAAAAAAAAAAAQgUAAAAAAABCBQAAAAAAAAIAAAAgIEIFAAAAAAAARgUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAQQUAAAAAAABBBQAAAAAAAAAAAAAAAPC/"
				],
				[
					178,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AwAAAEYFAAAAAAAARwUAAAAAAAAAAAAARwUAAAAAAABLBQAAAAAAAAAAAABCBQAAAAAAAEIFAAAAAAAABAAAACAgICA",
					"AQAAAAAAAAABAAAARgUAAAAAAABGBQAAAAAAAAAAAAAAAPC/"
				],
				[
					179,
					1,
					"insert",
					{
						"characters": "bl"
					},
					"AgAAAEcFAAAAAAAASAUAAAAAAAAAAAAASAUAAAAAAABJBQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAARwUAAAAAAABHBQAAAAAAAAAAAAAAAPC/"
				],
				[
					180,
					2,
					"left_delete",
					null,
					"AgAAAEgFAAAAAAAASAUAAAAAAAABAAAAbEcFAAAAAAAARwUAAAAAAAABAAAAYg",
					"AQAAAAAAAAABAAAASQUAAAAAAABJBQAAAAAAAAAAAAAAAPC/"
				],
				[
					181,
					1,
					"insert",
					{
						"characters": "s"
					},
					"AQAAAEcFAAAAAAAASAUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAARwUAAAAAAABHBQAAAAAAAAAAAAAAAPC/"
				],
				[
					182,
					1,
					"left_delete",
					null,
					"AQAAAEcFAAAAAAAARwUAAAAAAAABAAAAcw",
					"AQAAAAAAAAABAAAASAUAAAAAAABIBQAAAAAAAAAAAAAAAPC/"
				],
				[
					183,
					1,
					"insert",
					{
						"characters": "sl"
					},
					"AgAAAEcFAAAAAAAASAUAAAAAAAAAAAAASAUAAAAAAABJBQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAARwUAAAAAAABHBQAAAAAAAAAAAAAAAPC/"
				],
				[
					184,
					1,
					"insert",
					{
						"characters": " ="
					},
					"AgAAAEkFAAAAAAAASgUAAAAAAAAAAAAASgUAAAAAAABLBQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAASQUAAAAAAABJBQAAAAAAAAAAAAAAAPC/"
				],
				[
					185,
					1,
					"insert",
					{
						"characters": " new"
					},
					"BAAAAEsFAAAAAAAATAUAAAAAAAAAAAAATAUAAAAAAABNBQAAAAAAAAAAAABNBQAAAAAAAE4FAAAAAAAAAAAAAE4FAAAAAAAATwUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAASwUAAAAAAABLBQAAAAAAAAAAAAAAAPC/"
				],
				[
					186,
					1,
					"insert",
					{
						"characters": " Blob"
					},
					"BQAAAE8FAAAAAAAAUAUAAAAAAAAAAAAAUAUAAAAAAABRBQAAAAAAAAAAAABRBQAAAAAAAFIFAAAAAAAAAAAAAFIFAAAAAAAAUwUAAAAAAAAAAAAAUwUAAAAAAABUBQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATwUAAAAAAABPBQAAAAAAAAAAAAAAAPC/"
				],
				[
					187,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAFQFAAAAAAAAVgUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAVAUAAAAAAABUBQAAAAAAAAAAAAAAAPC/"
				],
				[
					188,
					1,
					"insert_snippet",
					{
						"contents": "[$0]"
					},
					"AQAAAFUFAAAAAAAAVwUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAVQUAAAAAAABVBQAAAAAAAAAAAAAAAPC/"
				],
				[
					189,
					1,
					"insert",
					{
						"characters": "sl,"
					},
					"AwAAAFYFAAAAAAAAVwUAAAAAAAAAAAAAVwUAAAAAAABYBQAAAAAAAAAAAABYBQAAAAAAAFkFAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAVgUAAAAAAABWBQAAAAAAAAAAAAAAAPC/"
				],
				[
					190,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAFkFAAAAAAAAWgUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAWQUAAAAAAABZBQAAAAAAAAAAAAAAAPC/"
				],
				[
					191,
					1,
					"insert",
					{
						"characters": "misc.toArrayBu"
					},
					"DgAAAFoFAAAAAAAAWwUAAAAAAAAAAAAAWwUAAAAAAABcBQAAAAAAAAAAAABcBQAAAAAAAF0FAAAAAAAAAAAAAF0FAAAAAAAAXgUAAAAAAAAAAAAAXgUAAAAAAABfBQAAAAAAAAAAAABfBQAAAAAAAGAFAAAAAAAAAAAAAGAFAAAAAAAAYQUAAAAAAAAAAAAAYQUAAAAAAABiBQAAAAAAAAAAAABiBQAAAAAAAGMFAAAAAAAAAAAAAGMFAAAAAAAAZAUAAAAAAAAAAAAAZAUAAAAAAABlBQAAAAAAAAAAAABlBQAAAAAAAGYFAAAAAAAAAAAAAGYFAAAAAAAAZwUAAAAAAAAAAAAAZwUAAAAAAABoBQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAWgUAAAAAAABaBQAAAAAAAAAAAAAAAPC/"
				],
				[
					192,
					1,
					"insert",
					{
						"characters": "ffer"
					},
					"BAAAAGgFAAAAAAAAaQUAAAAAAAAAAAAAaQUAAAAAAABqBQAAAAAAAAAAAABqBQAAAAAAAGsFAAAAAAAAAAAAAGsFAAAAAAAAbAUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAaAUAAAAAAABoBQAAAAAAAAAAAAAAAPC/"
				],
				[
					193,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAGwFAAAAAAAAbgUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbAUAAAAAAABsBQAAAAAAAAAAAAAAAPC/"
				],
				[
					194,
					1,
					"insert_snippet",
					{
						"contents": "'$0'"
					},
					"AQAAAG0FAAAAAAAAbwUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbQUAAAAAAABtBQAAAAAAAAAAAAAAAPC/"
				],
				[
					195,
					1,
					"run_macro_file",
					{
						"file": "res://Packages/Default/Delete Left Right.sublime-macro"
					},
					"AgAAAG0FAAAAAAAAbQUAAAAAAAABAAAAJ20FAAAAAAAAbQUAAAAAAAABAAAAJw",
					"AQAAAAAAAAABAAAAbgUAAAAAAABuBQAAAAAAAAAAAAAAAPC/"
				],
				[
					196,
					1,
					"insert_snippet",
					{
						"contents": "`$0`"
					},
					"AQAAAG0FAAAAAAAAbwUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbQUAAAAAAABtBQAAAAAAAAAAAAAAAPC/"
				],
				[
					197,
					1,
					"insert",
					{
						"characters": "line"
					},
					"BAAAAG4FAAAAAAAAbwUAAAAAAAAAAAAAbwUAAAAAAABwBQAAAAAAAAAAAABwBQAAAAAAAHEFAAAAAAAAAAAAAHEFAAAAAAAAcgUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAbgUAAAAAAABuBQAAAAAAAAAAAAAAAPC/"
				],
				[
					198,
					1,
					"insert",
					{
						"characters": " #${i}"
					},
					"BgAAAHIFAAAAAAAAcwUAAAAAAAAAAAAAcwUAAAAAAAB0BQAAAAAAAAAAAAB0BQAAAAAAAHUFAAAAAAAAAAAAAHUFAAAAAAAAdgUAAAAAAAAAAAAAdgUAAAAAAAB3BQAAAAAAAAAAAAB3BQAAAAAAAHgFAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAcgUAAAAAAAByBQAAAAAAAAAAAAAAAPC/"
				],
				[
					199,
					1,
					"insert",
					{
						"characters": "\\n"
					},
					"AgAAAHgFAAAAAAAAeQUAAAAAAAAAAAAAeQUAAAAAAAB6BQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAeAUAAAAAAAB4BQAAAAAAAAAAAAAAAPC/"
				],
				[
					201,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAAH4FAAAAAAAAfwUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAfgUAAAAAAAB+BQAAAAAAAAAAAAAAAPC/"
				],
				[
					202,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAAH8FAAAAAAAAgAUAAAAAAAAAAAAAgAUAAAAAAACEBQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAfwUAAAAAAAB/BQAAAAAAAAAAAAAAAPC/"
				],
				[
					205,
					1,
					"insert",
					{
						"characters": "console.log"
					},
					"CwAAAIQFAAAAAAAAhQUAAAAAAAAAAAAAhQUAAAAAAACGBQAAAAAAAAAAAACGBQAAAAAAAIcFAAAAAAAAAAAAAIcFAAAAAAAAiAUAAAAAAAAAAAAAiAUAAAAAAACJBQAAAAAAAAAAAACJBQAAAAAAAIoFAAAAAAAAAAAAAIoFAAAAAAAAiwUAAAAAAAAAAAAAiwUAAAAAAACMBQAAAAAAAAAAAACMBQAAAAAAAI0FAAAAAAAAAAAAAI0FAAAAAAAAjgUAAAAAAAAAAAAAjgUAAAAAAACPBQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAhAUAAAAAAACEBQAAAAAAAAAAAAAAAERA"
				],
				[
					206,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAI8FAAAAAAAAkQUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAjwUAAAAAAACPBQAAAAAAAAAAAAAAAPC/"
				],
				[
					207,
					1,
					"insert_snippet",
					{
						"contents": "`$0`"
					},
					"AQAAAJAFAAAAAAAAkgUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAkAUAAAAAAACQBQAAAAAAAAAAAAAAAPC/"
				],
				[
					208,
					1,
					"insert",
					{
						"characters": "sl[${i}"
					},
					"BwAAAJEFAAAAAAAAkgUAAAAAAAAAAAAAkgUAAAAAAACTBQAAAAAAAAAAAACTBQAAAAAAAJQFAAAAAAAAAAAAAJQFAAAAAAAAlQUAAAAAAAAAAAAAlQUAAAAAAACWBQAAAAAAAAAAAACWBQAAAAAAAJcFAAAAAAAAAAAAAJcFAAAAAAAAmAUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAkQUAAAAAAACRBQAAAAAAAAAAAAAAAPC/"
				],
				[
					209,
					1,
					"insert",
					{
						"characters": "]"
					},
					"AQAAAJgFAAAAAAAAmQUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmAUAAAAAAACYBQAAAAAAAAAAAAAAAPC/"
				],
				[
					211,
					1,
					"insert",
					{
						"characters": ",m"
					},
					"AgAAAJoFAAAAAAAAmwUAAAAAAAAAAAAAmwUAAAAAAACcBQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmgUAAAAAAACaBQAAAAAAAAAAAAAAAPC/"
				],
				[
					212,
					2,
					"left_delete",
					null,
					"AgAAAJsFAAAAAAAAmwUAAAAAAAABAAAAbZoFAAAAAAAAmgUAAAAAAAABAAAALA",
					"AQAAAAAAAAABAAAAnAUAAAAAAACcBQAAAAAAAAAAAAAAAPC/"
				],
				[
					213,
					1,
					"insert",
					{
						"characters": ",sl"
					},
					"AwAAAJoFAAAAAAAAmwUAAAAAAAAAAAAAmwUAAAAAAACcBQAAAAAAAAAAAACcBQAAAAAAAJ0FAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmgUAAAAAAACaBQAAAAAAAAAAAAAAAPC/"
				],
				[
					215,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAAJ4FAAAAAAAAnwUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAngUAAAAAAACeBQAAAAAAAAAAAAAAAPC/"
				],
				[
					218,
					1,
					"insert",
					{
						"characters": "\nlet"
					},
					"BQAAACIFAAAAAAAAIwUAAAAAAAAAAAAAIwUAAAAAAAAlBQAAAAAAAAAAAAAlBQAAAAAAACYFAAAAAAAAAAAAACYFAAAAAAAAJwUAAAAAAAAAAAAAJwUAAAAAAAAoBQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAIgUAAAAAAAAiBQAAAAAAAP///////+9/"
				],
				[
					219,
					1,
					"insert",
					{
						"characters": " a="
					},
					"AwAAACgFAAAAAAAAKQUAAAAAAAAAAAAAKQUAAAAAAAAqBQAAAAAAAAAAAAAqBQAAAAAAACsFAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAKAUAAAAAAAAoBQAAAAAAAAAAAAAAAPC/"
				],
				[
					220,
					2,
					"left_delete",
					null,
					"AgAAACoFAAAAAAAAKgUAAAAAAAABAAAAPSkFAAAAAAAAKQUAAAAAAAABAAAAYQ",
					"AQAAAAAAAAABAAAAKwUAAAAAAAArBQAAAAAAAAAAAAAAAPC/"
				],
				[
					221,
					1,
					"insert",
					{
						"characters": "blopbs"
					},
					"BgAAACkFAAAAAAAAKgUAAAAAAAAAAAAAKgUAAAAAAAArBQAAAAAAAAAAAAArBQAAAAAAACwFAAAAAAAAAAAAACwFAAAAAAAALQUAAAAAAAAAAAAALQUAAAAAAAAuBQAAAAAAAAAAAAAuBQAAAAAAAC8FAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAKQUAAAAAAAApBQAAAAAAAAAAAAAAAPC/"
				],
				[
					222,
					3,
					"left_delete",
					null,
					"AwAAAC4FAAAAAAAALgUAAAAAAAABAAAAcy0FAAAAAAAALQUAAAAAAAABAAAAYiwFAAAAAAAALAUAAAAAAAABAAAAcA",
					"AQAAAAAAAAABAAAALwUAAAAAAAAvBQAAAAAAAAAAAAAAAPC/"
				],
				[
					223,
					1,
					"insert",
					{
						"characters": "bs="
					},
					"AwAAACwFAAAAAAAALQUAAAAAAAAAAAAALQUAAAAAAAAuBQAAAAAAAAAAAAAuBQAAAAAAAC8FAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAALAUAAAAAAAAsBQAAAAAAAAAAAAAAAPC/"
				],
				[
					224,
					1,
					"insert_snippet",
					{
						"contents": "[$0]"
					},
					"AQAAAC8FAAAAAAAAMQUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAALwUAAAAAAAAvBQAAAAAAAAAAAAAAAPC/"
				],
				[
					226,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAADEFAAAAAAAAMgUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAMQUAAAAAAAAxBQAAAAAAAAAAAAAAAPC/"
				],
				[
					232,
					1,
					"insert",
					{
						"characters": "blobs[i]"
					},
					"CAAAAFwFAAAAAAAAXQUAAAAAAAAAAAAAXQUAAAAAAABeBQAAAAAAAAAAAABeBQAAAAAAAF8FAAAAAAAAAAAAAF8FAAAAAAAAYAUAAAAAAAAAAAAAYAUAAAAAAABhBQAAAAAAAAAAAABhBQAAAAAAAGIFAAAAAAAAAAAAAGIFAAAAAAAAYwUAAAAAAAAAAAAAYwUAAAAAAABkBQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAXAUAAAAAAABcBQAAAAAAAAAAAAAAAPC/"
				],
				[
					233,
					1,
					"insert",
					{
						"characters": " ="
					},
					"AgAAAGQFAAAAAAAAZQUAAAAAAAAAAAAAZQUAAAAAAABmBQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAZAUAAAAAAABkBQAAAAAAAAAAAAAAAPC/"
				],
				[
					234,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAGYFAAAAAAAAZwUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAZgUAAAAAAABmBQAAAAAAAAAAAAAAAPC/"
				],
				[
					239,
					1,
					"insert",
					{
						"characters": ".-"
					},
					"AgAAALgFAAAAAAAAuQUAAAAAAAAAAAAAuQUAAAAAAAC6BQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAuAUAAAAAAAC4BQAAAAAAAAAAAAAAAPC/"
				],
				[
					240,
					1,
					"left_delete",
					null,
					"AQAAALkFAAAAAAAAuQUAAAAAAAABAAAALQ",
					"AQAAAAAAAAABAAAAugUAAAAAAAC6BQAAAAAAAAAAAAAAAPC/"
				],
				[
					241,
					1,
					"insert",
					{
						"characters": "text"
					},
					"BAAAALkFAAAAAAAAugUAAAAAAAAAAAAAugUAAAAAAAC7BQAAAAAAAAAAAAC7BQAAAAAAALwFAAAAAAAAAAAAALwFAAAAAAAAvQUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAuQUAAAAAAAC5BQAAAAAAAAAAAAAAAPC/"
				],
				[
					242,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAL0FAAAAAAAAvwUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAvQUAAAAAAAC9BQAAAAAAAAAAAAAAAPC/"
				],
				[
					250,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAALkCAAAAAAAAugIAAAAAAAAAAAAAugIAAAAAAAC+AgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAuQIAAAAAAAC5AgAAAAAAAP///////+9/"
				],
				[
					251,
					3,
					"left_delete",
					null,
					"AwAAALwCAAAAAAAAvAIAAAAAAAACAAAAICC6AgAAAAAAALoCAAAAAAAAAgAAACAguQIAAAAAAAC5AgAAAAAAAAEAAAAK",
					"AQAAAAAAAAABAAAAvgIAAAAAAAC+AgAAAAAAAAAAAAAAAPC/"
				],
				[
					252,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAALkCAAAAAAAAugIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAuQIAAAAAAAC5AgAAAAAAAAAAAAAAAPC/"
				],
				[
					253,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAALoCAAAAAAAAuwIAAAAAAAAAAAAAuwIAAAAAAAC/AgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAugIAAAAAAAC6AgAAAAAAAAAAAAAAAPC/"
				],
				[
					254,
					1,
					"insert",
					{
						"characters": "new"
					},
					"AwAAAL8CAAAAAAAAwAIAAAAAAAAAAAAAwAIAAAAAAADBAgAAAAAAAAAAAADBAgAAAAAAAMICAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAvwIAAAAAAAC/AgAAAAAAAAAAAAAAAPC/"
				],
				[
					255,
					1,
					"insert",
					{
						"characters": " Uin8tA"
					},
					"BwAAAMICAAAAAAAAwwIAAAAAAAAAAAAAwwIAAAAAAADEAgAAAAAAAAAAAADEAgAAAAAAAMUCAAAAAAAAAAAAAMUCAAAAAAAAxgIAAAAAAAAAAAAAxgIAAAAAAADHAgAAAAAAAAAAAADHAgAAAAAAAMgCAAAAAAAAAAAAAMgCAAAAAAAAyQIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAwgIAAAAAAADCAgAAAAAAAAAAAAAAAPC/"
				],
				[
					256,
					3,
					"left_delete",
					null,
					"AwAAAMgCAAAAAAAAyAIAAAAAAAABAAAAQccCAAAAAAAAxwIAAAAAAAABAAAAdMYCAAAAAAAAxgIAAAAAAAABAAAAOA",
					"AQAAAAAAAAABAAAAyQIAAAAAAADJAgAAAAAAAAAAAAAAAPC/"
				],
				[
					257,
					1,
					"insert",
					{
						"characters": "tA"
					},
					"AgAAAMYCAAAAAAAAxwIAAAAAAAAAAAAAxwIAAAAAAADIAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAxgIAAAAAAADGAgAAAAAAAAAAAAAAAPC/"
				],
				[
					258,
					1,
					"left_delete",
					null,
					"AQAAAMcCAAAAAAAAxwIAAAAAAAABAAAAQQ",
					"AQAAAAAAAAABAAAAyAIAAAAAAADIAgAAAAAAAAAAAAAAAPC/"
				],
				[
					259,
					1,
					"insert",
					{
						"characters": "8Array"
					},
					"BgAAAMcCAAAAAAAAyAIAAAAAAAAAAAAAyAIAAAAAAADJAgAAAAAAAAAAAADJAgAAAAAAAMoCAAAAAAAAAAAAAMoCAAAAAAAAywIAAAAAAAAAAAAAywIAAAAAAADMAgAAAAAAAAAAAADMAgAAAAAAAM0CAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAxwIAAAAAAADHAgAAAAAAAAAAAAAAAPC/"
				],
				[
					260,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAM0CAAAAAAAAzwIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAzQIAAAAAAADNAgAAAAAAAAAAAAAAAPC/"
				],
				[
					261,
					1,
					"insert_snippet",
					{
						"contents": "[$0]"
					},
					"AQAAAM4CAAAAAAAA0AIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAzgIAAAAAAADOAgAAAAAAAAAAAAAAAPC/"
				],
				[
					262,
					1,
					"insert",
					{
						"characters": "0xa"
					},
					"AwAAAM8CAAAAAAAA0AIAAAAAAAAAAAAA0AIAAAAAAADRAgAAAAAAAAAAAADRAgAAAAAAANICAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAzwIAAAAAAADPAgAAAAAAAAAAAAAAAPC/"
				],
				[
					264,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAANQCAAAAAAAA1QIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA1AIAAAAAAADUAgAAAAAAAAAAAAAAAPC/"
				],
				[
					265,
					1,
					"left_delete",
					null,
					"AQAAANQCAAAAAAAA1AIAAAAAAAABAAAAOw",
					"AQAAAAAAAAABAAAA1QIAAAAAAADVAgAAAAAAAAAAAAAAAPC/"
				],
				[
					269,
					1,
					"cut",
					null,
					"AQAAALkCAAAAAAAAuQIAAAAAAAAcAAAALAogICAgbmV3IFVpbnQ4QXJyYXkoWzB4YV0pCg",
					"AQAAAAAAAAABAAAA1QIAAAAAAAC5AgAAAAAAAAAAAAAAAPC/"
				],
				[
					272,
					1,
					"paste",
					null,
					"AQAAACUCAAAAAAAAQQIAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAJQIAAAAAAAAlAgAAAAAAAAAAAAAAAPC/"
				],
				[
					273,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAACLBgAAaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnOwppbXBvcnQgKiBhcyBzdGQgZnJvbSAnc3RkJzsKLy9pbXBvcnQgeyBDb25zb2xlIH0gZnJvbSAnY29uc29sZSc7CmltcG9ydCB7IEJsb2IgfSBmcm9tICdibG9iJzsKaW1wb3J0ICogYXMgbWlzYyBmcm9tICdtaXNjJzsKCigndXNlIHN0cmljdCcpOwooJ3VzZSBtYXRoJyk7CgpmdW5jdGlvbiBtYWluKC4uLmFyZ3MpIHsKIC8qIGdsb2JhbFRoaXMuY29uc29sZSA9IG5ldyBDb25zb2xlKHsKICAgIGluc3BlY3RPcHRpb25zOiB7CiAgICAgIGNvbG9yczogdHJ1ZSwKICAgICAgZGVwdGg6IDgsCiAgICAgIG1heFN0cmluZ0xlbmd0aDogSW5maW5pdHksCiAgICAgIG1heEFycmF5TGVuZ3RoOiAyNTYsCiAgICAgIGNvbXBhY3Q6IDIsCiAgICAgIHNob3dIaWRkZW46IGZhbHNlCiAgICB9CiAgfSk7Ki8KICAvL2NvbnNvbGUubG9nKCdCbG9iJywgQmxvYik7CgovLyAgbGV0IGNoaWxkQmxvYiA9IG5ldyBCbG9iKFsnXG54XG55XG56XG4nXSk7CiAgbGV0IGJsb2IgPSBuZXcgQmxvYigKICAgIFsKICAgICAgJzxodG1sPjwvaHRtbD4nLAogICAgbmV3IFVpbnQ4QXJyYXkoWzB4YV0pCiwKICAgICAgbmV3IFVpbnQ4QXJyYXkoIG1pc2MudG9BcnJheUJ1ZmZlcignQkxBSCBibGFoIEJMQUgnKSwgNSwgNCksCiAgICAgIC8vY2hpbGRCbG9iLAogICAgbmV3IERhdGFWaWV3KG1pc2MudG9BcnJheUJ1ZmZlcignVEVTVCB0ZXN0IFRFU1QnKSwgNSwgNCkgICAgXSwKICAgIHsgdHlwZTogJ3RleHQvaHRtbCcsIGVuZGluZ3M6ICd0cmFuc3BhcmVudCcgfQogICk7CiAgY29uc29sZS5sb2coJ2Jsb2InLGJsb2IpOwoKCiAgY29uc29sZS5sb2coJ2Jsb2InLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmxvYikpOwogIGNvbnNvbGUubG9nKCdibG9iJywgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJsb2IpKSk7CiAgY29uc29sZS5sb2coJ2Jsb2InLCBibG9iKTsKICBjb25zb2xlLmxvZygnYmxvYi5zaXplJywgYmxvYi5zaXplKTsKICBjb25zb2xlLmxvZygnYmxvYi50eXBlJywgYmxvYi50eXBlKTsKICBjb25zb2xlLmxvZygnYmxvYi50ZXh0KCknLCBibG9iLnRleHQoKSk7CiAgY29uc29sZS5sb2coJ2Jsb2IuYXJyYXlCdWZmZXIoKScsIGJsb2IuYXJyYXlCdWZmZXIoKSk7CiAgbGV0IHNsID0gYmxvYi5zbGljZSgxLCAtMTAsICd0ZXh0L3BsYWluJyk7CiAgY29uc29sZS5sb2coJ2Jsb2Iuc2xpY2UoMSknLCBzbCk7CiAgY29uc29sZS5sb2coJ3NsLmFycmF5QnVmZmVyKCknLCBzbC5hcnJheUJ1ZmZlcigpKTsKICBjb25zb2xlLmxvZygnc2wudGV4dCgpJywgbWlzYy5lc2NhcGUoc2wudGV4dCgpKSk7CiAgbGV0IGJsb2JzPVtdOwogIGZvcihsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHsKCiAgICBzbCA9IGJsb2JzW2ldID0gbmV3IEJsb2IoW3NsLCBtaXNjLnRvQXJyYXlCdWZmZXIoYGxpbmUgIyR7aX1cbmApXSk7CiAgICBjb25zb2xlLmxvZyhgc2xbJHtpfV1gLHNsLnRleHQoKSk7CiAgfQp9Cgp0cnkgewogIG1haW4oLi4uc2NyaXB0QXJncy5zbGljZSgxKSk7Cn0gY2F0Y2goZXJyb3IpIHsKICBjb25zb2xlLmxvZyhgRkFJTDogJHtlcnJvci5tZXNzYWdlfVxuJHtlcnJvci5zdGFja31gKTsKICBzdGQuZXhpdCgxKTsKfSBmaW5hbGx5IHsKICBjb25zb2xlLmxvZygnU1VDQ0VTUycpOwp9CgAAAAAAAAAAkwYAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAQQIAAAAAAABBAgAAAAAAAAAAAAAAAPC/"
				],
				[
					276,
					1,
					"insert",
					{
						"characters": "\\t"
					},
					"AgAAACcCAAAAAAAAKAIAAAAAAAAAAAAAKAIAAAAAAAApAgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAJwIAAAAAAAAnAgAAAAAAAAAAAAAAAPC/"
				],
				[
					287,
					1,
					"insert",
					{
						"characters": "14"
					},
					"AwAAAKUEAAAAAAAApgQAAAAAAAAAAAAApgQAAAAAAACmBAAAAAAAAAMAAAAtMTCmBAAAAAAAAKcEAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAApQQAAAAAAACoBAAAAAAAAAAAAAAAAPC/"
				],
				[
					290,
					2,
					"left_delete",
					null,
					"AgAAACgCAAAAAAAAKAIAAAAAAAABAAAAdCcCAAAAAAAAJwIAAAAAAAABAAAAXA",
					"AQAAAAAAAAABAAAAKQIAAAAAAAApAgAAAAAAAAAAAAAAAPC/"
				],
				[
					294,
					1,
					"insert",
					{
						"characters": "misc.ex"
					},
					"BwAAANgFAAAAAAAA2QUAAAAAAAAAAAAA2QUAAAAAAADaBQAAAAAAAAAAAADaBQAAAAAAANsFAAAAAAAAAAAAANsFAAAAAAAA3AUAAAAAAAAAAAAA3AUAAAAAAADdBQAAAAAAAAAAAADdBQAAAAAAAN4FAAAAAAAAAAAAAN4FAAAAAAAA3wUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA2AUAAAAAAADYBQAAAAAAAAAAAAAAAPC/"
				],
				[
					295,
					1,
					"left_delete",
					null,
					"AQAAAN4FAAAAAAAA3gUAAAAAAAABAAAAeA",
					"AQAAAAAAAAABAAAA3wUAAAAAAADfBQAAAAAAAAAAAAAAAPC/"
				],
				[
					296,
					1,
					"insert",
					{
						"characters": "scape("
					},
					"BgAAAN4FAAAAAAAA3wUAAAAAAAAAAAAA3wUAAAAAAADgBQAAAAAAAAAAAADgBQAAAAAAAOEFAAAAAAAAAAAAAOEFAAAAAAAA4gUAAAAAAAAAAAAA4gUAAAAAAADjBQAAAAAAAAAAAADjBQAAAAAAAOQFAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA3gUAAAAAAADeBQAAAAAAAAAAAAAAAPC/"
				],
				[
					300,
					1,
					"insert",
					{
						"characters": ")"
					},
					"AQAAAO4FAAAAAAAA7wUAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA7gUAAAAAAADuBQAAAAAAAAAAAAAAAPC/"
				],
				[
					303,
					2,
					"left_delete",
					null,
					"AgAAADcAAAAAAAAANwAAAAAAAAABAAAALzYAAAAAAAAANgAAAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAAOAAAAAAAAAA4AAAAAAAAAAAAAAAAAPC/"
				],
				[
					308,
					2,
					"left_delete",
					null,
					"AgAAANAAAAAAAAAA0AAAAAAAAAABAAAAKs8AAAAAAAAAzwAAAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAA0QAAAAAAAADRAAAAAAAAAAAAAAAAAPC/"
				],
				[
					311,
					1,
					"left_delete",
					null,
					"AQAAAJ4BAAAAAAAAngEAAAAAAAACAAAAKi8",
					"AQAAAAAAAAABAAAAngEAAAAAAACgAQAAAAAAAAAAAAAAAPC/"
				],
				[
					314,
					2,
					"left_delete",
					null,
					"AgAAAKIBAAAAAAAAogEAAAAAAAABAAAAL6EBAAAAAAAAoQEAAAAAAAABAAAALw",
					"AQAAAAAAAAABAAAAowEAAAAAAACjAQAAAAAAAAAAAAAAAPC/"
				],
				[
					317,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAAJIBAAAAAAAAkwEAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAkgEAAAAAAACSAQAAAAAAAAAAAAAAAPC/"
				],
				[
					318,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAAJMBAAAAAAAAlAEAAAAAAAAAAAAAlAEAAAAAAACaAQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAkwEAAAAAAACTAQAAAAAAAAAAAAAAAPC/"
				],
				[
					319,
					1,
					"paste",
					null,
					"AQAAAJoBAAAAAAAApwEAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmgEAAAAAAACaAQAAAAAAAAAAAAAAAPC/"
				],
				[
					320,
					1,
					"insert",
					{
						"characters": ":"
					},
					"AQAAAKcBAAAAAAAAqAEAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAApwEAAAAAAACnAQAAAAAAAAAAAAAAAPC/"
				],
				[
					321,
					1,
					"insert",
					{
						"characters": " false"
					},
					"BgAAAKgBAAAAAAAAqQEAAAAAAAAAAAAAqQEAAAAAAACqAQAAAAAAAAAAAACqAQAAAAAAAKsBAAAAAAAAAAAAAKsBAAAAAAAArAEAAAAAAAAAAAAArAEAAAAAAACtAQAAAAAAAAAAAACtAQAAAAAAAK4BAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAqAEAAAAAAACoAQAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "CMakeLists.txt",
			"redo_stack":
			[
				[
					9,
					1,
					"insert",
					{
						"characters": "\t"
					},
					"AQAAAMcKAAAAAAAAxwoAAAAAAAACAAAAICA",
					"AQAAAAAAAAABAAAAyQoAAAAAAADJCgAAAAAAAAAAAAAAAPC/"
				]
			],
			"settings":
			{
				"buffer_size": 10207,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					5,
					1,
					"cut",
					null,
					"AQAAAOkMAAAAAAAA6QwAAAAAAAAZAAAAICR7c3RyaW5nZGVjb2Rlcl9TT1VSQ0VTfQ",
					"AQAAAAAAAAABAAAA6QwAAAAAAAACDQAAAAAAAAAAAAAAAPC/"
				],
				[
					6,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAAyKgAAcHJvamVjdChtb2R1bGVzIEMpCgpjbWFrZV9taW5pbXVtX3JlcXVpcmVkKFZFUlNJT04gMy4yKQoKaW5jbHVkZSgke0NNQUtFX0NVUlJFTlRfU09VUkNFX0RJUn0vY21ha2UvZnVuY3Rpb25zLmNtYWtlKQppbmNsdWRlKCR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS9jbWFrZS9jaGVjay1mbGFncy5jbWFrZSkKaW5jbHVkZSgke0NNQUtFX0NVUlJFTlRfU09VUkNFX0RJUn0vY21ha2UvUXVpY2tKU01vZHVsZS5jbWFrZSkKaW5jbHVkZSgke0NNQUtFX0NVUlJFTlRfU09VUkNFX0RJUn0vY21ha2UvRmluZFF1aWNrSlMuY21ha2UpCgpvcHRpb24oQlVJTERfUElHUElPICJCdWlsZCBwaWdwaW8gbGlicmFyeSIgT0ZGKQoKZmluZF9xdWlja2pzKCkKCmlmKEJVSUxEX1BJR1BJTykKICBpbmNsdWRlKEV4dGVybmFsUHJvamVjdCkKICBFeHRlcm5hbFByb2plY3RfQWRkKAogICAgcGlncGlvCiAgICBTT1VSQ0VfRElSICR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS9waWdwaW8KICAgIEJJTkFSWV9ESVIgJHtDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVJ9L3BpZ3BpbwogICAgQ01BS0VfQ0FDSEVfQVJHUwogICAgICAiLURDTUFLRV9DX0NPTVBJTEVSOkZJTEVQQVRIPSR7Q01BS0VfQ19DT01QSUxFUn0iCiAgICAgICItRENNQUtFX1NZU1JPT1Q6UEFUSD0ke0NNQUtFX1NZU1JPT1R9IgogICAgICAiLURDTUFLRV9UT09MQ0hBSU5fRklMRTpGSUxFUEFUSD0ke0NNQUtFX1RPT0xDSEFJTl9GSUxFfSIKICAgICAgIi1EQ01BS0VfQ19GTEFHUzpTVFJJTkc9LXciCiAgICAgICItRENNQUtFX1ZFUkJPU0VfTUFLRUZJTEU6Qk9PTD0ke0NNQUtFX1ZFUkJPU0VfTUFLRUZJTEV9IgogICAgICAiLURDTUFLRV9CVUlMRF9UWVBFOlNUUklORz0ke0NNQUtFX0JVSUxEX1RZUEV9IgogICAgQ01BS0VfQ0FDSEVfREVGQVVMVF9BUkdTCiAgICAgIi1EQlVJTERfU0hBUkVEX0xJQlM6Qk9PTD1GQUxTRSIpCgogIGxpbmtfZGlyZWN0b3JpZXMoIiR7Q01BS0VfQ1VSUkVOVF9CSU5BUllfRElSfS9waWdwaW8iKQoKZWxzZShCVUlMRF9QSUdQSU8pCiAgaW5jbHVkZSgke0NNQUtFX0NVUlJFTlRfU09VUkNFX0RJUn0vY21ha2UvRmluZHBpZ3Bpby5jbWFrZSkKCmVuZGlmKEJVSUxEX1BJR1BJTykKCmluY2x1ZGUoRmluZExpYkFyY2hpdmUpCgpsaW5rX2RpcmVjdG9yaWVzKCR7Q01BS0VfQ1VSUkVOVF9CSU5BUllfRElSfSkKCmlmKE5PVCBMaWJBcmNoaXZlX0ZPVU5EKQogIG1lc3NhZ2UoRVJST1IgImxpYmFyY2hpdmUgbm90IGZvdW5kIikKZW5kaWYoTk9UIExpYkFyY2hpdmVfRk9VTkQpCgpzZXQoUVVJQ0tKU19NT0RVTEVTCiAgICBhcmNoaXZlIGJqc29uIGJsb2IgY2hpbGQtcHJvY2VzcyBkZWVwIGdwaW8gbGV4ZXIgbG9jYXRpb24gbWlzYyBtbWFwIHBhdGgKICAgIHBvaW50ZXIgcHJlZGljYXRlIHJlcGVhdGVyIHN0cmluZ2RlY29kZXIgc29ja2V0cyBpbnNwZWN0IHRyZWUtd2Fsa2VyIHhtbCkKCmlmKEVYSVNUUyAiJHtRVUlDS0pTX0h9IikKCiAgc2V0KENPTU1PTl9IRUFERVJTICR7Q1VUSUxTX0h9ICR7UVVJQ0tKU19IfSkKZW5kaWYoKQpzZXQodXRpbF9TT1VSQ0VTIHV0aWxzLmMgdXRpbHMuaCBjaGFyLXV0aWxzLmMgY2hhci11dGlscy5oIGJ1ZmZlci11dGlscy5jCiAgICAgICAgICAgICAgICAgYnVmZmVyLXV0aWxzLmgpCnNldChjaGlsZF9wcm9jZXNzX1NPVVJDRVMKICAgIGNoaWxkLXByb2Nlc3MuYyBjaGlsZC1wcm9jZXNzLmggcHJvcGVydHktZW51bWVyYXRpb24uYwogICAgcHJvcGVydHktZW51bWVyYXRpb24uaCAke3V0aWxfU09VUkNFU30gdmVjdG9yLmMgdmVjdG9yLmggcXNvcnRfci5jKQpzZXQoZGVlcF9TT1VSQ0VTCiAgICB2ZWN0b3IuYyB2ZWN0b3IuaCBwb2ludGVyLmMgdmlydHVhbC1wcm9wZXJ0aWVzLmMgcHJvcGVydHktZW51bWVyYXRpb24uYwogICAgcHJvcGVydHktZW51bWVyYXRpb24uaCAke3V0aWxfU09VUkNFU30gcHJlZGljYXRlLmMgcHJlZGljYXRlLmggcG9pbnRlci5oCiAgICB2aXJ0dWFsLXByb3BlcnRpZXMuaCBxc29ydF9yLmMpCiMgc2V0KGRlZXBfTElCUkFSSUVTIHFqcy1wb2ludGVyIHFqcy1wcmVkaWNhdGUpCnNldChpbnNwZWN0X1NPVVJDRVMKICAgIHZlY3Rvci5jIHZlY3Rvci5oIGl0ZXJhdGlvbi5oICR7dXRpbF9TT1VSQ0VTfSBwcm9wZXJ0eS1lbnVtZXJhdGlvbi5jCiAgICBwcm9wZXJ0eS1lbnVtZXJhdGlvbi5oIHF1aWNranMtaW50ZXJuYWwuaCBxc29ydF9yLmMpCnNldCh0cmVlX3dhbGtlcl9TT1VSQ0VTIHZlY3Rvci5jIHZlY3Rvci5oIHByb3BlcnR5LWVudW1lcmF0aW9uLmMKICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHktZW51bWVyYXRpb24uaCAke3V0aWxfU09VUkNFU30pCnNldCh4bWxfU09VUkNFUyB2ZWN0b3IuYyB2ZWN0b3IuaCBwcm9wZXJ0eS1lbnVtZXJhdGlvbi5jIHByb3BlcnR5LWVudW1lcmF0aW9uLmgKICAgICAgICAgICAgICAgICR7dXRpbF9TT1VSQ0VTfSBxc29ydF9yLmMpCnNldChwYXRoX1NPVVJDRVMgcGF0aC5jIHBhdGguaCAke3V0aWxfU09VUkNFU30pCnNldChwcmVkaWNhdGVfU09VUkNFUyBwcmVkaWNhdGUuYyBwcmVkaWNhdGUuaCB2ZWN0b3IuYyB2ZWN0b3IuaCAke3V0aWxfU09VUkNFU30pCnNldChwb2ludGVyX1NPVVJDRVMgcG9pbnRlci5jIHBvaW50ZXIuaCAke3V0aWxfU09VUkNFU30pCnNldChsZXhlcl9TT1VSQ0VTIHF1aWNranMtbGV4ZXIuaCBsb2NhdGlvbi5jIGxvY2F0aW9uLmggJHt1dGlsX1NPVVJDRVN9CiAgICAgICAgICAgICAgICAgIHZlY3Rvci5jIHZlY3Rvci5oIGxleGVyLmMgbGV4ZXIuaCkKIyBzZXQobGV4ZXJfTElCUkFSSUVTIHF1aWNranMtcHJlZGljYXRlKQpzZXQobW1hcF9TT1VSQ0VTICR7dXRpbF9TT1VSQ0VTfSkKc2V0KHJlcGVhdGVyX1NPVVJDRVMgJHt1dGlsX1NPVVJDRVN9KQpzZXQobG9jYXRpb25fU09VUkNFUyBsb2NhdGlvbi5jIGxvY2F0aW9uLmggcXVpY2tqcy1sb2NhdGlvbi5jCiAgICAgICAgICAgICAgICAgICAgIHF1aWNranMtbG9jYXRpb24uaCB1dGlscy5jIHV0aWxzLmgpCnNldChibG9iX1NPVVJDRVMgdmVjdG9yLmMgdmVjdG9yLmggJHt1dGlsX1NPVVJDRVN9KQpzZXQoc3RyaW5nZGVjb2Rlcl9TT1VSQ0VTIHF1aWNranMtc3RyaW5nZGVjb2Rlci5jIHF1aWNranMtc3RyaW5nZGVjb2Rlci5oCiAgICAgICAgICAgICAgICAgICAgICAgICAgcmluZ2J1ZmZlci5jIHJpbmdidWZmZXIuaCAke3V0aWxfU09VUkNFU30pCnNldChtaXNjX1NPVVJDRVMgYmFzZTY0LmMgYmFzZTY0LmggcXVpY2tqcy1pbnRlcm5hbC5jIHF1aWNranMtaW50ZXJuYWwuaAogICAgICAgICAgICAgICAgICR7bG9jYXRpb25fU09VUkNFU30pCnNldChncGlvX1NPVVJDRVMgZ3Bpby5jIGdwaW8uaCkKaWYocGlncGlvX0xJQlJBUlkpCiAgc2V0KGdwaW9fTElCUkFSSUVTICR7cGlncGlvX0xJQlJBUll9KQplbmRpZihwaWdwaW9fTElCUkFSWSkKCmluY2x1ZGVfZGlyZWN0b3JpZXMoJHtMaWJBcmNoaXZlX0lOQ0xVREVfRElSU30pCnNldChhcmNoaXZlX0xJQlJBUklFUyAke0xpYkFyY2hpdmVfTElCUkFSSUVTfSkKCnNldChRSlNNX0VYVFJBX1NPVVJDRVMgJHtsb2NhdGlvbl9TT1VSQ0VTfSkKCnNldF9wcm9wZXJ0eShDQUNIRSBDTUFLRV9CVUlMRF9UWVBFIFBST1BFUlRZIFNUUklOR1MgRGVidWcgUmVsZWFzZSBNaW5TaXplUmVsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlbFdpdGhEZWJJbmZvKQoKbWVzc2FnZSgKICAiUXVpY2tKUwogIGluc3RhbGwKICBkaXJlY3Rvcnk6CiAgJHtRVUlDS0pTX1BSRUZJWH0iKQoKc2V0KENNQUtFX1JFUVVJUkVEX1FVSUVUIFRSVUUpCgpjaGVja19mbGFnKCItZnZpc2liaWxpdHk9aGlkZGVuIiBWSVNJQklMSVRZX0hJRERFTiBNT0RVTEVfQ09NUElMRV9GTEFHUykKCiMgZHVtcChWSVNJQklMSVRZX0hJRERFTikgZHVtcChNT0RVTEVfQ09NUElMRV9GTEFHUykKCmNoZWNrX2ZsYWdzKAogICItV2FsbDstV25vLXVudXNlZC1wYXJhbWV0ZXI7LVduby11bnVzZWQtdmFyaWFibGU7LVduby11bnVzZWQtYnV0LXNldC12YXJpYWJsZTstV25vLXVudXNlZC1mdW5jdGlvbjstV25vLWNhc3QtZnVuY3Rpb24tdHlwZSIKICBDTUFLRV9DX0ZMQUdTKQoKaWYoQ01BS0VfQlVJTERfVFlQRSBTVFJFUVVBTCAiRGVidWciKQogIGNoZWNrX2NfY29tcGlsZXJfZmxhZygiLU8wIiBPX09QVF9OT05FKQogIGlmKE9fT1BUX05PTkUpCiAgICBpZihOT1QgIiR7Q01BS0VfQ19GTEFHU19ERUJVR30iIE1BVENIRVMgIi1PMCIpCiAgICAgIHNldChDTUFLRV9DX0ZMQUdTX0RFQlVHICIke0NNQUtFX0NfRkxBR1NfREVCVUd9IC1PMCIKICAgICAgICAgIENBQ0hFIFNUUklORyAiQyBjb21waWxlciBvcHRpb25zIiBGT1JDRSkKICAgIGVuZGlmKE5PVCAiJHtDTUFLRV9DX0ZMQUdTX0RFQlVHfSIgTUFUQ0hFUyAiLU8wIikKICBlbmRpZihPX09QVF9OT05FKQogIGNoZWNrX2NfY29tcGlsZXJfZmxhZygiLWdnZGIiIEdfT1BUX0dEQikKICBpZihHX09QVF9HREIpCiAgICBpZihOT1QgIiR7Q01BS0VfQ19GTEFHU19ERUJVR30iIE1BVENIRVMgIi1nZ2RiIikKICAgICAgc2V0KENNQUtFX0NfRkxBR1NfREVCVUcgIiR7Q01BS0VfQ19GTEFHU19ERUJVR30gLWdnZGIiCiAgICAgICAgICBDQUNIRSBTVFJJTkcgIkMgY29tcGlsZXIgb3B0aW9ucyIgRk9SQ0UpCiAgICBlbmRpZihOT1QgIiR7Q01BS0VfQ19GTEFHU19ERUJVR30iIE1BVENIRVMgIi1nZ2RiIikKICBlbmRpZihHX09QVF9HREIpCiAgY2hlY2tfY19jb21waWxlcl9mbGFnKCItV2V4dHJhIiBHX1dBUk5fRVhUUkEpCiAgaWYoR19XQVJOX0VYVFJBKQogICAgaWYoTk9UICIke0NNQUtFX0NfRkxBR1NfREVCVUd9IiBNQVRDSEVTICItV2V4dHJhIikKICAgICAgc2V0KENNQUtFX0NfRkxBR1NfREVCVUcgIiR7Q01BS0VfQ19GTEFHU19ERUJVR30gLVdleHRyYSIKICAgICAgICAgIENBQ0hFIFNUUklORyAiQyBjb21waWxlciBvcHRpb25zIiBGT1JDRSkKICAgIGVuZGlmKE5PVCAiJHtDTUFLRV9DX0ZMQUdTX0RFQlVHfSIgTUFUQ0hFUyAiLVdleHRyYSIpCiAgZW5kaWYoR19XQVJOX0VYVFJBKQplbmRpZihDTUFLRV9CVUlMRF9UWVBFIFNUUkVRVUFMICJEZWJ1ZyIpCgppbmNsdWRlKENoZWNrRnVuY3Rpb25FeGlzdHMpCgppbmNsdWRlKENoZWNrQ1NvdXJjZVJ1bnMpCgpzZXQoQ01BS0VfUkVRVUlSRURfUVVJRVQgT0ZGKQpjaGVja19pbmNsdWRlX2ZpbGUoc3Bhd24uaCBIQVZFX1NQQVdOX0gpCgppZihIQVZFX1NQQVdOX0gpCiAgbGlzdChBUFBFTkQgQ01BS0VfUkVRVUlSRURfSU5DTFVERVMgc3Bhd24uaCkKCiAgY2hlY2tfZnVuY3Rpb25fZXhpc3RzKHBvc2l4X3NwYXducCBIQVZFX1BPU0lYX1NQQVdOUCkKICBtZXNzYWdlKFNUQVRVUyAiSEFWRV9QT1NJWF9TUEFXTlA6ICR7SEFWRV9QT1NJWF9TUEFXTlB9IikKCiAgaWYoSEFWRV9QT1NJWF9TUEFXTlApCiAgICBhZGRfZGVmaW5pdGlvbnMoLURQT1NJWF9TUEFXTj0xKQogIGVuZGlmKEhBVkVfUE9TSVhfU1BBV05QKQoKZW5kaWYoSEFWRV9TUEFXTl9IKQoKZmlsZShHTE9CIFRFU1RTIHRlc3RzL3Rlc3RfKi5qcykKCnJlbGF0aXZlX3BhdGgoVEVTVFMgIiR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfSIgJHtURVNUU30pCgppZihET19URVNUUykKICBpbmNsdWRlKENUZXN0KQoKICBmb3JlYWNoKFRFU1QgJHtURVNUU30pCiAgICBiYXNlbmFtZShCQVNFICIke1RFU1R9IikKICAgIHN0cmluZyhSRVBMQUNFICJ0ZXN0XyIgIiIgTkFNRSAiJHtCQVNFfSIpCiAgICBhZGRfdGVzdCgKICAgICAgTkFNRSAiJHtCQVNFfSIKICAgICAgQ09NTUFORAogICAgICAgIGVudgogICAgICAgIFFVSUNLSlNfTU9EVUxFX1BBVEg9JHtDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVJ9OiR7Q01BS0VfQ1VSUkVOVF9CSU5BUllfRElSfQogICAgICAgICIke1FKU30iIC0tYmlnbnVtICIke1RFU1R9IgogICAgICBXT1JLSU5HX0RJUkVDVE9SWSAiJHtDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVJ9IikKICAgIGFkZF9jdXN0b21fdGFyZ2V0KAogICAgICAiJHtCQVNFfSIgQUxMCiAgICAgIENPTU1BTkQKICAgICAgICBlbnYKICAgICAgICBRVUlDS0pTX01PRFVMRV9QQVRIPSR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfToke0NNQUtFX0NVUlJFTlRfQklOQVJZX0RJUn0KICAgICAgICAiJHtRSlNDfSIgLWZiaWdudW0gLU0gc3RkIC1NIG9zIC1NICR7TkFNRX0gLW8gIiR7QkFTRX0iCiAgICAgICAgIiR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS8ke1RFU1R9IgogICAgICBXT1JLSU5HX0RJUkVDVE9SWSAiJHtDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVJ9IgogICAgICBTT1VSQ0VTICIke1RFU1R9IikKICBlbmRmb3JlYWNoKFRFU1QgJHtURVNUU30pCmVuZGlmKERPX1RFU1RTKQoKY2hlY2tfY19zb3VyY2VfcnVucygKICAiICMgaW5jbHVkZSA8c3RkYm9vbC5oPlxuYm9vbCBmb28oaW50IGEsIGludCBiLCBpbnQgKmMpIHtcbiAgIHJldHVybiBfX2J1aWx0aW5fbXVsX292ZXJmbG93KGEsIGIsCiAgICAjIGMpO1xufVxuaW50IG1haW4oKSB7XG4gICBpbnQgb3V0O1xuICAgaWYgKGZvbygxLCAyLCAmb3V0KSkge1xuICAgICAgIHJldHVybiAwO1xuICAgfVxuIHJldHVybgogICAgIyAwO1xufSIKICBIQVZFX19CVUlMVElOX01VTF9PVkVSRkxPVykKaWYoSEFWRV9fQlVJTFRJTl9NVUxfT1ZFUkZMT1cpCiAgYWRkX2RlZmluaXRpb25zKC1ESEFWRV9fQlVJTFRJTl9NVUxfT1ZFUkZMT1cpCmVuZGlmKEhBVkVfX0JVSUxUSU5fTVVMX09WRVJGTE9XKQoKYWRkcHJlZml4KFNIQVJFRF9UQVJHRVRTICJxanMtIiAke1FVSUNLSlNfTU9EVUxFU30pCmFkZHN1ZmZpeChTVEFUSUNfVEFSR0VUUyAiLXN0YXRpYyIgJHtTSEFSRURfVEFSR0VUU30pCgojIGR1bXAoU1RBVElDX1RBUkdFVFMpCnVuc2V0KFFKU01fTERBREQpCgpzZXQoUUpTTV9MSUJESVIgIiR7Q01BS0VfQ1VSUkVOVF9CSU5BUllfRElSfSIpCgpmb3JlYWNoKEpTX01PRFVMRSAke1FVSUNLSlNfTU9EVUxFU30pCiAgbWFrZV9tb2R1bGUoJHtKU19NT0RVTEV9KQogIHN0cmluZyhSRUdFWCBSRVBMQUNFICItIiAiXyIgUUpTTV9NT0RVTEUgIiR7SlNfTU9EVUxFfSIpCiAgbGlzdChBUFBFTkQgUUpTTV9MREFERCAiJHtRSlNNX01PRFVMRX0uYSIpCmVuZGZvcmVhY2goSlNfTU9EVUxFICR7UVVJQ0tKU19NT0RVTEVTfSkKCmR1bXAoUUpTTV9MREFERCBRSlNNX0xJQkRJUikKCnRhcmdldF9saW5rX2xpYnJhcmllcyhxanMtZGVlcCBxanMtcHJlZGljYXRlKQp0YXJnZXRfbGlua19saWJyYXJpZXMocWpzLWxleGVyIHFqcy1wcmVkaWNhdGUpCmFkZF9kZXBlbmRlbmNpZXMocWpzLWxleGVyIHFqcy1wcmVkaWNhdGUpCgpmaWxlKEdMT0IgVEVTVFNfU09VUkNFUyB0ZXN0cy90ZXN0XyouanMpCmxpc3QoRklMVEVSIFRFU1RTX1NPVVJDRVMgRVhDTFVERSBSRUdFWCAidGVzdF9sZXhlci5qcyIpCnNvdXJjZV9ncm91cChURVNUU19HUk9VUCBGSUxFUyAke1RFU1RTX1NPVVJDRVN9KQoKaW5jbHVkZShDVGVzdCkKCmZvcmVhY2goVEVTVF9TT1VSQ0UgJHtURVNUU19TT1VSQ0VTfSkKICBmaWxlKFJFTEFUSVZFX1BBVEggVEVTVF9TT1VSQ0UgIiR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfSIgIiR7VEVTVF9TT1VSQ0V9IikKICBiYXNlbmFtZShURVNUX05BTUUgJHtURVNUX1NPVVJDRX0gLmpzKQogIGFkZF90ZXN0KE5BTUUgIiR7VEVTVF9OQU1FfSIgQ09NTUFORCBxanNtIC0tYmlnbnVtICIke1RFU1RfU09VUkNFfSIKICAgICAgICAgICBXT1JLSU5HX0RJUkVDVE9SWSAiJHtDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVJ9IikKCmVuZGZvcmVhY2goVEVTVF9TT1VSQ0UgJHtURVNUU19TT1VSQ0VTfSkKCmZpbGUoR0xPQiBMSUJKUyAiJHtDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVJ9L2xpYi8qLmpzIikKbGlzdChGSUxURVIgTElCSlMgRVhDTFVERSBSRUdFWCAibGliL3JlcXVpcmUuanN8bGliL2ZzLmpzIikKCmluc3RhbGwoRklMRVMgJHtMSUJKU30gREVTVElOQVRJT04gIiR7UVVJQ0tKU19MSUJSQVJZX0RJUn0vcXVpY2tqcyIpCgpzZXQoTElCX01PRFVMRVMgY29uc29sZSBldmVudHMgZnMgcGVyZl9ob29rcyBwcm9jZXNzIHJlcGwgcmVxdWlyZSB0dHkgdXRpbCkKCnN0cmluZyhSRUdFWCBSRVBMQUNFICJbXkEtWmEtejAtOV9dIiAiOyIgQlVJTFRJTl9MSUJTICIke0xJQl9NT0RVTEVTfSIpCgojIHRhcmdldF9jb21waWxlX2RlZmluaXRpb25zKHFqc20gLURCVUlMVElOX01PRFVMRVM9XFxcIiR7QlVJTFRJTl9MSUJTfVxcXCIpIG1lc3NhZ2UoIiR7QlVJTFRJTl9MSUJTfSIKCmxpc3QoQVBQRU5EIENNQUtFX0ZJTkRfTElCUkFSWV9QUkVGSVhFUyAiIikKCmZvcmVhY2goTElCX01PRFVMRSAke0xJQl9NT0RVTEVTfSkKICAjIG1lc3NhZ2UoIkNvbXBpbGUgTW9kdWxlOiAke0xJQl9NT0RVTEV9IikKICBjb21waWxlX21vZHVsZShsaWIvJHtMSUJfTU9EVUxFfS5qcykKZW5kZm9yZWFjaChMSUJfTU9EVUxFICR7TElCX01PRFVMRVN9KQoKaWYoRVhJU1RTICR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS8uLi9kZWZzLmNtYWtlKQogIHNldChRVUlDS0pTX1NPVVJDRVNfUk9PVCAke0NNQUtFX0NVUlJFTlRfU09VUkNFX0RJUn0vLi4pCgogIGluY2x1ZGUoJHtRVUlDS0pTX1NPVVJDRVNfUk9PVH0vZGVmcy5jbWFrZSkKICBpbmNsdWRlKCR7UVVJQ0tKU19TT1VSQ0VTX1JPT1R9L2NtYWtlL2NoZWNrLWxpYnJhcmllcy5jbWFrZSkKCiAgYWRkX2N1c3RvbV9jb21tYW5kKAogICAgT1VUUFVUICR7TU9EVUxFU19ESVJ9L3Fqc2NhbGMuYwogICAgQ09NTUFORCAke1FKU0N9IC1mYmlnbnVtIC1jIC1vICR7TU9EVUxFU19ESVJ9L3Fqc2NhbGMuYyAtbQogICAgICAgICAgICAke0NNQUtFX0NVUlJFTlRfU09VUkNFX0RJUn0vLi4vcWpzY2FsYy5qcwogICAgREVQRU5EUyAke1FKU0NfREVQU30KICAgIFdPUktJTkdfRElSRUNUT1JZICR7Q01BS0VfQ1VSUkVOVF9CSU5BUllfRElSfQogICAgQ09NTUVOVCAiR2VuZXJhdGUgZnJvbSBxanNjYWxjLmpzIHVzaW5nIHFqcyBjb21waWxlciIgU09VUkNFUwogICAgICAgICAgICAke0NNQUtFX0NVUlJFTlRfU09VUkNFX0RJUn0vLi4vcWpzY2FsYy5qcykKCiAgc2V0KFFKU01fU09VUkNFUwogICAgICBxanNtLmMKICAgICAgdmVjdG9yLmMKICAgICAgJHtNT0RVTEVTX0RJUn0vcmVwbC5jCiAgICAgICR7TU9EVUxFU19ESVJ9L3Fqc2NhbGMuYwogICAgICAke01PRFVMRVNfRElSfS9jb25zb2xlLmMKICAgICAgJHtNT0RVTEVTX0RJUn0vZXZlbnRzLmMKICAgICAgJHtNT0RVTEVTX0RJUn0vcmVxdWlyZS5jCiAgICAgICR7TU9EVUxFU19ESVJ9L2ZzLmMKICAgICAgJHtNT0RVTEVTX0RJUn0vcGVyZl9ob29rcy5jCiAgICAgICR7TU9EVUxFU19ESVJ9L3Byb2Nlc3MuYwogICAgICAke01PRFVMRVNfRElSfS90dHkuYwogICAgICAke01PRFVMRVNfRElSfS91dGlsLmMKICAgICAgJHtRSlNNX0VYVFJBX1NPVVJDRVN9KQoKICBpZihFWElTVFMgJHtDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVJ9Ly4uL3F1aWNranMtZGVidWdnZXIuYykKICAgIGlmKFFVSUNLSlNfREVCVUdHRVIpCiAgICAgIHNldChRSlNNX1NPVVJDRVMKICAgICAgICAgICR7UUpTTV9TT1VSQ0VTfQogICAgICAgICAgJHtDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVJ9Ly4uL3F1aWNranMtZGVidWdnZXIuYwogICAgICAgICAgJHtDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVJ9Ly4uL3F1aWNranMtZGVidWdnZXItdHJhbnNwb3J0LSR7VFJBTlNQT1JUX1BMQVRGT1JNfS5jCiAgICAgICkKICAgIGVuZGlmKFFVSUNLSlNfREVCVUdHRVIpCiAgZW5kaWYoRVhJU1RTICR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS8uLi9xdWlja2pzLWRlYnVnZ2VyLmMpCgogIGR1bXAoUUpTTV9TT1VSQ0VTKQogIGFkZF9leGVjdXRhYmxlKHFqc20gJHtRSlNNX1NPVVJDRVN9KQoKICAjIGR1bXAoUUpTX01PRFVMRVNfU1RBVElDKQogIGlmKFFKU19NT0RVTEVTX1NUQVRJQykKICAgIGFkZF9kZXBlbmRlbmNpZXMocWpzbSAke1FKU19NT0RVTEVTX1NUQVRJQ30pCiAgZW5kaWYoUUpTX01PRFVMRVNfU1RBVElDKQoKICAjIHRhcmdldF9saW5rX2xpYnJhcmllcyhxanNtIHF1aWNranMgJHtRSlNNX0xEQUREfSAke0xJQlBUSFJFQUR9ICR7TElCTX0gJHtMSUJETH0gJHtMSUJXUzJfMzJ9KQoKICAjIHRhcmdldF9saW5rX2xpYnJhcmllcyhxanMgJHtRVUlDS0pTX0xJQlJBUll9KQogIHRhcmdldF9saW5rX2RpcmVjdG9yaWVzKHFqc20gUFVCTElDICR7UUpTTV9MSUJESVJ9CiAgICAgICAgICAgICAgICAgICAgICAgICAgJHtDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVJ9KQogIHRhcmdldF9saW5rX2xpYnJhcmllcyhxanNtIHF1aWNranMgJHtRSlNNX0xEQUREfSAke0xJQlBUSFJFQUR9ICR7TElCTX0KICAgICAgICAgICAgICAgICAgICAgICAgJHtMSUJETH0gJHtMSUJXUzJfMzJ9KQogIHNldF90YXJnZXRfcHJvcGVydGllcygKICAgIHFqc20gUFJPUEVSVElFUyBMSU5LX09QVElPTlMgIiR7TElOS19FWFBPUlR9IiBDT01QSUxFX0ZMQUdTICItdyIKICAgICAgICAgICAgICAgICAgICBSUEFUSCAiJHtRVUlDS0pTX0lOU1RBTExfUFJFRklYfS9saWIvcXVpY2tqcyIpCgogIHRhcmdldF9jb21waWxlX2RlZmluaXRpb25zKAogICAgcWpzbSBQUklWQVRFIENPTkZJR19WRVJTSU9OPSIke1FVSUNLSlNfVkVSU0lPTn0iIF9HTlVfU09VUkNFPTEKICAgICAgICAgICAgICAgICBDT05GSUdfUFJFRklYPSIke1FVSUNLSlNfSU5TVEFMTF9QUkVGSVh9IiBDT05GSUdfQklHTlVNPTEpCiAgaW5zdGFsbChUQVJHRVRTIHFqc20gREVTVElOQVRJT04gYmluKQoKZW5kaWYoRVhJU1RTICR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS8uLi9kZWZzLmNtYWtlKQoAAAAAAAAAAN8oAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA6QwAAAAAAADpDAAAAAAAAAAAAAAAAPC/"
				],
				[
					8,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAADfKAAAcHJvamVjdChtb2R1bGVzIEMpCgpjbWFrZV9taW5pbXVtX3JlcXVpcmVkKFZFUlNJT04gMy4yKQoKaW5jbHVkZSgke0NNQUtFX0NVUlJFTlRfU09VUkNFX0RJUn0vY21ha2UvZnVuY3Rpb25zLmNtYWtlKQppbmNsdWRlKCR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS9jbWFrZS9jaGVjay1mbGFncy5jbWFrZSkKaW5jbHVkZSgke0NNQUtFX0NVUlJFTlRfU09VUkNFX0RJUn0vY21ha2UvUXVpY2tKU01vZHVsZS5jbWFrZSkKaW5jbHVkZSgke0NNQUtFX0NVUlJFTlRfU09VUkNFX0RJUn0vY21ha2UvRmluZFF1aWNrSlMuY21ha2UpCgpvcHRpb24oQlVJTERfUElHUElPICJCdWlsZCBwaWdwaW8gbGlicmFyeSIgT0ZGKQoKZmluZF9xdWlja2pzKCkKCmlmKEJVSUxEX1BJR1BJTykKICBpbmNsdWRlKEV4dGVybmFsUHJvamVjdCkKICBFeHRlcm5hbFByb2plY3RfQWRkKAogICAgcGlncGlvCiAgICBTT1VSQ0VfRElSICR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS9waWdwaW8KICAgIEJJTkFSWV9ESVIgJHtDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVJ9L3BpZ3BpbwogICAgQ01BS0VfQ0FDSEVfQVJHUwogICAgICAiLURDTUFLRV9DX0NPTVBJTEVSOkZJTEVQQVRIPSR7Q01BS0VfQ19DT01QSUxFUn0iICItRENNQUtFX1NZU1JPT1Q6UEFUSD0ke0NNQUtFX1NZU1JPT1R9IgogICAgICAiLURDTUFLRV9UT09MQ0hBSU5fRklMRTpGSUxFUEFUSD0ke0NNQUtFX1RPT0xDSEFJTl9GSUxFfSIgIi1EQ01BS0VfQ19GTEFHUzpTVFJJTkc9LXciCiAgICAgICItRENNQUtFX1ZFUkJPU0VfTUFLRUZJTEU6Qk9PTD0ke0NNQUtFX1ZFUkJPU0VfTUFLRUZJTEV9IiAiLURDTUFLRV9CVUlMRF9UWVBFOlNUUklORz0ke0NNQUtFX0JVSUxEX1RZUEV9IgogICAgQ01BS0VfQ0FDSEVfREVGQVVMVF9BUkdTICItREJVSUxEX1NIQVJFRF9MSUJTOkJPT0w9RkFMU0UiKQoKICBsaW5rX2RpcmVjdG9yaWVzKCIke0NNQUtFX0NVUlJFTlRfQklOQVJZX0RJUn0vcGlncGlvIikKCmVsc2UoQlVJTERfUElHUElPKQogIGluY2x1ZGUoJHtDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVJ9L2NtYWtlL0ZpbmRwaWdwaW8uY21ha2UpCgplbmRpZihCVUlMRF9QSUdQSU8pCgppbmNsdWRlKEZpbmRMaWJBcmNoaXZlKQoKbGlua19kaXJlY3Rvcmllcygke0NNQUtFX0NVUlJFTlRfQklOQVJZX0RJUn0pCgppZihOT1QgTGliQXJjaGl2ZV9GT1VORCkKICBtZXNzYWdlKEVSUk9SICJsaWJhcmNoaXZlIG5vdCBmb3VuZCIpCmVuZGlmKE5PVCBMaWJBcmNoaXZlX0ZPVU5EKQoKc2V0KFFVSUNLSlNfTU9EVUxFUyBhcmNoaXZlIGJqc29uIGJsb2IgY2hpbGQtcHJvY2VzcyBkZWVwIGdwaW8gbGV4ZXIgbG9jYXRpb24gbWlzYyBtbWFwIHBhdGggcG9pbnRlciBwcmVkaWNhdGUgcmVwZWF0ZXIKICAgICAgICAgICAgICAgICAgICBzdHJpbmdkZWNvZGVyIHNvY2tldHMgaW5zcGVjdCB0cmVlLXdhbGtlciB4bWwpCgppZihFWElTVFMgIiR7UVVJQ0tKU19IfSIpCgogIHNldChDT01NT05fSEVBREVSUyAke0NVVElMU19IfSAke1FVSUNLSlNfSH0pCmVuZGlmKCkKc2V0KHV0aWxfU09VUkNFUyB1dGlscy5jIHV0aWxzLmggY2hhci11dGlscy5jIGNoYXItdXRpbHMuaCBidWZmZXItdXRpbHMuYyBidWZmZXItdXRpbHMuaCkKc2V0KGNoaWxkX3Byb2Nlc3NfU09VUkNFUyBjaGlsZC1wcm9jZXNzLmMgY2hpbGQtcHJvY2Vzcy5oIHByb3BlcnR5LWVudW1lcmF0aW9uLmMgcHJvcGVydHktZW51bWVyYXRpb24uaCAke3V0aWxfU09VUkNFU30KICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWN0b3IuYyB2ZWN0b3IuaCBxc29ydF9yLmMpCnNldChkZWVwX1NPVVJDRVMgdmVjdG9yLmMgdmVjdG9yLmggcG9pbnRlci5jIHZpcnR1YWwtcHJvcGVydGllcy5jIHByb3BlcnR5LWVudW1lcmF0aW9uLmMgcHJvcGVydHktZW51bWVyYXRpb24uaAogICAgICAgICAgICAgICAgICR7dXRpbF9TT1VSQ0VTfSBwcmVkaWNhdGUuYyBwcmVkaWNhdGUuaCBwb2ludGVyLmggdmlydHVhbC1wcm9wZXJ0aWVzLmggcXNvcnRfci5jKQojIHNldChkZWVwX0xJQlJBUklFUyBxanMtcG9pbnRlciBxanMtcHJlZGljYXRlKQpzZXQoaW5zcGVjdF9TT1VSQ0VTIHZlY3Rvci5jIHZlY3Rvci5oIGl0ZXJhdGlvbi5oICR7dXRpbF9TT1VSQ0VTfSBwcm9wZXJ0eS1lbnVtZXJhdGlvbi5jIHByb3BlcnR5LWVudW1lcmF0aW9uLmgKICAgICAgICAgICAgICAgICAgICBxdWlja2pzLWludGVybmFsLmggcXNvcnRfci5jKQpzZXQodHJlZV93YWxrZXJfU09VUkNFUyB2ZWN0b3IuYyB2ZWN0b3IuaCBwcm9wZXJ0eS1lbnVtZXJhdGlvbi5jIHByb3BlcnR5LWVudW1lcmF0aW9uLmggJHt1dGlsX1NPVVJDRVN9KQpzZXQoeG1sX1NPVVJDRVMgdmVjdG9yLmMgdmVjdG9yLmggcHJvcGVydHktZW51bWVyYXRpb24uYyBwcm9wZXJ0eS1lbnVtZXJhdGlvbi5oICR7dXRpbF9TT1VSQ0VTfSBxc29ydF9yLmMpCnNldChwYXRoX1NPVVJDRVMgcGF0aC5jIHBhdGguaCAke3V0aWxfU09VUkNFU30pCnNldChwcmVkaWNhdGVfU09VUkNFUyBwcmVkaWNhdGUuYyBwcmVkaWNhdGUuaCB2ZWN0b3IuYyB2ZWN0b3IuaCAke3V0aWxfU09VUkNFU30pCnNldChwb2ludGVyX1NPVVJDRVMgcG9pbnRlci5jIHBvaW50ZXIuaCAke3V0aWxfU09VUkNFU30pCnNldChsZXhlcl9TT1VSQ0VTIHF1aWNranMtbGV4ZXIuaCBsb2NhdGlvbi5jIGxvY2F0aW9uLmggJHt1dGlsX1NPVVJDRVN9IHZlY3Rvci5jIHZlY3Rvci5oIGxleGVyLmMgbGV4ZXIuaCkKIyBzZXQobGV4ZXJfTElCUkFSSUVTIHF1aWNranMtcHJlZGljYXRlKQpzZXQobW1hcF9TT1VSQ0VTICR7dXRpbF9TT1VSQ0VTfSkKc2V0KHJlcGVhdGVyX1NPVVJDRVMgJHt1dGlsX1NPVVJDRVN9KQpzZXQobG9jYXRpb25fU09VUkNFUyBsb2NhdGlvbi5jIGxvY2F0aW9uLmggcXVpY2tqcy1sb2NhdGlvbi5jIHF1aWNranMtbG9jYXRpb24uaCB1dGlscy5jIHV0aWxzLmgpCnNldChibG9iX1NPVVJDRVMgdmVjdG9yLmMgdmVjdG9yLmggJHt1dGlsX1NPVVJDRVN9KQpzZXQoc3RyaW5nZGVjb2Rlcl9TT1VSQ0VTIHF1aWNranMtc3RyaW5nZGVjb2Rlci5jIHF1aWNranMtc3RyaW5nZGVjb2Rlci5oIHJpbmdidWZmZXIuYyByaW5nYnVmZmVyLmggJHt1dGlsX1NPVVJDRVN9KQpzZXQobWlzY19TT1VSQ0VTIGJhc2U2NC5jIGJhc2U2NC5oIHF1aWNranMtaW50ZXJuYWwuYyBxdWlja2pzLWludGVybmFsLmggJHtsb2NhdGlvbl9TT1VSQ0VTfSkKc2V0KGdwaW9fU09VUkNFUyBncGlvLmMgZ3Bpby5oKQppZihwaWdwaW9fTElCUkFSWSkKICBzZXQoZ3Bpb19MSUJSQVJJRVMgJHtwaWdwaW9fTElCUkFSWX0pCmVuZGlmKHBpZ3Bpb19MSUJSQVJZKQoKaW5jbHVkZV9kaXJlY3Rvcmllcygke0xpYkFyY2hpdmVfSU5DTFVERV9ESVJTfSkKc2V0KGFyY2hpdmVfTElCUkFSSUVTICR7TGliQXJjaGl2ZV9MSUJSQVJJRVN9KQoKc2V0KFFKU01fRVhUUkFfU09VUkNFUyAke2xvY2F0aW9uX1NPVVJDRVN9KQoKc2V0X3Byb3BlcnR5KENBQ0hFIENNQUtFX0JVSUxEX1RZUEUgUFJPUEVSVFkgU1RSSU5HUyBEZWJ1ZyBSZWxlYXNlIE1pblNpemVSZWwgUmVsV2l0aERlYkluZm8pCgptZXNzYWdlKAogICJRdWlja0pTCiAgaW5zdGFsbAogIGRpcmVjdG9yeToKICAke1FVSUNLSlNfUFJFRklYfSIpCgpzZXQoQ01BS0VfUkVRVUlSRURfUVVJRVQgVFJVRSkKCmNoZWNrX2ZsYWcoIi1mdmlzaWJpbGl0eT1oaWRkZW4iIFZJU0lCSUxJVFlfSElEREVOIE1PRFVMRV9DT01QSUxFX0ZMQUdTKQoKIyBkdW1wKFZJU0lCSUxJVFlfSElEREVOKSBkdW1wKE1PRFVMRV9DT01QSUxFX0ZMQUdTKQoKY2hlY2tfZmxhZ3MoCiAgIi1XYWxsOy1Xbm8tdW51c2VkLXBhcmFtZXRlcjstV25vLXVudXNlZC12YXJpYWJsZTstV25vLXVudXNlZC1idXQtc2V0LXZhcmlhYmxlOy1Xbm8tdW51c2VkLWZ1bmN0aW9uOy1Xbm8tY2FzdC1mdW5jdGlvbi10eXBlIgogIENNQUtFX0NfRkxBR1MpCgppZihDTUFLRV9CVUlMRF9UWVBFIFNUUkVRVUFMICJEZWJ1ZyIpCiAgY2hlY2tfY19jb21waWxlcl9mbGFnKCItTzAiIE9fT1BUX05PTkUpCiAgaWYoT19PUFRfTk9ORSkKICAgIGlmKE5PVCAiJHtDTUFLRV9DX0ZMQUdTX0RFQlVHfSIgTUFUQ0hFUyAiLU8wIikKICAgICAgc2V0KENNQUtFX0NfRkxBR1NfREVCVUcgIiR7Q01BS0VfQ19GTEFHU19ERUJVR30gLU8wIiBDQUNIRSBTVFJJTkcgIkMgY29tcGlsZXIgb3B0aW9ucyIgRk9SQ0UpCiAgICBlbmRpZihOT1QgIiR7Q01BS0VfQ19GTEFHU19ERUJVR30iIE1BVENIRVMgIi1PMCIpCiAgZW5kaWYoT19PUFRfTk9ORSkKICBjaGVja19jX2NvbXBpbGVyX2ZsYWcoIi1nZ2RiIiBHX09QVF9HREIpCiAgaWYoR19PUFRfR0RCKQogICAgaWYoTk9UICIke0NNQUtFX0NfRkxBR1NfREVCVUd9IiBNQVRDSEVTICItZ2dkYiIpCiAgICAgIHNldChDTUFLRV9DX0ZMQUdTX0RFQlVHICIke0NNQUtFX0NfRkxBR1NfREVCVUd9IC1nZ2RiIiBDQUNIRSBTVFJJTkcgIkMgY29tcGlsZXIgb3B0aW9ucyIgRk9SQ0UpCiAgICBlbmRpZihOT1QgIiR7Q01BS0VfQ19GTEFHU19ERUJVR30iIE1BVENIRVMgIi1nZ2RiIikKICBlbmRpZihHX09QVF9HREIpCiAgY2hlY2tfY19jb21waWxlcl9mbGFnKCItV2V4dHJhIiBHX1dBUk5fRVhUUkEpCiAgaWYoR19XQVJOX0VYVFJBKQogICAgaWYoTk9UICIke0NNQUtFX0NfRkxBR1NfREVCVUd9IiBNQVRDSEVTICItV2V4dHJhIikKICAgICAgc2V0KENNQUtFX0NfRkxBR1NfREVCVUcgIiR7Q01BS0VfQ19GTEFHU19ERUJVR30gLVdleHRyYSIgQ0FDSEUgU1RSSU5HICJDIGNvbXBpbGVyIG9wdGlvbnMiIEZPUkNFKQogICAgZW5kaWYoTk9UICIke0NNQUtFX0NfRkxBR1NfREVCVUd9IiBNQVRDSEVTICItV2V4dHJhIikKICBlbmRpZihHX1dBUk5fRVhUUkEpCmVuZGlmKENNQUtFX0JVSUxEX1RZUEUgU1RSRVFVQUwgIkRlYnVnIikKCmluY2x1ZGUoQ2hlY2tGdW5jdGlvbkV4aXN0cykKCmluY2x1ZGUoQ2hlY2tDU291cmNlUnVucykKCnNldChDTUFLRV9SRVFVSVJFRF9RVUlFVCBPRkYpCmNoZWNrX2luY2x1ZGVfZmlsZShzcGF3bi5oIEhBVkVfU1BBV05fSCkKCmlmKEhBVkVfU1BBV05fSCkKICBsaXN0KEFQUEVORCBDTUFLRV9SRVFVSVJFRF9JTkNMVURFUyBzcGF3bi5oKQoKICBjaGVja19mdW5jdGlvbl9leGlzdHMocG9zaXhfc3Bhd25wIEhBVkVfUE9TSVhfU1BBV05QKQogIG1lc3NhZ2UoU1RBVFVTICJIQVZFX1BPU0lYX1NQQVdOUDogJHtIQVZFX1BPU0lYX1NQQVdOUH0iKQoKICBpZihIQVZFX1BPU0lYX1NQQVdOUCkKICAgIGFkZF9kZWZpbml0aW9ucygtRFBPU0lYX1NQQVdOPTEpCiAgZW5kaWYoSEFWRV9QT1NJWF9TUEFXTlApCgplbmRpZihIQVZFX1NQQVdOX0gpCgpmaWxlKEdMT0IgVEVTVFMgdGVzdHMvdGVzdF8qLmpzKQoKcmVsYXRpdmVfcGF0aChURVNUUyAiJHtDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVJ9IiAke1RFU1RTfSkKCmlmKERPX1RFU1RTKQogIGluY2x1ZGUoQ1Rlc3QpCgogIGZvcmVhY2goVEVTVCAke1RFU1RTfSkKICAgIGJhc2VuYW1lKEJBU0UgIiR7VEVTVH0iKQogICAgc3RyaW5nKFJFUExBQ0UgInRlc3RfIiAiIiBOQU1FICIke0JBU0V9IikKICAgIGFkZF90ZXN0KE5BTUUgIiR7QkFTRX0iIENPTU1BTkQgZW52IFFVSUNLSlNfTU9EVUxFX1BBVEg9JHtDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVJ9OiR7Q01BS0VfQ1VSUkVOVF9CSU5BUllfRElSfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiJHtRSlN9IiAtLWJpZ251bSAiJHtURVNUfSIgV09SS0lOR19ESVJFQ1RPUlkgIiR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfSIpCiAgICBhZGRfY3VzdG9tX3RhcmdldCgKICAgICAgIiR7QkFTRX0iIEFMTCBDT01NQU5EIGVudiBRVUlDS0pTX01PRFVMRV9QQVRIPSR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfToke0NNQUtFX0NVUlJFTlRfQklOQVJZX0RJUn0gIiR7UUpTQ30iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtZmJpZ251bSAtTSBzdGQgLU0gb3MgLU0gJHtOQU1FfSAtbyAiJHtCQVNFfSIgIiR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS8ke1RFU1R9IgogICAgICBXT1JLSU5HX0RJUkVDVE9SWSAiJHtDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVJ9IiBTT1VSQ0VTICIke1RFU1R9IikKICBlbmRmb3JlYWNoKFRFU1QgJHtURVNUU30pCmVuZGlmKERPX1RFU1RTKQoKY2hlY2tfY19zb3VyY2VfcnVucygKICAiICMgaW5jbHVkZSA8c3RkYm9vbC5oPlxuYm9vbCBmb28oaW50IGEsIGludCBiLCBpbnQgKmMpIHtcbiAgIHJldHVybiBfX2J1aWx0aW5fbXVsX292ZXJmbG93KGEsIGIsCiAgICAjIGMpO1xufVxuaW50IG1haW4oKSB7XG4gICBpbnQgb3V0O1xuICAgaWYgKGZvbygxLCAyLCAmb3V0KSkge1xuICAgICAgIHJldHVybiAwO1xuICAgfVxuIHJldHVybgogICAgIyAwO1xufSIgSEFWRV9fQlVJTFRJTl9NVUxfT1ZFUkZMT1cpCmlmKEhBVkVfX0JVSUxUSU5fTVVMX09WRVJGTE9XKQogIGFkZF9kZWZpbml0aW9ucygtREhBVkVfX0JVSUxUSU5fTVVMX09WRVJGTE9XKQplbmRpZihIQVZFX19CVUlMVElOX01VTF9PVkVSRkxPVykKCmFkZHByZWZpeChTSEFSRURfVEFSR0VUUyAicWpzLSIgJHtRVUlDS0pTX01PRFVMRVN9KQphZGRzdWZmaXgoU1RBVElDX1RBUkdFVFMgIi1zdGF0aWMiICR7U0hBUkVEX1RBUkdFVFN9KQoKIyBkdW1wKFNUQVRJQ19UQVJHRVRTKQp1bnNldChRSlNNX0xEQUREKQoKc2V0KFFKU01fTElCRElSICIke0NNQUtFX0NVUlJFTlRfQklOQVJZX0RJUn0iKQoKZm9yZWFjaChKU19NT0RVTEUgJHtRVUlDS0pTX01PRFVMRVN9KQogIG1ha2VfbW9kdWxlKCR7SlNfTU9EVUxFfSkKICBzdHJpbmcoUkVHRVggUkVQTEFDRSAiLSIgIl8iIFFKU01fTU9EVUxFICIke0pTX01PRFVMRX0iKQogIGxpc3QoQVBQRU5EIFFKU01fTERBREQgIiR7UUpTTV9NT0RVTEV9LmEiKQplbmRmb3JlYWNoKEpTX01PRFVMRSAke1FVSUNLSlNfTU9EVUxFU30pCgpkdW1wKFFKU01fTERBREQgUUpTTV9MSUJESVIpCgp0YXJnZXRfbGlua19saWJyYXJpZXMocWpzLWRlZXAgcWpzLXByZWRpY2F0ZSkKdGFyZ2V0X2xpbmtfbGlicmFyaWVzKHFqcy1sZXhlciBxanMtcHJlZGljYXRlKQphZGRfZGVwZW5kZW5jaWVzKHFqcy1sZXhlciBxanMtcHJlZGljYXRlKQoKZmlsZShHTE9CIFRFU1RTX1NPVVJDRVMgdGVzdHMvdGVzdF8qLmpzKQpsaXN0KEZJTFRFUiBURVNUU19TT1VSQ0VTIEVYQ0xVREUgUkVHRVggInRlc3RfbGV4ZXIuanMiKQpzb3VyY2VfZ3JvdXAoVEVTVFNfR1JPVVAgRklMRVMgJHtURVNUU19TT1VSQ0VTfSkKCmluY2x1ZGUoQ1Rlc3QpCgpmb3JlYWNoKFRFU1RfU09VUkNFICR7VEVTVFNfU09VUkNFU30pCiAgZmlsZShSRUxBVElWRV9QQVRIIFRFU1RfU09VUkNFICIke0NNQUtFX0NVUlJFTlRfU09VUkNFX0RJUn0iICIke1RFU1RfU09VUkNFfSIpCiAgYmFzZW5hbWUoVEVTVF9OQU1FICR7VEVTVF9TT1VSQ0V9IC5qcykKICBhZGRfdGVzdChOQU1FICIke1RFU1RfTkFNRX0iIENPTU1BTkQgcWpzbSAtLWJpZ251bSAiJHtURVNUX1NPVVJDRX0iIFdPUktJTkdfRElSRUNUT1JZICIke0NNQUtFX0NVUlJFTlRfU09VUkNFX0RJUn0iKQoKZW5kZm9yZWFjaChURVNUX1NPVVJDRSAke1RFU1RTX1NPVVJDRVN9KQoKZmlsZShHTE9CIExJQkpTICIke0NNQUtFX0NVUlJFTlRfU09VUkNFX0RJUn0vbGliLyouanMiKQpsaXN0KEZJTFRFUiBMSUJKUyBFWENMVURFIFJFR0VYICJsaWIvcmVxdWlyZS5qc3xsaWIvZnMuanMiKQoKaW5zdGFsbChGSUxFUyAke0xJQkpTfSBERVNUSU5BVElPTiAiJHtRVUlDS0pTX0xJQlJBUllfRElSfS9xdWlja2pzIikKCnNldChMSUJfTU9EVUxFUyBjb25zb2xlIGV2ZW50cyBmcyBwZXJmX2hvb2tzIHByb2Nlc3MgcmVwbCByZXF1aXJlIHR0eSB1dGlsKQoKc3RyaW5nKFJFR0VYIFJFUExBQ0UgIlteQS1aYS16MC05X10iICI7IiBCVUlMVElOX0xJQlMgIiR7TElCX01PRFVMRVN9IikKCiMgdGFyZ2V0X2NvbXBpbGVfZGVmaW5pdGlvbnMocWpzbSAtREJVSUxUSU5fTU9EVUxFUz1cXFwiJHtCVUlMVElOX0xJQlN9XFxcIikgbWVzc2FnZSgiJHtCVUlMVElOX0xJQlN9IgoKbGlzdChBUFBFTkQgQ01BS0VfRklORF9MSUJSQVJZX1BSRUZJWEVTICIiKQoKZm9yZWFjaChMSUJfTU9EVUxFICR7TElCX01PRFVMRVN9KQogICMgbWVzc2FnZSgiQ29tcGlsZSBNb2R1bGU6ICR7TElCX01PRFVMRX0iKQogIGNvbXBpbGVfbW9kdWxlKGxpYi8ke0xJQl9NT0RVTEV9LmpzKQplbmRmb3JlYWNoKExJQl9NT0RVTEUgJHtMSUJfTU9EVUxFU30pCgppZihFWElTVFMgJHtDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVJ9Ly4uL2RlZnMuY21ha2UpCiAgc2V0KFFVSUNLSlNfU09VUkNFU19ST09UICR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS8uLikKCiAgaW5jbHVkZSgke1FVSUNLSlNfU09VUkNFU19ST09UfS9kZWZzLmNtYWtlKQogIGluY2x1ZGUoJHtRVUlDS0pTX1NPVVJDRVNfUk9PVH0vY21ha2UvY2hlY2stbGlicmFyaWVzLmNtYWtlKQoKICBhZGRfY3VzdG9tX2NvbW1hbmQoCiAgICBPVVRQVVQgJHtNT0RVTEVTX0RJUn0vcWpzY2FsYy5jCiAgICBDT01NQU5EICR7UUpTQ30gLWZiaWdudW0gLWMgLW8gJHtNT0RVTEVTX0RJUn0vcWpzY2FsYy5jIC1tICR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS8uLi9xanNjYWxjLmpzCiAgICBERVBFTkRTICR7UUpTQ19ERVBTfQogICAgV09SS0lOR19ESVJFQ1RPUlkgJHtDTUFLRV9DVVJSRU5UX0JJTkFSWV9ESVJ9CiAgICBDT01NRU5UICJHZW5lcmF0ZSBmcm9tIHFqc2NhbGMuanMgdXNpbmcgcWpzIGNvbXBpbGVyIiBTT1VSQ0VTICR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS8uLi9xanNjYWxjLmpzKQoKICBzZXQoUUpTTV9TT1VSQ0VTCiAgICAgIHFqc20uYyB2ZWN0b3IuYyAke01PRFVMRVNfRElSfS9yZXBsLmMgJHtNT0RVTEVTX0RJUn0vcWpzY2FsYy5jICR7TU9EVUxFU19ESVJ9L2NvbnNvbGUuYyAke01PRFVMRVNfRElSfS9ldmVudHMuYwogICAgICAke01PRFVMRVNfRElSfS9yZXF1aXJlLmMgJHtNT0RVTEVTX0RJUn0vZnMuYyAke01PRFVMRVNfRElSfS9wZXJmX2hvb2tzLmMgJHtNT0RVTEVTX0RJUn0vcHJvY2Vzcy5jCiAgICAgICR7TU9EVUxFU19ESVJ9L3R0eS5jICR7TU9EVUxFU19ESVJ9L3V0aWwuYyAke1FKU01fRVhUUkFfU09VUkNFU30pCgogIGlmKEVYSVNUUyAke0NNQUtFX0NVUlJFTlRfU09VUkNFX0RJUn0vLi4vcXVpY2tqcy1kZWJ1Z2dlci5jKQogICAgaWYoUVVJQ0tKU19ERUJVR0dFUikKICAgICAgc2V0KFFKU01fU09VUkNFUyAke1FKU01fU09VUkNFU30gJHtDTUFLRV9DVVJSRU5UX1NPVVJDRV9ESVJ9Ly4uL3F1aWNranMtZGVidWdnZXIuYwogICAgICAgICAgICAgICAgICAgICAgICR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS8uLi9xdWlja2pzLWRlYnVnZ2VyLXRyYW5zcG9ydC0ke1RSQU5TUE9SVF9QTEFURk9STX0uYykKICAgIGVuZGlmKFFVSUNLSlNfREVCVUdHRVIpCiAgZW5kaWYoRVhJU1RTICR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS8uLi9xdWlja2pzLWRlYnVnZ2VyLmMpCgogIGR1bXAoUUpTTV9TT1VSQ0VTKQogIGFkZF9leGVjdXRhYmxlKHFqc20gJHtRSlNNX1NPVVJDRVN9KQoKICAjIGR1bXAoUUpTX01PRFVMRVNfU1RBVElDKQogIGlmKFFKU19NT0RVTEVTX1NUQVRJQykKICAgIGFkZF9kZXBlbmRlbmNpZXMocWpzbSAke1FKU19NT0RVTEVTX1NUQVRJQ30pCiAgZW5kaWYoUUpTX01PRFVMRVNfU1RBVElDKQoKICAjIHRhcmdldF9saW5rX2xpYnJhcmllcyhxanNtIHF1aWNranMgJHtRSlNNX0xEQUREfSAke0xJQlBUSFJFQUR9ICR7TElCTX0gJHtMSUJETH0gJHtMSUJXUzJfMzJ9KQoKICAjIHRhcmdldF9saW5rX2xpYnJhcmllcyhxanMgJHtRVUlDS0pTX0xJQlJBUll9KQogIHRhcmdldF9saW5rX2RpcmVjdG9yaWVzKHFqc20gUFVCTElDICR7UUpTTV9MSUJESVJ9ICR7Q01BS0VfQ1VSUkVOVF9CSU5BUllfRElSfSkKICB0YXJnZXRfbGlua19saWJyYXJpZXMocWpzbSBxdWlja2pzICR7UUpTTV9MREFERH0gJHtMSUJQVEhSRUFEfSAke0xJQk19ICR7TElCREx9ICR7TElCV1MyXzMyfSkKICBzZXRfdGFyZ2V0X3Byb3BlcnRpZXMocWpzbSBQUk9QRVJUSUVTIExJTktfT1BUSU9OUyAiJHtMSU5LX0VYUE9SVH0iIENPTVBJTEVfRkxBR1MgIi13IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUlBBVEggIiR7UVVJQ0tKU19JTlNUQUxMX1BSRUZJWH0vbGliL3F1aWNranMiKQoKICB0YXJnZXRfY29tcGlsZV9kZWZpbml0aW9ucyhxanNtIFBSSVZBVEUgQ09ORklHX1ZFUlNJT049IiR7UVVJQ0tKU19WRVJTSU9OfSIgX0dOVV9TT1VSQ0U9MQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT05GSUdfUFJFRklYPSIke1FVSUNLSlNfSU5TVEFMTF9QUkVGSVh9IiBDT05GSUdfQklHTlVNPTEpCiAgaW5zdGFsbChUQVJHRVRTIHFqc20gREVTVElOQVRJT04gYmluKQoKZW5kaWYoRVhJU1RTICR7Q01BS0VfQ1VSUkVOVF9TT1VSQ0VfRElSfS8uLi9kZWZzLmNtYWtlKQoAAAAAAAAAAN8nAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAxwoAAAAAAADHCgAAAAAAAAAAAAAAAAAA"
				]
			]
		},
		{
			"contents": "/*\n * QuickJS Javascript Engine\n * \n * Copyright (c) 2017-2021 Fabrice Bellard\n * Copyright (c) 2017-2021 Charlie Gordon\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <string.h>\n#include <assert.h>\n#include <sys/time.h>\n#include <time.h>\n#include <fenv.h>\n#include <math.h>\n#if defined(__APPLE__)\n#include <malloc/malloc.h>\n#elif defined(__linux__)\n#include <malloc.h>\n#elif defined(__FreeBSD__)\n#include <malloc_np.h>\n#endif\n\n#ifdef HAVE_QUICKJS_CONFIG_H\n#include \"quickjs-config.h\"\n#endif\n\n#include \"cutils.h\"\n#include \"list.h\"\n#include \"quickjs.h\"\n#include \"quickjs-debugger.h\"\n#include \"libregexp.h\"\n#ifdef CONFIG_BIGNUM\n#include \"libbf.h\"\n#endif\n\n#define OPTIMIZE         1\n#define SHORT_OPCODES    1\n#if defined(EMSCRIPTEN) || defined(__wasi__)\n#define DIRECT_DISPATCH  0\n#else\n#define DIRECT_DISPATCH  1\n#endif\n\n#if defined(__APPLE__)\n#define MALLOC_OVERHEAD  0\n#else\n#define MALLOC_OVERHEAD  8\n#endif\n\n#if !defined(_WIN32)\n/* define it if printf uses the RNDN rounding mode instead of RNDNA */\n#define CONFIG_PRINTF_RNDN\n#endif\n\n/* define to include Atomics.* operations which depend on the OS\n   threads */\n#if !defined(EMSCRIPTEN) && !defined(CONFIG_ATOMICS) && !defined(__wasi__)\n#define CONFIG_ATOMICS\n#endif\n\n#if !defined(EMSCRIPTEN) && !defined(CONFIG_STACK_CHECK) && !defined(__wasi__)\n/* enable stack limitation */\n#define CONFIG_STACK_CHECK\n#endif\n\n\n/* dump object free */\n//#define DUMP_FREE\n//#define DUMP_CLOSURE\n/* dump the bytecode of the compiled functions: combination of bits\n   1: dump pass 3 final byte code\n   2: dump pass 2 code\n   4: dump pass 1 code\n   8: dump stdlib functions\n  16: dump bytecode in hex\n  32: dump line number table\n */\n//#define DUMP_BYTECODE  (1)\n/* dump the occurence of the automatic GC */\n//#define DUMP_GC\n/* dump objects freed by the garbage collector */\n//#define DUMP_GC_FREE\n/* dump objects leaking when freeing the runtime */\n//#define DUMP_LEAKS  1\n/* dump memory usage before running the garbage collector */\n//#define DUMP_MEM\n//#define DUMP_OBJECTS    /* dump objects in JS_FreeContext */\n//#define DUMP_ATOMS      /* dump atoms in JS_FreeContext */\n//#define DUMP_SHAPES     /* dump shapes in JS_FreeContext */\n//#define DUMP_MODULE_RESOLVE\n//#define DUMP_PROMISE\n//#define DUMP_READ_OBJECT\n\n/* test the GC by forcing it before each object allocation */\n//#define FORCE_GC_AT_MALLOC\n\n#ifdef CONFIG_ATOMICS\n#include <pthread.h>\n#include <stdatomic.h>\n#include <errno.h>\n#endif\n\nenum {\n    /* classid tag        */    /* union usage   | properties */\n    JS_CLASS_OBJECT = 1,        /* must be first */\n    JS_CLASS_ARRAY,             /* u.array       | length */\n    JS_CLASS_ERROR,\n    JS_CLASS_NUMBER,            /* u.object_data */\n    JS_CLASS_STRING,            /* u.object_data */\n    JS_CLASS_BOOLEAN,           /* u.object_data */\n    JS_CLASS_SYMBOL,            /* u.object_data */\n    JS_CLASS_ARGUMENTS,         /* u.array       | length */\n    JS_CLASS_MAPPED_ARGUMENTS,  /*               | length */\n    JS_CLASS_DATE,              /* u.object_data */\n    JS_CLASS_MODULE_NS,\n    JS_CLASS_C_FUNCTION,        /* u.cfunc */\n    JS_CLASS_BYTECODE_FUNCTION, /* u.func */\n    JS_CLASS_BOUND_FUNCTION,    /* u.bound_function */\n    JS_CLASS_C_FUNCTION_DATA,   /* u.c_function_data_record */\n    JS_CLASS_C_CLOSURE,         /* u.c_closure_record */\n    JS_CLASS_GENERATOR_FUNCTION, /* u.func */\n    JS_CLASS_FOR_IN_ITERATOR,   /* u.for_in_iterator */\n    JS_CLASS_REGEXP,            /* u.regexp */\n    JS_CLASS_ARRAY_BUFFER,      /* u.array_buffer */\n    JS_CLASS_SHARED_ARRAY_BUFFER, /* u.array_buffer */\n    JS_CLASS_UINT8C_ARRAY,      /* u.array (typed_array) */\n    JS_CLASS_INT8_ARRAY,        /* u.array (typed_array) */\n    JS_CLASS_UINT8_ARRAY,       /* u.array (typed_array) */\n    JS_CLASS_INT16_ARRAY,       /* u.array (typed_array) */\n    JS_CLASS_UINT16_ARRAY,      /* u.array (typed_array) */\n    JS_CLASS_INT32_ARRAY,       /* u.array (typed_array) */\n    JS_CLASS_UINT32_ARRAY,      /* u.array (typed_array) */\n#ifdef CONFIG_BIGNUM\n    JS_CLASS_BIG_INT64_ARRAY,   /* u.array (typed_array) */\n    JS_CLASS_BIG_UINT64_ARRAY,  /* u.array (typed_array) */\n#endif\n    JS_CLASS_FLOAT32_ARRAY,     /* u.array (typed_array) */\n    JS_CLASS_FLOAT64_ARRAY,     /* u.array (typed_array) */\n    JS_CLASS_DATAVIEW,          /* u.typed_array */\n#ifdef CONFIG_BIGNUM\n    JS_CLASS_BIG_INT,           /* u.object_data */\n    JS_CLASS_BIG_FLOAT,         /* u.object_data */\n    JS_CLASS_FLOAT_ENV,         /* u.float_env */\n    JS_CLASS_BIG_DECIMAL,       /* u.object_data */\n    JS_CLASS_OPERATOR_SET,      /* u.operator_set */\n#endif\n    JS_CLASS_MAP,               /* u.map_state */\n    JS_CLASS_SET,               /* u.map_state */\n    JS_CLASS_WEAKMAP,           /* u.map_state */\n    JS_CLASS_WEAKSET,           /* u.map_state */\n    JS_CLASS_MAP_ITERATOR,      /* u.map_iterator_data */\n    JS_CLASS_SET_ITERATOR,      /* u.map_iterator_data */\n    JS_CLASS_ARRAY_ITERATOR,    /* u.array_iterator_data */\n    JS_CLASS_STRING_ITERATOR,   /* u.array_iterator_data */\n    JS_CLASS_REGEXP_STRING_ITERATOR,   /* u.regexp_string_iterator_data */\n    JS_CLASS_GENERATOR,         /* u.generator_data */\n    JS_CLASS_PROXY,             /* u.proxy_data */\n    JS_CLASS_PROMISE,           /* u.promise_data */\n    JS_CLASS_PROMISE_RESOLVE_FUNCTION,  /* u.promise_function_data */\n    JS_CLASS_PROMISE_REJECT_FUNCTION,   /* u.promise_function_data */\n    JS_CLASS_ASYNC_FUNCTION,            /* u.func */\n    JS_CLASS_ASYNC_FUNCTION_RESOLVE,    /* u.async_function_data */\n    JS_CLASS_ASYNC_FUNCTION_REJECT,     /* u.async_function_data */\n    JS_CLASS_ASYNC_FROM_SYNC_ITERATOR,  /* u.async_from_sync_iterator_data */\n    JS_CLASS_ASYNC_GENERATOR_FUNCTION,  /* u.func */\n    JS_CLASS_ASYNC_GENERATOR,   /* u.async_generator_data */\n\n    JS_CLASS_INIT_COUNT, /* last entry for predefined classes */\n};\n\n/* number of typed array types */\n#define JS_TYPED_ARRAY_COUNT  (JS_CLASS_FLOAT64_ARRAY - JS_CLASS_UINT8C_ARRAY + 1)\nstatic uint8_t const typed_array_size_log2[JS_TYPED_ARRAY_COUNT];\n#define typed_array_size_log2(classid)  (typed_array_size_log2[(classid)- JS_CLASS_UINT8C_ARRAY])\n\ntypedef enum JSErrorEnum {\n    JS_EVAL_ERROR,\n    JS_RANGE_ERROR,\n    JS_REFERENCE_ERROR,\n    JS_SYNTAX_ERROR,\n    JS_TYPE_ERROR,\n    JS_URI_ERROR,\n    JS_INTERNAL_ERROR,\n    JS_AGGREGATE_ERROR,\n    \n    JS_NATIVE_ERROR_COUNT, /* number of different NativeError objects */\n} JSErrorEnum;\n\n#define JS_MAX_LOCAL_VARS 65536\n#define JS_STACK_SIZE_MAX 65534\n#define JS_STRING_LEN_MAX ((1 << 30) - 1)\n\n#define __exception __attribute__((warn_unused_result))\n\ntypedef struct JSShape JSShape;\ntypedef struct JSString JSString;\ntypedef struct JSString JSAtomStruct;\n\ntypedef enum {\n    JS_GC_PHASE_NONE,\n    JS_GC_PHASE_DECREF,\n    JS_GC_PHASE_REMOVE_CYCLES,\n} JSGCPhaseEnum;\n\ntypedef enum OPCodeEnum OPCodeEnum;\n\n#ifdef CONFIG_BIGNUM\n/* function pointers are used for numeric operations so that it is\n   possible to remove some numeric types */\ntypedef struct {\n    JSValue (*to_string)(JSContext *ctx, JSValueConst val);\n    JSValue (*from_string)(JSContext *ctx, const char *buf,\n                           int radix, int flags, slimb_t *pexponent);\n    int (*unary_arith)(JSContext *ctx,\n                       JSValue *pres, OPCodeEnum op, JSValue op1);\n    int (*binary_arith)(JSContext *ctx, OPCodeEnum op,\n                        JSValue *pres, JSValue op1, JSValue op2);\n    int (*compare)(JSContext *ctx, OPCodeEnum op,\n                   JSValue op1, JSValue op2);\n    /* only for bigfloat: */\n    JSValue (*mul_pow10_to_float64)(JSContext *ctx, const bf_t *a,\n                                    int64_t exponent);\n    int (*mul_pow10)(JSContext *ctx, JSValue *sp);\n} JSNumericOperations;\n#endif\n\nstruct JSRuntime {\n    JSMallocFunctions mf;\n    JSMallocState malloc_state;\n    const char *rt_info;\n\n    int atom_hash_size; /* power of two */\n    int atom_count;\n    int atom_size;\n    int atom_count_resize; /* resize hash table at this count */\n    uint32_t *atom_hash;\n    JSAtomStruct **atom_array;\n    int atom_free_index; /* 0 = none */\n\n    int class_count;    /* size of class_array */\n    JSClass *class_array;\n\n    struct list_head context_list; /* list of JSContext.link */\n    /* list of JSGCObjectHeader.link. List of allocated GC objects (used\n       by the garbage collector) */\n    struct list_head gc_obj_list;\n    /* list of JSGCObjectHeader.link. Used during JS_FreeValueRT() */\n    struct list_head gc_zero_ref_count_list; \n    struct list_head tmp_obj_list; /* used during GC */\n    JSGCPhaseEnum gc_phase : 8;\n    size_t malloc_gc_threshold;\n#ifdef DUMP_LEAKS\n    struct list_head string_list; /* list of JSString.link */\n#endif\n    /* stack limitation */\n    uintptr_t stack_size; /* in bytes, 0 if no limit */\n    uintptr_t stack_top;\n    uintptr_t stack_limit; /* lower stack limit */\n    \n    JSValue current_exception;\n    /* true if inside an out of memory error, to avoid recursing */\n    BOOL in_out_of_memory : 8;\n\n    struct JSStackFrame *current_stack_frame;\n\n    JSInterruptHandler *interrupt_handler;\n    void *interrupt_opaque;\n\n    JSHostPromiseRejectionTracker *host_promise_rejection_tracker;\n    void *host_promise_rejection_tracker_opaque;\n    \n    struct list_head job_list; /* list of JSJobEntry.link */\n\n    JSModuleNormalizeFunc *module_normalize_func;\n    JSModuleLoaderFunc *module_loader_func;\n    void *module_loader_opaque;\n\n    BOOL can_block : 8; /* TRUE if Atomics.wait can block */\n    /* used to allocate, free and clone SharedArrayBuffers */\n    JSSharedArrayBufferFunctions sab_funcs;\n    \n    /* Shape hash table */\n    int shape_hash_bits;\n    int shape_hash_size;\n    int shape_hash_count; /* number of hashed shapes */\n    JSShape **shape_hash;\n#ifdef CONFIG_BIGNUM\n    bf_context_t bf_ctx;\n    JSNumericOperations bigint_ops;\n    JSNumericOperations bigfloat_ops;\n    JSNumericOperations bigdecimal_ops;\n    uint32_t operator_count;\n#endif\n    void *user_opaque;\n\n    JSDebuggerInfo debugger_info;\n};\n\nstruct JSClass {\n    uint32_t class_id; /* 0 means free entry */\n    JSAtom class_name;\n    JSClassFinalizer *finalizer;\n    JSClassGCMark *gc_mark;\n    JSClassCall *call;\n    /* pointers for exotic behavior, can be NULL if none are present */\n    const JSClassExoticMethods *exotic;\n};\n\n#define JS_MODE_STRICT (1 << 0)\n#define JS_MODE_STRIP  (1 << 1)\n#define JS_MODE_MATH   (1 << 2)\n\ntypedef struct JSStackFrame {\n    struct JSStackFrame *prev_frame; /* NULL if first stack frame */\n    JSValue cur_func; /* current function, JS_UNDEFINED if the frame is detached */\n    JSValue *arg_buf; /* arguments */\n    JSValue *var_buf; /* variables */\n    struct list_head var_ref_list; /* list of JSVarRef.link */\n    const uint8_t *cur_pc; /* only used in bytecode functions : PC of the\n                        instruction after the call */\n    int arg_count;\n    int js_mode; /* 0 or JS_MODE_MATH for C functions */\n    /* only used in generators. Current stack pointer value. NULL if\n       the function is running. */ \n    JSValue *cur_sp;\n} JSStackFrame;\n\ntypedef enum {\n    JS_GC_OBJ_TYPE_JS_OBJECT,\n    JS_GC_OBJ_TYPE_FUNCTION_BYTECODE,\n    JS_GC_OBJ_TYPE_SHAPE,\n    JS_GC_OBJ_TYPE_VAR_REF,\n    JS_GC_OBJ_TYPE_ASYNC_FUNCTION,\n    JS_GC_OBJ_TYPE_JS_CONTEXT,\n} JSGCObjectTypeEnum;\n\n/* header for GC objects. GC objects are C data structures with a\n   reference count that can reference other GC objects. JS Objects are\n   a particular type of GC object. */\nstruct JSGCObjectHeader {\n    int ref_count; /* must come first, 32-bit */\n    JSGCObjectTypeEnum gc_obj_type : 4;\n    uint8_t mark : 4; /* used by the GC */\n    uint8_t dummy1; /* not used by the GC */\n    uint16_t dummy2; /* not used by the GC */\n    struct list_head link;\n};\n\ntypedef struct JSVarRef {\n    union {\n        JSGCObjectHeader header; /* must come first */\n        struct {\n            int __gc_ref_count; /* corresponds to header.ref_count */\n            uint8_t __gc_mark; /* corresponds to header.mark/gc_obj_type */\n\n            /* 0 : the JSVarRef is on the stack. header.link is an element\n               of JSStackFrame.var_ref_list.\n               1 : the JSVarRef is detached. header.link has the normal meanning \n            */\n            uint8_t is_detached : 1; \n            uint8_t is_arg : 1;\n            uint16_t var_idx; /* index of the corresponding function variable on\n                                 the stack */\n        };\n    };\n    JSValue *pvalue; /* pointer to the value, either on the stack or\n                        to 'value' */\n    JSValue value; /* used when the variable is no longer on the stack */\n} JSVarRef;\n\n#ifdef CONFIG_BIGNUM\ntypedef struct JSFloatEnv {\n    limb_t prec;\n    bf_flags_t flags;\n    unsigned int status;\n} JSFloatEnv;\n\n/* the same structure is used for big integers and big floats. Big\n   integers are never infinite or NaNs */\ntypedef struct JSBigFloat {\n    JSRefCountHeader header; /* must come first, 32-bit */\n    bf_t num;\n} JSBigFloat;\n\ntypedef struct JSBigDecimal {\n    JSRefCountHeader header; /* must come first, 32-bit */\n    bfdec_t num;\n} JSBigDecimal;\n#endif\n\ntypedef enum {\n    JS_AUTOINIT_ID_PROTOTYPE,\n    JS_AUTOINIT_ID_MODULE_NS,\n    JS_AUTOINIT_ID_PROP,\n} JSAutoInitIDEnum;\n\n/* must be large enough to have a negligible runtime cost and small\n   enough to call the interrupt callback often. */\n#define JS_INTERRUPT_COUNTER_INIT 10000\n\nstruct JSContext {\n    JSGCObjectHeader header; /* must come first */\n    JSRuntime *rt;\n    struct list_head link;\n\n    uint16_t binary_object_count;\n    int binary_object_size;\n\n    JSShape *array_shape;   /* initial shape for Array objects */\n\n    JSValue *class_proto;\n    JSValue function_proto;\n    JSValue function_ctor;\n    JSValue array_ctor;\n    JSValue regexp_ctor;\n    JSValue promise_ctor;\n    JSValue native_error_proto[JS_NATIVE_ERROR_COUNT];\n    JSValue iterator_proto;\n    JSValue async_iterator_proto;\n    JSValue array_proto_values;\n    JSValue throw_type_error;\n    JSValue eval_obj;\n\n    JSValue global_obj; /* global object */\n    JSValue global_var_obj; /* contains the global let/const definitions */\n\n    uint64_t random_state;\n#ifdef CONFIG_BIGNUM\n    bf_context_t *bf_ctx;   /* points to rt->bf_ctx, shared by all contexts */\n    JSFloatEnv fp_env; /* global FP environment */\n    BOOL bignum_ext : 8; /* enable math mode */\n    BOOL allow_operator_overloading : 8;\n#endif\n    /* when the counter reaches zero, JSRutime.interrupt_handler is called */\n    int interrupt_counter;\n    BOOL is_error_property_enabled;\n\n    struct list_head loaded_modules; /* list of JSModuleDef.link */\n\n    /* if NULL, RegExp compilation is not supported */\n    JSValue (*compile_regexp)(JSContext *ctx, JSValueConst pattern,\n                              JSValueConst flags);\n    /* if NULL, eval is not supported */\n    JSValue (*eval_internal)(JSContext *ctx, JSValueConst this_obj,\n                             const char *input, size_t input_len,\n                             const char *filename, int flags, int scope_idx);\n    void *user_opaque;\n};\n\ntypedef union JSFloat64Union {\n    double d;\n    uint64_t u64;\n    uint32_t u32[2];\n} JSFloat64Union;\n\nenum {\n    JS_ATOM_TYPE_STRING = 1,\n    JS_ATOM_TYPE_GLOBAL_SYMBOL,\n    JS_ATOM_TYPE_SYMBOL,\n    JS_ATOM_TYPE_PRIVATE,\n};\n\nenum {\n    JS_ATOM_HASH_SYMBOL,\n    JS_ATOM_HASH_PRIVATE,\n};\n\ntypedef enum {\n    JS_ATOM_KIND_STRING,\n    JS_ATOM_KIND_SYMBOL,\n    JS_ATOM_KIND_PRIVATE,\n} JSAtomKindEnum;\n\n#define JS_ATOM_HASH_MASK  ((1 << 30) - 1)\n\nstruct JSString {\n    JSRefCountHeader header; /* must come first, 32-bit */\n    uint32_t len : 31;\n    uint8_t is_wide_char : 1; /* 0 = 8 bits, 1 = 16 bits characters */\n    /* for JS_ATOM_TYPE_SYMBOL: hash = 0, atom_type = 3,\n       for JS_ATOM_TYPE_PRIVATE: hash = 1, atom_type = 3\n       XXX: could change encoding to have one more bit in hash */\n    uint32_t hash : 30;\n    uint8_t atom_type : 2; /* != 0 if atom, JS_ATOM_TYPE_x */\n    uint32_t hash_next; /* atom_index for JS_ATOM_TYPE_SYMBOL */\n#ifdef DUMP_LEAKS\n    struct list_head link; /* string list */\n#endif\n    union {\n        uint8_t str8[0]; /* 8 bit strings will get an extra null terminator */\n        uint16_t str16[0];\n    } u;\n};\n\ntypedef struct JSClosureVar {\n    uint8_t is_local : 1;\n    uint8_t is_arg : 1;\n    uint8_t is_const : 1;\n    uint8_t is_lexical : 1;\n    uint8_t var_kind : 4; /* see JSVarKindEnum */\n    /* 8 bits available */\n    uint16_t var_idx; /* is_local = TRUE: index to a normal variable of the\n                    parent function. otherwise: index to a closure\n                    variable of the parent function */\n    JSAtom var_name;\n} JSClosureVar;\n\n#define ARG_SCOPE_INDEX 1\n#define ARG_SCOPE_END (-2)\n\ntypedef struct JSVarScope {\n    int parent;  /* index into fd->scopes of the enclosing scope */\n    int first;   /* index into fd->vars of the last variable in this scope */\n} JSVarScope;\n\ntypedef enum {\n    /* XXX: add more variable kinds here instead of using bit fields */\n    JS_VAR_NORMAL,\n    JS_VAR_FUNCTION_DECL, /* lexical var with function declaration */\n    JS_VAR_NEW_FUNCTION_DECL, /* lexical var with async/generator\n                                 function declaration */\n    JS_VAR_CATCH,\n    JS_VAR_FUNCTION_NAME, /* function expression name */\n    JS_VAR_PRIVATE_FIELD,\n    JS_VAR_PRIVATE_METHOD,\n    JS_VAR_PRIVATE_GETTER,\n    JS_VAR_PRIVATE_SETTER, /* must come after JS_VAR_PRIVATE_GETTER */\n    JS_VAR_PRIVATE_GETTER_SETTER, /* must come after JS_VAR_PRIVATE_SETTER */\n} JSVarKindEnum;\n\n/* XXX: could use a different structure in bytecode functions to save\n   memory */\ntypedef struct JSVarDef {\n    JSAtom var_name;\n    /* index into fd->scopes of this variable lexical scope */\n    int scope_level;\n    /* during compilation: \n        - if scope_level = 0: scope in which the variable is defined\n        - if scope_level != 0: index into fd->vars of the next\n          variable in the same or enclosing lexical scope\n       in a bytecode function:\n       index into fd->vars of the next\n       variable in the same or enclosing lexical scope\n    */\n    int scope_next;    \n    uint8_t is_const : 1;\n    uint8_t is_lexical : 1;\n    uint8_t is_captured : 1;\n    uint8_t var_kind : 4; /* see JSVarKindEnum */\n    /* only used during compilation: function pool index for lexical\n       variables with var_kind =\n       JS_VAR_FUNCTION_DECL/JS_VAR_NEW_FUNCTION_DECL or scope level of\n       the definition of the 'var' variables (they have scope_level =\n       0) */\n    int func_pool_idx : 24; /* only used during compilation : index in\n                               the constant pool for hoisted function\n                               definition */\n} JSVarDef;\n\n/* for the encoding of the pc2line table */\n#define PC2LINE_BASE     (-1)\n#define PC2LINE_RANGE    5\n#define PC2LINE_OP_FIRST 1\n#define PC2LINE_DIFF_PC_MAX ((255 - PC2LINE_OP_FIRST) / PC2LINE_RANGE)\n\ntypedef enum JSFunctionKindEnum {\n    JS_FUNC_NORMAL = 0,\n    JS_FUNC_GENERATOR = (1 << 0),\n    JS_FUNC_ASYNC = (1 << 1),\n    JS_FUNC_ASYNC_GENERATOR = (JS_FUNC_GENERATOR | JS_FUNC_ASYNC),\n} JSFunctionKindEnum;\n\ntypedef struct JSFunctionBytecode {\n    JSGCObjectHeader header; /* must come first */\n    uint8_t js_mode;\n    uint8_t has_prototype : 1; /* true if a prototype field is necessary */\n    uint8_t has_simple_parameter_list : 1;\n    uint8_t is_derived_class_constructor : 1;\n    /* true if home_object needs to be initialized */\n    uint8_t need_home_object : 1;\n    uint8_t func_kind : 2;\n    uint8_t new_target_allowed : 1;\n    uint8_t super_call_allowed : 1;\n    uint8_t super_allowed : 1;\n    uint8_t arguments_allowed : 1;\n    uint8_t has_debug : 1;\n    uint8_t backtrace_barrier : 1; /* stop backtrace on this function */\n    uint8_t read_only_bytecode : 1;\n    /* XXX: 4 bits available */\n    uint8_t *byte_code_buf; /* (self pointer) */\n    int byte_code_len;\n    JSAtom func_name;\n    JSVarDef *vardefs; /* arguments + local variables (arg_count + var_count) (self pointer) */\n    JSClosureVar *closure_var; /* list of variables in the closure (self pointer) */\n    uint16_t arg_count;\n    uint16_t var_count;\n    uint16_t defined_arg_count; /* for length function property */\n    uint16_t stack_size; /* maximum stack size */\n    JSContext *realm; /* function realm */\n    JSValue *cpool; /* constant pool (self pointer) */\n    int cpool_count;\n    int closure_var_count;\n    struct {\n        /* debug info, move to separate structure to save memory? */\n        JSAtom filename;\n        int line_num;\n        int source_len;\n        int pc2line_len;\n        uint8_t *pc2line_buf;\n        char *source;\n    } debug;\n#ifdef CONFIG_DEBUGGER\n    struct JSDebuggerFunctionInfo debugger;\n#endif\n} JSFunctionBytecode;\n\ntypedef struct JSBoundFunction {\n    JSValue func_obj;\n    JSValue this_val;\n    int argc;\n    JSValue argv[0];\n} JSBoundFunction;\n\ntypedef enum JSIteratorKindEnum {\n    JS_ITERATOR_KIND_KEY,\n    JS_ITERATOR_KIND_VALUE,\n    JS_ITERATOR_KIND_KEY_AND_VALUE,\n} JSIteratorKindEnum;\n\ntypedef struct JSForInIterator {\n    JSValue obj;\n    BOOL is_array;\n    uint32_t array_length;\n    uint32_t idx;\n} JSForInIterator;\n\ntypedef struct JSRegExp {\n    JSString *pattern;\n    JSString *bytecode; /* also contains the flags */\n} JSRegExp;\n\ntypedef struct JSProxyData {\n    JSValue target;\n    JSValue handler;\n    uint8_t is_func;\n    uint8_t is_revoked;\n} JSProxyData;\n\ntypedef struct JSArrayBuffer {\n    int byte_length; /* 0 if detached */\n    uint8_t detached;\n    uint8_t shared; /* if shared, the array buffer cannot be detached */\n    uint8_t *data; /* NULL if detached */\n    struct list_head array_list;\n    void *opaque;\n    JSFreeArrayBufferDataFunc *free_func;\n} JSArrayBuffer;\n\ntypedef struct JSTypedArray {\n    struct list_head link; /* link to arraybuffer */\n    JSObject *obj; /* back pointer to the TypedArray/DataView object */\n    JSObject *buffer; /* based array buffer */\n    uint32_t offset; /* offset in the array buffer */\n    uint32_t length; /* length in the array buffer */\n} JSTypedArray;\n\ntypedef struct JSAsyncFunctionState {\n    JSValue this_val; /* 'this' generator argument */\n    int argc; /* number of function arguments */\n    BOOL throw_flag; /* used to throw an exception in JS_CallInternal() */\n    JSStackFrame frame;\n} JSAsyncFunctionState;\n\n/* XXX: could use an object instead to avoid the\n   JS_TAG_ASYNC_FUNCTION tag for the GC */\ntypedef struct JSAsyncFunctionData {\n    JSGCObjectHeader header; /* must come first */\n    JSValue resolving_funcs[2];\n    BOOL is_active; /* true if the async function state is valid */\n    JSAsyncFunctionState func_state;\n} JSAsyncFunctionData;\n\ntypedef enum {\n   /* binary operators */\n   JS_OVOP_ADD,\n   JS_OVOP_SUB,\n   JS_OVOP_MUL,\n   JS_OVOP_DIV,\n   JS_OVOP_MOD,\n   JS_OVOP_POW,\n   JS_OVOP_OR,\n   JS_OVOP_AND,\n   JS_OVOP_XOR,\n   JS_OVOP_SHL,\n   JS_OVOP_SAR,\n   JS_OVOP_SHR,\n   JS_OVOP_EQ,\n   JS_OVOP_LESS,\n\n   JS_OVOP_BINARY_COUNT,\n   /* unary operators */\n   JS_OVOP_POS = JS_OVOP_BINARY_COUNT,\n   JS_OVOP_NEG,\n   JS_OVOP_INC,\n   JS_OVOP_DEC,\n   JS_OVOP_NOT,\n\n   JS_OVOP_COUNT,\n} JSOverloadableOperatorEnum;\n\ntypedef struct {\n    uint32_t operator_index;\n    JSObject *ops[JS_OVOP_BINARY_COUNT]; /* self operators */\n} JSBinaryOperatorDefEntry;\n\ntypedef struct {\n    int count;\n    JSBinaryOperatorDefEntry *tab;\n} JSBinaryOperatorDef;\n\ntypedef struct {\n    uint32_t operator_counter;\n    BOOL is_primitive; /* OperatorSet for a primitive type */\n    /* NULL if no operator is defined */\n    JSObject *self_ops[JS_OVOP_COUNT]; /* self operators */\n    JSBinaryOperatorDef left;\n    JSBinaryOperatorDef right;\n} JSOperatorSetData;\n\ntypedef struct JSReqModuleEntry {\n    JSAtom module_name;\n    JSModuleDef *module; /* used using resolution */\n} JSReqModuleEntry;\n\ntypedef enum JSExportTypeEnum {\n    JS_EXPORT_TYPE_LOCAL,\n    JS_EXPORT_TYPE_INDIRECT,\n} JSExportTypeEnum;\n\ntypedef struct JSExportEntry {\n    union {\n        struct {\n            int var_idx; /* closure variable index */\n            JSVarRef *var_ref; /* if != NULL, reference to the variable */\n        } local; /* for local export */\n        int req_module_idx; /* module for indirect export */\n    } u;\n    JSExportTypeEnum export_type;\n    JSAtom local_name; /* '*' if export ns from. not used for local\n                          export after compilation */\n    JSAtom export_name; /* exported variable name */\n} JSExportEntry;\n\ntypedef struct JSStarExportEntry {\n    int req_module_idx; /* in req_module_entries */\n} JSStarExportEntry;\n\ntypedef struct JSImportEntry {\n    int var_idx; /* closure variable index */\n    JSAtom import_name;\n    int req_module_idx; /* in req_module_entries */\n} JSImportEntry;\n\nstruct JSModuleDef {\n    JSRefCountHeader header; /* must come first, 32-bit */\n    JSAtom module_name;\n    struct list_head link;\n\n    JSReqModuleEntry *req_module_entries;\n    int req_module_entries_count;\n    int req_module_entries_size;\n\n    JSExportEntry *export_entries;\n    int export_entries_count;\n    int export_entries_size;\n\n    JSStarExportEntry *star_export_entries;\n    int star_export_entries_count;\n    int star_export_entries_size;\n\n    JSImportEntry *import_entries;\n    int import_entries_count;\n    int import_entries_size;\n\n    JSValue module_ns;\n    JSValue func_obj; /* only used for JS modules */\n    JSModuleInitFunc *init_func; /* only used for C modules */\n    BOOL resolved : 8;\n    BOOL func_created : 8;\n    BOOL instantiated : 8;\n    BOOL evaluated : 8;\n    BOOL eval_mark : 8; /* temporary use during js_evaluate_module() */\n    /* true if evaluation yielded an exception. It is saved in\n       eval_exception */\n    BOOL eval_has_exception : 8; \n    JSValue eval_exception;\n    JSValue meta_obj; /* for import.meta */\n};\n\ntypedef struct JSJobEntry {\n    struct list_head link;\n    JSContext *ctx;\n    JSJobFunc *job_func;\n    int argc;\n    JSValue argv[0];\n} JSJobEntry;\n\ntypedef struct JSProperty {\n    union {\n        JSValue value;      /* JS_PROP_NORMAL */\n        struct {            /* JS_PROP_GETSET */\n            JSObject *getter; /* NULL if undefined */\n            JSObject *setter; /* NULL if undefined */\n        } getset;\n        JSVarRef *var_ref;  /* JS_PROP_VARREF */\n        struct {            /* JS_PROP_AUTOINIT */\n            /* in order to use only 2 pointers, we compress the realm\n               and the init function pointer */\n            uintptr_t realm_and_id; /* realm and init_id (JS_AUTOINIT_ID_x)\n                                       in the 2 low bits */\n            void *opaque;\n        } init;\n    } u;\n} JSProperty;\n\n#define JS_PROP_INITIAL_SIZE 2\n#define JS_PROP_INITIAL_HASH_SIZE 4 /* must be a power of two */\n#define JS_ARRAY_INITIAL_SIZE 2\n\ntypedef struct JSShapeProperty {\n    uint32_t hash_next : 26; /* 0 if last in list */\n    uint32_t flags : 6;   /* JS_PROP_XXX */\n    JSAtom atom; /* JS_ATOM_NULL = free property entry */\n} JSShapeProperty;\n\nstruct JSShape {\n    /* hash table of size hash_mask + 1 before the start of the\n       structure (see prop_hash_end()). */\n    JSGCObjectHeader header;\n    /* true if the shape is inserted in the shape hash table. If not,\n       JSShape.hash is not valid */\n    uint8_t is_hashed;\n    /* If true, the shape may have small array index properties 'n' with 0\n       <= n <= 2^31-1. If false, the shape is guaranteed not to have\n       small array index properties */\n    uint8_t has_small_array_index;\n    uint32_t hash; /* current hash value */\n    uint32_t prop_hash_mask;\n    int prop_size; /* allocated properties */\n    int prop_count; /* include deleted properties */\n    int deleted_prop_count;\n    JSShape *shape_hash_next; /* in JSRuntime.shape_hash[h] list */\n    JSObject *proto;\n    JSShapeProperty prop[0]; /* prop_size elements */\n};\n\nstruct JSObject {\n    union {\n        JSGCObjectHeader header;\n        struct {\n            int __gc_ref_count; /* corresponds to header.ref_count */\n            uint8_t __gc_mark; /* corresponds to header.mark/gc_obj_type */\n            \n            uint8_t extensible : 1;\n            uint8_t free_mark : 1; /* only used when freeing objects with cycles */\n            uint8_t is_exotic : 1; /* TRUE if object has exotic property handlers */\n            uint8_t fast_array : 1; /* TRUE if u.array is used for get/put (for JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS and typed arrays) */\n            uint8_t is_constructor : 1; /* TRUE if object is a constructor function */\n            uint8_t is_uncatchable_error : 1; /* if TRUE, error is not catchable */\n            uint8_t tmp_mark : 1; /* used in JS_WriteObjectRec() */\n            uint8_t is_HTMLDDA : 1; /* specific annex B IsHtmlDDA behavior */\n            uint16_t class_id; /* see JS_CLASS_x */\n        };\n    };\n    /* byte offsets: 16/24 */\n    JSShape *shape; /* prototype and property names + flag */\n    JSProperty *prop; /* array of properties */\n    /* byte offsets: 24/40 */\n    struct JSMapRecord *first_weak_ref; /* XXX: use a bit and an external hash table? */\n    /* byte offsets: 28/48 */\n    union {\n        void *opaque;\n        struct JSBoundFunction *bound_function; /* JS_CLASS_BOUND_FUNCTION */\n        struct JSCFunctionDataRecord *c_function_data_record; /* JS_CLASS_C_FUNCTION_DATA */\n        struct JSCClosureRecord *c_closure_record; /* JS_CLASS_C_CLOSURE */\n        struct JSForInIterator *for_in_iterator; /* JS_CLASS_FOR_IN_ITERATOR */\n        struct JSArrayBuffer *array_buffer; /* JS_CLASS_ARRAY_BUFFER, JS_CLASS_SHARED_ARRAY_BUFFER */\n        struct JSTypedArray *typed_array; /* JS_CLASS_UINT8C_ARRAY..JS_CLASS_DATAVIEW */\n#ifdef CONFIG_BIGNUM\n        struct JSFloatEnv *float_env; /* JS_CLASS_FLOAT_ENV */\n        struct JSOperatorSetData *operator_set; /* JS_CLASS_OPERATOR_SET */\n#endif\n        struct JSMapState *map_state;   /* JS_CLASS_MAP..JS_CLASS_WEAKSET */\n        struct JSMapIteratorData *map_iterator_data; /* JS_CLASS_MAP_ITERATOR, JS_CLASS_SET_ITERATOR */\n        struct JSArrayIteratorData *array_iterator_data; /* JS_CLASS_ARRAY_ITERATOR, JS_CLASS_STRING_ITERATOR */\n        struct JSRegExpStringIteratorData *regexp_string_iterator_data; /* JS_CLASS_REGEXP_STRING_ITERATOR */\n        struct JSGeneratorData *generator_data; /* JS_CLASS_GENERATOR */\n        struct JSProxyData *proxy_data; /* JS_CLASS_PROXY */\n        struct JSPromiseData *promise_data; /* JS_CLASS_PROMISE */\n        struct JSPromiseFunctionData *promise_function_data; /* JS_CLASS_PROMISE_RESOLVE_FUNCTION, JS_CLASS_PROMISE_REJECT_FUNCTION */\n        struct JSAsyncFunctionData *async_function_data; /* JS_CLASS_ASYNC_FUNCTION_RESOLVE, JS_CLASS_ASYNC_FUNCTION_REJECT */\n        struct JSAsyncFromSyncIteratorData *async_from_sync_iterator_data; /* JS_CLASS_ASYNC_FROM_SYNC_ITERATOR */\n        struct JSAsyncGeneratorData *async_generator_data; /* JS_CLASS_ASYNC_GENERATOR */\n        struct { /* JS_CLASS_BYTECODE_FUNCTION: 12/24 bytes */\n            /* also used by JS_CLASS_GENERATOR_FUNCTION, JS_CLASS_ASYNC_FUNCTION and JS_CLASS_ASYNC_GENERATOR_FUNCTION */\n            struct JSFunctionBytecode *function_bytecode;\n            JSVarRef **var_refs;\n            JSObject *home_object; /* for 'super' access */\n        } func;\n        struct { /* JS_CLASS_C_FUNCTION: 12/20 bytes */\n            JSContext *realm;\n            JSCFunctionType c_function;\n            uint8_t length;\n            uint8_t cproto;\n            int16_t magic;\n        } cfunc;\n        /* array part for fast arrays and typed arrays */\n        struct { /* JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS, JS_CLASS_UINT8C_ARRAY..JS_CLASS_FLOAT64_ARRAY */\n            union {\n                uint32_t size;          /* JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS */\n                struct JSTypedArray *typed_array; /* JS_CLASS_UINT8C_ARRAY..JS_CLASS_FLOAT64_ARRAY */\n            } u1;\n            union {\n                JSValue *values;        /* JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS */ \n                void *ptr;              /* JS_CLASS_UINT8C_ARRAY..JS_CLASS_FLOAT64_ARRAY */\n                int8_t *int8_ptr;       /* JS_CLASS_INT8_ARRAY */\n                uint8_t *uint8_ptr;     /* JS_CLASS_UINT8_ARRAY, JS_CLASS_UINT8C_ARRAY */\n                int16_t *int16_ptr;     /* JS_CLASS_INT16_ARRAY */\n                uint16_t *uint16_ptr;   /* JS_CLASS_UINT16_ARRAY */\n                int32_t *int32_ptr;     /* JS_CLASS_INT32_ARRAY */\n                uint32_t *uint32_ptr;   /* JS_CLASS_UINT32_ARRAY */\n                int64_t *int64_ptr;     /* JS_CLASS_INT64_ARRAY */\n                uint64_t *uint64_ptr;   /* JS_CLASS_UINT64_ARRAY */\n                float *float_ptr;       /* JS_CLASS_FLOAT32_ARRAY */\n                double *double_ptr;     /* JS_CLASS_FLOAT64_ARRAY */\n            } u;\n            uint32_t count; /* <= 2^31-1. 0 for a detached typed array */\n        } array;    /* 12/20 bytes */\n        JSRegExp regexp;    /* JS_CLASS_REGEXP: 8/16 bytes */\n        JSValue object_data;    /* for JS_SetObjectData(): 8/16/16 bytes */\n    } u;\n    /* byte sizes: 40/48/72 */\n};\nenum {\n    __JS_ATOM_NULL = JS_ATOM_NULL,\n#define DEF(name, str) JS_ATOM_ ## name,\n#include \"quickjs-atom.h\"\n#undef DEF\n    JS_ATOM_END,\n};\n#define JS_ATOM_LAST_KEYWORD JS_ATOM_super\n#define JS_ATOM_LAST_STRICT_KEYWORD JS_ATOM_yield\n\nstatic const char js_atom_init[] =\n#define DEF(name, str) str \"\\0\"\n#include \"quickjs-atom.h\"\n#undef DEF\n;\n\ntypedef enum OPCodeFormat {\n#define FMT(f) OP_FMT_ ## f,\n#define DEF(id, size, n_pop, n_push, f)\n#include \"quickjs-opcode.h\"\n#undef DEF\n#undef FMT\n} OPCodeFormat;\n\nenum OPCodeEnum {\n#define FMT(f)\n#define DEF(id, size, n_pop, n_push, f) OP_ ## id,\n#define def(id, size, n_pop, n_push, f)\n#include \"quickjs-opcode.h\"\n#undef def\n#undef DEF\n#undef FMT\n    OP_COUNT, /* excluding temporary opcodes */\n    /* temporary opcodes : overlap with the short opcodes */\n    OP_TEMP_START = OP_nop + 1,\n    OP___dummy = OP_TEMP_START - 1,\n#define FMT(f)\n#define DEF(id, size, n_pop, n_push, f)\n#define def(id, size, n_pop, n_push, f) OP_ ## id,\n#include \"quickjs-opcode.h\"\n#undef def\n#undef DEF\n#undef FMT\n    OP_TEMP_END,\n};\n\nstatic int JS_InitAtoms(JSRuntime *rt);\nstatic JSAtom __JS_NewAtomInit(JSRuntime *rt, const char *str, int len,\n                               int atom_type);\nstatic void JS_FreeAtomStruct(JSRuntime *rt, JSAtomStruct *p);\nstatic void free_function_bytecode(JSRuntime *rt, JSFunctionBytecode *b);\nstatic JSValue js_call_c_function(JSContext *ctx, JSValueConst func_obj,\n                                  JSValueConst this_obj,\n                                  int argc, JSValueConst *argv, int flags);\nstatic JSValue js_call_bound_function(JSContext *ctx, JSValueConst func_obj,\n                                      JSValueConst this_obj,\n                                      int argc, JSValueConst *argv, int flags);\nstatic JSValue JS_CallInternal(JSContext *ctx, JSValueConst func_obj,\n                               JSValueConst this_obj, JSValueConst new_target,\n                               int argc, JSValue *argv, int flags);\nstatic JSValue JS_CallConstructorInternal(JSContext *ctx,\n                                          JSValueConst func_obj,\n                                          JSValueConst new_target,\n                                          int argc, JSValue *argv, int flags);\nstatic JSValue JS_CallFree(JSContext *ctx, JSValue func_obj, JSValueConst this_obj,\n                           int argc, JSValueConst *argv);\nstatic JSValue JS_InvokeFree(JSContext *ctx, JSValue this_val, JSAtom atom,\n                             int argc, JSValueConst *argv);\nstatic __exception int JS_ToArrayLengthFree(JSContext *ctx, uint32_t *plen,\n                                            JSValue val, BOOL is_array_ctor);\nstatic JSValue JS_EvalObject(JSContext *ctx, JSValueConst this_obj,\n                             JSValueConst val, int flags, int scope_idx);\nJSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);\nstatic __maybe_unused void JS_DumpAtoms(JSRuntime *rt);\nstatic __maybe_unused void JS_DumpString(JSRuntime *rt,\n                                                  const JSString *p);\nstatic __maybe_unused void JS_DumpObjectHeader(JSRuntime *rt);\nstatic __maybe_unused void JS_DumpObject(JSRuntime *rt, JSObject *p);\nstatic __maybe_unused void JS_DumpGCObject(JSRuntime *rt, JSGCObjectHeader *p);\nstatic __maybe_unused void JS_DumpValueShort(JSRuntime *rt,\n                                                      JSValueConst val);\nstatic __maybe_unused void JS_DumpValue(JSContext *ctx, JSValueConst val);\nstatic __maybe_unused void JS_PrintValue(JSContext *ctx,\n                                                  const char *str,\n                                                  JSValueConst val);\nstatic __maybe_unused void JS_DumpShapes(JSRuntime *rt);\nstatic JSValue js_function_apply(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv, int magic);\nstatic void js_array_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_array_mark(JSRuntime *rt, JSValueConst val,\n                          JS_MarkFunc *mark_func);\nstatic void js_object_data_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_object_data_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_c_function_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_c_function_mark(JSRuntime *rt, JSValueConst val,\n                               JS_MarkFunc *mark_func);\nstatic void js_bytecode_function_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_bytecode_function_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_bound_function_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_bound_function_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_for_in_iterator_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_for_in_iterator_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_regexp_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_array_buffer_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_typed_array_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_typed_array_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_proxy_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_proxy_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_map_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_map_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_map_iterator_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_map_iterator_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_array_iterator_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_array_iterator_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_regexp_string_iterator_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_regexp_string_iterator_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_generator_finalizer(JSRuntime *rt, JSValue obj);\nstatic void js_generator_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_promise_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_promise_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_promise_resolve_function_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_promise_resolve_function_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\n#ifdef CONFIG_BIGNUM\nstatic void js_operator_set_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_operator_set_mark(JSRuntime *rt, JSValueConst val,\n                                 JS_MarkFunc *mark_func);\n#endif\nstatic JSValue JS_ToStringFree(JSContext *ctx, JSValue val);\nstatic int JS_ToBoolFree(JSContext *ctx, JSValue val);\nstatic int JS_ToInt32Free(JSContext *ctx, int32_t *pres, JSValue val);\nstatic int JS_ToFloat64Free(JSContext *ctx, double *pres, JSValue val);\nstatic int JS_ToUint8ClampFree(JSContext *ctx, int32_t *pres, JSValue val);\nstatic JSValue js_compile_regexp(JSContext *ctx, JSValueConst pattern,\n                                 JSValueConst flags);\nstatic JSValue js_regexp_constructor_internal(JSContext *ctx, JSValueConst ctor,\n                                              JSValue pattern, JSValue bc);\nstatic void gc_decref(JSRuntime *rt);\nstatic int JS_NewClass1(JSRuntime *rt, JSClassID class_id,\n                        const JSClassDef *class_def, JSAtom name);\n\ntypedef enum JSStrictEqModeEnum {\n    JS_EQ_STRICT,\n    JS_EQ_SAME_VALUE,\n    JS_EQ_SAME_VALUE_ZERO,\n} JSStrictEqModeEnum;\n\nstatic BOOL js_strict_eq2(JSContext *ctx, JSValue op1, JSValue op2,\n                          JSStrictEqModeEnum eq_mode);\nstatic BOOL js_strict_eq(JSContext *ctx, JSValue op1, JSValue op2);\nstatic BOOL js_same_value(JSContext *ctx, JSValueConst op1, JSValueConst op2);\nstatic BOOL js_same_value_zero(JSContext *ctx, JSValueConst op1, JSValueConst op2);\nstatic JSValue JS_ToObject(JSContext *ctx, JSValueConst val);\nstatic JSValue JS_ToObjectFree(JSContext *ctx, JSValue val);\nstatic JSProperty *add_property(JSContext *ctx,\n                                JSObject *p, JSAtom prop, int prop_flags);\n#ifdef CONFIG_BIGNUM\nstatic void js_float_env_finalizer(JSRuntime *rt, JSValue val);\nstatic JSValue JS_NewBigFloat(JSContext *ctx);\nstatic inline bf_t *JS_GetBigFloat(JSValueConst val)\n{\n    JSBigFloat *p = JS_VALUE_GET_PTR(val);\n    return &p->num;\n}\nstatic JSValue JS_NewBigDecimal(JSContext *ctx);\nstatic inline bfdec_t *JS_GetBigDecimal(JSValueConst val)\n{\n    JSBigDecimal *p = JS_VALUE_GET_PTR(val);\n    return &p->num;\n}\nstatic JSValue JS_NewBigInt(JSContext *ctx);\nstatic inline bf_t *JS_GetBigInt(JSValueConst val)\n{\n    JSBigFloat *p = JS_VALUE_GET_PTR(val);\n    return &p->num;\n}\nstatic JSValue JS_CompactBigInt1(JSContext *ctx, JSValue val,\n                                 BOOL convert_to_safe_integer);\nstatic JSValue JS_CompactBigInt(JSContext *ctx, JSValue val);\nstatic int JS_ToBigInt64Free(JSContext *ctx, int64_t *pres, JSValue val);\nstatic bf_t *JS_ToBigInt(JSContext *ctx, bf_t *buf, JSValueConst val);\nstatic void JS_FreeBigInt(JSContext *ctx, bf_t *a, bf_t *buf);\nstatic bf_t *JS_ToBigFloat(JSContext *ctx, bf_t *buf, JSValueConst val);\nstatic JSValue JS_ToBigDecimalFree(JSContext *ctx, JSValue val,\n                                   BOOL allow_null_or_undefined);\nstatic bfdec_t *JS_ToBigDecimal(JSContext *ctx, JSValueConst val);\n#endif\nJSValue JS_ThrowOutOfMemory(JSContext *ctx);\nstatic JSValue JS_ThrowTypeErrorRevokedProxy(JSContext *ctx);\nstatic JSValue js_proxy_getPrototypeOf(JSContext *ctx, JSValueConst obj);\nstatic int js_proxy_setPrototypeOf(JSContext *ctx, JSValueConst obj,\n                                   JSValueConst proto_val, BOOL throw_flag);\nstatic int js_proxy_isExtensible(JSContext *ctx, JSValueConst obj);\nstatic int js_proxy_preventExtensions(JSContext *ctx, JSValueConst obj);\nstatic int js_proxy_isArray(JSContext *ctx, JSValueConst obj);\nstatic int JS_CreateProperty(JSContext *ctx, JSObject *p,\n                             JSAtom prop, JSValueConst val,\n                             JSValueConst getter, JSValueConst setter,\n                             int flags);\nstatic int js_string_memcmp(const JSString *p1, const JSString *p2, int len);\nstatic void reset_weak_ref(JSRuntime *rt, JSObject *p);\nstatic JSValue js_array_buffer_constructor3(JSContext *ctx,\n                                            JSValueConst new_target,\n                                            uint64_t len, JSClassID class_id,\n                                            uint8_t *buf,\n                                            JSFreeArrayBufferDataFunc *free_func,\n                                            void *opaque, BOOL alloc_flag);\nstatic JSArrayBuffer *js_get_array_buffer(JSContext *ctx, JSValueConst obj);\nstatic JSValue js_typed_array_constructor(JSContext *ctx,\n                                          JSValueConst this_val,\n                                          int argc, JSValueConst *argv,\n                                          int classid);\nstatic BOOL typed_array_is_detached(JSContext *ctx, JSObject *p);\nstatic uint32_t typed_array_get_length(JSContext *ctx, JSObject *p);\nstatic JSValue JS_ThrowTypeErrorDetachedArrayBuffer(JSContext *ctx);\nstatic JSVarRef *get_var_ref(JSContext *ctx, JSStackFrame *sf, int var_idx,\n                             BOOL is_arg);\nstatic JSValue js_generator_function_call(JSContext *ctx, JSValueConst func_obj,\n                                          JSValueConst this_obj,\n                                          int argc, JSValueConst *argv,\n                                          int flags);\nstatic void js_async_function_resolve_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_async_function_resolve_mark(JSRuntime *rt, JSValueConst val,\n                                           JS_MarkFunc *mark_func);\nstatic JSValue JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,\n                               const char *input, size_t input_len,\n                               const char *filename, int flags, int scope_idx);\nstatic void js_free_module_def(JSContext *ctx, JSModuleDef *m);\nstatic void js_mark_module_def(JSRuntime *rt, JSModuleDef *m,\n                               JS_MarkFunc *mark_func);\nstatic JSValue js_import_meta(JSContext *ctx);\nstatic JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier);\nstatic void free_var_ref(JSRuntime *rt, JSVarRef *var_ref);\nstatic JSValue js_new_promise_capability(JSContext *ctx,\n                                         JSValue *resolving_funcs,\n                                         JSValueConst ctor);\nstatic __exception int perform_promise_then(JSContext *ctx,\n                                            JSValueConst promise,\n                                            JSValueConst *resolve_reject,\n                                            JSValueConst *cap_resolving_funcs);\nstatic JSValue js_promise_resolve(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv, int magic);\nstatic int js_string_compare(JSContext *ctx,\n                             const JSString *p1, const JSString *p2);\nstatic JSValue JS_ToNumber(JSContext *ctx, JSValueConst val);\nstatic int JS_SetPropertyValue(JSContext *ctx, JSValueConst this_obj,\n                               JSValue prop, JSValue val, int flags);\nstatic int JS_NumberIsInteger(JSContext *ctx, JSValueConst val);\nstatic BOOL JS_NumberIsNegativeOrMinusZero(JSContext *ctx, JSValueConst val);\nstatic JSValue JS_ToNumberFree(JSContext *ctx, JSValue val);\nstatic int JS_GetOwnPropertyInternal(JSContext *ctx, JSPropertyDescriptor *desc,\n                                     JSObject *p, JSAtom prop);\nstatic void js_free_desc(JSContext *ctx, JSPropertyDescriptor *desc);\nstatic void async_func_mark(JSRuntime *rt, JSAsyncFunctionState *s,\n                            JS_MarkFunc *mark_func);\nstatic void JS_AddIntrinsicBasicObjects(JSContext *ctx);\nstatic void js_free_shape(JSRuntime *rt, JSShape *sh);\nstatic void js_free_shape_null(JSRuntime *rt, JSShape *sh);\nstatic int js_shape_prepare_update(JSContext *ctx, JSObject *p,\n                                   JSShapeProperty **pprs);\nstatic int init_shape_hash(JSRuntime *rt);\nstatic __exception int js_get_length32(JSContext *ctx, uint32_t *pres,\n                                       JSValueConst obj);\nstatic __exception int js_get_length64(JSContext *ctx, int64_t *pres,\n                                       JSValueConst obj);\nstatic void free_arg_list(JSContext *ctx, JSValue *tab, uint32_t len);\nstatic JSValue *build_arg_list(JSContext *ctx, uint32_t *plen,\n                               JSValueConst array_arg);\nstatic BOOL js_get_fast_array(JSContext *ctx, JSValueConst obj,\n                              JSValue **arrpp, uint32_t *countp);\nstatic JSValue JS_CreateAsyncFromSyncIterator(JSContext *ctx,\n                                              JSValueConst sync_iter);\nstatic void js_c_function_data_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_c_function_data_mark(JSRuntime *rt, JSValueConst val,\n                                    JS_MarkFunc *mark_func);\nstatic JSValue js_c_function_data_call(JSContext *ctx, JSValueConst func_obj,\n                                       JSValueConst this_val,\n                                       int argc, JSValueConst *argv, int flags);\nstatic void js_c_closure_finalizer(JSRuntime *rt, JSValue val);\nstatic JSValue js_c_closure_call(JSContext *ctx, JSValueConst func_obj,\n                                 JSValueConst this_val,\n                                 int argc, JSValueConst *argv, int flags);\nstatic JSAtom js_symbol_to_atom(JSContext *ctx, JSValue val);\nstatic void add_gc_object(JSRuntime *rt, JSGCObjectHeader *h,\n                          JSGCObjectTypeEnum type);\nstatic void remove_gc_object(JSGCObjectHeader *h);\nstatic void js_async_function_free0(JSRuntime *rt, JSAsyncFunctionData *s);\nstatic JSValue js_instantiate_prototype(JSContext *ctx, JSObject *p, JSAtom atom, void *opaque);\nstatic JSValue js_module_ns_autoinit(JSContext *ctx, JSObject *p, JSAtom atom,\n                                 void *opaque);\nstatic JSValue JS_InstantiateFunctionListItem2(JSContext *ctx, JSObject *p,\n                                               JSAtom atom, void *opaque);\nvoid JS_SetUncatchableError(JSContext *ctx, JSValueConst val, BOOL flag);\n\nstatic const JSClassExoticMethods js_arguments_exotic_methods;\nstatic const JSClassExoticMethods js_string_exotic_methods;\nstatic const JSClassExoticMethods js_proxy_exotic_methods;\nstatic const JSClassExoticMethods js_module_ns_exotic_methods;\nstatic JSClassID js_class_id_alloc = JS_CLASS_INIT_COUNT;\n\nstatic void js_trigger_gc(JSRuntime *rt, size_t size)\n{\n    BOOL force_gc;\n#ifdef FORCE_GC_AT_MALLOC\n    force_gc = TRUE;\n#else\n    force_gc = ((rt->malloc_state.malloc_size + size) >\n                rt->malloc_gc_threshold);\n#endif\n    if (force_gc) {\n#ifdef DUMP_GC\n        printf(\"GC: size=%\" PRIu64 \"\\n\",\n               (uint64_t)rt->malloc_state.malloc_size);\n#endif\n        JS_RunGC(rt);\n        rt->malloc_gc_threshold = rt->malloc_state.malloc_size +\n            (rt->malloc_state.malloc_size >> 1);\n    }\n}\n\nstatic size_t js_malloc_usable_size_unknown(const void *ptr)\n{\n    return 0;\n}\n\nvoid *js_malloc_rt(JSRuntime *rt, size_t size)\n{\n    return rt->mf.js_malloc(&rt->malloc_state, size);\n}\n\nvoid js_free_rt(JSRuntime *rt, void *ptr)\n{\n    rt->mf.js_free(&rt->malloc_state, ptr);\n}\n\nvoid *js_realloc_rt(JSRuntime *rt, void *ptr, size_t size)\n{\n    return rt->mf.js_realloc(&rt->malloc_state, ptr, size);\n}\n\nsize_t js_malloc_usable_size_rt(JSRuntime *rt, const void *ptr)\n{\n    return rt->mf.js_malloc_usable_size(ptr);\n}\n\nvoid *js_mallocz_rt(JSRuntime *rt, size_t size)\n{\n    void *ptr;\n    ptr = js_malloc_rt(rt, size);\n    if (!ptr)\n        return NULL;\n    return memset(ptr, 0, size);\n}\n\n#ifdef CONFIG_BIGNUM\n/* called by libbf */\nstatic void *js_bf_realloc(void *opaque, void *ptr, size_t size)\n{\n    JSRuntime *rt = opaque;\n    return js_realloc_rt(rt, ptr, size);\n}\n#endif /* CONFIG_BIGNUM */\n\n/* Throw out of memory in case of error */\nvoid *js_malloc(JSContext *ctx, size_t size)\n{\n    void *ptr;\n    ptr = js_malloc_rt(ctx->rt, size);\n    if (unlikely(!ptr)) {\n        JS_ThrowOutOfMemory(ctx);\n        return NULL;\n    }\n    return ptr;\n}\n\n/* Throw out of memory in case of error */\nvoid *js_mallocz(JSContext *ctx, size_t size)\n{\n    void *ptr;\n    ptr = js_mallocz_rt(ctx->rt, size);\n    if (unlikely(!ptr)) {\n        JS_ThrowOutOfMemory(ctx);\n        return NULL;\n    }\n    return ptr;\n}\n\nvoid js_free(JSContext *ctx, void *ptr)\n{\n    js_free_rt(ctx->rt, ptr);\n}\n\n/* Throw out of memory in case of error */\nvoid *js_realloc(JSContext *ctx, void *ptr, size_t size)\n{\n    void *ret;\n    ret = js_realloc_rt(ctx->rt, ptr, size);\n    if (unlikely(!ret && size != 0)) {\n        JS_ThrowOutOfMemory(ctx);\n        return NULL;\n    }\n    return ret;\n}\n\n/* store extra allocated size in *pslack if successful */\nvoid *js_realloc2(JSContext *ctx, void *ptr, size_t size, size_t *pslack)\n{\n    void *ret;\n    ret = js_realloc_rt(ctx->rt, ptr, size);\n    if (unlikely(!ret && size != 0)) {\n        JS_ThrowOutOfMemory(ctx);\n        return NULL;\n    }\n    if (pslack) {\n        size_t new_size = js_malloc_usable_size_rt(ctx->rt, ret);\n        *pslack = (new_size > size) ? new_size - size : 0;\n    }\n    return ret;\n}\n\nsize_t js_malloc_usable_size(JSContext *ctx, const void *ptr)\n{\n    return js_malloc_usable_size_rt(ctx->rt, ptr);\n}\n\n/* Throw out of memory exception in case of error */\nchar *js_strndup(JSContext *ctx, const char *s, size_t n)\n{\n    char *ptr;\n    ptr = js_malloc(ctx, n + 1);\n    if (ptr) {\n        memcpy(ptr, s, n);\n        ptr[n] = '\\0';\n    }\n    return ptr;\n}\n\nchar *js_strdup(JSContext *ctx, const char *str)\n{\n    return js_strndup(ctx, str, strlen(str));\n}\n\nstatic no_inline int js_realloc_array(JSContext *ctx, void **parray,\n                                      int elem_size, int *psize, int req_size)\n{\n    int new_size;\n    size_t slack;\n    void *new_array;\n    /* XXX: potential arithmetic overflow */\n    new_size = max_int(req_size, *psize * 3 / 2);\n    new_array = js_realloc2(ctx, *parray, new_size * elem_size, &slack);\n    if (!new_array)\n        return -1;\n    new_size += slack / elem_size;\n    *psize = new_size;\n    *parray = new_array;\n    return 0;\n}\n\n/* resize the array and update its size if req_size > *psize */\nstatic inline int js_resize_array(JSContext *ctx, void **parray, int elem_size,\n                                  int *psize, int req_size)\n{\n    if (unlikely(req_size > *psize))\n        return js_realloc_array(ctx, parray, elem_size, psize, req_size);\n    else\n        return 0;\n}\n\nstatic inline void js_dbuf_init(JSContext *ctx, DynBuf *s)\n{\n    dbuf_init2(s, ctx->rt, (DynBufReallocFunc *)js_realloc_rt);\n}\n\nstatic inline int is_digit(int c) {\n    return c >= '0' && c <= '9';\n}\n\ntypedef struct JSClassShortDef {\n    JSAtom class_name;\n    JSClassFinalizer *finalizer;\n    JSClassGCMark *gc_mark;\n} JSClassShortDef;\n\nstatic JSClassShortDef const js_std_class_def[] = {\n    { JS_ATOM_Object, NULL, NULL },                             /* JS_CLASS_OBJECT */\n    { JS_ATOM_Array, js_array_finalizer, js_array_mark },       /* JS_CLASS_ARRAY */\n    { JS_ATOM_Error, NULL, NULL }, /* JS_CLASS_ERROR */\n    { JS_ATOM_Number, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_NUMBER */\n    { JS_ATOM_String, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_STRING */\n    { JS_ATOM_Boolean, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_BOOLEAN */\n    { JS_ATOM_Symbol, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_SYMBOL */\n    { JS_ATOM_Arguments, js_array_finalizer, js_array_mark },   /* JS_CLASS_ARGUMENTS */\n    { JS_ATOM_Arguments, NULL, NULL },                          /* JS_CLASS_MAPPED_ARGUMENTS */\n    { JS_ATOM_Date, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_DATE */\n    { JS_ATOM_Object, NULL, NULL },                             /* JS_CLASS_MODULE_NS */\n    { JS_ATOM_Function, js_c_function_finalizer, js_c_function_mark }, /* JS_CLASS_C_FUNCTION */\n    { JS_ATOM_Function, js_bytecode_function_finalizer, js_bytecode_function_mark }, /* JS_CLASS_BYTECODE_FUNCTION */\n    { JS_ATOM_Function, js_bound_function_finalizer, js_bound_function_mark }, /* JS_CLASS_BOUND_FUNCTION */\n    { JS_ATOM_Function, js_c_function_data_finalizer, js_c_function_data_mark }, /* JS_CLASS_C_FUNCTION_DATA */\n    { JS_ATOM_Function, js_c_closure_finalizer, NULL},                           /* JS_CLASS_C_CLOSURE */\n    { JS_ATOM_GeneratorFunction, js_bytecode_function_finalizer, js_bytecode_function_mark },  /* JS_CLASS_GENERATOR_FUNCTION */\n    { JS_ATOM_ForInIterator, js_for_in_iterator_finalizer, js_for_in_iterator_mark },      /* JS_CLASS_FOR_IN_ITERATOR */\n    { JS_ATOM_RegExp, js_regexp_finalizer, NULL },                              /* JS_CLASS_REGEXP */\n    { JS_ATOM_ArrayBuffer, js_array_buffer_finalizer, NULL },                   /* JS_CLASS_ARRAY_BUFFER */\n    { JS_ATOM_SharedArrayBuffer, js_array_buffer_finalizer, NULL },             /* JS_CLASS_SHARED_ARRAY_BUFFER */\n    { JS_ATOM_Uint8ClampedArray, js_typed_array_finalizer, js_typed_array_mark }, /* JS_CLASS_UINT8C_ARRAY */\n    { JS_ATOM_Int8Array, js_typed_array_finalizer, js_typed_array_mark },       /* JS_CLASS_INT8_ARRAY */\n    { JS_ATOM_Uint8Array, js_typed_array_finalizer, js_typed_array_mark },      /* JS_CLASS_UINT8_ARRAY */\n    { JS_ATOM_Int16Array, js_typed_array_finalizer, js_typed_array_mark },      /* JS_CLASS_INT16_ARRAY */\n    { JS_ATOM_Uint16Array, js_typed_array_finalizer, js_typed_array_mark },     /* JS_CLASS_UINT16_ARRAY */\n    { JS_ATOM_Int32Array, js_typed_array_finalizer, js_typed_array_mark },      /* JS_CLASS_INT32_ARRAY */\n    { JS_ATOM_Uint32Array, js_typed_array_finalizer, js_typed_array_mark },     /* JS_CLASS_UINT32_ARRAY */\n#ifdef CONFIG_BIGNUM\n    { JS_ATOM_BigInt64Array, js_typed_array_finalizer, js_typed_array_mark },   /* JS_CLASS_BIG_INT64_ARRAY */\n    { JS_ATOM_BigUint64Array, js_typed_array_finalizer, js_typed_array_mark },  /* JS_CLASS_BIG_UINT64_ARRAY */\n#endif\n    { JS_ATOM_Float32Array, js_typed_array_finalizer, js_typed_array_mark },    /* JS_CLASS_FLOAT32_ARRAY */\n    { JS_ATOM_Float64Array, js_typed_array_finalizer, js_typed_array_mark },    /* JS_CLASS_FLOAT64_ARRAY */\n    { JS_ATOM_DataView, js_typed_array_finalizer, js_typed_array_mark },        /* JS_CLASS_DATAVIEW */\n#ifdef CONFIG_BIGNUM\n    { JS_ATOM_BigInt, js_object_data_finalizer, js_object_data_mark },      /* JS_CLASS_BIG_INT */\n    { JS_ATOM_BigFloat, js_object_data_finalizer, js_object_data_mark },    /* JS_CLASS_BIG_FLOAT */\n    { JS_ATOM_BigFloatEnv, js_float_env_finalizer, NULL },      /* JS_CLASS_FLOAT_ENV */\n    { JS_ATOM_BigDecimal, js_object_data_finalizer, js_object_data_mark },    /* JS_CLASS_BIG_DECIMAL */\n    { JS_ATOM_OperatorSet, js_operator_set_finalizer, js_operator_set_mark },    /* JS_CLASS_OPERATOR_SET */\n#endif\n    { JS_ATOM_Map, js_map_finalizer, js_map_mark },             /* JS_CLASS_MAP */\n    { JS_ATOM_Set, js_map_finalizer, js_map_mark },             /* JS_CLASS_SET */\n    { JS_ATOM_WeakMap, js_map_finalizer, js_map_mark },         /* JS_CLASS_WEAKMAP */\n    { JS_ATOM_WeakSet, js_map_finalizer, js_map_mark },         /* JS_CLASS_WEAKSET */\n    { JS_ATOM_Map_Iterator, js_map_iterator_finalizer, js_map_iterator_mark }, /* JS_CLASS_MAP_ITERATOR */\n    { JS_ATOM_Set_Iterator, js_map_iterator_finalizer, js_map_iterator_mark }, /* JS_CLASS_SET_ITERATOR */\n    { JS_ATOM_Array_Iterator, js_array_iterator_finalizer, js_array_iterator_mark }, /* JS_CLASS_ARRAY_ITERATOR */\n    { JS_ATOM_String_Iterator, js_array_iterator_finalizer, js_array_iterator_mark }, /* JS_CLASS_STRING_ITERATOR */\n    { JS_ATOM_RegExp_String_Iterator, js_regexp_string_iterator_finalizer, js_regexp_string_iterator_mark }, /* JS_CLASS_REGEXP_STRING_ITERATOR */\n    { JS_ATOM_Generator, js_generator_finalizer, js_generator_mark }, /* JS_CLASS_GENERATOR */\n};\n\nstatic int init_class_range(JSRuntime *rt, JSClassShortDef const *tab,\n                            int start, int count)\n{\n    JSClassDef cm_s, *cm = &cm_s;\n    int i, class_id;\n\n    for(i = 0; i < count; i++) {\n        class_id = i + start;\n        memset(cm, 0, sizeof(*cm));\n        cm->finalizer = tab[i].finalizer;\n        cm->gc_mark = tab[i].gc_mark;\n        if (JS_NewClass1(rt, class_id, cm, tab[i].class_name) < 0)\n            return -1;\n    }\n    return 0;\n}\n\n#ifdef CONFIG_BIGNUM\nstatic JSValue JS_ThrowUnsupportedOperation(JSContext *ctx)\n{\n    return JS_ThrowTypeError(ctx, \"unsupported operation\");\n}\n\nstatic JSValue invalid_to_string(JSContext *ctx, JSValueConst val)\n{\n    return JS_ThrowUnsupportedOperation(ctx);\n}\n\nstatic JSValue invalid_from_string(JSContext *ctx, const char *buf,\n                                   int radix, int flags, slimb_t *pexponent)\n{\n    return JS_NAN;\n}\n\nstatic int invalid_unary_arith(JSContext *ctx,\n                               JSValue *pres, OPCodeEnum op, JSValue op1)\n{\n    JS_FreeValue(ctx, op1);\n    JS_ThrowUnsupportedOperation(ctx);\n    return -1;\n}\n\nstatic int invalid_binary_arith(JSContext *ctx, OPCodeEnum op,\n                                JSValue *pres, JSValue op1, JSValue op2)\n{\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    JS_ThrowUnsupportedOperation(ctx);\n    return -1;\n}\n\nstatic JSValue invalid_mul_pow10_to_float64(JSContext *ctx, const bf_t *a,\n                                            int64_t exponent)\n{\n    return JS_ThrowUnsupportedOperation(ctx);\n}\n\nstatic int invalid_mul_pow10(JSContext *ctx, JSValue *sp)\n{\n    JS_ThrowUnsupportedOperation(ctx);\n    return -1;\n}\n\nstatic void set_dummy_numeric_ops(JSNumericOperations *ops)\n{\n    ops->to_string = invalid_to_string;\n    ops->from_string = invalid_from_string;\n    ops->unary_arith = invalid_unary_arith;\n    ops->binary_arith = invalid_binary_arith;\n    ops->mul_pow10_to_float64 = invalid_mul_pow10_to_float64;\n    ops->mul_pow10 = invalid_mul_pow10;\n}\n\n#endif /* CONFIG_BIGNUM */\n\n#if !defined(CONFIG_STACK_CHECK)\n/* no stack limitation */\nstatic inline uintptr_t js_get_stack_pointer(void)\n{\n    return 0;\n}\n\nstatic inline BOOL js_check_stack_overflow(JSRuntime *rt, size_t alloca_size)\n{\n    return FALSE;\n}\n#else\n/* Note: OS and CPU dependent */\nstatic inline uintptr_t js_get_stack_pointer(void)\n{\n    return (uintptr_t)__builtin_frame_address(0);\n}\n\nstatic inline BOOL js_check_stack_overflow(JSRuntime *rt, size_t alloca_size)\n{\n    uintptr_t sp;\n    sp = js_get_stack_pointer() - alloca_size;\n    return unlikely(sp < rt->stack_limit);\n}\n#endif\n\nJSRuntime *JS_NewRuntime2(const JSMallocFunctions *mf, void *opaque)\n{\n    JSRuntime *rt;\n    JSMallocState ms;\n\n    memset(&ms, 0, sizeof(ms));\n    ms.opaque = opaque;\n    ms.malloc_limit = -1;\n\n    rt = mf->js_malloc(&ms, sizeof(JSRuntime));\n    if (!rt)\n        return NULL;\n    memset(rt, 0, sizeof(*rt));\n    rt->mf = *mf;\n    if (!rt->mf.js_malloc_usable_size) {\n        /* use dummy function if none provided */\n        rt->mf.js_malloc_usable_size = js_malloc_usable_size_unknown;\n    }\n    rt->malloc_state = ms;\n    rt->malloc_gc_threshold = 256 * 1024;\n\n#ifdef CONFIG_BIGNUM\n    bf_context_init(&rt->bf_ctx, js_bf_realloc, rt);\n    set_dummy_numeric_ops(&rt->bigint_ops);\n    set_dummy_numeric_ops(&rt->bigfloat_ops);\n    set_dummy_numeric_ops(&rt->bigdecimal_ops);\n#endif\n\n    init_list_head(&rt->context_list);\n    init_list_head(&rt->gc_obj_list);\n    init_list_head(&rt->gc_zero_ref_count_list);\n    rt->gc_phase = JS_GC_PHASE_NONE;\n    \n#ifdef DUMP_LEAKS\n    init_list_head(&rt->string_list);\n#endif\n    init_list_head(&rt->job_list);\n\n    if (JS_InitAtoms(rt))\n        goto fail;\n\n    /* create the object, array and function classes */\n    if (init_class_range(rt, js_std_class_def, JS_CLASS_OBJECT,\n                         countof(js_std_class_def)) < 0)\n        goto fail;\n    rt->class_array[JS_CLASS_ARGUMENTS].exotic = &js_arguments_exotic_methods;\n    rt->class_array[JS_CLASS_STRING].exotic = &js_string_exotic_methods;\n    rt->class_array[JS_CLASS_MODULE_NS].exotic = &js_module_ns_exotic_methods;\n\n    rt->class_array[JS_CLASS_C_FUNCTION].call = js_call_c_function;\n    rt->class_array[JS_CLASS_C_FUNCTION_DATA].call = js_c_function_data_call;\n    rt->class_array[JS_CLASS_C_CLOSURE].call = js_c_closure_call;\n    rt->class_array[JS_CLASS_BOUND_FUNCTION].call = js_call_bound_function;\n    rt->class_array[JS_CLASS_GENERATOR_FUNCTION].call = js_generator_function_call;\n    if (init_shape_hash(rt))\n        goto fail;\n\n    rt->stack_size = JS_DEFAULT_STACK_SIZE;\n    JS_UpdateStackTop(rt);\n\n    rt->current_exception = JS_NULL;\n\n    return rt;\n fail:\n    JS_FreeRuntime(rt);\n    return NULL;\n}\n\nvoid *JS_GetRuntimeOpaque(JSRuntime *rt)\n{\n    return rt->user_opaque;\n}\n\nvoid JS_SetRuntimeOpaque(JSRuntime *rt, void *opaque)\n{\n    rt->user_opaque = opaque;\n}\n\n/* default memory allocation functions with memory limitation */\nstatic inline size_t js_def_malloc_usable_size(void *ptr)\n{\n#if defined(__APPLE__)\n    return malloc_size(ptr);\n#elif defined(_WIN32)\n    return _msize(ptr);\n#elif defined(EMSCRIPTEN) || defined(__wasi__) || defined(__dietlibc__)\n    return 0;\n#elif defined(__linux__)\n    return malloc_usable_size(ptr);\n#else\n    /* change this to `return 0;` if compilation fails */\n    return malloc_usable_size(ptr);\n#endif\n}\n\nstatic void *js_def_malloc(JSMallocState *s, size_t size)\n{\n    void *ptr;\n\n    /* Do not allocate zero bytes: behavior is platform dependent */\n    assert(size != 0);\n\n    if (unlikely(s->malloc_size + size > s->malloc_limit))\n        return NULL;\n\n    ptr = malloc(size);\n    if (!ptr)\n        return NULL;\n\n    s->malloc_count++;\n    s->malloc_size += js_def_malloc_usable_size(ptr) + MALLOC_OVERHEAD;\n    return ptr;\n}\n\nstatic void js_def_free(JSMallocState *s, void *ptr)\n{\n    if (!ptr)\n        return;\n\n    s->malloc_count--;\n    s->malloc_size -= js_def_malloc_usable_size(ptr) + MALLOC_OVERHEAD;\n    free(ptr);\n}\n\nstatic void *js_def_realloc(JSMallocState *s, void *ptr, size_t size)\n{\n    size_t old_size;\n\n    if (!ptr) {\n        if (size == 0)\n            return NULL;\n        return js_def_malloc(s, size);\n    }\n    old_size = js_def_malloc_usable_size(ptr);\n    if (size == 0) {\n        s->malloc_count--;\n        s->malloc_size -= old_size + MALLOC_OVERHEAD;\n        free(ptr);\n        return NULL;\n    }\n    if (s->malloc_size + size - old_size > s->malloc_limit)\n        return NULL;\n\n    ptr = realloc(ptr, size);\n    if (!ptr)\n        return NULL;\n\n    s->malloc_size += js_def_malloc_usable_size(ptr) - old_size;\n    return ptr;\n}\n\nstatic const JSMallocFunctions def_malloc_funcs = {\n    js_def_malloc,\n    js_def_free,\n    js_def_realloc,\n#if defined(__APPLE__)\n    malloc_size,\n#elif defined(_WIN32)\n    (size_t (*)(const void *))_msize,\n#elif defined(EMSCRIPTEN) || defined(__wasi__) || defined(__dietlibc__)\n    NULL,\n#elif defined(__linux__)\n    (size_t (*)(const void *))malloc_usable_size,\n#else\n    /* change this to `NULL,` if compilation fails */\n    malloc_usable_size,\n#endif\n};\n\nJSRuntime *JS_NewRuntime(void)\n{\n    return JS_NewRuntime2(&def_malloc_funcs, NULL);\n}\n\nvoid JS_SetMemoryLimit(JSRuntime *rt, size_t limit)\n{\n    rt->malloc_state.malloc_limit = limit;\n}\n\n/* use -1 to disable automatic GC */\nvoid JS_SetGCThreshold(JSRuntime *rt, size_t gc_threshold)\n{\n    rt->malloc_gc_threshold = gc_threshold;\n}\n\n#define malloc(s) malloc_is_forbidden(s)\n#define free(p) free_is_forbidden(p)\n#define realloc(p,s) realloc_is_forbidden(p,s)\n\nvoid JS_SetInterruptHandler(JSRuntime *rt, JSInterruptHandler *cb, void *opaque)\n{\n    rt->interrupt_handler = cb;\n    rt->interrupt_opaque = opaque;\n}\n\nvoid JS_SetCanBlock(JSRuntime *rt, BOOL can_block)\n{\n    rt->can_block = can_block;\n}\n\nvoid JS_SetSharedArrayBufferFunctions(JSRuntime *rt,\n                                      const JSSharedArrayBufferFunctions *sf)\n{\n    rt->sab_funcs = *sf;\n}\n\n/* return 0 if OK, < 0 if exception */\nint JS_EnqueueJob(JSContext *ctx, JSJobFunc *job_func,\n                  int argc, JSValueConst *argv)\n{\n    JSRuntime *rt = ctx->rt;\n    JSJobEntry *e;\n    int i;\n\n    e = js_malloc(ctx, sizeof(*e) + argc * sizeof(JSValue));\n    if (!e)\n        return -1;\n    e->ctx = ctx;\n    e->job_func = job_func;\n    e->argc = argc;\n    for(i = 0; i < argc; i++) {\n        e->argv[i] = JS_DupValue(ctx, argv[i]);\n    }\n    list_add_tail(&e->link, &rt->job_list);\n    return 0;\n}\n\nBOOL JS_IsJobPending(JSRuntime *rt)\n{\n    return !list_empty(&rt->job_list);\n}\n\n/* return < 0 if exception, 0 if no job pending, 1 if a job was\n   executed successfully. the context of the job is stored in '*pctx' */\nint JS_ExecutePendingJob(JSRuntime *rt, JSContext **pctx)\n{\n    JSContext *ctx;\n    JSJobEntry *e;\n    JSValue res;\n    int i, ret;\n\n    if (list_empty(&rt->job_list)) {\n        *pctx = NULL;\n        return 0;\n    }\n\n    /* get the first pending job and execute it */\n    e = list_entry(rt->job_list.next, JSJobEntry, link);\n    list_del(&e->link);\n    ctx = e->ctx;\n    res = e->job_func(e->ctx, e->argc, (JSValueConst *)e->argv);\n    for(i = 0; i < e->argc; i++)\n        JS_FreeValue(ctx, e->argv[i]);\n    if (JS_IsException(res))\n        ret = -1;\n    else\n        ret = 1;\n    JS_FreeValue(ctx, res);\n    js_free(ctx, e);\n    *pctx = ctx;\n    return ret;\n}\n\nstatic inline uint32_t atom_get_free(const JSAtomStruct *p)\n{\n    return (uintptr_t)p >> 1;\n}\n\nstatic inline BOOL atom_is_free(const JSAtomStruct *p)\n{\n    return (uintptr_t)p & 1;\n}\n\nstatic inline JSAtomStruct *atom_set_free(uint32_t v)\n{\n    return (JSAtomStruct *)(((uintptr_t)v << 1) | 1);\n}\n\n/* Note: the string contents are uninitialized */\nstatic JSString *js_alloc_string_rt(JSRuntime *rt, int max_len, int is_wide_char)\n{\n    JSString *str;\n    str = js_malloc_rt(rt, sizeof(JSString) + (max_len << is_wide_char) + 1 - is_wide_char);\n    if (unlikely(!str))\n        return NULL;\n    str->header.ref_count = 1;\n    str->is_wide_char = is_wide_char;\n    str->len = max_len;\n    str->atom_type = 0;\n    str->hash = 0;          /* optional but costless */\n    str->hash_next = 0;     /* optional */\n#ifdef DUMP_LEAKS\n    list_add_tail(&str->link, &rt->string_list);\n#endif\n    return str;\n}\n\nstatic JSString *js_alloc_string(JSContext *ctx, int max_len, int is_wide_char)\n{\n    JSString *p;\n    p = js_alloc_string_rt(ctx->rt, max_len, is_wide_char);\n    if (unlikely(!p)) {\n        JS_ThrowOutOfMemory(ctx);\n        return NULL;\n    }\n    return p;\n}\n\n/* same as JS_FreeValueRT() but faster */\nstatic inline void js_free_string(JSRuntime *rt, JSString *str)\n{\n    if (--str->header.ref_count <= 0) {\n        if (str->atom_type) {\n            JS_FreeAtomStruct(rt, str);\n        } else {\n#ifdef DUMP_LEAKS\n            list_del(&str->link);\n#endif\n            js_free_rt(rt, str);\n        }\n    }\n}\n\nvoid JS_SetRuntimeInfo(JSRuntime *rt, const char *s)\n{\n    if (rt)\n        rt->rt_info = s;\n}\n\nvoid JS_FreeRuntime(JSRuntime *rt)\n{\n    struct list_head *el, *el1;\n    int i;\n\n#ifdef CONFIG_DEBUGGER\n    js_debugger_free(rt, &rt->debugger_info);\n#endif\n    JS_FreeValueRT(rt, rt->current_exception);\n\n    list_for_each_safe(el, el1, &rt->job_list) {\n        JSJobEntry *e = list_entry(el, JSJobEntry, link);\n        for(i = 0; i < e->argc; i++)\n            JS_FreeValueRT(rt, e->argv[i]);\n        js_free_rt(rt, e);\n    }\n    init_list_head(&rt->job_list);\n\n    JS_RunGC(rt);\n\n#ifdef DUMP_LEAKS\n    /* leaking objects */\n    {\n        BOOL header_done;\n        JSGCObjectHeader *p;\n        int count;\n\n        /* remove the internal refcounts to display only the object\n           referenced externally */\n        list_for_each(el, &rt->gc_obj_list) {\n            p = list_entry(el, JSGCObjectHeader, link);\n            p->mark = 0;\n        }\n        gc_decref(rt);\n\n        header_done = FALSE;\n        list_for_each(el, &rt->gc_obj_list) {\n            p = list_entry(el, JSGCObjectHeader, link);\n            if (p->ref_count != 0) {\n                if (!header_done) {\n                    printf(\"Object leaks:\\n\");\n                    JS_DumpObjectHeader(rt);\n                    header_done = TRUE;\n                }\n                JS_DumpGCObject(rt, p);\n            }\n        }\n\n        count = 0;\n        list_for_each(el, &rt->gc_obj_list) {\n            p = list_entry(el, JSGCObjectHeader, link);\n            if (p->ref_count == 0) {\n                count++;\n            }\n        }\n        if (count != 0)\n            printf(\"Secondary object leaks: %d\\n\", count);\n    }\n#endif\n    assert(list_empty(&rt->gc_obj_list));\n\n    /* free the classes */\n    for(i = 0; i < rt->class_count; i++) {\n        JSClass *cl = &rt->class_array[i];\n        if (cl->class_id != 0) {\n            JS_FreeAtomRT(rt, cl->class_name);\n        }\n    }\n    js_free_rt(rt, rt->class_array);\n\n#ifdef CONFIG_BIGNUM\n    bf_context_end(&rt->bf_ctx);\n#endif\n\n#ifdef DUMP_LEAKS\n    /* only the atoms defined in JS_InitAtoms() should be left */\n    {\n        BOOL header_done = FALSE;\n\n        for(i = 0; i < rt->atom_size; i++) {\n            JSAtomStruct *p = rt->atom_array[i];\n            if (!atom_is_free(p) /* && p->str*/) {\n                if (i >= JS_ATOM_END || p->header.ref_count != 1) {\n                    if (!header_done) {\n                        header_done = TRUE;\n                        if (rt->rt_info) {\n                            printf(\"%s:1: atom leakage:\", rt->rt_info);\n                        } else {\n                            printf(\"Atom leaks:\\n\"\n                                   \"    %6s %6s %s\\n\",\n                                   \"ID\", \"REFCNT\", \"NAME\");\n                        }\n                    }\n                    if (rt->rt_info) {\n                        printf(\" \");\n                    } else {\n                        printf(\"    %6u %6u \", i, p->header.ref_count);\n                    }\n                    switch (p->atom_type) {\n                    case JS_ATOM_TYPE_STRING:\n                        JS_DumpString(rt, p);\n                        break;\n                    case JS_ATOM_TYPE_GLOBAL_SYMBOL:\n                        printf(\"Symbol.for(\");\n                        JS_DumpString(rt, p);\n                        printf(\")\");\n                        break;\n                    case JS_ATOM_TYPE_SYMBOL:\n                        if (p->hash == JS_ATOM_HASH_SYMBOL) {\n                            printf(\"Symbol(\");\n                            JS_DumpString(rt, p);\n                            printf(\")\");\n                        } else {\n                            printf(\"Private(\");\n                            JS_DumpString(rt, p);\n                            printf(\")\");\n                        }\n                        break;\n                    }\n                    if (rt->rt_info) {\n                        printf(\":%u\", p->header.ref_count);\n                    } else {\n                        printf(\"\\n\");\n                    }\n                }\n            }\n        }\n        if (rt->rt_info && header_done)\n            printf(\"\\n\");\n    }\n#endif\n\n    /* free the atoms */\n    for(i = 0; i < rt->atom_size; i++) {\n        JSAtomStruct *p = rt->atom_array[i];\n        if (!atom_is_free(p)) {\n#ifdef DUMP_LEAKS\n            list_del(&p->link);\n#endif\n            js_free_rt(rt, p);\n        }\n    }\n    js_free_rt(rt, rt->atom_array);\n    js_free_rt(rt, rt->atom_hash);\n    js_free_rt(rt, rt->shape_hash);\n#ifdef DUMP_LEAKS\n    if (!list_empty(&rt->string_list)) {\n        if (rt->rt_info) {\n            printf(\"%s:1: string leakage:\", rt->rt_info);\n        } else {\n            printf(\"String leaks:\\n\"\n                   \"    %6s %s\\n\",\n                   \"REFCNT\", \"VALUE\");\n        }\n        list_for_each_safe(el, el1, &rt->string_list) {\n            JSString *str = list_entry(el, JSString, link);\n            if (rt->rt_info) {\n                printf(\" \");\n            } else {\n                printf(\"    %6u \", str->header.ref_count);\n            }\n            JS_DumpString(rt, str);\n            if (rt->rt_info) {\n                printf(\":%u\", str->header.ref_count);\n            } else {\n                printf(\"\\n\");\n            }\n            list_del(&str->link);\n            js_free_rt(rt, str);\n        }\n        if (rt->rt_info)\n            printf(\"\\n\");\n    }\n    {\n        JSMallocState *s = &rt->malloc_state;\n        if (s->malloc_count > 1) {\n            if (rt->rt_info)\n                printf(\"%s:1: \", rt->rt_info);\n            printf(\"Memory leak: %\"PRIu64\" bytes lost in %\"PRIu64\" block%s\\n\",\n                   (uint64_t)(s->malloc_size - sizeof(JSRuntime)),\n                   (uint64_t)(s->malloc_count - 1), &\"s\"[s->malloc_count == 2]);\n        }\n    }\n#endif\n\n    {\n        JSMallocState ms = rt->malloc_state;\n        rt->mf.js_free(&ms, rt);\n    }\n}\n\nJSContext *JS_NewContextRaw(JSRuntime *rt)\n{\n    JSContext *ctx;\n    int i;\n\n    ctx = js_mallocz_rt(rt, sizeof(JSContext));\n    if (!ctx)\n        return NULL;\n    ctx->header.ref_count = 1;\n    add_gc_object(rt, &ctx->header, JS_GC_OBJ_TYPE_JS_CONTEXT);\n\n    ctx->class_proto = js_malloc_rt(rt, sizeof(ctx->class_proto[0]) *\n                                    rt->class_count);\n    if (!ctx->class_proto) {\n        js_free_rt(rt, ctx);\n        return NULL;\n    }\n    ctx->rt = rt;\n    list_add_tail(&ctx->link, &rt->context_list);\n#ifdef CONFIG_BIGNUM\n    ctx->bf_ctx = &rt->bf_ctx;\n    ctx->fp_env.prec = 113;\n    ctx->fp_env.flags = bf_set_exp_bits(15) | BF_RNDN | BF_FLAG_SUBNORMAL;\n#endif\n    for(i = 0; i < rt->class_count; i++)\n        ctx->class_proto[i] = JS_NULL;\n    ctx->array_ctor = JS_NULL;\n    ctx->regexp_ctor = JS_NULL;\n    ctx->promise_ctor = JS_NULL;\n    init_list_head(&ctx->loaded_modules);\n\n    JS_AddIntrinsicBasicObjects(ctx);\n\n#ifdef CONFIG_DEBUGGER\n    js_debugger_new_context(ctx);\n#endif\n    return ctx;\n}\n\nJSContext *JS_NewContext(JSRuntime *rt)\n{\n    JSContext *ctx;\n\n    ctx = JS_NewContextRaw(rt);\n    if (!ctx)\n        return NULL;\n\n    JS_AddIntrinsicBaseObjects(ctx);\n    JS_AddIntrinsicDate(ctx);\n    JS_AddIntrinsicEval(ctx);\n    JS_AddIntrinsicStringNormalize(ctx);\n    JS_AddIntrinsicRegExp(ctx);\n    JS_AddIntrinsicJSON(ctx);\n    JS_AddIntrinsicProxy(ctx);\n    JS_AddIntrinsicMapSet(ctx);\n    JS_AddIntrinsicTypedArrays(ctx);\n    JS_AddIntrinsicPromise(ctx);\n#ifdef CONFIG_BIGNUM\n    JS_AddIntrinsicBigInt(ctx);\n#endif\n    return ctx;\n}\n\nvoid *JS_GetContextOpaque(JSContext *ctx)\n{\n    return ctx->user_opaque;\n}\n\nvoid JS_SetContextOpaque(JSContext *ctx, void *opaque)\n{\n    ctx->user_opaque = opaque;\n}\n\n/* set the new value and free the old value after (freeing the value\n   can reallocate the object data) */\nstatic inline void set_value(JSContext *ctx, JSValue *pval, JSValue new_val)\n{\n    JSValue old_val;\n    old_val = *pval;\n    *pval = new_val;\n    JS_FreeValue(ctx, old_val);\n}\n\nvoid JS_SetClassProto(JSContext *ctx, JSClassID class_id, JSValue obj)\n{\n    JSRuntime *rt = ctx->rt;\n    assert(class_id < rt->class_count);\n    set_value(ctx, &ctx->class_proto[class_id], obj);\n}\n\nJSValue JS_GetClassProto(JSContext *ctx, JSClassID class_id)\n{\n    JSRuntime *rt = ctx->rt;\n    assert(class_id < rt->class_count);\n    return JS_DupValue(ctx, ctx->class_proto[class_id]);\n}\n\ntypedef enum JSFreeModuleEnum {\n    JS_FREE_MODULE_ALL,\n    JS_FREE_MODULE_NOT_RESOLVED,\n    JS_FREE_MODULE_NOT_EVALUATED,\n} JSFreeModuleEnum;\n\n/* XXX: would be more efficient with separate module lists */\nstatic void js_free_modules(JSContext *ctx, JSFreeModuleEnum flag)\n{\n    struct list_head *el, *el1;\n    list_for_each_safe(el, el1, &ctx->loaded_modules) {\n        JSModuleDef *m = list_entry(el, JSModuleDef, link);\n        if (flag == JS_FREE_MODULE_ALL ||\n            (flag == JS_FREE_MODULE_NOT_RESOLVED && !m->resolved) ||\n            (flag == JS_FREE_MODULE_NOT_EVALUATED && !m->evaluated)) {\n            js_free_module_def(ctx, m);\n        }\n    }\n}\n\nJSContext *JS_DupContext(JSContext *ctx)\n{\n    ctx->header.ref_count++;\n    return ctx;\n}\n\n/* used by the GC */\nstatic void JS_MarkContext(JSRuntime *rt, JSContext *ctx,\n                           JS_MarkFunc *mark_func)\n{\n    int i;\n    struct list_head *el;\n\n    /* modules are not seen by the GC, so we directly mark the objects\n       referenced by each module */\n    list_for_each(el, &ctx->loaded_modules) {\n        JSModuleDef *m = list_entry(el, JSModuleDef, link);\n        js_mark_module_def(rt, m, mark_func);\n    }\n\n    JS_MarkValue(rt, ctx->global_obj, mark_func);\n    JS_MarkValue(rt, ctx->global_var_obj, mark_func);\n\n    JS_MarkValue(rt, ctx->throw_type_error, mark_func);\n    JS_MarkValue(rt, ctx->eval_obj, mark_func);\n\n    JS_MarkValue(rt, ctx->array_proto_values, mark_func);\n    for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {\n        JS_MarkValue(rt, ctx->native_error_proto[i], mark_func);\n    }\n    for(i = 0; i < rt->class_count; i++) {\n        JS_MarkValue(rt, ctx->class_proto[i], mark_func);\n    }\n    JS_MarkValue(rt, ctx->iterator_proto, mark_func);\n    JS_MarkValue(rt, ctx->async_iterator_proto, mark_func);\n    JS_MarkValue(rt, ctx->promise_ctor, mark_func);\n    JS_MarkValue(rt, ctx->array_ctor, mark_func);\n    JS_MarkValue(rt, ctx->regexp_ctor, mark_func);\n    JS_MarkValue(rt, ctx->function_ctor, mark_func);\n    JS_MarkValue(rt, ctx->function_proto, mark_func);\n\n    if (ctx->array_shape)\n        mark_func(rt, &ctx->array_shape->header);\n}\n\nvoid JS_FreeContext(JSContext *ctx)\n{\n    JSRuntime *rt = ctx->rt;\n    int i;\n\n    if (--ctx->header.ref_count > 0)\n        return;\n    assert(ctx->header.ref_count == 0);\n    \n#ifdef DUMP_ATOMS\n    JS_DumpAtoms(ctx->rt);\n#endif\n#ifdef DUMP_SHAPES\n    JS_DumpShapes(ctx->rt);\n#endif\n#ifdef DUMP_OBJECTS\n    {\n        struct list_head *el;\n        JSGCObjectHeader *p;\n        printf(\"JSObjects: {\\n\");\n        JS_DumpObjectHeader(ctx->rt);\n        list_for_each(el, &rt->gc_obj_list) {\n            p = list_entry(el, JSGCObjectHeader, link);\n            JS_DumpGCObject(rt, p);\n        }\n        printf(\"}\\n\");\n    }\n#endif\n#ifdef DUMP_MEM\n    {\n        JSMemoryUsage stats;\n        JS_ComputeMemoryUsage(rt, &stats);\n        JS_DumpMemoryUsage(stdout, &stats, rt);\n    }\n#endif\n#ifdef CONFIG_DEBUGGER\n    js_debugger_free_context(ctx);\n#endif\n    js_free_modules(ctx, JS_FREE_MODULE_ALL);\n\n    JS_FreeValue(ctx, ctx->global_obj);\n    JS_FreeValue(ctx, ctx->global_var_obj);\n\n    JS_FreeValue(ctx, ctx->throw_type_error);\n    JS_FreeValue(ctx, ctx->eval_obj);\n\n    JS_FreeValue(ctx, ctx->array_proto_values);\n    for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {\n        JS_FreeValue(ctx, ctx->native_error_proto[i]);\n    }\n    for(i = 0; i < rt->class_count; i++) {\n        JS_FreeValue(ctx, ctx->class_proto[i]);\n    }\n    js_free_rt(rt, ctx->class_proto);\n    JS_FreeValue(ctx, ctx->iterator_proto);\n    JS_FreeValue(ctx, ctx->async_iterator_proto);\n    JS_FreeValue(ctx, ctx->promise_ctor);\n    JS_FreeValue(ctx, ctx->array_ctor);\n    JS_FreeValue(ctx, ctx->regexp_ctor);\n    JS_FreeValue(ctx, ctx->function_ctor);\n    JS_FreeValue(ctx, ctx->function_proto);\n\n    js_free_shape_null(ctx->rt, ctx->array_shape);\n\n    list_del(&ctx->link);\n    remove_gc_object(&ctx->header);\n    js_free_rt(ctx->rt, ctx);\n}\n\nJSRuntime *JS_GetRuntime(JSContext *ctx)\n{\n    return ctx->rt;\n}\n\nstatic void update_stack_limit(JSRuntime *rt)\n{\n    if (rt->stack_size == 0) {\n        rt->stack_limit = 0; /* no limit */\n    } else {\n        rt->stack_limit = rt->stack_top - rt->stack_size;\n    }\n}\n\nvoid JS_SetMaxStackSize(JSRuntime *rt, size_t stack_size)\n{\n    rt->stack_size = stack_size;\n    update_stack_limit(rt);\n}\n\nvoid JS_UpdateStackTop(JSRuntime *rt)\n{\n    rt->stack_top = js_get_stack_pointer();\n    update_stack_limit(rt);\n}\n\nstatic inline BOOL is_strict_mode(JSContext *ctx)\n{\n    JSStackFrame *sf = ctx->rt->current_stack_frame;\n    return (sf && (sf->js_mode & JS_MODE_STRICT));\n}\n\n#ifdef CONFIG_BIGNUM\nstatic inline BOOL is_math_mode(JSContext *ctx)\n{\n    JSStackFrame *sf = ctx->rt->current_stack_frame;\n    return (sf && (sf->js_mode & JS_MODE_MATH));\n}\n#endif\n\n/* JSAtom support */\n\n#define JS_ATOM_TAG_INT (1U << 31)\n#define JS_ATOM_MAX_INT (JS_ATOM_TAG_INT - 1)\n#define JS_ATOM_MAX     ((1U << 30) - 1)\n\n/* return the max count from the hash size */\n#define JS_ATOM_COUNT_RESIZE(n) ((n) * 2)\n\nstatic inline BOOL __JS_AtomIsConst(JSAtom v)\n{\n#if defined(DUMP_LEAKS) && DUMP_LEAKS > 1\n        return (int32_t)v <= 0;\n#else\n        return (int32_t)v < JS_ATOM_END;\n#endif\n}\n\nstatic inline BOOL __JS_AtomIsTaggedInt(JSAtom v)\n{\n    return (v & JS_ATOM_TAG_INT) != 0;\n}\n\nstatic inline JSAtom __JS_AtomFromUInt32(uint32_t v)\n{\n    return v | JS_ATOM_TAG_INT;\n}\n\nstatic inline uint32_t __JS_AtomToUInt32(JSAtom atom)\n{\n    return atom & ~JS_ATOM_TAG_INT;\n}\n\nstatic inline int is_num(int c)\n{\n    return c >= '0' && c <= '9';\n}\n\n/* return TRUE if the string is a number n with 0 <= n <= 2^32-1 */\nstatic inline BOOL is_num_string(uint32_t *pval, const JSString *p)\n{\n    uint32_t n;\n    uint64_t n64;\n    int c, i, len;\n\n    len = p->len;\n    if (len == 0 || len > 10)\n        return FALSE;\n    if (p->is_wide_char)\n        c = p->u.str16[0];\n    else\n        c = p->u.str8[0];\n    if (is_num(c)) {\n        if (c == '0') {\n            if (len != 1)\n                return FALSE;\n            n = 0;\n        } else {\n            n = c - '0';\n            for(i = 1; i < len; i++) {\n                if (p->is_wide_char)\n                    c = p->u.str16[i];\n                else\n                    c = p->u.str8[i];\n                if (!is_num(c))\n                    return FALSE;\n                n64 = (uint64_t)n * 10 + (c - '0');\n                if ((n64 >> 32) != 0)\n                    return FALSE;\n                n = n64;\n            }\n        }\n        *pval = n;\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\n\n/* XXX: could use faster version ? */\nstatic inline uint32_t hash_string8(const uint8_t *str, size_t len, uint32_t h)\n{\n    size_t i;\n\n    for(i = 0; i < len; i++)\n        h = h * 263 + str[i];\n    return h;\n}\n\nstatic inline uint32_t hash_string16(const uint16_t *str,\n                                     size_t len, uint32_t h)\n{\n    size_t i;\n\n    for(i = 0; i < len; i++)\n        h = h * 263 + str[i];\n    return h;\n}\n\nstatic uint32_t hash_string(const JSString *str, uint32_t h)\n{\n    if (str->is_wide_char)\n        h = hash_string16(str->u.str16, str->len, h);\n    else\n        h = hash_string8(str->u.str8, str->len, h);\n    return h;\n}\n\nstatic __maybe_unused void JS_DumpString(JSRuntime *rt,\n                                                  const JSString *p)\n{\n    int i, c, sep;\n\n    if (p == NULL) {\n        printf(\"<null>\");\n        return;\n    }\n    printf(\"%d\", p->header.ref_count);\n    sep = (p->header.ref_count == 1) ? '\\\"' : '\\'';\n    putchar(sep);\n    for(i = 0; i < p->len; i++) {\n        if (p->is_wide_char)\n            c = p->u.str16[i];\n        else\n            c = p->u.str8[i];\n        if (c == sep || c == '\\\\') {\n            putchar('\\\\');\n            putchar(c);\n        } else if (c >= ' ' && c <= 126) {\n            putchar(c);\n        } else if (c == '\\n') {\n            putchar('\\\\');\n            putchar('n');\n        } else {\n            printf(\"\\\\u%04x\", c);\n        }\n    }\n    putchar(sep);\n}\n\nstatic __maybe_unused void JS_DumpAtoms(JSRuntime *rt)\n{\n    JSAtomStruct *p;\n    int h, i;\n    /* This only dumps hashed atoms, not JS_ATOM_TYPE_SYMBOL atoms */\n    printf(\"JSAtom count=%d size=%d hash_size=%d:\\n\",\n           rt->atom_count, rt->atom_size, rt->atom_hash_size);\n    printf(\"JSAtom hash table: {\\n\");\n    for(i = 0; i < rt->atom_hash_size; i++) {\n        h = rt->atom_hash[i];\n        if (h) {\n            printf(\"  %d:\", i);\n            while (h) {\n                p = rt->atom_array[h];\n                printf(\" \");\n                JS_DumpString(rt, p);\n                h = p->hash_next;\n            }\n            printf(\"\\n\");\n        }\n    }\n    printf(\"}\\n\");\n    printf(\"JSAtom table: {\\n\");\n    for(i = 0; i < rt->atom_size; i++) {\n        p = rt->atom_array[i];\n        if (!atom_is_free(p)) {\n            printf(\"  %d: { %d %08x \", i, p->atom_type, p->hash);\n            if (!(p->len == 0 && p->is_wide_char != 0))\n                JS_DumpString(rt, p);\n            printf(\" %d }\\n\", p->hash_next);\n        }\n    }\n    printf(\"}\\n\");\n}\n\nstatic int JS_ResizeAtomHash(JSRuntime *rt, int new_hash_size)\n{\n    JSAtomStruct *p;\n    uint32_t new_hash_mask, h, i, hash_next1, j, *new_hash;\n\n    assert((new_hash_size & (new_hash_size - 1)) == 0); /* power of two */\n    new_hash_mask = new_hash_size - 1;\n    new_hash = js_mallocz_rt(rt, sizeof(rt->atom_hash[0]) * new_hash_size);\n    if (!new_hash)\n        return -1;\n    for(i = 0; i < rt->atom_hash_size; i++) {\n        h = rt->atom_hash[i];\n        while (h != 0) {\n            p = rt->atom_array[h];\n            hash_next1 = p->hash_next;\n            /* add in new hash table */\n            j = p->hash & new_hash_mask;\n            p->hash_next = new_hash[j];\n            new_hash[j] = h;\n            h = hash_next1;\n        }\n    }\n    js_free_rt(rt, rt->atom_hash);\n    rt->atom_hash = new_hash;\n    rt->atom_hash_size = new_hash_size;\n    rt->atom_count_resize = JS_ATOM_COUNT_RESIZE(new_hash_size);\n    //    JS_DumpAtoms(rt);\n    return 0;\n}\n\nstatic int JS_InitAtoms(JSRuntime *rt)\n{\n    int i, len, atom_type;\n    const char *p;\n\n    rt->atom_hash_size = 0;\n    rt->atom_hash = NULL;\n    rt->atom_count = 0;\n    rt->atom_size = 0;\n    rt->atom_free_index = 0;\n    if (JS_ResizeAtomHash(rt, 256))     /* there are at least 195 predefined atoms */\n        return -1;\n\n    p = js_atom_init;\n    for(i = 1; i < JS_ATOM_END; i++) {\n        if (i == JS_ATOM_Private_brand)\n            atom_type = JS_ATOM_TYPE_PRIVATE;\n        else if (i >= JS_ATOM_Symbol_toPrimitive)\n            atom_type = JS_ATOM_TYPE_SYMBOL;\n        else\n            atom_type = JS_ATOM_TYPE_STRING;\n        len = strlen(p);\n        if (__JS_NewAtomInit(rt, p, len, atom_type) == JS_ATOM_NULL)\n            return -1;\n        p = p + len + 1;\n    }\n    return 0;\n}\n\nstatic JSAtom JS_DupAtomRT(JSRuntime *rt, JSAtom v)\n{\n    JSAtomStruct *p;\n\n    if (!__JS_AtomIsConst(v)) {\n        p = rt->atom_array[v];\n        p->header.ref_count++;\n    }\n    return v;\n}\n\nJSAtom JS_DupAtom(JSContext *ctx, JSAtom v)\n{\n    JSRuntime *rt;\n    JSAtomStruct *p;\n\n    if (!__JS_AtomIsConst(v)) {\n        rt = ctx->rt;\n        p = rt->atom_array[v];\n        p->header.ref_count++;\n    }\n    return v;\n}\n\nstatic JSAtomKindEnum JS_AtomGetKind(JSContext *ctx, JSAtom v)\n{\n    JSRuntime *rt;\n    JSAtomStruct *p;\n\n    rt = ctx->rt;\n    if (__JS_AtomIsTaggedInt(v))\n        return JS_ATOM_KIND_STRING;\n    p = rt->atom_array[v];\n    switch(p->atom_type) {\n    case JS_ATOM_TYPE_STRING:\n        return JS_ATOM_KIND_STRING;\n    case JS_ATOM_TYPE_GLOBAL_SYMBOL:\n        return JS_ATOM_KIND_SYMBOL;\n    case JS_ATOM_TYPE_SYMBOL:\n        switch(p->hash) {\n        case JS_ATOM_HASH_SYMBOL:\n            return JS_ATOM_KIND_SYMBOL;\n        case JS_ATOM_HASH_PRIVATE:\n            return JS_ATOM_KIND_PRIVATE;\n        default:\n            abort();\n        }\n    default:\n        abort();\n    }\n}\n\nstatic BOOL JS_AtomIsString(JSContext *ctx, JSAtom v)\n{\n    return JS_AtomGetKind(ctx, v) == JS_ATOM_KIND_STRING;\n}\n\nstatic JSAtom js_get_atom_index(JSRuntime *rt, JSAtomStruct *p)\n{\n    uint32_t i = p->hash_next;  /* atom_index */\n    if (p->atom_type != JS_ATOM_TYPE_SYMBOL) {\n        JSAtomStruct *p1;\n\n        i = rt->atom_hash[p->hash & (rt->atom_hash_size - 1)];\n        p1 = rt->atom_array[i];\n        while (p1 != p) {\n            assert(i != 0);\n            i = p1->hash_next;\n            p1 = rt->atom_array[i];\n        }\n    }\n    return i;\n}\n\n/* string case (internal). Return JS_ATOM_NULL if error. 'str' is\n   freed. */\nstatic JSAtom __JS_NewAtom(JSRuntime *rt, JSString *str, int atom_type)\n{\n    uint32_t h, h1, i;\n    JSAtomStruct *p;\n    int len;\n\n#if 0\n    printf(\"__JS_NewAtom: \");  JS_DumpString(rt, str); printf(\"\\n\");\n#endif\n    if (atom_type < JS_ATOM_TYPE_SYMBOL) {\n        /* str is not NULL */\n        if (str->atom_type == atom_type) {\n            /* str is the atom, return its index */\n            i = js_get_atom_index(rt, str);\n            /* reduce string refcount and increase atom's unless constant */\n            if (__JS_AtomIsConst(i))\n                str->header.ref_count--;\n            return i;\n        }\n        /* try and locate an already registered atom */\n        len = str->len;\n        h = hash_string(str, atom_type);\n        h &= JS_ATOM_HASH_MASK;\n        h1 = h & (rt->atom_hash_size - 1);\n        i = rt->atom_hash[h1];\n        while (i != 0) {\n            p = rt->atom_array[i];\n            if (p->hash == h &&\n                p->atom_type == atom_type &&\n                p->len == len &&\n                js_string_memcmp(p, str, len) == 0) {\n                if (!__JS_AtomIsConst(i))\n                    p->header.ref_count++;\n                goto done;\n            }\n            i = p->hash_next;\n        }\n    } else {\n        h1 = 0; /* avoid warning */\n        if (atom_type == JS_ATOM_TYPE_SYMBOL) {\n            h = JS_ATOM_HASH_SYMBOL;\n        } else {\n            h = JS_ATOM_HASH_PRIVATE;\n            atom_type = JS_ATOM_TYPE_SYMBOL;\n        }\n    }\n\n    if (rt->atom_free_index == 0) {\n        /* allow new atom entries */\n        uint32_t new_size, start;\n        JSAtomStruct **new_array;\n\n        /* alloc new with size progression 3/2:\n           4 6 9 13 19 28 42 63 94 141 211 316 474 711 1066 1599 2398 3597 5395 8092\n           preallocating space for predefined atoms (at least 195).\n         */\n        new_size = max_int(211, rt->atom_size * 3 / 2);\n        if (new_size > JS_ATOM_MAX)\n            goto fail;\n        /* XXX: should use realloc2 to use slack space */\n        new_array = js_realloc_rt(rt, rt->atom_array, sizeof(*new_array) * new_size);\n        if (!new_array)\n            goto fail;\n        /* Note: the atom 0 is not used */\n        start = rt->atom_size;\n        if (start == 0) {\n            /* JS_ATOM_NULL entry */\n            p = js_mallocz_rt(rt, sizeof(JSAtomStruct));\n            if (!p) {\n                js_free_rt(rt, new_array);\n                goto fail;\n            }\n            p->header.ref_count = 1;  /* not refcounted */\n            p->atom_type = JS_ATOM_TYPE_SYMBOL;\n#ifdef DUMP_LEAKS\n            list_add_tail(&p->link, &rt->string_list);\n#endif\n            new_array[0] = p;\n            rt->atom_count++;\n            start = 1;\n        }\n        rt->atom_size = new_size;\n        rt->atom_array = new_array;\n        rt->atom_free_index = start;\n        for(i = start; i < new_size; i++) {\n            uint32_t next;\n            if (i == (new_size - 1))\n                next = 0;\n            else\n                next = i + 1;\n            rt->atom_array[i] = atom_set_free(next);\n        }\n    }\n\n    if (str) {\n        if (str->atom_type == 0) {\n            p = str;\n            p->atom_type = atom_type;\n        } else {\n            p = js_malloc_rt(rt, sizeof(JSString) +\n                             (str->len << str->is_wide_char) +\n                             1 - str->is_wide_char);\n            if (unlikely(!p))\n                goto fail;\n            p->header.ref_count = 1;\n            p->is_wide_char = str->is_wide_char;\n            p->len = str->len;\n#ifdef DUMP_LEAKS\n            list_add_tail(&p->link, &rt->string_list);\n#endif\n            memcpy(p->u.str8, str->u.str8, (str->len << str->is_wide_char) +\n                   1 - str->is_wide_char);\n            js_free_string(rt, str);\n        }\n    } else {\n        p = js_malloc_rt(rt, sizeof(JSAtomStruct)); /* empty wide string */\n        if (!p)\n            return JS_ATOM_NULL;\n        p->header.ref_count = 1;\n        p->is_wide_char = 1;    /* Hack to represent NULL as a JSString */\n        p->len = 0;\n#ifdef DUMP_LEAKS\n        list_add_tail(&p->link, &rt->string_list);\n#endif\n    }\n\n    /* use an already free entry */\n    i = rt->atom_free_index;\n    rt->atom_free_index = atom_get_free(rt->atom_array[i]);\n    rt->atom_array[i] = p;\n\n    p->hash = h;\n    p->hash_next = i;   /* atom_index */\n    p->atom_type = atom_type;\n\n    rt->atom_count++;\n\n    if (atom_type != JS_ATOM_TYPE_SYMBOL) {\n        p->hash_next = rt->atom_hash[h1];\n        rt->atom_hash[h1] = i;\n        if (unlikely(rt->atom_count >= rt->atom_count_resize))\n            JS_ResizeAtomHash(rt, rt->atom_hash_size * 2);\n    }\n\n    //    JS_DumpAtoms(rt);\n    return i;\n\n fail:\n    i = JS_ATOM_NULL;\n done:\n    if (str)\n        js_free_string(rt, str);\n    return i;\n}\n\n/* only works with zero terminated 8 bit strings */\nstatic JSAtom __JS_NewAtomInit(JSRuntime *rt, const char *str, int len,\n                               int atom_type)\n{\n    JSString *p;\n    p = js_alloc_string_rt(rt, len, 0);\n    if (!p)\n        return JS_ATOM_NULL;\n    memcpy(p->u.str8, str, len);\n    p->u.str8[len] = '\\0';\n    return __JS_NewAtom(rt, p, atom_type);\n}\n\nstatic JSAtom __JS_FindAtom(JSRuntime *rt, const char *str, size_t len,\n                            int atom_type)\n{\n    uint32_t h, h1, i;\n    JSAtomStruct *p;\n\n    h = hash_string8((const uint8_t *)str, len, JS_ATOM_TYPE_STRING);\n    h &= JS_ATOM_HASH_MASK;\n    h1 = h & (rt->atom_hash_size - 1);\n    i = rt->atom_hash[h1];\n    while (i != 0) {\n        p = rt->atom_array[i];\n        if (p->hash == h &&\n            p->atom_type == JS_ATOM_TYPE_STRING &&\n            p->len == len &&\n            p->is_wide_char == 0 &&\n            memcmp(p->u.str8, str, len) == 0) {\n            if (!__JS_AtomIsConst(i))\n                p->header.ref_count++;\n            return i;\n        }\n        i = p->hash_next;\n    }\n    return JS_ATOM_NULL;\n}\n\nstatic void JS_FreeAtomStruct(JSRuntime *rt, JSAtomStruct *p)\n{\n#if 0   /* JS_ATOM_NULL is not refcounted: __JS_AtomIsConst() includes 0 */\n    if (unlikely(i == JS_ATOM_NULL)) {\n        p->header.ref_count = INT32_MAX / 2;\n        return;\n    }\n#endif\n    uint32_t i = p->hash_next;  /* atom_index */\n    if (p->atom_type != JS_ATOM_TYPE_SYMBOL) {\n        JSAtomStruct *p0, *p1;\n        uint32_t h0;\n\n        h0 = p->hash & (rt->atom_hash_size - 1);\n        i = rt->atom_hash[h0];\n        p1 = rt->atom_array[i];\n        if (p1 == p) {\n            rt->atom_hash[h0] = p1->hash_next;\n        } else {\n            for(;;) {\n                assert(i != 0);\n                p0 = p1;\n                i = p1->hash_next;\n                p1 = rt->atom_array[i];\n                if (p1 == p) {\n                    p0->hash_next = p1->hash_next;\n                    break;\n                }\n            }\n        }\n    }\n    /* insert in free atom list */\n    rt->atom_array[i] = atom_set_free(rt->atom_free_index);\n    rt->atom_free_index = i;\n    /* free the string structure */\n#ifdef DUMP_LEAKS\n    list_del(&p->link);\n#endif\n    js_free_rt(rt, p);\n    rt->atom_count--;\n    assert(rt->atom_count >= 0);\n}\n\nstatic void __JS_FreeAtom(JSRuntime *rt, uint32_t i)\n{\n    JSAtomStruct *p;\n\n    p = rt->atom_array[i];\n        if (--p->header.ref_count > 0)\n        return;\n    JS_FreeAtomStruct(rt, p);\n}\n\n/* Warning: 'p' is freed */\nstatic JSAtom JS_NewAtomStr(JSContext *ctx, JSString *p)\n{\n    JSRuntime *rt = ctx->rt;\n    uint32_t n;\n    if (is_num_string(&n, p)) {\n        if (n <= JS_ATOM_MAX_INT) {\n            js_free_string(rt, p);\n            return __JS_AtomFromUInt32(n);\n        }\n    }\n    /* XXX: should generate an exception */\n    return __JS_NewAtom(rt, p, JS_ATOM_TYPE_STRING);\n}\n\nJSAtom JS_NewAtomLen(JSContext *ctx, const char *str, size_t len)\n{\n    JSValue val;\n\n    if (len == 0 || !is_digit(*str)) {\n        JSAtom atom = __JS_FindAtom(ctx->rt, str, len, JS_ATOM_TYPE_STRING);\n        if (atom)\n            return atom;\n    }\n    val = JS_NewStringLen(ctx, str, len);\n    if (JS_IsException(val))\n        return JS_ATOM_NULL;\n    return JS_NewAtomStr(ctx, JS_VALUE_GET_STRING(val));\n}\n\nJSAtom JS_NewAtom(JSContext *ctx, const char *str)\n{\n    return JS_NewAtomLen(ctx, str, strlen(str));\n}\n\nJSAtom JS_NewAtomUInt32(JSContext *ctx, uint32_t n)\n{\n    if (n <= JS_ATOM_MAX_INT) {\n        return __JS_AtomFromUInt32(n);\n    } else {\n        char buf[11];\n        JSValue val;\n        snprintf(buf, sizeof(buf), \"%u\", n);\n        val = JS_NewString(ctx, buf);\n        if (JS_IsException(val))\n            return JS_ATOM_NULL;\n        return __JS_NewAtom(ctx->rt, JS_VALUE_GET_STRING(val),\n                            JS_ATOM_TYPE_STRING);\n    }\n}\n\nstatic JSAtom JS_NewAtomInt64(JSContext *ctx, int64_t n)\n{\n    if ((uint64_t)n <= JS_ATOM_MAX_INT) {\n        return __JS_AtomFromUInt32((uint32_t)n);\n    } else {\n        char buf[24];\n        JSValue val;\n        snprintf(buf, sizeof(buf), \"%\" PRId64 , n);\n        val = JS_NewString(ctx, buf);\n        if (JS_IsException(val))\n            return JS_ATOM_NULL;\n        return __JS_NewAtom(ctx->rt, JS_VALUE_GET_STRING(val),\n                            JS_ATOM_TYPE_STRING);\n    }\n}\n\n/* 'p' is freed */\nstatic JSValue JS_NewSymbol(JSContext *ctx, JSString *p, int atom_type)\n{\n    JSRuntime *rt = ctx->rt;\n    JSAtom atom;\n    atom = __JS_NewAtom(rt, p, atom_type);\n    if (atom == JS_ATOM_NULL)\n        return JS_ThrowOutOfMemory(ctx);\n    return JS_MKPTR(JS_TAG_SYMBOL, rt->atom_array[atom]);\n}\n\n/* descr must be a non-numeric string atom */\nstatic JSValue JS_NewSymbolFromAtom(JSContext *ctx, JSAtom descr,\n                                    int atom_type)\n{\n    JSRuntime *rt = ctx->rt;\n    JSString *p;\n\n    assert(!__JS_AtomIsTaggedInt(descr));\n    assert(descr < rt->atom_size);\n    p = rt->atom_array[descr];\n    JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, p));\n    return JS_NewSymbol(ctx, p, atom_type);\n}\n\n#define ATOM_GET_STR_BUF_SIZE 64\n\n/* Should only be used for debug. */\nstatic const char *JS_AtomGetStrRT(JSRuntime *rt, char *buf, int buf_size,\n                                   JSAtom atom)\n{\n    if (__JS_AtomIsTaggedInt(atom)) {\n        snprintf(buf, buf_size, \"%u\", __JS_AtomToUInt32(atom));\n    } else {\n        JSAtomStruct *p;\n        assert(atom < rt->atom_size);\n        if (atom == JS_ATOM_NULL) {\n            snprintf(buf, buf_size, \"<null>\");\n        } else {\n            int i, c;\n            char *q;\n            JSString *str;\n\n            q = buf;\n            p = rt->atom_array[atom];\n            assert(!atom_is_free(p));\n            str = p;\n            if (str) {\n                if (!str->is_wide_char) {\n                    /* special case ASCII strings */\n                    c = 0;\n                    for(i = 0; i < str->len; i++) {\n                        c |= str->u.str8[i];\n                    }\n                    if (c < 0x80)\n                        return (const char *)str->u.str8;\n                }\n                for(i = 0; i < str->len; i++) {\n                    if (str->is_wide_char)\n                        c = str->u.str16[i];\n                    else\n                        c = str->u.str8[i];\n                    if ((q - buf) >= buf_size - UTF8_CHAR_LEN_MAX)\n                        break;\n                    if (c < 128) {\n                        *q++ = c;\n                    } else {\n                        q += unicode_to_utf8((uint8_t *)q, c);\n                    }\n                }\n            }\n            *q = '\\0';\n        }\n    }\n    return buf;\n}\n\nstatic const char *JS_AtomGetStr(JSContext *ctx, char *buf, int buf_size, JSAtom atom)\n{\n    return JS_AtomGetStrRT(ctx->rt, buf, buf_size, atom);\n}\n\nstatic JSValue __JS_AtomToValue(JSContext *ctx, JSAtom atom, BOOL force_string)\n{\n    char buf[ATOM_GET_STR_BUF_SIZE];\n\n    if (__JS_AtomIsTaggedInt(atom)) {\n        snprintf(buf, sizeof(buf), \"%u\", __JS_AtomToUInt32(atom));\n        return JS_NewString(ctx, buf);\n    } else {\n        JSRuntime *rt = ctx->rt;\n        JSAtomStruct *p;\n        assert(atom < rt->atom_size);\n        p = rt->atom_array[atom];\n        if (p->atom_type == JS_ATOM_TYPE_STRING) {\n            goto ret_string;\n        } else if (force_string) {\n            if (p->len == 0 && p->is_wide_char != 0) {\n                /* no description string */\n                p = rt->atom_array[JS_ATOM_empty_string];\n            }\n        ret_string:\n            return JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, p));\n        } else {\n            return JS_DupValue(ctx, JS_MKPTR(JS_TAG_SYMBOL, p));\n        }\n    }\n}\n\nJSValue JS_AtomToValue(JSContext *ctx, JSAtom atom)\n{\n    return __JS_AtomToValue(ctx, atom, FALSE);\n}\n\nJSValue JS_AtomToString(JSContext *ctx, JSAtom atom)\n{\n    return __JS_AtomToValue(ctx, atom, TRUE);\n}\n\n/* return TRUE if the atom is an array index (i.e. 0 <= index <=\n   2^32-2 and return its value */\nstatic BOOL JS_AtomIsArrayIndex(JSContext *ctx, uint32_t *pval, JSAtom atom)\n{\n    if (__JS_AtomIsTaggedInt(atom)) {\n        *pval = __JS_AtomToUInt32(atom);\n        return TRUE;\n    } else {\n        JSRuntime *rt = ctx->rt;\n        JSAtomStruct *p;\n        uint32_t val;\n\n        assert(atom < rt->atom_size);\n        p = rt->atom_array[atom];\n        if (p->atom_type == JS_ATOM_TYPE_STRING &&\n            is_num_string(&val, p) && val != -1) {\n            *pval = val;\n            return TRUE;\n        } else {\n            *pval = 0;\n            return FALSE;\n        }\n    }\n}\n\n/* This test must be fast if atom is not a numeric index (e.g. a\n   method name). Return JS_UNDEFINED if not a numeric\n   index. JS_EXCEPTION can also be returned. */\nstatic JSValue JS_AtomIsNumericIndex1(JSContext *ctx, JSAtom atom)\n{\n    JSRuntime *rt = ctx->rt;\n    JSAtomStruct *p1;\n    JSString *p;\n    int c, len, ret;\n    JSValue num, str;\n\n    if (__JS_AtomIsTaggedInt(atom))\n        return JS_NewInt32(ctx, __JS_AtomToUInt32(atom));\n    assert(atom < rt->atom_size);\n    p1 = rt->atom_array[atom];\n    if (p1->atom_type != JS_ATOM_TYPE_STRING)\n        return JS_UNDEFINED;\n    p = p1;\n    len = p->len;\n    if (p->is_wide_char) {\n        const uint16_t *r = p->u.str16, *r_end = p->u.str16 + len;\n        if (r >= r_end)\n            return JS_UNDEFINED;\n        c = *r;\n        if (c == '-') {\n            if (r >= r_end)\n                return JS_UNDEFINED;\n            r++;\n            c = *r;\n            /* -0 case is specific */\n            if (c == '0' && len == 2)\n                goto minus_zero;\n        }\n        /* XXX: should test NaN, but the tests do not check it */\n        if (!is_num(c)) {\n            /* XXX: String should be normalized, therefore 8-bit only */\n            const uint16_t nfinity16[7] = { 'n', 'f', 'i', 'n', 'i', 't', 'y' };\n            if (!(c =='I' && (r_end - r) == 8 &&\n                  !memcmp(r + 1, nfinity16, sizeof(nfinity16))))\n                return JS_UNDEFINED;\n        }\n    } else {\n        const uint8_t *r = p->u.str8, *r_end = p->u.str8 + len;\n        if (r >= r_end)\n            return JS_UNDEFINED;\n        c = *r;\n        if (c == '-') {\n            if (r >= r_end)\n                return JS_UNDEFINED;\n            r++;\n            c = *r;\n            /* -0 case is specific */\n            if (c == '0' && len == 2) {\n            minus_zero:\n                return __JS_NewFloat64(ctx, -0.0);\n            }\n        }\n        if (!is_num(c)) {\n            if (!(c =='I' && (r_end - r) == 8 &&\n                  !memcmp(r + 1, \"nfinity\", 7)))\n                return JS_UNDEFINED;\n        }\n    }\n    /* XXX: bignum: would be better to only accept integer to avoid\n       relying on current floating point precision */\n    /* this is ECMA CanonicalNumericIndexString primitive */\n    num = JS_ToNumber(ctx, JS_MKPTR(JS_TAG_STRING, p));\n    if (JS_IsException(num))\n        return num;\n    str = JS_ToString(ctx, num);\n    if (JS_IsException(str)) {\n        JS_FreeValue(ctx, num);\n        return str;\n    }\n    ret = js_string_compare(ctx, p, JS_VALUE_GET_STRING(str));\n    JS_FreeValue(ctx, str);\n    if (ret == 0) {\n        return num;\n    } else {\n        JS_FreeValue(ctx, num);\n        return JS_UNDEFINED;\n    }\n}\n\n/* return -1 if exception or TRUE/FALSE */\nstatic int JS_AtomIsNumericIndex(JSContext *ctx, JSAtom atom)\n{\n    JSValue num;\n    num = JS_AtomIsNumericIndex1(ctx, atom);\n    if (likely(JS_IsUndefined(num)))\n        return FALSE;\n    if (JS_IsException(num))\n        return -1;\n    JS_FreeValue(ctx, num);\n    return TRUE;\n}\n\nvoid JS_FreeAtom(JSContext *ctx, JSAtom v)\n{\n    if (!__JS_AtomIsConst(v))\n        __JS_FreeAtom(ctx->rt, v);\n}\n\nvoid JS_FreeAtomRT(JSRuntime *rt, JSAtom v)\n{\n    if (!__JS_AtomIsConst(v))\n        __JS_FreeAtom(rt, v);\n}\n\n/* return TRUE if 'v' is a symbol with a string description */\nstatic BOOL JS_AtomSymbolHasDescription(JSContext *ctx, JSAtom v)\n{\n    JSRuntime *rt;\n    JSAtomStruct *p;\n\n    rt = ctx->rt;\n    if (__JS_AtomIsTaggedInt(v))\n        return FALSE;\n    p = rt->atom_array[v];\n    return (((p->atom_type == JS_ATOM_TYPE_SYMBOL &&\n              p->hash == JS_ATOM_HASH_SYMBOL) ||\n             p->atom_type == JS_ATOM_TYPE_GLOBAL_SYMBOL) &&\n            !(p->len == 0 && p->is_wide_char != 0));\n}\n\nstatic __maybe_unused void print_atom(JSContext *ctx, JSAtom atom)\n{\n    char buf[ATOM_GET_STR_BUF_SIZE];\n    const char *p;\n    int i;\n\n    /* XXX: should handle embedded null characters */\n    /* XXX: should move encoding code to JS_AtomGetStr */\n    p = JS_AtomGetStr(ctx, buf, sizeof(buf), atom);\n    for (i = 0; p[i]; i++) {\n        int c = (unsigned char)p[i];\n        if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||\n              (c == '_' || c == '$') || (c >= '0' && c <= '9' && i > 0)))\n            break;\n    }\n    if (i > 0 && p[i] == '\\0') {\n        printf(\"%s\", p);\n    } else {\n        putchar('\"');\n        printf(\"%.*s\", i, p);\n        for (; p[i]; i++) {\n            int c = (unsigned char)p[i];\n            if (c == '\\\"' || c == '\\\\') {\n                putchar('\\\\');\n                putchar(c);\n            } else if (c >= ' ' && c <= 126) {\n                putchar(c);\n            } else if (c == '\\n') {\n                putchar('\\\\');\n                putchar('n');\n            } else {\n                printf(\"\\\\u%04x\", c);\n            }\n        }\n        putchar('\\\"');\n    }\n}\n\n/* free with JS_FreeCString() */\nconst char *JS_AtomToCString(JSContext *ctx, JSAtom atom)\n{\n    JSValue str;\n    const char *cstr;\n\n    str = JS_AtomToString(ctx, atom);\n    if (JS_IsException(str))\n        return NULL;\n    cstr = JS_ToCString(ctx, str);\n    JS_FreeValue(ctx, str);\n    return cstr;\n}\n\n/* return a string atom containing name concatenated with str1 */\nstatic JSAtom js_atom_concat_str(JSContext *ctx, JSAtom name, const char *str1)\n{\n    JSValue str;\n    JSAtom atom;\n    const char *cstr;\n    char *cstr2;\n    size_t len, len1;\n    \n    str = JS_AtomToString(ctx, name);\n    if (JS_IsException(str))\n        return JS_ATOM_NULL;\n    cstr = JS_ToCStringLen(ctx, &len, str);\n    if (!cstr)\n        goto fail;\n    len1 = strlen(str1);\n    cstr2 = js_malloc(ctx, len + len1 + 1);\n    if (!cstr2)\n        goto fail;\n    memcpy(cstr2, cstr, len);\n    memcpy(cstr2 + len, str1, len1);\n    cstr2[len + len1] = '\\0';\n    atom = JS_NewAtomLen(ctx, cstr2, len + len1);\n    js_free(ctx, cstr2);\n    JS_FreeCString(ctx, cstr);\n    JS_FreeValue(ctx, str);\n    return atom;\n fail:\n    JS_FreeCString(ctx, cstr);\n    JS_FreeValue(ctx, str);\n    return JS_ATOM_NULL;\n}\n\nstatic JSAtom js_atom_concat_num(JSContext *ctx, JSAtom name, uint32_t n)\n{\n    char buf[16];\n    snprintf(buf, sizeof(buf), \"%u\", n);\n    return js_atom_concat_str(ctx, name, buf);\n}\n\nstatic inline BOOL JS_IsEmptyString(JSValueConst v)\n{\n    return JS_VALUE_GET_TAG(v) == JS_TAG_STRING && JS_VALUE_GET_STRING(v)->len == 0;\n}\n\n/* JSClass support */\n\n/* a new class ID is allocated if *pclass_id != 0 */\nJSClassID JS_NewClassID(JSClassID *pclass_id)\n{\n    JSClassID class_id;\n    /* XXX: make it thread safe */\n    class_id = *pclass_id;\n    if (class_id == 0) {\n        class_id = js_class_id_alloc++;\n        *pclass_id = class_id;\n    }\n    return class_id;\n}\n\nBOOL JS_IsRegisteredClass(JSRuntime *rt, JSClassID class_id)\n{\n    return (class_id < rt->class_count &&\n            rt->class_array[class_id].class_id != 0);\n}\n\n/* create a new object internal class. Return -1 if error, 0 if\n   OK. The finalizer can be NULL if none is needed. */\nstatic int JS_NewClass1(JSRuntime *rt, JSClassID class_id,\n                        const JSClassDef *class_def, JSAtom name)\n{\n    int new_size, i;\n    JSClass *cl, *new_class_array;\n    struct list_head *el;\n\n    if (class_id >= (1 << 16))\n        return -1;\n    if (class_id < rt->class_count &&\n        rt->class_array[class_id].class_id != 0)\n        return -1;\n\n    if (class_id >= rt->class_count) {\n        new_size = max_int(JS_CLASS_INIT_COUNT,\n                           max_int(class_id + 1, rt->class_count * 3 / 2));\n\n        /* reallocate the context class prototype array, if any */\n        list_for_each(el, &rt->context_list) {\n            JSContext *ctx = list_entry(el, JSContext, link);\n            JSValue *new_tab;\n            new_tab = js_realloc_rt(rt, ctx->class_proto,\n                                    sizeof(ctx->class_proto[0]) * new_size);\n            if (!new_tab)\n                return -1;\n            for(i = rt->class_count; i < new_size; i++)\n                new_tab[i] = JS_NULL;\n            ctx->class_proto = new_tab;\n        }\n        /* reallocate the class array */\n        new_class_array = js_realloc_rt(rt, rt->class_array,\n                                        sizeof(JSClass) * new_size);\n        if (!new_class_array)\n            return -1;\n        memset(new_class_array + rt->class_count, 0,\n               (new_size - rt->class_count) * sizeof(JSClass));\n        rt->class_array = new_class_array;\n        rt->class_count = new_size;\n    }\n    cl = &rt->class_array[class_id];\n    cl->class_id = class_id;\n    cl->class_name = JS_DupAtomRT(rt, name);\n    cl->finalizer = class_def->finalizer;\n    cl->gc_mark = class_def->gc_mark;\n    cl->call = class_def->call;\n    cl->exotic = class_def->exotic;\n    return 0;\n}\n\nint JS_NewClass(JSRuntime *rt, JSClassID class_id, const JSClassDef *class_def)\n{\n    int ret, len;\n    JSAtom name;\n\n    len = strlen(class_def->class_name);\n    name = __JS_FindAtom(rt, class_def->class_name, len, JS_ATOM_TYPE_STRING);\n    if (name == JS_ATOM_NULL) {\n        name = __JS_NewAtomInit(rt, class_def->class_name, len, JS_ATOM_TYPE_STRING);\n        if (name == JS_ATOM_NULL)\n            return -1;\n    }\n    ret = JS_NewClass1(rt, class_id, class_def, name);\n    JS_FreeAtomRT(rt, name);\n    return ret;\n}\n\nstatic JSValue js_new_string8(JSContext *ctx, const uint8_t *buf, int len)\n{\n    JSString *str;\n\n    if (len <= 0) {\n        return JS_AtomToString(ctx, JS_ATOM_empty_string);\n    }\n    str = js_alloc_string(ctx, len, 0);\n    if (!str)\n        return JS_EXCEPTION;\n    memcpy(str->u.str8, buf, len);\n    str->u.str8[len] = '\\0';\n    return JS_MKPTR(JS_TAG_STRING, str);\n}\n\nstatic JSValue js_new_string16(JSContext *ctx, const uint16_t *buf, int len)\n{\n    JSString *str;\n    str = js_alloc_string(ctx, len, 1);\n    if (!str)\n        return JS_EXCEPTION;\n    memcpy(str->u.str16, buf, len * 2);\n    return JS_MKPTR(JS_TAG_STRING, str);\n}\n\nstatic JSValue js_new_string_char(JSContext *ctx, uint16_t c)\n{\n    if (c < 0x100) {\n        uint8_t ch8 = c;\n        return js_new_string8(ctx, &ch8, 1);\n    } else {\n        uint16_t ch16 = c;\n        return js_new_string16(ctx, &ch16, 1);\n    }\n}\n\nstatic JSValue js_sub_string(JSContext *ctx, JSString *p, int start, int end)\n{\n    int len = end - start;\n    if (start == 0 && end == p->len) {\n        return JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, p));\n    }\n    if (p->is_wide_char && len > 0) {\n        JSString *str;\n        int i;\n        uint16_t c = 0;\n        for (i = start; i < end; i++) {\n            c |= p->u.str16[i];\n        }\n        if (c > 0xFF)\n            return js_new_string16(ctx, p->u.str16 + start, len);\n\n        str = js_alloc_string(ctx, len, 0);\n        if (!str)\n            return JS_EXCEPTION;\n        for (i = 0; i < len; i++) {\n            str->u.str8[i] = p->u.str16[start + i];\n        }\n        str->u.str8[len] = '\\0';\n        return JS_MKPTR(JS_TAG_STRING, str);\n    } else {\n        return js_new_string8(ctx, p->u.str8 + start, len);\n    }\n}\n\ntypedef struct StringBuffer {\n    JSContext *ctx;\n    JSString *str;\n    int len;\n    int size;\n    int is_wide_char;\n    int error_status;\n} StringBuffer;\n\n/* It is valid to call string_buffer_end() and all string_buffer functions even\n   if string_buffer_init() or another string_buffer function returns an error.\n   If the error_status is set, string_buffer_end() returns JS_EXCEPTION.\n */\nstatic int string_buffer_init2(JSContext *ctx, StringBuffer *s, int size,\n                               int is_wide)\n{\n    s->ctx = ctx;\n    s->size = size;\n    s->len = 0;\n    s->is_wide_char = is_wide;\n    s->error_status = 0;\n    s->str = js_alloc_string(ctx, size, is_wide);\n    if (unlikely(!s->str)) {\n        s->size = 0;\n        return s->error_status = -1;\n    }\n#ifdef DUMP_LEAKS\n    /* the StringBuffer may reallocate the JSString, only link it at the end */\n    list_del(&s->str->link);\n#endif\n    return 0;\n}\n\nstatic inline int string_buffer_init(JSContext *ctx, StringBuffer *s, int size)\n{\n    return string_buffer_init2(ctx, s, size, 0);\n}\n\nstatic void string_buffer_free(StringBuffer *s)\n{\n    js_free(s->ctx, s->str);\n    s->str = NULL;\n}\n\nstatic int string_buffer_set_error(StringBuffer *s)\n{\n    js_free(s->ctx, s->str);\n    s->str = NULL;\n    s->size = 0;\n    s->len = 0;\n    return s->error_status = -1;\n}\n\nstatic no_inline int string_buffer_widen(StringBuffer *s, int size)\n{\n    JSString *str;\n    size_t slack;\n    int i;\n\n    if (s->error_status)\n        return -1;\n\n    str = js_realloc2(s->ctx, s->str, sizeof(JSString) + (size << 1), &slack);\n    if (!str)\n        return string_buffer_set_error(s);\n    size += slack >> 1;\n    for(i = s->len; i-- > 0;) {\n        str->u.str16[i] = str->u.str8[i];\n    }\n    s->is_wide_char = 1;\n    s->size = size;\n    s->str = str;\n    return 0;\n}\n\nstatic no_inline int string_buffer_realloc(StringBuffer *s, int new_len, int c)\n{\n    JSString *new_str;\n    int new_size;\n    size_t new_size_bytes, slack;\n\n    if (s->error_status)\n        return -1;\n\n    if (new_len > JS_STRING_LEN_MAX) {\n        JS_ThrowInternalError(s->ctx, \"string too long\");\n        return string_buffer_set_error(s);\n    }\n    new_size = min_int(max_int(new_len, s->size * 3 / 2), JS_STRING_LEN_MAX);\n    if (!s->is_wide_char && c >= 0x100) {\n        return string_buffer_widen(s, new_size);\n    }\n    new_size_bytes = sizeof(JSString) + (new_size << s->is_wide_char) + 1 - s->is_wide_char;\n    new_str = js_realloc2(s->ctx, s->str, new_size_bytes, &slack);\n    if (!new_str)\n        return string_buffer_set_error(s);\n    new_size = min_int(new_size + (slack >> s->is_wide_char), JS_STRING_LEN_MAX);\n    s->size = new_size;\n    s->str = new_str;\n    return 0;\n}\n\nstatic no_inline int string_buffer_putc_slow(StringBuffer *s, uint32_t c)\n{\n    if (unlikely(s->len >= s->size)) {\n        if (string_buffer_realloc(s, s->len + 1, c))\n            return -1;\n    }\n    if (s->is_wide_char) {\n        s->str->u.str16[s->len++] = c;\n    } else if (c < 0x100) {\n        s->str->u.str8[s->len++] = c;\n    } else {\n        if (string_buffer_widen(s, s->size))\n            return -1;\n        s->str->u.str16[s->len++] = c;\n    }\n    return 0;\n}\n\n/* 0 <= c <= 0xff */\nstatic int string_buffer_putc8(StringBuffer *s, uint32_t c)\n{\n    if (unlikely(s->len >= s->size)) {\n        if (string_buffer_realloc(s, s->len + 1, c))\n            return -1;\n    }\n    if (s->is_wide_char) {\n        s->str->u.str16[s->len++] = c;\n    } else {\n        s->str->u.str8[s->len++] = c;\n    }\n    return 0;\n}\n\n/* 0 <= c <= 0xffff */\nstatic int string_buffer_putc16(StringBuffer *s, uint32_t c)\n{\n    if (likely(s->len < s->size)) {\n        if (s->is_wide_char) {\n            s->str->u.str16[s->len++] = c;\n            return 0;\n        } else if (c < 0x100) {\n            s->str->u.str8[s->len++] = c;\n            return 0;\n        }\n    }\n    return string_buffer_putc_slow(s, c);\n}\n\n/* 0 <= c <= 0x10ffff */\nstatic int string_buffer_putc(StringBuffer *s, uint32_t c)\n{\n    if (unlikely(c >= 0x10000)) {\n        /* surrogate pair */\n        c -= 0x10000;\n        if (string_buffer_putc16(s, (c >> 10) + 0xd800))\n            return -1;\n        c = (c & 0x3ff) + 0xdc00;\n    }\n    return string_buffer_putc16(s, c);\n}\n\nstatic int string_get(const JSString *p, int idx) {\n    return p->is_wide_char ? p->u.str16[idx] : p->u.str8[idx];\n}\n\nstatic int string_getc(const JSString *p, int *pidx)\n{\n    int idx, c, c1;\n    idx = *pidx;\n    if (p->is_wide_char) {\n        c = p->u.str16[idx++];\n        if (c >= 0xd800 && c < 0xdc00 && idx < p->len) {\n            c1 = p->u.str16[idx];\n            if (c1 >= 0xdc00 && c1 < 0xe000) {\n                c = (((c & 0x3ff) << 10) | (c1 & 0x3ff)) + 0x10000;\n                idx++;\n            }\n        }\n    } else {\n        c = p->u.str8[idx++];\n    }\n    *pidx = idx;\n    return c;\n}\n\nstatic int string_buffer_write8(StringBuffer *s, const uint8_t *p, int len)\n{\n    int i;\n\n    if (s->len + len > s->size) {\n        if (string_buffer_realloc(s, s->len + len, 0))\n            return -1;\n    }\n    if (s->is_wide_char) {\n        for (i = 0; i < len; i++) {\n            s->str->u.str16[s->len + i] = p[i];\n        }\n        s->len += len;\n    } else {\n        memcpy(&s->str->u.str8[s->len], p, len);\n        s->len += len;\n    }\n    return 0;\n}\n\nstatic int string_buffer_write16(StringBuffer *s, const uint16_t *p, int len)\n{\n    int c = 0, i;\n\n    for (i = 0; i < len; i++) {\n        c |= p[i];\n    }\n    if (s->len + len > s->size) {\n        if (string_buffer_realloc(s, s->len + len, c))\n            return -1;\n    } else if (!s->is_wide_char && c >= 0x100) {\n        if (string_buffer_widen(s, s->size))\n            return -1;\n    }\n    if (s->is_wide_char) {\n        memcpy(&s->str->u.str16[s->len], p, len << 1);\n        s->len += len;\n    } else {\n        for (i = 0; i < len; i++) {\n            s->str->u.str8[s->len + i] = p[i];\n        }\n        s->len += len;\n    }\n    return 0;\n}\n\n/* appending an ASCII string */\nstatic int string_buffer_puts8(StringBuffer *s, const char *str)\n{\n    return string_buffer_write8(s, (const uint8_t *)str, strlen(str));\n}\n\nstatic int string_buffer_concat(StringBuffer *s, const JSString *p,\n                                uint32_t from, uint32_t to)\n{\n    if (to <= from)\n        return 0;\n    if (p->is_wide_char)\n        return string_buffer_write16(s, p->u.str16 + from, to - from);\n    else\n        return string_buffer_write8(s, p->u.str8 + from, to - from);\n}\n\nstatic int string_buffer_concat_value(StringBuffer *s, JSValueConst v)\n{\n    JSString *p;\n    JSValue v1;\n    int res;\n\n    if (s->error_status) {\n        /* prevent exception overload */\n        return -1;\n    }\n    if (unlikely(JS_VALUE_GET_TAG(v) != JS_TAG_STRING)) {\n        v1 = JS_ToString(s->ctx, v);\n        if (JS_IsException(v1))\n            return string_buffer_set_error(s);\n        p = JS_VALUE_GET_STRING(v1);\n        res = string_buffer_concat(s, p, 0, p->len);\n        JS_FreeValue(s->ctx, v1);\n        return res;\n    }\n    p = JS_VALUE_GET_STRING(v);\n    return string_buffer_concat(s, p, 0, p->len);\n}\n\nstatic int string_buffer_concat_value_free(StringBuffer *s, JSValue v)\n{\n    JSString *p;\n    int res;\n\n    if (s->error_status) {\n        /* prevent exception overload */\n        JS_FreeValue(s->ctx, v);\n        return -1;\n    }\n    if (unlikely(JS_VALUE_GET_TAG(v) != JS_TAG_STRING)) {\n        v = JS_ToStringFree(s->ctx, v);\n        if (JS_IsException(v))\n            return string_buffer_set_error(s);\n    }\n    p = JS_VALUE_GET_STRING(v);\n    res = string_buffer_concat(s, p, 0, p->len);\n    JS_FreeValue(s->ctx, v);\n    return res;\n}\n\nstatic int string_buffer_fill(StringBuffer *s, int c, int count)\n{\n    /* XXX: optimize */\n    if (s->len + count > s->size) {\n        if (string_buffer_realloc(s, s->len + count, c))\n            return -1;\n    }\n    while (count-- > 0) {\n        if (string_buffer_putc16(s, c))\n            return -1;\n    }\n    return 0;\n}\n\nstatic JSValue string_buffer_end(StringBuffer *s)\n{\n    JSString *str;\n    str = s->str;\n    if (s->error_status)\n        return JS_EXCEPTION;\n    if (s->len == 0) {\n        js_free(s->ctx, str);\n        s->str = NULL;\n        return JS_AtomToString(s->ctx, JS_ATOM_empty_string);\n    }\n    if (s->len < s->size) {\n        /* smaller size so js_realloc should not fail, but OK if it does */\n        /* XXX: should add some slack to avoid unnecessary calls */\n        /* XXX: might need to use malloc+free to ensure smaller size */\n        str = js_realloc_rt(s->ctx->rt, str, sizeof(JSString) +\n                            (s->len << s->is_wide_char) + 1 - s->is_wide_char);\n        if (str == NULL)\n            str = s->str;\n        s->str = str;\n    }\n    if (!s->is_wide_char)\n        str->u.str8[s->len] = 0;\n#ifdef DUMP_LEAKS\n    list_add_tail(&str->link, &s->ctx->rt->string_list);\n#endif\n    str->is_wide_char = s->is_wide_char;\n    str->len = s->len;\n    s->str = NULL;\n    return JS_MKPTR(JS_TAG_STRING, str);\n}\n\n/* create a string from a UTF-8 buffer */\nJSValue JS_NewStringLen(JSContext *ctx, const char *buf, size_t buf_len)\n{\n    const uint8_t *p, *p_end, *p_start, *p_next;\n    uint32_t c;\n    StringBuffer b_s, *b = &b_s;\n    size_t len1;\n    \n    p_start = (const uint8_t *)buf;\n    p_end = p_start + buf_len;\n    p = p_start;\n    while (p < p_end && *p < 128)\n        p++;\n    len1 = p - p_start;\n    if (len1 > JS_STRING_LEN_MAX)\n        return JS_ThrowInternalError(ctx, \"string too long\");\n    if (p == p_end) {\n        /* ASCII string */\n        return js_new_string8(ctx, (const uint8_t *)buf, buf_len);\n    } else {\n        if (string_buffer_init(ctx, b, buf_len))\n            goto fail;\n        string_buffer_write8(b, p_start, len1);\n        while (p < p_end) {\n            if (*p < 128) {\n                string_buffer_putc8(b, *p++);\n            } else {\n                /* parse utf-8 sequence, return 0xFFFFFFFF for error */\n                c = unicode_from_utf8(p, p_end - p, &p_next);\n                if (c < 0x10000) {\n                    p = p_next;\n                } else if (c <= 0x10FFFF) {\n                    p = p_next;\n                    /* surrogate pair */\n                    c -= 0x10000;\n                    string_buffer_putc16(b, (c >> 10) + 0xd800);\n                    c = (c & 0x3ff) + 0xdc00;\n                } else {\n                    /* invalid char */\n                    c = 0xfffd;\n                    /* skip the invalid chars */\n                    /* XXX: seems incorrect. Why not just use c = *p++; ? */\n                    while (p < p_end && (*p >= 0x80 && *p < 0xc0))\n                        p++;\n                    if (p < p_end) {\n                        p++;\n                        while (p < p_end && (*p >= 0x80 && *p < 0xc0))\n                            p++;\n                    }\n                }\n                string_buffer_putc16(b, c);\n            }\n        }\n    }\n    return string_buffer_end(b);\n\n fail:\n    string_buffer_free(b);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ConcatString3(JSContext *ctx, const char *str1,\n                                JSValue str2, const char *str3)\n{\n    StringBuffer b_s, *b = &b_s;\n    int len1, len3;\n    JSString *p;\n\n    if (unlikely(JS_VALUE_GET_TAG(str2) != JS_TAG_STRING)) {\n        str2 = JS_ToStringFree(ctx, str2);\n        if (JS_IsException(str2))\n            goto fail;\n    }\n    p = JS_VALUE_GET_STRING(str2);\n    len1 = strlen(str1);\n    len3 = strlen(str3);\n\n    if (string_buffer_init2(ctx, b, len1 + p->len + len3, p->is_wide_char))\n        goto fail;\n\n    string_buffer_write8(b, (const uint8_t *)str1, len1);\n    string_buffer_concat(b, p, 0, p->len);\n    string_buffer_write8(b, (const uint8_t *)str3, len3);\n\n    JS_FreeValue(ctx, str2);\n    return string_buffer_end(b);\n\n fail:\n    JS_FreeValue(ctx, str2);\n    return JS_EXCEPTION;\n}\n\nJSValue JS_NewString(JSContext *ctx, const char *str)\n{\n    return JS_NewStringLen(ctx, str, strlen(str));\n}\n\nJSValue JS_NewAtomString(JSContext *ctx, const char *str)\n{\n    JSAtom atom = JS_NewAtom(ctx, str);\n    if (atom == JS_ATOM_NULL)\n        return JS_EXCEPTION;\n    JSValue val = JS_AtomToString(ctx, atom);\n    JS_FreeAtom(ctx, atom);\n    return val;\n}\n\n/* return (NULL, 0) if exception. */\n/* return pointer into a JSString with a live ref_count */\n/* cesu8 determines if non-BMP1 codepoints are encoded as 1 or 2 utf-8 sequences */\nconst char *JS_ToCStringLen2(JSContext *ctx, size_t *plen, JSValueConst val1, BOOL cesu8)\n{\n    JSValue val;\n    JSString *str, *str_new;\n    int pos, len, c, c1;\n    uint8_t *q;\n\n    if (JS_VALUE_GET_TAG(val1) != JS_TAG_STRING) {\n        val = JS_ToString(ctx, val1);\n        if (JS_IsException(val))\n            goto fail;\n    } else {\n        val = JS_DupValue(ctx, val1);\n    }\n\n    str = JS_VALUE_GET_STRING(val);\n    len = str->len;\n    if (!str->is_wide_char) {\n        const uint8_t *src = str->u.str8;\n        int count;\n\n        /* count the number of non-ASCII characters */\n        /* Scanning the whole string is required for ASCII strings,\n           and computing the number of non-ASCII bytes is less expensive\n           than testing each byte, hence this method is faster for ASCII\n           strings, which is the most common case.\n         */\n        count = 0;\n        for (pos = 0; pos < len; pos++) {\n            count += src[pos] >> 7;\n        }\n        if (count == 0) {\n            if (plen)\n                *plen = len;\n            return (const char *)src;\n        }\n        str_new = js_alloc_string(ctx, len + count, 0);\n        if (!str_new)\n            goto fail;\n        q = str_new->u.str8;\n        for (pos = 0; pos < len; pos++) {\n            c = src[pos];\n            if (c < 0x80) {\n                *q++ = c;\n            } else {\n                *q++ = (c >> 6) | 0xc0;\n                *q++ = (c & 0x3f) | 0x80;\n            }\n        }\n    } else {\n        const uint16_t *src = str->u.str16;\n        /* Allocate 3 bytes per 16 bit code point. Surrogate pairs may\n           produce 4 bytes but use 2 code points.\n         */\n        str_new = js_alloc_string(ctx, len * 3, 0);\n        if (!str_new)\n            goto fail;\n        q = str_new->u.str8;\n        pos = 0;\n        while (pos < len) {\n            c = src[pos++];\n            if (c < 0x80) {\n                *q++ = c;\n            } else {\n                if (c >= 0xd800 && c < 0xdc00) {\n                    if (pos < len && !cesu8) {\n                        c1 = src[pos];\n                        if (c1 >= 0xdc00 && c1 < 0xe000) {\n                            pos++;\n                            /* surrogate pair */\n                            c = (((c & 0x3ff) << 10) | (c1 & 0x3ff)) + 0x10000;\n                        } else {\n                            /* Keep unmatched surrogate code points */\n                            /* c = 0xfffd; */ /* error */\n                        }\n                    } else {\n                        /* Keep unmatched surrogate code points */\n                        /* c = 0xfffd; */ /* error */\n                    }\n                }\n                q += unicode_to_utf8(q, c);\n            }\n        }\n    }\n\n    *q = '\\0';\n    str_new->len = q - str_new->u.str8;\n    JS_FreeValue(ctx, val);\n    if (plen)\n        *plen = str_new->len;\n    return (const char *)str_new->u.str8;\n fail:\n    if (plen)\n        *plen = 0;\n    return NULL;\n}\n\nvoid JS_FreeCString(JSContext *ctx, const char *ptr)\n{\n    JSString *p;\n    if (!ptr)\n        return;\n    /* purposely removing constness */\n    p = (JSString *)(void *)(ptr - offsetof(JSString, u));\n    JS_FreeValue(ctx, JS_MKPTR(JS_TAG_STRING, p));\n}\n\nstatic int memcmp16_8(const uint16_t *src1, const uint8_t *src2, int len)\n{\n    int c, i;\n    for(i = 0; i < len; i++) {\n        c = src1[i] - src2[i];\n        if (c != 0)\n            return c;\n    }\n    return 0;\n}\n\nstatic int memcmp16(const uint16_t *src1, const uint16_t *src2, int len)\n{\n    int c, i;\n    for(i = 0; i < len; i++) {\n        c = src1[i] - src2[i];\n        if (c != 0)\n            return c;\n    }\n    return 0;\n}\n\nstatic int js_string_memcmp(const JSString *p1, const JSString *p2, int len)\n{\n    int res;\n\n    if (likely(!p1->is_wide_char)) {\n        if (likely(!p2->is_wide_char))\n            res = memcmp(p1->u.str8, p2->u.str8, len);\n        else\n            res = -memcmp16_8(p2->u.str16, p1->u.str8, len);\n    } else {\n        if (!p2->is_wide_char)\n            res = memcmp16_8(p1->u.str16, p2->u.str8, len);\n        else\n            res = memcmp16(p1->u.str16, p2->u.str16, len);\n    }\n    return res;\n}\n\n/* return < 0, 0 or > 0 */\nstatic int js_string_compare(JSContext *ctx,\n                             const JSString *p1, const JSString *p2)\n{\n    int res, len;\n    len = min_int(p1->len, p2->len);\n    res = js_string_memcmp(p1, p2, len);\n    if (res == 0) {\n        if (p1->len == p2->len)\n            res = 0;\n        else if (p1->len < p2->len)\n            res = -1;\n        else\n            res = 1;\n    }\n    return res;\n}\n\nstatic void copy_str16(uint16_t *dst, const JSString *p, int offset, int len)\n{\n    if (p->is_wide_char) {\n        memcpy(dst, p->u.str16 + offset, len * 2);\n    } else {\n        const uint8_t *src1 = p->u.str8 + offset;\n        int i;\n\n        for(i = 0; i < len; i++)\n            dst[i] = src1[i];\n    }\n}\n\nstatic JSValue JS_ConcatString1(JSContext *ctx,\n                                const JSString *p1, const JSString *p2)\n{\n    JSString *p;\n    uint32_t len;\n    int is_wide_char;\n\n    len = p1->len + p2->len;\n    if (len > JS_STRING_LEN_MAX)\n        return JS_ThrowInternalError(ctx, \"string too long\");\n    is_wide_char = p1->is_wide_char | p2->is_wide_char;\n    p = js_alloc_string(ctx, len, is_wide_char);\n    if (!p)\n        return JS_EXCEPTION;\n    if (!is_wide_char) {\n        memcpy(p->u.str8, p1->u.str8, p1->len);\n        memcpy(p->u.str8 + p1->len, p2->u.str8, p2->len);\n        p->u.str8[len] = '\\0';\n    } else {\n        copy_str16(p->u.str16, p1, 0, p1->len);\n        copy_str16(p->u.str16 + p1->len, p2, 0, p2->len);\n    }\n    return JS_MKPTR(JS_TAG_STRING, p);\n}\n\n/* op1 and op2 are converted to strings. For convience, op1 or op2 =\n   JS_EXCEPTION are accepted and return JS_EXCEPTION.  */\nstatic JSValue JS_ConcatString(JSContext *ctx, JSValue op1, JSValue op2)\n{\n    JSValue ret;\n    JSString *p1, *p2;\n\n    if (unlikely(JS_VALUE_GET_TAG(op1) != JS_TAG_STRING)) {\n        op1 = JS_ToStringFree(ctx, op1);\n        if (JS_IsException(op1)) {\n            JS_FreeValue(ctx, op2);\n            return JS_EXCEPTION;\n        }\n    }\n    if (unlikely(JS_VALUE_GET_TAG(op2) != JS_TAG_STRING)) {\n        op2 = JS_ToStringFree(ctx, op2);\n        if (JS_IsException(op2)) {\n            JS_FreeValue(ctx, op1);\n            return JS_EXCEPTION;\n        }\n    }\n    p1 = JS_VALUE_GET_STRING(op1);\n    p2 = JS_VALUE_GET_STRING(op2);\n\n    /* XXX: could also check if p1 is empty */\n    if (p2->len == 0) {\n        goto ret_op1;\n    }\n    if (p1->header.ref_count == 1 && p1->is_wide_char == p2->is_wide_char\n    &&  js_malloc_usable_size(ctx, p1) >= sizeof(*p1) + ((p1->len + p2->len) << p2->is_wide_char) + 1 - p1->is_wide_char) {\n        /* Concatenate in place in available space at the end of p1 */\n        if (p1->is_wide_char) {\n            memcpy(p1->u.str16 + p1->len, p2->u.str16, p2->len << 1);\n            p1->len += p2->len;\n        } else {\n            memcpy(p1->u.str8 + p1->len, p2->u.str8, p2->len);\n            p1->len += p2->len;\n            p1->u.str8[p1->len] = '\\0';\n        }\n    ret_op1:\n        JS_FreeValue(ctx, op2);\n        return op1;\n    }\n    ret = JS_ConcatString1(ctx, p1, p2);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    return ret;\n}\n\n/* Shape support */\n\nstatic inline size_t get_shape_size(size_t hash_size, size_t prop_size)\n{\n    return hash_size * sizeof(uint32_t) + sizeof(JSShape) +\n        prop_size * sizeof(JSShapeProperty);\n}\n\nstatic inline JSShape *get_shape_from_alloc(void *sh_alloc, size_t hash_size)\n{\n    return (JSShape *)(void *)((uint32_t *)sh_alloc + hash_size);\n}\n\nstatic inline uint32_t *prop_hash_end(JSShape *sh)\n{\n    return (uint32_t *)sh;\n}\n\nstatic inline void *get_alloc_from_shape(JSShape *sh)\n{\n    return prop_hash_end(sh) - ((intptr_t)sh->prop_hash_mask + 1);\n}\n\nstatic inline JSShapeProperty *get_shape_prop(JSShape *sh)\n{\n    return sh->prop;\n}\n\nstatic int init_shape_hash(JSRuntime *rt)\n{\n    rt->shape_hash_bits = 4;   /* 16 shapes */\n    rt->shape_hash_size = 1 << rt->shape_hash_bits;\n    rt->shape_hash_count = 0;\n    rt->shape_hash = js_mallocz_rt(rt, sizeof(rt->shape_hash[0]) *\n                                   rt->shape_hash_size);\n    if (!rt->shape_hash)\n        return -1;\n    return 0;\n}\n\n/* same magic hash multiplier as the Linux kernel */\nstatic uint32_t shape_hash(uint32_t h, uint32_t val)\n{\n    return (h + val) * 0x9e370001;\n}\n\n/* truncate the shape hash to 'hash_bits' bits */\nstatic uint32_t get_shape_hash(uint32_t h, int hash_bits)\n{\n    return h >> (32 - hash_bits);\n}\n\nstatic uint32_t shape_initial_hash(JSObject *proto)\n{\n    uint32_t h;\n    h = shape_hash(1, (uintptr_t)proto);\n    if (sizeof(proto) > 4)\n        h = shape_hash(h, (uint64_t)(uintptr_t)proto >> 32);\n    return h;\n}\n\nstatic int resize_shape_hash(JSRuntime *rt, int new_shape_hash_bits)\n{\n    int new_shape_hash_size, i;\n    uint32_t h;\n    JSShape **new_shape_hash, *sh, *sh_next;\n\n    new_shape_hash_size = 1 << new_shape_hash_bits;\n    new_shape_hash = js_mallocz_rt(rt, sizeof(rt->shape_hash[0]) *\n                                   new_shape_hash_size);\n    if (!new_shape_hash)\n        return -1;\n    for(i = 0; i < rt->shape_hash_size; i++) {\n        for(sh = rt->shape_hash[i]; sh != NULL; sh = sh_next) {\n            sh_next = sh->shape_hash_next;\n            h = get_shape_hash(sh->hash, new_shape_hash_bits);\n            sh->shape_hash_next = new_shape_hash[h];\n            new_shape_hash[h] = sh;\n        }\n    }\n    js_free_rt(rt, rt->shape_hash);\n    rt->shape_hash_bits = new_shape_hash_bits;\n    rt->shape_hash_size = new_shape_hash_size;\n    rt->shape_hash = new_shape_hash;\n    return 0;\n}\n\nstatic void js_shape_hash_link(JSRuntime *rt, JSShape *sh)\n{\n    uint32_t h;\n    h = get_shape_hash(sh->hash, rt->shape_hash_bits);\n    sh->shape_hash_next = rt->shape_hash[h];\n    rt->shape_hash[h] = sh;\n    rt->shape_hash_count++;\n}\n\nstatic void js_shape_hash_unlink(JSRuntime *rt, JSShape *sh)\n{\n    uint32_t h;\n    JSShape **psh;\n\n    h = get_shape_hash(sh->hash, rt->shape_hash_bits);\n    psh = &rt->shape_hash[h];\n    while (*psh != sh)\n        psh = &(*psh)->shape_hash_next;\n    *psh = sh->shape_hash_next;\n    rt->shape_hash_count--;\n}\n\n/* create a new empty shape with prototype 'proto' */\nstatic no_inline JSShape *js_new_shape2(JSContext *ctx, JSObject *proto,\n                                        int hash_size, int prop_size)\n{\n    JSRuntime *rt = ctx->rt;\n    void *sh_alloc;\n    JSShape *sh;\n\n    /* resize the shape hash table if necessary */\n    if (2 * (rt->shape_hash_count + 1) > rt->shape_hash_size) {\n        resize_shape_hash(rt, rt->shape_hash_bits + 1);\n    }\n\n    sh_alloc = js_malloc(ctx, get_shape_size(hash_size, prop_size));\n    if (!sh_alloc)\n        return NULL;\n    sh = get_shape_from_alloc(sh_alloc, hash_size);\n    sh->header.ref_count = 1;\n    add_gc_object(rt, &sh->header, JS_GC_OBJ_TYPE_SHAPE);\n    if (proto)\n        JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, proto));\n    sh->proto = proto;\n    memset(prop_hash_end(sh) - hash_size, 0, sizeof(prop_hash_end(sh)[0]) *\n           hash_size);\n    sh->prop_hash_mask = hash_size - 1;\n    sh->prop_size = prop_size;\n    sh->prop_count = 0;\n    sh->deleted_prop_count = 0;\n    \n    /* insert in the hash table */\n    sh->hash = shape_initial_hash(proto);\n    sh->is_hashed = TRUE;\n    sh->has_small_array_index = FALSE;\n    js_shape_hash_link(ctx->rt, sh);\n    return sh;\n}\n\nstatic JSShape *js_new_shape(JSContext *ctx, JSObject *proto)\n{\n    return js_new_shape2(ctx, proto, JS_PROP_INITIAL_HASH_SIZE,\n                         JS_PROP_INITIAL_SIZE);\n}\n\n/* The shape is cloned. The new shape is not inserted in the shape\n   hash table */\nstatic JSShape *js_clone_shape(JSContext *ctx, JSShape *sh1)\n{\n    JSShape *sh;\n    void *sh_alloc, *sh_alloc1;\n    size_t size;\n    JSShapeProperty *pr;\n    uint32_t i, hash_size;\n\n    hash_size = sh1->prop_hash_mask + 1;\n    size = get_shape_size(hash_size, sh1->prop_size);\n    sh_alloc = js_malloc(ctx, size);\n    if (!sh_alloc)\n        return NULL;\n    sh_alloc1 = get_alloc_from_shape(sh1);\n    memcpy(sh_alloc, sh_alloc1, size);\n    sh = get_shape_from_alloc(sh_alloc, hash_size);\n    sh->header.ref_count = 1;\n    add_gc_object(ctx->rt, &sh->header, JS_GC_OBJ_TYPE_SHAPE);\n    sh->is_hashed = FALSE;\n    if (sh->proto) {\n        JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, sh->proto));\n    }\n    for(i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {\n        JS_DupAtom(ctx, pr->atom);\n    }\n    return sh;\n}\n\nstatic JSShape *js_dup_shape(JSShape *sh)\n{\n    sh->header.ref_count++;\n    return sh;\n}\n\nstatic void js_free_shape0(JSRuntime *rt, JSShape *sh)\n{\n    uint32_t i;\n    JSShapeProperty *pr;\n\n    assert(sh->header.ref_count == 0);\n    if (sh->is_hashed)\n        js_shape_hash_unlink(rt, sh);\n    if (sh->proto != NULL) {\n        JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, sh->proto));\n    }\n    pr = get_shape_prop(sh);\n    for(i = 0; i < sh->prop_count; i++) {\n        JS_FreeAtomRT(rt, pr->atom);\n        pr++;\n    }\n    remove_gc_object(&sh->header);\n    js_free_rt(rt, get_alloc_from_shape(sh));\n}\n\nstatic void js_free_shape(JSRuntime *rt, JSShape *sh)\n{\n    if (unlikely(--sh->header.ref_count <= 0)) {\n        js_free_shape0(rt, sh);\n    }\n}\n\nstatic void js_free_shape_null(JSRuntime *rt, JSShape *sh)\n{\n    if (sh)\n        js_free_shape(rt, sh);\n}\n\n/* make space to hold at least 'count' properties */\nstatic no_inline int resize_properties(JSContext *ctx, JSShape **psh,\n                                       JSObject *p, uint32_t count)\n{\n    JSShape *sh;\n    uint32_t new_size, new_hash_size, new_hash_mask, i;\n    JSShapeProperty *pr;\n    void *sh_alloc;\n    intptr_t h;\n\n    sh = *psh;\n    new_size = max_int(count, sh->prop_size * 3 / 2);\n    /* Reallocate prop array first to avoid crash or size inconsistency\n       in case of memory allocation failure */\n    if (p) {\n        JSProperty *new_prop;\n        new_prop = js_realloc(ctx, p->prop, sizeof(new_prop[0]) * new_size);\n        if (unlikely(!new_prop))\n            return -1;\n        p->prop = new_prop;\n    }\n    new_hash_size = sh->prop_hash_mask + 1;\n    while (new_hash_size < new_size)\n        new_hash_size = 2 * new_hash_size;\n    if (new_hash_size != (sh->prop_hash_mask + 1)) {\n        JSShape *old_sh;\n        /* resize the hash table and the properties */\n        old_sh = sh;\n        sh_alloc = js_malloc(ctx, get_shape_size(new_hash_size, new_size));\n        if (!sh_alloc)\n            return -1;\n        sh = get_shape_from_alloc(sh_alloc, new_hash_size);\n        list_del(&old_sh->header.link);\n        /* copy all the fields and the properties */\n        memcpy(sh, old_sh,\n               sizeof(JSShape) + sizeof(sh->prop[0]) * old_sh->prop_count);\n        list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);\n        new_hash_mask = new_hash_size - 1;\n        sh->prop_hash_mask = new_hash_mask;\n        memset(prop_hash_end(sh) - new_hash_size, 0,\n               sizeof(prop_hash_end(sh)[0]) * new_hash_size);\n        for(i = 0, pr = sh->prop; i < sh->prop_count; i++, pr++) {\n            if (pr->atom != JS_ATOM_NULL) {\n                h = ((uintptr_t)pr->atom & new_hash_mask);\n                pr->hash_next = prop_hash_end(sh)[-h - 1];\n                prop_hash_end(sh)[-h - 1] = i + 1;\n            }\n        }\n        js_free(ctx, get_alloc_from_shape(old_sh));\n    } else {\n        /* only resize the properties */\n        list_del(&sh->header.link);\n        sh_alloc = js_realloc(ctx, get_alloc_from_shape(sh),\n                              get_shape_size(new_hash_size, new_size));\n        if (unlikely(!sh_alloc)) {\n            /* insert again in the GC list */\n            list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);\n            return -1;\n        }\n        sh = get_shape_from_alloc(sh_alloc, new_hash_size);\n        list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);\n    }\n    *psh = sh;\n    sh->prop_size = new_size;\n    return 0;\n}\n\n/* remove the deleted properties. */\nstatic int compact_properties(JSContext *ctx, JSObject *p)\n{\n    JSShape *sh, *old_sh;\n    void *sh_alloc;\n    intptr_t h;\n    uint32_t new_hash_size, i, j, new_hash_mask, new_size;\n    JSShapeProperty *old_pr, *pr;\n    JSProperty *prop, *new_prop;\n    \n    sh = p->shape;\n    assert(!sh->is_hashed);\n\n    new_size = max_int(JS_PROP_INITIAL_SIZE,\n                       sh->prop_count - sh->deleted_prop_count);\n    assert(new_size <= sh->prop_size);\n\n    new_hash_size = sh->prop_hash_mask + 1;\n    while ((new_hash_size / 2) >= new_size)\n        new_hash_size = new_hash_size / 2;\n    new_hash_mask = new_hash_size - 1;\n\n    /* resize the hash table and the properties */\n    old_sh = sh;\n    sh_alloc = js_malloc(ctx, get_shape_size(new_hash_size, new_size));\n    if (!sh_alloc)\n        return -1;\n    sh = get_shape_from_alloc(sh_alloc, new_hash_size);\n    list_del(&old_sh->header.link);\n    memcpy(sh, old_sh, sizeof(JSShape));\n    list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);\n    \n    memset(prop_hash_end(sh) - new_hash_size, 0,\n           sizeof(prop_hash_end(sh)[0]) * new_hash_size);\n\n    j = 0;\n    old_pr = old_sh->prop;\n    pr = sh->prop;\n    prop = p->prop;\n    for(i = 0; i < sh->prop_count; i++) {\n        if (old_pr->atom != JS_ATOM_NULL) {\n            pr->atom = old_pr->atom;\n            pr->flags = old_pr->flags;\n            h = ((uintptr_t)old_pr->atom & new_hash_mask);\n            pr->hash_next = prop_hash_end(sh)[-h - 1];\n            prop_hash_end(sh)[-h - 1] = j + 1;\n            prop[j] = prop[i];\n            j++;\n            pr++;\n        }\n        old_pr++;\n    }\n    assert(j == (sh->prop_count - sh->deleted_prop_count));\n    sh->prop_hash_mask = new_hash_mask;\n    sh->prop_size = new_size;\n    sh->deleted_prop_count = 0;\n    sh->prop_count = j;\n\n    p->shape = sh;\n    js_free(ctx, get_alloc_from_shape(old_sh));\n    \n    /* reduce the size of the object properties */\n    new_prop = js_realloc(ctx, p->prop, sizeof(new_prop[0]) * new_size);\n    if (new_prop)\n        p->prop = new_prop;\n    return 0;\n}\n\nstatic int add_shape_property(JSContext *ctx, JSShape **psh,\n                              JSObject *p, JSAtom atom, int prop_flags)\n{\n    JSRuntime *rt = ctx->rt;\n    JSShape *sh = *psh;\n    JSShapeProperty *pr, *prop;\n    uint32_t hash_mask, new_shape_hash = 0;\n    intptr_t h;\n\n    /* update the shape hash */\n    if (sh->is_hashed) {\n        js_shape_hash_unlink(rt, sh);\n        new_shape_hash = shape_hash(shape_hash(sh->hash, atom), prop_flags);\n    }\n\n    if (unlikely(sh->prop_count >= sh->prop_size)) {\n        if (resize_properties(ctx, psh, p, sh->prop_count + 1)) {\n            /* in case of error, reinsert in the hash table.\n               sh is still valid if resize_properties() failed */\n            if (sh->is_hashed)\n                js_shape_hash_link(rt, sh);\n            return -1;\n        }\n        sh = *psh;\n    }\n    if (sh->is_hashed) {\n        sh->hash = new_shape_hash;\n        js_shape_hash_link(rt, sh);\n    }\n    /* Initialize the new shape property.\n       The object property at p->prop[sh->prop_count] is uninitialized */\n    prop = get_shape_prop(sh);\n    pr = &prop[sh->prop_count++];\n    pr->atom = JS_DupAtom(ctx, atom);\n    pr->flags = prop_flags;\n    sh->has_small_array_index |= __JS_AtomIsTaggedInt(atom);\n    /* add in hash table */\n    hash_mask = sh->prop_hash_mask;\n    h = atom & hash_mask;\n    pr->hash_next = prop_hash_end(sh)[-h - 1];\n    prop_hash_end(sh)[-h - 1] = sh->prop_count;\n    return 0;\n}\n\n/* find a hashed empty shape matching the prototype. Return NULL if\n   not found */\nstatic JSShape *find_hashed_shape_proto(JSRuntime *rt, JSObject *proto)\n{\n    JSShape *sh1;\n    uint32_t h, h1;\n\n    h = shape_initial_hash(proto);\n    h1 = get_shape_hash(h, rt->shape_hash_bits);\n    for(sh1 = rt->shape_hash[h1]; sh1 != NULL; sh1 = sh1->shape_hash_next) {\n        if (sh1->hash == h &&\n            sh1->proto == proto &&\n            sh1->prop_count == 0) {\n            return sh1;\n        }\n    }\n    return NULL;\n}\n\n/* find a hashed shape matching sh + (prop, prop_flags). Return NULL if\n   not found */\nstatic JSShape *find_hashed_shape_prop(JSRuntime *rt, JSShape *sh,\n                                       JSAtom atom, int prop_flags)\n{\n    JSShape *sh1;\n    uint32_t h, h1, i, n;\n\n    h = sh->hash;\n    h = shape_hash(h, atom);\n    h = shape_hash(h, prop_flags);\n    h1 = get_shape_hash(h, rt->shape_hash_bits);\n    for(sh1 = rt->shape_hash[h1]; sh1 != NULL; sh1 = sh1->shape_hash_next) {\n        /* we test the hash first so that the rest is done only if the\n           shapes really match */\n        if (sh1->hash == h &&\n            sh1->proto == sh->proto &&\n            sh1->prop_count == ((n = sh->prop_count) + 1)) {\n            for(i = 0; i < n; i++) {\n                if (unlikely(sh1->prop[i].atom != sh->prop[i].atom) ||\n                    unlikely(sh1->prop[i].flags != sh->prop[i].flags))\n                    goto next;\n            }\n            if (unlikely(sh1->prop[n].atom != atom) ||\n                unlikely(sh1->prop[n].flags != prop_flags))\n                goto next;\n            return sh1;\n        }\n    next: ;\n    }\n    return NULL;\n}\n\nstatic __maybe_unused void JS_DumpShape(JSRuntime *rt, int i, JSShape *sh)\n{\n    char atom_buf[ATOM_GET_STR_BUF_SIZE];\n    int j;\n\n    /* XXX: should output readable class prototype */\n    printf(\"%5d %3d%c %14p %5d %5d\", i,\n           sh->header.ref_count, \" *\"[sh->is_hashed],\n           (void *)sh->proto, sh->prop_size, sh->prop_count);\n    for(j = 0; j < sh->prop_count; j++) {\n        printf(\" %s\", JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf),\n                                      sh->prop[j].atom));\n    }\n    printf(\"\\n\");\n}\n\nstatic __maybe_unused void JS_DumpShapes(JSRuntime *rt)\n{\n    int i;\n    JSShape *sh;\n    struct list_head *el;\n    JSObject *p;\n    JSGCObjectHeader *gp;\n    \n    printf(\"JSShapes: {\\n\");\n    printf(\"%5s %4s %14s %5s %5s %s\\n\", \"SLOT\", \"REFS\", \"PROTO\", \"SIZE\", \"COUNT\", \"PROPS\");\n    for(i = 0; i < rt->shape_hash_size; i++) {\n        for(sh = rt->shape_hash[i]; sh != NULL; sh = sh->shape_hash_next) {\n            JS_DumpShape(rt, i, sh);\n            assert(sh->is_hashed);\n        }\n    }\n    /* dump non-hashed shapes */\n    list_for_each(el, &rt->gc_obj_list) {\n        gp = list_entry(el, JSGCObjectHeader, link);\n        if (gp->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT) {\n            p = (JSObject *)gp;\n            if (!p->shape->is_hashed) {\n                JS_DumpShape(rt, -1, p->shape);\n            }\n        }\n    }\n    printf(\"}\\n\");\n}\n\nstatic JSValue JS_NewObjectFromShape(JSContext *ctx, JSShape *sh, JSClassID class_id)\n{\n    JSObject *p;\n\n    js_trigger_gc(ctx->rt, sizeof(JSObject));\n    p = js_malloc(ctx, sizeof(JSObject));\n    if (unlikely(!p))\n        goto fail;\n    p->class_id = class_id;\n    p->extensible = TRUE;\n    p->free_mark = 0;\n    p->is_exotic = 0;\n    p->fast_array = 0;\n    p->is_constructor = 0;\n    p->is_uncatchable_error = 0;\n    p->tmp_mark = 0;\n    p->is_HTMLDDA = 0;\n    p->first_weak_ref = NULL;\n    p->u.opaque = NULL;\n    p->shape = sh;\n    p->prop = js_malloc(ctx, sizeof(JSProperty) * sh->prop_size);\n    if (unlikely(!p->prop)) {\n        js_free(ctx, p);\n    fail:\n        js_free_shape(ctx->rt, sh);\n        return JS_EXCEPTION;\n    }\n\n    switch(class_id) {\n    case JS_CLASS_OBJECT:\n        break;\n    case JS_CLASS_ARRAY:\n        {\n            JSProperty *pr;\n            p->is_exotic = 1;\n            p->fast_array = 1;\n            p->u.array.u.values = NULL;\n            p->u.array.count = 0;\n            p->u.array.u1.size = 0;\n            /* the length property is always the first one */\n            if (likely(sh == ctx->array_shape)) {\n                pr = &p->prop[0];\n            } else {\n                /* only used for the first array */\n                /* cannot fail */\n                pr = add_property(ctx, p, JS_ATOM_length,\n                                  JS_PROP_WRITABLE | JS_PROP_LENGTH);\n            }\n            pr->u.value = JS_NewInt32(ctx, 0);\n        }\n        break;\n    case JS_CLASS_C_FUNCTION:\n        p->prop[0].u.value = JS_UNDEFINED;\n        break;\n    case JS_CLASS_ARGUMENTS:\n    case JS_CLASS_UINT8C_ARRAY:\n    case JS_CLASS_INT8_ARRAY:\n    case JS_CLASS_UINT8_ARRAY:\n    case JS_CLASS_INT16_ARRAY:\n    case JS_CLASS_UINT16_ARRAY:\n    case JS_CLASS_INT32_ARRAY:\n    case JS_CLASS_UINT32_ARRAY:\n#ifdef CONFIG_BIGNUM\n    case JS_CLASS_BIG_INT64_ARRAY:\n    case JS_CLASS_BIG_UINT64_ARRAY:\n#endif\n    case JS_CLASS_FLOAT32_ARRAY:\n    case JS_CLASS_FLOAT64_ARRAY:\n        p->is_exotic = 1;\n        p->fast_array = 1;\n        p->u.array.u.ptr = NULL;\n        p->u.array.count = 0;\n        break;\n    case JS_CLASS_DATAVIEW:\n        p->u.array.u.ptr = NULL;\n        p->u.array.count = 0;\n        break;\n    case JS_CLASS_NUMBER:\n    case JS_CLASS_STRING:\n    case JS_CLASS_BOOLEAN:\n    case JS_CLASS_SYMBOL:\n    case JS_CLASS_DATE:\n#ifdef CONFIG_BIGNUM\n    case JS_CLASS_BIG_INT:\n    case JS_CLASS_BIG_FLOAT:\n    case JS_CLASS_BIG_DECIMAL:\n#endif\n        p->u.object_data = JS_UNDEFINED;\n        goto set_exotic;\n    case JS_CLASS_REGEXP:\n        p->u.regexp.pattern = NULL;\n        p->u.regexp.bytecode = NULL;\n        goto set_exotic;\n    default:\n    set_exotic:\n        if (ctx->rt->class_array[class_id].exotic) {\n            p->is_exotic = 1;\n        }\n        break;\n    }\n    p->header.ref_count = 1;\n    add_gc_object(ctx->rt, &p->header, JS_GC_OBJ_TYPE_JS_OBJECT);\n    return JS_MKPTR(JS_TAG_OBJECT, p);\n}\n\nstatic JSObject *get_proto_obj(JSValueConst proto_val)\n{\n    if (JS_VALUE_GET_TAG(proto_val) != JS_TAG_OBJECT)\n        return NULL;\n    else\n        return JS_VALUE_GET_OBJ(proto_val);\n}\n\n/* WARNING: proto must be an object or JS_NULL */\nJSValue JS_NewObjectProtoClass(JSContext *ctx, JSValueConst proto_val,\n                               JSClassID class_id)\n{\n    JSShape *sh;\n    JSObject *proto;\n\n    proto = get_proto_obj(proto_val);\n    sh = find_hashed_shape_proto(ctx->rt, proto);\n    if (likely(sh)) {\n        sh = js_dup_shape(sh);\n    } else {\n        sh = js_new_shape(ctx, proto);\n        if (!sh)\n            return JS_EXCEPTION;\n    }\n    return JS_NewObjectFromShape(ctx, sh, class_id);\n}\n\n#if 0\nstatic JSValue JS_GetObjectData(JSContext *ctx, JSValueConst obj)\n{\n    JSObject *p;\n\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        p = JS_VALUE_GET_OBJ(obj);\n        switch(p->class_id) {\n        case JS_CLASS_NUMBER:\n        case JS_CLASS_STRING:\n        case JS_CLASS_BOOLEAN:\n        case JS_CLASS_SYMBOL:\n        case JS_CLASS_DATE:\n#ifdef CONFIG_BIGNUM\n        case JS_CLASS_BIG_INT:\n        case JS_CLASS_BIG_FLOAT:\n        case JS_CLASS_BIG_DECIMAL:\n#endif\n            return JS_DupValue(ctx, p->u.object_data);\n        }\n    }\n    return JS_UNDEFINED;\n}\n#endif\n\nstatic int JS_SetObjectData(JSContext *ctx, JSValueConst obj, JSValue val)\n{\n    JSObject *p;\n\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        p = JS_VALUE_GET_OBJ(obj);\n        switch(p->class_id) {\n        case JS_CLASS_NUMBER:\n        case JS_CLASS_STRING:\n        case JS_CLASS_BOOLEAN:\n        case JS_CLASS_SYMBOL:\n        case JS_CLASS_DATE:\n#ifdef CONFIG_BIGNUM\n        case JS_CLASS_BIG_INT:\n        case JS_CLASS_BIG_FLOAT:\n        case JS_CLASS_BIG_DECIMAL:\n#endif\n            JS_FreeValue(ctx, p->u.object_data);\n            p->u.object_data = val;\n            return 0;\n        }\n    }\n    JS_FreeValue(ctx, val);\n    if (!JS_IsException(obj))\n        JS_ThrowTypeError(ctx, \"invalid object type\");\n    return -1;\n}\n\nJSValue JS_NewObjectClass(JSContext *ctx, int class_id)\n{\n    return JS_NewObjectProtoClass(ctx, ctx->class_proto[class_id], class_id);\n}\n\nJSValue JS_NewObjectProto(JSContext *ctx, JSValueConst proto)\n{\n    return JS_NewObjectProtoClass(ctx, proto, JS_CLASS_OBJECT);\n}\n\nJSValue JS_NewArray(JSContext *ctx)\n{\n    return JS_NewObjectFromShape(ctx, js_dup_shape(ctx->array_shape),\n                                 JS_CLASS_ARRAY);\n}\n\nJSValue JS_NewObject(JSContext *ctx)\n{\n    /* inline JS_NewObjectClass(ctx, JS_CLASS_OBJECT); */\n    return JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT], JS_CLASS_OBJECT);\n}\n\nstatic void js_function_set_properties(JSContext *ctx, JSValueConst func_obj,\n                                       JSAtom name, int len)\n{\n    /* ES6 feature non compatible with ES5.1: length is configurable */\n    JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_length, JS_NewInt32(ctx, len),\n                           JS_PROP_CONFIGURABLE);\n    JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_name,\n                           JS_AtomToString(ctx, name), JS_PROP_CONFIGURABLE);\n}\n\nstatic BOOL js_class_has_bytecode(JSClassID class_id)\n{\n    return (class_id == JS_CLASS_BYTECODE_FUNCTION ||\n            class_id == JS_CLASS_GENERATOR_FUNCTION ||\n            class_id == JS_CLASS_ASYNC_FUNCTION ||\n            class_id == JS_CLASS_ASYNC_GENERATOR_FUNCTION);\n}\n\n/* return NULL without exception if not a function or no bytecode */\nstatic JSFunctionBytecode *JS_GetFunctionBytecode(JSValueConst val)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return NULL;\n    p = JS_VALUE_GET_OBJ(val);\n    if (!js_class_has_bytecode(p->class_id))\n        return NULL;\n    return p->u.func.function_bytecode;\n}\n\nstatic void js_method_set_home_object(JSContext *ctx, JSValueConst func_obj,\n                                      JSValueConst home_obj)\n{\n    JSObject *p, *p1;\n    JSFunctionBytecode *b;\n\n    if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)\n        return;\n    p = JS_VALUE_GET_OBJ(func_obj);\n    if (!js_class_has_bytecode(p->class_id))\n        return;\n    b = p->u.func.function_bytecode;\n    if (b->need_home_object) {\n        p1 = p->u.func.home_object;\n        if (p1) {\n            JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p1));\n        }\n        if (JS_VALUE_GET_TAG(home_obj) == JS_TAG_OBJECT)\n            p1 = JS_VALUE_GET_OBJ(JS_DupValue(ctx, home_obj));\n        else\n            p1 = NULL;\n        p->u.func.home_object = p1;\n    }\n}\n\nstatic JSValue js_get_function_name(JSContext *ctx, JSAtom name)\n{\n    JSValue name_str;\n\n    name_str = JS_AtomToString(ctx, name);\n    if (JS_AtomSymbolHasDescription(ctx, name)) {\n        name_str = JS_ConcatString3(ctx, \"[\", name_str, \"]\");\n    }\n    return name_str;\n}\n\n/* Modify the name of a method according to the atom and\n   'flags'. 'flags' is a bitmask of JS_PROP_HAS_GET and\n   JS_PROP_HAS_SET. Also set the home object of the method.\n   Return < 0 if exception. */\nstatic int js_method_set_properties(JSContext *ctx, JSValueConst func_obj,\n                                    JSAtom name, int flags, JSValueConst home_obj)\n{\n    JSValue name_str;\n\n    name_str = js_get_function_name(ctx, name);\n    if (flags & JS_PROP_HAS_GET) {\n        name_str = JS_ConcatString3(ctx, \"get \", name_str, \"\");\n    } else if (flags & JS_PROP_HAS_SET) {\n        name_str = JS_ConcatString3(ctx, \"set \", name_str, \"\");\n    }\n    if (JS_IsException(name_str))\n        return -1;\n    if (JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_name, name_str,\n                               JS_PROP_CONFIGURABLE) < 0)\n        return -1;\n    js_method_set_home_object(ctx, func_obj, home_obj);\n    return 0;\n}\n\n/* Note: at least 'length' arguments will be readable in 'argv' */\nstatic JSValue JS_NewCFunction3(JSContext *ctx, JSCFunction *func,\n                                const char *name,\n                                int length, JSCFunctionEnum cproto, int magic,\n                                JSValueConst proto_val)\n{\n    JSValue func_obj;\n    JSObject *p;\n    JSAtom name_atom;\n    \n    func_obj = JS_NewObjectProtoClass(ctx, proto_val, JS_CLASS_C_FUNCTION);\n    if (JS_IsException(func_obj))\n        return func_obj;\n    p = JS_VALUE_GET_OBJ(func_obj);\n    p->u.cfunc.realm = JS_DupContext(ctx);\n    p->u.cfunc.c_function.generic = func;\n    p->u.cfunc.length = length;\n    p->u.cfunc.cproto = cproto;\n    p->u.cfunc.magic = magic;\n    p->is_constructor = (cproto == JS_CFUNC_constructor ||\n                         cproto == JS_CFUNC_constructor_magic ||\n                         cproto == JS_CFUNC_constructor_or_func ||\n                         cproto == JS_CFUNC_constructor_or_func_magic);\n    if (!name)\n        name = \"\";\n    name_atom = JS_NewAtom(ctx, name);\n    js_function_set_properties(ctx, func_obj, name_atom, length);\n    JS_FreeAtom(ctx, name_atom);\n    return func_obj;\n}\n\n/* Note: at least 'length' arguments will be readable in 'argv' */\nJSValue JS_NewCFunction2(JSContext *ctx, JSCFunction *func,\n                         const char *name,\n                         int length, JSCFunctionEnum cproto, int magic)\n{\n    return JS_NewCFunction3(ctx, func, name, length, cproto, magic,\n                            ctx->function_proto);\n}\n\ntypedef struct JSCFunctionDataRecord {\n    JSCFunctionData *func;\n    uint8_t length;\n    uint8_t data_len;\n    uint16_t magic;\n    JSValue data[0];\n} JSCFunctionDataRecord;\n\nstatic void js_c_function_data_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSCFunctionDataRecord *s = JS_GetOpaque(val, JS_CLASS_C_FUNCTION_DATA);\n    int i;\n\n    if (s) {\n        for(i = 0; i < s->data_len; i++) {\n            JS_FreeValueRT(rt, s->data[i]);\n        }\n        js_free_rt(rt, s);\n    }\n}\n\nstatic void js_c_function_data_mark(JSRuntime *rt, JSValueConst val,\n                                    JS_MarkFunc *mark_func)\n{\n    JSCFunctionDataRecord *s = JS_GetOpaque(val, JS_CLASS_C_FUNCTION_DATA);\n    int i;\n\n    if (s) {\n        for(i = 0; i < s->data_len; i++) {\n            JS_MarkValue(rt, s->data[i], mark_func);\n        }\n    }\n}\n\nstatic JSValue js_c_function_data_call(JSContext *ctx, JSValueConst func_obj,\n                                       JSValueConst this_val,\n                                       int argc, JSValueConst *argv, int flags)\n{\n    JSCFunctionDataRecord *s = JS_GetOpaque(func_obj, JS_CLASS_C_FUNCTION_DATA);\n    JSValueConst *arg_buf;\n    int i;\n\n    /* XXX: could add the function on the stack for debug */\n    if (unlikely(argc < s->length)) {\n        arg_buf = alloca(sizeof(arg_buf[0]) * s->length);\n        for(i = 0; i < argc; i++)\n            arg_buf[i] = argv[i];\n        for(i = argc; i < s->length; i++)\n            arg_buf[i] = JS_UNDEFINED;\n    } else {\n        arg_buf = argv;\n    }\n\n    return s->func(ctx, this_val, argc, arg_buf, s->magic, s->data);\n}\n\nJSValue JS_NewCFunctionData(JSContext *ctx, JSCFunctionData *func,\n                            int length, int magic, int data_len,\n                            JSValueConst *data)\n{\n    JSCFunctionDataRecord *s;\n    JSValue func_obj;\n    int i;\n\n    func_obj = JS_NewObjectProtoClass(ctx, ctx->function_proto,\n                                      JS_CLASS_C_FUNCTION_DATA);\n    if (JS_IsException(func_obj))\n        return func_obj;\n    s = js_malloc(ctx, sizeof(*s) + data_len * sizeof(JSValue));\n    if (!s) {\n        JS_FreeValue(ctx, func_obj);\n        return JS_EXCEPTION;\n    }\n    s->func = func;\n    s->length = length;\n    s->data_len = data_len;\n    s->magic = magic;\n    for(i = 0; i < data_len; i++)\n        s->data[i] = JS_DupValue(ctx, data[i]);\n    JS_SetOpaque(func_obj, s);\n    js_function_set_properties(ctx, func_obj,\n                               JS_ATOM_empty_string, length);\n    return func_obj;\n}\n\nstatic JSContext *js_autoinit_get_realm(JSProperty *pr)\n{\n    return (JSContext *)(pr->u.init.realm_and_id & ~3);\n}\n\nstatic JSAutoInitIDEnum js_autoinit_get_id(JSProperty *pr)\n{\n    return pr->u.init.realm_and_id & 3;\n}\n\nstatic void js_autoinit_free(JSRuntime *rt, JSProperty *pr)\n{\n    JS_FreeContext(js_autoinit_get_realm(pr));\n}\n\nstatic void js_autoinit_mark(JSRuntime *rt, JSProperty *pr,\n                             JS_MarkFunc *mark_func)\n{\n    mark_func(rt, &js_autoinit_get_realm(pr)->header);\n}\n\ntypedef struct JSCClosureRecord {\n    JSCClosure *func;\n    uint16_t length;\n    uint16_t magic;\n    void *opaque;\n    void (*opaque_finalize)(void*);\n} JSCClosureRecord;\n\nstatic void js_c_closure_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSCClosureRecord *s = JS_GetOpaque(val, JS_CLASS_C_CLOSURE);\n\n    if (s) {\n        if (s->opaque_finalize)\n           s->opaque_finalize(s->opaque);\n\n        js_free_rt(rt, s);\n    }\n}\n\nstatic JSValue js_c_closure_call(JSContext *ctx, JSValueConst func_obj,\n                                 JSValueConst this_val,\n                                 int argc, JSValueConst *argv, int flags)\n{\n    JSCClosureRecord *s = JS_GetOpaque(func_obj, JS_CLASS_C_CLOSURE);\n    JSValueConst *arg_buf;\n    int i;\n\n    /* XXX: could add the function on the stack for debug */\n    if (unlikely(argc < s->length)) {\n        arg_buf = alloca(sizeof(arg_buf[0]) * s->length);\n        for(i = 0; i < argc; i++)\n            arg_buf[i] = argv[i];\n        for(i = argc; i < s->length; i++)\n            arg_buf[i] = JS_UNDEFINED;\n    } else {\n        arg_buf = argv;\n    }\n\n    return s->func(ctx, this_val, argc, arg_buf, s->magic, s->opaque);\n}\n\nJSValue JS_NewCClosure(JSContext *ctx, JSCClosure *func,\n                       int length, int magic, void *opaque,\n                       void (*opaque_finalize)(void*))\n{\n    JSCClosureRecord *s;\n    JSValue func_obj;\n\n    func_obj = JS_NewObjectProtoClass(ctx, ctx->function_proto,\n                                      JS_CLASS_C_CLOSURE);\n    if (JS_IsException(func_obj))\n        return func_obj;\n    s = js_malloc(ctx, sizeof(*s));\n    if (!s) {\n        JS_FreeValue(ctx, func_obj);\n        return JS_EXCEPTION;\n    }\n    s->func = func;\n    s->length = length;\n    s->magic = magic;\n    s->opaque = opaque;\n    s->opaque_finalize = opaque_finalize;\n    JS_SetOpaque(func_obj, s);\n    js_function_set_properties(ctx, func_obj,\n                               JS_ATOM_empty_string, length);\n    return func_obj;\n}\n\nstatic void free_property(JSRuntime *rt, JSProperty *pr, int prop_flags)\n{\n    if (unlikely(prop_flags & JS_PROP_TMASK)) {\n        if ((prop_flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n            if (pr->u.getset.getter)\n                JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter));\n            if (pr->u.getset.setter)\n                JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.setter));\n        } else if ((prop_flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n            free_var_ref(rt, pr->u.var_ref);\n        } else if ((prop_flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n            js_autoinit_free(rt, pr);\n        }\n    } else {\n        JS_FreeValueRT(rt, pr->u.value);\n    }\n}\n\nstatic force_inline JSShapeProperty *find_own_property1(JSObject *p,\n                                                        JSAtom atom)\n{\n    JSShape *sh;\n    JSShapeProperty *pr, *prop;\n    intptr_t h;\n    sh = p->shape;\n    h = (uintptr_t)atom & sh->prop_hash_mask;\n    h = prop_hash_end(sh)[-h - 1];\n    prop = get_shape_prop(sh);\n    while (h) {\n        pr = &prop[h - 1];\n        if (likely(pr->atom == atom)) {\n            return pr;\n        }\n        h = pr->hash_next;\n    }\n    return NULL;\n}\n\nstatic force_inline JSShapeProperty *find_own_property(JSProperty **ppr,\n                                                       JSObject *p,\n                                                       JSAtom atom)\n{\n    JSShape *sh;\n    JSShapeProperty *pr, *prop;\n    intptr_t h;\n    sh = p->shape;\n    h = (uintptr_t)atom & sh->prop_hash_mask;\n    h = prop_hash_end(sh)[-h - 1];\n    prop = get_shape_prop(sh);\n    while (h) {\n        pr = &prop[h - 1];\n        if (likely(pr->atom == atom)) {\n            *ppr = &p->prop[h - 1];\n            /* the compiler should be able to assume that pr != NULL here */\n            return pr;\n        }\n        h = pr->hash_next;\n    }\n    *ppr = NULL;\n    return NULL;\n}\n\n/* indicate that the object may be part of a function prototype cycle */\nstatic void set_cycle_flag(JSContext *ctx, JSValueConst obj)\n{\n}\n\nstatic void free_var_ref(JSRuntime *rt, JSVarRef *var_ref)\n{\n    if (var_ref) {\n        assert(var_ref->header.ref_count > 0);\n        if (--var_ref->header.ref_count == 0) {\n            if (var_ref->is_detached) {\n                JS_FreeValueRT(rt, var_ref->value);\n                remove_gc_object(&var_ref->header);\n            } else {\n                list_del(&var_ref->header.link); /* still on the stack */\n            }\n            js_free_rt(rt, var_ref);\n        }\n    }\n}\n\nstatic void js_array_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    int i;\n\n    for(i = 0; i < p->u.array.count; i++) {\n        JS_FreeValueRT(rt, p->u.array.u.values[i]);\n    }\n    js_free_rt(rt, p->u.array.u.values);\n}\n\nstatic void js_array_mark(JSRuntime *rt, JSValueConst val,\n                          JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    int i;\n\n    for(i = 0; i < p->u.array.count; i++) {\n        JS_MarkValue(rt, p->u.array.u.values[i], mark_func);\n    }\n}\n\nstatic void js_object_data_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JS_FreeValueRT(rt, p->u.object_data);\n    p->u.object_data = JS_UNDEFINED;\n}\n\nstatic void js_object_data_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JS_MarkValue(rt, p->u.object_data, mark_func);\n}\n\nstatic void js_c_function_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n\n    if (p->u.cfunc.realm)\n        JS_FreeContext(p->u.cfunc.realm);\n}\n\nstatic void js_c_function_mark(JSRuntime *rt, JSValueConst val,\n                               JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n\n    if (p->u.cfunc.realm)\n        mark_func(rt, &p->u.cfunc.realm->header);\n}\n\nstatic void js_bytecode_function_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p1, *p = JS_VALUE_GET_OBJ(val);\n    JSFunctionBytecode *b;\n    JSVarRef **var_refs;\n    int i;\n\n    p1 = p->u.func.home_object;\n    if (p1) {\n        JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, p1));\n    }\n    b = p->u.func.function_bytecode;\n    if (b) {\n        var_refs = p->u.func.var_refs;\n        if (var_refs) {\n            for(i = 0; i < b->closure_var_count; i++)\n                free_var_ref(rt, var_refs[i]);\n            js_free_rt(rt, var_refs);\n        }\n        JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, b));\n    }\n}\n\nstatic void js_bytecode_function_mark(JSRuntime *rt, JSValueConst val,\n                                      JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSVarRef **var_refs = p->u.func.var_refs;\n    JSFunctionBytecode *b = p->u.func.function_bytecode;\n    int i;\n\n    if (p->u.func.home_object) {\n        JS_MarkValue(rt, JS_MKPTR(JS_TAG_OBJECT, p->u.func.home_object),\n                     mark_func);\n    }\n    if (b) {\n        if (var_refs) {\n            for(i = 0; i < b->closure_var_count; i++) {\n                JSVarRef *var_ref = var_refs[i];\n                if (var_ref && var_ref->is_detached) {\n                    mark_func(rt, &var_ref->header);\n                }\n            }\n        }\n        /* must mark the function bytecode because template objects may be\n           part of a cycle */\n        JS_MarkValue(rt, JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, b), mark_func);\n    }\n}\n\nstatic void js_bound_function_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSBoundFunction *bf = p->u.bound_function;\n    int i;\n\n    JS_FreeValueRT(rt, bf->func_obj);\n    JS_FreeValueRT(rt, bf->this_val);\n    for(i = 0; i < bf->argc; i++) {\n        JS_FreeValueRT(rt, bf->argv[i]);\n    }\n    js_free_rt(rt, bf);\n}\n\nstatic void js_bound_function_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSBoundFunction *bf = p->u.bound_function;\n    int i;\n\n    JS_MarkValue(rt, bf->func_obj, mark_func);\n    JS_MarkValue(rt, bf->this_val, mark_func);\n    for(i = 0; i < bf->argc; i++)\n        JS_MarkValue(rt, bf->argv[i], mark_func);\n}\n\nstatic void js_for_in_iterator_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSForInIterator *it = p->u.for_in_iterator;\n    JS_FreeValueRT(rt, it->obj);\n    js_free_rt(rt, it);\n}\n\nstatic void js_for_in_iterator_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSForInIterator *it = p->u.for_in_iterator;\n    JS_MarkValue(rt, it->obj, mark_func);\n}\n\nstatic void free_object(JSRuntime *rt, JSObject *p)\n{\n    int i;\n    JSClassFinalizer *finalizer;\n    JSShape *sh;\n    JSShapeProperty *pr;\n\n    p->free_mark = 1; /* used to tell the object is invalid when\n                         freeing cycles */\n    /* free all the fields */\n    sh = p->shape;\n    pr = get_shape_prop(sh);\n    for(i = 0; i < sh->prop_count; i++) {\n        free_property(rt, &p->prop[i], pr->flags);\n        pr++;\n    }\n    js_free_rt(rt, p->prop);\n    /* as an optimization we destroy the shape immediately without\n       putting it in gc_zero_ref_count_list */\n    js_free_shape(rt, sh);\n\n    /* fail safe */\n    p->shape = NULL;\n    p->prop = NULL;\n\n    if (unlikely(p->first_weak_ref)) {\n        reset_weak_ref(rt, p);\n    }\n\n    finalizer = rt->class_array[p->class_id].finalizer;\n    if (finalizer)\n        (*finalizer)(rt, JS_MKPTR(JS_TAG_OBJECT, p));\n\n    /* fail safe */\n    p->class_id = 0;\n    p->u.opaque = NULL;\n    p->u.func.var_refs = NULL;\n    p->u.func.home_object = NULL;\n\n    remove_gc_object(&p->header);\n    if (rt->gc_phase == JS_GC_PHASE_REMOVE_CYCLES && p->header.ref_count != 0) {\n        list_add_tail(&p->header.link, &rt->gc_zero_ref_count_list);\n    } else {\n        js_free_rt(rt, p);\n    }\n}\n\nstatic void free_gc_object(JSRuntime *rt, JSGCObjectHeader *gp)\n{\n    switch(gp->gc_obj_type) {\n    case JS_GC_OBJ_TYPE_JS_OBJECT:\n        free_object(rt, (JSObject *)gp);\n        break;\n    case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:\n        free_function_bytecode(rt, (JSFunctionBytecode *)gp);\n        break;\n    default:\n        abort();\n    }\n}\n\nstatic void free_zero_refcount(JSRuntime *rt)\n{\n    struct list_head *el;\n    JSGCObjectHeader *p;\n    \n    rt->gc_phase = JS_GC_PHASE_DECREF;\n    for(;;) {\n        el = rt->gc_zero_ref_count_list.next;\n        if (el == &rt->gc_zero_ref_count_list)\n            break;\n        p = list_entry(el, JSGCObjectHeader, link);\n        assert(p->ref_count == 0);\n        free_gc_object(rt, p);\n    }\n    rt->gc_phase = JS_GC_PHASE_NONE;\n}\n\n/* called with the ref_count of 'v' reaches zero. */\nvoid __JS_FreeValueRT(JSRuntime *rt, JSValue v)\n{\n    uint32_t tag = JS_VALUE_GET_TAG(v);\n\n#ifdef DUMP_FREE\n    {\n        printf(\"Freeing \");\n        if (tag == JS_TAG_OBJECT) {\n            JS_DumpObject(rt, JS_VALUE_GET_OBJ(v));\n        } else {\n            JS_DumpValueShort(rt, v);\n            printf(\"\\n\");\n        }\n    }\n#endif\n\n    switch(tag) {\n    case JS_TAG_STRING:\n        {\n            JSString *p = JS_VALUE_GET_STRING(v);\n            if (p->atom_type) {\n                JS_FreeAtomStruct(rt, p);\n            } else {\n#ifdef DUMP_LEAKS\n                list_del(&p->link);\n#endif\n                js_free_rt(rt, p);\n            }\n        }\n        break;\n    case JS_TAG_OBJECT:\n    case JS_TAG_FUNCTION_BYTECODE:\n        {\n            JSGCObjectHeader *p = JS_VALUE_GET_PTR(v);\n            if (rt->gc_phase != JS_GC_PHASE_REMOVE_CYCLES) {\n                list_del(&p->link);\n                list_add(&p->link, &rt->gc_zero_ref_count_list);\n                if (rt->gc_phase == JS_GC_PHASE_NONE) {\n                    free_zero_refcount(rt);\n                }\n            }\n        }\n        break;\n    case JS_TAG_MODULE:\n        abort(); /* never freed here */\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *bf = JS_VALUE_GET_PTR(v);\n            bf_delete(&bf->num);\n            js_free_rt(rt, bf);\n        }\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        {\n            JSBigDecimal *bf = JS_VALUE_GET_PTR(v);\n            bfdec_delete(&bf->num);\n            js_free_rt(rt, bf);\n        }\n        break;\n#endif\n    case JS_TAG_SYMBOL:\n        {\n            JSAtomStruct *p = JS_VALUE_GET_PTR(v);\n            JS_FreeAtomStruct(rt, p);\n        }\n        break;\n    default:\n        printf(\"__JS_FreeValue: unknown tag=%d\\n\", tag);\n        abort();\n    }\n}\n\nvoid __JS_FreeValue(JSContext *ctx, JSValue v)\n{\n    __JS_FreeValueRT(ctx->rt, v);\n}\n\n/* garbage collection */\n\nstatic void add_gc_object(JSRuntime *rt, JSGCObjectHeader *h,\n                          JSGCObjectTypeEnum type)\n{\n    h->mark = 0;\n    h->gc_obj_type = type;\n    list_add_tail(&h->link, &rt->gc_obj_list);\n}\n\nstatic void remove_gc_object(JSGCObjectHeader *h)\n{\n    list_del(&h->link);\n}\n\nvoid JS_MarkValue(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func)\n{\n    if (JS_VALUE_HAS_REF_COUNT(val)) {\n        switch(JS_VALUE_GET_TAG(val)) {\n        case JS_TAG_OBJECT:\n        case JS_TAG_FUNCTION_BYTECODE:\n            mark_func(rt, JS_VALUE_GET_PTR(val));\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nstatic void mark_children(JSRuntime *rt, JSGCObjectHeader *gp,\n                          JS_MarkFunc *mark_func)\n{\n    switch(gp->gc_obj_type) {\n    case JS_GC_OBJ_TYPE_JS_OBJECT:\n        {\n            JSObject *p = (JSObject *)gp;\n            JSShapeProperty *prs;\n            JSShape *sh;\n            int i;\n            sh = p->shape;\n            mark_func(rt, &sh->header);\n            /* mark all the fields */\n            prs = get_shape_prop(sh);\n            for(i = 0; i < sh->prop_count; i++) {\n                JSProperty *pr = &p->prop[i];\n                if (prs->atom != JS_ATOM_NULL) {\n                    if (prs->flags & JS_PROP_TMASK) {\n                        if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n                            if (pr->u.getset.getter)\n                                mark_func(rt, &pr->u.getset.getter->header);\n                            if (pr->u.getset.setter)\n                                mark_func(rt, &pr->u.getset.setter->header);\n                        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n                            if (pr->u.var_ref->is_detached) {\n                                /* Note: the tag does not matter\n                                   provided it is a GC object */\n                                mark_func(rt, &pr->u.var_ref->header);\n                            }\n                        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n                            js_autoinit_mark(rt, pr, mark_func);\n                        }\n                    } else {\n                        JS_MarkValue(rt, pr->u.value, mark_func);\n                    }\n                }\n                prs++;\n            }\n\n            if (p->class_id != JS_CLASS_OBJECT) {\n                JSClassGCMark *gc_mark;\n                gc_mark = rt->class_array[p->class_id].gc_mark;\n                if (gc_mark)\n                    gc_mark(rt, JS_MKPTR(JS_TAG_OBJECT, p), mark_func);\n            }\n        }\n        break;\n    case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:\n        /* the template objects can be part of a cycle */\n        {\n            JSFunctionBytecode *b = (JSFunctionBytecode *)gp;\n            int i;\n            for(i = 0; i < b->cpool_count; i++) {\n                JS_MarkValue(rt, b->cpool[i], mark_func);\n            }\n            if (b->realm)\n                mark_func(rt, &b->realm->header);\n        }\n        break;\n    case JS_GC_OBJ_TYPE_VAR_REF:\n        {\n            JSVarRef *var_ref = (JSVarRef *)gp;\n            /* only detached variable referenced are taken into account */\n            assert(var_ref->is_detached);\n            JS_MarkValue(rt, *var_ref->pvalue, mark_func);\n        }\n        break;\n    case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:\n        {\n            JSAsyncFunctionData *s = (JSAsyncFunctionData *)gp;\n            if (s->is_active)\n                async_func_mark(rt, &s->func_state, mark_func);\n            JS_MarkValue(rt, s->resolving_funcs[0], mark_func);\n            JS_MarkValue(rt, s->resolving_funcs[1], mark_func);\n        }\n        break;\n    case JS_GC_OBJ_TYPE_SHAPE:\n        {\n            JSShape *sh = (JSShape *)gp;\n            if (sh->proto != NULL) {\n                mark_func(rt, &sh->proto->header);\n            }\n        }\n        break;\n    case JS_GC_OBJ_TYPE_JS_CONTEXT:\n        {\n            JSContext *ctx = (JSContext *)gp;\n            JS_MarkContext(rt, ctx, mark_func);\n        }\n        break;\n    default:\n        abort();\n    }\n}\n\nstatic void gc_decref_child(JSRuntime *rt, JSGCObjectHeader *p)\n{\n    assert(p->ref_count > 0);\n    p->ref_count--;\n    if (p->ref_count == 0 && p->mark == 1) {\n        list_del(&p->link);\n        list_add_tail(&p->link, &rt->tmp_obj_list);\n    }\n}\n\nstatic void gc_decref(JSRuntime *rt)\n{\n    struct list_head *el, *el1;\n    JSGCObjectHeader *p;\n    \n    init_list_head(&rt->tmp_obj_list);\n\n    /* decrement the refcount of all the children of all the GC\n       objects and move the GC objects with zero refcount to\n       tmp_obj_list */\n    list_for_each_safe(el, el1, &rt->gc_obj_list) {\n        p = list_entry(el, JSGCObjectHeader, link);\n        assert(p->mark == 0);\n        mark_children(rt, p, gc_decref_child);\n        p->mark = 1;\n        if (p->ref_count == 0) {\n            list_del(&p->link);\n            list_add_tail(&p->link, &rt->tmp_obj_list);\n        }\n    }\n}\n\nstatic void gc_scan_incref_child(JSRuntime *rt, JSGCObjectHeader *p)\n{\n    p->ref_count++;\n    if (p->ref_count == 1) {\n        /* ref_count was 0: remove from tmp_obj_list and add at the\n           end of gc_obj_list */\n        list_del(&p->link);\n        list_add_tail(&p->link, &rt->gc_obj_list);\n        p->mark = 0; /* reset the mark for the next GC call */\n    }\n}\n\nstatic void gc_scan_incref_child2(JSRuntime *rt, JSGCObjectHeader *p)\n{\n    p->ref_count++;\n}\n\nstatic void gc_scan(JSRuntime *rt)\n{\n    struct list_head *el;\n    JSGCObjectHeader *p;\n\n    /* keep the objects with a refcount > 0 and their children. */\n    list_for_each(el, &rt->gc_obj_list) {\n        p = list_entry(el, JSGCObjectHeader, link);\n        assert(p->ref_count > 0);\n        p->mark = 0; /* reset the mark for the next GC call */\n        mark_children(rt, p, gc_scan_incref_child);\n    }\n    \n    /* restore the refcount of the objects to be deleted. */\n    list_for_each(el, &rt->tmp_obj_list) {\n        p = list_entry(el, JSGCObjectHeader, link);\n        mark_children(rt, p, gc_scan_incref_child2);\n    }\n}\n\nstatic void gc_free_cycles(JSRuntime *rt)\n{\n    struct list_head *el, *el1;\n    JSGCObjectHeader *p;\n#ifdef DUMP_GC_FREE\n    BOOL header_done = FALSE;\n#endif\n\n    rt->gc_phase = JS_GC_PHASE_REMOVE_CYCLES;\n\n    for(;;) {\n        el = rt->tmp_obj_list.next;\n        if (el == &rt->tmp_obj_list)\n            break;\n        p = list_entry(el, JSGCObjectHeader, link);\n        /* Only need to free the GC object associated with JS\n           values. The rest will be automatically removed because they\n           must be referenced by them. */\n        switch(p->gc_obj_type) {\n        case JS_GC_OBJ_TYPE_JS_OBJECT:\n        case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:\n#ifdef DUMP_GC_FREE\n            if (!header_done) {\n                printf(\"Freeing cycles:\\n\");\n                JS_DumpObjectHeader(rt);\n                header_done = TRUE;\n            }\n            JS_DumpGCObject(rt, p);\n#endif\n            free_gc_object(rt, p);\n            break;\n        default:\n            list_del(&p->link);\n            list_add_tail(&p->link, &rt->gc_zero_ref_count_list);\n            break;\n        }\n    }\n    rt->gc_phase = JS_GC_PHASE_NONE;\n           \n    list_for_each_safe(el, el1, &rt->gc_zero_ref_count_list) {\n        p = list_entry(el, JSGCObjectHeader, link);\n        assert(p->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT ||\n               p->gc_obj_type == JS_GC_OBJ_TYPE_FUNCTION_BYTECODE);\n        js_free_rt(rt, p);\n    }\n\n    init_list_head(&rt->gc_zero_ref_count_list);\n}\n\nvoid JS_RunGC(JSRuntime *rt)\n{\n    /* decrement the reference of the children of each object. mark =\n       1 after this pass. */\n    gc_decref(rt);\n\n    /* keep the GC objects with a non zero refcount and their childs */\n    gc_scan(rt);\n\n    /* free the GC objects in a cycle */\n    gc_free_cycles(rt);\n}\n\n/* Return false if not an object or if the object has already been\n   freed (zombie objects are visible in finalizers when freeing\n   cycles). */\nBOOL JS_IsLiveObject(JSRuntime *rt, JSValueConst obj)\n{\n    JSObject *p;\n    if (!JS_IsObject(obj))\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(obj);\n    return !p->free_mark;\n}\n\n/* Compute memory used by various object types */\n/* XXX: poor man's approach to handling multiply referenced objects */\ntypedef struct JSMemoryUsage_helper {\n    double memory_used_count;\n    double str_count;\n    double str_size;\n    int64_t js_func_count;\n    double js_func_size;\n    int64_t js_func_code_size;\n    int64_t js_func_pc2line_count;\n    int64_t js_func_pc2line_size;\n} JSMemoryUsage_helper;\n\nstatic void compute_value_size(JSValueConst val, JSMemoryUsage_helper *hp);\n\nstatic void compute_jsstring_size(JSString *str, JSMemoryUsage_helper *hp)\n{\n    if (!str->atom_type) {  /* atoms are handled separately */\n        double s_ref_count = str->header.ref_count;\n        hp->str_count += 1 / s_ref_count;\n        hp->str_size += ((sizeof(*str) + (str->len << str->is_wide_char) +\n                          1 - str->is_wide_char) / s_ref_count);\n    }\n}\n\nstatic void compute_bytecode_size(JSFunctionBytecode *b, JSMemoryUsage_helper *hp)\n{\n    int memory_used_count, js_func_size, i;\n\n    memory_used_count = 0;\n    js_func_size = offsetof(JSFunctionBytecode, debug);\n    if (b->vardefs) {\n        js_func_size += (b->arg_count + b->var_count) * sizeof(*b->vardefs);\n    }\n    if (b->cpool) {\n        js_func_size += b->cpool_count * sizeof(*b->cpool);\n        for (i = 0; i < b->cpool_count; i++) {\n            JSValueConst val = b->cpool[i];\n            compute_value_size(val, hp);\n        }\n    }\n    if (b->closure_var) {\n        js_func_size += b->closure_var_count * sizeof(*b->closure_var);\n    }\n    if (!b->read_only_bytecode && b->byte_code_buf) {\n        hp->js_func_code_size += b->byte_code_len;\n    }\n    if (b->has_debug) {\n        js_func_size += sizeof(*b) - offsetof(JSFunctionBytecode, debug);\n        if (b->debug.source) {\n            memory_used_count++;\n            js_func_size += b->debug.source_len + 1;\n        }\n        if (b->debug.pc2line_len) {\n            memory_used_count++;\n            hp->js_func_pc2line_count += 1;\n            hp->js_func_pc2line_size += b->debug.pc2line_len;\n        }\n    }\n    hp->js_func_size += js_func_size;\n    hp->js_func_count += 1;\n    hp->memory_used_count += memory_used_count;\n}\n\nstatic void compute_value_size(JSValueConst val, JSMemoryUsage_helper *hp)\n{\n    switch(JS_VALUE_GET_TAG(val)) {\n    case JS_TAG_STRING:\n        compute_jsstring_size(JS_VALUE_GET_STRING(val), hp);\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n    case JS_TAG_BIG_FLOAT:\n    case JS_TAG_BIG_DECIMAL:\n        /* should track JSBigFloat usage */\n        break;\n#endif\n    }\n}\n\nvoid JS_ComputeMemoryUsage(JSRuntime *rt, JSMemoryUsage *s)\n{\n    struct list_head *el, *el1;\n    int i;\n    JSMemoryUsage_helper mem = { 0 }, *hp = &mem;\n\n    memset(s, 0, sizeof(*s));\n    s->malloc_count = rt->malloc_state.malloc_count;\n    s->malloc_size = rt->malloc_state.malloc_size;\n    s->malloc_limit = rt->malloc_state.malloc_limit;\n\n    s->memory_used_count = 2; /* rt + rt->class_array */\n    s->memory_used_size = sizeof(JSRuntime) + sizeof(JSValue) * rt->class_count;\n\n    list_for_each(el, &rt->context_list) {\n        JSContext *ctx = list_entry(el, JSContext, link);\n        JSShape *sh = ctx->array_shape;\n        s->memory_used_count += 2; /* ctx + ctx->class_proto */\n        s->memory_used_size += sizeof(JSContext) +\n            sizeof(JSValue) * rt->class_count;\n        s->binary_object_count += ctx->binary_object_count;\n        s->binary_object_size += ctx->binary_object_size;\n\n        /* the hashed shapes are counted separately */\n        if (sh && !sh->is_hashed) {\n            int hash_size = sh->prop_hash_mask + 1;\n            s->shape_count++;\n            s->shape_size += get_shape_size(hash_size, sh->prop_size);\n        }\n        list_for_each(el1, &ctx->loaded_modules) {\n            JSModuleDef *m = list_entry(el1, JSModuleDef, link);\n            s->memory_used_count += 1;\n            s->memory_used_size += sizeof(*m);\n            if (m->req_module_entries) {\n                s->memory_used_count += 1;\n                s->memory_used_size += m->req_module_entries_count * sizeof(*m->req_module_entries);\n            }\n            if (m->export_entries) {\n                s->memory_used_count += 1;\n                s->memory_used_size += m->export_entries_count * sizeof(*m->export_entries);\n                for (i = 0; i < m->export_entries_count; i++) {\n                    JSExportEntry *me = &m->export_entries[i];\n                    if (me->export_type == JS_EXPORT_TYPE_LOCAL && me->u.local.var_ref) {\n                        /* potential multiple count */\n                        s->memory_used_count += 1;\n                        compute_value_size(me->u.local.var_ref->value, hp);\n                    }\n                }\n            }\n            if (m->star_export_entries) {\n                s->memory_used_count += 1;\n                s->memory_used_size += m->star_export_entries_count * sizeof(*m->star_export_entries);\n            }\n            if (m->import_entries) {\n                s->memory_used_count += 1;\n                s->memory_used_size += m->import_entries_count * sizeof(*m->import_entries);\n            }\n            compute_value_size(m->module_ns, hp);\n            compute_value_size(m->func_obj, hp);\n        }\n    }\n\n    list_for_each(el, &rt->gc_obj_list) {\n        JSGCObjectHeader *gp = list_entry(el, JSGCObjectHeader, link);\n        JSObject *p;\n        JSShape *sh;\n        JSShapeProperty *prs;\n\n        /* XXX: could count the other GC object types too */\n        if (gp->gc_obj_type == JS_GC_OBJ_TYPE_FUNCTION_BYTECODE) {\n            compute_bytecode_size((JSFunctionBytecode *)gp, hp);\n            continue;\n        } else if (gp->gc_obj_type != JS_GC_OBJ_TYPE_JS_OBJECT) {\n            continue;\n        }\n        p = (JSObject *)gp;\n        sh = p->shape;\n        s->obj_count++;\n        if (p->prop) {\n            s->memory_used_count++;\n            s->prop_size += sh->prop_size * sizeof(*p->prop);\n            s->prop_count += sh->prop_count;\n            prs = get_shape_prop(sh);\n            for(i = 0; i < sh->prop_count; i++) {\n                JSProperty *pr = &p->prop[i];\n                if (prs->atom != JS_ATOM_NULL && !(prs->flags & JS_PROP_TMASK)) {\n                    compute_value_size(pr->u.value, hp);\n                }\n                prs++;\n            }\n        }\n        /* the hashed shapes are counted separately */\n        if (!sh->is_hashed) {\n            int hash_size = sh->prop_hash_mask + 1;\n            s->shape_count++;\n            s->shape_size += get_shape_size(hash_size, sh->prop_size);\n        }\n\n        switch(p->class_id) {\n        case JS_CLASS_ARRAY:             /* u.array | length */\n        case JS_CLASS_ARGUMENTS:         /* u.array | length */\n            s->array_count++;\n            if (p->fast_array) {\n                s->fast_array_count++;\n                if (p->u.array.u.values) {\n                    s->memory_used_count++;\n                    s->memory_used_size += p->u.array.count *\n                        sizeof(*p->u.array.u.values);\n                    s->fast_array_elements += p->u.array.count;\n                    for (i = 0; i < p->u.array.count; i++) {\n                        compute_value_size(p->u.array.u.values[i], hp);\n                    }\n                }\n            }\n            break;\n        case JS_CLASS_NUMBER:            /* u.object_data */\n        case JS_CLASS_STRING:            /* u.object_data */\n        case JS_CLASS_BOOLEAN:           /* u.object_data */\n        case JS_CLASS_SYMBOL:            /* u.object_data */\n        case JS_CLASS_DATE:              /* u.object_data */\n#ifdef CONFIG_BIGNUM\n        case JS_CLASS_BIG_INT:           /* u.object_data */\n        case JS_CLASS_BIG_FLOAT:         /* u.object_data */\n        case JS_CLASS_BIG_DECIMAL:         /* u.object_data */\n#endif\n            compute_value_size(p->u.object_data, hp);\n            break;\n        case JS_CLASS_C_FUNCTION:        /* u.cfunc */\n            s->c_func_count++;\n            break;\n        case JS_CLASS_BYTECODE_FUNCTION: /* u.func */\n            {\n                JSFunctionBytecode *b = p->u.func.function_bytecode;\n                JSVarRef **var_refs = p->u.func.var_refs;\n                /* home_object: object will be accounted for in list scan */\n                if (var_refs) {\n                    s->memory_used_count++;\n                    s->js_func_size += b->closure_var_count * sizeof(*var_refs);\n                    for (i = 0; i < b->closure_var_count; i++) {\n                        if (var_refs[i]) {\n                            double ref_count = var_refs[i]->header.ref_count;\n                            s->memory_used_count += 1 / ref_count;\n                            s->js_func_size += sizeof(*var_refs[i]) / ref_count;\n                            /* handle non object closed values */\n                            if (var_refs[i]->pvalue == &var_refs[i]->value) {\n                                /* potential multiple count */\n                                compute_value_size(var_refs[i]->value, hp);\n                            }\n                        }\n                    }\n                }\n            }\n            break;\n        case JS_CLASS_BOUND_FUNCTION:    /* u.bound_function */\n            {\n                JSBoundFunction *bf = p->u.bound_function;\n                /* func_obj and this_val are objects */\n                for (i = 0; i < bf->argc; i++) {\n                    compute_value_size(bf->argv[i], hp);\n                }\n                s->memory_used_count += 1;\n                s->memory_used_size += sizeof(*bf) + bf->argc * sizeof(*bf->argv);\n            }\n            break;\n        case JS_CLASS_C_FUNCTION_DATA:   /* u.c_function_data_record */\n            {\n                JSCFunctionDataRecord *fd = p->u.c_function_data_record;\n                if (fd) {\n                    for (i = 0; i < fd->data_len; i++) {\n                        compute_value_size(fd->data[i], hp);\n                    }\n                    s->memory_used_count += 1;\n                    s->memory_used_size += sizeof(*fd) + fd->data_len * sizeof(*fd->data);\n                }\n            }\n            break;\n        case JS_CLASS_C_CLOSURE:   /* u.c_closure_record */\n            {\n                JSCClosureRecord *c = p->u.c_closure_record;\n                if (c) {\n                    s->memory_used_count += 1;\n                    s->memory_used_size += sizeof(*c);\n                }\n            }\n            break;\n        case JS_CLASS_REGEXP:            /* u.regexp */\n            compute_jsstring_size(p->u.regexp.pattern, hp);\n            compute_jsstring_size(p->u.regexp.bytecode, hp);\n            break;\n\n        case JS_CLASS_FOR_IN_ITERATOR:   /* u.for_in_iterator */\n            {\n                JSForInIterator *it = p->u.for_in_iterator;\n                if (it) {\n                    compute_value_size(it->obj, hp);\n                    s->memory_used_count += 1;\n                    s->memory_used_size += sizeof(*it);\n                }\n            }\n            break;\n        case JS_CLASS_ARRAY_BUFFER:      /* u.array_buffer */\n        case JS_CLASS_SHARED_ARRAY_BUFFER: /* u.array_buffer */\n            {\n                JSArrayBuffer *abuf = p->u.array_buffer;\n                if (abuf) {\n                    s->memory_used_count += 1;\n                    s->memory_used_size += sizeof(*abuf);\n                    if (abuf->data) {\n                        s->memory_used_count += 1;\n                        s->memory_used_size += abuf->byte_length;\n                    }\n                }\n            }\n            break;\n        case JS_CLASS_GENERATOR:         /* u.generator_data */\n        case JS_CLASS_UINT8C_ARRAY:      /* u.typed_array / u.array */\n        case JS_CLASS_INT8_ARRAY:        /* u.typed_array / u.array */\n        case JS_CLASS_UINT8_ARRAY:       /* u.typed_array / u.array */\n        case JS_CLASS_INT16_ARRAY:       /* u.typed_array / u.array */\n        case JS_CLASS_UINT16_ARRAY:      /* u.typed_array / u.array */\n        case JS_CLASS_INT32_ARRAY:       /* u.typed_array / u.array */\n        case JS_CLASS_UINT32_ARRAY:      /* u.typed_array / u.array */\n#ifdef CONFIG_BIGNUM\n        case JS_CLASS_BIG_INT64_ARRAY:   /* u.typed_array / u.array */\n        case JS_CLASS_BIG_UINT64_ARRAY:  /* u.typed_array / u.array */\n#endif\n        case JS_CLASS_FLOAT32_ARRAY:     /* u.typed_array / u.array */\n        case JS_CLASS_FLOAT64_ARRAY:     /* u.typed_array / u.array */\n        case JS_CLASS_DATAVIEW:          /* u.typed_array */\n#ifdef CONFIG_BIGNUM\n        case JS_CLASS_FLOAT_ENV:         /* u.float_env */\n#endif\n        case JS_CLASS_MAP:               /* u.map_state */\n        case JS_CLASS_SET:               /* u.map_state */\n        case JS_CLASS_WEAKMAP:           /* u.map_state */\n        case JS_CLASS_WEAKSET:           /* u.map_state */\n        case JS_CLASS_MAP_ITERATOR:      /* u.map_iterator_data */\n        case JS_CLASS_SET_ITERATOR:      /* u.map_iterator_data */\n        case JS_CLASS_ARRAY_ITERATOR:    /* u.array_iterator_data */\n        case JS_CLASS_STRING_ITERATOR:   /* u.array_iterator_data */\n        case JS_CLASS_PROXY:             /* u.proxy_data */\n        case JS_CLASS_PROMISE:           /* u.promise_data */\n        case JS_CLASS_PROMISE_RESOLVE_FUNCTION:  /* u.promise_function_data */\n        case JS_CLASS_PROMISE_REJECT_FUNCTION:   /* u.promise_function_data */\n        case JS_CLASS_ASYNC_FUNCTION_RESOLVE:    /* u.async_function_data */\n        case JS_CLASS_ASYNC_FUNCTION_REJECT:     /* u.async_function_data */\n        case JS_CLASS_ASYNC_FROM_SYNC_ITERATOR:  /* u.async_from_sync_iterator_data */\n        case JS_CLASS_ASYNC_GENERATOR:   /* u.async_generator_data */\n            /* TODO */\n        default:\n            /* XXX: class definition should have an opaque block size */\n            if (p->u.opaque) {\n                s->memory_used_count += 1;\n            }\n            break;\n        }\n    }\n    s->obj_size += s->obj_count * sizeof(JSObject);\n\n    /* hashed shapes */\n    s->memory_used_count++; /* rt->shape_hash */\n    s->memory_used_size += sizeof(rt->shape_hash[0]) * rt->shape_hash_size;\n    for(i = 0; i < rt->shape_hash_size; i++) {\n        JSShape *sh;\n        for(sh = rt->shape_hash[i]; sh != NULL; sh = sh->shape_hash_next) {\n            int hash_size = sh->prop_hash_mask + 1;\n            s->shape_count++;\n            s->shape_size += get_shape_size(hash_size, sh->prop_size);\n        }\n    }\n\n    /* atoms */\n    s->memory_used_count += 2; /* rt->atom_array, rt->atom_hash */\n    s->atom_count = rt->atom_count;\n    s->atom_size = sizeof(rt->atom_array[0]) * rt->atom_size +\n        sizeof(rt->atom_hash[0]) * rt->atom_hash_size;\n    for(i = 0; i < rt->atom_size; i++) {\n        JSAtomStruct *p = rt->atom_array[i];\n        if (!atom_is_free(p)) {\n            s->atom_size += (sizeof(*p) + (p->len << p->is_wide_char) +\n                             1 - p->is_wide_char);\n        }\n    }\n    s->str_count = round(mem.str_count);\n    s->str_size = round(mem.str_size);\n    s->js_func_count = mem.js_func_count;\n    s->js_func_size = round(mem.js_func_size);\n    s->js_func_code_size = mem.js_func_code_size;\n    s->js_func_pc2line_count = mem.js_func_pc2line_count;\n    s->js_func_pc2line_size = mem.js_func_pc2line_size;\n    s->memory_used_count += round(mem.memory_used_count) +\n        s->atom_count + s->str_count +\n        s->obj_count + s->shape_count +\n        s->js_func_count + s->js_func_pc2line_count;\n    s->memory_used_size += s->atom_size + s->str_size +\n        s->obj_size + s->prop_size + s->shape_size +\n        s->js_func_size + s->js_func_code_size + s->js_func_pc2line_size;\n}\n\nvoid JS_DumpMemoryUsage(FILE *fp, const JSMemoryUsage *s, JSRuntime *rt)\n{\n    fprintf(fp, \"QuickJS memory usage -- \"\n#ifdef CONFIG_BIGNUM\n            \"BigNum \"\n#endif\n            CONFIG_VERSION \" version, %d-bit, malloc limit: %\"PRId64\"\\n\\n\",\n            (int)sizeof(void *) * 8, (int64_t)(ssize_t)s->malloc_limit);\n#if 1\n    if (rt) {\n        static const struct {\n            const char *name;\n            size_t size;\n        } object_types[] = {\n            { \"JSRuntime\", sizeof(JSRuntime) },\n            { \"JSContext\", sizeof(JSContext) },\n            { \"JSObject\", sizeof(JSObject) },\n            { \"JSString\", sizeof(JSString) },\n            { \"JSFunctionBytecode\", sizeof(JSFunctionBytecode) },\n        };\n        int i, usage_size_ok = 0;\n        for(i = 0; i < countof(object_types); i++) {\n            unsigned int size = object_types[i].size;\n            void *p = js_malloc_rt(rt, size);\n            if (p) {\n                unsigned int size1 = js_malloc_usable_size_rt(rt, p);\n                if (size1 >= size) {\n                    usage_size_ok = 1;\n                    fprintf(fp, \"  %3u + %-2u  %s\\n\",\n                            size, size1 - size, object_types[i].name);\n                }\n                js_free_rt(rt, p);\n            }\n        }\n        if (!usage_size_ok) {\n            fprintf(fp, \"  malloc_usable_size unavailable\\n\");\n        }\n        {\n            int obj_classes[JS_CLASS_INIT_COUNT + 1] = { 0 };\n            int class_id;\n            struct list_head *el;\n            list_for_each(el, &rt->gc_obj_list) {\n                JSGCObjectHeader *gp = list_entry(el, JSGCObjectHeader, link);\n                JSObject *p;\n                if (gp->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT) {\n                    p = (JSObject *)gp;\n                    obj_classes[min_uint32(p->class_id, JS_CLASS_INIT_COUNT)]++;\n                }\n            }\n            fprintf(fp, \"\\n\" \"JSObject classes\\n\");\n            if (obj_classes[0])\n                fprintf(fp, \"  %5d  %2.0d %s\\n\", obj_classes[0], 0, \"none\");\n            for (class_id = 1; class_id < JS_CLASS_INIT_COUNT; class_id++) {\n                if (obj_classes[class_id]) {\n                    char buf[ATOM_GET_STR_BUF_SIZE];\n                    fprintf(fp, \"  %5d  %2.0d %s\\n\", obj_classes[class_id], class_id,\n                            JS_AtomGetStrRT(rt, buf, sizeof(buf), js_std_class_def[class_id - 1].class_name));\n                }\n            }\n            if (obj_classes[JS_CLASS_INIT_COUNT])\n                fprintf(fp, \"  %5d  %2.0d %s\\n\", obj_classes[JS_CLASS_INIT_COUNT], 0, \"other\");\n        }\n        fprintf(fp, \"\\n\");\n    }\n#endif\n    fprintf(fp, \"%-20s %8s %8s\\n\", \"NAME\", \"COUNT\", \"SIZE\");\n\n    if (s->malloc_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per block)\\n\",\n                \"memory allocated\", s->malloc_count, s->malloc_size,\n                (double)s->malloc_size / s->malloc_count);\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%d overhead, %0.1f average slack)\\n\",\n                \"memory used\", s->memory_used_count, s->memory_used_size,\n                MALLOC_OVERHEAD, ((double)(s->malloc_size - s->memory_used_size) /\n                                  s->memory_used_count));\n    }\n    if (s->atom_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per atom)\\n\",\n                \"atoms\", s->atom_count, s->atom_size,\n                (double)s->atom_size / s->atom_count);\n    }\n    if (s->str_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per string)\\n\",\n                \"strings\", s->str_count, s->str_size,\n                (double)s->str_size / s->str_count);\n    }\n    if (s->obj_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per object)\\n\",\n                \"objects\", s->obj_count, s->obj_size,\n                (double)s->obj_size / s->obj_count);\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per object)\\n\",\n                \"  properties\", s->prop_count, s->prop_size,\n                (double)s->prop_count / s->obj_count);\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per shape)\\n\",\n                \"  shapes\", s->shape_count, s->shape_size,\n                (double)s->shape_size / s->shape_count);\n    }\n    if (s->js_func_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"\\n\",\n                \"bytecode functions\", s->js_func_count, s->js_func_size);\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per function)\\n\",\n                \"  bytecode\", s->js_func_count, s->js_func_code_size,\n                (double)s->js_func_code_size / s->js_func_count);\n        if (s->js_func_pc2line_count) {\n            fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per function)\\n\",\n                    \"  pc2line\", s->js_func_pc2line_count,\n                    s->js_func_pc2line_size,\n                    (double)s->js_func_pc2line_size / s->js_func_pc2line_count);\n        }\n    }\n    if (s->c_func_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\"\\n\", \"C functions\", s->c_func_count);\n    }\n    if (s->array_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\"\\n\", \"arrays\", s->array_count);\n        if (s->fast_array_count) {\n            fprintf(fp, \"%-20s %8\"PRId64\"\\n\", \"  fast arrays\", s->fast_array_count);\n            fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per fast array)\\n\",\n                    \"  elements\", s->fast_array_elements,\n                    s->fast_array_elements * (int)sizeof(JSValue),\n                    (double)s->fast_array_elements / s->fast_array_count);\n        }\n    }\n    if (s->binary_object_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"\\n\",\n                \"binary objects\", s->binary_object_count, s->binary_object_size);\n    }\n}\n\nJSValue JS_GetGlobalObject(JSContext *ctx)\n{\n    return JS_DupValue(ctx, ctx->global_obj);\n}\n\n/* WARNING: obj is freed */\nJSValue JS_Throw(JSContext *ctx, JSValue obj)\n{\n    JSRuntime *rt = ctx->rt;\n    JS_FreeValue(ctx, rt->current_exception);\n    rt->current_exception = obj;\n#ifdef CONFIG_DEBUGGER\n    js_debugger_exception(ctx);\n#endif\n    return JS_EXCEPTION;\n}\n\n/* return the pending exception (cannot be called twice). */\nJSValue JS_GetException(JSContext *ctx)\n{\n    JSValue val;\n    JSRuntime *rt = ctx->rt;\n    val = rt->current_exception;\n    rt->current_exception = JS_NULL;\n    return val;\n}\n\nstatic void dbuf_put_leb128(DynBuf *s, uint32_t v)\n{\n    uint32_t a;\n    for(;;) {\n        a = v & 0x7f;\n        v >>= 7;\n        if (v != 0) {\n            dbuf_putc(s, a | 0x80);\n        } else {\n            dbuf_putc(s, a);\n            break;\n        }\n    }\n}\n\nstatic void dbuf_put_sleb128(DynBuf *s, int32_t v1)\n{\n    uint32_t v = v1;\n    dbuf_put_leb128(s, (2 * v) ^ -(v >> 31));\n}\n\nstatic int get_leb128(uint32_t *pval, const uint8_t *buf,\n                      const uint8_t *buf_end)\n{\n    const uint8_t *ptr = buf;\n    uint32_t v, a, i;\n    v = 0;\n    for(i = 0; i < 5; i++) {\n        if (unlikely(ptr >= buf_end))\n            break;\n        a = *ptr++;\n        v |= (a & 0x7f) << (i * 7);\n        if (!(a & 0x80)) {\n            *pval = v;\n            return ptr - buf;\n        }\n    }\n    *pval = 0;\n    return -1;\n}\n\nstatic int get_sleb128(int32_t *pval, const uint8_t *buf,\n                       const uint8_t *buf_end)\n{\n    int ret;\n    uint32_t val;\n    ret = get_leb128(&val, buf, buf_end);\n    if (ret < 0) {\n        *pval = 0;\n        return -1;\n    }\n    *pval = (val >> 1) ^ -(val & 1);\n    return ret;\n}\n\nstatic int find_line_num(JSContext *ctx, JSFunctionBytecode *b,\n                         uint32_t pc_value)\n{\n    const uint8_t *p_end, *p;\n    int new_line_num, line_num, pc, v, ret;\n    unsigned int op;\n\n    if (!b->has_debug || !b->debug.pc2line_buf) {\n        /* function was stripped */\n        return -1;\n    }\n\n    p = b->debug.pc2line_buf;\n    p_end = p + b->debug.pc2line_len;\n    pc = 0;\n    line_num = b->debug.line_num;\n    while (p < p_end) {\n        op = *p++;\n        if (op == 0) {\n            uint32_t val;\n            ret = get_leb128(&val, p, p_end);\n            if (ret < 0)\n                goto fail;\n            pc += val;\n            p += ret;\n            ret = get_sleb128(&v, p, p_end);\n            if (ret < 0) {\n            fail:\n                /* should never happen */\n                return b->debug.line_num;\n            }\n            p += ret;\n            new_line_num = line_num + v;\n        } else {\n            op -= PC2LINE_OP_FIRST;\n            pc += (op / PC2LINE_RANGE);\n            new_line_num = line_num + (op % PC2LINE_RANGE) + PC2LINE_BASE;\n        }\n        if (pc_value < pc)\n            return line_num;\n        line_num = new_line_num;\n    }\n    return line_num;\n}\n\n/* in order to avoid executing arbitrary code during the stack trace\n   generation, we only look at simple 'name' properties containing a\n   string. */\nstatic const char *get_func_name(JSContext *ctx, JSValueConst func)\n{\n    JSProperty *pr;\n    JSShapeProperty *prs;\n    JSValueConst val;\n    \n    if (JS_VALUE_GET_TAG(func) != JS_TAG_OBJECT)\n        return NULL;\n    prs = find_own_property(&pr, JS_VALUE_GET_OBJ(func), JS_ATOM_name);\n    if (!prs)\n        return NULL;\n    if ((prs->flags & JS_PROP_TMASK) != JS_PROP_NORMAL)\n        return NULL;\n    val = pr->u.value;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_STRING)\n        return NULL;\n    return JS_ToCString(ctx, val);\n}\n\n#define JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL (1 << 0)\n/* only taken into account if filename is provided */\n#define JS_BACKTRACE_FLAG_SINGLE_LEVEL     (1 << 1)\n\n/* if filename != NULL, an additional level is added with the filename\n   and line number information (used for parse error). */\nstatic void build_backtrace(JSContext *ctx, JSValueConst error_obj,\n                            const char *filename, int line_num,\n                            int backtrace_flags)\n{\n    JSStackFrame *sf;\n    JSValue str;\n    DynBuf dbuf;\n    const char *func_name_str;\n    const char *str1;\n    JSObject *p;\n    BOOL backtrace_barrier;\n    \n    js_dbuf_init(ctx, &dbuf);\n    if (filename) {\n        dbuf_printf(&dbuf, \"    at %s\", filename);\n        if (line_num != -1)\n            dbuf_printf(&dbuf, \":%d\", line_num);\n        dbuf_putc(&dbuf, '\\n');\n        str = JS_NewString(ctx, filename);\n        JS_DefinePropertyValue(ctx, error_obj, JS_ATOM_fileName, str,\n                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n        JS_DefinePropertyValue(ctx, error_obj, JS_ATOM_lineNumber, JS_NewInt32(ctx, line_num),\n                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n        if (backtrace_flags & JS_BACKTRACE_FLAG_SINGLE_LEVEL)\n            goto done;\n    }\n    for(sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {\n        if (backtrace_flags & JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL) {\n            backtrace_flags &= ~JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL;\n            continue;\n        }\n        func_name_str = get_func_name(ctx, sf->cur_func);\n        if (!func_name_str || func_name_str[0] == '\\0')\n            str1 = \"<anonymous>\";\n        else\n            str1 = func_name_str;\n        dbuf_printf(&dbuf, \"    at %s\", str1);\n        JS_FreeCString(ctx, func_name_str);\n\n        p = JS_VALUE_GET_OBJ(sf->cur_func);\n        backtrace_barrier = FALSE;\n        if (js_class_has_bytecode(p->class_id)) {\n            JSFunctionBytecode *b;\n            const char *atom_str;\n            int line_num1;\n\n            b = p->u.func.function_bytecode;\n            backtrace_barrier = b->backtrace_barrier;\n            if (b->has_debug) {\n                line_num1 = find_line_num(ctx, b,\n                                          sf->cur_pc - b->byte_code_buf - 1);\n                atom_str = JS_AtomToCString(ctx, b->debug.filename);\n                dbuf_printf(&dbuf, \" (%s\",\n                            atom_str ? atom_str : \"<null>\");\n                JS_FreeCString(ctx, atom_str);\n                if (line_num1 != -1)\n                    dbuf_printf(&dbuf, \":%d\", line_num1);\n                dbuf_putc(&dbuf, ')');\n            }\n        } else {\n            dbuf_printf(&dbuf, \" (native)\");\n        }\n        dbuf_putc(&dbuf, '\\n');\n        /* stop backtrace if JS_EVAL_FLAG_BACKTRACE_BARRIER was used */\n        if (backtrace_barrier)\n            break;\n    }\n done:\n    dbuf_putc(&dbuf, '\\0');\n    if (dbuf_error(&dbuf))\n        str = JS_NULL;\n    else\n        str = JS_NewString(ctx, (char *)dbuf.buf);\n    dbuf_free(&dbuf);\n    JS_DefinePropertyValue(ctx, error_obj, JS_ATOM_stack, str,\n                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n}\n\n/* Note: it is important that no exception is returned by this function */\nstatic BOOL is_backtrace_needed(JSContext *ctx, JSValueConst obj)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(obj);\n    if (p->class_id != JS_CLASS_ERROR)\n        return FALSE;\n    if (find_own_property1(p, JS_ATOM_stack))\n        return FALSE;\n    return TRUE;\n}\n\nJSValue JS_NewError(JSContext *ctx)\n{\n    return JS_NewObjectClass(ctx, JS_CLASS_ERROR);\n}\n\nstatic JSValue JS_ThrowError2(JSContext *ctx, JSErrorEnum error_num,\n                              const char *fmt, va_list ap, BOOL add_backtrace)\n{\n    char buf[256];\n    JSValue obj, ret;\n\n    vsnprintf(buf, sizeof(buf), fmt, ap);\n    obj = JS_NewObjectProtoClass(ctx, ctx->native_error_proto[error_num],\n                                 JS_CLASS_ERROR);\n    if (unlikely(JS_IsException(obj))) {\n        /* out of memory: throw JS_NULL to avoid recursing */\n        obj = JS_NULL;\n    } else {\n        JS_DefinePropertyValue(ctx, obj, JS_ATOM_message,\n                               JS_NewString(ctx, buf),\n                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    }\n    if (add_backtrace) {\n        build_backtrace(ctx, obj, NULL, 0, 0);\n    }\n    ret = JS_Throw(ctx, obj);\n    return ret;\n}\n\nstatic JSValue JS_ThrowError(JSContext *ctx, JSErrorEnum error_num,\n                             const char *fmt, va_list ap)\n{\n    JSRuntime *rt = ctx->rt;\n    JSStackFrame *sf;\n    BOOL add_backtrace;\n\n    /* the backtrace is added later if called from a bytecode function */\n    sf = rt->current_stack_frame;\n    add_backtrace = !rt->in_out_of_memory &&\n        (!sf || (JS_GetFunctionBytecode(sf->cur_func) == NULL));\n    return JS_ThrowError2(ctx, error_num, fmt, ap, add_backtrace);\n}\n\nJSValue __attribute__((format(printf, 2, 3))) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...)\n{\n    JSValue val;\n    va_list ap;\n\n    va_start(ap, fmt);\n    val = JS_ThrowError(ctx, JS_SYNTAX_ERROR, fmt, ap);\n    va_end(ap);\n    return val;\n}\n\nJSValue __attribute__((format(printf, 2, 3))) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...)\n{\n    JSValue val;\n    va_list ap;\n\n    va_start(ap, fmt);\n    val = JS_ThrowError(ctx, JS_TYPE_ERROR, fmt, ap);\n    va_end(ap);\n    return val;\n}\n\nstatic int __attribute__((format(printf, 3, 4))) JS_ThrowTypeErrorOrFalse(JSContext *ctx, int flags, const char *fmt, ...)\n{\n    va_list ap;\n\n    if ((flags & JS_PROP_THROW) ||\n        ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {\n        va_start(ap, fmt);\n        JS_ThrowError(ctx, JS_TYPE_ERROR, fmt, ap);\n        va_end(ap);\n        return -1;\n    } else {\n        return FALSE;\n    }\n}\n\n/* never use it directly */\nstatic JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowTypeErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)\n{\n    char buf[ATOM_GET_STR_BUF_SIZE];\n    return JS_ThrowTypeError(ctx, fmt,\n                             JS_AtomGetStr(ctx, buf, sizeof(buf), atom));\n}\n\n/* never use it directly */\nstatic JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowSyntaxErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)\n{\n    char buf[ATOM_GET_STR_BUF_SIZE];\n    return JS_ThrowSyntaxError(ctx, fmt,\n                             JS_AtomGetStr(ctx, buf, sizeof(buf), atom));\n}\n\n/* %s is replaced by 'atom'. The macro is used so that gcc can check\n    the format string. */\n#define JS_ThrowTypeErrorAtom(ctx, fmt, atom) __JS_ThrowTypeErrorAtom(ctx, atom, fmt, \"\")\n#define JS_ThrowSyntaxErrorAtom(ctx, fmt, atom) __JS_ThrowSyntaxErrorAtom(ctx, atom, fmt, \"\")\n\nstatic int JS_ThrowTypeErrorReadOnly(JSContext *ctx, int flags, JSAtom atom)\n{\n    if ((flags & JS_PROP_THROW) ||\n        ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {\n        JS_ThrowTypeErrorAtom(ctx, \"'%s' is read-only\", atom);\n        return -1;\n    } else {\n        return FALSE;\n    }\n}\n\nJSValue __attribute__((format(printf, 2, 3))) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...)\n{\n    JSValue val;\n    va_list ap;\n\n    va_start(ap, fmt);\n    val = JS_ThrowError(ctx, JS_REFERENCE_ERROR, fmt, ap);\n    va_end(ap);\n    return val;\n}\n\nJSValue __attribute__((format(printf, 2, 3))) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...)\n{\n    JSValue val;\n    va_list ap;\n\n    va_start(ap, fmt);\n    val = JS_ThrowError(ctx, JS_RANGE_ERROR, fmt, ap);\n    va_end(ap);\n    return val;\n}\n\nJSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...)\n{\n    JSValue val;\n    va_list ap;\n\n    va_start(ap, fmt);\n    val = JS_ThrowError(ctx, JS_INTERNAL_ERROR, fmt, ap);\n    va_end(ap);\n    return val;\n}\n\nJSValue JS_ThrowOutOfMemory(JSContext *ctx)\n{\n    JSRuntime *rt = ctx->rt;\n    if (!rt->in_out_of_memory) {\n        rt->in_out_of_memory = TRUE;\n        JS_ThrowInternalError(ctx, \"out of memory\");\n        rt->in_out_of_memory = FALSE;\n    }\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ThrowStackOverflow(JSContext *ctx)\n{\n    return JS_ThrowInternalError(ctx, \"stack overflow\");\n}\n\nstatic JSValue JS_ThrowTypeErrorNotAnObject(JSContext *ctx)\n{\n    return JS_ThrowTypeError(ctx, \"not an object\");\n}\n\nstatic JSValue JS_ThrowTypeErrorNotASymbol(JSContext *ctx)\n{\n    return JS_ThrowTypeError(ctx, \"not a symbol\");\n}\n\nstatic JSValue JS_ThrowReferenceErrorNotDefined(JSContext *ctx, JSAtom name)\n{\n    char buf[ATOM_GET_STR_BUF_SIZE];\n    return JS_ThrowReferenceError(ctx, \"'%s' is not defined\",\n                                  JS_AtomGetStr(ctx, buf, sizeof(buf), name));\n}\n\nstatic JSValue JS_ThrowReferenceErrorUninitialized(JSContext *ctx, JSAtom name)\n{\n    char buf[ATOM_GET_STR_BUF_SIZE];\n    return JS_ThrowReferenceError(ctx, \"%s is not initialized\",\n                                  name == JS_ATOM_NULL ? \"lexical variable\" :\n                                  JS_AtomGetStr(ctx, buf, sizeof(buf), name));\n}\n\nstatic JSValue JS_ThrowReferenceErrorUninitialized2(JSContext *ctx,\n                                                    JSFunctionBytecode *b,\n                                                    int idx, BOOL is_ref)\n{\n    JSAtom atom = JS_ATOM_NULL;\n    if (is_ref) {\n        atom = b->closure_var[idx].var_name;\n    } else {\n        /* not present if the function is stripped and contains no eval() */\n        if (b->vardefs)\n            atom = b->vardefs[b->arg_count + idx].var_name;\n    }\n    return JS_ThrowReferenceErrorUninitialized(ctx, atom);\n}\n\nstatic JSValue JS_ThrowTypeErrorInvalidClass(JSContext *ctx, int class_id)\n{\n    JSRuntime *rt = ctx->rt;\n    JSAtom name;\n    name = rt->class_array[class_id].class_name;\n    return JS_ThrowTypeErrorAtom(ctx, \"%s object expected\", name);\n}\n\nstatic no_inline __exception int __js_poll_interrupts(JSContext *ctx)\n{\n    JSRuntime *rt = ctx->rt;\n    ctx->interrupt_counter = JS_INTERRUPT_COUNTER_INIT;\n    if (rt->interrupt_handler) {\n        if (rt->interrupt_handler(rt, rt->interrupt_opaque)) {\n            /* XXX: should set a specific flag to avoid catching */\n            JS_ThrowInternalError(ctx, \"interrupted\");\n            JS_SetUncatchableError(ctx, ctx->rt->current_exception, TRUE);\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic inline __exception int js_poll_interrupts(JSContext *ctx)\n{\n    if (unlikely(--ctx->interrupt_counter <= 0)) {\n        return __js_poll_interrupts(ctx);\n    } else {\n        return 0;\n    }\n}\n\n/* return -1 (exception) or TRUE/FALSE */\nstatic int JS_SetPrototypeInternal(JSContext *ctx, JSValueConst obj,\n                                   JSValueConst proto_val,\n                                   BOOL throw_flag)\n{\n    JSObject *proto, *p, *p1;\n    JSShape *sh;\n\n    if (throw_flag) {\n        if (JS_VALUE_GET_TAG(obj) == JS_TAG_NULL ||\n            JS_VALUE_GET_TAG(obj) == JS_TAG_UNDEFINED)\n            goto not_obj;\n    } else {\n        if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n            goto not_obj;\n    }\n    p = JS_VALUE_GET_OBJ(obj);\n    if (JS_VALUE_GET_TAG(proto_val) != JS_TAG_OBJECT) {\n        if (JS_VALUE_GET_TAG(proto_val) != JS_TAG_NULL) {\n        not_obj:\n            JS_ThrowTypeErrorNotAnObject(ctx);\n            return -1;\n        }\n        proto = NULL;\n    } else {\n        proto = JS_VALUE_GET_OBJ(proto_val);\n    }\n\n    if (throw_flag && JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return TRUE;\n\n    if (unlikely(p->class_id == JS_CLASS_PROXY))\n        return js_proxy_setPrototypeOf(ctx, obj, proto_val, throw_flag);\n    sh = p->shape;\n    if (sh->proto == proto)\n        return TRUE;\n    if (!p->extensible) {\n        if (throw_flag) {\n            JS_ThrowTypeError(ctx, \"object is not extensible\");\n            return -1;\n        } else {\n            return FALSE;\n        }\n    }\n    if (proto) {\n        /* check if there is a cycle */\n        p1 = proto;\n        do {\n            if (p1 == p) {\n                if (throw_flag) {\n                    JS_ThrowTypeError(ctx, \"circular prototype chain\");\n                    return -1;\n                } else {\n                    return FALSE;\n                }\n            }\n            /* Note: for Proxy objects, proto is NULL */\n            p1 = p1->shape->proto;\n        } while (p1 != NULL);\n        JS_DupValue(ctx, proto_val);\n    }\n\n    if (js_shape_prepare_update(ctx, p, NULL))\n        return -1;\n    sh = p->shape;\n    if (sh->proto)\n        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, sh->proto));\n    sh->proto = proto;\n    return TRUE;\n}\n\n/* return -1 (exception) or TRUE/FALSE */\nint JS_SetPrototype(JSContext *ctx, JSValueConst obj, JSValueConst proto_val)\n{\n    return JS_SetPrototypeInternal(ctx, obj, proto_val, TRUE);\n}\n\n/* Only works for primitive types, otherwise return JS_NULL. */\nstatic JSValueConst JS_GetPrototypePrimitive(JSContext *ctx, JSValueConst val)\n{\n    switch(JS_VALUE_GET_NORM_TAG(val)) {\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n        val = ctx->class_proto[JS_CLASS_BIG_INT];\n        break;\n    case JS_TAG_BIG_FLOAT:\n        val = ctx->class_proto[JS_CLASS_BIG_FLOAT];\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        val = ctx->class_proto[JS_CLASS_BIG_DECIMAL];\n        break;\n#endif\n    case JS_TAG_INT:\n    case JS_TAG_FLOAT64:\n        val = ctx->class_proto[JS_CLASS_NUMBER];\n        break;\n    case JS_TAG_BOOL:\n        val = ctx->class_proto[JS_CLASS_BOOLEAN];\n        break;\n    case JS_TAG_STRING:\n        val = ctx->class_proto[JS_CLASS_STRING];\n        break;\n    case JS_TAG_SYMBOL:\n        val = ctx->class_proto[JS_CLASS_SYMBOL];\n        break;\n    case JS_TAG_OBJECT:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n    default:\n        val = JS_NULL;\n        break;\n    }\n    return val;\n}\n\n/* Return an Object, JS_NULL or JS_EXCEPTION in case of Proxy object. */\nJSValue JS_GetPrototype(JSContext *ctx, JSValueConst obj)\n{\n    JSValue val;\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        JSObject *p;\n        p = JS_VALUE_GET_OBJ(obj);\n        if (unlikely(p->class_id == JS_CLASS_PROXY)) {\n            val = js_proxy_getPrototypeOf(ctx, obj);\n        } else {\n            p = p->shape->proto;\n            if (!p)\n                val = JS_NULL;\n            else\n                val = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n        }\n    } else {\n        val = JS_DupValue(ctx, JS_GetPrototypePrimitive(ctx, obj));\n    }\n    return val;\n}\n\nstatic JSValue JS_GetPrototypeFree(JSContext *ctx, JSValue obj)\n{\n    JSValue obj1;\n    obj1 = JS_GetPrototype(ctx, obj);\n    JS_FreeValue(ctx, obj);\n    return obj1;\n}\n\n/* return TRUE, FALSE or (-1) in case of exception */\nstatic int JS_OrdinaryIsInstanceOf(JSContext *ctx, JSValueConst val,\n                                   JSValueConst obj)\n{\n    JSValue obj_proto;\n    JSObject *proto;\n    const JSObject *p, *proto1;\n    BOOL ret;\n\n    if (!JS_IsFunction(ctx, obj))\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(obj);\n    if (p->class_id == JS_CLASS_BOUND_FUNCTION) {\n        JSBoundFunction *s = p->u.bound_function;\n        return JS_IsInstanceOf(ctx, val, s->func_obj);\n    }\n\n    /* Only explicitly boxed values are instances of constructors */\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return FALSE;\n    obj_proto = JS_GetProperty(ctx, obj, JS_ATOM_prototype);\n    if (JS_VALUE_GET_TAG(obj_proto) != JS_TAG_OBJECT) {\n        if (!JS_IsException(obj_proto))\n            JS_ThrowTypeError(ctx, \"operand 'prototype' property is not an object\");\n        ret = -1;\n        goto done;\n    }\n    proto = JS_VALUE_GET_OBJ(obj_proto);\n    p = JS_VALUE_GET_OBJ(val);\n    for(;;) {\n        proto1 = p->shape->proto;\n        if (!proto1) {\n            /* slow case if proxy in the prototype chain */\n            if (unlikely(p->class_id == JS_CLASS_PROXY)) {\n                JSValue obj1;\n                obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, (JSObject *)p));\n                for(;;) {\n                    obj1 = JS_GetPrototypeFree(ctx, obj1);\n                    if (JS_IsException(obj1)) {\n                        ret = -1;\n                        break;\n                    }\n                    if (JS_IsNull(obj1)) {\n                        ret = FALSE;\n                        break;\n                    }\n                    if (proto == JS_VALUE_GET_OBJ(obj1)) {\n                        JS_FreeValue(ctx, obj1);\n                        ret = TRUE;\n                        break;\n                    }\n                    /* must check for timeout to avoid infinite loop */\n                    if (js_poll_interrupts(ctx)) {\n                        JS_FreeValue(ctx, obj1);\n                        ret = -1;\n                        break;\n                    }\n                }\n            } else {\n                ret = FALSE;\n            }\n            break;\n        }\n        p = proto1;\n        if (proto == p) {\n            ret = TRUE;\n            break;\n        }\n    }\ndone:\n    JS_FreeValue(ctx, obj_proto);\n    return ret;\n}\n\n/* return TRUE, FALSE or (-1) in case of exception */\nint JS_IsInstanceOf(JSContext *ctx, JSValueConst val, JSValueConst obj)\n{\n    JSValue method;\n\n    if (!JS_IsObject(obj))\n        goto fail;\n    method = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_hasInstance);\n    if (JS_IsException(method))\n        return -1;\n    if (!JS_IsNull(method) && !JS_IsUndefined(method)) {\n        JSValue ret;\n        ret = JS_CallFree(ctx, method, obj, 1, &val);\n        return JS_ToBoolFree(ctx, ret);\n    }\n\n    /* legacy case */\n    if (!JS_IsFunction(ctx, obj)) {\n    fail:\n        JS_ThrowTypeError(ctx, \"invalid 'instanceof' right operand\");\n        return -1;\n    }\n    return JS_OrdinaryIsInstanceOf(ctx, val, obj);\n}\n\n/* return the value associated to the autoinit property or an exception */\ntypedef JSValue JSAutoInitFunc(JSContext *ctx, JSObject *p, JSAtom atom, void *opaque);\n\nstatic JSAutoInitFunc *js_autoinit_func_table[] = {\n    js_instantiate_prototype, /* JS_AUTOINIT_ID_PROTOTYPE */\n    js_module_ns_autoinit, /* JS_AUTOINIT_ID_MODULE_NS */\n    JS_InstantiateFunctionListItem2, /* JS_AUTOINIT_ID_PROP */\n};\n\n/* warning: 'prs' is reallocated after it */\nstatic int JS_AutoInitProperty(JSContext *ctx, JSObject *p, JSAtom prop,\n                               JSProperty *pr, JSShapeProperty *prs)\n{\n    JSValue val;\n    JSContext *realm;\n    JSAutoInitFunc *func;\n\n    if (js_shape_prepare_update(ctx, p, &prs))\n        return -1;\n\n    realm = js_autoinit_get_realm(pr);\n    func = js_autoinit_func_table[js_autoinit_get_id(pr)];\n    /* 'func' shall not modify the object properties 'pr' */\n    val = func(realm, p, prop, pr->u.init.opaque);\n    js_autoinit_free(ctx->rt, pr);\n    prs->flags &= ~JS_PROP_TMASK;\n    pr->u.value = JS_UNDEFINED;\n    if (JS_IsException(val))\n        return -1;\n    pr->u.value = val;\n    return 0;\n}\n\nJSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,\n                               JSAtom prop, JSValueConst this_obj,\n                               BOOL throw_ref_error)\n{\n    JSObject *p;\n    JSProperty *pr;\n    JSShapeProperty *prs;\n    uint32_t tag;\n\n    tag = JS_VALUE_GET_TAG(obj);\n    if (unlikely(tag != JS_TAG_OBJECT)) {\n        switch(tag) {\n        case JS_TAG_NULL:\n            return JS_ThrowTypeErrorAtom(ctx, \"cannot read property '%s' of null\", prop);\n        case JS_TAG_UNDEFINED:\n            return JS_ThrowTypeErrorAtom(ctx, \"cannot read property '%s' of undefined\", prop);\n        case JS_TAG_EXCEPTION:\n            return JS_EXCEPTION;\n        case JS_TAG_STRING:\n            {\n                JSString *p1 = JS_VALUE_GET_STRING(obj);\n                if (__JS_AtomIsTaggedInt(prop)) {\n                    uint32_t idx, ch;\n                    idx = __JS_AtomToUInt32(prop);\n                    if (idx < p1->len) {\n                        if (p1->is_wide_char)\n                            ch = p1->u.str16[idx];\n                        else\n                            ch = p1->u.str8[idx];\n                        return js_new_string_char(ctx, ch);\n                    }\n                } else if (prop == JS_ATOM_length) {\n                    return JS_NewInt32(ctx, p1->len);\n                }\n            }\n            break;\n        default:\n            break;\n        }\n        /* cannot raise an exception */\n        p = JS_VALUE_GET_OBJ(JS_GetPrototypePrimitive(ctx, obj));\n        if (!p)\n            return JS_UNDEFINED;\n    } else {\n        p = JS_VALUE_GET_OBJ(obj);\n    }\n\n    for(;;) {\n        prs = find_own_property(&pr, p, prop);\n        if (prs) {\n            /* found */\n            if (unlikely(prs->flags & JS_PROP_TMASK)) {\n                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n                    if (unlikely(!pr->u.getset.getter)) {\n                        return JS_UNDEFINED;\n                    } else {\n                        JSValue func = JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter);\n                        /* Note: the field could be removed in the getter */\n                        func = JS_DupValue(ctx, func);\n                        return JS_CallFree(ctx, func, this_obj, 0, NULL);\n                    }\n                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n                    JSValue val = *pr->u.var_ref->pvalue;\n                    if (unlikely(JS_IsUninitialized(val)))\n                        return JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);\n                    return JS_DupValue(ctx, val);\n                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n                    /* Instantiate property and retry */\n                    if (JS_AutoInitProperty(ctx, p, prop, pr, prs))\n                        return JS_EXCEPTION;\n                    continue;\n                }\n            } else {\n                return JS_DupValue(ctx, pr->u.value);\n            }\n        }\n        if (unlikely(p->is_exotic)) {\n            /* exotic behaviors */\n            if (p->fast_array) {\n                if (__JS_AtomIsTaggedInt(prop)) {\n                    uint32_t idx = __JS_AtomToUInt32(prop);\n                    if (idx < p->u.array.count) {\n                        /* we avoid duplicating the code */\n                        return JS_GetPropertyUint32(ctx, JS_MKPTR(JS_TAG_OBJECT, p), idx);\n                    } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n                               p->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n                        return JS_UNDEFINED;\n                    }\n                } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n                           p->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n                    int ret;\n                    ret = JS_AtomIsNumericIndex(ctx, prop);\n                    if (ret != 0) {\n                        if (ret < 0)\n                            return JS_EXCEPTION;\n                        return JS_UNDEFINED;\n                    }\n                }\n            } else {\n                const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n                if (em) {\n                    if (em->get_property) {\n                        JSValue obj1, retval;\n                        /* XXX: should pass throw_ref_error */\n                        /* Note: if 'p' is a prototype, it can be\n                           freed in the called function */\n                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n                        retval = em->get_property(ctx, obj1, prop, this_obj);\n                        JS_FreeValue(ctx, obj1);\n                        return retval;\n                    }\n                    if (em->get_own_property) {\n                        JSPropertyDescriptor desc;\n                        int ret;\n                        JSValue obj1;\n\n                        /* Note: if 'p' is a prototype, it can be\n                           freed in the called function */\n                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n                        ret = em->get_own_property(ctx, &desc, obj1, prop);\n                        JS_FreeValue(ctx, obj1);\n                        if (ret < 0)\n                            return JS_EXCEPTION;\n                        if (ret) {\n                            if (desc.flags & JS_PROP_GETSET) {\n                                JS_FreeValue(ctx, desc.setter);\n                                return JS_CallFree(ctx, desc.getter, this_obj, 0, NULL);\n                            } else {\n                                return desc.value;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        p = p->shape->proto;\n        if (!p)\n            break;\n    }\n    if (unlikely(throw_ref_error)) {\n        return JS_ThrowReferenceErrorNotDefined(ctx, prop);\n    } else {\n        return JS_UNDEFINED;\n    }\n}\n\nstatic JSValue JS_ThrowTypeErrorPrivateNotFound(JSContext *ctx, JSAtom atom)\n{\n    return JS_ThrowTypeErrorAtom(ctx, \"private class field '%s' does not exist\",\n                                 atom);\n}\n\n/* Private fields can be added even on non extensible objects or\n   Proxies */\nstatic int JS_DefinePrivateField(JSContext *ctx, JSValueConst obj,\n                                 JSValueConst name, JSValue val)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    JSAtom prop;\n\n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        goto fail;\n    }\n    /* safety check */\n    if (unlikely(JS_VALUE_GET_TAG(name) != JS_TAG_SYMBOL)) {\n        JS_ThrowTypeErrorNotASymbol(ctx);\n        goto fail;\n    }\n    prop = js_symbol_to_atom(ctx, (JSValue)name);\n    p = JS_VALUE_GET_OBJ(obj);\n    prs = find_own_property(&pr, p, prop);\n    if (prs) {\n        JS_ThrowTypeErrorAtom(ctx, \"private class field '%s' already exists\",\n                              prop);\n        goto fail;\n    }\n    pr = add_property(ctx, p, prop, JS_PROP_C_W_E);\n    if (unlikely(!pr)) {\n    fail:\n        JS_FreeValue(ctx, val);\n        return -1;\n    }\n    pr->u.value = val;\n    return 0;\n}\n\nstatic JSValue JS_GetPrivateField(JSContext *ctx, JSValueConst obj,\n                                  JSValueConst name)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    JSAtom prop;\n\n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    /* safety check */\n    if (unlikely(JS_VALUE_GET_TAG(name) != JS_TAG_SYMBOL))\n        return JS_ThrowTypeErrorNotASymbol(ctx);\n    prop = js_symbol_to_atom(ctx, (JSValue)name);\n    p = JS_VALUE_GET_OBJ(obj);\n    prs = find_own_property(&pr, p, prop);\n    if (!prs) {\n        JS_ThrowTypeErrorPrivateNotFound(ctx, prop);\n        return JS_EXCEPTION;\n    }\n    return JS_DupValue(ctx, pr->u.value);\n}\n\nstatic int JS_SetPrivateField(JSContext *ctx, JSValueConst obj,\n                              JSValueConst name, JSValue val)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    JSAtom prop;\n\n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        goto fail;\n    }\n    /* safety check */\n    if (unlikely(JS_VALUE_GET_TAG(name) != JS_TAG_SYMBOL)) {\n        JS_ThrowTypeErrorNotASymbol(ctx);\n        goto fail;\n    }\n    prop = js_symbol_to_atom(ctx, (JSValue)name);\n    p = JS_VALUE_GET_OBJ(obj);\n    prs = find_own_property(&pr, p, prop);\n    if (!prs) {\n        JS_ThrowTypeErrorPrivateNotFound(ctx, prop);\n    fail:\n        JS_FreeValue(ctx, val);\n        return -1;\n    }\n    set_value(ctx, &pr->u.value, val);\n    return 0;\n}\n\nstatic int JS_AddBrand(JSContext *ctx, JSValueConst obj, JSValueConst home_obj)\n{\n    JSObject *p, *p1;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    JSValue brand;\n    JSAtom brand_atom;\n    \n    if (unlikely(JS_VALUE_GET_TAG(home_obj) != JS_TAG_OBJECT)) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        return -1;\n    }\n    p = JS_VALUE_GET_OBJ(home_obj);\n    prs = find_own_property(&pr, p, JS_ATOM_Private_brand);\n    if (!prs) {\n        brand = JS_NewSymbolFromAtom(ctx, JS_ATOM_brand, JS_ATOM_TYPE_PRIVATE);\n        if (JS_IsException(brand))\n            return -1;\n        /* if the brand is not present, add it */\n        pr = add_property(ctx, p, JS_ATOM_Private_brand, JS_PROP_C_W_E);\n        if (!pr) {\n            JS_FreeValue(ctx, brand);\n            return -1;\n        }\n        pr->u.value = JS_DupValue(ctx, brand);\n    } else {\n        brand = JS_DupValue(ctx, pr->u.value);\n    }\n    brand_atom = js_symbol_to_atom(ctx, brand);\n    \n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        JS_FreeAtom(ctx, brand_atom);\n        return -1;\n    }\n    p1 = JS_VALUE_GET_OBJ(obj);\n    pr = add_property(ctx, p1, brand_atom, JS_PROP_C_W_E);\n    JS_FreeAtom(ctx, brand_atom);\n    if (!pr)\n        return -1;\n    pr->u.value = JS_UNDEFINED;\n    return 0;\n}\n\nstatic int JS_CheckBrand(JSContext *ctx, JSValueConst obj, JSValueConst func)\n{\n    JSObject *p, *p1, *home_obj;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    JSValueConst brand;\n    \n    /* get the home object of 'func' */\n    if (unlikely(JS_VALUE_GET_TAG(func) != JS_TAG_OBJECT)) {\n    not_obj:\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        return -1;\n    }\n    p1 = JS_VALUE_GET_OBJ(func);\n    if (!js_class_has_bytecode(p1->class_id))\n        goto not_obj;\n    home_obj = p1->u.func.home_object;\n    if (!home_obj)\n        goto not_obj;\n    prs = find_own_property(&pr, home_obj, JS_ATOM_Private_brand);\n    if (!prs) {\n        JS_ThrowTypeError(ctx, \"expecting <brand> private field\");\n        return -1;\n    }\n    brand = pr->u.value;\n    /* safety check */\n    if (unlikely(JS_VALUE_GET_TAG(brand) != JS_TAG_SYMBOL))\n        goto not_obj;\n    \n    /* get the brand array of 'obj' */\n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))\n        goto not_obj;\n    p = JS_VALUE_GET_OBJ(obj);\n    prs = find_own_property(&pr, p, js_symbol_to_atom(ctx, (JSValue)brand));\n    if (!prs) {\n        JS_ThrowTypeError(ctx, \"invalid brand on object\");\n        return -1;\n    }\n    return 0;\n}\n\nstatic uint32_t js_string_obj_get_length(JSContext *ctx,\n                                         JSValueConst obj)\n{\n    JSObject *p;\n    JSString *p1;\n    uint32_t len = 0;\n\n    /* This is a class exotic method: obj class_id is JS_CLASS_STRING */\n    p = JS_VALUE_GET_OBJ(obj);\n    if (JS_VALUE_GET_TAG(p->u.object_data) == JS_TAG_STRING) {\n        p1 = JS_VALUE_GET_STRING(p->u.object_data);\n        len = p1->len;\n    }\n    return len;\n}\n\nstatic int num_keys_cmp(const void *p1, const void *p2, void *opaque)\n{\n    JSContext *ctx = opaque;\n    JSAtom atom1 = ((const JSPropertyEnum *)p1)->atom;\n    JSAtom atom2 = ((const JSPropertyEnum *)p2)->atom;\n    uint32_t v1, v2;\n    BOOL atom1_is_integer, atom2_is_integer;\n\n    atom1_is_integer = JS_AtomIsArrayIndex(ctx, &v1, atom1);\n    atom2_is_integer = JS_AtomIsArrayIndex(ctx, &v2, atom2);\n    assert(atom1_is_integer && atom2_is_integer);\n    if (v1 < v2)\n        return -1;\n    else if (v1 == v2)\n        return 0;\n    else\n        return 1;\n}\n\nstatic void js_free_prop_enum(JSContext *ctx, JSPropertyEnum *tab, uint32_t len)\n{\n    uint32_t i;\n    if (tab) {\n        for(i = 0; i < len; i++)\n            JS_FreeAtom(ctx, tab[i].atom);\n        js_free(ctx, tab);\n    }\n}\n\n/* return < 0 in case if exception, 0 if OK. ptab and its atoms must\n   be freed by the user. */\nstatic int __exception JS_GetOwnPropertyNamesInternal(JSContext *ctx,\n                                                      JSPropertyEnum **ptab,\n                                                      uint32_t *plen,\n                                                      JSObject *p, int flags)\n{\n    int i, j;\n    JSShape *sh;\n    JSShapeProperty *prs;\n    JSPropertyEnum *tab_atom, *tab_exotic;\n    JSAtom atom;\n    uint32_t num_keys_count, str_keys_count, sym_keys_count, atom_count;\n    uint32_t num_index, str_index, sym_index, exotic_count, exotic_keys_count;\n    BOOL is_enumerable, num_sorted;\n    uint32_t num_key;\n    JSAtomKindEnum kind;\n    \n    /* clear pointer for consistency in case of failure */\n    *ptab = NULL;\n    *plen = 0;\n\n    /* compute the number of returned properties */\n    num_keys_count = 0;\n    str_keys_count = 0;\n    sym_keys_count = 0;\n    exotic_keys_count = 0;\n    exotic_count = 0;\n    tab_exotic = NULL;\n    sh = p->shape;\n    for(i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {\n        atom = prs->atom;\n        if (atom != JS_ATOM_NULL) {\n            is_enumerable = ((prs->flags & JS_PROP_ENUMERABLE) != 0);\n            kind = JS_AtomGetKind(ctx, atom);\n            if ((!(flags & JS_GPN_ENUM_ONLY) || is_enumerable) &&\n                ((flags >> kind) & 1) != 0) {\n                /* need to raise an exception in case of the module\n                   name space (implicit GetOwnProperty) */\n                if (unlikely((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) &&\n                    (flags & (JS_GPN_SET_ENUM | JS_GPN_ENUM_ONLY))) {\n                    JSVarRef *var_ref = p->prop[i].u.var_ref;\n                    if (unlikely(JS_IsUninitialized(*var_ref->pvalue))) {\n                        JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);\n                        return -1;\n                    }\n                }\n                if (JS_AtomIsArrayIndex(ctx, &num_key, atom)) {\n                    num_keys_count++;\n                } else if (kind == JS_ATOM_KIND_STRING) {\n                    str_keys_count++;\n                } else {\n                    sym_keys_count++;\n                }\n            }\n        }\n    }\n\n    if (p->is_exotic) {\n        if (p->fast_array) {\n            if (flags & JS_GPN_STRING_MASK) {\n                num_keys_count += p->u.array.count;\n            }\n        } else if (p->class_id == JS_CLASS_STRING) {\n            if (flags & JS_GPN_STRING_MASK) {\n                num_keys_count += js_string_obj_get_length(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n            }\n        } else {\n            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n            if (em && em->get_own_property_names) {\n                if (em->get_own_property_names(ctx, &tab_exotic, &exotic_count,\n                                               JS_MKPTR(JS_TAG_OBJECT, p)))\n                    return -1;\n                for(i = 0; i < exotic_count; i++) {\n                    atom = tab_exotic[i].atom;\n                    kind = JS_AtomGetKind(ctx, atom);\n                    if (((flags >> kind) & 1) != 0) {\n                        is_enumerable = FALSE;\n                        if (flags & (JS_GPN_SET_ENUM | JS_GPN_ENUM_ONLY)) {\n                            JSPropertyDescriptor desc;\n                            int res;\n                            /* set the \"is_enumerable\" field if necessary */\n                            res = JS_GetOwnPropertyInternal(ctx, &desc, p, atom);\n                            if (res < 0) {\n                                js_free_prop_enum(ctx, tab_exotic, exotic_count);\n                                return -1;\n                            }\n                            if (res) {\n                                is_enumerable =\n                                    ((desc.flags & JS_PROP_ENUMERABLE) != 0);\n                                js_free_desc(ctx, &desc);\n                            }\n                            tab_exotic[i].is_enumerable = is_enumerable;\n                        }\n                        if (!(flags & JS_GPN_ENUM_ONLY) || is_enumerable) {\n                            exotic_keys_count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /* fill them */\n\n    atom_count = num_keys_count + str_keys_count + sym_keys_count + exotic_keys_count;\n    /* avoid allocating 0 bytes */\n    tab_atom = js_malloc(ctx, sizeof(tab_atom[0]) * max_int(atom_count, 1));\n    if (!tab_atom) {\n        js_free_prop_enum(ctx, tab_exotic, exotic_count);\n        return -1;\n    }\n\n    num_index = 0;\n    str_index = num_keys_count;\n    sym_index = str_index + str_keys_count;\n\n    num_sorted = TRUE;\n    sh = p->shape;\n    for(i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {\n        atom = prs->atom;\n        if (atom != JS_ATOM_NULL) {\n            is_enumerable = ((prs->flags & JS_PROP_ENUMERABLE) != 0);\n            kind = JS_AtomGetKind(ctx, atom);\n            if ((!(flags & JS_GPN_ENUM_ONLY) || is_enumerable) &&\n                ((flags >> kind) & 1) != 0) {\n                if (JS_AtomIsArrayIndex(ctx, &num_key, atom)) {\n                    j = num_index++;\n                    num_sorted = FALSE;\n                } else if (kind == JS_ATOM_KIND_STRING) {\n                    j = str_index++;\n                } else {\n                    j = sym_index++;\n                }\n                tab_atom[j].atom = JS_DupAtom(ctx, atom);\n                tab_atom[j].is_enumerable = is_enumerable;\n            }\n        }\n    }\n\n    if (p->is_exotic) {\n        int len;\n        if (p->fast_array) {\n            if (flags & JS_GPN_STRING_MASK) {\n                len = p->u.array.count;\n                goto add_array_keys;\n            }\n        } else if (p->class_id == JS_CLASS_STRING) {\n            if (flags & JS_GPN_STRING_MASK) {\n                len = js_string_obj_get_length(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n            add_array_keys:\n                for(i = 0; i < len; i++) {\n                    tab_atom[num_index].atom = __JS_AtomFromUInt32(i);\n                    if (tab_atom[num_index].atom == JS_ATOM_NULL) {\n                        js_free_prop_enum(ctx, tab_atom, num_index);\n                        return -1;\n                    }\n                    tab_atom[num_index].is_enumerable = TRUE;\n                    num_index++;\n                }\n            }\n        } else {\n            /* Note: exotic keys are not reordered and comes after the object own properties. */\n            for(i = 0; i < exotic_count; i++) {\n                atom = tab_exotic[i].atom;\n                is_enumerable = tab_exotic[i].is_enumerable;\n                kind = JS_AtomGetKind(ctx, atom);\n                if ((!(flags & JS_GPN_ENUM_ONLY) || is_enumerable) &&\n                    ((flags >> kind) & 1) != 0) {\n                    tab_atom[sym_index].atom = atom;\n                    tab_atom[sym_index].is_enumerable = is_enumerable;\n                    sym_index++;\n                } else {\n                    JS_FreeAtom(ctx, atom);\n                }\n            }\n            js_free(ctx, tab_exotic);\n        }\n    }\n\n    assert(num_index == num_keys_count);\n    assert(str_index == num_keys_count + str_keys_count);\n    assert(sym_index == atom_count);\n\n    if (num_keys_count != 0 && !num_sorted) {\n        rqsort(tab_atom, num_keys_count, sizeof(tab_atom[0]), num_keys_cmp,\n               ctx);\n    }\n    *ptab = tab_atom;\n    *plen = atom_count;\n    return 0;\n}\n\nint JS_GetOwnPropertyNames(JSContext *ctx, JSPropertyEnum **ptab,\n                           uint32_t *plen, JSValueConst obj, int flags)\n{\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        return -1;\n    }\n    return JS_GetOwnPropertyNamesInternal(ctx, ptab, plen,\n                                          JS_VALUE_GET_OBJ(obj), flags);\n}\n\n/* Return -1 if exception,\n   FALSE if the property does not exist, TRUE if it exists. If TRUE is\n   returned, the property descriptor 'desc' is filled present. */\nstatic int JS_GetOwnPropertyInternal(JSContext *ctx, JSPropertyDescriptor *desc,\n                                     JSObject *p, JSAtom prop)\n{\n    JSShapeProperty *prs;\n    JSProperty *pr;\n\nretry:\n    prs = find_own_property(&pr, p, prop);\n    if (prs) {\n        if (desc) {\n            desc->flags = prs->flags & JS_PROP_C_W_E;\n            desc->getter = JS_UNDEFINED;\n            desc->setter = JS_UNDEFINED;\n            desc->value = JS_UNDEFINED;\n            if (unlikely(prs->flags & JS_PROP_TMASK)) {\n                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n                    desc->flags |= JS_PROP_GETSET;\n                    if (pr->u.getset.getter)\n                        desc->getter = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter));\n                    if (pr->u.getset.setter)\n                        desc->setter = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.setter));\n                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n                    JSValue val = *pr->u.var_ref->pvalue;\n                    if (unlikely(JS_IsUninitialized(val))) {\n                        JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);\n                        return -1;\n                    }\n                    desc->value = JS_DupValue(ctx, val);\n                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n                    /* Instantiate property and retry */\n                    if (JS_AutoInitProperty(ctx, p, prop, pr, prs))\n                        return -1;\n                    goto retry;\n                }\n            } else {\n                desc->value = JS_DupValue(ctx, pr->u.value);\n            }\n        } else {\n            /* for consistency, send the exception even if desc is NULL */\n            if (unlikely((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF)) {\n                if (unlikely(JS_IsUninitialized(*pr->u.var_ref->pvalue))) {\n                    JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);\n                    return -1;\n                }\n            } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n                /* nothing to do: delay instantiation until actual value and/or attributes are read */\n            }\n        }\n        return TRUE;\n    }\n    if (p->is_exotic) {\n        if (p->fast_array) {\n            /* specific case for fast arrays */\n            if (__JS_AtomIsTaggedInt(prop)) {\n                uint32_t idx;\n                idx = __JS_AtomToUInt32(prop);\n                if (idx < p->u.array.count) {\n                    if (desc) {\n                        desc->flags = JS_PROP_WRITABLE | JS_PROP_ENUMERABLE |\n                            JS_PROP_CONFIGURABLE;\n                        desc->getter = JS_UNDEFINED;\n                        desc->setter = JS_UNDEFINED;\n                        desc->value = JS_GetPropertyUint32(ctx, JS_MKPTR(JS_TAG_OBJECT, p), idx);\n                    }\n                    return TRUE;\n                }\n            }\n        } else {\n            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n            if (em && em->get_own_property) {\n                return em->get_own_property(ctx, desc,\n                                            JS_MKPTR(JS_TAG_OBJECT, p), prop);\n            }\n        }\n    }\n    return FALSE;\n}\n\nint JS_GetOwnProperty(JSContext *ctx, JSPropertyDescriptor *desc,\n                      JSValueConst obj, JSAtom prop)\n{\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        return -1;\n    }\n    return JS_GetOwnPropertyInternal(ctx, desc, JS_VALUE_GET_OBJ(obj), prop);\n}\n\n/* return -1 if exception (Proxy object only) or TRUE/FALSE */\nint JS_IsExtensible(JSContext *ctx, JSValueConst obj)\n{\n    JSObject *p;\n\n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(obj);\n    if (unlikely(p->class_id == JS_CLASS_PROXY))\n        return js_proxy_isExtensible(ctx, obj);\n    else\n        return p->extensible;\n}\n\n/* return -1 if exception (Proxy object only) or TRUE/FALSE */\nint JS_PreventExtensions(JSContext *ctx, JSValueConst obj)\n{\n    JSObject *p;\n\n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(obj);\n    if (unlikely(p->class_id == JS_CLASS_PROXY))\n        return js_proxy_preventExtensions(ctx, obj);\n    p->extensible = FALSE;\n    return TRUE;\n}\n\n/* return -1 if exception otherwise TRUE or FALSE */\nint JS_HasProperty(JSContext *ctx, JSValueConst obj, JSAtom prop)\n{\n    JSObject *p;\n    int ret;\n    JSValue obj1;\n\n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(obj);\n    for(;;) {\n        if (p->is_exotic) {\n            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n            if (em && em->has_property) {\n                /* has_property can free the prototype */\n                obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n                ret = em->has_property(ctx, obj1, prop);\n                JS_FreeValue(ctx, obj1);\n                return ret;\n            }\n        }\n        /* JS_GetOwnPropertyInternal can free the prototype */\n        JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n        ret = JS_GetOwnPropertyInternal(ctx, NULL, p, prop);\n        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n        if (ret != 0)\n            return ret;\n        if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n            p->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n            ret = JS_AtomIsNumericIndex(ctx, prop);\n            if (ret != 0) {\n                if (ret < 0)\n                    return -1;\n                return FALSE;\n            }\n        }\n        p = p->shape->proto;\n        if (!p)\n            break;\n    }\n    return FALSE;\n}\n\n/* val must be a symbol */\nstatic JSAtom js_symbol_to_atom(JSContext *ctx, JSValue val)\n{\n    JSAtomStruct *p = JS_VALUE_GET_PTR(val);\n    return js_get_atom_index(ctx->rt, p);\n}\n\n/* return JS_ATOM_NULL in case of exception */\nJSAtom JS_ValueToAtom(JSContext *ctx, JSValueConst val)\n{\n    JSAtom atom;\n    uint32_t tag;\n    tag = JS_VALUE_GET_TAG(val);\n    if (tag == JS_TAG_INT &&\n        (uint32_t)JS_VALUE_GET_INT(val) <= JS_ATOM_MAX_INT) {\n        /* fast path for integer values */\n        atom = __JS_AtomFromUInt32(JS_VALUE_GET_INT(val));\n    } else if (tag == JS_TAG_SYMBOL) {\n        JSAtomStruct *p = JS_VALUE_GET_PTR(val);\n        atom = JS_DupAtom(ctx, js_get_atom_index(ctx->rt, p));\n    } else {\n        JSValue str;\n        str = JS_ToPropertyKey(ctx, val);\n        if (JS_IsException(str))\n            return JS_ATOM_NULL;\n        if (JS_VALUE_GET_TAG(str) == JS_TAG_SYMBOL) {\n            atom = js_symbol_to_atom(ctx, str);\n        } else {\n            atom = JS_NewAtomStr(ctx, JS_VALUE_GET_STRING(str));\n        }\n    }\n    return atom;\n}\n\nstatic JSValue JS_GetPropertyValue(JSContext *ctx, JSValueConst this_obj,\n                                   JSValue prop)\n{\n    JSAtom atom;\n    JSValue ret;\n\n    if (likely(JS_VALUE_GET_TAG(this_obj) == JS_TAG_OBJECT &&\n               JS_VALUE_GET_TAG(prop) == JS_TAG_INT)) {\n        JSObject *p;\n        uint32_t idx, len;\n        /* fast path for array access */\n        p = JS_VALUE_GET_OBJ(this_obj);\n        idx = JS_VALUE_GET_INT(prop);\n        len = (uint32_t)p->u.array.count;\n        if (unlikely(idx >= len))\n            goto slow_path;\n        switch(p->class_id) {\n        case JS_CLASS_ARRAY:\n        case JS_CLASS_ARGUMENTS:\n            return JS_DupValue(ctx, p->u.array.u.values[idx]);\n        case JS_CLASS_INT8_ARRAY:\n            return JS_NewInt32(ctx, p->u.array.u.int8_ptr[idx]);\n        case JS_CLASS_UINT8C_ARRAY:\n        case JS_CLASS_UINT8_ARRAY:\n            return JS_NewInt32(ctx, p->u.array.u.uint8_ptr[idx]);\n        case JS_CLASS_INT16_ARRAY:\n            return JS_NewInt32(ctx, p->u.array.u.int16_ptr[idx]);\n        case JS_CLASS_UINT16_ARRAY:\n            return JS_NewInt32(ctx, p->u.array.u.uint16_ptr[idx]);\n        case JS_CLASS_INT32_ARRAY:\n            return JS_NewInt32(ctx, p->u.array.u.int32_ptr[idx]);\n        case JS_CLASS_UINT32_ARRAY:\n            return JS_NewUint32(ctx, p->u.array.u.uint32_ptr[idx]);\n#ifdef CONFIG_BIGNUM\n        case JS_CLASS_BIG_INT64_ARRAY:\n            return JS_NewBigInt64(ctx, p->u.array.u.int64_ptr[idx]);\n        case JS_CLASS_BIG_UINT64_ARRAY:\n            return JS_NewBigUint64(ctx, p->u.array.u.uint64_ptr[idx]);\n#endif\n        case JS_CLASS_FLOAT32_ARRAY:\n            return __JS_NewFloat64(ctx, p->u.array.u.float_ptr[idx]);\n        case JS_CLASS_FLOAT64_ARRAY:\n            return __JS_NewFloat64(ctx, p->u.array.u.double_ptr[idx]);\n        default:\n            goto slow_path;\n        }\n    } else {\n    slow_path:\n        atom = JS_ValueToAtom(ctx, prop);\n        JS_FreeValue(ctx, prop);\n        if (unlikely(atom == JS_ATOM_NULL))\n            return JS_EXCEPTION;\n        ret = JS_GetProperty(ctx, this_obj, atom);\n        JS_FreeAtom(ctx, atom);\n        return ret;\n    }\n}\n\nJSValue JS_GetPropertyUint32(JSContext *ctx, JSValueConst this_obj,\n                             uint32_t idx)\n{\n    return JS_GetPropertyValue(ctx, this_obj, JS_NewUint32(ctx, idx));\n}\n\n/* Check if an object has a generalized numeric property. Return value:\n   -1 for exception,\n   TRUE if property exists, stored into *pval,\n   FALSE if proprty does not exist.\n */\nstatic int JS_TryGetPropertyInt64(JSContext *ctx, JSValueConst obj, int64_t idx, JSValue *pval)\n{\n    JSValue val = JS_UNDEFINED;\n    JSAtom prop;\n    int present;\n\n    if (likely((uint64_t)idx <= JS_ATOM_MAX_INT)) {\n        /* fast path */\n        present = JS_HasProperty(ctx, obj, __JS_AtomFromUInt32(idx));\n        if (present > 0) {\n            val = JS_GetPropertyValue(ctx, obj, JS_NewInt32(ctx, idx));\n            if (unlikely(JS_IsException(val)))\n                present = -1;\n        }\n    } else {\n        prop = JS_NewAtomInt64(ctx, idx);\n        present = -1;\n        if (likely(prop != JS_ATOM_NULL)) {\n            present = JS_HasProperty(ctx, obj, prop);\n            if (present > 0) {\n                val = JS_GetProperty(ctx, obj, prop);\n                if (unlikely(JS_IsException(val)))\n                    present = -1;\n            }\n            JS_FreeAtom(ctx, prop);\n        }\n    }\n    *pval = val;\n    return present;\n}\n\nstatic JSValue JS_GetPropertyInt64(JSContext *ctx, JSValueConst obj, int64_t idx)\n{\n    JSAtom prop;\n    JSValue val;\n\n    if ((uint64_t)idx <= INT32_MAX) {\n        /* fast path for fast arrays */\n        return JS_GetPropertyValue(ctx, obj, JS_NewInt32(ctx, idx));\n    }\n    prop = JS_NewAtomInt64(ctx, idx);\n    if (prop == JS_ATOM_NULL)\n        return JS_EXCEPTION;\n\n    val = JS_GetProperty(ctx, obj, prop);\n    JS_FreeAtom(ctx, prop);\n    return val;\n}\n\nJSValue JS_GetPropertyStr(JSContext *ctx, JSValueConst this_obj,\n                          const char *prop)\n{\n    JSAtom atom;\n    JSValue ret;\n    atom = JS_NewAtom(ctx, prop);\n    ret = JS_GetProperty(ctx, this_obj, atom);\n    JS_FreeAtom(ctx, atom);\n    return ret;\n}\n\n/* Note: the property value is not initialized. Return NULL if memory\n   error. */\nstatic JSProperty *add_property(JSContext *ctx,\n                                JSObject *p, JSAtom prop, int prop_flags)\n{\n    JSShape *sh, *new_sh;\n\n    sh = p->shape;\n    if (sh->is_hashed) {\n        /* try to find an existing shape */\n        new_sh = find_hashed_shape_prop(ctx->rt, sh, prop, prop_flags);\n        if (new_sh) {\n            /* matching shape found: use it */\n            /*  the property array may need to be resized */\n            if (new_sh->prop_size != sh->prop_size) {\n                JSProperty *new_prop;\n                new_prop = js_realloc(ctx, p->prop, sizeof(p->prop[0]) *\n                                      new_sh->prop_size);\n                if (!new_prop)\n                    return NULL;\n                p->prop = new_prop;\n            }\n            p->shape = js_dup_shape(new_sh);\n            js_free_shape(ctx->rt, sh);\n            return &p->prop[new_sh->prop_count - 1];\n        } else if (sh->header.ref_count != 1) {\n            /* if the shape is shared, clone it */\n            new_sh = js_clone_shape(ctx, sh);\n            if (!new_sh)\n                return NULL;\n            /* hash the cloned shape */\n            new_sh->is_hashed = TRUE;\n            js_shape_hash_link(ctx->rt, new_sh);\n            js_free_shape(ctx->rt, p->shape);\n            p->shape = new_sh;\n        }\n    }\n    assert(p->shape->header.ref_count == 1);\n    if (add_shape_property(ctx, &p->shape, p, prop, prop_flags))\n        return NULL;\n    return &p->prop[p->shape->prop_count - 1];\n}\n\n/* can be called on Array or Arguments objects. return < 0 if\n   memory alloc error. */\nstatic no_inline __exception int convert_fast_array_to_array(JSContext *ctx,\n                                                             JSObject *p)\n{\n    JSProperty *pr;\n    JSShape *sh;\n    JSValue *tab;\n    uint32_t i, len, new_count;\n\n    if (js_shape_prepare_update(ctx, p, NULL))\n        return -1;\n    len = p->u.array.count;\n    /* resize the properties once to simplify the error handling */\n    sh = p->shape;\n    new_count = sh->prop_count + len;\n    if (new_count > sh->prop_size) {\n        if (resize_properties(ctx, &p->shape, p, new_count))\n            return -1;\n    }\n\n    tab = p->u.array.u.values;\n    for(i = 0; i < len; i++) {\n        /* add_property cannot fail here but\n           __JS_AtomFromUInt32(i) fails for i > INT32_MAX */\n        pr = add_property(ctx, p, __JS_AtomFromUInt32(i), JS_PROP_C_W_E);\n        pr->u.value = *tab++;\n    }\n    js_free(ctx, p->u.array.u.values);\n    p->u.array.count = 0;\n    p->u.array.u.values = NULL; /* fail safe */\n    p->u.array.u1.size = 0;\n    p->fast_array = 0;\n    return 0;\n}\n\nstatic int delete_property(JSContext *ctx, JSObject *p, JSAtom atom)\n{\n    JSShape *sh;\n    JSShapeProperty *pr, *lpr, *prop;\n    JSProperty *pr1;\n    uint32_t lpr_idx;\n    intptr_t h, h1;\n\n redo:\n    sh = p->shape;\n    h1 = atom & sh->prop_hash_mask;\n    h = prop_hash_end(sh)[-h1 - 1];\n    prop = get_shape_prop(sh);\n    lpr = NULL;\n    lpr_idx = 0;   /* prevent warning */\n    while (h != 0) {\n        pr = &prop[h - 1];\n        if (likely(pr->atom == atom)) {\n            /* found ! */\n            if (!(pr->flags & JS_PROP_CONFIGURABLE))\n                return FALSE;\n            /* realloc the shape if needed */\n            if (lpr)\n                lpr_idx = lpr - get_shape_prop(sh);\n            if (js_shape_prepare_update(ctx, p, &pr))\n                return -1;\n            sh = p->shape;\n            /* remove property */\n            if (lpr) {\n                lpr = get_shape_prop(sh) + lpr_idx;\n                lpr->hash_next = pr->hash_next;\n            } else {\n                prop_hash_end(sh)[-h1 - 1] = pr->hash_next;\n            }\n            sh->deleted_prop_count++;\n            /* free the entry */\n            pr1 = &p->prop[h - 1];\n            free_property(ctx->rt, pr1, pr->flags);\n            JS_FreeAtom(ctx, pr->atom);\n            /* put default values */\n            pr->flags = 0;\n            pr->atom = JS_ATOM_NULL;\n            pr1->u.value = JS_UNDEFINED;\n\n            /* compact the properties if too many deleted properties */\n            if (sh->deleted_prop_count >= 8 &&\n                sh->deleted_prop_count >= ((unsigned)sh->prop_count / 2)) {\n                compact_properties(ctx, p);\n            }\n            return TRUE;\n        }\n        lpr = pr;\n        h = pr->hash_next;\n    }\n\n    if (p->is_exotic) {\n        if (p->fast_array) {\n            uint32_t idx;\n            if (JS_AtomIsArrayIndex(ctx, &idx, atom) &&\n                idx < p->u.array.count) {\n                if (p->class_id == JS_CLASS_ARRAY ||\n                    p->class_id == JS_CLASS_ARGUMENTS) {\n                    /* Special case deleting the last element of a fast Array */\n                    if (idx == p->u.array.count - 1) {\n                        JS_FreeValue(ctx, p->u.array.u.values[idx]);\n                        p->u.array.count = idx;\n                        return TRUE;\n                    }\n                    if (convert_fast_array_to_array(ctx, p))\n                        return -1;\n                    goto redo;\n                } else {\n                    return FALSE;\n                }\n            }\n        } else {\n            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n            if (em && em->delete_property) {\n                return em->delete_property(ctx, JS_MKPTR(JS_TAG_OBJECT, p), atom);\n            }\n        }\n    }\n    /* not found */\n    return TRUE;\n}\n\nstatic int call_setter(JSContext *ctx, JSObject *setter,\n                       JSValueConst this_obj, JSValue val, int flags)\n{\n    JSValue ret, func;\n    if (likely(setter)) {\n        func = JS_MKPTR(JS_TAG_OBJECT, setter);\n        /* Note: the field could be removed in the setter */\n        func = JS_DupValue(ctx, func);\n        ret = JS_CallFree(ctx, func, this_obj, 1, (JSValueConst *)&val);\n        JS_FreeValue(ctx, val);\n        if (JS_IsException(ret))\n            return -1;\n        JS_FreeValue(ctx, ret);\n        return TRUE;\n    } else {\n        JS_FreeValue(ctx, val);\n        if ((flags & JS_PROP_THROW) ||\n            ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {\n            JS_ThrowTypeError(ctx, \"no setter for property\");\n            return -1;\n        }\n        return FALSE;\n    }\n}\n\n/* set the array length and remove the array elements if necessary. */\nstatic int set_array_length(JSContext *ctx, JSObject *p, JSValue val,\n                            int flags)\n{\n    uint32_t len, idx, cur_len;\n    int i, ret;\n\n    /* Note: this call can reallocate the properties of 'p' */\n    ret = JS_ToArrayLengthFree(ctx, &len, val, FALSE);\n    if (ret)\n        return -1;\n    /* JS_ToArrayLengthFree() must be done before the read-only test */\n    if (unlikely(!(p->shape->prop[0].flags & JS_PROP_WRITABLE)))\n        return JS_ThrowTypeErrorReadOnly(ctx, flags, JS_ATOM_length);\n\n    if (likely(p->fast_array)) {\n        uint32_t old_len = p->u.array.count;\n        if (len < old_len) {\n            for(i = len; i < old_len; i++) {\n                JS_FreeValue(ctx, p->u.array.u.values[i]);\n            }\n            p->u.array.count = len;\n        }\n        p->prop[0].u.value = JS_NewUint32(ctx, len);\n    } else {\n        /* Note: length is always a uint32 because the object is an\n           array */\n        JS_ToUint32(ctx, &cur_len, p->prop[0].u.value);\n        if (len < cur_len) {\n            uint32_t d;\n            JSShape *sh;\n            JSShapeProperty *pr;\n\n            d = cur_len - len;\n            sh = p->shape;\n            if (d <= sh->prop_count) {\n                JSAtom atom;\n\n                /* faster to iterate */\n                while (cur_len > len) {\n                    atom = JS_NewAtomUInt32(ctx, cur_len - 1);\n                    ret = delete_property(ctx, p, atom);\n                    JS_FreeAtom(ctx, atom);\n                    if (unlikely(!ret)) {\n                        /* unlikely case: property is not\n                           configurable */\n                        break;\n                    }\n                    cur_len--;\n                }\n            } else {\n                /* faster to iterate thru all the properties. Need two\n                   passes in case one of the property is not\n                   configurable */\n                cur_len = len;\n                for(i = 0, pr = get_shape_prop(sh); i < sh->prop_count;\n                    i++, pr++) {\n                    if (pr->atom != JS_ATOM_NULL &&\n                        JS_AtomIsArrayIndex(ctx, &idx, pr->atom)) {\n                        if (idx >= cur_len &&\n                            !(pr->flags & JS_PROP_CONFIGURABLE)) {\n                            cur_len = idx + 1;\n                        }\n                    }\n                }\n\n                for(i = 0, pr = get_shape_prop(sh); i < sh->prop_count;\n                    i++, pr++) {\n                    if (pr->atom != JS_ATOM_NULL &&\n                        JS_AtomIsArrayIndex(ctx, &idx, pr->atom)) {\n                        if (idx >= cur_len) {\n                            /* remove the property */\n                            delete_property(ctx, p, pr->atom);\n                            /* WARNING: the shape may have been modified */\n                            sh = p->shape;\n                            pr = get_shape_prop(sh) + i;\n                        }\n                    }\n                }\n            }\n        } else {\n            cur_len = len;\n        }\n        set_value(ctx, &p->prop[0].u.value, JS_NewUint32(ctx, cur_len));\n        if (unlikely(cur_len > len)) {\n            return JS_ThrowTypeErrorOrFalse(ctx, flags, \"not configurable\");\n        }\n    }\n    return TRUE;\n}\n\n/* return -1 if exception */\nstatic int expand_fast_array(JSContext *ctx, JSObject *p, uint32_t new_len)\n{\n    uint32_t new_size;\n    size_t slack;\n    JSValue *new_array_prop;\n    /* XXX: potential arithmetic overflow */\n    new_size = max_int(new_len, p->u.array.u1.size * 3 / 2);\n    new_array_prop = js_realloc2(ctx, p->u.array.u.values, sizeof(JSValue) * new_size, &slack);\n    if (!new_array_prop)\n        return -1;\n    new_size += slack / sizeof(*new_array_prop);\n    p->u.array.u.values = new_array_prop;\n    p->u.array.u1.size = new_size;\n    return 0;\n}\n\n/* Preconditions: 'p' must be of class JS_CLASS_ARRAY, p->fast_array =\n   TRUE and p->extensible = TRUE */\nstatic int add_fast_array_element(JSContext *ctx, JSObject *p,\n                                  JSValue val, int flags)\n{\n    uint32_t new_len, array_len;\n    /* extend the array by one */\n    /* XXX: convert to slow array if new_len > 2^31-1 elements */\n    new_len = p->u.array.count + 1;\n    /* update the length if necessary. We assume that if the length is\n       not an integer, then if it >= 2^31.  */\n    if (likely(JS_VALUE_GET_TAG(p->prop[0].u.value) == JS_TAG_INT)) {\n        array_len = JS_VALUE_GET_INT(p->prop[0].u.value);\n        if (new_len > array_len) {\n            if (unlikely(!(get_shape_prop(p->shape)->flags & JS_PROP_WRITABLE))) {\n                JS_FreeValue(ctx, val);\n                return JS_ThrowTypeErrorReadOnly(ctx, flags, JS_ATOM_length);\n            }\n            p->prop[0].u.value = JS_NewInt32(ctx, new_len);\n        }\n    }\n    if (unlikely(new_len > p->u.array.u1.size)) {\n        if (expand_fast_array(ctx, p, new_len)) {\n            JS_FreeValue(ctx, val);\n            return -1;\n        }\n    }\n    p->u.array.u.values[new_len - 1] = val;\n    p->u.array.count = new_len;\n    return TRUE;\n}\n\nstatic void js_free_desc(JSContext *ctx, JSPropertyDescriptor *desc)\n{\n    JS_FreeValue(ctx, desc->getter);\n    JS_FreeValue(ctx, desc->setter);\n    JS_FreeValue(ctx, desc->value);\n}\n\n/* generic (and slower) version of JS_SetProperty() for\n * Reflect.set(). 'obj' must be an object.  */\nstatic int JS_SetPropertyGeneric(JSContext *ctx,\n                                 JSValueConst obj, JSAtom prop,\n                                 JSValue val, JSValueConst this_obj,\n                                 int flags)\n{\n    int ret;\n    JSPropertyDescriptor desc;\n    JSValue obj1;\n    JSObject *p;\n    \n    obj1 = JS_DupValue(ctx, obj);\n    for(;;) {\n        p = JS_VALUE_GET_OBJ(obj1);\n        if (p->is_exotic) {\n            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n            if (em && em->set_property) {\n                ret = em->set_property(ctx, obj1, prop,\n                                       val, this_obj, flags);\n                JS_FreeValue(ctx, obj1);\n                JS_FreeValue(ctx, val);\n                return ret;\n            }\n        }\n\n        ret = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);\n        if (ret < 0) {\n            JS_FreeValue(ctx, obj1);\n            JS_FreeValue(ctx, val);\n            return ret;\n        }\n        if (ret) {\n            if (desc.flags & JS_PROP_GETSET) {\n                JSObject *setter;\n                if (JS_IsUndefined(desc.setter))\n                    setter = NULL;\n                else\n                    setter = JS_VALUE_GET_OBJ(desc.setter);\n                ret = call_setter(ctx, setter, this_obj, val, flags);\n                JS_FreeValue(ctx, desc.getter);\n                JS_FreeValue(ctx, desc.setter);\n                JS_FreeValue(ctx, obj1);\n                return ret;\n            } else {\n                JS_FreeValue(ctx, desc.value);\n                if (!(desc.flags & JS_PROP_WRITABLE)) {\n                    JS_FreeValue(ctx, obj1);\n                    goto read_only_error;\n                }\n            }\n            break;\n        }\n        /* Note: at this point 'obj1' cannot be a proxy. XXX: may have\n           to check recursion */\n        obj1 = JS_GetPrototypeFree(ctx, obj1);\n        if (JS_IsNull(obj1))\n            break;\n    }\n    JS_FreeValue(ctx, obj1);\n\n    if (!JS_IsObject(this_obj)) {\n        JS_FreeValue(ctx, val);\n        return JS_ThrowTypeErrorOrFalse(ctx, flags, \"receiver is not an object\");\n    }\n    \n    p = JS_VALUE_GET_OBJ(this_obj);\n\n    /* modify the property in this_obj if it already exists */\n    ret = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);\n    if (ret < 0) {\n        JS_FreeValue(ctx, val);\n        return ret;\n    }\n    if (ret) {\n        if (desc.flags & JS_PROP_GETSET) {\n            JS_FreeValue(ctx, desc.getter);\n            JS_FreeValue(ctx, desc.setter);\n            JS_FreeValue(ctx, val);\n            return JS_ThrowTypeErrorOrFalse(ctx, flags, \"setter is forbidden\");\n        } else {\n            JS_FreeValue(ctx, desc.value);\n            if (!(desc.flags & JS_PROP_WRITABLE) ||\n                p->class_id == JS_CLASS_MODULE_NS) {\n            read_only_error:\n                JS_FreeValue(ctx, val);\n                return JS_ThrowTypeErrorReadOnly(ctx, flags, prop);\n            }\n        }\n        ret = JS_DefineProperty(ctx, this_obj, prop, val,\n                                JS_UNDEFINED, JS_UNDEFINED,\n                                JS_PROP_HAS_VALUE);\n        JS_FreeValue(ctx, val);\n        return ret;\n    }\n\n    ret = JS_CreateProperty(ctx, p, prop, val, JS_UNDEFINED, JS_UNDEFINED,\n                            flags |\n                            JS_PROP_HAS_VALUE |\n                            JS_PROP_HAS_ENUMERABLE |\n                            JS_PROP_HAS_WRITABLE |\n                            JS_PROP_HAS_CONFIGURABLE |\n                            JS_PROP_C_W_E);\n    JS_FreeValue(ctx, val);\n    return ret;\n}\n\n/* return -1 in case of exception or TRUE or FALSE. Warning: 'val' is\n   freed by the function. 'flags' is a bitmask of JS_PROP_NO_ADD,\n   JS_PROP_THROW or JS_PROP_THROW_STRICT. If JS_PROP_NO_ADD is set,\n   the new property is not added and an error is raised. */\nint JS_SetPropertyInternal(JSContext *ctx, JSValueConst this_obj,\n                           JSAtom prop, JSValue val, int flags)\n{\n    JSObject *p, *p1;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    uint32_t tag;\n    JSPropertyDescriptor desc;\n    int ret;\n#if 0\n    printf(\"JS_SetPropertyInternal: \"); print_atom(ctx, prop); printf(\"\\n\");\n#endif\n    tag = JS_VALUE_GET_TAG(this_obj);\n    if (unlikely(tag != JS_TAG_OBJECT)) {\n        switch(tag) {\n        case JS_TAG_NULL:\n            JS_FreeValue(ctx, val);\n            JS_ThrowTypeErrorAtom(ctx, \"cannot set property '%s' of null\", prop);\n            return -1;\n        case JS_TAG_UNDEFINED:\n            JS_FreeValue(ctx, val);\n            JS_ThrowTypeErrorAtom(ctx, \"cannot set property '%s' of undefined\", prop);\n            return -1;\n        default:\n            /* even on a primitive type we can have setters on the prototype */\n            p = NULL;\n            p1 = JS_VALUE_GET_OBJ(JS_GetPrototypePrimitive(ctx, this_obj));\n            goto prototype_lookup;\n        }\n    }\n    p = JS_VALUE_GET_OBJ(this_obj);\nretry:\n    prs = find_own_property(&pr, p, prop);\n    if (prs) {\n        if (likely((prs->flags & (JS_PROP_TMASK | JS_PROP_WRITABLE |\n                                  JS_PROP_LENGTH)) == JS_PROP_WRITABLE)) {\n            /* fast case */\n            set_value(ctx, &pr->u.value, val);\n            return TRUE;\n        } else if (prs->flags & JS_PROP_LENGTH) {\n            assert(p->class_id == JS_CLASS_ARRAY);\n            assert(prop == JS_ATOM_length);\n            return set_array_length(ctx, p, val, flags);\n        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n            return call_setter(ctx, pr->u.getset.setter, this_obj, val, flags);\n        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n            /* JS_PROP_WRITABLE is always true for variable\n               references, but they are write protected in module name\n               spaces. */\n            if (p->class_id == JS_CLASS_MODULE_NS)\n                goto read_only_prop;\n            set_value(ctx, pr->u.var_ref->pvalue, val);\n            return TRUE;\n        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n            /* Instantiate property and retry (potentially useless) */\n            if (JS_AutoInitProperty(ctx, p, prop, pr, prs)) {\n                JS_FreeValue(ctx, val);\n                return -1;\n            }\n            goto retry;\n        } else {\n            goto read_only_prop;\n        }\n    }\n\n    p1 = p;\n    for(;;) {\n        if (p1->is_exotic) {\n            if (p1->fast_array) {\n                if (__JS_AtomIsTaggedInt(prop)) {\n                    uint32_t idx = __JS_AtomToUInt32(prop);\n                    if (idx < p1->u.array.count) {\n                        if (unlikely(p == p1))\n                            return JS_SetPropertyValue(ctx, this_obj, JS_NewInt32(ctx, idx), val, flags);\n                        else\n                            break;\n                    } else if (p1->class_id >= JS_CLASS_UINT8C_ARRAY &&\n                               p1->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n                        goto typed_array_oob;\n                    }\n                } else if (p1->class_id >= JS_CLASS_UINT8C_ARRAY &&\n                           p1->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n                    ret = JS_AtomIsNumericIndex(ctx, prop);\n                    if (ret != 0) {\n                        if (ret < 0) {\n                            JS_FreeValue(ctx, val);\n                            return -1;\n                        }\n                    typed_array_oob:\n                        val = JS_ToNumberFree(ctx, val);\n                        JS_FreeValue(ctx, val);\n                        if (JS_IsException(val))\n                            return -1;\n                        return JS_ThrowTypeErrorOrFalse(ctx, flags, \"out-of-bound numeric index\");\n                    }\n                }\n            } else {\n                const JSClassExoticMethods *em = ctx->rt->class_array[p1->class_id].exotic;\n                if (em) {\n                    JSValue obj1;\n                    if (em->set_property) {\n                        /* set_property can free the prototype */\n                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p1));\n                        ret = em->set_property(ctx, obj1, prop,\n                                               val, this_obj, flags);\n                        JS_FreeValue(ctx, obj1);\n                        JS_FreeValue(ctx, val);\n                        return ret;\n                    }\n                    if (em->get_own_property) {\n                        /* get_own_property can free the prototype */\n                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p1));\n                        ret = em->get_own_property(ctx, &desc,\n                                                   obj1, prop);\n                        JS_FreeValue(ctx, obj1);\n                        if (ret < 0) {\n                            JS_FreeValue(ctx, val);\n                            return ret;\n                        }\n                        if (ret) {\n                            if (desc.flags & JS_PROP_GETSET) {\n                                JSObject *setter;\n                                if (JS_IsUndefined(desc.setter))\n                                    setter = NULL;\n                                else\n                                    setter = JS_VALUE_GET_OBJ(desc.setter);\n                                ret = call_setter(ctx, setter, this_obj, val, flags);\n                                JS_FreeValue(ctx, desc.getter);\n                                JS_FreeValue(ctx, desc.setter);\n                                return ret;\n                            } else {\n                                JS_FreeValue(ctx, desc.value);\n                                if (!(desc.flags & JS_PROP_WRITABLE))\n                                    goto read_only_prop;\n                                if (likely(p == p1)) {\n                                    ret = JS_DefineProperty(ctx, this_obj, prop, val,\n                                                            JS_UNDEFINED, JS_UNDEFINED,\n                                                            JS_PROP_HAS_VALUE);\n                                    JS_FreeValue(ctx, val);\n                                    return ret;\n                                } else {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        p1 = p1->shape->proto;\n    prototype_lookup:\n        if (!p1)\n            break;\n\n    retry2:\n        prs = find_own_property(&pr, p1, prop);\n        if (prs) {\n            if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n                return call_setter(ctx, pr->u.getset.setter, this_obj, val, flags);\n            } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n                /* Instantiate property and retry (potentially useless) */\n                if (JS_AutoInitProperty(ctx, p1, prop, pr, prs))\n                    return -1;\n                goto retry2;\n            } else if (!(prs->flags & JS_PROP_WRITABLE)) {\n            read_only_prop:\n                JS_FreeValue(ctx, val);\n                return JS_ThrowTypeErrorReadOnly(ctx, flags, prop);\n            }\n        }\n    }\n\n    if (unlikely(flags & JS_PROP_NO_ADD)) {\n        JS_FreeValue(ctx, val);\n        JS_ThrowReferenceErrorNotDefined(ctx, prop);\n        return -1;\n    }\n\n    if (unlikely(!p)) {\n        JS_FreeValue(ctx, val);\n        return JS_ThrowTypeErrorOrFalse(ctx, flags, \"not an object\");\n    }\n\n    if (unlikely(!p->extensible)) {\n        JS_FreeValue(ctx, val);\n        return JS_ThrowTypeErrorOrFalse(ctx, flags, \"object is not extensible\");\n    }\n\n    if (p->is_exotic) {\n        if (p->class_id == JS_CLASS_ARRAY && p->fast_array &&\n            __JS_AtomIsTaggedInt(prop)) {\n            uint32_t idx = __JS_AtomToUInt32(prop);\n            if (idx == p->u.array.count) {\n                /* fast case */\n                return add_fast_array_element(ctx, p, val, flags);\n            } else {\n                goto generic_create_prop;\n            }\n        } else {\n        generic_create_prop:\n            ret = JS_CreateProperty(ctx, p, prop, val, JS_UNDEFINED, JS_UNDEFINED,\n                                    flags |\n                                    JS_PROP_HAS_VALUE |\n                                    JS_PROP_HAS_ENUMERABLE |\n                                    JS_PROP_HAS_WRITABLE |\n                                    JS_PROP_HAS_CONFIGURABLE |\n                                    JS_PROP_C_W_E);\n            JS_FreeValue(ctx, val);\n            return ret;\n        }\n    }\n\n    pr = add_property(ctx, p, prop, JS_PROP_C_W_E);\n    if (unlikely(!pr)) {\n        JS_FreeValue(ctx, val);\n        return -1;\n    }\n    pr->u.value = val;\n    return TRUE;\n}\n\n/* flags can be JS_PROP_THROW or JS_PROP_THROW_STRICT */\nstatic int JS_SetPropertyValue(JSContext *ctx, JSValueConst this_obj,\n                               JSValue prop, JSValue val, int flags)\n{\n    if (likely(JS_VALUE_GET_TAG(this_obj) == JS_TAG_OBJECT &&\n               JS_VALUE_GET_TAG(prop) == JS_TAG_INT)) {\n        JSObject *p;\n        uint32_t idx;\n        double d;\n        int32_t v;\n\n        /* fast path for array access */\n        p = JS_VALUE_GET_OBJ(this_obj);\n        idx = JS_VALUE_GET_INT(prop);\n        switch(p->class_id) {\n        case JS_CLASS_ARRAY:\n            if (unlikely(idx >= (uint32_t)p->u.array.count)) {\n                JSObject *p1;\n                JSShape *sh1;\n\n                /* fast path to add an element to the array */\n                if (idx != (uint32_t)p->u.array.count ||\n                    !p->fast_array || !p->extensible)\n                    goto slow_path;\n                /* check if prototype chain has a numeric property */\n                p1 = p->shape->proto;\n                while (p1 != NULL) {\n                    sh1 = p1->shape;\n                    if (p1->class_id == JS_CLASS_ARRAY) {\n                        if (unlikely(!p1->fast_array))\n                            goto slow_path;\n                    } else if (p1->class_id == JS_CLASS_OBJECT) {\n                        if (unlikely(sh1->has_small_array_index))\n                            goto slow_path;\n                    } else {\n                        goto slow_path;\n                    }\n                    p1 = sh1->proto;\n                }\n                /* add element */\n                return add_fast_array_element(ctx, p, val, flags);\n            }\n            set_value(ctx, &p->u.array.u.values[idx], val);\n            break;\n        case JS_CLASS_ARGUMENTS:\n            if (unlikely(idx >= (uint32_t)p->u.array.count))\n                goto slow_path;\n            set_value(ctx, &p->u.array.u.values[idx], val);\n            break;\n        case JS_CLASS_UINT8C_ARRAY:\n            if (JS_ToUint8ClampFree(ctx, &v, val))\n                return -1;\n            /* Note: the conversion can detach the typed array, so the\n               array bound check must be done after */\n            if (unlikely(idx >= (uint32_t)p->u.array.count))\n                goto ta_out_of_bound;\n            p->u.array.u.uint8_ptr[idx] = v;\n            break;\n        case JS_CLASS_INT8_ARRAY:\n        case JS_CLASS_UINT8_ARRAY:\n            if (JS_ToInt32Free(ctx, &v, val))\n                return -1;\n            if (unlikely(idx >= (uint32_t)p->u.array.count))\n                goto ta_out_of_bound;\n            p->u.array.u.uint8_ptr[idx] = v;\n            break;\n        case JS_CLASS_INT16_ARRAY:\n        case JS_CLASS_UINT16_ARRAY:\n            if (JS_ToInt32Free(ctx, &v, val))\n                return -1;\n            if (unlikely(idx >= (uint32_t)p->u.array.count))\n                goto ta_out_of_bound;\n            p->u.array.u.uint16_ptr[idx] = v;\n            break;\n        case JS_CLASS_INT32_ARRAY:\n        case JS_CLASS_UINT32_ARRAY:\n            if (JS_ToInt32Free(ctx, &v, val))\n                return -1;\n            if (unlikely(idx >= (uint32_t)p->u.array.count))\n                goto ta_out_of_bound;\n            p->u.array.u.uint32_ptr[idx] = v;\n            break;\n#ifdef CONFIG_BIGNUM\n        case JS_CLASS_BIG_INT64_ARRAY:\n        case JS_CLASS_BIG_UINT64_ARRAY:\n            /* XXX: need specific conversion function */\n            {\n                int64_t v;\n                if (JS_ToBigInt64Free(ctx, &v, val))\n                    return -1;\n                if (unlikely(idx >= (uint32_t)p->u.array.count))\n                    goto ta_out_of_bound;\n                p->u.array.u.uint64_ptr[idx] = v;\n            }\n            break;\n#endif\n        case JS_CLASS_FLOAT32_ARRAY:\n            if (JS_ToFloat64Free(ctx, &d, val))\n                return -1;\n            if (unlikely(idx >= (uint32_t)p->u.array.count))\n                goto ta_out_of_bound;\n            p->u.array.u.float_ptr[idx] = d;\n            break;\n        case JS_CLASS_FLOAT64_ARRAY:\n            if (JS_ToFloat64Free(ctx, &d, val))\n                return -1;\n            if (unlikely(idx >= (uint32_t)p->u.array.count)) {\n            ta_out_of_bound:\n                return JS_ThrowTypeErrorOrFalse(ctx, flags, \"out-of-bound numeric index\");\n            }\n            p->u.array.u.double_ptr[idx] = d;\n            break;\n        default:\n            goto slow_path;\n        }\n        return TRUE;\n    } else {\n        JSAtom atom;\n        int ret;\n    slow_path:\n        atom = JS_ValueToAtom(ctx, prop);\n        JS_FreeValue(ctx, prop);\n        if (unlikely(atom == JS_ATOM_NULL)) {\n            JS_FreeValue(ctx, val);\n            return -1;\n        }\n        ret = JS_SetPropertyInternal(ctx, this_obj, atom, val, flags);\n        JS_FreeAtom(ctx, atom);\n        return ret;\n    }\n}\n\nint JS_SetPropertyUint32(JSContext *ctx, JSValueConst this_obj,\n                         uint32_t idx, JSValue val)\n{\n    return JS_SetPropertyValue(ctx, this_obj, JS_NewUint32(ctx, idx), val,\n                               JS_PROP_THROW);\n}\n\nint JS_SetPropertyInt64(JSContext *ctx, JSValueConst this_obj,\n                        int64_t idx, JSValue val)\n{\n    JSAtom prop;\n    int res;\n\n    if ((uint64_t)idx <= INT32_MAX) {\n        /* fast path for fast arrays */\n        return JS_SetPropertyValue(ctx, this_obj, JS_NewInt32(ctx, idx), val,\n                                   JS_PROP_THROW);\n    }\n    prop = JS_NewAtomInt64(ctx, idx);\n    if (prop == JS_ATOM_NULL) {\n        JS_FreeValue(ctx, val);\n        return -1;\n    }\n    res = JS_SetProperty(ctx, this_obj, prop, val);\n    JS_FreeAtom(ctx, prop);\n    return res;\n}\n\nint JS_SetPropertyStr(JSContext *ctx, JSValueConst this_obj,\n                      const char *prop, JSValue val)\n{\n    JSAtom atom;\n    int ret;\n    atom = JS_NewAtom(ctx, prop);\n    ret = JS_SetPropertyInternal(ctx, this_obj, atom, val, JS_PROP_THROW);\n    JS_FreeAtom(ctx, atom);\n    return ret;\n}\n\n/* compute the property flags. For each flag: (JS_PROP_HAS_x forces\n   it, otherwise def_flags is used)\n   Note: makes assumption about the bit pattern of the flags\n*/\nstatic int get_prop_flags(int flags, int def_flags)\n{\n    int mask;\n    mask = (flags >> JS_PROP_HAS_SHIFT) & JS_PROP_C_W_E;\n    return (flags & mask) | (def_flags & ~mask);\n}\n\nstatic int JS_CreateProperty(JSContext *ctx, JSObject *p,\n                             JSAtom prop, JSValueConst val,\n                             JSValueConst getter, JSValueConst setter,\n                             int flags)\n{\n    JSProperty *pr;\n    int ret, prop_flags;\n\n    /* add a new property or modify an existing exotic one */\n    if (p->is_exotic) {\n        if (p->class_id == JS_CLASS_ARRAY) {\n            uint32_t idx, len;\n\n            if (p->fast_array) {\n                if (__JS_AtomIsTaggedInt(prop)) {\n                    idx = __JS_AtomToUInt32(prop);\n                    if (idx == p->u.array.count) {\n                        if (!p->extensible)\n                            goto not_extensible;\n                        if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET))\n                            goto convert_to_array;\n                        prop_flags = get_prop_flags(flags, 0);\n                        if (prop_flags != JS_PROP_C_W_E)\n                            goto convert_to_array;\n                        return add_fast_array_element(ctx, p,\n                                                      JS_DupValue(ctx, val), flags);\n                    } else {\n                        goto convert_to_array;\n                    }\n                } else if (JS_AtomIsArrayIndex(ctx, &idx, prop)) {\n                    /* convert the fast array to normal array */\n                convert_to_array:\n                    if (convert_fast_array_to_array(ctx, p))\n                        return -1;\n                    goto generic_array;\n                }\n            } else if (JS_AtomIsArrayIndex(ctx, &idx, prop)) {\n                JSProperty *plen;\n                JSShapeProperty *pslen;\n            generic_array:\n                /* update the length field */\n                plen = &p->prop[0];\n                JS_ToUint32(ctx, &len, plen->u.value);\n                if ((idx + 1) > len) {\n                    pslen = get_shape_prop(p->shape);\n                    if (unlikely(!(pslen->flags & JS_PROP_WRITABLE)))\n                        return JS_ThrowTypeErrorReadOnly(ctx, flags, JS_ATOM_length);\n                    /* XXX: should update the length after defining\n                       the property */\n                    len = idx + 1;\n                    set_value(ctx, &plen->u.value, JS_NewUint32(ctx, len));\n                }\n            }\n        } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n                   p->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n            ret = JS_AtomIsNumericIndex(ctx, prop);\n            if (ret != 0) {\n                if (ret < 0)\n                    return -1;\n                return JS_ThrowTypeErrorOrFalse(ctx, flags, \"cannot create numeric index in typed array\");\n            }\n        } else if (!(flags & JS_PROP_NO_EXOTIC)) {\n            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n            if (em) {\n                if (em->define_own_property) {\n                    return em->define_own_property(ctx, JS_MKPTR(JS_TAG_OBJECT, p),\n                                                   prop, val, getter, setter, flags);\n                }\n                ret = JS_IsExtensible(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n                if (ret < 0)\n                    return -1;\n                if (!ret)\n                    goto not_extensible;\n            }\n        }\n    }\n\n    if (!p->extensible) {\n    not_extensible:\n        return JS_ThrowTypeErrorOrFalse(ctx, flags, \"object is not extensible\");\n    }\n\n    if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {\n        prop_flags = (flags & (JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE)) |\n            JS_PROP_GETSET;\n    } else {\n        prop_flags = flags & JS_PROP_C_W_E;\n    }\n    pr = add_property(ctx, p, prop, prop_flags);\n    if (unlikely(!pr))\n        return -1;\n    if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {\n        pr->u.getset.getter = NULL;\n        if ((flags & JS_PROP_HAS_GET) && JS_IsFunction(ctx, getter)) {\n            pr->u.getset.getter =\n                JS_VALUE_GET_OBJ(JS_DupValue(ctx, getter));\n        }\n        pr->u.getset.setter = NULL;\n        if ((flags & JS_PROP_HAS_SET) && JS_IsFunction(ctx, setter)) {\n            pr->u.getset.setter =\n                JS_VALUE_GET_OBJ(JS_DupValue(ctx, setter));\n        }\n    } else {\n        if (flags & JS_PROP_HAS_VALUE) {\n            pr->u.value = JS_DupValue(ctx, val);\n        } else {\n            pr->u.value = JS_UNDEFINED;\n        }\n    }\n    return TRUE;\n}\n\n/* return FALSE if not OK */\nstatic BOOL check_define_prop_flags(int prop_flags, int flags)\n{\n    BOOL has_accessor, is_getset;\n\n    if (!(prop_flags & JS_PROP_CONFIGURABLE)) {\n        if ((flags & (JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE)) ==\n            (JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE)) {\n            return FALSE;\n        }\n        if ((flags & JS_PROP_HAS_ENUMERABLE) &&\n            (flags & JS_PROP_ENUMERABLE) != (prop_flags & JS_PROP_ENUMERABLE))\n            return FALSE;\n    }\n    if (flags & (JS_PROP_HAS_VALUE | JS_PROP_HAS_WRITABLE |\n                 JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {\n        if (!(prop_flags & JS_PROP_CONFIGURABLE)) {\n            has_accessor = ((flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) != 0);\n            is_getset = ((prop_flags & JS_PROP_TMASK) == JS_PROP_GETSET);\n            if (has_accessor != is_getset)\n                return FALSE;\n            if (!has_accessor && !is_getset && !(prop_flags & JS_PROP_WRITABLE)) {\n                /* not writable: cannot set the writable bit */\n                if ((flags & (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE)) ==\n                    (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE))\n                    return FALSE;\n            }\n        }\n    }\n    return TRUE;\n}\n\n/* ensure that the shape can be safely modified */\nstatic int js_shape_prepare_update(JSContext *ctx, JSObject *p,\n                                   JSShapeProperty **pprs)\n{\n    JSShape *sh;\n    uint32_t idx = 0;    /* prevent warning */\n\n    sh = p->shape;\n    if (sh->is_hashed) {\n        if (sh->header.ref_count != 1) {\n            if (pprs)\n                idx = *pprs - get_shape_prop(sh);\n            /* clone the shape (the resulting one is no longer hashed) */\n            sh = js_clone_shape(ctx, sh);\n            if (!sh)\n                return -1;\n            js_free_shape(ctx->rt, p->shape);\n            p->shape = sh;\n            if (pprs)\n                *pprs = get_shape_prop(sh) + idx;\n        } else {\n            js_shape_hash_unlink(ctx->rt, sh);\n            sh->is_hashed = FALSE;\n        }\n    }\n    return 0;\n}\n\nstatic int js_update_property_flags(JSContext *ctx, JSObject *p,\n                                    JSShapeProperty **pprs, int flags)\n{\n    if (flags != (*pprs)->flags) {\n        if (js_shape_prepare_update(ctx, p, pprs))\n            return -1;\n        (*pprs)->flags = flags;\n    }\n    return 0;\n}\n\n/* allowed flags:\n   JS_PROP_CONFIGURABLE, JS_PROP_WRITABLE, JS_PROP_ENUMERABLE\n   JS_PROP_HAS_GET, JS_PROP_HAS_SET, JS_PROP_HAS_VALUE,\n   JS_PROP_HAS_CONFIGURABLE, JS_PROP_HAS_WRITABLE, JS_PROP_HAS_ENUMERABLE,\n   JS_PROP_THROW, JS_PROP_NO_EXOTIC.\n   If JS_PROP_THROW is set, return an exception instead of FALSE.\n   if JS_PROP_NO_EXOTIC is set, do not call the exotic\n   define_own_property callback.\n   return -1 (exception), FALSE or TRUE.\n*/\nint JS_DefineProperty(JSContext *ctx, JSValueConst this_obj,\n                      JSAtom prop, JSValueConst val,\n                      JSValueConst getter, JSValueConst setter, int flags)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    int mask, res;\n\n    if (JS_VALUE_GET_TAG(this_obj) != JS_TAG_OBJECT) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        return -1;\n    }\n    p = JS_VALUE_GET_OBJ(this_obj);\n\n redo_prop_update:\n    prs = find_own_property(&pr, p, prop);\n    if (prs) {\n        /* the range of the Array length property is always tested before */\n        if ((prs->flags & JS_PROP_LENGTH) && (flags & JS_PROP_HAS_VALUE)) {\n            uint32_t array_length;\n            if (JS_ToArrayLengthFree(ctx, &array_length,\n                                     JS_DupValue(ctx, val), FALSE)) {\n                return -1;\n            }\n            /* this code relies on the fact that Uint32 are never allocated */\n            val = (JSValueConst)JS_NewUint32(ctx, array_length);\n            /* prs may have been modified */\n            prs = find_own_property(&pr, p, prop);\n            assert(prs != NULL);\n        }\n        /* property already exists */\n        if (!check_define_prop_flags(prs->flags, flags)) {\n        not_configurable:\n            return JS_ThrowTypeErrorOrFalse(ctx, flags, \"property is not configurable\");\n        }\n\n        if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n            /* Instantiate property and retry */\n            if (JS_AutoInitProperty(ctx, p, prop, pr, prs))\n                return -1;\n            goto redo_prop_update;\n        }\n\n        if (flags & (JS_PROP_HAS_VALUE | JS_PROP_HAS_WRITABLE |\n                     JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {\n            if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {\n                JSObject *new_getter, *new_setter;\n\n                if (JS_IsFunction(ctx, getter)) {\n                    new_getter = JS_VALUE_GET_OBJ(getter);\n                } else {\n                    new_getter = NULL;\n                }\n                if (JS_IsFunction(ctx, setter)) {\n                    new_setter = JS_VALUE_GET_OBJ(setter);\n                } else {\n                    new_setter = NULL;\n                }\n\n                if ((prs->flags & JS_PROP_TMASK) != JS_PROP_GETSET) {\n                    if (js_shape_prepare_update(ctx, p, &prs))\n                        return -1;\n                    /* convert to getset */\n                    if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n                        free_var_ref(ctx->rt, pr->u.var_ref);\n                    } else {\n                        JS_FreeValue(ctx, pr->u.value);\n                    }\n                    prs->flags = (prs->flags &\n                                  (JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE)) |\n                        JS_PROP_GETSET;\n                    pr->u.getset.getter = NULL;\n                    pr->u.getset.setter = NULL;\n                } else {\n                    if (!(prs->flags & JS_PROP_CONFIGURABLE)) {\n                        if ((flags & JS_PROP_HAS_GET) &&\n                            new_getter != pr->u.getset.getter) {\n                            goto not_configurable;\n                        }\n                        if ((flags & JS_PROP_HAS_SET) &&\n                            new_setter != pr->u.getset.setter) {\n                            goto not_configurable;\n                        }\n                    }\n                }\n                if (flags & JS_PROP_HAS_GET) {\n                    if (pr->u.getset.getter)\n                        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter));\n                    if (new_getter)\n                        JS_DupValue(ctx, getter);\n                    pr->u.getset.getter = new_getter;\n                }\n                if (flags & JS_PROP_HAS_SET) {\n                    if (pr->u.getset.setter)\n                        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.setter));\n                    if (new_setter)\n                        JS_DupValue(ctx, setter);\n                    pr->u.getset.setter = new_setter;\n                }\n            } else {\n                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n                    /* convert to data descriptor */\n                    if (js_shape_prepare_update(ctx, p, &prs))\n                        return -1;\n                    if (pr->u.getset.getter)\n                        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter));\n                    if (pr->u.getset.setter)\n                        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.setter));\n                    prs->flags &= ~(JS_PROP_TMASK | JS_PROP_WRITABLE);\n                    pr->u.value = JS_UNDEFINED;\n                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n                    /* Note: JS_PROP_VARREF is always writable */\n                } else {\n                    if ((prs->flags & (JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE)) == 0 &&\n                        (flags & JS_PROP_HAS_VALUE)) {\n                        if (!js_same_value(ctx, val, pr->u.value)) {\n                            goto not_configurable;\n                        } else {\n                            return TRUE;\n                        }\n                    }\n                }\n                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n                    if (flags & JS_PROP_HAS_VALUE) {\n                        if (p->class_id == JS_CLASS_MODULE_NS) {\n                            /* JS_PROP_WRITABLE is always true for variable\n                               references, but they are write protected in module name\n                               spaces. */\n                            if (!js_same_value(ctx, val, *pr->u.var_ref->pvalue))\n                                goto not_configurable;\n                        }\n                        /* update the reference */\n                        set_value(ctx, pr->u.var_ref->pvalue,\n                                  JS_DupValue(ctx, val));\n                    }\n                    /* if writable is set to false, no longer a\n                       reference (for mapped arguments) */\n                    if ((flags & (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE)) == JS_PROP_HAS_WRITABLE) {\n                        JSValue val1;\n                        if (js_shape_prepare_update(ctx, p, &prs))\n                            return -1;\n                        val1 = JS_DupValue(ctx, *pr->u.var_ref->pvalue);\n                        free_var_ref(ctx->rt, pr->u.var_ref);\n                        pr->u.value = val1;\n                        prs->flags &= ~(JS_PROP_TMASK | JS_PROP_WRITABLE);\n                    }\n                } else if (prs->flags & JS_PROP_LENGTH) {\n                    if (flags & JS_PROP_HAS_VALUE) {\n                        /* Note: no JS code is executable because\n                           'val' is guaranted to be a Uint32 */\n                        res = set_array_length(ctx, p, JS_DupValue(ctx, val),\n                                               flags);\n                    } else {\n                        res = TRUE;\n                    }\n                    /* still need to reset the writable flag if\n                       needed.  The JS_PROP_LENGTH is kept because the\n                       Uint32 test is still done if the length\n                       property is read-only. */\n                    if ((flags & (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE)) ==\n                        JS_PROP_HAS_WRITABLE) {\n                        prs = get_shape_prop(p->shape);\n                        if (js_update_property_flags(ctx, p, &prs,\n                                                     prs->flags & ~JS_PROP_WRITABLE))\n                            return -1;\n                    }\n                    return res;\n                } else {\n                    if (flags & JS_PROP_HAS_VALUE) {\n                        JS_FreeValue(ctx, pr->u.value);\n                        pr->u.value = JS_DupValue(ctx, val);\n                    }\n                    if (flags & JS_PROP_HAS_WRITABLE) {\n                        if (js_update_property_flags(ctx, p, &prs,\n                                                     (prs->flags & ~JS_PROP_WRITABLE) |\n                                                     (flags & JS_PROP_WRITABLE)))\n                            return -1;\n                    }\n                }\n            }\n        }\n        mask = 0;\n        if (flags & JS_PROP_HAS_CONFIGURABLE)\n            mask |= JS_PROP_CONFIGURABLE;\n        if (flags & JS_PROP_HAS_ENUMERABLE)\n            mask |= JS_PROP_ENUMERABLE;\n        if (js_update_property_flags(ctx, p, &prs,\n                                     (prs->flags & ~mask) | (flags & mask)))\n            return -1;\n        return TRUE;\n    }\n\n    /* handle modification of fast array elements */\n    if (p->fast_array) {\n        uint32_t idx;\n        uint32_t prop_flags;\n        if (p->class_id == JS_CLASS_ARRAY) {\n            if (__JS_AtomIsTaggedInt(prop)) {\n                idx = __JS_AtomToUInt32(prop);\n                if (idx < p->u.array.count) {\n                    prop_flags = get_prop_flags(flags, JS_PROP_C_W_E);\n                    if (prop_flags != JS_PROP_C_W_E)\n                        goto convert_to_slow_array;\n                    if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {\n                    convert_to_slow_array:\n                        if (convert_fast_array_to_array(ctx, p))\n                            return -1;\n                        else\n                            goto redo_prop_update;\n                    }\n                    if (flags & JS_PROP_HAS_VALUE) {\n                        set_value(ctx, &p->u.array.u.values[idx], JS_DupValue(ctx, val));\n                    }\n                    return TRUE;\n                }\n            }\n        } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n                   p->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n            JSValue num;\n            int ret;\n\n            if (!__JS_AtomIsTaggedInt(prop)) {\n                /* slow path with to handle all numeric indexes */\n                num = JS_AtomIsNumericIndex1(ctx, prop);\n                if (JS_IsUndefined(num))\n                    goto typed_array_done;\n                if (JS_IsException(num))\n                    return -1;\n                ret = JS_NumberIsInteger(ctx, num);\n                if (ret < 0) {\n                    JS_FreeValue(ctx, num);\n                    return -1;\n                }\n                if (!ret) {\n                    JS_FreeValue(ctx, num);\n                    return JS_ThrowTypeErrorOrFalse(ctx, flags, \"non integer index in typed array\");\n                }\n                ret = JS_NumberIsNegativeOrMinusZero(ctx, num);\n                JS_FreeValue(ctx, num);\n                if (ret) {\n                    return JS_ThrowTypeErrorOrFalse(ctx, flags, \"negative index in typed array\");\n                }\n                if (!__JS_AtomIsTaggedInt(prop))\n                    goto typed_array_oob;\n            }\n            idx = __JS_AtomToUInt32(prop);\n            /* if the typed array is detached, p->u.array.count = 0 */\n            if (idx >= typed_array_get_length(ctx, p)) {\n            typed_array_oob:\n                return JS_ThrowTypeErrorOrFalse(ctx, flags, \"out-of-bound index in typed array\");\n            }\n            prop_flags = get_prop_flags(flags, JS_PROP_ENUMERABLE | JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n            if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET) ||\n                prop_flags != (JS_PROP_ENUMERABLE | JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE)) {\n                return JS_ThrowTypeErrorOrFalse(ctx, flags, \"invalid descriptor flags\");\n            }\n            if (flags & JS_PROP_HAS_VALUE) {\n                return JS_SetPropertyValue(ctx, this_obj, JS_NewInt32(ctx, idx), JS_DupValue(ctx, val), flags);\n            }\n            return TRUE;\n        typed_array_done: ;\n        }\n    }\n\n    return JS_CreateProperty(ctx, p, prop, val, getter, setter, flags);\n}\n\nstatic int JS_DefineAutoInitProperty(JSContext *ctx, JSValueConst this_obj,\n                                     JSAtom prop, JSAutoInitIDEnum id,\n                                     void *opaque, int flags)\n{\n    JSObject *p;\n    JSProperty *pr;\n\n    if (JS_VALUE_GET_TAG(this_obj) != JS_TAG_OBJECT)\n        return FALSE;\n\n    p = JS_VALUE_GET_OBJ(this_obj);\n\n    if (find_own_property(&pr, p, prop)) {\n        /* property already exists */\n        abort();\n        return FALSE;\n    }\n\n    /* Specialized CreateProperty */\n    pr = add_property(ctx, p, prop, (flags & JS_PROP_C_W_E) | JS_PROP_AUTOINIT);\n    if (unlikely(!pr))\n        return -1;\n    pr->u.init.realm_and_id = (uintptr_t)JS_DupContext(ctx);\n    assert((pr->u.init.realm_and_id & 3) == 0);\n    assert(id <= 3);\n    pr->u.init.realm_and_id |= id;\n    pr->u.init.opaque = opaque;\n    return TRUE;\n}\n\n/* shortcut to add or redefine a new property value */\nint JS_DefinePropertyValue(JSContext *ctx, JSValueConst this_obj,\n                           JSAtom prop, JSValue val, int flags)\n{\n    int ret;\n    ret = JS_DefineProperty(ctx, this_obj, prop, val, JS_UNDEFINED, JS_UNDEFINED,\n                            flags | JS_PROP_HAS_VALUE | JS_PROP_HAS_CONFIGURABLE | JS_PROP_HAS_WRITABLE | JS_PROP_HAS_ENUMERABLE);\n    JS_FreeValue(ctx, val);\n    return ret;\n}\n\nint JS_DefinePropertyValueValue(JSContext *ctx, JSValueConst this_obj,\n                                JSValue prop, JSValue val, int flags)\n{\n    JSAtom atom;\n    int ret;\n    atom = JS_ValueToAtom(ctx, prop);\n    JS_FreeValue(ctx, prop);\n    if (unlikely(atom == JS_ATOM_NULL)) {\n        JS_FreeValue(ctx, val);\n        return -1;\n    }\n    ret = JS_DefinePropertyValue(ctx, this_obj, atom, val, flags);\n    JS_FreeAtom(ctx, atom);\n    return ret;\n}\n\nint JS_DefinePropertyValueUint32(JSContext *ctx, JSValueConst this_obj,\n                                 uint32_t idx, JSValue val, int flags)\n{\n    return JS_DefinePropertyValueValue(ctx, this_obj, JS_NewUint32(ctx, idx),\n                                       val, flags);\n}\n\nint JS_DefinePropertyValueInt64(JSContext *ctx, JSValueConst this_obj,\n                                int64_t idx, JSValue val, int flags)\n{\n    return JS_DefinePropertyValueValue(ctx, this_obj, JS_NewInt64(ctx, idx),\n                                       val, flags);\n}\n\nint JS_DefinePropertyValueStr(JSContext *ctx, JSValueConst this_obj,\n                              const char *prop, JSValue val, int flags)\n{\n    JSAtom atom;\n    int ret;\n    atom = JS_NewAtom(ctx, prop);\n    ret = JS_DefinePropertyValue(ctx, this_obj, atom, val, flags);\n    JS_FreeAtom(ctx, atom);\n    return ret;\n}\n\n/* shortcut to add getter & setter */\nint JS_DefinePropertyGetSet(JSContext *ctx, JSValueConst this_obj,\n                            JSAtom prop, JSValue getter, JSValue setter,\n                            int flags)\n{\n    int ret;\n    ret = JS_DefineProperty(ctx, this_obj, prop, JS_UNDEFINED, getter, setter,\n                            flags | JS_PROP_HAS_GET | JS_PROP_HAS_SET |\n                            JS_PROP_HAS_CONFIGURABLE | JS_PROP_HAS_ENUMERABLE);\n    JS_FreeValue(ctx, getter);\n    JS_FreeValue(ctx, setter);\n    return ret;\n}\n\nstatic int JS_CreateDataPropertyUint32(JSContext *ctx, JSValueConst this_obj,\n                                       int64_t idx, JSValue val, int flags)\n{\n    return JS_DefinePropertyValueValue(ctx, this_obj, JS_NewInt64(ctx, idx),\n                                       val, flags | JS_PROP_CONFIGURABLE |\n                                       JS_PROP_ENUMERABLE | JS_PROP_WRITABLE);\n}\n\n\n/* return TRUE if 'obj' has a non empty 'name' string */\nstatic BOOL js_object_has_name(JSContext *ctx, JSValueConst obj)\n{\n    JSProperty *pr;\n    JSShapeProperty *prs;\n    JSValueConst val;\n    JSString *p;\n    \n    prs = find_own_property(&pr, JS_VALUE_GET_OBJ(obj), JS_ATOM_name);\n    if (!prs)\n        return FALSE;\n    if ((prs->flags & JS_PROP_TMASK) != JS_PROP_NORMAL)\n        return TRUE;\n    val = pr->u.value;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_STRING)\n        return TRUE;\n    p = JS_VALUE_GET_STRING(val);\n    return (p->len != 0);\n}\n\nstatic int JS_DefineObjectName(JSContext *ctx, JSValueConst obj,\n                               JSAtom name, int flags)\n{\n    if (name != JS_ATOM_NULL\n    &&  JS_IsObject(obj)\n    &&  !js_object_has_name(ctx, obj)\n    &&  JS_DefinePropertyValue(ctx, obj, JS_ATOM_name, JS_AtomToString(ctx, name), flags) < 0) {\n        return -1;\n    }\n    return 0;\n}\n\nstatic int JS_DefineObjectNameComputed(JSContext *ctx, JSValueConst obj,\n                                       JSValueConst str, int flags)\n{\n    if (JS_IsObject(obj) &&\n        !js_object_has_name(ctx, obj)) {\n        JSAtom prop;\n        JSValue name_str;\n        prop = JS_ValueToAtom(ctx, str);\n        if (prop == JS_ATOM_NULL)\n            return -1;\n        name_str = js_get_function_name(ctx, prop);\n        JS_FreeAtom(ctx, prop);\n        if (JS_IsException(name_str))\n            return -1;\n        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_name, name_str, flags) < 0)\n            return -1;\n    }\n    return 0;\n}\n\n#define DEFINE_GLOBAL_LEX_VAR (1 << 7)\n#define DEFINE_GLOBAL_FUNC_VAR (1 << 6)\n\nstatic JSValue JS_ThrowSyntaxErrorVarRedeclaration(JSContext *ctx, JSAtom prop)\n{\n    return JS_ThrowSyntaxErrorAtom(ctx, \"redeclaration of '%s'\", prop);\n}\n\n/* flags is 0, DEFINE_GLOBAL_LEX_VAR or DEFINE_GLOBAL_FUNC_VAR */\n/* XXX: could support exotic global object. */\nstatic int JS_CheckDefineGlobalVar(JSContext *ctx, JSAtom prop, int flags)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n\n    p = JS_VALUE_GET_OBJ(ctx->global_obj);\n    prs = find_own_property1(p, prop);\n    /* XXX: should handle JS_PROP_AUTOINIT */\n    if (flags & DEFINE_GLOBAL_LEX_VAR) {\n        if (prs && !(prs->flags & JS_PROP_CONFIGURABLE))\n            goto fail_redeclaration;\n    } else {\n        if (!prs && !p->extensible)\n            goto define_error;\n        if (flags & DEFINE_GLOBAL_FUNC_VAR) {\n            if (prs) {\n                if (!(prs->flags & JS_PROP_CONFIGURABLE) &&\n                    ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET ||\n                     ((prs->flags & (JS_PROP_WRITABLE | JS_PROP_ENUMERABLE)) !=\n                      (JS_PROP_WRITABLE | JS_PROP_ENUMERABLE)))) {\n                define_error:\n                    JS_ThrowTypeErrorAtom(ctx, \"cannot define variable '%s'\",\n                                          prop);\n                    return -1;\n                }\n            }\n        }\n    }\n    /* check if there already is a lexical declaration */\n    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);\n    prs = find_own_property1(p, prop);\n    if (prs) {\n    fail_redeclaration:\n        JS_ThrowSyntaxErrorVarRedeclaration(ctx, prop);\n        return -1;\n    }\n    return 0;\n}\n\n/* def_flags is (0, DEFINE_GLOBAL_LEX_VAR) |\n   JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE */\n/* XXX: could support exotic global object. */\nstatic int JS_DefineGlobalVar(JSContext *ctx, JSAtom prop, int def_flags)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    JSValue val;\n    int flags;\n\n    if (def_flags & DEFINE_GLOBAL_LEX_VAR) {\n        p = JS_VALUE_GET_OBJ(ctx->global_var_obj);\n        flags = JS_PROP_ENUMERABLE | (def_flags & JS_PROP_WRITABLE) |\n            JS_PROP_CONFIGURABLE;\n        val = JS_UNINITIALIZED;\n    } else {\n        p = JS_VALUE_GET_OBJ(ctx->global_obj);\n        flags = JS_PROP_ENUMERABLE | JS_PROP_WRITABLE |\n            (def_flags & JS_PROP_CONFIGURABLE);\n        val = JS_UNDEFINED;\n    }\n    prs = find_own_property1(p, prop);\n    if (prs)\n        return 0;\n    if (!p->extensible)\n        return 0;\n    pr = add_property(ctx, p, prop, flags);\n    if (unlikely(!pr))\n        return -1;\n    pr->u.value = val;\n    return 0;\n}\n\n/* 'def_flags' is 0 or JS_PROP_CONFIGURABLE. */\n/* XXX: could support exotic global object. */\nstatic int JS_DefineGlobalFunction(JSContext *ctx, JSAtom prop,\n                                   JSValueConst func, int def_flags)\n{\n\n    JSObject *p;\n    JSShapeProperty *prs;\n    int flags;\n\n    p = JS_VALUE_GET_OBJ(ctx->global_obj);\n    prs = find_own_property1(p, prop);\n    flags = JS_PROP_HAS_VALUE | JS_PROP_THROW;\n    if (!prs || (prs->flags & JS_PROP_CONFIGURABLE)) {\n        flags |= JS_PROP_ENUMERABLE | JS_PROP_WRITABLE | def_flags |\n            JS_PROP_HAS_CONFIGURABLE | JS_PROP_HAS_WRITABLE | JS_PROP_HAS_ENUMERABLE;\n    }\n    if (JS_DefineProperty(ctx, ctx->global_obj, prop, func,\n                          JS_UNDEFINED, JS_UNDEFINED, flags) < 0)\n        return -1;\n    return 0;\n}\n\nstatic JSValue JS_GetGlobalVar(JSContext *ctx, JSAtom prop,\n                               BOOL throw_ref_error)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n\n    /* no exotic behavior is possible in global_var_obj */\n    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);\n    prs = find_own_property(&pr, p, prop);\n    if (prs) {\n        /* XXX: should handle JS_PROP_TMASK properties */\n        if (unlikely(JS_IsUninitialized(pr->u.value)))\n            return JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);\n        return JS_DupValue(ctx, pr->u.value);\n    }\n    return JS_GetPropertyInternal(ctx, ctx->global_obj, prop,\n                                 ctx->global_obj, throw_ref_error);\n}\n\n/* construct a reference to a global variable */\nstatic int JS_GetGlobalVarRef(JSContext *ctx, JSAtom prop, JSValue *sp)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n\n    /* no exotic behavior is possible in global_var_obj */\n    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);\n    prs = find_own_property(&pr, p, prop);\n    if (prs) {\n        /* XXX: should handle JS_PROP_AUTOINIT properties? */\n        /* XXX: conformance: do these tests in\n           OP_put_var_ref/OP_get_var_ref ? */\n        if (unlikely(JS_IsUninitialized(pr->u.value))) {\n            JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);\n            return -1;\n        }\n        if (unlikely(!(prs->flags & JS_PROP_WRITABLE))) {\n            return JS_ThrowTypeErrorReadOnly(ctx, JS_PROP_THROW, prop);\n        }\n        sp[0] = JS_DupValue(ctx, ctx->global_var_obj);\n    } else {\n        int ret;\n        ret = JS_HasProperty(ctx, ctx->global_obj, prop);\n        if (ret < 0)\n            return -1;\n        if (ret) {\n            sp[0] = JS_DupValue(ctx, ctx->global_obj);\n        } else {\n            sp[0] = JS_UNDEFINED;\n        }\n    }\n    sp[1] = JS_AtomToValue(ctx, prop);\n    return 0;\n}\n\n/* use for strict variable access: test if the variable exists */\nstatic int JS_CheckGlobalVar(JSContext *ctx, JSAtom prop)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    int ret;\n\n    /* no exotic behavior is possible in global_var_obj */\n    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);\n    prs = find_own_property1(p, prop);\n    if (prs) {\n        ret = TRUE;\n    } else {\n        ret = JS_HasProperty(ctx, ctx->global_obj, prop);\n        if (ret < 0)\n            return -1;\n    }\n    return ret;\n}\n\n/* flag = 0: normal variable write\n   flag = 1: initialize lexical variable\n   flag = 2: normal variable write, strict check was done before\n*/\nstatic int JS_SetGlobalVar(JSContext *ctx, JSAtom prop, JSValue val,\n                           int flag)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    int flags;\n\n    /* no exotic behavior is possible in global_var_obj */\n    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);\n    prs = find_own_property(&pr, p, prop);\n    if (prs) {\n        /* XXX: should handle JS_PROP_AUTOINIT properties? */\n        if (flag != 1) {\n            if (unlikely(JS_IsUninitialized(pr->u.value))) {\n                JS_FreeValue(ctx, val);\n                JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);\n                return -1;\n            }\n            if (unlikely(!(prs->flags & JS_PROP_WRITABLE))) {\n                JS_FreeValue(ctx, val);\n                return JS_ThrowTypeErrorReadOnly(ctx, JS_PROP_THROW, prop);\n            }\n        }\n        set_value(ctx, &pr->u.value, val);\n        return 0;\n    }\n    flags = JS_PROP_THROW_STRICT;\n    if (is_strict_mode(ctx)) \n        flags |= JS_PROP_NO_ADD;\n    return JS_SetPropertyInternal(ctx, ctx->global_obj, prop, val, flags);\n}\n\n/* return -1, FALSE or TRUE. return FALSE if not configurable or\n   invalid object. return -1 in case of exception.\n   flags can be 0, JS_PROP_THROW or JS_PROP_THROW_STRICT */\nint JS_DeleteProperty(JSContext *ctx, JSValueConst obj, JSAtom prop, int flags)\n{\n    JSValue obj1;\n    JSObject *p;\n    int res;\n    \n    obj1 = JS_ToObject(ctx, obj);\n    if (JS_IsException(obj1))\n        return -1;\n    p = JS_VALUE_GET_OBJ(obj1);\n    res = delete_property(ctx, p, prop);\n    JS_FreeValue(ctx, obj1);\n    if (res != FALSE)\n        return res;\n    if ((flags & JS_PROP_THROW) ||\n        ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {\n        JS_ThrowTypeError(ctx, \"could not delete property\");\n        return -1;\n    }\n    return FALSE;\n}\n\nint JS_DeletePropertyInt64(JSContext *ctx, JSValueConst obj, int64_t idx, int flags)\n{\n    JSAtom prop;\n    int res;\n\n    if ((uint64_t)idx <= JS_ATOM_MAX_INT) {\n        /* fast path for fast arrays */\n        return JS_DeleteProperty(ctx, obj, __JS_AtomFromUInt32(idx), flags);\n    }\n    prop = JS_NewAtomInt64(ctx, idx);\n    if (prop == JS_ATOM_NULL)\n        return -1;\n    res = JS_DeleteProperty(ctx, obj, prop, flags);\n    JS_FreeAtom(ctx, prop);\n    return res;\n}\n\nBOOL JS_IsFunction(JSContext *ctx, JSValueConst val)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(val);\n    switch(p->class_id) {\n    case JS_CLASS_BYTECODE_FUNCTION:\n        return TRUE;\n    case JS_CLASS_PROXY:\n        return p->u.proxy_data->is_func;\n    default:\n        return (ctx->rt->class_array[p->class_id].call != NULL);\n    }\n}\n\nBOOL JS_IsCFunction(JSContext *ctx, JSValueConst val, JSCFunction *func, int magic)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(val);\n    if (p->class_id == JS_CLASS_C_FUNCTION)\n        return (p->u.cfunc.c_function.generic == func && p->u.cfunc.magic == magic);\n    else\n        return FALSE;\n}\n\nBOOL JS_IsConstructor(JSContext *ctx, JSValueConst val)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(val);\n    return p->is_constructor;\n}\n\nBOOL JS_SetConstructorBit(JSContext *ctx, JSValueConst func_obj, BOOL val)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(func_obj);\n    p->is_constructor = val;\n    return TRUE;\n}\n\nBOOL JS_IsError(JSContext *ctx, JSValueConst val)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(val);\n    return (p->class_id == JS_CLASS_ERROR);\n}\n\n/* used to avoid catching interrupt exceptions */\nBOOL JS_IsUncatchableError(JSContext *ctx, JSValueConst val)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(val);\n    return p->class_id == JS_CLASS_ERROR && p->is_uncatchable_error;\n}\n\nvoid JS_SetUncatchableError(JSContext *ctx, JSValueConst val, BOOL flag)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return;\n    p = JS_VALUE_GET_OBJ(val);\n    if (p->class_id == JS_CLASS_ERROR)\n        p->is_uncatchable_error = flag;\n}\n\nvoid JS_ResetUncatchableError(JSContext *ctx)\n{\n    JS_SetUncatchableError(ctx, ctx->rt->current_exception, FALSE);\n}\n\nJSValue JS_NewUncatchableError(JSContext *ctx)\n{\n    JSValue obj;\n\n    obj = JS_NewError(ctx);\n    JS_SetUncatchableError(ctx, obj, TRUE);\n    return obj;\n}\n\nvoid JS_SetOpaque(JSValue obj, void *opaque)\n{\n   JSObject *p;\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        p = JS_VALUE_GET_OBJ(obj);\n        p->u.opaque = opaque;\n    }\n}\n\n/* return NULL if not an object of class class_id */\nvoid *JS_GetOpaque(JSValueConst obj, JSClassID class_id)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return NULL;\n    p = JS_VALUE_GET_OBJ(obj);\n    if (p->class_id != class_id)\n        return NULL;\n    return p->u.opaque;\n}\n\nvoid *JS_GetOpaque2(JSContext *ctx, JSValueConst obj, JSClassID class_id)\n{\n    void *p = JS_GetOpaque(obj, class_id);\n    if (unlikely(!p)) {\n        JS_ThrowTypeErrorInvalidClass(ctx, class_id);\n    }\n    return p;\n}\n\n#define HINT_STRING  0\n#define HINT_NUMBER  1\n#define HINT_NONE    2\n/* don't try Symbol.toPrimitive */\n#define HINT_FORCE_ORDINARY (1 << 4)\n\nstatic JSValue JS_ToPrimitiveFree(JSContext *ctx, JSValue val, int hint)\n{\n    int i;\n    BOOL force_ordinary;\n\n    JSAtom method_name;\n    JSValue method, ret;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return val;\n    force_ordinary = hint & HINT_FORCE_ORDINARY;\n    hint &= ~HINT_FORCE_ORDINARY;\n    if (!force_ordinary) {\n        method = JS_GetProperty(ctx, val, JS_ATOM_Symbol_toPrimitive);\n        if (JS_IsException(method))\n            goto exception;\n        /* ECMA says *If exoticToPrim is not undefined* but tests in\n           test262 use null as a non callable converter */\n        if (!JS_IsUndefined(method) && !JS_IsNull(method)) {\n            JSAtom atom;\n            JSValue arg;\n            switch(hint) {\n            case HINT_STRING:\n                atom = JS_ATOM_string;\n                break;\n            case HINT_NUMBER:\n                atom = JS_ATOM_number;\n                break;\n            default:\n            case HINT_NONE:\n                atom = JS_ATOM_default;\n                break;\n            }\n            arg = JS_AtomToString(ctx, atom);\n            ret = JS_CallFree(ctx, method, val, 1, (JSValueConst *)&arg);\n            JS_FreeValue(ctx, arg);\n            if (JS_IsException(ret))\n                goto exception;\n            JS_FreeValue(ctx, val);\n            if (JS_VALUE_GET_TAG(ret) != JS_TAG_OBJECT)\n                return ret;\n            JS_FreeValue(ctx, ret);\n            return JS_ThrowTypeError(ctx, \"toPrimitive\");\n        }\n    }\n    if (hint != HINT_STRING)\n        hint = HINT_NUMBER;\n    for(i = 0; i < 2; i++) {\n        if ((i ^ hint) == 0) {\n            method_name = JS_ATOM_toString;\n        } else {\n            method_name = JS_ATOM_valueOf;\n        }\n        method = JS_GetProperty(ctx, val, method_name);\n        if (JS_IsException(method))\n            goto exception;\n        if (JS_IsFunction(ctx, method)) {\n            ret = JS_CallFree(ctx, method, val, 0, NULL);\n            if (JS_IsException(ret))\n                goto exception;\n            if (JS_VALUE_GET_TAG(ret) != JS_TAG_OBJECT) {\n                JS_FreeValue(ctx, val);\n                return ret;\n            }\n            JS_FreeValue(ctx, ret);\n        } else {\n            JS_FreeValue(ctx, method);\n        }\n    }\n    JS_ThrowTypeError(ctx, \"toPrimitive\");\nexception:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ToPrimitive(JSContext *ctx, JSValueConst val, int hint)\n{\n    return JS_ToPrimitiveFree(ctx, JS_DupValue(ctx, val), hint);\n}\n\nvoid JS_SetIsHTMLDDA(JSContext *ctx, JSValueConst obj)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return;\n    p = JS_VALUE_GET_OBJ(obj);\n    p->is_HTMLDDA = TRUE;\n}\n\nstatic inline BOOL JS_IsHTMLDDA(JSContext *ctx, JSValueConst obj)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(obj);\n    return p->is_HTMLDDA;\n}\n                         \nstatic int JS_ToBoolFree(JSContext *ctx, JSValue val)\n{\n    uint32_t tag = JS_VALUE_GET_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n        return JS_VALUE_GET_INT(val) != 0;\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        return JS_VALUE_GET_INT(val);\n    case JS_TAG_EXCEPTION:\n        return -1;\n    case JS_TAG_STRING:\n        {\n            BOOL ret = JS_VALUE_GET_STRING(val)->len != 0;\n            JS_FreeValue(ctx, val);\n            return ret;\n        }\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            BOOL ret;\n            ret = p->num.expn != BF_EXP_ZERO && p->num.expn != BF_EXP_NAN;\n            JS_FreeValue(ctx, val);\n            return ret;\n        }\n    case JS_TAG_BIG_DECIMAL:\n        {\n            JSBigDecimal *p = JS_VALUE_GET_PTR(val);\n            BOOL ret;\n            ret = p->num.expn != BF_EXP_ZERO && p->num.expn != BF_EXP_NAN;\n            JS_FreeValue(ctx, val);\n            return ret;\n        }\n#endif\n    case JS_TAG_OBJECT:\n        {\n            JSObject *p = JS_VALUE_GET_OBJ(val);\n            BOOL ret;\n            ret = !p->is_HTMLDDA;\n            JS_FreeValue(ctx, val);\n            return ret;\n        }\n        break;\n    default:\n        if (JS_TAG_IS_FLOAT64(tag)) {\n            double d = JS_VALUE_GET_FLOAT64(val);\n            return !isnan(d) && d != 0;\n        } else {\n            JS_FreeValue(ctx, val);\n            return TRUE;\n        }\n    }\n}\n\nint JS_ToBool(JSContext *ctx, JSValueConst val)\n{\n    return JS_ToBoolFree(ctx, JS_DupValue(ctx, val));\n}\n\nstatic int skip_spaces(const char *pc)\n{\n    const uint8_t *p, *p_next, *p_start;\n    uint32_t c;\n\n    p = p_start = (const uint8_t *)pc;\n    for (;;) {\n        c = *p;\n        if (c < 128) {\n            if (!((c >= 0x09 && c <= 0x0d) || (c == 0x20)))\n                break;\n            p++;\n        } else {\n            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);\n            if (!lre_is_space(c))\n                break;\n            p = p_next;\n        }\n    }\n    return p - p_start;\n}\n\nstatic inline int to_digit(int c)\n{\n    if (c >= '0' && c <= '9')\n        return c - '0';\n    else if (c >= 'A' && c <= 'Z')\n        return c - 'A' + 10;\n    else if (c >= 'a' && c <= 'z')\n        return c - 'a' + 10;\n    else\n        return 36;\n}\n\n/* XXX: remove */\nstatic double js_strtod(const char *p, int radix, BOOL is_float)\n{\n    double d;\n    int c;\n    \n    if (!is_float || radix != 10) {\n        uint64_t n_max, n;\n        int int_exp, is_neg;\n        \n        is_neg = 0;\n        if (*p == '-') {\n            is_neg = 1;\n            p++;\n        }\n\n        /* skip leading zeros */\n        while (*p == '0')\n            p++;\n        n = 0;\n        if (radix == 10)\n            n_max = ((uint64_t)-1 - 9) / 10; /* most common case */\n        else\n            n_max = ((uint64_t)-1 - (radix - 1)) / radix;\n        /* XXX: could be more precise */\n        int_exp = 0;\n        while (*p != '\\0') {\n            c = to_digit((uint8_t)*p);\n            if (c >= radix)\n                break;\n            if (n <= n_max) {\n                n = n * radix + c;\n            } else {\n                int_exp++;\n            }\n            p++;\n        }\n        d = n;\n        if (int_exp != 0) {\n            d *= pow(radix, int_exp);\n        }\n        if (is_neg)\n            d = -d;\n    } else {\n        d = strtod(p, NULL);\n    }\n    return d;\n}\n\n#define ATOD_INT_ONLY        (1 << 0)\n/* accept Oo and Ob prefixes in addition to 0x prefix if radix = 0 */\n#define ATOD_ACCEPT_BIN_OCT  (1 << 2)\n/* accept O prefix as octal if radix == 0 and properly formed (Annex B) */\n#define ATOD_ACCEPT_LEGACY_OCTAL  (1 << 4)\n/* accept _ between digits as a digit separator */\n#define ATOD_ACCEPT_UNDERSCORES  (1 << 5)\n/* allow a suffix to override the type */\n#define ATOD_ACCEPT_SUFFIX    (1 << 6) \n/* default type */\n#define ATOD_TYPE_MASK        (3 << 7)\n#define ATOD_TYPE_FLOAT64     (0 << 7)\n#define ATOD_TYPE_BIG_INT     (1 << 7)\n#define ATOD_TYPE_BIG_FLOAT   (2 << 7)\n#define ATOD_TYPE_BIG_DECIMAL (3 << 7)\n/* assume bigint mode: floats are parsed as integers if no decimal\n   point nor exponent */\n#define ATOD_MODE_BIGINT      (1 << 9) \n/* accept -0x1 */\n#define ATOD_ACCEPT_PREFIX_AFTER_SIGN (1 << 10)\n\n#ifdef CONFIG_BIGNUM\nstatic JSValue js_string_to_bigint(JSContext *ctx, const char *buf,\n                                   int radix, int flags, slimb_t *pexponent)\n{\n    bf_t a_s, *a = &a_s;\n    int ret;\n    JSValue val;\n    val = JS_NewBigInt(ctx);\n    if (JS_IsException(val))\n        return val;\n    a = JS_GetBigInt(val);\n    ret = bf_atof(a, buf, NULL, radix, BF_PREC_INF, BF_RNDZ);\n    if (ret & BF_ST_MEM_ERROR) {\n        JS_FreeValue(ctx, val);\n        return JS_ThrowOutOfMemory(ctx);\n    }\n    val = JS_CompactBigInt1(ctx, val, (flags & ATOD_MODE_BIGINT) != 0);\n    return val;\n}\n\nstatic JSValue js_string_to_bigfloat(JSContext *ctx, const char *buf,\n                                     int radix, int flags, slimb_t *pexponent)\n{\n    bf_t *a;\n    int ret;\n    JSValue val;\n    \n    val = JS_NewBigFloat(ctx);\n    if (JS_IsException(val))\n        return val;\n    a = JS_GetBigFloat(val);\n    if (flags & ATOD_ACCEPT_SUFFIX) {\n        /* return the exponent to get infinite precision */\n        ret = bf_atof2(a, pexponent, buf, NULL, radix, BF_PREC_INF,\n                       BF_RNDZ | BF_ATOF_EXPONENT);\n    } else {\n        ret = bf_atof(a, buf, NULL, radix, ctx->fp_env.prec,\n                      ctx->fp_env.flags);\n    }\n    if (ret & BF_ST_MEM_ERROR) {\n        JS_FreeValue(ctx, val);\n        return JS_ThrowOutOfMemory(ctx);\n    }\n    return val;\n}\n\nstatic JSValue js_string_to_bigdecimal(JSContext *ctx, const char *buf,\n                                       int radix, int flags, slimb_t *pexponent)\n{\n    bfdec_t *a;\n    int ret;\n    JSValue val;\n    \n    val = JS_NewBigDecimal(ctx);\n    if (JS_IsException(val))\n        return val;\n    a = JS_GetBigDecimal(val);\n    ret = bfdec_atof(a, buf, NULL, BF_PREC_INF,\n                     BF_RNDZ | BF_ATOF_NO_NAN_INF);\n    if (ret & BF_ST_MEM_ERROR) {\n        JS_FreeValue(ctx, val);\n        return JS_ThrowOutOfMemory(ctx);\n    }\n    return val;\n}\n\n#endif\n\n/* return an exception in case of memory error. Return JS_NAN if\n   invalid syntax */\n#ifdef CONFIG_BIGNUM\nstatic JSValue js_atof2(JSContext *ctx, const char *str, const char **pp,\n                        int radix, int flags, slimb_t *pexponent)\n#else\nstatic JSValue js_atof(JSContext *ctx, const char *str, const char **pp,\n                       int radix, int flags)\n#endif\n{\n    const char *p, *p_start;\n    int sep, is_neg;\n    BOOL is_float, has_legacy_octal;\n    int atod_type = flags & ATOD_TYPE_MASK;\n    char buf1[64], *buf;\n    int i, j, len;\n    BOOL buf_allocated = FALSE;\n    JSValue val;\n    \n    /* optional separator between digits */\n    sep = (flags & ATOD_ACCEPT_UNDERSCORES) ? '_' : 256;\n    has_legacy_octal = FALSE;\n    \n    p = str;\n    p_start = p;\n    is_neg = 0;\n    if (p[0] == '+') {\n        p++;\n        p_start++;\n        if (!(flags & ATOD_ACCEPT_PREFIX_AFTER_SIGN))\n            goto no_radix_prefix;\n    } else if (p[0] == '-') {\n        p++;\n        p_start++;\n        is_neg = 1;\n        if (!(flags & ATOD_ACCEPT_PREFIX_AFTER_SIGN))\n            goto no_radix_prefix;\n    }\n    if (p[0] == '0') {\n        if ((p[1] == 'x' || p[1] == 'X') &&\n            (radix == 0 || radix == 16)) {\n            p += 2;\n            radix = 16;\n        } else if ((p[1] == 'o' || p[1] == 'O') &&\n                   radix == 0 && (flags & ATOD_ACCEPT_BIN_OCT)) {\n            p += 2;\n            radix = 8;\n        } else if ((p[1] == 'b' || p[1] == 'B') &&\n                   radix == 0 && (flags & ATOD_ACCEPT_BIN_OCT)) {\n            p += 2;\n            radix = 2;\n        } else if ((p[1] >= '0' && p[1] <= '9') &&\n                   radix == 0 && (flags & ATOD_ACCEPT_LEGACY_OCTAL)) {\n            int i;\n            has_legacy_octal = TRUE;\n            sep = 256;\n            for (i = 1; (p[i] >= '0' && p[i] <= '7'); i++)\n                continue;\n            if (p[i] == '8' || p[i] == '9')\n                goto no_prefix;\n            p += 1;\n            radix = 8;\n        } else {\n            goto no_prefix;\n        }\n        /* there must be a digit after the prefix */\n        if (to_digit((uint8_t)*p) >= radix)\n            goto fail;\n    no_prefix: ;\n    } else {\n no_radix_prefix:\n        if (!(flags & ATOD_INT_ONLY) &&\n            (atod_type == ATOD_TYPE_FLOAT64 ||\n             atod_type == ATOD_TYPE_BIG_FLOAT) &&\n            strstart(p, \"Infinity\", &p)) {\n#ifdef CONFIG_BIGNUM\n            if (atod_type == ATOD_TYPE_BIG_FLOAT) {\n                bf_t *a;\n                val = JS_NewBigFloat(ctx);\n                if (JS_IsException(val))\n                    goto done;\n                a = JS_GetBigFloat(val);\n                bf_set_inf(a, is_neg);\n            } else\n#endif\n            {\n                double d = 1.0 / 0.0;\n                if (is_neg)\n                    d = -d;\n                val = JS_NewFloat64(ctx, d);\n            }\n            goto done;\n        }\n    }\n    if (radix == 0)\n        radix = 10;\n    is_float = FALSE;\n    p_start = p;\n    while (to_digit((uint8_t)*p) < radix\n           ||  (*p == sep && (radix != 10 ||\n                              p != p_start + 1 || p[-1] != '0') &&\n                to_digit((uint8_t)p[1]) < radix)) {\n        p++;\n    }\n    if (!(flags & ATOD_INT_ONLY)) {\n        if (*p == '.' && (p > p_start || to_digit((uint8_t)p[1]) < radix)) {\n            is_float = TRUE;\n            p++;\n            if (*p == sep)\n                goto fail;\n            while (to_digit((uint8_t)*p) < radix ||\n                   (*p == sep && to_digit((uint8_t)p[1]) < radix))\n                p++;\n        }\n        if (p > p_start &&\n            (((*p == 'e' || *p == 'E') && radix == 10) ||\n             ((*p == 'p' || *p == 'P') && (radix == 2 || radix == 8 || radix == 16)))) {\n            const char *p1 = p + 1;\n            is_float = TRUE;\n            if (*p1 == '+') {\n                p1++;\n            } else if (*p1 == '-') {\n                p1++;\n            }\n            if (is_digit((uint8_t)*p1)) {\n                p = p1 + 1;\n                while (is_digit((uint8_t)*p) || (*p == sep && is_digit((uint8_t)p[1])))\n                    p++;\n            }\n        }\n    }\n    if (p == p_start)\n        goto fail;\n\n    buf = buf1;\n    buf_allocated = FALSE;\n    len = p - p_start;\n    if (unlikely((len + 2) > sizeof(buf1))) {\n        buf = js_malloc_rt(ctx->rt, len + 2); /* no exception raised */\n        if (!buf)\n            goto mem_error;\n        buf_allocated = TRUE;\n    }\n    /* remove the separators and the radix prefixes */\n    j = 0;\n    if (is_neg)\n        buf[j++] = '-';\n    for (i = 0; i < len; i++) {\n        if (p_start[i] != '_')\n            buf[j++] = p_start[i];\n    }\n    buf[j] = '\\0';\n\n#ifdef CONFIG_BIGNUM\n    if (flags & ATOD_ACCEPT_SUFFIX) {\n        if (*p == 'n') {\n            p++;\n            atod_type = ATOD_TYPE_BIG_INT;\n        } else if (*p == 'l') {\n            p++;\n            atod_type = ATOD_TYPE_BIG_FLOAT;\n        } else if (*p == 'm') {\n            p++;\n            atod_type = ATOD_TYPE_BIG_DECIMAL;\n        } else {\n            if (flags & ATOD_MODE_BIGINT) {\n                if (!is_float)\n                    atod_type = ATOD_TYPE_BIG_INT;\n                if (has_legacy_octal)\n                    goto fail;\n            } else {\n                if (is_float && radix != 10)\n                    goto fail;\n            }\n        }\n    } else {\n        if (atod_type == ATOD_TYPE_FLOAT64) {\n            if (flags & ATOD_MODE_BIGINT) {\n                if (!is_float)\n                    atod_type = ATOD_TYPE_BIG_INT;\n                if (has_legacy_octal)\n                    goto fail;\n            } else {\n                if (is_float && radix != 10)\n                    goto fail;\n            }\n        }\n    }\n\n    switch(atod_type) {\n    case ATOD_TYPE_FLOAT64:\n        {\n            double d;\n            d = js_strtod(buf, radix, is_float);\n            /* return int or float64 */\n            val = JS_NewFloat64(ctx, d);\n        }\n        break;\n    case ATOD_TYPE_BIG_INT:\n        if (has_legacy_octal || is_float)\n            goto fail;\n        val = ctx->rt->bigint_ops.from_string(ctx, buf, radix, flags, NULL);\n        break;\n    case ATOD_TYPE_BIG_FLOAT:\n        if (has_legacy_octal)\n            goto fail;\n        val = ctx->rt->bigfloat_ops.from_string(ctx, buf, radix, flags,\n                                                pexponent);\n        break;\n    case ATOD_TYPE_BIG_DECIMAL:\n        if (radix != 10)\n            goto fail;\n        val = ctx->rt->bigdecimal_ops.from_string(ctx, buf, radix, flags, NULL);\n        break;\n    default:\n        abort();\n    }\n#else\n    {\n        double d;\n        (void)has_legacy_octal;\n        if (is_float && radix != 10)\n            goto fail;\n        d = js_strtod(buf, radix, is_float);\n        val = JS_NewFloat64(ctx, d);\n    }\n#endif\n    \ndone:\n    if (buf_allocated)\n        js_free_rt(ctx->rt, buf);\n    if (pp)\n        *pp = p;\n    return val;\n fail:\n    val = JS_NAN;\n    goto done;\n mem_error:\n    val = JS_ThrowOutOfMemory(ctx);\n    goto done;\n}\n\n#ifdef CONFIG_BIGNUM\nstatic JSValue js_atof(JSContext *ctx, const char *str, const char **pp,\n                       int radix, int flags)\n{\n    return js_atof2(ctx, str, pp, radix, flags, NULL);\n}\n#endif\n\ntypedef enum JSToNumberHintEnum {\n    TON_FLAG_NUMBER,\n    TON_FLAG_NUMERIC,\n} JSToNumberHintEnum;\n\nstatic JSValue JS_ToNumberHintFree(JSContext *ctx, JSValue val,\n                                   JSToNumberHintEnum flag)\n{\n    uint32_t tag;\n    JSValue ret;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_DECIMAL:\n        if (flag != TON_FLAG_NUMERIC) {\n            JS_FreeValue(ctx, val);\n            return JS_ThrowTypeError(ctx, \"cannot convert bigdecimal to number\");\n        }\n        ret = val;\n        break;\n    case JS_TAG_BIG_INT:\n        if (flag != TON_FLAG_NUMERIC) {\n            JS_FreeValue(ctx, val);\n            return JS_ThrowTypeError(ctx, \"cannot convert bigint to number\");\n        }\n        ret = val;\n        break;\n    case JS_TAG_BIG_FLOAT:\n        if (flag != TON_FLAG_NUMERIC) {\n            JS_FreeValue(ctx, val);\n            return JS_ThrowTypeError(ctx, \"cannot convert bigfloat to number\");\n        }\n        ret = val;\n        break;\n#endif\n    case JS_TAG_FLOAT64:\n    case JS_TAG_INT:\n    case JS_TAG_EXCEPTION:\n        ret = val;\n        break;\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n        ret = JS_NewInt32(ctx, JS_VALUE_GET_INT(val));\n        break;\n    case JS_TAG_UNDEFINED:\n        ret = JS_NAN;\n        break;\n    case JS_TAG_OBJECT:\n        val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);\n        if (JS_IsException(val))\n            return JS_EXCEPTION;\n        goto redo;\n    case JS_TAG_STRING:\n        {\n            const char *str;\n            const char *p;\n            size_t len;\n            \n            str = JS_ToCStringLen(ctx, &len, val);\n            JS_FreeValue(ctx, val);\n            if (!str)\n                return JS_EXCEPTION;\n            p = str;\n            p += skip_spaces(p);\n            if ((p - str) == len) {\n                ret = JS_NewInt32(ctx, 0);\n            } else {\n                int flags = ATOD_ACCEPT_BIN_OCT;\n                ret = js_atof(ctx, p, &p, 0, flags);\n                if (!JS_IsException(ret)) {\n                    p += skip_spaces(p);\n                    if ((p - str) != len) {\n                        JS_FreeValue(ctx, ret);\n                        ret = JS_NAN;\n                    }\n                }\n            }\n            JS_FreeCString(ctx, str);\n        }\n        break;\n    case JS_TAG_SYMBOL:\n        JS_FreeValue(ctx, val);\n        return JS_ThrowTypeError(ctx, \"cannot convert symbol to number\");\n    default:\n        JS_FreeValue(ctx, val);\n        ret = JS_NAN;\n        break;\n    }\n    return ret;\n}\n\nstatic JSValue JS_ToNumberFree(JSContext *ctx, JSValue val)\n{\n    return JS_ToNumberHintFree(ctx, val, TON_FLAG_NUMBER);\n}\n\nstatic JSValue JS_ToNumericFree(JSContext *ctx, JSValue val)\n{\n    return JS_ToNumberHintFree(ctx, val, TON_FLAG_NUMERIC);\n}\n\nstatic JSValue JS_ToNumeric(JSContext *ctx, JSValueConst val)\n{\n    return JS_ToNumericFree(ctx, JS_DupValue(ctx, val));\n}\n\nstatic __exception int __JS_ToFloat64Free(JSContext *ctx, double *pres,\n                                          JSValue val)\n{\n    double d;\n    uint32_t tag;\n\n    val = JS_ToNumberFree(ctx, val);\n    if (JS_IsException(val)) {\n        *pres = JS_FLOAT64_NAN;\n        return -1;\n    }\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n        d = JS_VALUE_GET_INT(val);\n        break;\n    case JS_TAG_FLOAT64:\n        d = JS_VALUE_GET_FLOAT64(val);\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            /* XXX: there can be a double rounding issue with some\n               primitives (such as JS_ToUint8ClampFree()), but it is\n               not critical to fix it. */\n            bf_get_float64(&p->num, &d, BF_RNDN);\n            JS_FreeValue(ctx, val);\n        }\n        break;\n#endif\n    default:\n        abort();\n    }\n    *pres = d;\n    return 0;\n}\n\nstatic inline int JS_ToFloat64Free(JSContext *ctx, double *pres, JSValue val)\n{\n    uint32_t tag;\n\n    tag = JS_VALUE_GET_TAG(val);\n    if (tag <= JS_TAG_NULL) {\n        *pres = JS_VALUE_GET_INT(val);\n        return 0;\n    } else if (JS_TAG_IS_FLOAT64(tag)) {\n        *pres = JS_VALUE_GET_FLOAT64(val);\n        return 0;\n    } else {\n        return __JS_ToFloat64Free(ctx, pres, val);\n    }\n}\n\nint JS_ToFloat64(JSContext *ctx, double *pres, JSValueConst val)\n{\n    return JS_ToFloat64Free(ctx, pres, JS_DupValue(ctx, val));\n}\n\nstatic JSValue JS_ToNumber(JSContext *ctx, JSValueConst val)\n{\n    return JS_ToNumberFree(ctx, JS_DupValue(ctx, val));\n}\n\n/* same as JS_ToNumber() but return 0 in case of NaN/Undefined */\nstatic __maybe_unused JSValue JS_ToIntegerFree(JSContext *ctx, JSValue val)\n{\n    uint32_t tag;\n    JSValue ret;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        ret = JS_NewInt32(ctx, JS_VALUE_GET_INT(val));\n        break;\n    case JS_TAG_FLOAT64:\n        {\n            double d = JS_VALUE_GET_FLOAT64(val);\n            if (isnan(d)) {\n                ret = JS_NewInt32(ctx, 0);\n            } else {\n                /* convert -0 to +0 */\n                d = trunc(d) + 0.0;\n                ret = JS_NewFloat64(ctx, d);\n            }\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            bf_t a_s, *a, r_s, *r = &r_s;\n            BOOL is_nan;\n\n            a = JS_ToBigFloat(ctx, &a_s, val);\n            if (!bf_is_finite(a)) {\n                is_nan = bf_is_nan(a);\n                if (is_nan)\n                    ret = JS_NewInt32(ctx, 0);\n                else\n                    ret = JS_DupValue(ctx, val);\n            } else {\n                ret = JS_NewBigInt(ctx);\n                if (!JS_IsException(ret)) {\n                    r = JS_GetBigInt(ret);\n                    bf_set(r, a);\n                    bf_rint(r, BF_RNDZ);\n                    ret = JS_CompactBigInt(ctx, ret);\n                }\n            }\n            if (a == &a_s)\n                bf_delete(a);\n            JS_FreeValue(ctx, val);\n        }\n        break;\n#endif\n    default:\n        val = JS_ToNumberFree(ctx, val);\n        if (JS_IsException(val))\n            return val;\n        goto redo;\n    }\n    return ret;\n}\n\n/* Note: the integer value is satured to 32 bits */\nstatic int JS_ToInt32SatFree(JSContext *ctx, int *pres, JSValue val)\n{\n    uint32_t tag;\n    int ret;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        ret = JS_VALUE_GET_INT(val);\n        break;\n    case JS_TAG_EXCEPTION:\n        *pres = 0;\n        return -1;\n    case JS_TAG_FLOAT64:\n        {\n            double d = JS_VALUE_GET_FLOAT64(val);\n            if (isnan(d)) {\n                ret = 0;\n            } else {\n                if (d < INT32_MIN)\n                    ret = INT32_MIN;\n                else if (d > INT32_MAX)\n                    ret = INT32_MAX;\n                else\n                    ret = (int)d;\n            }\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            bf_get_int32(&ret, &p->num, 0);\n            JS_FreeValue(ctx, val);\n        }\n        break;\n#endif\n    default:\n        val = JS_ToNumberFree(ctx, val);\n        if (JS_IsException(val)) {\n            *pres = 0;\n            return -1;\n        }\n        goto redo;\n    }\n    *pres = ret;\n    return 0;\n}\n\nint JS_ToInt32Sat(JSContext *ctx, int *pres, JSValueConst val)\n{\n    return JS_ToInt32SatFree(ctx, pres, JS_DupValue(ctx, val));\n}\n\nint JS_ToInt32Clamp(JSContext *ctx, int *pres, JSValueConst val,\n                    int min, int max, int min_offset)\n{\n    int res = JS_ToInt32SatFree(ctx, pres, JS_DupValue(ctx, val));\n    if (res == 0) {\n        if (*pres < min) {\n            *pres += min_offset;\n            if (*pres < min)\n                *pres = min;\n        } else {\n            if (*pres > max)\n                *pres = max;\n        }\n    }\n    return res;\n}\n\nstatic int JS_ToInt64SatFree(JSContext *ctx, int64_t *pres, JSValue val)\n{\n    uint32_t tag;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        *pres = JS_VALUE_GET_INT(val);\n        return 0;\n    case JS_TAG_EXCEPTION:\n        *pres = 0;\n        return -1;\n    case JS_TAG_FLOAT64:\n        {\n            double d = JS_VALUE_GET_FLOAT64(val);\n            if (isnan(d)) {\n                *pres = 0;\n            } else {\n                if (d < INT64_MIN)\n                    *pres = INT64_MIN;\n                else if (d > INT64_MAX)\n                    *pres = INT64_MAX;\n                else\n                    *pres = (int64_t)d;\n            }\n        }\n        return 0;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            bf_get_int64(pres, &p->num, 0);\n            JS_FreeValue(ctx, val);\n        }\n        return 0;\n#endif\n    default:\n        val = JS_ToNumberFree(ctx, val);\n        if (JS_IsException(val)) {\n            *pres = 0;\n            return -1;\n        }\n        goto redo;\n    }\n}\n\nint JS_ToInt64Sat(JSContext *ctx, int64_t *pres, JSValueConst val)\n{\n    return JS_ToInt64SatFree(ctx, pres, JS_DupValue(ctx, val));\n}\n\nint JS_ToInt64Clamp(JSContext *ctx, int64_t *pres, JSValueConst val,\n                    int64_t min, int64_t max, int64_t neg_offset)\n{\n    int res = JS_ToInt64SatFree(ctx, pres, JS_DupValue(ctx, val));\n    if (res == 0) {\n        if (*pres < 0)\n            *pres += neg_offset;\n        if (*pres < min)\n            *pres = min;\n        else if (*pres > max)\n            *pres = max;\n    }\n    return res;\n}\n\n/* Same as JS_ToInt32Free() but with a 64 bit result. Return (<0, 0)\n   in case of exception */\nstatic int JS_ToInt64Free(JSContext *ctx, int64_t *pres, JSValue val)\n{\n    uint32_t tag;\n    int64_t ret;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        ret = JS_VALUE_GET_INT(val);\n        break;\n    case JS_TAG_FLOAT64:\n        {\n            JSFloat64Union u;\n            double d;\n            int e;\n            d = JS_VALUE_GET_FLOAT64(val);\n            u.d = d;\n            /* we avoid doing fmod(x, 2^64) */\n            e = (u.u64 >> 52) & 0x7ff;\n            if (likely(e <= (1023 + 62))) {\n                /* fast case */\n                ret = (int64_t)d;\n            } else if (e <= (1023 + 62 + 53)) {\n                uint64_t v;\n                /* remainder modulo 2^64 */\n                v = (u.u64 & (((uint64_t)1 << 52) - 1)) | ((uint64_t)1 << 52);\n                ret = v << ((e - 1023) - 52);\n                /* take the sign into account */\n                if (u.u64 >> 63)\n                    ret = -ret;\n            } else {\n                ret = 0; /* also handles NaN and +inf */\n            }\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            bf_get_int64(&ret, &p->num, BF_GET_INT_MOD);\n            JS_FreeValue(ctx, val);\n        }\n        break;\n#endif\n    default:\n        val = JS_ToNumberFree(ctx, val);\n        if (JS_IsException(val)) {\n            *pres = 0;\n            return -1;\n        }\n        goto redo;\n    }\n    *pres = ret;\n    return 0;\n}\n\nint JS_ToInt64(JSContext *ctx, int64_t *pres, JSValueConst val)\n{\n    return JS_ToInt64Free(ctx, pres, JS_DupValue(ctx, val));\n}\n\nint JS_ToInt64Ext(JSContext *ctx, int64_t *pres, JSValueConst val)\n{\n    if (JS_IsBigInt(ctx, val))\n        return JS_ToBigInt64(ctx, pres, val);\n    else\n        return JS_ToInt64(ctx, pres, val);\n}\n\n/* return (<0, 0) in case of exception */\nstatic int JS_ToInt32Free(JSContext *ctx, int32_t *pres, JSValue val)\n{\n    uint32_t tag;\n    int32_t ret;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        ret = JS_VALUE_GET_INT(val);\n        break;\n    case JS_TAG_FLOAT64:\n        {\n            JSFloat64Union u;\n            double d;\n            int e;\n            d = JS_VALUE_GET_FLOAT64(val);\n            u.d = d;\n            /* we avoid doing fmod(x, 2^32) */\n            e = (u.u64 >> 52) & 0x7ff;\n            if (likely(e <= (1023 + 30))) {\n                /* fast case */\n                ret = (int32_t)d;\n            } else if (e <= (1023 + 30 + 53)) {\n                uint64_t v;\n                /* remainder modulo 2^32 */\n                v = (u.u64 & (((uint64_t)1 << 52) - 1)) | ((uint64_t)1 << 52);\n                v = v << ((e - 1023) - 52 + 32);\n                ret = v >> 32;\n                /* take the sign into account */\n                if (u.u64 >> 63)\n                    ret = -ret;\n            } else {\n                ret = 0; /* also handles NaN and +inf */\n            }\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            bf_get_int32(&ret, &p->num, BF_GET_INT_MOD);\n            JS_FreeValue(ctx, val);\n        }\n        break;\n#endif\n    default:\n        val = JS_ToNumberFree(ctx, val);\n        if (JS_IsException(val)) {\n            *pres = 0;\n            return -1;\n        }\n        goto redo;\n    }\n    *pres = ret;\n    return 0;\n}\n\nint JS_ToInt32(JSContext *ctx, int32_t *pres, JSValueConst val)\n{\n    return JS_ToInt32Free(ctx, pres, JS_DupValue(ctx, val));\n}\n\nstatic inline int JS_ToUint32Free(JSContext *ctx, uint32_t *pres, JSValue val)\n{\n    return JS_ToInt32Free(ctx, (int32_t *)pres, val);\n}\n\nstatic int JS_ToUint8ClampFree(JSContext *ctx, int32_t *pres, JSValue val)\n{\n    uint32_t tag;\n    int res;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        res = JS_VALUE_GET_INT(val);\n#ifdef CONFIG_BIGNUM\n    int_clamp:\n#endif\n        res = max_int(0, min_int(255, res));\n        break;\n    case JS_TAG_FLOAT64:\n        {\n            double d = JS_VALUE_GET_FLOAT64(val);\n            if (isnan(d)) {\n                res = 0;\n            } else {\n                if (d < 0)\n                    res = 0;\n                else if (d > 255)\n                    res = 255;\n                else\n                    res = lrint(d);\n            }\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            bf_t r_s, *r = &r_s;\n            bf_init(ctx->bf_ctx, r);\n            bf_set(r, &p->num);\n            bf_rint(r, BF_RNDN);\n            bf_get_int32(&res, r, 0);\n            bf_delete(r);\n            JS_FreeValue(ctx, val);\n        }\n        goto int_clamp;\n#endif\n    default:\n        val = JS_ToNumberFree(ctx, val);\n        if (JS_IsException(val)) {\n            *pres = 0;\n            return -1;\n        }\n        goto redo;\n    }\n    *pres = res;\n    return 0;\n}\n\nstatic __exception int JS_ToArrayLengthFree(JSContext *ctx, uint32_t *plen,\n                                            JSValue val, BOOL is_array_ctor)\n{\n    uint32_t tag, len;\n\n    tag = JS_VALUE_GET_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n        {\n            int v;\n            v = JS_VALUE_GET_INT(val);\n            if (v < 0)\n                goto fail;\n            len = v;\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            bf_t a;\n            BOOL res;\n            bf_get_int32((int32_t *)&len, &p->num, BF_GET_INT_MOD);\n            bf_init(ctx->bf_ctx, &a);\n            bf_set_ui(&a, len);\n            res = bf_cmp_eq(&a, &p->num);\n            bf_delete(&a);\n            JS_FreeValue(ctx, val);\n            if (!res)\n                goto fail;\n        }\n        break;\n#endif\n    default:\n        if (JS_TAG_IS_FLOAT64(tag)) {\n            double d;\n            d = JS_VALUE_GET_FLOAT64(val);\n            len = (uint32_t)d;\n            if (len != d)\n                goto fail;\n        } else {\n            uint32_t len1;\n\n            if (is_array_ctor) {\n                val = JS_ToNumberFree(ctx, val);\n                if (JS_IsException(val))\n                    return -1;\n                /* cannot recurse because val is a number */\n                if (JS_ToArrayLengthFree(ctx, &len, val, TRUE))\n                    return -1;\n            } else {\n                /* legacy behavior: must do the conversion twice and compare */\n                if (JS_ToUint32(ctx, &len, val)) {\n                    JS_FreeValue(ctx, val);\n                    return -1;\n                }\n                val = JS_ToNumberFree(ctx, val);\n                if (JS_IsException(val))\n                    return -1;\n                /* cannot recurse because val is a number */\n                if (JS_ToArrayLengthFree(ctx, &len1, val, FALSE))\n                    return -1;\n                if (len1 != len) {\n                fail:\n                    JS_ThrowRangeError(ctx, \"invalid array length\");\n                    return -1;\n                }\n            }\n        }\n        break;\n    }\n    *plen = len;\n    return 0;\n}\n\n#define MAX_SAFE_INTEGER (((int64_t)1 << 53) - 1)\n\nstatic BOOL is_safe_integer(double d)\n{\n    return isfinite(d) && floor(d) == d &&\n        fabs(d) <= (double)MAX_SAFE_INTEGER;\n}\n\nint JS_ToIndex(JSContext *ctx, uint64_t *plen, JSValueConst val)\n{\n    int64_t v;\n    if (JS_ToInt64Sat(ctx, &v, val))\n        return -1;\n    if (v < 0 || v > MAX_SAFE_INTEGER) {\n        JS_ThrowRangeError(ctx, \"invalid array index\");\n        *plen = 0;\n        return -1;\n    }\n    *plen = v;\n    return 0;\n}\n\n/* convert a value to a length between 0 and MAX_SAFE_INTEGER.\n   return -1 for exception */\nstatic __exception int JS_ToLengthFree(JSContext *ctx, int64_t *plen,\n                                       JSValue val)\n{\n    int res = JS_ToInt64Clamp(ctx, plen, val, 0, MAX_SAFE_INTEGER, 0);\n    JS_FreeValue(ctx, val);\n    return res;\n}\n\n/* Note: can return an exception */\nstatic int JS_NumberIsInteger(JSContext *ctx, JSValueConst val)\n{\n    double d;\n    if (!JS_IsNumber(val))\n        return FALSE;\n    if (unlikely(JS_ToFloat64(ctx, &d, val)))\n        return -1;\n    return isfinite(d) && floor(d) == d;\n}\n\nstatic BOOL JS_NumberIsNegativeOrMinusZero(JSContext *ctx, JSValueConst val)\n{\n    uint32_t tag;\n\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n        {\n            int v;\n            v = JS_VALUE_GET_INT(val);\n            return (v < 0);\n        }\n    case JS_TAG_FLOAT64:\n        {\n            JSFloat64Union u;\n            u.d = JS_VALUE_GET_FLOAT64(val);\n            return (u.u64 >> 63);\n        }\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            /* Note: integer zeros are not necessarily positive */\n            return p->num.sign && !bf_is_zero(&p->num);\n        }\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            return p->num.sign;\n        }\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        {\n            JSBigDecimal *p = JS_VALUE_GET_PTR(val);\n            return p->num.sign;\n        }\n        break;\n#endif\n    default:\n        return FALSE;\n    }\n}\n\n#ifdef CONFIG_BIGNUM\n\nstatic JSValue js_bigint_to_string1(JSContext *ctx, JSValueConst val, int radix)\n{\n    JSValue ret;\n    bf_t a_s, *a;\n    char *str;\n    int saved_sign;\n\n    a = JS_ToBigInt(ctx, &a_s, val);\n    if (!a)\n        return JS_EXCEPTION;\n    saved_sign = a->sign;\n    if (a->expn == BF_EXP_ZERO)\n        a->sign = 0;\n    str = bf_ftoa(NULL, a, radix, 0, BF_RNDZ | BF_FTOA_FORMAT_FRAC |\n                  BF_FTOA_JS_QUIRKS);\n    a->sign = saved_sign;\n    JS_FreeBigInt(ctx, a, &a_s);\n    if (!str)\n        return JS_ThrowOutOfMemory(ctx);\n    ret = JS_NewString(ctx, str);\n    bf_free(ctx->bf_ctx, str);\n    return ret;\n}\n\nstatic JSValue js_bigint_to_string(JSContext *ctx, JSValueConst val)\n{\n    return js_bigint_to_string1(ctx, val, 10);\n}\n\nstatic JSValue js_ftoa(JSContext *ctx, JSValueConst val1, int radix,\n                       limb_t prec, bf_flags_t flags)\n{\n    JSValue val, ret;\n    bf_t a_s, *a;\n    char *str;\n    int saved_sign;\n\n    val = JS_ToNumeric(ctx, val1);\n    if (JS_IsException(val))\n        return val;\n    a = JS_ToBigFloat(ctx, &a_s, val);\n    saved_sign = a->sign;\n    if (a->expn == BF_EXP_ZERO)\n        a->sign = 0;\n    flags |= BF_FTOA_JS_QUIRKS;\n    if ((flags & BF_FTOA_FORMAT_MASK) == BF_FTOA_FORMAT_FREE_MIN) {\n        /* Note: for floating point numbers with a radix which is not\n           a power of two, the current precision is used to compute\n           the number of digits. */\n        if ((radix & (radix - 1)) != 0) {\n            bf_t r_s, *r = &r_s;\n            int prec, flags1;\n            /* must round first */\n            if (JS_VALUE_GET_TAG(val) == JS_TAG_BIG_FLOAT) {\n                prec = ctx->fp_env.prec;\n                flags1 = ctx->fp_env.flags &\n                    (BF_FLAG_SUBNORMAL | (BF_EXP_BITS_MASK << BF_EXP_BITS_SHIFT));\n            } else {\n                prec = 53;\n                flags1 = bf_set_exp_bits(11) | BF_FLAG_SUBNORMAL;\n            }\n            bf_init(ctx->bf_ctx, r);\n            bf_set(r, a);\n            bf_round(r, prec, flags1 | BF_RNDN);\n            str = bf_ftoa(NULL, r, radix, prec, flags1 | flags);\n            bf_delete(r);\n        } else {\n            str = bf_ftoa(NULL, a, radix, BF_PREC_INF, flags);\n        }\n    } else {\n        str = bf_ftoa(NULL, a, radix, prec, flags);\n    }\n    a->sign = saved_sign;\n    if (a == &a_s)\n        bf_delete(a);\n    JS_FreeValue(ctx, val);\n    if (!str)\n        return JS_ThrowOutOfMemory(ctx);\n    ret = JS_NewString(ctx, str);\n    bf_free(ctx->bf_ctx, str);\n    return ret;\n}\n\nstatic JSValue js_bigfloat_to_string(JSContext *ctx, JSValueConst val)\n{\n    return js_ftoa(ctx, val, 10, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);\n}\n\nstatic JSValue js_bigdecimal_to_string1(JSContext *ctx, JSValueConst val,\n                                        limb_t prec, int flags)\n{\n    JSValue ret;\n    bfdec_t *a;\n    char *str;\n    int saved_sign;\n\n    a = JS_ToBigDecimal(ctx, val);\n    saved_sign = a->sign;\n    if (a->expn == BF_EXP_ZERO)\n        a->sign = 0;\n    str = bfdec_ftoa(NULL, a, prec, flags | BF_FTOA_JS_QUIRKS);\n    a->sign = saved_sign;\n    if (!str)\n        return JS_ThrowOutOfMemory(ctx);\n    ret = JS_NewString(ctx, str);\n    bf_free(ctx->bf_ctx, str);\n    return ret;\n}\n\nstatic JSValue js_bigdecimal_to_string(JSContext *ctx, JSValueConst val)\n{\n    return js_bigdecimal_to_string1(ctx, val, 0,\n                                    BF_RNDZ | BF_FTOA_FORMAT_FREE);\n}\n\n#endif /* CONFIG_BIGNUM */\n\n/* 2 <= base <= 36 */\nstatic char *i64toa(char *buf_end, int64_t n, unsigned int base)\n{\n    char *q = buf_end;\n    int digit, is_neg;\n\n    is_neg = 0;\n    if (n < 0) {\n        is_neg = 1;\n        n = -n;\n    }\n    *--q = '\\0';\n    do {\n        digit = (uint64_t)n % base;\n        n = (uint64_t)n / base;\n        if (digit < 10)\n            digit += '0';\n        else\n            digit += 'a' - 10;\n        *--q = digit;\n    } while (n != 0);\n    if (is_neg)\n        *--q = '-';\n    return q;\n}\n\n/* buf1 contains the printf result */\nstatic void js_ecvt1(double d, int n_digits, int *decpt, int *sign, char *buf,\n                     int rounding_mode, char *buf1, int buf1_size)\n{\n    if (rounding_mode != FE_TONEAREST)\n        fesetround(rounding_mode);\n    snprintf(buf1, buf1_size, \"%+.*e\", n_digits - 1, d);\n    if (rounding_mode != FE_TONEAREST)\n        fesetround(FE_TONEAREST);\n    *sign = (buf1[0] == '-');\n    /* mantissa */\n    buf[0] = buf1[1];\n    if (n_digits > 1)\n        memcpy(buf + 1, buf1 + 3, n_digits - 1);\n    buf[n_digits] = '\\0';\n    /* exponent */\n    *decpt = atoi(buf1 + n_digits + 2 + (n_digits > 1)) + 1;\n}\n\n/* maximum buffer size for js_dtoa */\n#define JS_DTOA_BUF_SIZE 128\n\n/* needed because ecvt usually limits the number of digits to\n   17. Return the number of digits. */\nstatic int js_ecvt(double d, int n_digits, int *decpt, int *sign, char *buf,\n                   BOOL is_fixed)\n{\n    int rounding_mode;\n    char buf_tmp[JS_DTOA_BUF_SIZE];\n\n    if (!is_fixed) {\n        unsigned int n_digits_min, n_digits_max;\n        /* find the minimum amount of digits (XXX: inefficient but simple) */\n        n_digits_min = 1;\n        n_digits_max = 17;\n        while (n_digits_min < n_digits_max) {\n            n_digits = (n_digits_min + n_digits_max) / 2;\n            js_ecvt1(d, n_digits, decpt, sign, buf, FE_TONEAREST,\n                     buf_tmp, sizeof(buf_tmp));\n            if (strtod(buf_tmp, NULL) == d) {\n                /* no need to keep the trailing zeros */\n                while (n_digits >= 2 && buf[n_digits - 1] == '0')\n                    n_digits--;\n                n_digits_max = n_digits;\n            } else {\n                n_digits_min = n_digits + 1;\n            }\n        }\n        n_digits = n_digits_max;\n        rounding_mode = FE_TONEAREST;\n    } else {\n        rounding_mode = FE_TONEAREST;\n#ifdef CONFIG_PRINTF_RNDN\n        {\n            char buf1[JS_DTOA_BUF_SIZE], buf2[JS_DTOA_BUF_SIZE];\n            int decpt1, sign1, decpt2, sign2;\n            /* The JS rounding is specified as round to nearest ties away\n               from zero (RNDNA), but in printf the \"ties\" case is not\n               specified (for example it is RNDN for glibc, RNDNA for\n               Windows), so we must round manually. */\n            js_ecvt1(d, n_digits + 1, &decpt1, &sign1, buf1, FE_TONEAREST,\n                     buf_tmp, sizeof(buf_tmp));\n            /* XXX: could use 2 digits to reduce the average running time */\n            if (buf1[n_digits] == '5') {\n                js_ecvt1(d, n_digits + 1, &decpt1, &sign1, buf1, FE_DOWNWARD,\n                         buf_tmp, sizeof(buf_tmp));\n                js_ecvt1(d, n_digits + 1, &decpt2, &sign2, buf2, FE_UPWARD,\n                         buf_tmp, sizeof(buf_tmp));\n                if (memcmp(buf1, buf2, n_digits + 1) == 0 && decpt1 == decpt2) {\n                    /* exact result: round away from zero */\n                    if (sign1)\n                        rounding_mode = FE_DOWNWARD;\n                    else\n                        rounding_mode = FE_UPWARD;\n                }\n            }\n        }\n#endif /* CONFIG_PRINTF_RNDN */\n    }\n    js_ecvt1(d, n_digits, decpt, sign, buf, rounding_mode,\n             buf_tmp, sizeof(buf_tmp));\n    return n_digits;\n}\n\nstatic int js_fcvt1(char *buf, int buf_size, double d, int n_digits,\n                    int rounding_mode)\n{\n    int n;\n    if (rounding_mode != FE_TONEAREST)\n        fesetround(rounding_mode);\n    n = snprintf(buf, buf_size, \"%.*f\", n_digits, d);\n    if (rounding_mode != FE_TONEAREST)\n        fesetround(FE_TONEAREST);\n    assert(n < buf_size);\n    return n;\n}\n\nstatic void js_fcvt(char *buf, int buf_size, double d, int n_digits)\n{\n    int rounding_mode;\n    rounding_mode = FE_TONEAREST;\n#ifdef CONFIG_PRINTF_RNDN\n    {\n        int n1, n2;\n        char buf1[JS_DTOA_BUF_SIZE];\n        char buf2[JS_DTOA_BUF_SIZE];\n\n        /* The JS rounding is specified as round to nearest ties away from\n           zero (RNDNA), but in printf the \"ties\" case is not specified\n           (for example it is RNDN for glibc, RNDNA for Windows), so we\n           must round manually. */\n        n1 = js_fcvt1(buf1, sizeof(buf1), d, n_digits + 1, FE_TONEAREST);\n        rounding_mode = FE_TONEAREST;\n        /* XXX: could use 2 digits to reduce the average running time */\n        if (buf1[n1 - 1] == '5') {\n            n1 = js_fcvt1(buf1, sizeof(buf1), d, n_digits + 1, FE_DOWNWARD);\n            n2 = js_fcvt1(buf2, sizeof(buf2), d, n_digits + 1, FE_UPWARD);\n            if (n1 == n2 && memcmp(buf1, buf2, n1) == 0) {\n                /* exact result: round away from zero */\n                if (buf1[0] == '-')\n                    rounding_mode = FE_DOWNWARD;\n                else\n                    rounding_mode = FE_UPWARD;\n            }\n        }\n    }\n#endif /* CONFIG_PRINTF_RNDN */\n    js_fcvt1(buf, buf_size, d, n_digits, rounding_mode);\n}\n\n/* radix != 10 is only supported with flags = JS_DTOA_VAR_FORMAT */\n/* use as many digits as necessary */\n#define JS_DTOA_VAR_FORMAT   (0 << 0)\n/* use n_digits significant digits (1 <= n_digits <= 101) */\n#define JS_DTOA_FIXED_FORMAT (1 << 0)\n/* force fractional format: [-]dd.dd with n_digits fractional digits */\n#define JS_DTOA_FRAC_FORMAT  (2 << 0)\n/* force exponential notation either in fixed or variable format */\n#define JS_DTOA_FORCE_EXP    (1 << 2)\n\n/* XXX: slow and maybe not fully correct. Use libbf when it is fast enough.\n   XXX: radix != 10 is only supported for small integers\n*/\nstatic void js_dtoa1(char *buf, double d, int radix, int n_digits, int flags)\n{\n    char *q;\n\n    if (!isfinite(d)) {\n        if (isnan(d)) {\n            strcpy(buf, \"NaN\");\n        } else {\n            q = buf;\n            if (d < 0)\n                *q++ = '-';\n            strcpy(q, \"Infinity\");\n        }\n    } else if (flags == JS_DTOA_VAR_FORMAT) {\n        int64_t i64;\n        char buf1[70], *ptr;\n        i64 = (int64_t)d;\n        if (d != i64 || i64 > MAX_SAFE_INTEGER || i64 < -MAX_SAFE_INTEGER)\n            goto generic_conv;\n        /* fast path for integers */\n        ptr = i64toa(buf1 + sizeof(buf1), i64, radix);\n        strcpy(buf, ptr);\n    } else {\n        if (d == 0.0)\n            d = 0.0; /* convert -0 to 0 */\n        if (flags == JS_DTOA_FRAC_FORMAT) {\n            js_fcvt(buf, JS_DTOA_BUF_SIZE, d, n_digits);\n        } else {\n            char buf1[JS_DTOA_BUF_SIZE];\n            int sign, decpt, k, n, i, p, n_max;\n            BOOL is_fixed;\n        generic_conv:\n            is_fixed = ((flags & 3) == JS_DTOA_FIXED_FORMAT);\n            if (is_fixed) {\n                n_max = n_digits;\n            } else {\n                n_max = 21;\n            }\n            /* the number has k digits (k >= 1) */\n            k = js_ecvt(d, n_digits, &decpt, &sign, buf1, is_fixed);\n            n = decpt; /* d=10^(n-k)*(buf1) i.e. d= < x.yyyy 10^(n-1) */\n            q = buf;\n            if (sign)\n                *q++ = '-';\n            if (flags & JS_DTOA_FORCE_EXP)\n                goto force_exp;\n            if (n >= 1 && n <= n_max) {\n                if (k <= n) {\n                    memcpy(q, buf1, k);\n                    q += k;\n                    for(i = 0; i < (n - k); i++)\n                        *q++ = '0';\n                    *q = '\\0';\n                } else {\n                    /* k > n */\n                    memcpy(q, buf1, n);\n                    q += n;\n                    *q++ = '.';\n                    for(i = 0; i < (k - n); i++)\n                        *q++ = buf1[n + i];\n                    *q = '\\0';\n                }\n            } else if (n >= -5 && n <= 0) {\n                *q++ = '0';\n                *q++ = '.';\n                for(i = 0; i < -n; i++)\n                    *q++ = '0';\n                memcpy(q, buf1, k);\n                q += k;\n                *q = '\\0';\n            } else {\n            force_exp:\n                /* exponential notation */\n                *q++ = buf1[0];\n                if (k > 1) {\n                    *q++ = '.';\n                    for(i = 1; i < k; i++)\n                        *q++ = buf1[i];\n                }\n                *q++ = 'e';\n                p = n - 1;\n                if (p >= 0)\n                    *q++ = '+';\n                sprintf(q, \"%d\", p);\n            }\n        }\n    }\n}\n\nstatic JSValue js_dtoa(JSContext *ctx,\n                       double d, int radix, int n_digits, int flags)\n{\n    char buf[JS_DTOA_BUF_SIZE];\n    js_dtoa1(buf, d, radix, n_digits, flags);\n    return JS_NewString(ctx, buf);\n}\n\nJSValue JS_ToStringInternal(JSContext *ctx, JSValueConst val, BOOL is_ToPropertyKey)\n{\n    uint32_t tag;\n    const char *str;\n    char buf[32];\n\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_STRING:\n        return JS_DupValue(ctx, val);\n    case JS_TAG_INT:\n        snprintf(buf, sizeof(buf), \"%d\", JS_VALUE_GET_INT(val));\n        str = buf;\n        goto new_string;\n    case JS_TAG_BOOL:\n        return JS_AtomToString(ctx, JS_VALUE_GET_BOOL(val) ?\n                          JS_ATOM_true : JS_ATOM_false);\n    case JS_TAG_NULL:\n        return JS_AtomToString(ctx, JS_ATOM_null);\n    case JS_TAG_UNDEFINED:\n        return JS_AtomToString(ctx, JS_ATOM_undefined);\n    case JS_TAG_EXCEPTION:\n        return JS_EXCEPTION;\n    case JS_TAG_OBJECT:\n        {\n            JSValue val1, ret;\n            val1 = JS_ToPrimitive(ctx, val, HINT_STRING);\n            if (JS_IsException(val1))\n                return val1;\n            ret = JS_ToStringInternal(ctx, val1, is_ToPropertyKey);\n            JS_FreeValue(ctx, val1);\n            return ret;\n        }\n        break;\n    case JS_TAG_FUNCTION_BYTECODE:\n        str = \"[function bytecode]\";\n        goto new_string;\n    case JS_TAG_SYMBOL:\n        if (is_ToPropertyKey) {\n            return JS_DupValue(ctx, val);\n        } else {\n            return JS_ThrowTypeError(ctx, \"cannot convert symbol to string\");\n        }\n    case JS_TAG_FLOAT64:\n        return js_dtoa(ctx, JS_VALUE_GET_FLOAT64(val), 10, 0,\n                       JS_DTOA_VAR_FORMAT);\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n        return ctx->rt->bigint_ops.to_string(ctx, val);\n    case JS_TAG_BIG_FLOAT:\n        return ctx->rt->bigfloat_ops.to_string(ctx, val);\n    case JS_TAG_BIG_DECIMAL:\n        return ctx->rt->bigdecimal_ops.to_string(ctx, val);\n#endif\n    default:\n        str = \"[unsupported type]\";\n    new_string:\n        return JS_NewString(ctx, str);\n    }\n}\n\nJSValue JS_ToString(JSContext *ctx, JSValueConst val)\n{\n    return JS_ToStringInternal(ctx, val, FALSE);\n}\n\nstatic JSValue JS_ToStringFree(JSContext *ctx, JSValue val)\n{\n    JSValue ret;\n    ret = JS_ToString(ctx, val);\n    JS_FreeValue(ctx, val);\n    return ret;\n}\n\nstatic JSValue JS_ToLocaleStringFree(JSContext *ctx, JSValue val)\n{\n    if (JS_IsUndefined(val) || JS_IsNull(val))\n        return JS_ToStringFree(ctx, val);\n    return JS_InvokeFree(ctx, val, JS_ATOM_toLocaleString, 0, NULL);\n}\n\nJSValue JS_ToPropertyKey(JSContext *ctx, JSValueConst val)\n{\n    return JS_ToStringInternal(ctx, val, TRUE);\n}\n\nstatic JSValue JS_ToStringCheckObject(JSContext *ctx, JSValueConst val)\n{\n    uint32_t tag = JS_VALUE_GET_TAG(val);\n    if (tag == JS_TAG_NULL || tag == JS_TAG_UNDEFINED)\n        return JS_ThrowTypeError(ctx, \"null or undefined are forbidden\");\n    return JS_ToString(ctx, val);\n}\n\nstatic JSValue JS_ToQuotedString(JSContext *ctx, JSValueConst val1)\n{\n    JSValue val;\n    JSString *p;\n    int i;\n    uint32_t c;\n    StringBuffer b_s, *b = &b_s;\n    char buf[16];\n\n    val = JS_ToStringCheckObject(ctx, val1);\n    if (JS_IsException(val))\n        return val;\n    p = JS_VALUE_GET_STRING(val);\n\n    if (string_buffer_init(ctx, b, p->len + 2))\n        goto fail;\n\n    if (string_buffer_putc8(b, '\\\"'))\n        goto fail;\n    for(i = 0; i < p->len; ) {\n        c = string_getc(p, &i);\n        switch(c) {\n        case '\\t':\n            c = 't';\n            goto quote;\n        case '\\r':\n            c = 'r';\n            goto quote;\n        case '\\n':\n            c = 'n';\n            goto quote;\n        case '\\b':\n            c = 'b';\n            goto quote;\n        case '\\f':\n            c = 'f';\n            goto quote;\n        case '\\\"':\n        case '\\\\':\n        quote:\n            if (string_buffer_putc8(b, '\\\\'))\n                goto fail;\n            if (string_buffer_putc8(b, c))\n                goto fail;\n            break;\n        default:\n            if (c < 32 || (c >= 0xd800 && c < 0xe000)) {\n                snprintf(buf, sizeof(buf), \"\\\\u%04x\", c);\n                if (string_buffer_puts8(b, buf))\n                    goto fail;\n            } else {\n                if (string_buffer_putc(b, c))\n                    goto fail;\n            }\n            break;\n        }\n    }\n    if (string_buffer_putc8(b, '\\\"'))\n        goto fail;\n    JS_FreeValue(ctx, val);\n    return string_buffer_end(b);\n fail:\n    JS_FreeValue(ctx, val);\n    string_buffer_free(b);\n    return JS_EXCEPTION;\n}\n\nstatic __maybe_unused void JS_DumpObjectHeader(JSRuntime *rt)\n{\n    printf(\"%14s %4s %4s %14s %10s %s\\n\",\n           \"ADDRESS\", \"REFS\", \"SHRF\", \"PROTO\", \"CLASS\", \"PROPS\");\n}\n\n/* for debug only: dump an object without side effect */\nstatic __maybe_unused void JS_DumpObject(JSRuntime *rt, JSObject *p)\n{\n    uint32_t i;\n    char atom_buf[ATOM_GET_STR_BUF_SIZE];\n    JSShape *sh;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    BOOL is_first = TRUE;\n\n    /* XXX: should encode atoms with special characters */\n    sh = p->shape; /* the shape can be NULL while freeing an object */\n    printf(\"%14p %4d \",\n           (void *)p,\n           p->header.ref_count);\n    if (sh) {\n        printf(\"%3d%c %14p \",\n               sh->header.ref_count,\n               \" *\"[sh->is_hashed],\n               (void *)sh->proto);\n    } else {\n        printf(\"%3s  %14s \", \"-\", \"-\");\n    }\n    printf(\"%10s \",\n           JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), rt->class_array[p->class_id].class_name));\n    if (p->is_exotic && p->fast_array) {\n        printf(\"[ \");\n        for(i = 0; i < p->u.array.count; i++) {\n            if (i != 0)\n                printf(\", \");\n            switch (p->class_id) {\n            case JS_CLASS_ARRAY:\n            case JS_CLASS_ARGUMENTS:\n                JS_DumpValueShort(rt, p->u.array.u.values[i]);\n                break;\n            case JS_CLASS_UINT8C_ARRAY:\n            case JS_CLASS_INT8_ARRAY:\n            case JS_CLASS_UINT8_ARRAY:\n            case JS_CLASS_INT16_ARRAY:\n            case JS_CLASS_UINT16_ARRAY:\n            case JS_CLASS_INT32_ARRAY:\n            case JS_CLASS_UINT32_ARRAY:\n#ifdef CONFIG_BIGNUM\n            case JS_CLASS_BIG_INT64_ARRAY:\n            case JS_CLASS_BIG_UINT64_ARRAY:\n#endif\n            case JS_CLASS_FLOAT32_ARRAY:\n            case JS_CLASS_FLOAT64_ARRAY:\n                {\n                    int size = 1 << typed_array_size_log2(p->class_id);\n                    const uint8_t *b = p->u.array.u.uint8_ptr + i * size;\n                    while (size-- > 0)\n                        printf(\"%02X\", *b++);\n                }\n                break;\n            }\n        }\n        printf(\" ] \");\n    }\n\n    if (sh) {\n        printf(\"{ \");\n        for(i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {\n            if (prs->atom != JS_ATOM_NULL) {\n                pr = &p->prop[i];\n                if (!is_first)\n                    printf(\", \");\n                printf(\"%s: \",\n                       JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), prs->atom));\n                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n                    printf(\"[getset %p %p]\", (void *)pr->u.getset.getter,\n                           (void *)pr->u.getset.setter);\n                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n                    printf(\"[varref %p]\", (void *)pr->u.var_ref);\n                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n                    printf(\"[autoinit %p %d %p]\",\n                           (void *)js_autoinit_get_realm(pr),\n                           js_autoinit_get_id(pr),\n                           (void *)pr->u.init.opaque);\n                } else {\n                    JS_DumpValueShort(rt, pr->u.value);\n                }\n                is_first = FALSE;\n            }\n        }\n        printf(\" }\");\n    }\n    \n    if (js_class_has_bytecode(p->class_id)) {\n        JSFunctionBytecode *b = p->u.func.function_bytecode;\n        JSVarRef **var_refs;\n        if (b->closure_var_count) {\n            var_refs = p->u.func.var_refs;\n            printf(\" Closure:\");\n            for(i = 0; i < b->closure_var_count; i++) {\n                printf(\" \");\n                JS_DumpValueShort(rt, var_refs[i]->value);\n            }\n            if (p->u.func.home_object) {\n                printf(\" HomeObject: \");\n                JS_DumpValueShort(rt, JS_MKPTR(JS_TAG_OBJECT, p->u.func.home_object));\n            }\n        }\n    }\n    printf(\"\\n\");\n}\n\nstatic __maybe_unused void JS_DumpGCObject(JSRuntime *rt, JSGCObjectHeader *p)\n{\n    if (p->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT) {\n        JS_DumpObject(rt, (JSObject *)p);\n    } else {\n        printf(\"%14p %4d \",\n               (void *)p,\n               p->ref_count);\n        switch(p->gc_obj_type) {\n        case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:\n            printf(\"[function bytecode]\");\n            break;\n        case JS_GC_OBJ_TYPE_SHAPE:\n            printf(\"[shape]\");\n            break;\n        case JS_GC_OBJ_TYPE_VAR_REF:\n            printf(\"[var_ref]\");\n            break;\n        case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:\n            printf(\"[async_function]\");\n            break;\n        case JS_GC_OBJ_TYPE_JS_CONTEXT:\n            printf(\"[js_context]\");\n            break;\n        default:\n            printf(\"[unknown %d]\", p->gc_obj_type);\n            break;\n        }\n        printf(\"\\n\");\n    }\n}\n\nstatic __maybe_unused void JS_DumpValueShort(JSRuntime *rt,\n                                                      JSValueConst val)\n{\n    uint32_t tag = JS_VALUE_GET_NORM_TAG(val);\n    const char *str;\n\n    switch(tag) {\n    case JS_TAG_INT:\n        printf(\"%d\", JS_VALUE_GET_INT(val));\n        break;\n    case JS_TAG_BOOL:\n        if (JS_VALUE_GET_BOOL(val))\n            str = \"true\";\n        else\n            str = \"false\";\n        goto print_str;\n    case JS_TAG_NULL:\n        str = \"null\";\n        goto print_str;\n    case JS_TAG_EXCEPTION:\n        str = \"exception\";\n        goto print_str;\n    case JS_TAG_UNINITIALIZED:\n        str = \"uninitialized\";\n        goto print_str;\n    case JS_TAG_UNDEFINED:\n        str = \"undefined\";\n    print_str:\n        printf(\"%s\", str);\n        break;\n    case JS_TAG_FLOAT64:\n        printf(\"%.14g\", JS_VALUE_GET_FLOAT64(val));\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            char *str;\n            str = bf_ftoa(NULL, &p->num, 10, 0,\n                          BF_RNDZ | BF_FTOA_FORMAT_FRAC);\n            printf(\"%sn\", str);\n            bf_realloc(&rt->bf_ctx, str, 0);\n        }\n        break;\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            char *str;\n            str = bf_ftoa(NULL, &p->num, 16, BF_PREC_INF,\n                          BF_RNDZ | BF_FTOA_FORMAT_FREE | BF_FTOA_ADD_PREFIX);\n            printf(\"%sl\", str);\n            bf_free(&rt->bf_ctx, str);\n        }\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        {\n            JSBigDecimal *p = JS_VALUE_GET_PTR(val);\n            char *str;\n            str = bfdec_ftoa(NULL, &p->num, BF_PREC_INF,\n                             BF_RNDZ | BF_FTOA_FORMAT_FREE);\n            printf(\"%sm\", str);\n            bf_free(&rt->bf_ctx, str);\n        }\n        break;\n#endif\n    case JS_TAG_STRING:\n        {\n            JSString *p;\n            p = JS_VALUE_GET_STRING(val);\n            JS_DumpString(rt, p);\n        }\n        break;\n    case JS_TAG_FUNCTION_BYTECODE:\n        {\n            JSFunctionBytecode *b = JS_VALUE_GET_PTR(val);\n            char buf[ATOM_GET_STR_BUF_SIZE];\n            printf(\"[bytecode %s]\", JS_AtomGetStrRT(rt, buf, sizeof(buf), b->func_name));\n        }\n        break;\n    case JS_TAG_OBJECT:\n        {\n            JSObject *p = JS_VALUE_GET_OBJ(val);\n            JSAtom atom = rt->class_array[p->class_id].class_name;\n            char atom_buf[ATOM_GET_STR_BUF_SIZE];\n            printf(\"[%s %p]\",\n                   JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), atom), (void *)p);\n        }\n        break;\n    case JS_TAG_SYMBOL:\n        {\n            JSAtomStruct *p = JS_VALUE_GET_PTR(val);\n            char atom_buf[ATOM_GET_STR_BUF_SIZE];\n            printf(\"Symbol(%s)\",\n                   JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), js_get_atom_index(rt, p)));\n        }\n        break;\n    case JS_TAG_MODULE:\n        printf(\"[module]\");\n        break;\n    default:\n        printf(\"[unknown tag %d]\", tag);\n        break;\n    }\n}\n\nstatic __maybe_unused void JS_DumpValue(JSContext *ctx,\n                                                 JSValueConst val)\n{\n    JS_DumpValueShort(ctx->rt, val);\n}\n\nstatic __maybe_unused void JS_PrintValue(JSContext *ctx,\n                                                  const char *str,\n                                                  JSValueConst val)\n{\n    printf(\"%s=\", str);\n    JS_DumpValueShort(ctx->rt, val);\n    printf(\"\\n\");\n}\n\n/* return -1 if exception (proxy case) or TRUE/FALSE */\nint JS_IsArray(JSContext *ctx, JSValueConst val)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) == JS_TAG_OBJECT) {\n        p = JS_VALUE_GET_OBJ(val);\n        if (unlikely(p->class_id == JS_CLASS_PROXY))\n            return js_proxy_isArray(ctx, val);\n        else\n            return p->class_id == JS_CLASS_ARRAY;\n    } else {\n        return FALSE;\n    }\n}\n\nstatic double js_pow(double a, double b)\n{\n    if (unlikely(!isfinite(b)) && fabs(a) == 1) {\n        /* not compatible with IEEE 754 */\n        return JS_FLOAT64_NAN;\n    } else {\n        return pow(a, b);\n    }\n}\n\n#ifdef CONFIG_BIGNUM\n\nJSValue JS_NewBigInt64_1(JSContext *ctx, int64_t v)\n{\n    JSValue val;\n    bf_t *a;\n    val = JS_NewBigInt(ctx);\n    if (JS_IsException(val))\n        return val;\n    a = JS_GetBigInt(val);\n    if (bf_set_si(a, v)) {\n        JS_FreeValue(ctx, val);\n        return JS_ThrowOutOfMemory(ctx);\n    }\n    return val;\n}\n\nJSValue JS_NewBigInt64(JSContext *ctx, int64_t v)\n{\n    if (is_math_mode(ctx) &&\n        v >= -MAX_SAFE_INTEGER && v <= MAX_SAFE_INTEGER) {\n        return JS_NewInt64(ctx, v);\n    } else {\n        return JS_NewBigInt64_1(ctx, v);\n    }\n}\n\nJSValue JS_NewBigUint64(JSContext *ctx, uint64_t v)\n{\n    JSValue val;\n    if (is_math_mode(ctx) && v <= MAX_SAFE_INTEGER) {\n        val = JS_NewInt64(ctx, v);\n    } else {\n        bf_t *a;\n        val = JS_NewBigInt(ctx);\n        if (JS_IsException(val))\n            return val;\n        a = JS_GetBigInt(val);\n        if (bf_set_ui(a, v)) {\n            JS_FreeValue(ctx, val);\n            return JS_ThrowOutOfMemory(ctx);\n        }\n    }\n    return val;\n}\n\n/* if the returned bigfloat is allocated it is equal to\n   'buf'. Otherwise it is a pointer to the bigfloat in 'val'. Return\n   NULL in case of error. */\nstatic bf_t *JS_ToBigFloat(JSContext *ctx, bf_t *buf, JSValueConst val)\n{\n    uint32_t tag;\n    bf_t *r;\n    JSBigFloat *p;\n\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n        r = buf;\n        bf_init(ctx->bf_ctx, r);\n        if (bf_set_si(r, JS_VALUE_GET_INT(val)))\n            goto fail;\n        break;\n    case JS_TAG_FLOAT64:\n        r = buf;\n        bf_init(ctx->bf_ctx, r);\n        if (bf_set_float64(r, JS_VALUE_GET_FLOAT64(val))) {\n        fail:\n            bf_delete(r);\n            return NULL;\n        }\n        break;\n    case JS_TAG_BIG_INT:\n    case JS_TAG_BIG_FLOAT:\n        p = JS_VALUE_GET_PTR(val);\n        r = &p->num;\n        break;\n    case JS_TAG_UNDEFINED:\n    default:\n        r = buf;\n        bf_init(ctx->bf_ctx, r);\n        bf_set_nan(r);\n        break;\n    }\n    return r;\n}\n\n/* return NULL if invalid type */\nstatic bfdec_t *JS_ToBigDecimal(JSContext *ctx, JSValueConst val)\n{\n    uint32_t tag;\n    JSBigDecimal *p;\n    bfdec_t *r;\n    \n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_BIG_DECIMAL:\n        p = JS_VALUE_GET_PTR(val);\n        r = &p->num;\n        break;\n    default:\n        JS_ThrowTypeError(ctx, \"bigdecimal expected\");\n        r = NULL;\n        break;\n    }\n    return r;\n}\n\n/* return NaN if bad bigint literal */\nstatic JSValue JS_StringToBigInt(JSContext *ctx, JSValue val)\n{\n    const char *str, *p;\n    size_t len;\n    int flags;\n    \n    str = JS_ToCStringLen(ctx, &len, val);\n    JS_FreeValue(ctx, val);\n    if (!str)\n        return JS_EXCEPTION;\n    p = str;\n    p += skip_spaces(p);\n    if ((p - str) == len) {\n        val = JS_NewBigInt64(ctx, 0);\n    } else {\n        flags = ATOD_INT_ONLY | ATOD_ACCEPT_BIN_OCT | ATOD_TYPE_BIG_INT;\n        if (is_math_mode(ctx))\n            flags |= ATOD_MODE_BIGINT;\n        val = js_atof(ctx, p, &p, 0, flags);\n        p += skip_spaces(p);\n        if (!JS_IsException(val)) {\n            if ((p - str) != len) {\n                JS_FreeValue(ctx, val);\n                val = JS_NAN;\n            }\n        }\n    }\n    JS_FreeCString(ctx, str);\n    return val;\n}\n\nstatic JSValue JS_StringToBigIntErr(JSContext *ctx, JSValue val)\n{\n    val = JS_StringToBigInt(ctx, val);\n    if (JS_VALUE_IS_NAN(val))\n        return JS_ThrowSyntaxError(ctx, \"invalid bigint literal\");\n    return val;\n}\n\n/* if the returned bigfloat is allocated it is equal to\n   'buf'. Otherwise it is a pointer to the bigfloat in 'val'. */\nstatic bf_t *JS_ToBigIntFree(JSContext *ctx, bf_t *buf, JSValue val)\n{\n    uint32_t tag;\n    bf_t *r;\n    JSBigFloat *p;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        if (!is_math_mode(ctx))\n            goto fail;\n        /* fall tru */\n    case JS_TAG_BOOL:\n        r = buf;\n        bf_init(ctx->bf_ctx, r);\n        bf_set_si(r, JS_VALUE_GET_INT(val));\n        break;\n    case JS_TAG_FLOAT64:\n        {\n            double d = JS_VALUE_GET_FLOAT64(val);\n            if (!is_math_mode(ctx))\n                goto fail;\n            if (!isfinite(d))\n                goto fail;\n            r = buf;\n            bf_init(ctx->bf_ctx, r);\n            d = trunc(d);\n            bf_set_float64(r, d);\n        }\n        break;\n    case JS_TAG_BIG_INT:\n        p = JS_VALUE_GET_PTR(val);\n        r = &p->num;\n        break;\n    case JS_TAG_BIG_FLOAT:\n        if (!is_math_mode(ctx))\n            goto fail;\n        p = JS_VALUE_GET_PTR(val);\n        if (!bf_is_finite(&p->num))\n            goto fail;\n        r = buf;\n        bf_init(ctx->bf_ctx, r);\n        bf_set(r, &p->num);\n        bf_rint(r, BF_RNDZ);\n        JS_FreeValue(ctx, val);\n        break;\n    case JS_TAG_STRING:\n        val = JS_StringToBigIntErr(ctx, val);\n        if (JS_IsException(val))\n            return NULL;\n        goto redo;\n    case JS_TAG_OBJECT:\n        val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);\n        if (JS_IsException(val))\n            return NULL;\n        goto redo;\n    default:\n    fail:\n        JS_FreeValue(ctx, val);\n        JS_ThrowTypeError(ctx, \"cannot convert to bigint\");\n        return NULL;\n    }\n    return r;\n}\n\nstatic bf_t *JS_ToBigInt(JSContext *ctx, bf_t *buf, JSValueConst val)\n{\n    return JS_ToBigIntFree(ctx, buf, JS_DupValue(ctx, val));\n}\n\nstatic __maybe_unused JSValue JS_ToBigIntValueFree(JSContext *ctx, JSValue val)\n{\n    if (JS_VALUE_GET_TAG(val) == JS_TAG_BIG_INT) {\n        return val;\n    } else {\n        bf_t a_s, *a, *r;\n        int ret;\n        JSValue res; \n\n        res = JS_NewBigInt(ctx);\n        if (JS_IsException(res))\n            return JS_EXCEPTION;\n        a = JS_ToBigIntFree(ctx, &a_s, val);\n        if (!a) {\n            JS_FreeValue(ctx, res);\n            return JS_EXCEPTION;\n        }\n        r = JS_GetBigInt(res);\n        ret = bf_set(r, a);\n        JS_FreeBigInt(ctx, a, &a_s);\n        if (ret) {\n            JS_FreeValue(ctx, res);\n            return JS_ThrowOutOfMemory(ctx);\n        }\n        return JS_CompactBigInt(ctx, res);\n    }\n}\n\n/* free the bf_t allocated by JS_ToBigInt */\nstatic void JS_FreeBigInt(JSContext *ctx, bf_t *a, bf_t *buf)\n{\n    if (a == buf) {\n        bf_delete(a);\n    } else {\n        JSBigFloat *p = (JSBigFloat *)((uint8_t *)a -\n                                       offsetof(JSBigFloat, num));\n        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_BIG_FLOAT, p));\n    }\n}\n\n/* XXX: merge with JS_ToInt64Free with a specific flag */\nstatic int JS_ToBigInt64Free(JSContext *ctx, int64_t *pres, JSValue val)\n{\n    bf_t a_s, *a;\n\n    a = JS_ToBigIntFree(ctx, &a_s, val);\n    if (!a) {\n        *pres = 0;\n        return -1;\n    }\n    bf_get_int64(pres, a, BF_GET_INT_MOD);\n    JS_FreeBigInt(ctx, a, &a_s);\n    return 0;\n}\n\nint JS_ToBigInt64(JSContext *ctx, int64_t *pres, JSValueConst val)\n{\n    return JS_ToBigInt64Free(ctx, pres, JS_DupValue(ctx, val));\n}\n\nstatic JSBigFloat *js_new_bf(JSContext *ctx)\n{\n    JSBigFloat *p;\n    p = js_malloc(ctx, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->header.ref_count = 1;\n    bf_init(ctx->bf_ctx, &p->num);\n    return p;\n}\n\nstatic JSValue JS_NewBigFloat(JSContext *ctx)\n{\n    JSBigFloat *p;\n    p = js_malloc(ctx, sizeof(*p));\n    if (!p)\n        return JS_EXCEPTION;\n    p->header.ref_count = 1;\n    bf_init(ctx->bf_ctx, &p->num);\n    return JS_MKPTR(JS_TAG_BIG_FLOAT, p);\n}\n\nstatic JSValue JS_NewBigDecimal(JSContext *ctx)\n{\n    JSBigDecimal *p;\n    p = js_malloc(ctx, sizeof(*p));\n    if (!p)\n        return JS_EXCEPTION;\n    p->header.ref_count = 1;\n    bfdec_init(ctx->bf_ctx, &p->num);\n    return JS_MKPTR(JS_TAG_BIG_DECIMAL, p);\n}\n\nstatic JSValue JS_NewBigInt(JSContext *ctx)\n{\n    JSBigFloat *p;\n    p = js_malloc(ctx, sizeof(*p));\n    if (!p)\n        return JS_EXCEPTION;\n    p->header.ref_count = 1;\n    bf_init(ctx->bf_ctx, &p->num);\n    return JS_MKPTR(JS_TAG_BIG_INT, p);\n}\n\nstatic JSValue JS_CompactBigInt1(JSContext *ctx, JSValue val,\n                                 BOOL convert_to_safe_integer)\n{\n    int64_t v;\n    bf_t *a;\n    \n    if (JS_VALUE_GET_TAG(val) != JS_TAG_BIG_INT)\n        return val; /* fail safe */\n    a = JS_GetBigInt(val);\n    if (convert_to_safe_integer && bf_get_int64(&v, a, 0) == 0 &&\n        v >= -MAX_SAFE_INTEGER && v <= MAX_SAFE_INTEGER) {\n        JS_FreeValue(ctx, val);\n        return JS_NewInt64(ctx, v);\n    } else if (a->expn == BF_EXP_ZERO && a->sign) {\n        JSBigFloat *p = JS_VALUE_GET_PTR(val);\n        assert(p->header.ref_count == 1);\n        a->sign = 0;\n    }\n    return val;\n}\n\n/* Convert the big int to a safe integer if in math mode. normalize\n   the zero representation. Could also be used to convert the bigint\n   to a short bigint value. The reference count of the value must be\n   1. Cannot fail */\nstatic JSValue JS_CompactBigInt(JSContext *ctx, JSValue val)\n{\n    return JS_CompactBigInt1(ctx, val, is_math_mode(ctx));\n}\n\n/* must be kept in sync with JSOverloadableOperatorEnum */\n/* XXX: use atoms ? */\nstatic const char js_overloadable_operator_names[JS_OVOP_COUNT][4] = {\n    \"+\",\n    \"-\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \"**\",\n    \"|\",\n    \"&\",\n    \"^\",\n    \"<<\",\n    \">>\",\n    \">>>\",\n    \"==\",\n    \"<\",\n    \"pos\",\n    \"neg\",\n    \"++\",\n    \"--\",\n    \"~\",\n};\n\nstatic int get_ovop_from_opcode(OPCodeEnum op)\n{\n    switch(op) {\n    case OP_add:\n        return JS_OVOP_ADD;\n    case OP_sub:\n        return JS_OVOP_SUB;\n    case OP_mul:\n        return JS_OVOP_MUL;\n    case OP_div:\n        return JS_OVOP_DIV;\n    case OP_mod:\n    case OP_math_mod:\n        return JS_OVOP_MOD;\n    case OP_pow:\n        return JS_OVOP_POW;\n    case OP_or:\n        return JS_OVOP_OR;\n    case OP_and:\n        return JS_OVOP_AND;\n    case OP_xor:\n        return JS_OVOP_XOR;\n    case OP_shl:\n        return JS_OVOP_SHL;\n    case OP_sar:\n        return JS_OVOP_SAR;\n    case OP_shr:\n        return JS_OVOP_SHR;\n    case OP_eq:\n    case OP_neq:\n        return JS_OVOP_EQ;\n    case OP_lt:\n    case OP_lte:\n    case OP_gt:\n    case OP_gte:\n        return JS_OVOP_LESS;\n    case OP_plus:\n        return JS_OVOP_POS;\n    case OP_neg:\n        return JS_OVOP_NEG;\n    case OP_inc:\n        return JS_OVOP_INC;\n    case OP_dec:\n        return JS_OVOP_DEC;\n    default:\n        abort();\n    }\n}\n\n/* return NULL if not present */\nstatic JSObject *find_binary_op(JSBinaryOperatorDef *def,\n                                uint32_t operator_index,\n                                JSOverloadableOperatorEnum op)\n{\n    JSBinaryOperatorDefEntry *ent;\n    int i;\n    for(i = 0; i < def->count; i++) {\n        ent = &def->tab[i];\n        if (ent->operator_index == operator_index)\n            return ent->ops[op];\n    }\n    return NULL;\n}\n\n/* return -1 if exception, 0 if no operator overloading, 1 if\n   overloaded operator called */\nstatic __exception int js_call_binary_op_fallback(JSContext *ctx,\n                                                  JSValue *pret,\n                                                  JSValueConst op1,\n                                                  JSValueConst op2,\n                                                  OPCodeEnum op,\n                                                  BOOL is_numeric,\n                                                  int hint)\n{\n    JSValue opset1_obj, opset2_obj, method, ret, new_op1, new_op2;\n    JSOperatorSetData *opset1, *opset2;\n    JSOverloadableOperatorEnum ovop;\n    JSObject *p;\n    JSValueConst args[2];\n    \n    if (!ctx->allow_operator_overloading)\n        return 0;\n    \n    opset2_obj = JS_UNDEFINED;\n    opset1_obj = JS_GetProperty(ctx, op1, JS_ATOM_Symbol_operatorSet);\n    if (JS_IsException(opset1_obj))\n        goto exception;\n    if (JS_IsUndefined(opset1_obj))\n        return 0;\n    opset1 = JS_GetOpaque2(ctx, opset1_obj, JS_CLASS_OPERATOR_SET);\n    if (!opset1)\n        goto exception;\n\n    opset2_obj = JS_GetProperty(ctx, op2, JS_ATOM_Symbol_operatorSet);\n    if (JS_IsException(opset2_obj))\n        goto exception;\n    if (JS_IsUndefined(opset2_obj)) {\n        JS_FreeValue(ctx, opset1_obj);\n        return 0;\n    }\n    opset2 = JS_GetOpaque2(ctx, opset2_obj, JS_CLASS_OPERATOR_SET);\n    if (!opset2)\n        goto exception;\n\n    if (opset1->is_primitive && opset2->is_primitive) {\n        JS_FreeValue(ctx, opset1_obj);\n        JS_FreeValue(ctx, opset2_obj);\n        return 0;\n    }\n\n    ovop = get_ovop_from_opcode(op);\n    \n    if (opset1->operator_counter == opset2->operator_counter) {\n        p = opset1->self_ops[ovop];\n    } else if (opset1->operator_counter > opset2->operator_counter) {\n        p = find_binary_op(&opset1->left, opset2->operator_counter, ovop);\n    } else {\n        p = find_binary_op(&opset2->right, opset1->operator_counter, ovop);\n    }\n    if (!p) {\n        JS_ThrowTypeError(ctx, \"operator %s: no function defined\",\n                          js_overloadable_operator_names[ovop]);\n        goto exception;\n    }\n\n    if (opset1->is_primitive) {\n        if (is_numeric) {\n            new_op1 = JS_ToNumeric(ctx, op1);\n        } else {\n            new_op1 = JS_ToPrimitive(ctx, op1, hint);\n        }\n        if (JS_IsException(new_op1))\n            goto exception;\n    } else {\n        new_op1 = JS_DupValue(ctx, op1);\n    }\n    \n    if (opset2->is_primitive) {\n        if (is_numeric) {\n            new_op2 = JS_ToNumeric(ctx, op2);\n        } else {\n            new_op2 = JS_ToPrimitive(ctx, op2, hint);\n        }\n        if (JS_IsException(new_op2)) {\n            JS_FreeValue(ctx, new_op1);\n            goto exception;\n        }\n    } else {\n        new_op2 = JS_DupValue(ctx, op2);\n    }\n\n    /* XXX: could apply JS_ToPrimitive() if primitive type so that the\n       operator function does not get a value object */\n    \n    method = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n    if (ovop == JS_OVOP_LESS && (op == OP_lte || op == OP_gt)) {\n        args[0] = new_op2;\n        args[1] = new_op1;\n    } else {\n        args[0] = new_op1;\n        args[1] = new_op2;\n    }\n    ret = JS_CallFree(ctx, method, JS_UNDEFINED, 2, args);\n    JS_FreeValue(ctx, new_op1);\n    JS_FreeValue(ctx, new_op2);\n    if (JS_IsException(ret))\n        goto exception;\n    if (ovop == JS_OVOP_EQ) {\n        BOOL res = JS_ToBoolFree(ctx, ret);\n        if (op == OP_neq)\n            res ^= 1;\n        ret = JS_NewBool(ctx, res);\n    } else if (ovop == JS_OVOP_LESS) {\n        if (JS_IsUndefined(ret)) {\n            ret = JS_FALSE;\n        } else {\n            BOOL res = JS_ToBoolFree(ctx, ret);\n            if (op == OP_lte || op == OP_gte)\n                res ^= 1;\n            ret = JS_NewBool(ctx, res);\n        }\n    }\n    JS_FreeValue(ctx, opset1_obj);\n    JS_FreeValue(ctx, opset2_obj);\n    *pret = ret;\n    return 1;\n exception:\n    JS_FreeValue(ctx, opset1_obj);\n    JS_FreeValue(ctx, opset2_obj);\n    *pret = JS_UNDEFINED;\n    return -1;\n}\n\n/* try to call the operation on the operatorSet field of 'obj'. Only\n   used for \"/\" and \"**\" on the BigInt prototype in math mode */\nstatic __exception int js_call_binary_op_simple(JSContext *ctx,\n                                                JSValue *pret,\n                                                JSValueConst obj,\n                                                JSValueConst op1,\n                                                JSValueConst op2,\n                                                OPCodeEnum op)\n{\n    JSValue opset1_obj, method, ret, new_op1, new_op2;\n    JSOperatorSetData *opset1;\n    JSOverloadableOperatorEnum ovop;\n    JSObject *p;\n    JSValueConst args[2];\n\n    opset1_obj = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_operatorSet);\n    if (JS_IsException(opset1_obj))\n        goto exception;\n    if (JS_IsUndefined(opset1_obj))\n        return 0;\n    opset1 = JS_GetOpaque2(ctx, opset1_obj, JS_CLASS_OPERATOR_SET);\n    if (!opset1)\n        goto exception;\n    ovop = get_ovop_from_opcode(op);\n\n    p = opset1->self_ops[ovop];\n    if (!p) {\n        JS_FreeValue(ctx, opset1_obj);\n        return 0;\n    }\n\n    new_op1 = JS_ToNumeric(ctx, op1);\n    if (JS_IsException(new_op1))\n        goto exception;\n    new_op2 = JS_ToNumeric(ctx, op2);\n    if (JS_IsException(new_op2)) {\n        JS_FreeValue(ctx, new_op1);\n        goto exception;\n    }\n\n    method = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n    args[0] = new_op1;\n    args[1] = new_op2;\n    ret = JS_CallFree(ctx, method, JS_UNDEFINED, 2, args);\n    JS_FreeValue(ctx, new_op1);\n    JS_FreeValue(ctx, new_op2);\n    if (JS_IsException(ret))\n        goto exception;\n    JS_FreeValue(ctx, opset1_obj);\n    *pret = ret;\n    return 1;\n exception:\n    JS_FreeValue(ctx, opset1_obj);\n    *pret = JS_UNDEFINED;\n    return -1;\n}\n\n/* return -1 if exception, 0 if no operator overloading, 1 if\n   overloaded operator called */\nstatic __exception int js_call_unary_op_fallback(JSContext *ctx,\n                                                 JSValue *pret,\n                                                 JSValueConst op1,\n                                                 OPCodeEnum op)\n{\n    JSValue opset1_obj, method, ret;\n    JSOperatorSetData *opset1;\n    JSOverloadableOperatorEnum ovop;\n    JSObject *p;\n\n    if (!ctx->allow_operator_overloading)\n        return 0;\n    \n    opset1_obj = JS_GetProperty(ctx, op1, JS_ATOM_Symbol_operatorSet);\n    if (JS_IsException(opset1_obj))\n        goto exception;\n    if (JS_IsUndefined(opset1_obj))\n        return 0;\n    opset1 = JS_GetOpaque2(ctx, opset1_obj, JS_CLASS_OPERATOR_SET);\n    if (!opset1)\n        goto exception;\n    if (opset1->is_primitive) {\n        JS_FreeValue(ctx, opset1_obj);\n        return 0;\n    }\n\n    ovop = get_ovop_from_opcode(op);\n\n    p = opset1->self_ops[ovop];\n    if (!p) {\n        JS_ThrowTypeError(ctx, \"no overloaded operator %s\",\n                          js_overloadable_operator_names[ovop]);\n        goto exception;\n    }\n    method = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n    ret = JS_CallFree(ctx, method, JS_UNDEFINED, 1, &op1);\n    if (JS_IsException(ret))\n        goto exception;\n    JS_FreeValue(ctx, opset1_obj);\n    *pret = ret;\n    return 1;\n exception:\n    JS_FreeValue(ctx, opset1_obj);\n    *pret = JS_UNDEFINED;\n    return -1;\n}\n\nstatic JSValue throw_bf_exception(JSContext *ctx, int status)\n{\n    const char *str;\n    if (status & BF_ST_MEM_ERROR)\n        return JS_ThrowOutOfMemory(ctx);\n    if (status & BF_ST_DIVIDE_ZERO) {\n        str = \"division by zero\";\n    } else if (status & BF_ST_INVALID_OP) {\n        str = \"invalid operation\";\n    } else {\n        str = \"integer overflow\";\n    }\n    return JS_ThrowRangeError(ctx, \"%s\", str);\n}\n\nstatic int js_unary_arith_bigint(JSContext *ctx,\n                                 JSValue *pres, OPCodeEnum op, JSValue op1)\n{\n    bf_t a_s, *r, *a;\n    int ret, v;\n    JSValue res;\n    \n    if (op == OP_plus && !is_math_mode(ctx)) {\n        JS_ThrowTypeError(ctx, \"bigint argument with unary +\");\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    res = JS_NewBigInt(ctx);\n    if (JS_IsException(res)) {\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    r = JS_GetBigInt(res);\n    a = JS_ToBigInt(ctx, &a_s, op1);\n    ret = 0;\n    switch(op) {\n    case OP_inc:\n    case OP_dec:\n        v = 2 * (op - OP_dec) - 1;\n        ret = bf_add_si(r, a, v, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_plus:\n        ret = bf_set(r, a);\n        break;\n    case OP_neg:\n        ret = bf_set(r, a);\n        bf_neg(r);\n        break;\n    case OP_not:\n        ret = bf_add_si(r, a, 1, BF_PREC_INF, BF_RNDZ);\n        bf_neg(r);\n        break;\n    default:\n        abort();\n    }\n    JS_FreeBigInt(ctx, a, &a_s);\n    JS_FreeValue(ctx, op1);\n    if (unlikely(ret)) {\n        JS_FreeValue(ctx, res);\n        throw_bf_exception(ctx, ret);\n        return -1;\n    }\n    res = JS_CompactBigInt(ctx, res);\n    *pres = res;\n    return 0;\n}\n\nstatic int js_unary_arith_bigfloat(JSContext *ctx,\n                                   JSValue *pres, OPCodeEnum op, JSValue op1)\n{\n    bf_t a_s, *r, *a;\n    int ret, v;\n    JSValue res;\n    \n    if (op == OP_plus && !is_math_mode(ctx)) {\n        JS_ThrowTypeError(ctx, \"bigfloat argument with unary +\");\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n\n    res = JS_NewBigFloat(ctx);\n    if (JS_IsException(res)) {\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    r = JS_GetBigFloat(res);\n    a = JS_ToBigFloat(ctx, &a_s, op1);\n    ret = 0;\n    switch(op) {\n    case OP_inc:\n    case OP_dec:\n        v = 2 * (op - OP_dec) - 1;\n        ret = bf_add_si(r, a, v, ctx->fp_env.prec, ctx->fp_env.flags);\n        break;\n    case OP_plus:\n        ret = bf_set(r, a);\n        break;\n    case OP_neg:\n        ret = bf_set(r, a);\n        bf_neg(r);\n        break;\n    default:\n        abort();\n    }\n    if (a == &a_s)\n        bf_delete(a);\n    JS_FreeValue(ctx, op1);\n    if (unlikely(ret & BF_ST_MEM_ERROR)) {\n        JS_FreeValue(ctx, res);\n        throw_bf_exception(ctx, ret);\n        return -1;\n    }\n    *pres = res;\n    return 0;\n}\n\nstatic int js_unary_arith_bigdecimal(JSContext *ctx,\n                                     JSValue *pres, OPCodeEnum op, JSValue op1)\n{\n    bfdec_t *r, *a;\n    int ret, v;\n    JSValue res;\n    \n    if (op == OP_plus && !is_math_mode(ctx)) {\n        JS_ThrowTypeError(ctx, \"bigdecimal argument with unary +\");\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n\n    res = JS_NewBigDecimal(ctx);\n    if (JS_IsException(res)) {\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    r = JS_GetBigDecimal(res);\n    a = JS_ToBigDecimal(ctx, op1);\n    ret = 0;\n    switch(op) {\n    case OP_inc:\n    case OP_dec:\n        v = 2 * (op - OP_dec) - 1;\n        ret = bfdec_add_si(r, a, v, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_plus:\n        ret = bfdec_set(r, a);\n        break;\n    case OP_neg:\n        ret = bfdec_set(r, a);\n        bfdec_neg(r);\n        break;\n    default:\n        abort();\n    }\n    JS_FreeValue(ctx, op1);\n    if (unlikely(ret)) {\n        JS_FreeValue(ctx, res);\n        throw_bf_exception(ctx, ret);\n        return -1;\n    }\n    *pres = res;\n    return 0;\n}\n\nstatic no_inline __exception int js_unary_arith_slow(JSContext *ctx,\n                                                     JSValue *sp,\n                                                     OPCodeEnum op)\n{\n    JSValue op1, val;\n    int v, ret;\n    uint32_t tag;\n\n    op1 = sp[-1];\n    /* fast path for float64 */\n    if (JS_TAG_IS_FLOAT64(JS_VALUE_GET_TAG(op1)))\n        goto handle_float64;\n    if (JS_IsObject(op1)) {\n        ret = js_call_unary_op_fallback(ctx, &val, op1, op);\n        if (ret < 0)\n            return -1;\n        if (ret) {\n            JS_FreeValue(ctx, op1);\n            sp[-1] = val;\n            return 0;\n        }\n    }\n\n    op1 = JS_ToNumericFree(ctx, op1);\n    if (JS_IsException(op1))\n        goto exception;\n    tag = JS_VALUE_GET_TAG(op1);\n    switch(tag) {\n    case JS_TAG_INT:\n        {\n            int64_t v64;\n            v64 = JS_VALUE_GET_INT(op1);\n            switch(op) {\n            case OP_inc:\n            case OP_dec:\n                v = 2 * (op - OP_dec) - 1;\n                v64 += v;\n                break;\n            case OP_plus:\n                break;\n            case OP_neg:\n                if (v64 == 0) {\n                    sp[-1] = __JS_NewFloat64(ctx, -0.0);\n                    return 0;\n                } else {\n                    v64 = -v64;\n                }\n                break;\n            default:\n                abort();\n            }\n            sp[-1] = JS_NewInt64(ctx, v64);\n        }\n        break;\n    case JS_TAG_BIG_INT:\n    handle_bigint:\n        if (ctx->rt->bigint_ops.unary_arith(ctx, sp - 1, op, op1))\n            goto exception;\n        break;\n    case JS_TAG_BIG_FLOAT:\n        if (ctx->rt->bigfloat_ops.unary_arith(ctx, sp - 1, op, op1))\n            goto exception;\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        if (ctx->rt->bigdecimal_ops.unary_arith(ctx, sp - 1, op, op1))\n            goto exception;\n        break;\n    default:\n    handle_float64:\n        {\n            double d;\n            if (is_math_mode(ctx))\n                goto handle_bigint;\n            d = JS_VALUE_GET_FLOAT64(op1);\n            switch(op) {\n            case OP_inc:\n            case OP_dec:\n                v = 2 * (op - OP_dec) - 1;\n                d += v;\n                break;\n            case OP_plus:\n                break;\n            case OP_neg:\n                d = -d;\n                break;\n            default:\n                abort();\n            }\n            sp[-1] = __JS_NewFloat64(ctx, d);\n        }\n        break;\n    }\n    return 0;\n exception:\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic __exception int js_post_inc_slow(JSContext *ctx,\n                                        JSValue *sp, OPCodeEnum op)\n{\n    JSValue op1;\n\n    /* XXX: allow custom operators */\n    op1 = sp[-1];\n    op1 = JS_ToNumericFree(ctx, op1);\n    if (JS_IsException(op1)) {\n        sp[-1] = JS_UNDEFINED;\n        return -1;\n    }\n    sp[-1] = op1;\n    sp[0] = JS_DupValue(ctx, op1);\n    return js_unary_arith_slow(ctx, sp + 1, op - OP_post_dec + OP_dec);\n}\n\nstatic no_inline int js_not_slow(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1, val;\n    int ret;\n    \n    op1 = sp[-1];\n    if (JS_IsObject(op1)) {\n        ret = js_call_unary_op_fallback(ctx, &val, op1, OP_not);\n        if (ret < 0)\n            return -1;\n        if (ret) {\n            JS_FreeValue(ctx, op1);\n            sp[-1] = val;\n            return 0;\n        }\n    }\n\n    op1 = JS_ToNumericFree(ctx, op1);\n    if (JS_IsException(op1))\n        goto exception;\n    if (is_math_mode(ctx) || JS_VALUE_GET_TAG(op1) == JS_TAG_BIG_INT) {\n        if (ctx->rt->bigint_ops.unary_arith(ctx, sp - 1, OP_not, op1))\n            goto exception;\n    } else {\n        int32_t v1;\n        if (unlikely(JS_ToInt32Free(ctx, &v1, op1)))\n            goto exception;\n        sp[-1] = JS_NewInt32(ctx, ~v1);\n    }\n    return 0;\n exception:\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic int js_binary_arith_bigfloat(JSContext *ctx, OPCodeEnum op,\n                                    JSValue *pres, JSValue op1, JSValue op2)\n{\n    bf_t a_s, b_s, *r, *a, *b;\n    int ret;\n    JSValue res;\n    \n    res = JS_NewBigFloat(ctx);\n    if (JS_IsException(res)) {\n        JS_FreeValue(ctx, op1);\n        JS_FreeValue(ctx, op2);\n        return -1;\n    }\n    r = JS_GetBigFloat(res);\n    a = JS_ToBigFloat(ctx, &a_s, op1);\n    b = JS_ToBigFloat(ctx, &b_s, op2);\n    bf_init(ctx->bf_ctx, r);\n    switch(op) {\n    case OP_add:\n        ret = bf_add(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);\n        break;\n    case OP_sub:\n        ret = bf_sub(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);\n        break;\n    case OP_mul:\n        ret = bf_mul(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);\n        break;\n    case OP_div:\n        ret = bf_div(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);\n        break;\n    case OP_math_mod:\n        /* Euclidian remainder */\n        ret = bf_rem(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags,\n                     BF_DIVREM_EUCLIDIAN);\n        break;\n    case OP_mod:\n        ret = bf_rem(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags,\n                     BF_RNDZ);\n        break;\n    case OP_pow:\n        ret = bf_pow(r, a, b, ctx->fp_env.prec,\n                     ctx->fp_env.flags | BF_POW_JS_QUIRKS);\n        break;\n    default:\n        abort();\n    }\n    if (a == &a_s)\n        bf_delete(a);\n    if (b == &b_s)\n        bf_delete(b);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    if (unlikely(ret & BF_ST_MEM_ERROR)) {\n        JS_FreeValue(ctx, res);\n        throw_bf_exception(ctx, ret);\n        return -1;\n    }\n    *pres = res;\n    return 0;\n}\n\nstatic int js_binary_arith_bigint(JSContext *ctx, OPCodeEnum op,\n                                  JSValue *pres, JSValue op1, JSValue op2)\n{\n    bf_t a_s, b_s, *r, *a, *b;\n    int ret;\n    JSValue res;\n    \n    res = JS_NewBigInt(ctx);\n    if (JS_IsException(res))\n        goto fail;\n    a = JS_ToBigInt(ctx, &a_s, op1);\n    if (!a)\n        goto fail;\n    b = JS_ToBigInt(ctx, &b_s, op2);\n    if (!b) {\n        JS_FreeBigInt(ctx, a, &a_s);\n        goto fail;\n    }\n    r = JS_GetBigInt(res);\n    ret = 0;\n    switch(op) {\n    case OP_add:\n        ret = bf_add(r, a, b, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_sub:\n        ret = bf_sub(r, a, b, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_mul:\n        ret = bf_mul(r, a, b, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_div:\n        if (!is_math_mode(ctx)) {\n            bf_t rem_s, *rem = &rem_s;\n            bf_init(ctx->bf_ctx, rem);\n            ret = bf_divrem(r, rem, a, b, BF_PREC_INF, BF_RNDZ,\n                            BF_RNDZ);\n            bf_delete(rem);\n        } else {\n            goto math_mode_div_pow;\n        }\n        break;\n    case OP_math_mod:\n        /* Euclidian remainder */\n        ret = bf_rem(r, a, b, BF_PREC_INF, BF_RNDZ,\n                     BF_DIVREM_EUCLIDIAN) & BF_ST_INVALID_OP;\n        break;\n    case OP_mod:\n        ret = bf_rem(r, a, b, BF_PREC_INF, BF_RNDZ,\n                     BF_RNDZ) & BF_ST_INVALID_OP;\n        break;\n    case OP_pow:\n        if (b->sign) {\n            if (!is_math_mode(ctx)) {\n                ret = BF_ST_INVALID_OP;\n            } else {\n            math_mode_div_pow:\n                JS_FreeValue(ctx, res);\n                ret = js_call_binary_op_simple(ctx, &res, ctx->class_proto[JS_CLASS_BIG_INT], op1, op2, op);\n                if (ret != 0) {\n                    JS_FreeBigInt(ctx, a, &a_s);\n                    JS_FreeBigInt(ctx, b, &b_s);\n                    JS_FreeValue(ctx, op1);\n                    JS_FreeValue(ctx, op2);\n                    if (ret < 0) {\n                        return -1;\n                    } else {\n                        *pres = res;\n                        return 0;\n                    }\n                }\n                /* if no BigInt power operator defined, return a\n                   bigfloat */\n                res = JS_NewBigFloat(ctx);\n                if (JS_IsException(res)) {\n                    JS_FreeBigInt(ctx, a, &a_s);\n                    JS_FreeBigInt(ctx, b, &b_s);\n                    goto fail;\n                }\n                r = JS_GetBigFloat(res);\n                if (op == OP_div) {\n                    ret = bf_div(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags) & BF_ST_MEM_ERROR;\n                } else {\n                    ret = bf_pow(r, a, b, ctx->fp_env.prec,\n                                 ctx->fp_env.flags | BF_POW_JS_QUIRKS) & BF_ST_MEM_ERROR;\n                }\n                JS_FreeBigInt(ctx, a, &a_s);\n                JS_FreeBigInt(ctx, b, &b_s);\n                JS_FreeValue(ctx, op1);\n                JS_FreeValue(ctx, op2);\n                if (unlikely(ret)) {\n                    JS_FreeValue(ctx, res);\n                    throw_bf_exception(ctx, ret);\n                    return -1;\n                }\n                *pres = res;\n                return 0;\n            }\n        } else {\n            ret = bf_pow(r, a, b, BF_PREC_INF, BF_RNDZ | BF_POW_JS_QUIRKS);\n        }\n        break;\n\n        /* logical operations */\n    case OP_shl:\n    case OP_sar:\n        {\n            slimb_t v2;\n#if LIMB_BITS == 32\n            bf_get_int32(&v2, b, 0);\n            if (v2 == INT32_MIN)\n                v2 = INT32_MIN + 1;\n#else\n            bf_get_int64(&v2, b, 0);\n            if (v2 == INT64_MIN)\n                v2 = INT64_MIN + 1;\n#endif\n            if (op == OP_sar)\n                v2 = -v2;\n            ret = bf_set(r, a);\n            ret |= bf_mul_2exp(r, v2, BF_PREC_INF, BF_RNDZ);\n            if (v2 < 0) {\n                ret |= bf_rint(r, BF_RNDD) & (BF_ST_OVERFLOW | BF_ST_MEM_ERROR);\n            }\n        }\n        break;\n    case OP_and:\n        ret = bf_logic_and(r, a, b);\n        break;\n    case OP_or:\n        ret = bf_logic_or(r, a, b);\n        break;\n    case OP_xor:\n        ret = bf_logic_xor(r, a, b);\n        break;\n    default:\n        abort();\n    }\n    JS_FreeBigInt(ctx, a, &a_s);\n    JS_FreeBigInt(ctx, b, &b_s);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    if (unlikely(ret)) {\n        JS_FreeValue(ctx, res);\n        throw_bf_exception(ctx, ret);\n        return -1;\n    }\n    *pres = JS_CompactBigInt(ctx, res);\n    return 0;\n fail:\n    JS_FreeValue(ctx, res);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    return -1;\n}\n\n/* b must be a positive integer */\nstatic int js_bfdec_pow(bfdec_t *r, const bfdec_t *a, const bfdec_t *b)\n{\n    bfdec_t b1;\n    int32_t b2;\n    int ret;\n\n    bfdec_init(b->ctx, &b1);\n    ret = bfdec_set(&b1, b);\n    if (ret) {\n        bfdec_delete(&b1);\n        return ret;\n    }\n    ret = bfdec_rint(&b1, BF_RNDZ);\n    if (ret) {\n        bfdec_delete(&b1);\n        return BF_ST_INVALID_OP; /* must be an integer */\n    }\n    ret = bfdec_get_int32(&b2, &b1);\n    bfdec_delete(&b1);\n    if (ret)\n        return ret; /* overflow */\n    if (b2 < 0)\n        return BF_ST_INVALID_OP; /* must be positive */\n    return bfdec_pow_ui(r, a, b2);\n}\n\nstatic int js_binary_arith_bigdecimal(JSContext *ctx, OPCodeEnum op,\n                                      JSValue *pres, JSValue op1, JSValue op2)\n{\n    bfdec_t *r, *a, *b;\n    int ret;\n    JSValue res;\n\n    res = JS_NewBigDecimal(ctx);\n    if (JS_IsException(res))\n        goto fail;\n    r = JS_GetBigDecimal(res);\n    \n    a = JS_ToBigDecimal(ctx, op1);\n    if (!a)\n        goto fail;\n    b = JS_ToBigDecimal(ctx, op2);\n    if (!b)\n        goto fail;\n    switch(op) {\n    case OP_add:\n        ret = bfdec_add(r, a, b, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_sub:\n        ret = bfdec_sub(r, a, b, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_mul:\n        ret = bfdec_mul(r, a, b, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_div:\n        ret = bfdec_div(r, a, b, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_math_mod:\n        /* Euclidian remainder */\n        ret = bfdec_rem(r, a, b, BF_PREC_INF, BF_RNDZ, BF_DIVREM_EUCLIDIAN);\n        break;\n    case OP_mod:\n        ret = bfdec_rem(r, a, b, BF_PREC_INF, BF_RNDZ, BF_RNDZ);\n        break;\n    case OP_pow:\n        ret = js_bfdec_pow(r, a, b);\n        break;\n    default:\n        abort();\n    }\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    if (unlikely(ret)) {\n        JS_FreeValue(ctx, res);\n        throw_bf_exception(ctx, ret);\n        return -1;\n    }\n    *pres = res;\n    return 0;\n fail:\n    JS_FreeValue(ctx, res);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    return -1;\n}\n\nstatic no_inline __exception int js_binary_arith_slow(JSContext *ctx, JSValue *sp,\n                                                      OPCodeEnum op)\n{\n    JSValue op1, op2, res;\n    uint32_t tag1, tag2;\n    int ret;\n    double d1, d2;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n    /* fast path for float operations */\n    if (tag1 == JS_TAG_FLOAT64 && tag2 == JS_TAG_FLOAT64) {\n        d1 = JS_VALUE_GET_FLOAT64(op1);\n        d2 = JS_VALUE_GET_FLOAT64(op2);\n        goto handle_float64;\n    }\n\n    /* try to call an overloaded operator */\n    if ((tag1 == JS_TAG_OBJECT &&\n         (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED)) ||\n        (tag2 == JS_TAG_OBJECT &&\n         (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED))) {\n        ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op, TRUE, 0);\n        if (ret != 0) {\n            JS_FreeValue(ctx, op1);\n            JS_FreeValue(ctx, op2);\n            if (ret < 0) {\n                goto exception;\n            } else {\n                sp[-2] = res;\n                return 0;\n            }\n        }\n    }\n\n    op1 = JS_ToNumericFree(ctx, op1);\n    if (JS_IsException(op1)) {\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    op2 = JS_ToNumericFree(ctx, op2);\n    if (JS_IsException(op2)) {\n        JS_FreeValue(ctx, op1);\n        goto exception;\n    }\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n\n    if (tag1 == JS_TAG_INT && tag2 == JS_TAG_INT) {\n        int32_t v1, v2;\n        int64_t v;\n        v1 = JS_VALUE_GET_INT(op1);\n        v2 = JS_VALUE_GET_INT(op2);\n        switch(op) {\n        case OP_sub:\n            v = (int64_t)v1 - (int64_t)v2;\n            break;\n        case OP_mul:\n            v = (int64_t)v1 * (int64_t)v2;\n            if (is_math_mode(ctx) &&\n                (v < -MAX_SAFE_INTEGER || v > MAX_SAFE_INTEGER))\n                goto handle_bigint;\n            if (v == 0 && (v1 | v2) < 0) {\n                sp[-2] = __JS_NewFloat64(ctx, -0.0);\n                return 0;\n            }\n            break;\n        case OP_div:\n            if (is_math_mode(ctx))\n                goto handle_bigint;\n            sp[-2] = __JS_NewFloat64(ctx, (double)v1 / (double)v2);\n            return 0;\n        case OP_math_mod:\n            if (unlikely(v2 == 0)) {\n                throw_bf_exception(ctx, BF_ST_DIVIDE_ZERO);\n                goto exception;\n            }\n            v = (int64_t)v1 % (int64_t)v2;\n            if (v < 0) {\n                if (v2 < 0)\n                    v -= v2;\n                else\n                    v += v2;\n            }\n            break;\n        case OP_mod:\n            if (v1 < 0 || v2 <= 0) {\n                sp[-2] = JS_NewFloat64(ctx, fmod(v1, v2));\n                return 0;\n            } else {\n                v = (int64_t)v1 % (int64_t)v2;\n            }\n            break;\n        case OP_pow:\n            if (!is_math_mode(ctx)) {\n                sp[-2] = JS_NewFloat64(ctx, js_pow(v1, v2));\n                return 0;\n            } else {\n                goto handle_bigint;\n            }\n            break;\n        default:\n            abort();\n        }\n        sp[-2] = JS_NewInt64(ctx, v);\n    } else if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {\n        if (ctx->rt->bigdecimal_ops.binary_arith(ctx, op, sp - 2, op1, op2))\n            goto exception;\n    } else if (tag1 == JS_TAG_BIG_FLOAT || tag2 == JS_TAG_BIG_FLOAT) {\n        if (ctx->rt->bigfloat_ops.binary_arith(ctx, op, sp - 2, op1, op2))\n            goto exception;\n    } else if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {\n    handle_bigint:\n        if (ctx->rt->bigint_ops.binary_arith(ctx, op, sp - 2, op1, op2))\n            goto exception;\n    } else {\n        double dr;\n        /* float64 result */\n        if (JS_ToFloat64Free(ctx, &d1, op1)) {\n            JS_FreeValue(ctx, op2);\n            goto exception;\n        }\n        if (JS_ToFloat64Free(ctx, &d2, op2))\n            goto exception;\n    handle_float64:\n        if (is_math_mode(ctx) && is_safe_integer(d1) && is_safe_integer(d2))\n            goto handle_bigint;\n        switch(op) {\n        case OP_sub:\n            dr = d1 - d2;\n            break;\n        case OP_mul:\n            dr = d1 * d2;\n            break;\n        case OP_div:\n            dr = d1 / d2;\n            break;\n        case OP_mod:\n            dr = fmod(d1, d2);\n            break;\n        case OP_math_mod:\n            d2 = fabs(d2);\n            dr = fmod(d1, d2);\n            /* XXX: loss of accuracy if dr < 0 */\n            if (dr < 0)\n                dr += d2;\n            break;\n        case OP_pow:\n            dr = js_pow(d1, d2);\n            break;\n        default:\n            abort();\n        }\n        sp[-2] = __JS_NewFloat64(ctx, dr);\n    }\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic no_inline __exception int js_add_slow(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1, op2, res;\n    uint32_t tag1, tag2;\n    int ret;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n    /* fast path for float64 */\n    if (tag1 == JS_TAG_FLOAT64 && tag2 == JS_TAG_FLOAT64) {\n        double d1, d2;\n        d1 = JS_VALUE_GET_FLOAT64(op1);\n        d2 = JS_VALUE_GET_FLOAT64(op2);\n        sp[-2] = __JS_NewFloat64(ctx, d1 + d2);\n        return 0;\n    }\n\n    if (tag1 == JS_TAG_OBJECT || tag2 == JS_TAG_OBJECT) {\n        /* try to call an overloaded operator */\n        if ((tag1 == JS_TAG_OBJECT &&\n             (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED &&\n              tag2 != JS_TAG_STRING)) ||\n            (tag2 == JS_TAG_OBJECT &&\n             (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED &&\n              tag1 != JS_TAG_STRING))) {\n            ret = js_call_binary_op_fallback(ctx, &res, op1, op2, OP_add,\n                                             FALSE, HINT_NONE);\n            if (ret != 0) {\n                JS_FreeValue(ctx, op1);\n                JS_FreeValue(ctx, op2);\n                if (ret < 0) {\n                    goto exception;\n                } else {\n                    sp[-2] = res;\n                    return 0;\n                }\n            }\n        }\n\n        op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);\n        if (JS_IsException(op1)) {\n            JS_FreeValue(ctx, op2);\n            goto exception;\n        }\n\n        op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NONE);\n        if (JS_IsException(op2)) {\n            JS_FreeValue(ctx, op1);\n            goto exception;\n        }\n        tag1 = JS_VALUE_GET_NORM_TAG(op1);\n        tag2 = JS_VALUE_GET_NORM_TAG(op2);\n    }\n\n    if (tag1 == JS_TAG_STRING || tag2 == JS_TAG_STRING) {\n        sp[-2] = JS_ConcatString(ctx, op1, op2);\n        if (JS_IsException(sp[-2]))\n            goto exception;\n        return 0;\n    }\n\n    op1 = JS_ToNumericFree(ctx, op1);\n    if (JS_IsException(op1)) {\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    op2 = JS_ToNumericFree(ctx, op2);\n    if (JS_IsException(op2)) {\n        JS_FreeValue(ctx, op1);\n        goto exception;\n    }\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n\n    if (tag1 == JS_TAG_INT && tag2 == JS_TAG_INT) {\n        int32_t v1, v2;\n        int64_t v;\n        v1 = JS_VALUE_GET_INT(op1);\n        v2 = JS_VALUE_GET_INT(op2);\n        v = (int64_t)v1 + (int64_t)v2;\n        sp[-2] = JS_NewInt64(ctx, v);\n    } else if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {\n        if (ctx->rt->bigdecimal_ops.binary_arith(ctx, OP_add, sp - 2, op1, op2))\n            goto exception;\n    } else if (tag1 == JS_TAG_BIG_FLOAT || tag2 == JS_TAG_BIG_FLOAT) {\n        if (ctx->rt->bigfloat_ops.binary_arith(ctx, OP_add, sp - 2, op1, op2))\n            goto exception;\n    } else if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {\n    handle_bigint:\n        if (ctx->rt->bigint_ops.binary_arith(ctx, OP_add, sp - 2, op1, op2))\n            goto exception;\n    } else {\n        double d1, d2;\n        /* float64 result */\n        if (JS_ToFloat64Free(ctx, &d1, op1)) {\n            JS_FreeValue(ctx, op2);\n            goto exception;\n        }\n        if (JS_ToFloat64Free(ctx, &d2, op2))\n            goto exception;\n        if (is_math_mode(ctx) && is_safe_integer(d1) && is_safe_integer(d2))\n            goto handle_bigint;\n        sp[-2] = __JS_NewFloat64(ctx, d1 + d2);\n    }\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic no_inline __exception int js_binary_logic_slow(JSContext *ctx,\n                                                      JSValue *sp,\n                                                      OPCodeEnum op)\n{\n    JSValue op1, op2, res;\n    int ret;\n    uint32_t tag1, tag2;\n    uint32_t v1, v2, r;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n\n    /* try to call an overloaded operator */\n    if ((tag1 == JS_TAG_OBJECT &&\n         (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED)) ||\n        (tag2 == JS_TAG_OBJECT &&\n         (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED))) {\n        ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op, TRUE, 0);\n        if (ret != 0) {\n            JS_FreeValue(ctx, op1);\n            JS_FreeValue(ctx, op2);\n            if (ret < 0) {\n                goto exception;\n            } else {\n                sp[-2] = res;\n                return 0;\n            }\n        }\n    }\n\n    op1 = JS_ToNumericFree(ctx, op1);\n    if (JS_IsException(op1)) {\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    op2 = JS_ToNumericFree(ctx, op2);\n    if (JS_IsException(op2)) {\n        JS_FreeValue(ctx, op1);\n        goto exception;\n    }\n\n    if (is_math_mode(ctx))\n        goto bigint_op;\n\n    tag1 = JS_VALUE_GET_TAG(op1);\n    tag2 = JS_VALUE_GET_TAG(op2);\n    if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {\n        if (tag1 != tag2) {\n            JS_FreeValue(ctx, op1);\n            JS_FreeValue(ctx, op2);\n            JS_ThrowTypeError(ctx, \"both operands must be bigint\");\n            goto exception;\n        } else {\n        bigint_op:\n            if (ctx->rt->bigint_ops.binary_arith(ctx, op, sp - 2, op1, op2))\n                goto exception;\n        }\n    } else {\n        if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v1, op1))) {\n            JS_FreeValue(ctx, op2);\n            goto exception;\n        }\n        if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v2, op2)))\n            goto exception;\n        switch(op) {\n        case OP_shl:\n            r = v1 << (v2 & 0x1f);\n            break;\n        case OP_sar:\n            r = (int)v1 >> (v2 & 0x1f);\n            break;\n        case OP_and:\n            r = v1 & v2;\n            break;\n        case OP_or:\n            r = v1 | v2;\n            break;\n        case OP_xor:\n            r = v1 ^ v2;\n            break;\n        default:\n            abort();\n        }\n        sp[-2] = JS_NewInt32(ctx, r);\n    }\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\n/* Note: also used for bigint */\nstatic int js_compare_bigfloat(JSContext *ctx, OPCodeEnum op,\n                               JSValue op1, JSValue op2)\n{\n    bf_t a_s, b_s, *a, *b;\n    int res;\n    \n    a = JS_ToBigFloat(ctx, &a_s, op1);\n    if (!a) {\n        JS_FreeValue(ctx, op2);\n        return -1;\n    }\n    b = JS_ToBigFloat(ctx, &b_s, op2);\n    if (!b) {\n        if (a == &a_s)\n            bf_delete(a);\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    switch(op) {\n    case OP_lt:\n        res = bf_cmp_lt(a, b); /* if NaN return false */\n        break;\n    case OP_lte:\n        res = bf_cmp_le(a, b); /* if NaN return false */\n        break;\n    case OP_gt:\n        res = bf_cmp_lt(b, a); /* if NaN return false */\n        break;\n    case OP_gte:\n        res = bf_cmp_le(b, a); /* if NaN return false */\n        break;\n    case OP_eq:\n        res = bf_cmp_eq(a, b); /* if NaN return false */\n        break;\n    default:\n        abort();\n    }\n    if (a == &a_s)\n        bf_delete(a);\n    if (b == &b_s)\n        bf_delete(b);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    return res;\n}\n\nstatic int js_compare_bigdecimal(JSContext *ctx, OPCodeEnum op,\n                                 JSValue op1, JSValue op2)\n{\n    bfdec_t *a, *b;\n    int res;\n\n    /* Note: binary floats are converted to bigdecimal with\n       toString(). It is not mathematically correct but is consistent\n       with the BigDecimal() constructor behavior */\n    op1 = JS_ToBigDecimalFree(ctx, op1, TRUE);\n    if (JS_IsException(op1)) {\n        JS_FreeValue(ctx, op2);\n        return -1;\n    }\n    op2 = JS_ToBigDecimalFree(ctx, op2, TRUE);\n    if (JS_IsException(op2)) {\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    a = JS_ToBigDecimal(ctx, op1);\n    b = JS_ToBigDecimal(ctx, op2);\n    \n    switch(op) {\n    case OP_lt:\n        res = bfdec_cmp_lt(a, b); /* if NaN return false */\n        break;\n    case OP_lte:\n        res = bfdec_cmp_le(a, b); /* if NaN return false */\n        break;\n    case OP_gt:\n        res = bfdec_cmp_lt(b, a); /* if NaN return false */\n        break;\n    case OP_gte:\n        res = bfdec_cmp_le(b, a); /* if NaN return false */\n        break;\n    case OP_eq:\n        res = bfdec_cmp_eq(a, b); /* if NaN return false */\n        break;\n    default:\n        abort();\n    }\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    return res;\n}\n\nstatic no_inline int js_relational_slow(JSContext *ctx, JSValue *sp,\n                                        OPCodeEnum op)\n{\n    JSValue op1, op2, ret;\n    int res;\n    uint32_t tag1, tag2;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n    /* try to call an overloaded operator */\n    if ((tag1 == JS_TAG_OBJECT &&\n         (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED)) ||\n        (tag2 == JS_TAG_OBJECT &&\n         (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED))) {\n        res = js_call_binary_op_fallback(ctx, &ret, op1, op2, op,\n                                         FALSE, HINT_NUMBER);\n        if (res != 0) {\n            JS_FreeValue(ctx, op1);\n            JS_FreeValue(ctx, op2);\n            if (res < 0) {\n                goto exception;\n            } else {\n                sp[-2] = ret;\n                return 0;\n            }\n        }\n    }\n    op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NUMBER);\n    if (JS_IsException(op1)) {\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NUMBER);\n    if (JS_IsException(op2)) {\n        JS_FreeValue(ctx, op1);\n        goto exception;\n    }\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n\n    if (tag1 == JS_TAG_STRING && tag2 == JS_TAG_STRING) {\n        JSString *p1, *p2;\n        p1 = JS_VALUE_GET_STRING(op1);\n        p2 = JS_VALUE_GET_STRING(op2);\n        res = js_string_compare(ctx, p1, p2);\n        switch(op) {\n        case OP_lt:\n            res = (res < 0);\n            break;\n        case OP_lte:\n            res = (res <= 0);\n            break;\n        case OP_gt:\n            res = (res > 0);\n            break;\n        default:\n        case OP_gte:\n            res = (res >= 0);\n            break;\n        }\n        JS_FreeValue(ctx, op1);\n        JS_FreeValue(ctx, op2);\n    } else if ((tag1 <= JS_TAG_NULL || tag1 == JS_TAG_FLOAT64) &&\n               (tag2 <= JS_TAG_NULL || tag2 == JS_TAG_FLOAT64)) {\n        /* fast path for float64/int */\n        goto float64_compare;\n    } else {\n        if (((tag1 == JS_TAG_BIG_INT && tag2 == JS_TAG_STRING) ||\n             (tag2 == JS_TAG_BIG_INT && tag1 == JS_TAG_STRING)) &&\n            !is_math_mode(ctx)) {\n            if (tag1 == JS_TAG_STRING) {\n                op1 = JS_StringToBigInt(ctx, op1);\n                if (JS_VALUE_GET_TAG(op1) != JS_TAG_BIG_INT)\n                    goto invalid_bigint_string;\n            }\n            if (tag2 == JS_TAG_STRING) {\n                op2 = JS_StringToBigInt(ctx, op2);\n                if (JS_VALUE_GET_TAG(op2) != JS_TAG_BIG_INT) {\n                invalid_bigint_string:\n                    JS_FreeValue(ctx, op1);\n                    JS_FreeValue(ctx, op2);\n                    res = FALSE;\n                    goto done;\n                }\n            }\n        } else {\n            op1 = JS_ToNumericFree(ctx, op1);\n            if (JS_IsException(op1)) {\n                JS_FreeValue(ctx, op2);\n                goto exception;\n            }\n            op2 = JS_ToNumericFree(ctx, op2);\n            if (JS_IsException(op2)) {\n                JS_FreeValue(ctx, op1);\n                goto exception;\n            }\n        }\n\n        tag1 = JS_VALUE_GET_NORM_TAG(op1);\n        tag2 = JS_VALUE_GET_NORM_TAG(op2);\n\n        if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {\n            res = ctx->rt->bigdecimal_ops.compare(ctx, op, op1, op2);\n            if (res < 0)\n                goto exception;\n        } else if (tag1 == JS_TAG_BIG_FLOAT || tag2 == JS_TAG_BIG_FLOAT) {\n            res = ctx->rt->bigfloat_ops.compare(ctx, op, op1, op2);\n            if (res < 0)\n                goto exception;\n        } else if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {\n            res = ctx->rt->bigint_ops.compare(ctx, op, op1, op2);\n            if (res < 0)\n                goto exception;\n        } else {\n            double d1, d2;\n\n        float64_compare:\n            /* can use floating point comparison */\n            if (tag1 == JS_TAG_FLOAT64) {\n                d1 = JS_VALUE_GET_FLOAT64(op1);\n            } else {\n                d1 = JS_VALUE_GET_INT(op1);\n            }\n            if (tag2 == JS_TAG_FLOAT64) {\n                d2 = JS_VALUE_GET_FLOAT64(op2);\n            } else {\n                d2 = JS_VALUE_GET_INT(op2);\n            }\n            switch(op) {\n            case OP_lt:\n                res = (d1 < d2); /* if NaN return false */\n                break;\n            case OP_lte:\n                res = (d1 <= d2); /* if NaN return false */\n                break;\n            case OP_gt:\n                res = (d1 > d2); /* if NaN return false */\n                break;\n            default:\n            case OP_gte:\n                res = (d1 >= d2); /* if NaN return false */\n                break;\n            }\n        }\n    }\n done:\n    sp[-2] = JS_NewBool(ctx, res);\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic BOOL tag_is_number(uint32_t tag)\n{\n    return (tag == JS_TAG_INT || tag == JS_TAG_BIG_INT ||\n            tag == JS_TAG_FLOAT64 || tag == JS_TAG_BIG_FLOAT ||\n            tag == JS_TAG_BIG_DECIMAL);\n}\n\nstatic no_inline __exception int js_eq_slow(JSContext *ctx, JSValue *sp,\n                                            BOOL is_neq)\n{\n    JSValue op1, op2, ret;\n    int res;\n    uint32_t tag1, tag2;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n redo:\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n    if (tag_is_number(tag1) && tag_is_number(tag2)) {\n        if (tag1 == JS_TAG_INT && tag2 == JS_TAG_INT) {\n            res = JS_VALUE_GET_INT(op1) == JS_VALUE_GET_INT(op2);\n        } else if ((tag1 == JS_TAG_FLOAT64 &&\n                    (tag2 == JS_TAG_INT || tag2 == JS_TAG_FLOAT64)) ||\n                   (tag2 == JS_TAG_FLOAT64 &&\n                    (tag1 == JS_TAG_INT || tag1 == JS_TAG_FLOAT64))) {\n            double d1, d2;\n            if (tag1 == JS_TAG_FLOAT64) {\n                d1 = JS_VALUE_GET_FLOAT64(op1);\n            } else {\n                d1 = JS_VALUE_GET_INT(op1);\n            }\n            if (tag2 == JS_TAG_FLOAT64) {\n                d2 = JS_VALUE_GET_FLOAT64(op2);\n            } else {\n                d2 = JS_VALUE_GET_INT(op2);\n            }\n            res = (d1 == d2);\n        } else if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {\n            res = ctx->rt->bigdecimal_ops.compare(ctx, OP_eq, op1, op2);\n            if (res < 0)\n                goto exception;\n        } else if (tag1 == JS_TAG_BIG_FLOAT || tag2 == JS_TAG_BIG_FLOAT) {\n            res = ctx->rt->bigfloat_ops.compare(ctx, OP_eq, op1, op2);\n            if (res < 0)\n                goto exception;\n        } else {\n            res = ctx->rt->bigint_ops.compare(ctx, OP_eq, op1, op2);\n            if (res < 0)\n                goto exception;\n        }\n    } else if (tag1 == tag2) {\n        if (tag1 == JS_TAG_OBJECT) {\n            /* try the fallback operator */\n            res = js_call_binary_op_fallback(ctx, &ret, op1, op2,\n                                             is_neq ? OP_neq : OP_eq,\n                                             FALSE, HINT_NONE);\n            if (res != 0) {\n                JS_FreeValue(ctx, op1);\n                JS_FreeValue(ctx, op2);\n                if (res < 0) {\n                    goto exception;\n                } else {\n                    sp[-2] = ret;\n                    return 0;\n                }\n            }\n        }\n        res = js_strict_eq2(ctx, op1, op2, JS_EQ_STRICT);\n    } else if ((tag1 == JS_TAG_NULL && tag2 == JS_TAG_UNDEFINED) ||\n               (tag2 == JS_TAG_NULL && tag1 == JS_TAG_UNDEFINED)) {\n        res = TRUE;\n    } else if ((tag1 == JS_TAG_STRING && tag_is_number(tag2)) ||\n               (tag2 == JS_TAG_STRING && tag_is_number(tag1))) {\n\n        if ((tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) &&\n            !is_math_mode(ctx)) {\n            if (tag1 == JS_TAG_STRING) {\n                op1 = JS_StringToBigInt(ctx, op1);\n                if (JS_VALUE_GET_TAG(op1) != JS_TAG_BIG_INT)\n                    goto invalid_bigint_string;\n            }\n            if (tag2 == JS_TAG_STRING) {\n                op2 = JS_StringToBigInt(ctx, op2);\n                if (JS_VALUE_GET_TAG(op2) != JS_TAG_BIG_INT) {\n                invalid_bigint_string:\n                    JS_FreeValue(ctx, op1);\n                    JS_FreeValue(ctx, op2);\n                    res = FALSE;\n                    goto done;\n                }\n            }\n        } else {\n            op1 = JS_ToNumericFree(ctx, op1);\n            if (JS_IsException(op1)) {\n                JS_FreeValue(ctx, op2);\n                goto exception;\n            }\n            op2 = JS_ToNumericFree(ctx, op2);\n            if (JS_IsException(op2)) {\n                JS_FreeValue(ctx, op1);\n                goto exception;\n            }\n        }\n        res = js_strict_eq(ctx, op1, op2);\n    } else if (tag1 == JS_TAG_BOOL) {\n        op1 = JS_NewInt32(ctx, JS_VALUE_GET_INT(op1));\n        goto redo;\n    } else if (tag2 == JS_TAG_BOOL) {\n        op2 = JS_NewInt32(ctx, JS_VALUE_GET_INT(op2));\n        goto redo;\n    } else if ((tag1 == JS_TAG_OBJECT &&\n                (tag_is_number(tag2) || tag2 == JS_TAG_STRING || tag2 == JS_TAG_SYMBOL)) ||\n               (tag2 == JS_TAG_OBJECT &&\n                (tag_is_number(tag1) || tag1 == JS_TAG_STRING || tag1 == JS_TAG_SYMBOL))) {\n\n        /* try the fallback operator */\n        res = js_call_binary_op_fallback(ctx, &ret, op1, op2,\n                                         is_neq ? OP_neq : OP_eq,\n                                         FALSE, HINT_NONE);\n        if (res != 0) {\n            JS_FreeValue(ctx, op1);\n            JS_FreeValue(ctx, op2);\n            if (res < 0) {\n                goto exception;\n            } else {\n                sp[-2] = ret;\n                return 0;\n            }\n        }\n\n        op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);\n        if (JS_IsException(op1)) {\n            JS_FreeValue(ctx, op2);\n            goto exception;\n        }\n        op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NONE);\n        if (JS_IsException(op2)) {\n            JS_FreeValue(ctx, op1);\n            goto exception;\n        }\n        goto redo;\n    } else {\n        /* IsHTMLDDA object is equivalent to undefined for '==' and '!=' */\n        if ((JS_IsHTMLDDA(ctx, op1) &&\n             (tag2 == JS_TAG_NULL || tag2 == JS_TAG_UNDEFINED)) ||\n            (JS_IsHTMLDDA(ctx, op2) &&\n             (tag1 == JS_TAG_NULL || tag1 == JS_TAG_UNDEFINED))) {\n            res = TRUE;\n        } else {\n            res = FALSE;\n        }\n        JS_FreeValue(ctx, op1);\n        JS_FreeValue(ctx, op2);\n    }\n done:\n    sp[-2] = JS_NewBool(ctx, res ^ is_neq);\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic no_inline int js_shr_slow(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1, op2;\n    uint32_t v1, v2, r;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    op1 = JS_ToNumericFree(ctx, op1);\n    if (JS_IsException(op1)) {\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    op2 = JS_ToNumericFree(ctx, op2);\n    if (JS_IsException(op2)) {\n        JS_FreeValue(ctx, op1);\n        goto exception;\n    }\n    /* XXX: could forbid >>> in bignum mode */\n    if (!is_math_mode(ctx) &&\n        (JS_VALUE_GET_TAG(op1) == JS_TAG_BIG_INT ||\n         JS_VALUE_GET_TAG(op2) == JS_TAG_BIG_INT)) {\n        JS_ThrowTypeError(ctx, \"bigint operands are forbidden for >>>\");\n        JS_FreeValue(ctx, op1);\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    /* cannot give an exception */\n    JS_ToUint32Free(ctx, &v1, op1);\n    JS_ToUint32Free(ctx, &v2, op2);\n    r = v1 >> (v2 & 0x1f);\n    sp[-2] = JS_NewUint32(ctx, r);\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic JSValue js_mul_pow10_to_float64(JSContext *ctx, const bf_t *a,\n                                       int64_t exponent)\n{\n    bf_t r_s, *r = &r_s;\n    double d;\n    int ret;\n    \n    /* always convert to Float64 */\n    bf_init(ctx->bf_ctx, r);\n    ret = bf_mul_pow_radix(r, a, 10, exponent,\n                           53, bf_set_exp_bits(11) | BF_RNDN |\n                           BF_FLAG_SUBNORMAL);\n    bf_get_float64(r, &d, BF_RNDN);\n    bf_delete(r);\n    if (ret & BF_ST_MEM_ERROR)\n        return JS_ThrowOutOfMemory(ctx);\n    else\n        return __JS_NewFloat64(ctx, d);\n}\n\nstatic no_inline int js_mul_pow10(JSContext *ctx, JSValue *sp)\n{\n    bf_t a_s, *a, *r;\n    JSValue op1, op2, res;\n    int64_t e;\n    int ret;\n\n    res = JS_NewBigFloat(ctx);\n    if (JS_IsException(res))\n        return -1;\n    r = JS_GetBigFloat(res);\n    op1 = sp[-2];\n    op2 = sp[-1];\n    a = JS_ToBigFloat(ctx, &a_s, op1);\n    if (!a)\n        return -1;\n    if (JS_IsBigInt(ctx, op2)) {\n        ret = JS_ToBigInt64(ctx, &e, op2);\n    } else {\n        ret = JS_ToInt64(ctx, &e, op2);\n    }\n    if (ret) {\n        if (a == &a_s)\n            bf_delete(a);\n        JS_FreeValue(ctx, res);\n        return -1;\n    }\n\n    bf_mul_pow_radix(r, a, 10, e, ctx->fp_env.prec, ctx->fp_env.flags);\n    if (a == &a_s)\n        bf_delete(a);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    sp[-2] = res;\n    return 0;\n}\n\n#else /* !CONFIG_BIGNUM */\n\nstatic JSValue JS_ThrowUnsupportedBigint(JSContext *ctx)\n{\n    return JS_ThrowTypeError(ctx, \"bigint is not supported\");\n}\n\nJSValue JS_NewBigInt64(JSContext *ctx, int64_t v)\n{\n    return JS_ThrowUnsupportedBigint(ctx);\n}\n\nJSValue JS_NewBigUint64(JSContext *ctx, uint64_t v)\n{\n    return JS_ThrowUnsupportedBigint(ctx);\n}\n\nint JS_ToBigInt64(JSContext *ctx, int64_t *pres, JSValueConst val)\n{\n    JS_ThrowUnsupportedBigint(ctx);\n    *pres = 0;\n    return -1;\n}\n\nstatic no_inline __exception int js_unary_arith_slow(JSContext *ctx,\n                                                     JSValue *sp,\n                                                     OPCodeEnum op)\n{\n    JSValue op1;\n    double d;\n\n    op1 = sp[-1];\n    if (unlikely(JS_ToFloat64Free(ctx, &d, op1))) {\n        sp[-1] = JS_UNDEFINED;\n        return -1;\n    }\n    switch(op) {\n    case OP_inc:\n        d++;\n        break;\n    case OP_dec:\n        d--;\n        break;\n    case OP_plus:\n        break;\n    case OP_neg:\n        d = -d;\n        break;\n    default:\n        abort();\n    }\n    sp[-1] = JS_NewFloat64(ctx, d);\n    return 0;\n}\n\n/* specific case necessary for correct return value semantics */\nstatic __exception int js_post_inc_slow(JSContext *ctx,\n                                        JSValue *sp, OPCodeEnum op)\n{\n    JSValue op1;\n    double d, r;\n\n    op1 = sp[-1];\n    if (unlikely(JS_ToFloat64Free(ctx, &d, op1))) {\n        sp[-1] = JS_UNDEFINED;\n        return -1;\n    }\n    r = d + 2 * (op - OP_post_dec) - 1;\n    sp[0] = JS_NewFloat64(ctx, r);\n    sp[-1] = JS_NewFloat64(ctx, d);\n    return 0;\n}\n\nstatic no_inline __exception int js_binary_arith_slow(JSContext *ctx, JSValue *sp,\n                                                      OPCodeEnum op)\n{\n    JSValue op1, op2;\n    double d1, d2, r;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    if (unlikely(JS_ToFloat64Free(ctx, &d1, op1))) {\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    if (unlikely(JS_ToFloat64Free(ctx, &d2, op2))) {\n        goto exception;\n    }\n    switch(op) {\n    case OP_sub:\n        r = d1 - d2;\n        break;\n    case OP_mul:\n        r = d1 * d2;\n        break;\n    case OP_div:\n        r = d1 / d2;\n        break;\n    case OP_mod:\n        r = fmod(d1, d2);\n        break;\n    case OP_pow:\n        r = js_pow(d1, d2);\n        break;\n    default:\n        abort();\n    }\n    sp[-2] = JS_NewFloat64(ctx, r);\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic no_inline __exception int js_add_slow(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1, op2;\n    uint32_t tag1, tag2;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    tag1 = JS_VALUE_GET_TAG(op1);\n    tag2 = JS_VALUE_GET_TAG(op2);\n    if ((tag1 == JS_TAG_INT || JS_TAG_IS_FLOAT64(tag1)) &&\n        (tag2 == JS_TAG_INT || JS_TAG_IS_FLOAT64(tag2))) {\n        goto add_numbers;\n    } else {\n        op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);\n        if (JS_IsException(op1)) {\n            JS_FreeValue(ctx, op2);\n            goto exception;\n        }\n        op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NONE);\n        if (JS_IsException(op2)) {\n            JS_FreeValue(ctx, op1);\n            goto exception;\n        }\n        tag1 = JS_VALUE_GET_TAG(op1);\n        tag2 = JS_VALUE_GET_TAG(op2);\n        if (tag1 == JS_TAG_STRING || tag2 == JS_TAG_STRING) {\n            sp[-2] = JS_ConcatString(ctx, op1, op2);\n            if (JS_IsException(sp[-2]))\n                goto exception;\n        } else {\n            double d1, d2;\n        add_numbers:\n            if (JS_ToFloat64Free(ctx, &d1, op1)) {\n                JS_FreeValue(ctx, op2);\n                goto exception;\n            }\n            if (JS_ToFloat64Free(ctx, &d2, op2))\n                goto exception;\n            sp[-2] = JS_NewFloat64(ctx, d1 + d2);\n        }\n    }\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic no_inline __exception int js_binary_logic_slow(JSContext *ctx,\n                                                      JSValue *sp,\n                                                      OPCodeEnum op)\n{\n    JSValue op1, op2;\n    uint32_t v1, v2, r;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v1, op1))) {\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v2, op2)))\n        goto exception;\n    switch(op) {\n    case OP_shl:\n        r = v1 << (v2 & 0x1f);\n        break;\n    case OP_sar:\n        r = (int)v1 >> (v2 & 0x1f);\n        break;\n    case OP_and:\n        r = v1 & v2;\n        break;\n    case OP_or:\n        r = v1 | v2;\n        break;\n    case OP_xor:\n        r = v1 ^ v2;\n        break;\n    default:\n        abort();\n    }\n    sp[-2] = JS_NewInt32(ctx, r);\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic no_inline int js_not_slow(JSContext *ctx, JSValue *sp)\n{\n    int32_t v1;\n\n    if (unlikely(JS_ToInt32Free(ctx, &v1, sp[-1]))) {\n        sp[-1] = JS_UNDEFINED;\n        return -1;\n    }\n    sp[-1] = JS_NewInt32(ctx, ~v1);\n    return 0;\n}\n\nstatic no_inline int js_relational_slow(JSContext *ctx, JSValue *sp,\n                                        OPCodeEnum op)\n{\n    JSValue op1, op2;\n    int res;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NUMBER);\n    if (JS_IsException(op1)) {\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NUMBER);\n    if (JS_IsException(op2)) {\n        JS_FreeValue(ctx, op1);\n        goto exception;\n    }\n    if (JS_VALUE_GET_TAG(op1) == JS_TAG_STRING &&\n        JS_VALUE_GET_TAG(op2) == JS_TAG_STRING) {\n        JSString *p1, *p2;\n        p1 = JS_VALUE_GET_STRING(op1);\n        p2 = JS_VALUE_GET_STRING(op2);\n        res = js_string_compare(ctx, p1, p2);\n        JS_FreeValue(ctx, op1);\n        JS_FreeValue(ctx, op2);\n        switch(op) {\n        case OP_lt:\n            res = (res < 0);\n            break;\n        case OP_lte:\n            res = (res <= 0);\n            break;\n        case OP_gt:\n            res = (res > 0);\n            break;\n        default:\n        case OP_gte:\n            res = (res >= 0);\n            break;\n        }\n    } else {\n        double d1, d2;\n        if (JS_ToFloat64Free(ctx, &d1, op1)) {\n            JS_FreeValue(ctx, op2);\n            goto exception;\n        }\n        if (JS_ToFloat64Free(ctx, &d2, op2))\n            goto exception;\n        switch(op) {\n        case OP_lt:\n            res = (d1 < d2); /* if NaN return false */\n            break;\n        case OP_lte:\n            res = (d1 <= d2); /* if NaN return false */\n            break;\n        case OP_gt:\n            res = (d1 > d2); /* if NaN return false */\n            break;\n        default:\n        case OP_gte:\n            res = (d1 >= d2); /* if NaN return false */\n            break;\n        }\n    }\n    sp[-2] = JS_NewBool(ctx, res);\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic no_inline __exception int js_eq_slow(JSContext *ctx, JSValue *sp,\n                                            BOOL is_neq)\n{\n    JSValue op1, op2;\n    int tag1, tag2;\n    BOOL res;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n redo:\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n    if (tag1 == tag2 ||\n        (tag1 == JS_TAG_INT && tag2 == JS_TAG_FLOAT64) ||\n        (tag2 == JS_TAG_INT && tag1 == JS_TAG_FLOAT64)) {\n        res = js_strict_eq(ctx, op1, op2);\n    } else if ((tag1 == JS_TAG_NULL && tag2 == JS_TAG_UNDEFINED) ||\n               (tag2 == JS_TAG_NULL && tag1 == JS_TAG_UNDEFINED)) {\n        res = TRUE;\n    } else if ((tag1 == JS_TAG_STRING && (tag2 == JS_TAG_INT ||\n                                   tag2 == JS_TAG_FLOAT64)) ||\n        (tag2 == JS_TAG_STRING && (tag1 == JS_TAG_INT ||\n                                   tag1 == JS_TAG_FLOAT64))) {\n        double d1;\n        double d2;\n        if (JS_ToFloat64Free(ctx, &d1, op1)) {\n            JS_FreeValue(ctx, op2);\n            goto exception;\n        }\n        if (JS_ToFloat64Free(ctx, &d2, op2))\n            goto exception;\n        res = (d1 == d2);\n    } else if (tag1 == JS_TAG_BOOL) {\n        op1 = JS_NewInt32(ctx, JS_VALUE_GET_INT(op1));\n        goto redo;\n    } else if (tag2 == JS_TAG_BOOL) {\n        op2 = JS_NewInt32(ctx, JS_VALUE_GET_INT(op2));\n        goto redo;\n    } else if (tag1 == JS_TAG_OBJECT &&\n               (tag2 == JS_TAG_INT || tag2 == JS_TAG_FLOAT64 || tag2 == JS_TAG_STRING || tag2 == JS_TAG_SYMBOL)) {\n        op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);\n        if (JS_IsException(op1)) {\n            JS_FreeValue(ctx, op2);\n            goto exception;\n        }\n        goto redo;\n    } else if (tag2 == JS_TAG_OBJECT &&\n               (tag1 == JS_TAG_INT || tag1 == JS_TAG_FLOAT64 || tag1 == JS_TAG_STRING || tag1 == JS_TAG_SYMBOL)) {\n        op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NONE);\n        if (JS_IsException(op2)) {\n            JS_FreeValue(ctx, op1);\n            goto exception;\n        }\n        goto redo;\n    } else {\n        /* IsHTMLDDA object is equivalent to undefined for '==' and '!=' */\n        if ((JS_IsHTMLDDA(ctx, op1) &&\n             (tag2 == JS_TAG_NULL || tag2 == JS_TAG_UNDEFINED)) ||\n            (JS_IsHTMLDDA(ctx, op2) &&\n             (tag1 == JS_TAG_NULL || tag1 == JS_TAG_UNDEFINED))) {\n            res = TRUE;\n        } else {\n            res = FALSE;\n        }\n        JS_FreeValue(ctx, op1);\n        JS_FreeValue(ctx, op2);\n    }\n    sp[-2] = JS_NewBool(ctx, res ^ is_neq);\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic no_inline int js_shr_slow(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1, op2;\n    uint32_t v1, v2, r;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    if (unlikely(JS_ToUint32Free(ctx, &v1, op1))) {\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    if (unlikely(JS_ToUint32Free(ctx, &v2, op2)))\n        goto exception;\n    r = v1 >> (v2 & 0x1f);\n    sp[-2] = JS_NewUint32(ctx, r);\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\n#endif /* !CONFIG_BIGNUM */\n\n/* XXX: Should take JSValueConst arguments */\nstatic BOOL js_strict_eq2(JSContext *ctx, JSValue op1, JSValue op2,\n                          JSStrictEqModeEnum eq_mode)\n{\n    BOOL res;\n    int tag1, tag2;\n    double d1, d2;\n\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n    switch(tag1) {\n    case JS_TAG_BOOL:\n        if (tag1 != tag2) {\n            res = FALSE;\n        } else {\n            res = JS_VALUE_GET_INT(op1) == JS_VALUE_GET_INT(op2);\n            goto done_no_free;\n        }\n        break;\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        res = (tag1 == tag2);\n        break;\n    case JS_TAG_STRING:\n        {\n            JSString *p1, *p2;\n            if (tag1 != tag2) {\n                res = FALSE;\n            } else {\n                p1 = JS_VALUE_GET_STRING(op1);\n                p2 = JS_VALUE_GET_STRING(op2);\n                res = (js_string_compare(ctx, p1, p2) == 0);\n            }\n        }\n        break;\n    case JS_TAG_SYMBOL:\n        {\n            JSAtomStruct *p1, *p2;\n            if (tag1 != tag2) {\n                res = FALSE;\n            } else {\n                p1 = JS_VALUE_GET_PTR(op1);\n                p2 = JS_VALUE_GET_PTR(op2);\n                res = (p1 == p2);\n            }\n        }\n        break;\n    case JS_TAG_OBJECT:\n        if (tag1 != tag2)\n            res = FALSE;\n        else\n            res = JS_VALUE_GET_OBJ(op1) == JS_VALUE_GET_OBJ(op2);\n        break;\n    case JS_TAG_INT:\n        d1 = JS_VALUE_GET_INT(op1);\n        if (tag2 == JS_TAG_INT) {\n            d2 = JS_VALUE_GET_INT(op2);\n            goto number_test;\n        } else if (tag2 == JS_TAG_FLOAT64) {\n            d2 = JS_VALUE_GET_FLOAT64(op2);\n            goto number_test;\n        } else {\n            res = FALSE;\n        }\n        break;\n    case JS_TAG_FLOAT64:\n        d1 = JS_VALUE_GET_FLOAT64(op1);\n        if (tag2 == JS_TAG_FLOAT64) {\n            d2 = JS_VALUE_GET_FLOAT64(op2);\n        } else if (tag2 == JS_TAG_INT) {\n            d2 = JS_VALUE_GET_INT(op2);\n        } else {\n            res = FALSE;\n            break;\n        }\n    number_test:\n        if (unlikely(eq_mode >= JS_EQ_SAME_VALUE)) {\n            JSFloat64Union u1, u2;\n            /* NaN is not always normalized, so this test is necessary */\n            if (isnan(d1) || isnan(d2)) {\n                res = isnan(d1) == isnan(d2);\n            } else if (eq_mode == JS_EQ_SAME_VALUE_ZERO) {\n                res = (d1 == d2); /* +0 == -0 */\n            } else {\n                u1.d = d1;\n                u2.d = d2;\n                res = (u1.u64 == u2.u64); /* +0 != -0 */\n            }\n        } else {\n            res = (d1 == d2); /* if NaN return false and +0 == -0 */\n        }\n        goto done_no_free;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n        {\n            bf_t a_s, *a, b_s, *b;\n            if (tag1 != tag2) {\n                res = FALSE;\n                break;\n            }\n            a = JS_ToBigFloat(ctx, &a_s, op1);\n            b = JS_ToBigFloat(ctx, &b_s, op2);\n            res = bf_cmp_eq(a, b);\n            if (a == &a_s)\n                bf_delete(a);\n            if (b == &b_s)\n                bf_delete(b);\n        }\n        break;\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p1, *p2;\n            const bf_t *a, *b;\n            if (tag1 != tag2) {\n                res = FALSE;\n                break;\n            }\n            p1 = JS_VALUE_GET_PTR(op1);\n            p2 = JS_VALUE_GET_PTR(op2);\n            a = &p1->num;\n            b = &p2->num;\n            if (unlikely(eq_mode >= JS_EQ_SAME_VALUE)) {\n                if (eq_mode == JS_EQ_SAME_VALUE_ZERO &&\n                           a->expn == BF_EXP_ZERO && b->expn == BF_EXP_ZERO) {\n                    res = TRUE;\n                } else {\n                    res = (bf_cmp_full(a, b) == 0);\n                }\n            } else {\n                res = bf_cmp_eq(a, b);\n            }\n        }\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        {\n            JSBigDecimal *p1, *p2;\n            const bfdec_t *a, *b;\n            if (tag1 != tag2) {\n                res = FALSE;\n                break;\n            }\n            p1 = JS_VALUE_GET_PTR(op1);\n            p2 = JS_VALUE_GET_PTR(op2);\n            a = &p1->num;\n            b = &p2->num;\n            res = bfdec_cmp_eq(a, b);\n        }\n        break;\n#endif\n    default:\n        res = FALSE;\n        break;\n    }\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n done_no_free:\n    return res;\n}\n\nstatic BOOL js_strict_eq(JSContext *ctx, JSValue op1, JSValue op2)\n{\n    return js_strict_eq2(ctx, op1, op2, JS_EQ_STRICT);\n}\n\nstatic BOOL js_same_value(JSContext *ctx, JSValueConst op1, JSValueConst op2)\n{\n    return js_strict_eq2(ctx,\n                         JS_DupValue(ctx, op1), JS_DupValue(ctx, op2),\n                         JS_EQ_SAME_VALUE);\n}\n\nstatic BOOL js_same_value_zero(JSContext *ctx, JSValueConst op1, JSValueConst op2)\n{\n    return js_strict_eq2(ctx,\n                         JS_DupValue(ctx, op1), JS_DupValue(ctx, op2),\n                         JS_EQ_SAME_VALUE_ZERO);\n}\n\nstatic no_inline int js_strict_eq_slow(JSContext *ctx, JSValue *sp,\n                                       BOOL is_neq)\n{\n    BOOL res;\n    res = js_strict_eq(ctx, sp[-2], sp[-1]);\n    sp[-2] = JS_NewBool(ctx, res ^ is_neq);\n    return 0;\n}\n\nstatic __exception int js_operator_in(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1, op2;\n    JSAtom atom;\n    int ret;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n\n    if (JS_VALUE_GET_TAG(op2) != JS_TAG_OBJECT) {\n        JS_ThrowTypeError(ctx, \"invalid 'in' operand\");\n        return -1;\n    }\n    atom = JS_ValueToAtom(ctx, op1);\n    if (unlikely(atom == JS_ATOM_NULL))\n        return -1;\n    ret = JS_HasProperty(ctx, op2, atom);\n    JS_FreeAtom(ctx, atom);\n    if (ret < 0)\n        return -1;\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    sp[-2] = JS_NewBool(ctx, ret);\n    return 0;\n}\n\nstatic __exception int js_has_unscopable(JSContext *ctx, JSValueConst obj,\n                                         JSAtom atom)\n{\n    JSValue arr, val;\n    int ret;\n\n    arr = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_unscopables);\n    if (JS_IsException(arr))\n        return -1;\n    ret = 0;\n    if (JS_IsObject(arr)) {\n        val = JS_GetProperty(ctx, arr, atom);\n        ret = JS_ToBoolFree(ctx, val);\n    }\n    JS_FreeValue(ctx, arr);\n    return ret;\n}\n\nstatic __exception int js_operator_instanceof(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1, op2;\n    BOOL ret;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    ret = JS_IsInstanceOf(ctx, op1, op2);\n    if (ret < 0)\n        return ret;\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    sp[-2] = JS_NewBool(ctx, ret);\n    return 0;\n}\n\nstatic __exception int js_operator_typeof(JSContext *ctx, JSValueConst op1)\n{\n    JSAtom atom;\n    uint32_t tag;\n\n    tag = JS_VALUE_GET_NORM_TAG(op1);\n    switch(tag) {\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n        atom = JS_ATOM_bigint;\n        break;\n    case JS_TAG_BIG_FLOAT:\n        atom = JS_ATOM_bigfloat;\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        atom = JS_ATOM_bigdecimal;\n        break;\n#endif\n    case JS_TAG_INT:\n    case JS_TAG_FLOAT64:\n        atom = JS_ATOM_number;\n        break;\n    case JS_TAG_UNDEFINED:\n        atom = JS_ATOM_undefined;\n        break;\n    case JS_TAG_BOOL:\n        atom = JS_ATOM_boolean;\n        break;\n    case JS_TAG_STRING:\n        atom = JS_ATOM_string;\n        break;\n    case JS_TAG_OBJECT:\n        {\n            JSObject *p;\n            p = JS_VALUE_GET_OBJ(op1);\n            if (unlikely(p->is_HTMLDDA)) \n                atom = JS_ATOM_undefined;\n            else if (JS_IsFunction(ctx, op1))\n                atom = JS_ATOM_function;\n            else\n                goto obj_type;\n        }\n        break;\n    case JS_TAG_NULL:\n    obj_type:\n        atom = JS_ATOM_object;\n        break;\n    case JS_TAG_SYMBOL:\n        atom = JS_ATOM_symbol;\n        break;\n    default:\n        atom = JS_ATOM_unknown;\n        break;\n    }\n    return atom;\n}\n\nstatic __exception int js_operator_delete(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1, op2;\n    JSAtom atom;\n    int ret;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    atom = JS_ValueToAtom(ctx, op2);\n    if (unlikely(atom == JS_ATOM_NULL))\n        return -1;\n    ret = JS_DeleteProperty(ctx, op1, atom, JS_PROP_THROW_STRICT);\n    JS_FreeAtom(ctx, atom);\n    if (unlikely(ret < 0))\n        return -1;\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    sp[-2] = JS_NewBool(ctx, ret);\n    return 0;\n}\n\nstatic JSValue js_throw_type_error(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    return JS_ThrowTypeError(ctx, \"invalid property access\");\n}\n\n/* XXX: not 100% compatible, but mozilla seems to use a similar\n   implementation to ensure that caller in non strict mode does not\n   throw (ES5 compatibility) */\nstatic JSValue js_function_proto_caller(JSContext *ctx, JSValueConst this_val,\n                                        int argc, JSValueConst *argv)\n{\n    JSFunctionBytecode *b = JS_GetFunctionBytecode(this_val);\n    if (!b || (b->js_mode & JS_MODE_STRICT) || !b->has_prototype) {\n        return js_throw_type_error(ctx, this_val, 0, NULL);\n    }\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_function_proto_fileName(JSContext *ctx,\n                                          JSValueConst this_val)\n{\n    JSFunctionBytecode *b = JS_GetFunctionBytecode(this_val);\n    if (b && b->has_debug) {\n        return JS_AtomToString(ctx, b->debug.filename);\n    }\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_function_proto_lineNumber(JSContext *ctx,\n                                            JSValueConst this_val)\n{\n    JSFunctionBytecode *b = JS_GetFunctionBytecode(this_val);\n    if (b && b->has_debug) {\n        return JS_NewInt32(ctx, b->debug.line_num);\n    }\n    return JS_UNDEFINED;\n}\n\nstatic int js_arguments_define_own_property(JSContext *ctx,\n                                            JSValueConst this_obj,\n                                            JSAtom prop, JSValueConst val,\n                                            JSValueConst getter, JSValueConst setter, int flags)\n{\n    JSObject *p;\n    uint32_t idx;\n    p = JS_VALUE_GET_OBJ(this_obj);\n    /* convert to normal array when redefining an existing numeric field */\n    if (p->fast_array && JS_AtomIsArrayIndex(ctx, &idx, prop) &&\n        idx < p->u.array.count) {\n        if (convert_fast_array_to_array(ctx, p))\n            return -1;\n    }\n    /* run the default define own property */\n    return JS_DefineProperty(ctx, this_obj, prop, val, getter, setter,\n                             flags | JS_PROP_NO_EXOTIC);\n}\n\nstatic const JSClassExoticMethods js_arguments_exotic_methods = {\n    .define_own_property = js_arguments_define_own_property,\n};\n\nstatic JSValue js_build_arguments(JSContext *ctx, int argc, JSValueConst *argv)\n{\n    JSValue val, *tab;\n    JSProperty *pr;\n    JSObject *p;\n    int i;\n\n    val = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],\n                                 JS_CLASS_ARGUMENTS);\n    if (JS_IsException(val))\n        return val;\n    p = JS_VALUE_GET_OBJ(val);\n\n    /* add the length field (cannot fail) */\n    pr = add_property(ctx, p, JS_ATOM_length,\n                      JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    pr->u.value = JS_NewInt32(ctx, argc);\n\n    /* initialize the fast array part */\n    tab = NULL;\n    if (argc > 0) {\n        tab = js_malloc(ctx, sizeof(tab[0]) * argc);\n        if (!tab) {\n            JS_FreeValue(ctx, val);\n            return JS_EXCEPTION;\n        }\n        for(i = 0; i < argc; i++) {\n            tab[i] = JS_DupValue(ctx, argv[i]);\n        }\n    }\n    p->u.array.u.values = tab;\n    p->u.array.count = argc;\n\n    JS_DefinePropertyValue(ctx, val, JS_ATOM_Symbol_iterator,\n                           JS_DupValue(ctx, ctx->array_proto_values),\n                           JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);\n    /* add callee property to throw a TypeError in strict mode */\n    JS_DefineProperty(ctx, val, JS_ATOM_callee, JS_UNDEFINED,\n                      ctx->throw_type_error, ctx->throw_type_error,\n                      JS_PROP_HAS_GET | JS_PROP_HAS_SET);\n    return val;\n}\n\n#define GLOBAL_VAR_OFFSET 0x40000000\n#define ARGUMENT_VAR_OFFSET 0x20000000\n\n/* legacy arguments object: add references to the function arguments */\nstatic JSValue js_build_mapped_arguments(JSContext *ctx, int argc,\n                                         JSValueConst *argv,\n                                         JSStackFrame *sf, int arg_count)\n{\n    JSValue val;\n    JSProperty *pr;\n    JSObject *p;\n    int i;\n\n    val = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],\n                                 JS_CLASS_MAPPED_ARGUMENTS);\n    if (JS_IsException(val))\n        return val;\n    p = JS_VALUE_GET_OBJ(val);\n\n    /* add the length field (cannot fail) */\n    pr = add_property(ctx, p, JS_ATOM_length,\n                      JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    pr->u.value = JS_NewInt32(ctx, argc);\n\n    for(i = 0; i < arg_count; i++) {\n        JSVarRef *var_ref;\n        var_ref = get_var_ref(ctx, sf, i, TRUE);\n        if (!var_ref)\n            goto fail;\n        pr = add_property(ctx, p, __JS_AtomFromUInt32(i), JS_PROP_C_W_E | JS_PROP_VARREF);\n        if (!pr) {\n            free_var_ref(ctx->rt, var_ref);\n            goto fail;\n        }\n        pr->u.var_ref = var_ref;\n    }\n\n    /* the arguments not mapped to the arguments of the function can\n       be normal properties */\n    for(i = arg_count; i < argc; i++) {\n        if (JS_DefinePropertyValueUint32(ctx, val, i,\n                                         JS_DupValue(ctx, argv[i]),\n                                         JS_PROP_C_W_E) < 0)\n            goto fail;\n    }\n\n    JS_DefinePropertyValue(ctx, val, JS_ATOM_Symbol_iterator,\n                           JS_DupValue(ctx, ctx->array_proto_values),\n                           JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);\n    /* callee returns this function in non strict mode */\n    JS_DefinePropertyValue(ctx, val, JS_ATOM_callee,\n                           JS_DupValue(ctx, ctx->rt->current_stack_frame->cur_func),\n                           JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);\n    return val;\n fail:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_build_rest(JSContext *ctx, int first, int argc, JSValueConst *argv)\n{\n    JSValue val;\n    int i, ret;\n\n    val = JS_NewArray(ctx);\n    if (JS_IsException(val))\n        return val;\n    for (i = first; i < argc; i++) {\n        ret = JS_DefinePropertyValueUint32(ctx, val, i - first,\n                                           JS_DupValue(ctx, argv[i]),\n                                           JS_PROP_C_W_E);\n        if (ret < 0) {\n            JS_FreeValue(ctx, val);\n            return JS_EXCEPTION;\n        }\n    }\n    return val;\n}\n\nstatic JSValue build_for_in_iterator(JSContext *ctx, JSValue obj)\n{\n    JSObject *p;\n    JSPropertyEnum *tab_atom;\n    int i;\n    JSValue enum_obj, obj1;\n    JSForInIterator *it;\n    uint32_t tag, tab_atom_count;\n\n    tag = JS_VALUE_GET_TAG(obj);\n    if (tag != JS_TAG_OBJECT && tag != JS_TAG_NULL && tag != JS_TAG_UNDEFINED) {\n        obj = JS_ToObjectFree(ctx, obj);\n    }\n\n    it = js_malloc(ctx, sizeof(*it));\n    if (!it) {\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    enum_obj = JS_NewObjectProtoClass(ctx, JS_NULL, JS_CLASS_FOR_IN_ITERATOR);\n    if (JS_IsException(enum_obj)) {\n        js_free(ctx, it);\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    it->is_array = FALSE;\n    it->obj = obj;\n    it->idx = 0;\n    p = JS_VALUE_GET_OBJ(enum_obj);\n    p->u.for_in_iterator = it;\n\n    if (tag == JS_TAG_NULL || tag == JS_TAG_UNDEFINED)\n        return enum_obj;\n\n    /* fast path: assume no enumerable properties in the prototype chain */\n    obj1 = JS_DupValue(ctx, obj);\n    for(;;) {\n        obj1 = JS_GetPrototypeFree(ctx, obj1);\n        if (JS_IsNull(obj1))\n            break;\n        if (JS_IsException(obj1))\n            goto fail;\n        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count,\n                                           JS_VALUE_GET_OBJ(obj1),\n                                           JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY)) {\n            JS_FreeValue(ctx, obj1);\n            goto fail;\n        }\n        js_free_prop_enum(ctx, tab_atom, tab_atom_count);\n        if (tab_atom_count != 0) {\n            JS_FreeValue(ctx, obj1);\n            goto slow_path;\n        }\n        /* must check for timeout to avoid infinite loop */\n        if (js_poll_interrupts(ctx)) {\n            JS_FreeValue(ctx, obj1);\n            goto fail;\n        }\n    }\n\n    p = JS_VALUE_GET_OBJ(obj);\n\n    if (p->fast_array) {\n        JSShape *sh;\n        JSShapeProperty *prs;\n        /* check that there are no enumerable normal fields */\n        sh = p->shape;\n        for(i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {\n            if (prs->flags & JS_PROP_ENUMERABLE)\n                goto normal_case;\n        }\n        /* for fast arrays, we only store the number of elements */\n        it->is_array = TRUE;\n        it->array_length = p->u.array.count;\n    } else {\n    normal_case:\n        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count, p,\n                                   JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY))\n            goto fail;\n        for(i = 0; i < tab_atom_count; i++) {\n            JS_SetPropertyInternal(ctx, enum_obj, tab_atom[i].atom, JS_NULL, 0);\n        }\n        js_free_prop_enum(ctx, tab_atom, tab_atom_count);\n    }\n    return enum_obj;\n\n slow_path:\n    /* non enumerable properties hide the enumerables ones in the\n       prototype chain */\n    obj1 = JS_DupValue(ctx, obj);\n    for(;;) {\n        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count,\n                                           JS_VALUE_GET_OBJ(obj1),\n                                           JS_GPN_STRING_MASK | JS_GPN_SET_ENUM)) {\n            JS_FreeValue(ctx, obj1);\n            goto fail;\n        }\n        for(i = 0; i < tab_atom_count; i++) {\n            JS_DefinePropertyValue(ctx, enum_obj, tab_atom[i].atom, JS_NULL,\n                                   (tab_atom[i].is_enumerable ?\n                                    JS_PROP_ENUMERABLE : 0));\n        }\n        js_free_prop_enum(ctx, tab_atom, tab_atom_count);\n        obj1 = JS_GetPrototypeFree(ctx, obj1);\n        if (JS_IsNull(obj1))\n            break;\n        if (JS_IsException(obj1))\n            goto fail;\n        /* must check for timeout to avoid infinite loop */\n        if (js_poll_interrupts(ctx)) {\n            JS_FreeValue(ctx, obj1);\n            goto fail;\n        }\n    }\n    return enum_obj;\n\n fail:\n    JS_FreeValue(ctx, enum_obj);\n    return JS_EXCEPTION;\n}\n\n/* obj -> enum_obj */\nstatic __exception int js_for_in_start(JSContext *ctx, JSValue *sp)\n{\n    sp[-1] = build_for_in_iterator(ctx, sp[-1]);\n    if (JS_IsException(sp[-1]))\n        return -1;\n    return 0;\n}\n\n/* enum_obj -> enum_obj value done */\nstatic __exception int js_for_in_next(JSContext *ctx, JSValue *sp)\n{\n    JSValueConst enum_obj;\n    JSObject *p;\n    JSAtom prop;\n    JSForInIterator *it;\n    int ret;\n\n    enum_obj = sp[-1];\n    /* fail safe */\n    if (JS_VALUE_GET_TAG(enum_obj) != JS_TAG_OBJECT)\n        goto done;\n    p = JS_VALUE_GET_OBJ(enum_obj);\n    if (p->class_id != JS_CLASS_FOR_IN_ITERATOR)\n        goto done;\n    it = p->u.for_in_iterator;\n\n    for(;;) {\n        if (it->is_array) {\n            if (it->idx >= it->array_length)\n                goto done;\n            prop = __JS_AtomFromUInt32(it->idx);\n            it->idx++;\n        } else {\n            JSShape *sh = p->shape;\n            JSShapeProperty *prs;\n            if (it->idx >= sh->prop_count)\n                goto done;\n            prs = get_shape_prop(sh) + it->idx;\n            prop = prs->atom;\n            it->idx++;\n            if (prop == JS_ATOM_NULL || !(prs->flags & JS_PROP_ENUMERABLE))\n                continue;\n        }\n        /* check if the property was deleted */\n        ret = JS_HasProperty(ctx, it->obj, prop);\n        if (ret < 0)\n            return ret;\n        if (ret)\n            break;\n    }\n    /* return the property */\n    sp[0] = JS_AtomToValue(ctx, prop);\n    sp[1] = JS_FALSE;\n    return 0;\n done:\n    /* return the end */\n    sp[0] = JS_UNDEFINED;\n    sp[1] = JS_TRUE;\n    return 0;\n}\n\nstatic JSValue JS_GetIterator2(JSContext *ctx, JSValueConst obj,\n                               JSValueConst method)\n{\n    JSValue enum_obj;\n\n    enum_obj = JS_Call(ctx, method, obj, 0, NULL);\n    if (JS_IsException(enum_obj))\n        return enum_obj;\n    if (!JS_IsObject(enum_obj)) {\n        JS_FreeValue(ctx, enum_obj);\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    }\n    return enum_obj;\n}\n\nstatic JSValue JS_GetIterator(JSContext *ctx, JSValueConst obj, BOOL is_async)\n{\n    JSValue method, ret, sync_iter;\n\n    if (is_async) {\n        method = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_asyncIterator);\n        if (JS_IsException(method))\n            return method;\n        if (JS_IsUndefined(method) || JS_IsNull(method)) {\n            method = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_iterator);\n            if (JS_IsException(method))\n                return method;\n            sync_iter = JS_GetIterator2(ctx, obj, method);\n            JS_FreeValue(ctx, method);\n            if (JS_IsException(sync_iter))\n                return sync_iter;\n            ret = JS_CreateAsyncFromSyncIterator(ctx, sync_iter);\n            JS_FreeValue(ctx, sync_iter);\n            return ret;\n        }\n    } else {\n        method = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_iterator);\n        if (JS_IsException(method))\n            return method;\n    }\n    if (!JS_IsFunction(ctx, method)) {\n        JS_FreeValue(ctx, method);\n        return JS_ThrowTypeError(ctx, \"value is not iterable\");\n    }\n    ret = JS_GetIterator2(ctx, obj, method);\n    JS_FreeValue(ctx, method);\n    return ret;\n}\n\n/* return *pdone = 2 if the iterator object is not parsed */\nstatic JSValue JS_IteratorNext2(JSContext *ctx, JSValueConst enum_obj,\n                                JSValueConst method,\n                                int argc, JSValueConst *argv, int *pdone)\n{\n    JSValue obj;\n\n    /* fast path for the built-in iterators (avoid creating the\n       intermediate result object) */\n    if (JS_IsObject(method)) {\n        JSObject *p = JS_VALUE_GET_OBJ(method);\n        if (p->class_id == JS_CLASS_C_FUNCTION &&\n            p->u.cfunc.cproto == JS_CFUNC_iterator_next) {\n            JSCFunctionType func;\n            JSValueConst args[1];\n\n            /* in case the function expects one argument */\n            if (argc == 0) {\n                args[0] = JS_UNDEFINED;\n                argv = args;\n            }\n            func = p->u.cfunc.c_function;\n            return func.iterator_next(ctx, enum_obj, argc, argv,\n                                      pdone, p->u.cfunc.magic);\n        }\n    }\n    obj = JS_Call(ctx, method, enum_obj, argc, argv);\n    if (JS_IsException(obj))\n        goto fail;\n    if (!JS_IsObject(obj)) {\n        JS_FreeValue(ctx, obj);\n        JS_ThrowTypeError(ctx, \"iterator must return an object\");\n        goto fail;\n    }\n    *pdone = 2;\n    return obj;\n fail:\n    *pdone = FALSE;\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_IteratorNext(JSContext *ctx, JSValueConst enum_obj,\n                               JSValueConst method,\n                               int argc, JSValueConst *argv, BOOL *pdone)\n{\n    JSValue obj, value, done_val;\n    int done;\n\n    obj = JS_IteratorNext2(ctx, enum_obj, method, argc, argv, &done);\n    if (JS_IsException(obj))\n        goto fail;\n    if (done != 2) {\n        *pdone = done;\n        return obj;\n    } else {\n        done_val = JS_GetProperty(ctx, obj, JS_ATOM_done);\n        if (JS_IsException(done_val))\n            goto fail;\n        *pdone = JS_ToBoolFree(ctx, done_val);\n        value = JS_UNDEFINED;\n        if (!*pdone) {\n            value = JS_GetProperty(ctx, obj, JS_ATOM_value);\n        }\n        JS_FreeValue(ctx, obj);\n        return value;\n    }\n fail:\n    JS_FreeValue(ctx, obj);\n    *pdone = FALSE;\n    return JS_EXCEPTION;\n}\n\n/* return < 0 in case of exception */\nstatic int JS_IteratorClose(JSContext *ctx, JSValueConst enum_obj,\n                            BOOL is_exception_pending)\n{\n    JSValue method, ret, ex_obj;\n    int res;\n\n    if (is_exception_pending) {\n        ex_obj = ctx->rt->current_exception;\n        ctx->rt->current_exception = JS_NULL;\n        res = -1;\n    } else {\n        ex_obj = JS_UNDEFINED;\n        res = 0;\n    }\n    method = JS_GetProperty(ctx, enum_obj, JS_ATOM_return);\n    if (JS_IsException(method)) {\n        res = -1;\n        goto done;\n    }\n    if (JS_IsUndefined(method) || JS_IsNull(method)) {\n        goto done;\n    }\n    ret = JS_CallFree(ctx, method, enum_obj, 0, NULL);\n    if (!is_exception_pending) {\n        if (JS_IsException(ret)) {\n            res = -1;\n        } else if (!JS_IsObject(ret)) {\n            JS_ThrowTypeErrorNotAnObject(ctx);\n            res = -1;\n        }\n    }\n    JS_FreeValue(ctx, ret);\n done:\n    if (is_exception_pending) {\n        JS_Throw(ctx, ex_obj);\n    }\n    return res;\n}\n\n/* obj -> enum_rec (3 slots) */\nstatic __exception int js_for_of_start(JSContext *ctx, JSValue *sp,\n                                       BOOL is_async)\n{\n    JSValue op1, obj, method;\n    op1 = sp[-1];\n    obj = JS_GetIterator(ctx, op1, is_async);\n    if (JS_IsException(obj))\n        return -1;\n    JS_FreeValue(ctx, op1);\n    sp[-1] = obj;\n    method = JS_GetProperty(ctx, obj, JS_ATOM_next);\n    if (JS_IsException(method))\n        return -1;\n    sp[0] = method;\n    return 0;\n}\n\n/* enum_rec [objs] -> enum_rec [objs] value done. There are 'offset'\n   objs. If 'done' is true or in case of exception, 'enum_rec' is set\n   to undefined. If 'done' is true, 'value' is always set to\n   undefined. */\nstatic __exception int js_for_of_next(JSContext *ctx, JSValue *sp, int offset)\n{\n    JSValue value = JS_UNDEFINED;\n    int done = 1;\n\n    if (likely(!JS_IsUndefined(sp[offset]))) {\n        value = JS_IteratorNext(ctx, sp[offset], sp[offset + 1], 0, NULL, &done);\n        if (JS_IsException(value))\n            done = -1;\n        if (done) {\n            /* value is JS_UNDEFINED or JS_EXCEPTION */\n            /* replace the iteration object with undefined */\n            JS_FreeValue(ctx, sp[offset]);\n            sp[offset] = JS_UNDEFINED;\n            if (done < 0) {\n                return -1;\n            } else {\n                JS_FreeValue(ctx, value);\n                value = JS_UNDEFINED;\n            }\n        }\n    }\n    sp[0] = value;\n    sp[1] = JS_NewBool(ctx, done);\n    return 0;\n}\n\nstatic JSValue JS_IteratorGetCompleteValue(JSContext *ctx, JSValueConst obj,\n                                           BOOL *pdone)\n{\n    JSValue done_val, value;\n    BOOL done;\n    done_val = JS_GetProperty(ctx, obj, JS_ATOM_done);\n    if (JS_IsException(done_val))\n        goto fail;\n    done = JS_ToBoolFree(ctx, done_val);\n    value = JS_GetProperty(ctx, obj, JS_ATOM_value);\n    if (JS_IsException(value))\n        goto fail;\n    *pdone = done;\n    return value;\n fail:\n    *pdone = FALSE;\n    return JS_EXCEPTION;\n}\n\nstatic __exception int js_iterator_get_value_done(JSContext *ctx, JSValue *sp)\n{\n    JSValue obj, value;\n    BOOL done;\n    obj = sp[-1];\n    if (!JS_IsObject(obj)) {\n        JS_ThrowTypeError(ctx, \"iterator must return an object\");\n        return -1;\n    }\n    value = JS_IteratorGetCompleteValue(ctx, obj, &done);\n    if (JS_IsException(value))\n        return -1;\n    JS_FreeValue(ctx, obj);\n    sp[-1] = value;\n    sp[0] = JS_NewBool(ctx, done);\n    return 0;\n}\n\nstatic JSValue js_create_iterator_result(JSContext *ctx,\n                                         JSValue val,\n                                         BOOL done)\n{\n    JSValue obj;\n    obj = JS_NewObject(ctx);\n    if (JS_IsException(obj)) {\n        JS_FreeValue(ctx, val);\n        return obj;\n    }\n    if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_value,\n                               val, JS_PROP_C_W_E) < 0) {\n        goto fail;\n    }\n    if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_done,\n                               JS_NewBool(ctx, done), JS_PROP_C_W_E) < 0) {\n    fail:\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    return obj;\n}\n\nstatic JSValue js_array_iterator_next(JSContext *ctx, JSValueConst this_val,\n                                      int argc, JSValueConst *argv,\n                                      BOOL *pdone, int magic);\n\nstatic JSValue js_create_array_iterator(JSContext *ctx, JSValueConst this_val,\n                                        int argc, JSValueConst *argv, int magic);\n\nstatic BOOL js_is_fast_array(JSContext *ctx, JSValueConst obj)\n{\n    /* Try and handle fast arrays explicitly */\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(obj);\n        if (p->class_id == JS_CLASS_ARRAY && p->fast_array) {\n            return TRUE;\n        }\n    }\n    return FALSE;\n}\n\n/* Access an Array's internal JSValue array if available */\nstatic BOOL js_get_fast_array(JSContext *ctx, JSValueConst obj,\n                              JSValue **arrpp, uint32_t *countp)\n{\n    /* Try and handle fast arrays explicitly */\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(obj);\n        if (p->class_id == JS_CLASS_ARRAY && p->fast_array) {\n            *countp = p->u.array.count;\n            *arrpp = p->u.array.u.values;\n            return TRUE;\n        }\n    }\n    return FALSE;\n}\n\nstatic __exception int js_append_enumerate(JSContext *ctx, JSValue *sp)\n{\n    JSValue iterator, enumobj, method, value;\n    int is_array_iterator;\n    JSValue *arrp;\n    uint32_t i, count32, pos;\n    \n    if (JS_VALUE_GET_TAG(sp[-2]) != JS_TAG_INT) {\n        JS_ThrowInternalError(ctx, \"invalid index for append\");\n        return -1;\n    }\n\n    pos = JS_VALUE_GET_INT(sp[-2]);\n\n    /* XXX: further optimisations:\n       - use ctx->array_proto_values?\n       - check if array_iterator_prototype next method is built-in and\n         avoid constructing actual iterator object?\n       - build this into js_for_of_start and use in all `for (x of o)` loops\n     */\n    iterator = JS_GetProperty(ctx, sp[-1], JS_ATOM_Symbol_iterator);\n    if (JS_IsException(iterator))\n        return -1;\n    is_array_iterator = JS_IsCFunction(ctx, iterator,\n                                       (JSCFunction *)js_create_array_iterator,\n                                       JS_ITERATOR_KIND_VALUE);\n    JS_FreeValue(ctx, iterator);\n\n    enumobj = JS_GetIterator(ctx, sp[-1], FALSE);\n    if (JS_IsException(enumobj))\n        return -1;\n    method = JS_GetProperty(ctx, enumobj, JS_ATOM_next);\n    if (JS_IsException(method)) {\n        JS_FreeValue(ctx, enumobj);\n        return -1;\n    }\n    if (is_array_iterator\n    &&  JS_IsCFunction(ctx, method, (JSCFunction *)js_array_iterator_next, 0)\n    &&  js_get_fast_array(ctx, sp[-1], &arrp, &count32)) {\n        uint32_t len;\n        if (js_get_length32(ctx, &len, sp[-1]))\n            goto exception;\n        /* if len > count32, the elements >= count32 might be read in\n           the prototypes and might have side effects */\n        if (len != count32)\n            goto general_case;\n        /* Handle fast arrays explicitly */\n        for (i = 0; i < count32; i++) {\n            if (JS_DefinePropertyValueUint32(ctx, sp[-3], pos++,\n                                             JS_DupValue(ctx, arrp[i]), JS_PROP_C_W_E) < 0)\n                goto exception;\n        }\n    } else {\n    general_case:\n        for (;;) {\n            BOOL done;\n            value = JS_IteratorNext(ctx, enumobj, method, 0, NULL, &done);\n            if (JS_IsException(value))\n                goto exception;\n            if (done) {\n                /* value is JS_UNDEFINED */\n                break;\n            }\n            if (JS_DefinePropertyValueUint32(ctx, sp[-3], pos++, value, JS_PROP_C_W_E) < 0)\n                goto exception;\n        }\n    }\n    /* Note: could raise an error if too many elements */\n    sp[-2] = JS_NewInt32(ctx, pos);\n    JS_FreeValue(ctx, enumobj);\n    JS_FreeValue(ctx, method);\n    return 0;\n\nexception:\n    JS_IteratorClose(ctx, enumobj, TRUE);\n    JS_FreeValue(ctx, enumobj);\n    JS_FreeValue(ctx, method);\n    return -1;\n}\n\nstatic __exception int JS_CopyDataProperties(JSContext *ctx,\n                                             JSValueConst target,\n                                             JSValueConst source,\n                                             JSValueConst excluded,\n                                             BOOL setprop)\n{\n    JSPropertyEnum *tab_atom;\n    JSValue val;\n    uint32_t i, tab_atom_count;\n    JSObject *p;\n    JSObject *pexcl = NULL;\n    int ret, gpn_flags;\n    JSPropertyDescriptor desc;\n    BOOL is_enumerable;\n    \n    if (JS_VALUE_GET_TAG(source) != JS_TAG_OBJECT)\n        return 0;\n\n    if (JS_VALUE_GET_TAG(excluded) == JS_TAG_OBJECT)\n        pexcl = JS_VALUE_GET_OBJ(excluded);\n\n    p = JS_VALUE_GET_OBJ(source);\n\n    gpn_flags = JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK | JS_GPN_ENUM_ONLY;\n    if (p->is_exotic) {\n        const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n        /* cannot use JS_GPN_ENUM_ONLY with e.g. proxies because it\n           introduces a visible change */\n        if (em && em->get_own_property_names) {\n            gpn_flags &= ~JS_GPN_ENUM_ONLY;\n        }\n    }\n    if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count, p,\n                                       gpn_flags))\n        return -1;\n    \n    for (i = 0; i < tab_atom_count; i++) {\n        if (pexcl) {\n            ret = JS_GetOwnPropertyInternal(ctx, NULL, pexcl, tab_atom[i].atom);\n            if (ret) {\n                if (ret < 0)\n                    goto exception;\n                continue;\n            }\n        }\n        if (!(gpn_flags & JS_GPN_ENUM_ONLY)) {\n            /* test if the property is enumerable */\n            ret = JS_GetOwnPropertyInternal(ctx, &desc, p, tab_atom[i].atom);\n            if (ret < 0)\n                goto exception;\n            if (!ret)\n                continue;\n            is_enumerable = (desc.flags & JS_PROP_ENUMERABLE) != 0;\n            js_free_desc(ctx, &desc);\n            if (!is_enumerable)\n                continue;\n        }\n        val = JS_GetProperty(ctx, source, tab_atom[i].atom);\n        if (JS_IsException(val))\n            goto exception;\n        if (setprop)\n            ret = JS_SetProperty(ctx, target, tab_atom[i].atom, val);\n        else\n            ret = JS_DefinePropertyValue(ctx, target, tab_atom[i].atom, val,\n                                         JS_PROP_C_W_E);\n        if (ret < 0)\n            goto exception;\n    }\n    js_free_prop_enum(ctx, tab_atom, tab_atom_count);\n    return 0;\n exception:\n    js_free_prop_enum(ctx, tab_atom, tab_atom_count);\n    return -1;\n}\n\n/* only valid inside C functions */\nstatic JSValueConst JS_GetActiveFunction(JSContext *ctx)\n{\n    return ctx->rt->current_stack_frame->cur_func;\n}\n\nstatic JSVarRef *get_var_ref(JSContext *ctx, JSStackFrame *sf,\n                             int var_idx, BOOL is_arg)\n{\n    JSVarRef *var_ref;\n    struct list_head *el;\n\n    list_for_each(el, &sf->var_ref_list) {\n        var_ref = list_entry(el, JSVarRef, header.link);\n        if (var_ref->var_idx == var_idx && var_ref->is_arg == is_arg) {\n            var_ref->header.ref_count++;\n            return var_ref;\n        }\n    }\n    /* create a new one */\n    var_ref = js_malloc(ctx, sizeof(JSVarRef));\n    if (!var_ref)\n        return NULL;\n    var_ref->header.ref_count = 1;\n    var_ref->is_detached = FALSE;\n    var_ref->is_arg = is_arg;\n    var_ref->var_idx = var_idx;\n    list_add_tail(&var_ref->header.link, &sf->var_ref_list);\n    if (is_arg)\n        var_ref->pvalue = &sf->arg_buf[var_idx];\n    else\n        var_ref->pvalue = &sf->var_buf[var_idx];\n    var_ref->value = JS_UNDEFINED;\n    return var_ref;\n}\n\nstatic JSValue js_closure2(JSContext *ctx, JSValue func_obj,\n                           JSFunctionBytecode *b,\n                           JSVarRef **cur_var_refs,\n                           JSStackFrame *sf)\n{\n    JSObject *p;\n    JSVarRef **var_refs;\n    int i;\n\n    p = JS_VALUE_GET_OBJ(func_obj);\n    p->u.func.function_bytecode = b;\n    p->u.func.home_object = NULL;\n    p->u.func.var_refs = NULL;\n    if (b->closure_var_count) {\n        var_refs = js_mallocz(ctx, sizeof(var_refs[0]) * b->closure_var_count);\n        if (!var_refs)\n            goto fail;\n        p->u.func.var_refs = var_refs;\n        for(i = 0; i < b->closure_var_count; i++) {\n            JSClosureVar *cv = &b->closure_var[i];\n            JSVarRef *var_ref;\n            if (cv->is_local) {\n                /* reuse the existing variable reference if it already exists */\n                var_ref = get_var_ref(ctx, sf, cv->var_idx, cv->is_arg);\n                if (!var_ref)\n                    goto fail;\n            } else {\n                var_ref = cur_var_refs[cv->var_idx];\n                var_ref->header.ref_count++;\n            }\n            var_refs[i] = var_ref;\n        }\n    }\n    return func_obj;\n fail:\n    /* bfunc is freed when func_obj is freed */\n    JS_FreeValue(ctx, func_obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_instantiate_prototype(JSContext *ctx, JSObject *p, JSAtom atom, void *opaque)\n{\n    JSValue obj, this_val;\n    int ret;\n\n    this_val = JS_MKPTR(JS_TAG_OBJECT, p);\n    obj = JS_NewObject(ctx);\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n    set_cycle_flag(ctx, obj);\n    set_cycle_flag(ctx, this_val);\n    ret = JS_DefinePropertyValue(ctx, obj, JS_ATOM_constructor,\n                                 JS_DupValue(ctx, this_val),\n                                 JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    if (ret < 0) {\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    return obj;\n}\n\nstatic const uint16_t func_kind_to_class_id[] = {\n    [JS_FUNC_NORMAL] = JS_CLASS_BYTECODE_FUNCTION,\n    [JS_FUNC_GENERATOR] = JS_CLASS_GENERATOR_FUNCTION,\n    [JS_FUNC_ASYNC] = JS_CLASS_ASYNC_FUNCTION,\n    [JS_FUNC_ASYNC_GENERATOR] = JS_CLASS_ASYNC_GENERATOR_FUNCTION,\n};\n\nstatic JSValue js_closure(JSContext *ctx, JSValue bfunc,\n                          JSVarRef **cur_var_refs,\n                          JSStackFrame *sf)\n{\n    JSFunctionBytecode *b;\n    JSValue func_obj;\n    JSAtom name_atom;\n\n    b = JS_VALUE_GET_PTR(bfunc);\n    func_obj = JS_NewObjectClass(ctx, func_kind_to_class_id[b->func_kind]);\n    if (JS_IsException(func_obj)) {\n        JS_FreeValue(ctx, bfunc);\n        return JS_EXCEPTION;\n    }\n    func_obj = js_closure2(ctx, func_obj, b, cur_var_refs, sf);\n    if (JS_IsException(func_obj)) {\n        /* bfunc has been freed */\n        goto fail;\n    }\n    name_atom = b->func_name;\n    if (name_atom == JS_ATOM_NULL)\n        name_atom = JS_ATOM_empty_string;\n    js_function_set_properties(ctx, func_obj, name_atom,\n                               b->defined_arg_count);\n\n    if (b->func_kind & JS_FUNC_GENERATOR) {\n        JSValue proto;\n        int proto_class_id;\n        /* generators have a prototype field which is used as\n           prototype for the generator object */\n        if (b->func_kind == JS_FUNC_ASYNC_GENERATOR)\n            proto_class_id = JS_CLASS_ASYNC_GENERATOR;\n        else\n            proto_class_id = JS_CLASS_GENERATOR;\n        proto = JS_NewObjectProto(ctx, ctx->class_proto[proto_class_id]);\n        if (JS_IsException(proto))\n            goto fail;\n        JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_prototype, proto,\n                               JS_PROP_WRITABLE);\n    } else if (b->has_prototype) {\n        /* add the 'prototype' property: delay instantiation to avoid\n           creating cycles for every javascript function. The prototype\n           object is created on the fly when first accessed */\n        JS_SetConstructorBit(ctx, func_obj, TRUE);\n        JS_DefineAutoInitProperty(ctx, func_obj, JS_ATOM_prototype,\n                                  JS_AUTOINIT_ID_PROTOTYPE, NULL,\n                                  JS_PROP_WRITABLE);\n    }\n    return func_obj;\n fail:\n    /* bfunc is freed when func_obj is freed */\n    JS_FreeValue(ctx, func_obj);\n    return JS_EXCEPTION;\n}\n\n#define JS_DEFINE_CLASS_HAS_HERITAGE     (1 << 0)\n\nstatic int js_op_define_class(JSContext *ctx, JSValue *sp,\n                              JSAtom class_name, int class_flags,\n                              JSVarRef **cur_var_refs,\n                              JSStackFrame *sf, BOOL is_computed_name)\n{\n    JSValue bfunc, parent_class, proto = JS_UNDEFINED;\n    JSValue ctor = JS_UNDEFINED, parent_proto = JS_UNDEFINED;\n    JSFunctionBytecode *b;\n\n    parent_class = sp[-2];\n    bfunc = sp[-1];\n\n    if (class_flags & JS_DEFINE_CLASS_HAS_HERITAGE) {\n        if (JS_IsNull(parent_class)) {\n            parent_proto = JS_NULL;\n            parent_class = JS_DupValue(ctx, ctx->function_proto);\n        } else {\n            if (!JS_IsConstructor(ctx, parent_class)) {\n                JS_ThrowTypeError(ctx, \"parent class must be constructor\");\n                goto fail;\n            }\n            parent_proto = JS_GetProperty(ctx, parent_class, JS_ATOM_prototype);\n            if (JS_IsException(parent_proto))\n                goto fail;\n            if (!JS_IsNull(parent_proto) && !JS_IsObject(parent_proto)) {\n                JS_ThrowTypeError(ctx, \"parent prototype must be an object or null\");\n                goto fail;\n            }\n        }\n    } else {\n        /* parent_class is JS_UNDEFINED in this case */\n        parent_proto = JS_DupValue(ctx, ctx->class_proto[JS_CLASS_OBJECT]);\n        parent_class = JS_DupValue(ctx, ctx->function_proto);\n    }\n    proto = JS_NewObjectProto(ctx, parent_proto);\n    if (JS_IsException(proto))\n        goto fail;\n\n    b = JS_VALUE_GET_PTR(bfunc);\n    assert(b->func_kind == JS_FUNC_NORMAL);\n    ctor = JS_NewObjectProtoClass(ctx, parent_class,\n                                  JS_CLASS_BYTECODE_FUNCTION);\n    if (JS_IsException(ctor))\n        goto fail;\n    ctor = js_closure2(ctx, ctor, b, cur_var_refs, sf);\n    bfunc = JS_UNDEFINED;\n    if (JS_IsException(ctor))\n        goto fail;\n    js_method_set_home_object(ctx, ctor, proto);\n    JS_SetConstructorBit(ctx, ctor, TRUE);\n\n    JS_DefinePropertyValue(ctx, ctor, JS_ATOM_length,\n                           JS_NewInt32(ctx, b->defined_arg_count),\n                           JS_PROP_CONFIGURABLE);\n\n    if (is_computed_name) {\n        if (JS_DefineObjectNameComputed(ctx, ctor, sp[-3],\n                                        JS_PROP_CONFIGURABLE) < 0)\n            goto fail;\n    } else {\n        if (JS_DefineObjectName(ctx, ctor, class_name, JS_PROP_CONFIGURABLE) < 0)\n            goto fail;\n    }\n\n    /* the constructor property must be first. It can be overriden by\n       computed property names */\n    if (JS_DefinePropertyValue(ctx, proto, JS_ATOM_constructor,\n                               JS_DupValue(ctx, ctor),\n                               JS_PROP_CONFIGURABLE |\n                               JS_PROP_WRITABLE | JS_PROP_THROW) < 0)\n        goto fail;\n    /* set the prototype property */\n    if (JS_DefinePropertyValue(ctx, ctor, JS_ATOM_prototype,\n                               JS_DupValue(ctx, proto), JS_PROP_THROW) < 0)\n        goto fail;\n    set_cycle_flag(ctx, ctor);\n    set_cycle_flag(ctx, proto);\n\n    JS_FreeValue(ctx, parent_proto);\n    JS_FreeValue(ctx, parent_class);\n\n    sp[-2] = ctor;\n    sp[-1] = proto;\n    return 0;\n fail:\n    JS_FreeValue(ctx, parent_class);\n    JS_FreeValue(ctx, parent_proto);\n    JS_FreeValue(ctx, bfunc);\n    JS_FreeValue(ctx, proto);\n    JS_FreeValue(ctx, ctor);\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic void close_var_refs(JSRuntime *rt, JSStackFrame *sf)\n{\n    struct list_head *el, *el1;\n    JSVarRef *var_ref;\n    int var_idx;\n\n    list_for_each_safe(el, el1, &sf->var_ref_list) {\n        var_ref = list_entry(el, JSVarRef, header.link);\n        var_idx = var_ref->var_idx;\n        if (var_ref->is_arg)\n            var_ref->value = JS_DupValueRT(rt, sf->arg_buf[var_idx]);\n        else\n            var_ref->value = JS_DupValueRT(rt, sf->var_buf[var_idx]);\n        var_ref->pvalue = &var_ref->value;\n        /* the reference is no longer to a local variable */\n        var_ref->is_detached = TRUE;\n        add_gc_object(rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);\n    }\n}\n\nstatic void close_lexical_var(JSContext *ctx, JSStackFrame *sf, int idx, int is_arg)\n{\n    struct list_head *el, *el1;\n    JSVarRef *var_ref;\n    int var_idx = idx;\n\n    list_for_each_safe(el, el1, &sf->var_ref_list) {\n        var_ref = list_entry(el, JSVarRef, header.link);\n        if (var_idx == var_ref->var_idx && var_ref->is_arg == is_arg) {\n            var_ref->value = JS_DupValue(ctx, sf->var_buf[var_idx]);\n            var_ref->pvalue = &var_ref->value;\n            list_del(&var_ref->header.link);\n            /* the reference is no longer to a local variable */\n            var_ref->is_detached = TRUE;\n            add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);\n        }\n    }\n}\n\n#define JS_CALL_FLAG_COPY_ARGV   (1 << 1)\n#define JS_CALL_FLAG_GENERATOR   (1 << 2)\n\nstatic JSValue js_call_c_function(JSContext *ctx, JSValueConst func_obj,\n                                  JSValueConst this_obj,\n                                  int argc, JSValueConst *argv, int flags)\n{\n    JSRuntime *rt = ctx->rt;\n    JSCFunctionType func;\n    JSObject *p;\n    JSStackFrame sf_s, *sf = &sf_s, *prev_sf;\n    JSValue ret_val;\n    JSValueConst *arg_buf;\n    int arg_count, i;\n    JSCFunctionEnum cproto;\n\n    p = JS_VALUE_GET_OBJ(func_obj);\n    cproto = p->u.cfunc.cproto;\n    arg_count = p->u.cfunc.length;\n\n    /* better to always check stack overflow */\n    if (js_check_stack_overflow(rt, sizeof(arg_buf[0]) * arg_count))\n        return JS_ThrowStackOverflow(ctx);\n\n    prev_sf = rt->current_stack_frame;\n    sf->prev_frame = prev_sf;\n    rt->current_stack_frame = sf;\n    ctx = p->u.cfunc.realm; /* change the current realm */\n    \n#ifdef CONFIG_BIGNUM\n    /* we only propagate the bignum mode as some runtime functions\n       test it */\n    if (prev_sf)\n        sf->js_mode = prev_sf->js_mode & JS_MODE_MATH;\n    else\n        sf->js_mode = 0;\n#else\n    sf->js_mode = 0;\n#endif\n    sf->cur_func = (JSValue)func_obj;\n    sf->arg_count = argc;\n    arg_buf = argv;\n\n    if (unlikely(argc < arg_count)) {\n        /* ensure that at least argc_count arguments are readable */\n        arg_buf = alloca(sizeof(arg_buf[0]) * arg_count);\n        for(i = 0; i < argc; i++)\n            arg_buf[i] = argv[i];\n        for(i = argc; i < arg_count; i++)\n            arg_buf[i] = JS_UNDEFINED;\n        sf->arg_count = arg_count;\n    }\n    sf->arg_buf = (JSValue*)arg_buf;\n\n    func = p->u.cfunc.c_function;\n    switch(cproto) {\n    case JS_CFUNC_constructor:\n    case JS_CFUNC_constructor_or_func:\n        if (!(flags & JS_CALL_FLAG_CONSTRUCTOR)) {\n            if (cproto == JS_CFUNC_constructor) {\n            not_a_constructor:\n                ret_val = JS_ThrowTypeError(ctx, \"must be called with new\");\n                break;\n            } else {\n                this_obj = JS_UNDEFINED;\n            }\n        }\n        /* here this_obj is new_target */\n        /* fall thru */\n    case JS_CFUNC_generic:\n        ret_val = func.generic(ctx, this_obj, argc, arg_buf);\n        break;\n    case JS_CFUNC_constructor_magic:\n    case JS_CFUNC_constructor_or_func_magic:\n        if (!(flags & JS_CALL_FLAG_CONSTRUCTOR)) {\n            if (cproto == JS_CFUNC_constructor_magic) {\n                goto not_a_constructor;\n            } else {\n                this_obj = JS_UNDEFINED;\n            }\n        }\n        /* fall thru */\n    case JS_CFUNC_generic_magic:\n        ret_val = func.generic_magic(ctx, this_obj, argc, arg_buf,\n                                     p->u.cfunc.magic);\n        break;\n    case JS_CFUNC_getter:\n        ret_val = func.getter(ctx, this_obj);\n        break;\n    case JS_CFUNC_setter:\n        ret_val = func.setter(ctx, this_obj, arg_buf[0]);\n        break;\n    case JS_CFUNC_getter_magic:\n        ret_val = func.getter_magic(ctx, this_obj, p->u.cfunc.magic);\n        break;\n    case JS_CFUNC_setter_magic:\n        ret_val = func.setter_magic(ctx, this_obj, arg_buf[0], p->u.cfunc.magic);\n        break;\n    case JS_CFUNC_f_f:\n        {\n            double d1;\n\n            if (unlikely(JS_ToFloat64(ctx, &d1, arg_buf[0]))) {\n                ret_val = JS_EXCEPTION;\n                break;\n            }\n            ret_val = JS_NewFloat64(ctx, func.f_f(d1));\n        }\n        break;\n    case JS_CFUNC_f_f_f:\n        {\n            double d1, d2;\n\n            if (unlikely(JS_ToFloat64(ctx, &d1, arg_buf[0]))) {\n                ret_val = JS_EXCEPTION;\n                break;\n            }\n            if (unlikely(JS_ToFloat64(ctx, &d2, arg_buf[1]))) {\n                ret_val = JS_EXCEPTION;\n                break;\n            }\n            ret_val = JS_NewFloat64(ctx, func.f_f_f(d1, d2));\n        }\n        break;\n    case JS_CFUNC_iterator_next:\n        {\n            int done;\n            ret_val = func.iterator_next(ctx, this_obj, argc, arg_buf,\n                                         &done, p->u.cfunc.magic);\n            if (!JS_IsException(ret_val) && done != 2) {\n                ret_val = js_create_iterator_result(ctx, ret_val, done);\n            }\n        }\n        break;\n    default:\n        abort();\n    }\n\n    rt->current_stack_frame = sf->prev_frame;\n    return ret_val;\n}\n\nstatic JSValue js_call_bound_function(JSContext *ctx, JSValueConst func_obj,\n                                      JSValueConst this_obj,\n                                      int argc, JSValueConst *argv, int flags)\n{\n    JSObject *p;\n    JSBoundFunction *bf;\n    JSValueConst *arg_buf, new_target;\n    int arg_count, i;\n\n    p = JS_VALUE_GET_OBJ(func_obj);\n    bf = p->u.bound_function;\n    arg_count = bf->argc + argc;\n    if (js_check_stack_overflow(ctx->rt, sizeof(JSValue) * arg_count))\n        return JS_ThrowStackOverflow(ctx);\n    arg_buf = alloca(sizeof(JSValue) * arg_count);\n    for(i = 0; i < bf->argc; i++) {\n        arg_buf[i] = bf->argv[i];\n    }\n    for(i = 0; i < argc; i++) {\n        arg_buf[bf->argc + i] = argv[i];\n    }\n    if (flags & JS_CALL_FLAG_CONSTRUCTOR) {\n        new_target = this_obj;\n        if (js_same_value(ctx, func_obj, new_target))\n            new_target = bf->func_obj;\n        return JS_CallConstructor2(ctx, bf->func_obj, new_target,\n                                   arg_count, arg_buf);\n    } else {\n        return JS_Call(ctx, bf->func_obj, bf->this_val,\n                       arg_count, arg_buf);\n    }\n}\n\n/* argument of OP_special_object */\ntypedef enum {\n    OP_SPECIAL_OBJECT_ARGUMENTS,\n    OP_SPECIAL_OBJECT_MAPPED_ARGUMENTS,\n    OP_SPECIAL_OBJECT_THIS_FUNC,\n    OP_SPECIAL_OBJECT_NEW_TARGET,\n    OP_SPECIAL_OBJECT_HOME_OBJECT,\n    OP_SPECIAL_OBJECT_VAR_OBJECT,\n    OP_SPECIAL_OBJECT_IMPORT_META,\n} OPSpecialObjectEnum;\n\n#define FUNC_RET_AWAIT      0\n#define FUNC_RET_YIELD      1\n#define FUNC_RET_YIELD_STAR 2\n\n/* argv[] is modified if (flags & JS_CALL_FLAG_COPY_ARGV) = 0. */\nstatic JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,\n                               JSValueConst this_obj, JSValueConst new_target,\n                               int argc, JSValue *argv, int flags)\n{\n    JSRuntime *rt = caller_ctx->rt;\n    JSContext *ctx;\n    JSObject *p;\n    JSFunctionBytecode *b;\n    JSStackFrame sf_s, *sf = &sf_s;\n    const uint8_t *pc;\n    int opcode, arg_allocated_size, i;\n    JSValue *local_buf, *stack_buf, *var_buf, *arg_buf, *sp, ret_val, *pval;\n    JSVarRef **var_refs;\n    size_t alloca_size;\n\n#if !DIRECT_DISPATCH\n#define SWITCH(pc)      switch (opcode = *pc++)\n#ifdef CONFIG_DEBUGGER\n#define CASE(op)        case op: if (caller_ctx->rt->debugger_info.transport_close) js_debugger_check(ctx, pc); stub_ ## op\n#else\n#define CASE(op)        case op: stub_ ## op\n#endif\n#define DEFAULT         default\n#define BREAK           break\n#else\n    static const void * const dispatch_table[256] = {\n#define DEF(id, size, n_pop, n_push, f) && case_OP_ ## id,\n#if SHORT_OPCODES\n#define def(id, size, n_pop, n_push, f)\n#else                                                     \n#define def(id, size, n_pop, n_push, f) && case_default,\n#endif\n#include \"quickjs-opcode.h\"\n        [ OP_COUNT ... 255 ] = &&case_default\n    };\n    static const void * const debugger_dispatch_table[256] = {\n#define DEF(id, size, n_pop, n_push, f) && case_debugger_OP_ ## id,\n#if SHORT_OPCODES\n#define def(id, size, n_pop, n_push, f)\n#else\n#define def(id, size, n_pop, n_push, f) && case_default,\n#endif\n#include \"quickjs-opcode.h\"\n        [ OP_COUNT ... 255 ] = &&case_default\n    };\n#define SWITCH(pc)      goto *active_dispatch_table[opcode = *pc++];\n#ifdef CONFIG_DEBUGGER\n#define CASE(op)        case_debugger_ ## op: if(!ctx->rt->debugger_info.is_debugging) js_debugger_check(ctx, pc); case_ ## op\n#else\n#define CASE(op)        case_debugger_ ## op: case_ ## op\n#endif\n#define DEFAULT         case_default\n#define BREAK           SWITCH(pc)\n\n    const void * const * active_dispatch_table = caller_ctx->rt->debugger_info.transport_close\n        ? debugger_dispatch_table : dispatch_table;\n#endif\n\n    if (js_poll_interrupts(caller_ctx))\n        return JS_EXCEPTION;\n    if (unlikely(JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)) {\n        if (flags & JS_CALL_FLAG_GENERATOR) {\n            JSAsyncFunctionState *s = JS_VALUE_GET_PTR(func_obj);\n            /* func_obj get contains a pointer to JSFuncAsyncState */\n            /* the stack frame is already allocated */\n            sf = &s->frame;\n            p = JS_VALUE_GET_OBJ(sf->cur_func);\n            b = p->u.func.function_bytecode;\n            ctx = b->realm;\n            var_refs = p->u.func.var_refs;\n            local_buf = arg_buf = sf->arg_buf;\n            var_buf = sf->var_buf;\n            stack_buf = sf->var_buf + b->var_count;\n            sp = sf->cur_sp;\n            sf->cur_sp = NULL; /* cur_sp is NULL if the function is running */\n            pc = sf->cur_pc;\n            sf->prev_frame = rt->current_stack_frame;\n            rt->current_stack_frame = sf;\n            if (s->throw_flag)\n                goto exception;\n            else\n                goto restart;\n        } else {\n            goto not_a_function;\n        }\n    }\n    p = JS_VALUE_GET_OBJ(func_obj);\n    if (unlikely(p->class_id != JS_CLASS_BYTECODE_FUNCTION)) {\n        JSClassCall *call_func;\n        call_func = rt->class_array[p->class_id].call;\n        if (!call_func) {\n        not_a_function:\n            return JS_ThrowTypeError(caller_ctx, \"not a function\");\n        }\n        return call_func(caller_ctx, func_obj, this_obj, argc,\n                         (JSValueConst *)argv, flags);\n    }\n    b = p->u.func.function_bytecode;\n\n    if (unlikely(argc < b->arg_count || (flags & JS_CALL_FLAG_COPY_ARGV))) {\n        arg_allocated_size = b->arg_count;\n    } else {\n        arg_allocated_size = 0;\n    }\n\n    alloca_size = sizeof(JSValue) * (arg_allocated_size + b->var_count +\n                                     b->stack_size);\n    if (js_check_stack_overflow(rt, alloca_size))\n        return JS_ThrowStackOverflow(caller_ctx);\n\n    sf->js_mode = b->js_mode;\n    arg_buf = argv;\n    sf->arg_count = argc;\n    sf->cur_func = (JSValue)func_obj;\n    init_list_head(&sf->var_ref_list);\n    var_refs = p->u.func.var_refs;\n\n    local_buf = alloca(alloca_size);\n    if (unlikely(arg_allocated_size)) {\n        int n = min_int(argc, b->arg_count);\n        arg_buf = local_buf;\n        for(i = 0; i < n; i++)\n            arg_buf[i] = JS_DupValue(caller_ctx, argv[i]);\n        for(; i < b->arg_count; i++)\n            arg_buf[i] = JS_UNDEFINED;\n        sf->arg_count = b->arg_count;\n    }\n    var_buf = local_buf + arg_allocated_size;\n    sf->var_buf = var_buf;\n    sf->arg_buf = arg_buf;\n\n    for(i = 0; i < b->var_count; i++)\n        var_buf[i] = JS_UNDEFINED;\n\n    stack_buf = var_buf + b->var_count;\n    sp = stack_buf;\n    pc = b->byte_code_buf;\n    sf->prev_frame = rt->current_stack_frame;\n    rt->current_stack_frame = sf;\n    ctx = b->realm; /* set the current realm */\n    \n restart:\n    for(;;) {\n        int call_argc;\n        JSValue *call_argv;\n\n#ifdef CONFIG_DEBUGGER\n        if(ctx->rt->debugger_info.is_debugging)\n            js_debugger_check(ctx, NULL);\n#endif\n\n        SWITCH(pc) {\n        CASE(OP_push_i32):\n            *sp++ = JS_NewInt32(ctx, get_u32(pc));\n            pc += 4;\n            BREAK;\n        CASE(OP_push_const):\n            *sp++ = JS_DupValue(ctx, b->cpool[get_u32(pc)]);\n            pc += 4;\n            BREAK;\n#if SHORT_OPCODES\n        CASE(OP_push_minus1):\n        CASE(OP_push_0):\n        CASE(OP_push_1):\n        CASE(OP_push_2):\n        CASE(OP_push_3):\n        CASE(OP_push_4):\n        CASE(OP_push_5):\n        CASE(OP_push_6):\n        CASE(OP_push_7):\n            *sp++ = JS_NewInt32(ctx, opcode - OP_push_0);\n            BREAK;\n        CASE(OP_push_i8):\n            *sp++ = JS_NewInt32(ctx, get_i8(pc));\n            pc += 1;\n            BREAK;\n        CASE(OP_push_i16):\n            *sp++ = JS_NewInt32(ctx, get_i16(pc));\n            pc += 2;\n            BREAK;\n        CASE(OP_push_const8):\n            *sp++ = JS_DupValue(ctx, b->cpool[*pc++]);\n            BREAK;\n        CASE(OP_fclosure8):\n            *sp++ = js_closure(ctx, JS_DupValue(ctx, b->cpool[*pc++]), var_refs, sf);\n            if (unlikely(JS_IsException(sp[-1])))\n                goto exception;\n            BREAK;\n        CASE(OP_push_empty_string):\n            *sp++ = JS_AtomToString(ctx, JS_ATOM_empty_string);\n            BREAK;\n        CASE(OP_get_length):\n            {\n                JSValue val;\n\n                val = JS_GetProperty(ctx, sp[-1], JS_ATOM_length);\n                if (unlikely(JS_IsException(val)))\n                    goto exception;\n                JS_FreeValue(ctx, sp[-1]);\n                sp[-1] = val;\n            }\n            BREAK;\n#endif\n        CASE(OP_push_atom_value):\n            *sp++ = JS_AtomToValue(ctx, get_u32(pc));\n            pc += 4;\n            BREAK;\n        CASE(OP_undefined):\n            *sp++ = JS_UNDEFINED;\n            BREAK;\n        CASE(OP_null):\n            *sp++ = JS_NULL;\n            BREAK;\n        CASE(OP_push_this):\n            /* OP_push_this is only called at the start of a function */\n            {\n                JSValue val;\n                if (!(b->js_mode & JS_MODE_STRICT)) {\n                    uint32_t tag = JS_VALUE_GET_TAG(this_obj);\n                    if (likely(tag == JS_TAG_OBJECT))\n                        goto normal_this;\n                    if (tag == JS_TAG_NULL || tag == JS_TAG_UNDEFINED) {\n                        val = JS_DupValue(ctx, ctx->global_obj);\n                    } else {\n                        val = JS_ToObject(ctx, this_obj);\n                        if (JS_IsException(val))\n                            goto exception;\n                    }\n                } else {\n                normal_this:\n                    val = JS_DupValue(ctx, this_obj);\n                }\n                *sp++ = val;\n            }\n            BREAK;\n        CASE(OP_push_false):\n            *sp++ = JS_FALSE;\n            BREAK;\n        CASE(OP_push_true):\n            *sp++ = JS_TRUE;\n            BREAK;\n        CASE(OP_object):\n            *sp++ = JS_NewObject(ctx);\n            if (unlikely(JS_IsException(sp[-1])))\n                goto exception;\n            BREAK;\n        CASE(OP_special_object):\n            {\n                int arg = *pc++;\n                switch(arg) {\n                case OP_SPECIAL_OBJECT_ARGUMENTS:\n                    *sp++ = js_build_arguments(ctx, argc, (JSValueConst *)argv);\n                    if (unlikely(JS_IsException(sp[-1])))\n                        goto exception;\n                    break;\n                case OP_SPECIAL_OBJECT_MAPPED_ARGUMENTS:\n                    *sp++ = js_build_mapped_arguments(ctx, argc, (JSValueConst *)argv,\n                                                      sf, min_int(argc, b->arg_count));\n                    if (unlikely(JS_IsException(sp[-1])))\n                        goto exception;\n                    break;\n                case OP_SPECIAL_OBJECT_THIS_FUNC:\n                    *sp++ = JS_DupValue(ctx, sf->cur_func);\n                    break;\n                case OP_SPECIAL_OBJECT_NEW_TARGET:\n                    *sp++ = JS_DupValue(ctx, new_target);\n                    break;\n                case OP_SPECIAL_OBJECT_HOME_OBJECT:\n                    {\n                        JSObject *p1;\n                        p1 = p->u.func.home_object;\n                        if (unlikely(!p1))\n                            *sp++ = JS_UNDEFINED;\n                        else\n                            *sp++ = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p1));\n                    }\n                    break;\n                case OP_SPECIAL_OBJECT_VAR_OBJECT:\n                    *sp++ = JS_NewObjectProto(ctx, JS_NULL);\n                    if (unlikely(JS_IsException(sp[-1])))\n                        goto exception;\n                    break;\n                case OP_SPECIAL_OBJECT_IMPORT_META:\n                    *sp++ = js_import_meta(ctx);\n                    if (unlikely(JS_IsException(sp[-1])))\n                        goto exception;\n                    break;\n                default:\n                    abort();\n                }\n            }\n            BREAK;\n        CASE(OP_rest):\n            {\n                int first = get_u16(pc);\n                pc += 2;\n                *sp++ = js_build_rest(ctx, first, argc, (JSValueConst *)argv);\n                if (unlikely(JS_IsException(sp[-1])))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_drop):\n            JS_FreeValue(ctx, sp[-1]);\n            sp--;\n            BREAK;\n        CASE(OP_nip):\n            JS_FreeValue(ctx, sp[-2]);\n            sp[-2] = sp[-1];\n            sp--;\n            BREAK;\n        CASE(OP_nip1): /* a b c -> b c */\n            JS_FreeValue(ctx, sp[-3]);\n            sp[-3] = sp[-2];\n            sp[-2] = sp[-1];\n            sp--;\n            BREAK;\n        CASE(OP_dup):\n            sp[0] = JS_DupValue(ctx, sp[-1]);\n            sp++;\n            BREAK;\n        CASE(OP_dup2): /* a b -> a b a b */\n            sp[0] = JS_DupValue(ctx, sp[-2]);\n            sp[1] = JS_DupValue(ctx, sp[-1]);\n            sp += 2;\n            BREAK;\n        CASE(OP_dup3): /* a b c -> a b c a b c */\n            sp[0] = JS_DupValue(ctx, sp[-3]);\n            sp[1] = JS_DupValue(ctx, sp[-2]);\n            sp[2] = JS_DupValue(ctx, sp[-1]);\n            sp += 3;\n            BREAK;\n        CASE(OP_dup1): /* a b -> a a b */\n            sp[0] = sp[-1];\n            sp[-1] = JS_DupValue(ctx, sp[-2]);\n            sp++;\n            BREAK;\n        CASE(OP_insert2): /* obj a -> a obj a (dup_x1) */\n            sp[0] = sp[-1];\n            sp[-1] = sp[-2];\n            sp[-2] = JS_DupValue(ctx, sp[0]);\n            sp++;\n            BREAK;\n        CASE(OP_insert3): /* obj prop a -> a obj prop a (dup_x2) */\n            sp[0] = sp[-1];\n            sp[-1] = sp[-2];\n            sp[-2] = sp[-3];\n            sp[-3] = JS_DupValue(ctx, sp[0]);\n            sp++;\n            BREAK;\n        CASE(OP_insert4): /* this obj prop a -> a this obj prop a */\n            sp[0] = sp[-1];\n            sp[-1] = sp[-2];\n            sp[-2] = sp[-3];\n            sp[-3] = sp[-4];\n            sp[-4] = JS_DupValue(ctx, sp[0]);\n            sp++;\n            BREAK;\n        CASE(OP_perm3): /* obj a b -> a obj b (213) */\n            {\n                JSValue tmp;\n                tmp = sp[-2];\n                sp[-2] = sp[-3];\n                sp[-3] = tmp;\n            }\n            BREAK;\n        CASE(OP_rot3l): /* x a b -> a b x (231) */\n            {\n                JSValue tmp;\n                tmp = sp[-3];\n                sp[-3] = sp[-2];\n                sp[-2] = sp[-1];\n                sp[-1] = tmp;\n            }\n            BREAK;\n        CASE(OP_rot4l): /* x a b c -> a b c x */\n            {\n                JSValue tmp;\n                tmp = sp[-4];\n                sp[-4] = sp[-3];\n                sp[-3] = sp[-2];\n                sp[-2] = sp[-1];\n                sp[-1] = tmp;\n            }\n            BREAK;\n        CASE(OP_rot5l): /* x a b c d -> a b c d x */\n            {\n                JSValue tmp;\n                tmp = sp[-5];\n                sp[-5] = sp[-4];\n                sp[-4] = sp[-3];\n                sp[-3] = sp[-2];\n                sp[-2] = sp[-1];\n                sp[-1] = tmp;\n            }\n            BREAK;\n        CASE(OP_rot3r): /* a b x -> x a b (312) */\n            {\n                JSValue tmp;\n                tmp = sp[-1];\n                sp[-1] = sp[-2];\n                sp[-2] = sp[-3];\n                sp[-3] = tmp;\n            }\n            BREAK;\n        CASE(OP_perm4): /* obj prop a b -> a obj prop b */\n            {\n                JSValue tmp;\n                tmp = sp[-2];\n                sp[-2] = sp[-3];\n                sp[-3] = sp[-4];\n                sp[-4] = tmp;\n            }\n            BREAK;\n        CASE(OP_perm5): /* this obj prop a b -> a this obj prop b */\n            {\n                JSValue tmp;\n                tmp = sp[-2];\n                sp[-2] = sp[-3];\n                sp[-3] = sp[-4];\n                sp[-4] = sp[-5];\n                sp[-5] = tmp;\n            }\n            BREAK;\n        CASE(OP_swap): /* a b -> b a */\n            {\n                JSValue tmp;\n                tmp = sp[-2];\n                sp[-2] = sp[-1];\n                sp[-1] = tmp;\n            }\n            BREAK;\n        CASE(OP_swap2): /* a b c d -> c d a b */\n            {\n                JSValue tmp1, tmp2;\n                tmp1 = sp[-4];\n                tmp2 = sp[-3];\n                sp[-4] = sp[-2];\n                sp[-3] = sp[-1];\n                sp[-2] = tmp1;\n                sp[-1] = tmp2;\n            }\n            BREAK;\n\n        CASE(OP_fclosure):\n            {\n                JSValue bfunc = JS_DupValue(ctx, b->cpool[get_u32(pc)]);\n                pc += 4;\n                *sp++ = js_closure(ctx, bfunc, var_refs, sf);\n                if (unlikely(JS_IsException(sp[-1])))\n                    goto exception;\n            }\n            BREAK;\n#if SHORT_OPCODES\n        CASE(OP_call0):\n        CASE(OP_call1):\n        CASE(OP_call2):\n        CASE(OP_call3):\n            call_argc = opcode - OP_call0;\n            goto has_call_argc;\n#endif\n        CASE(OP_call):\n        CASE(OP_tail_call):\n            {\n                call_argc = get_u16(pc);\n                pc += 2;\n                goto has_call_argc;\n            has_call_argc:\n                call_argv = sp - call_argc;\n                sf->cur_pc = pc;\n                ret_val = JS_CallInternal(ctx, call_argv[-1], JS_UNDEFINED,\n                                          JS_UNDEFINED, call_argc, call_argv, 0);\n                if (unlikely(JS_IsException(ret_val)))\n                    goto exception;\n                if (opcode == OP_tail_call)\n                    goto done;\n                for(i = -1; i < call_argc; i++)\n                    JS_FreeValue(ctx, call_argv[i]);\n                sp -= call_argc + 1;\n                *sp++ = ret_val;\n            }\n            BREAK;\n        CASE(OP_call_constructor):\n            {\n                call_argc = get_u16(pc);\n                pc += 2;\n                call_argv = sp - call_argc;\n                sf->cur_pc = pc;\n                ret_val = JS_CallConstructorInternal(ctx, call_argv[-2],\n                                                     call_argv[-1],\n                                                     call_argc, call_argv, 0);\n                if (unlikely(JS_IsException(ret_val)))\n                    goto exception;\n                for(i = -2; i < call_argc; i++)\n                    JS_FreeValue(ctx, call_argv[i]);\n                sp -= call_argc + 2;\n                *sp++ = ret_val;\n            }\n            BREAK;\n        CASE(OP_call_method):\n        CASE(OP_tail_call_method):\n            {\n                call_argc = get_u16(pc);\n                pc += 2;\n                call_argv = sp - call_argc;\n                sf->cur_pc = pc;\n                ret_val = JS_CallInternal(ctx, call_argv[-1], call_argv[-2],\n                                          JS_UNDEFINED, call_argc, call_argv, 0);\n                if (unlikely(JS_IsException(ret_val)))\n                    goto exception;\n                if (opcode == OP_tail_call_method)\n                    goto done;\n                for(i = -2; i < call_argc; i++)\n                    JS_FreeValue(ctx, call_argv[i]);\n                sp -= call_argc + 2;\n                *sp++ = ret_val;\n            }\n            BREAK;\n        CASE(OP_array_from):\n            {\n                int i, ret;\n\n                call_argc = get_u16(pc);\n                pc += 2;\n                ret_val = JS_NewArray(ctx);\n                if (unlikely(JS_IsException(ret_val)))\n                    goto exception;\n                call_argv = sp - call_argc;\n                for(i = 0; i < call_argc; i++) {\n                    ret = JS_DefinePropertyValue(ctx, ret_val, __JS_AtomFromUInt32(i), call_argv[i],\n                                                 JS_PROP_C_W_E | JS_PROP_THROW);\n                    call_argv[i] = JS_UNDEFINED;\n                    if (ret < 0) {\n                        JS_FreeValue(ctx, ret_val);\n                        goto exception;\n                    }\n                }\n                sp -= call_argc;\n                *sp++ = ret_val;\n            }\n            BREAK;\n\n        CASE(OP_apply):\n            {\n                int magic;\n                magic = get_u16(pc);\n                pc += 2;\n\n                ret_val = js_function_apply(ctx, sp[-3], 2, (JSValueConst *)&sp[-2], magic);\n                if (unlikely(JS_IsException(ret_val)))\n                    goto exception;\n                JS_FreeValue(ctx, sp[-3]);\n                JS_FreeValue(ctx, sp[-2]);\n                JS_FreeValue(ctx, sp[-1]);\n                sp -= 3;\n                *sp++ = ret_val;\n            }\n            BREAK;\n        CASE(OP_return):\n            ret_val = *--sp;\n            goto done;\n        CASE(OP_return_undef):\n            ret_val = JS_UNDEFINED;\n            goto done;\n\n        CASE(OP_check_ctor_return):\n            /* return TRUE if 'this' should be returned */\n            if (!JS_IsObject(sp[-1])) {\n                if (!JS_IsUndefined(sp[-1])) {\n                    JS_ThrowTypeError(caller_ctx, \"derived class constructor must return an object or undefined\");\n                    goto exception;\n                }\n                sp[0] = JS_TRUE;\n            } else {\n                sp[0] = JS_FALSE;\n            }\n            sp++;\n            BREAK;\n        CASE(OP_check_ctor):\n            if (JS_IsUndefined(new_target)) {\n                JS_ThrowTypeError(ctx, \"class constructors must be invoked with 'new'\");\n                goto exception;\n            }\n            BREAK;\n        CASE(OP_check_brand):\n            if (JS_CheckBrand(ctx, sp[-2], sp[-1]) < 0)\n                goto exception;\n            BREAK;\n        CASE(OP_add_brand):\n            if (JS_AddBrand(ctx, sp[-2], sp[-1]) < 0)\n                goto exception;\n            JS_FreeValue(ctx, sp[-2]);\n            JS_FreeValue(ctx, sp[-1]);\n            sp -= 2;\n            BREAK;\n            \n        CASE(OP_throw):\n            JS_Throw(ctx, *--sp);\n            goto exception;\n\n        CASE(OP_throw_error):\n#define JS_THROW_VAR_RO             0\n#define JS_THROW_VAR_REDECL         1\n#define JS_THROW_VAR_UNINITIALIZED  2\n#define JS_THROW_ERROR_DELETE_SUPER   3\n#define JS_THROW_ERROR_ITERATOR_THROW 4\n            {\n                JSAtom atom;\n                int type;\n                atom = get_u32(pc);\n                type = pc[4];\n                pc += 5;\n                if (type == JS_THROW_VAR_RO)\n                    JS_ThrowTypeErrorReadOnly(ctx, JS_PROP_THROW, atom);\n                else\n                if (type == JS_THROW_VAR_REDECL)\n                    JS_ThrowSyntaxErrorVarRedeclaration(ctx, atom);\n                else\n                if (type == JS_THROW_VAR_UNINITIALIZED)\n                    JS_ThrowReferenceErrorUninitialized(ctx, atom);\n                else\n                if (type == JS_THROW_ERROR_DELETE_SUPER)\n                    JS_ThrowReferenceError(ctx, \"unsupported reference to 'super'\");\n                else\n                if (type == JS_THROW_ERROR_ITERATOR_THROW)\n                    JS_ThrowTypeError(ctx, \"iterator does not have a throw method\");\n                else\n                    JS_ThrowInternalError(ctx, \"invalid throw var type %d\", type);\n            }\n            goto exception;\n\n        CASE(OP_eval):\n            {\n                JSValueConst obj;\n                int scope_idx;\n                call_argc = get_u16(pc);\n                scope_idx = get_u16(pc + 2) - 1;\n                pc += 4;\n                call_argv = sp - call_argc;\n                sf->cur_pc = pc;\n                if (js_same_value(ctx, call_argv[-1], ctx->eval_obj)) {\n                    if (call_argc >= 1)\n                        obj = call_argv[0];\n                    else\n                        obj = JS_UNDEFINED;\n                    ret_val = JS_EvalObject(ctx, JS_UNDEFINED, obj,\n                                            JS_EVAL_TYPE_DIRECT, scope_idx);\n                } else {\n                    ret_val = JS_CallInternal(ctx, call_argv[-1], JS_UNDEFINED,\n                                              JS_UNDEFINED, call_argc, call_argv, 0);\n                }\n                if (unlikely(JS_IsException(ret_val)))\n                    goto exception;\n                for(i = -1; i < call_argc; i++)\n                    JS_FreeValue(ctx, call_argv[i]);\n                sp -= call_argc + 1;\n                *sp++ = ret_val;\n            }\n            BREAK;\n            /* could merge with OP_apply */\n        CASE(OP_apply_eval):\n            {\n                int scope_idx;\n                uint32_t len;\n                JSValue *tab;\n                JSValueConst obj;\n\n                scope_idx = get_u16(pc) - 1;\n                pc += 2;\n                tab = build_arg_list(ctx, &len, sp[-1]);\n                if (!tab)\n                    goto exception;\n                if (js_same_value(ctx, sp[-2], ctx->eval_obj)) {\n                    if (len >= 1)\n                        obj = tab[0];\n                    else\n                        obj = JS_UNDEFINED;\n                    ret_val = JS_EvalObject(ctx, JS_UNDEFINED, obj,\n                                            JS_EVAL_TYPE_DIRECT, scope_idx);\n                } else {\n                    ret_val = JS_Call(ctx, sp[-2], JS_UNDEFINED, len,\n                                      (JSValueConst *)tab);\n                }\n                free_arg_list(ctx, tab, len);\n                if (unlikely(JS_IsException(ret_val)))\n                    goto exception;\n                JS_FreeValue(ctx, sp[-2]);\n                JS_FreeValue(ctx, sp[-1]);\n                sp -= 2;\n                *sp++ = ret_val;\n            }\n            BREAK;\n\n        CASE(OP_regexp):\n            {\n                sp[-2] = js_regexp_constructor_internal(ctx, JS_UNDEFINED,\n                                                        sp[-2], sp[-1]);\n                sp--;\n            }\n            BREAK;\n\n        CASE(OP_get_super):\n            {\n                JSValue proto;\n                proto = JS_GetPrototype(ctx, sp[-1]);\n                if (JS_IsException(proto))\n                    goto exception;\n                JS_FreeValue(ctx, sp[-1]);\n                sp[-1] = proto;\n            }\n            BREAK;\n\n        CASE(OP_import):\n            {\n                JSValue val;\n                val = js_dynamic_import(ctx, sp[-1]);\n                if (JS_IsException(val))\n                    goto exception;\n                JS_FreeValue(ctx, sp[-1]);\n                sp[-1] = val;\n            }\n            BREAK;\n\n        CASE(OP_check_var):\n            {\n                int ret;\n                JSAtom atom;\n                atom = get_u32(pc);\n                pc += 4;\n\n                ret = JS_CheckGlobalVar(ctx, atom);\n                if (ret < 0)\n                    goto exception;\n                *sp++ = JS_NewBool(ctx, ret);\n            }\n            BREAK;\n\n        CASE(OP_get_var_undef):\n        CASE(OP_get_var):\n            {\n                JSValue val;\n                JSAtom atom;\n                atom = get_u32(pc);\n                pc += 4;\n\n                val = JS_GetGlobalVar(ctx, atom, opcode - OP_get_var_undef);\n                if (unlikely(JS_IsException(val)))\n                    goto exception;\n                *sp++ = val;\n            }\n            BREAK;\n\n        CASE(OP_put_var):\n        CASE(OP_put_var_init):\n            {\n                int ret;\n                JSAtom atom;\n                atom = get_u32(pc);\n                pc += 4;\n\n                ret = JS_SetGlobalVar(ctx, atom, sp[-1], opcode - OP_put_var);\n                sp--;\n                if (unlikely(ret < 0))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_put_var_strict):\n            {\n                int ret;\n                JSAtom atom;\n                atom = get_u32(pc);\n                pc += 4;\n\n                /* sp[-2] is JS_TRUE or JS_FALSE */\n                if (unlikely(!JS_VALUE_GET_INT(sp[-2]))) {\n                    JS_ThrowReferenceErrorNotDefined(ctx, atom);\n                    goto exception;\n                }\n                ret = JS_SetGlobalVar(ctx, atom, sp[-1], 2);\n                sp -= 2;\n                if (unlikely(ret < 0))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_check_define_var):\n            {\n                JSAtom atom;\n                int flags;\n                atom = get_u32(pc);\n                flags = pc[4];\n                pc += 5;\n                if (JS_CheckDefineGlobalVar(ctx, atom, flags))\n                    goto exception;\n            }\n            BREAK;\n        CASE(OP_define_var):\n            {\n                JSAtom atom;\n                int flags;\n                atom = get_u32(pc);\n                flags = pc[4];\n                pc += 5;\n                if (JS_DefineGlobalVar(ctx, atom, flags))\n                    goto exception;\n            }\n            BREAK;\n        CASE(OP_define_func):\n            {\n                JSAtom atom;\n                int flags;\n                atom = get_u32(pc);\n                flags = pc[4];\n                pc += 5;\n                if (JS_DefineGlobalFunction(ctx, atom, sp[-1], flags))\n                    goto exception;\n                JS_FreeValue(ctx, sp[-1]);\n                sp--;\n            }\n            BREAK;\n\n        CASE(OP_get_loc):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                sp[0] = JS_DupValue(ctx, var_buf[idx]);\n                sp++;\n            }\n            BREAK;\n        CASE(OP_put_loc):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                set_value(ctx, &var_buf[idx], sp[-1]);\n                sp--;\n            }\n            BREAK;\n        CASE(OP_set_loc):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                set_value(ctx, &var_buf[idx], JS_DupValue(ctx, sp[-1]));\n            }\n            BREAK;\n        CASE(OP_get_arg):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                sp[0] = JS_DupValue(ctx, arg_buf[idx]);\n                sp++;\n            }\n            BREAK;\n        CASE(OP_put_arg):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                set_value(ctx, &arg_buf[idx], sp[-1]);\n                sp--;\n            }\n            BREAK;\n        CASE(OP_set_arg):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                set_value(ctx, &arg_buf[idx], JS_DupValue(ctx, sp[-1]));\n            }\n            BREAK;\n\n#if SHORT_OPCODES\n        CASE(OP_get_loc8): *sp++ = JS_DupValue(ctx, var_buf[*pc++]); BREAK;\n        CASE(OP_put_loc8): set_value(ctx, &var_buf[*pc++], *--sp); BREAK;\n        CASE(OP_set_loc8): set_value(ctx, &var_buf[*pc++], JS_DupValue(ctx, sp[-1])); BREAK;\n\n        CASE(OP_get_loc0): *sp++ = JS_DupValue(ctx, var_buf[0]); BREAK;\n        CASE(OP_get_loc1): *sp++ = JS_DupValue(ctx, var_buf[1]); BREAK;\n        CASE(OP_get_loc2): *sp++ = JS_DupValue(ctx, var_buf[2]); BREAK;\n        CASE(OP_get_loc3): *sp++ = JS_DupValue(ctx, var_buf[3]); BREAK;\n        CASE(OP_put_loc0): set_value(ctx, &var_buf[0], *--sp); BREAK;\n        CASE(OP_put_loc1): set_value(ctx, &var_buf[1], *--sp); BREAK;\n        CASE(OP_put_loc2): set_value(ctx, &var_buf[2], *--sp); BREAK;\n        CASE(OP_put_loc3): set_value(ctx, &var_buf[3], *--sp); BREAK;\n        CASE(OP_set_loc0): set_value(ctx, &var_buf[0], JS_DupValue(ctx, sp[-1])); BREAK;\n        CASE(OP_set_loc1): set_value(ctx, &var_buf[1], JS_DupValue(ctx, sp[-1])); BREAK;\n        CASE(OP_set_loc2): set_value(ctx, &var_buf[2], JS_DupValue(ctx, sp[-1])); BREAK;\n        CASE(OP_set_loc3): set_value(ctx, &var_buf[3], JS_DupValue(ctx, sp[-1])); BREAK;\n        CASE(OP_get_arg0): *sp++ = JS_DupValue(ctx, arg_buf[0]); BREAK;\n        CASE(OP_get_arg1): *sp++ = JS_DupValue(ctx, arg_buf[1]); BREAK;\n        CASE(OP_get_arg2): *sp++ = JS_DupValue(ctx, arg_buf[2]); BREAK;\n        CASE(OP_get_arg3): *sp++ = JS_DupValue(ctx, arg_buf[3]); BREAK;\n        CASE(OP_put_arg0): set_value(ctx, &arg_buf[0], *--sp); BREAK;\n        CASE(OP_put_arg1): set_value(ctx, &arg_buf[1], *--sp); BREAK;\n        CASE(OP_put_arg2): set_value(ctx, &arg_buf[2], *--sp); BREAK;\n        CASE(OP_put_arg3): set_value(ctx, &arg_buf[3], *--sp); BREAK;\n        CASE(OP_set_arg0): set_value(ctx, &arg_buf[0], JS_DupValue(ctx, sp[-1])); BREAK;\n        CASE(OP_set_arg1): set_value(ctx, &arg_buf[1], JS_DupValue(ctx, sp[-1])); BREAK;\n        CASE(OP_set_arg2): set_value(ctx, &arg_buf[2], JS_DupValue(ctx, sp[-1])); BREAK;\n        CASE(OP_set_arg3): set_value(ctx, &arg_buf[3], JS_DupValue(ctx, sp[-1])); BREAK;\n        CASE(OP_get_var_ref0): *sp++ = JS_DupValue(ctx, *var_refs[0]->pvalue); BREAK;\n        CASE(OP_get_var_ref1): *sp++ = JS_DupValue(ctx, *var_refs[1]->pvalue); BREAK;\n        CASE(OP_get_var_ref2): *sp++ = JS_DupValue(ctx, *var_refs[2]->pvalue); BREAK;\n        CASE(OP_get_var_ref3): *sp++ = JS_DupValue(ctx, *var_refs[3]->pvalue); BREAK;\n        CASE(OP_put_var_ref0): set_value(ctx, var_refs[0]->pvalue, *--sp); BREAK;\n        CASE(OP_put_var_ref1): set_value(ctx, var_refs[1]->pvalue, *--sp); BREAK;\n        CASE(OP_put_var_ref2): set_value(ctx, var_refs[2]->pvalue, *--sp); BREAK;\n        CASE(OP_put_var_ref3): set_value(ctx, var_refs[3]->pvalue, *--sp); BREAK;\n        CASE(OP_set_var_ref0): set_value(ctx, var_refs[0]->pvalue, JS_DupValue(ctx, sp[-1])); BREAK;\n        CASE(OP_set_var_ref1): set_value(ctx, var_refs[1]->pvalue, JS_DupValue(ctx, sp[-1])); BREAK;\n        CASE(OP_set_var_ref2): set_value(ctx, var_refs[2]->pvalue, JS_DupValue(ctx, sp[-1])); BREAK;\n        CASE(OP_set_var_ref3): set_value(ctx, var_refs[3]->pvalue, JS_DupValue(ctx, sp[-1])); BREAK;\n#endif\n\n        CASE(OP_get_var_ref):\n            {\n                int idx;\n                JSValue val;\n                idx = get_u16(pc);\n                pc += 2;\n                val = *var_refs[idx]->pvalue;\n                sp[0] = JS_DupValue(ctx, val);\n                sp++;\n            }\n            BREAK;\n        CASE(OP_put_var_ref):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                set_value(ctx, var_refs[idx]->pvalue, sp[-1]);\n                sp--;\n            }\n            BREAK;\n        CASE(OP_set_var_ref):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                set_value(ctx, var_refs[idx]->pvalue, JS_DupValue(ctx, sp[-1]));\n            }\n            BREAK;\n        CASE(OP_get_var_ref_check):\n            {\n                int idx;\n                JSValue val;\n                idx = get_u16(pc);\n                pc += 2;\n                val = *var_refs[idx]->pvalue;\n                if (unlikely(JS_IsUninitialized(val))) {\n                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, TRUE);\n                    goto exception;\n                }\n                sp[0] = JS_DupValue(ctx, val);\n                sp++;\n            }\n            BREAK;\n        CASE(OP_put_var_ref_check):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                if (unlikely(JS_IsUninitialized(*var_refs[idx]->pvalue))) {\n                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, TRUE);\n                    goto exception;\n                }\n                set_value(ctx, var_refs[idx]->pvalue, sp[-1]);\n                sp--;\n            }\n            BREAK;\n        CASE(OP_put_var_ref_check_init):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                if (unlikely(!JS_IsUninitialized(*var_refs[idx]->pvalue))) {\n                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, TRUE);\n                    goto exception;\n                }\n                set_value(ctx, var_refs[idx]->pvalue, sp[-1]);\n                sp--;\n            }\n            BREAK;\n        CASE(OP_set_loc_uninitialized):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                set_value(ctx, &var_buf[idx], JS_UNINITIALIZED);\n            }\n            BREAK;\n        CASE(OP_get_loc_check):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                if (unlikely(JS_IsUninitialized(var_buf[idx]))) {\n                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, FALSE);\n                    goto exception;\n                }\n                sp[0] = JS_DupValue(ctx, var_buf[idx]);\n                sp++;\n            }\n            BREAK;\n        CASE(OP_put_loc_check):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                if (unlikely(JS_IsUninitialized(var_buf[idx]))) {\n                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, FALSE);\n                    goto exception;\n                }\n                set_value(ctx, &var_buf[idx], sp[-1]);\n                sp--;\n            }\n            BREAK;\n        CASE(OP_put_loc_check_init):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                if (unlikely(!JS_IsUninitialized(var_buf[idx]))) {\n                    JS_ThrowReferenceError(ctx, \"'this' can be initialized only once\");\n                    goto exception;\n                }\n                set_value(ctx, &var_buf[idx], sp[-1]);\n                sp--;\n            }\n            BREAK;\n        CASE(OP_close_loc):\n            {\n                int idx;\n                idx = get_u16(pc);\n                pc += 2;\n                close_lexical_var(ctx, sf, idx, FALSE);\n            }\n            BREAK;\n\n        CASE(OP_make_loc_ref):\n        CASE(OP_make_arg_ref):\n        CASE(OP_make_var_ref_ref):\n            {\n                JSVarRef *var_ref;\n                JSProperty *pr;\n                JSAtom atom;\n                int idx;\n                atom = get_u32(pc);\n                idx = get_u16(pc + 4);\n                pc += 6;\n                *sp++ = JS_NewObjectProto(ctx, JS_NULL);\n                if (unlikely(JS_IsException(sp[-1])))\n                    goto exception;\n                if (opcode == OP_make_var_ref_ref) {\n                    var_ref = var_refs[idx];\n                    var_ref->header.ref_count++;\n                } else {\n                    var_ref = get_var_ref(ctx, sf, idx, opcode == OP_make_arg_ref);\n                    if (!var_ref)\n                        goto exception;\n                }\n                pr = add_property(ctx, JS_VALUE_GET_OBJ(sp[-1]), atom,\n                                  JS_PROP_WRITABLE | JS_PROP_VARREF);\n                if (!pr) {\n                    free_var_ref(rt, var_ref);\n                    goto exception;\n                }\n                pr->u.var_ref = var_ref;\n                *sp++ = JS_AtomToValue(ctx, atom);\n            }\n            BREAK;\n        CASE(OP_make_var_ref):\n            {\n                JSAtom atom;\n                atom = get_u32(pc);\n                pc += 4;\n\n                if (JS_GetGlobalVarRef(ctx, atom, sp))\n                    goto exception;\n                sp += 2;\n            }\n            BREAK;\n\n        CASE(OP_goto):\n            pc += (int32_t)get_u32(pc);\n            if (unlikely(js_poll_interrupts(ctx)))\n                goto exception;\n            BREAK;\n#if SHORT_OPCODES\n        CASE(OP_goto16):\n            pc += (int16_t)get_u16(pc);\n            if (unlikely(js_poll_interrupts(ctx)))\n                goto exception;\n            BREAK;\n        CASE(OP_goto8):\n            pc += (int8_t)pc[0];\n            if (unlikely(js_poll_interrupts(ctx)))\n                goto exception;\n            BREAK;\n#endif\n        CASE(OP_if_true):\n            {\n                int res;\n                JSValue op1;\n\n                op1 = sp[-1];\n                pc += 4;\n                if ((uint32_t)JS_VALUE_GET_TAG(op1) <= JS_TAG_UNDEFINED) {\n                    res = JS_VALUE_GET_INT(op1);\n                } else {\n                    res = JS_ToBoolFree(ctx, op1);\n                }\n                sp--;\n                if (res) {\n                    pc += (int32_t)get_u32(pc - 4) - 4;\n                }\n                if (unlikely(js_poll_interrupts(ctx)))\n                    goto exception;\n            }\n            BREAK;\n        CASE(OP_if_false):\n            {\n                int res;\n                JSValue op1;\n\n                op1 = sp[-1];\n                pc += 4;\n                if ((uint32_t)JS_VALUE_GET_TAG(op1) <= JS_TAG_UNDEFINED) {\n                    res = JS_VALUE_GET_INT(op1);\n                } else {\n                    res = JS_ToBoolFree(ctx, op1);\n                }\n                sp--;\n                if (!res) {\n                    pc += (int32_t)get_u32(pc - 4) - 4;\n                }\n                if (unlikely(js_poll_interrupts(ctx)))\n                    goto exception;\n            }\n            BREAK;\n#if SHORT_OPCODES\n        CASE(OP_if_true8):\n            {\n                int res;\n                JSValue op1;\n\n                op1 = sp[-1];\n                pc += 1;\n                if ((uint32_t)JS_VALUE_GET_TAG(op1) <= JS_TAG_UNDEFINED) {\n                    res = JS_VALUE_GET_INT(op1);\n                } else {\n                    res = JS_ToBoolFree(ctx, op1);\n                }\n                sp--;\n                if (res) {\n                    pc += (int8_t)pc[-1] - 1;\n                }\n                if (unlikely(js_poll_interrupts(ctx)))\n                    goto exception;\n            }\n            BREAK;\n        CASE(OP_if_false8):\n            {\n                int res;\n                JSValue op1;\n\n                op1 = sp[-1];\n                pc += 1;\n                if ((uint32_t)JS_VALUE_GET_TAG(op1) <= JS_TAG_UNDEFINED) {\n                    res = JS_VALUE_GET_INT(op1);\n                } else {\n                    res = JS_ToBoolFree(ctx, op1);\n                }\n                sp--;\n                if (!res) {\n                    pc += (int8_t)pc[-1] - 1;\n                }\n                if (unlikely(js_poll_interrupts(ctx)))\n                    goto exception;\n            }\n            BREAK;\n#endif\n        CASE(OP_catch):\n            {\n                int32_t diff;\n                diff = get_u32(pc);\n                sp[0] = JS_NewCatchOffset(ctx, pc + diff - b->byte_code_buf);\n                sp++;\n                pc += 4;\n            }\n            BREAK;\n        CASE(OP_gosub):\n            {\n                int32_t diff;\n                diff = get_u32(pc);\n                /* XXX: should have a different tag to avoid security flaw */\n                sp[0] = JS_NewInt32(ctx, pc + 4 - b->byte_code_buf);\n                sp++;\n                pc += diff;\n            }\n            BREAK;\n        CASE(OP_ret):\n            {\n                JSValue op1;\n                uint32_t pos;\n                op1 = sp[-1];\n                if (unlikely(JS_VALUE_GET_TAG(op1) != JS_TAG_INT))\n                    goto ret_fail;\n                pos = JS_VALUE_GET_INT(op1);\n                if (unlikely(pos >= b->byte_code_len)) {\n                ret_fail:\n                    JS_ThrowInternalError(ctx, \"invalid ret value\");\n                    goto exception;\n                }\n                sp--;\n                pc = b->byte_code_buf + pos;\n            }\n            BREAK;\n\n        CASE(OP_for_in_start):\n            if (js_for_in_start(ctx, sp))\n                goto exception;\n            BREAK;\n        CASE(OP_for_in_next):\n            if (js_for_in_next(ctx, sp))\n                goto exception;\n            sp += 2;\n            BREAK;\n        CASE(OP_for_of_start):\n            if (js_for_of_start(ctx, sp, FALSE))\n                goto exception;\n            sp += 1;\n            *sp++ = JS_NewCatchOffset(ctx, 0);\n            BREAK;\n        CASE(OP_for_of_next):\n            {\n                int offset = -3 - pc[0];\n                pc += 1;\n                if (js_for_of_next(ctx, sp, offset))\n                    goto exception;\n                sp += 2;\n            }\n            BREAK;\n        CASE(OP_for_await_of_start):\n            if (js_for_of_start(ctx, sp, TRUE))\n                goto exception;\n            sp += 1;\n            *sp++ = JS_NewCatchOffset(ctx, 0);\n            BREAK;\n        CASE(OP_iterator_get_value_done):\n            if (js_iterator_get_value_done(ctx, sp))\n                goto exception;\n            sp += 1;\n            BREAK;\n        CASE(OP_iterator_check_object):\n            if (unlikely(!JS_IsObject(sp[-1]))) {\n                JS_ThrowTypeError(ctx, \"iterator must return an object\");\n                goto exception;\n            }\n            BREAK;\n\n        CASE(OP_iterator_close):\n            /* iter_obj next catch_offset -> */\n            sp--; /* drop the catch offset to avoid getting caught by exception */\n            JS_FreeValue(ctx, sp[-1]); /* drop the next method */\n            sp--;\n            if (!JS_IsUndefined(sp[-1])) {\n                if (JS_IteratorClose(ctx, sp[-1], FALSE))\n                    goto exception;\n                JS_FreeValue(ctx, sp[-1]);\n            }\n            sp--;\n            BREAK;\n        CASE(OP_iterator_close_return):\n            {\n                JSValue ret_val;\n                /* iter_obj next catch_offset ... ret_val ->\n                   ret_eval iter_obj next catch_offset */\n                ret_val = *--sp;\n                while (sp > stack_buf &&\n                       JS_VALUE_GET_TAG(sp[-1]) != JS_TAG_CATCH_OFFSET) {\n                    JS_FreeValue(ctx, *--sp);\n                }\n                if (unlikely(sp < stack_buf + 3)) {\n                    JS_ThrowInternalError(ctx, \"iterator_close_return\");\n                    JS_FreeValue(ctx, ret_val);\n                    goto exception;\n                }\n                sp[0] = sp[-1];\n                sp[-1] = sp[-2];\n                sp[-2] = sp[-3];\n                sp[-3] = ret_val;\n                sp++;\n            }\n            BREAK;\n\n        CASE(OP_iterator_next):\n            /* stack: iter_obj next catch_offset val */\n            {\n                JSValue ret;\n                ret = JS_Call(ctx, sp[-3], sp[-4],\n                              1, (JSValueConst *)(sp - 1));\n                if (JS_IsException(ret))\n                    goto exception;\n                JS_FreeValue(ctx, sp[-1]);\n                sp[-1] = ret;\n            }\n            BREAK;\n\n        CASE(OP_iterator_call):\n            /* stack: iter_obj next catch_offset val */\n            {\n                JSValue method, ret;\n                BOOL ret_flag;\n                int flags;\n                flags = *pc++;\n                method = JS_GetProperty(ctx, sp[-4], (flags & 1) ?\n                                        JS_ATOM_throw : JS_ATOM_return);\n                if (JS_IsException(method))\n                    goto exception;\n                if (JS_IsUndefined(method) || JS_IsNull(method)) {\n                    ret_flag = TRUE;\n                } else {\n                    if (flags & 2) {\n                        /* no argument */\n                        ret = JS_CallFree(ctx, method, sp[-4],\n                                          0, NULL);\n                    } else {\n                        ret = JS_CallFree(ctx, method, sp[-4],\n                                          1, (JSValueConst *)(sp - 1));\n                    }\n                    if (JS_IsException(ret))\n                        goto exception;\n                    JS_FreeValue(ctx, sp[-1]);\n                    sp[-1] = ret;\n                    ret_flag = FALSE;\n                }\n                sp[0] = JS_NewBool(ctx, ret_flag);\n                sp += 1;\n            }\n            BREAK;\n\n        CASE(OP_lnot):\n            {\n                int res;\n                JSValue op1;\n\n                op1 = sp[-1];\n                if ((uint32_t)JS_VALUE_GET_TAG(op1) <= JS_TAG_UNDEFINED) {\n                    res = JS_VALUE_GET_INT(op1) != 0;\n                } else {\n                    res = JS_ToBoolFree(ctx, op1);\n                }\n                sp[-1] = JS_NewBool(ctx, !res);\n            }\n            BREAK;\n\n        CASE(OP_get_field):\n            {\n                JSValue val;\n                JSAtom atom;\n                atom = get_u32(pc);\n                pc += 4;\n\n                val = JS_GetProperty(ctx, sp[-1], atom);\n                if (unlikely(JS_IsException(val)))\n                    goto exception;\n                JS_FreeValue(ctx, sp[-1]);\n                sp[-1] = val;\n            }\n            BREAK;\n\n        CASE(OP_get_field2):\n            {\n                JSValue val;\n                JSAtom atom;\n                atom = get_u32(pc);\n                pc += 4;\n\n                val = JS_GetProperty(ctx, sp[-1], atom);\n                if (unlikely(JS_IsException(val)))\n                    goto exception;\n                *sp++ = val;\n            }\n            BREAK;\n\n        CASE(OP_put_field):\n            {\n                int ret;\n                JSAtom atom;\n                atom = get_u32(pc);\n                pc += 4;\n\n                ret = JS_SetPropertyInternal(ctx, sp[-2], atom, sp[-1],\n                                             JS_PROP_THROW_STRICT);\n                JS_FreeValue(ctx, sp[-2]);\n                sp -= 2;\n                if (unlikely(ret < 0))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_private_symbol):\n            {\n                JSAtom atom;\n                JSValue val;\n                \n                atom = get_u32(pc);\n                pc += 4;\n                val = JS_NewSymbolFromAtom(ctx, atom, JS_ATOM_TYPE_PRIVATE);\n                if (JS_IsException(val))\n                    goto exception;\n                *sp++ = val;\n            }\n            BREAK;\n            \n        CASE(OP_get_private_field):\n            {\n                JSValue val;\n\n                val = JS_GetPrivateField(ctx, sp[-2], sp[-1]);\n                JS_FreeValue(ctx, sp[-1]);\n                JS_FreeValue(ctx, sp[-2]);\n                sp[-2] = val;\n                sp--;\n                if (unlikely(JS_IsException(val)))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_put_private_field):\n            {\n                int ret;\n                ret = JS_SetPrivateField(ctx, sp[-3], sp[-1], sp[-2]);\n                JS_FreeValue(ctx, sp[-3]);\n                JS_FreeValue(ctx, sp[-1]);\n                sp -= 3;\n                if (unlikely(ret < 0))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_define_private_field):\n            {\n                int ret;\n                ret = JS_DefinePrivateField(ctx, sp[-3], sp[-2], sp[-1]);\n                JS_FreeValue(ctx, sp[-2]);\n                sp -= 2;\n                if (unlikely(ret < 0))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_define_field):\n            {\n                int ret;\n                JSAtom atom;\n                atom = get_u32(pc);\n                pc += 4;\n\n                ret = JS_DefinePropertyValue(ctx, sp[-2], atom, sp[-1],\n                                             JS_PROP_C_W_E | JS_PROP_THROW);\n                sp--;\n                if (unlikely(ret < 0))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_set_name):\n            {\n                int ret;\n                JSAtom atom;\n                atom = get_u32(pc);\n                pc += 4;\n\n                ret = JS_DefineObjectName(ctx, sp[-1], atom, JS_PROP_CONFIGURABLE);\n                if (unlikely(ret < 0))\n                    goto exception;\n            }\n            BREAK;\n        CASE(OP_set_name_computed):\n            {\n                int ret;\n                ret = JS_DefineObjectNameComputed(ctx, sp[-1], sp[-2], JS_PROP_CONFIGURABLE);\n                if (unlikely(ret < 0))\n                    goto exception;\n            }\n            BREAK;\n        CASE(OP_set_proto):\n            {\n                JSValue proto;\n                proto = sp[-1];\n                if (JS_IsObject(proto) || JS_IsNull(proto)) {\n                    if (JS_SetPrototypeInternal(ctx, sp[-2], proto, TRUE) < 0)\n                        goto exception;\n                }\n                JS_FreeValue(ctx, proto);\n                sp--;\n            }\n            BREAK;\n        CASE(OP_set_home_object):\n            js_method_set_home_object(ctx, sp[-1], sp[-2]);\n            BREAK;\n        CASE(OP_define_method):\n        CASE(OP_define_method_computed):\n            {\n                JSValue getter, setter, value;\n                JSValueConst obj;\n                JSAtom atom;\n                int flags, ret, op_flags;\n                BOOL is_computed;\n#define OP_DEFINE_METHOD_METHOD 0\n#define OP_DEFINE_METHOD_GETTER 1\n#define OP_DEFINE_METHOD_SETTER 2\n#define OP_DEFINE_METHOD_ENUMERABLE 4\n\n                is_computed = (opcode == OP_define_method_computed);\n                if (is_computed) {\n                    atom = JS_ValueToAtom(ctx, sp[-2]);\n                    if (unlikely(atom == JS_ATOM_NULL))\n                        goto exception;\n                    opcode += OP_define_method - OP_define_method_computed;\n                } else {\n                    atom = get_u32(pc);\n                    pc += 4;\n                }\n                op_flags = *pc++;\n\n                obj = sp[-2 - is_computed];\n                flags = JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE |\n                    JS_PROP_HAS_ENUMERABLE | JS_PROP_THROW;\n                if (op_flags & OP_DEFINE_METHOD_ENUMERABLE)\n                    flags |= JS_PROP_ENUMERABLE;\n                op_flags &= 3;\n                value = JS_UNDEFINED;\n                getter = JS_UNDEFINED;\n                setter = JS_UNDEFINED;\n                if (op_flags == OP_DEFINE_METHOD_METHOD) {\n                    value = sp[-1];\n                    flags |= JS_PROP_HAS_VALUE | JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE;\n                } else if (op_flags == OP_DEFINE_METHOD_GETTER) {\n                    getter = sp[-1];\n                    flags |= JS_PROP_HAS_GET;\n                } else {\n                    setter = sp[-1];\n                    flags |= JS_PROP_HAS_SET;\n                }\n                ret = js_method_set_properties(ctx, sp[-1], atom, flags, obj);\n                if (ret >= 0) {\n                    ret = JS_DefineProperty(ctx, obj, atom, value,\n                                            getter, setter, flags);\n                }\n                JS_FreeValue(ctx, sp[-1]);\n                if (is_computed) {\n                    JS_FreeAtom(ctx, atom);\n                    JS_FreeValue(ctx, sp[-2]);\n                }\n                sp -= 1 + is_computed;\n                if (unlikely(ret < 0))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_define_class):\n        CASE(OP_define_class_computed):\n            {\n                int class_flags;\n                JSAtom atom;\n                \n                atom = get_u32(pc);\n                class_flags = pc[4];\n                pc += 5;\n                if (js_op_define_class(ctx, sp, atom, class_flags,\n                                       var_refs, sf,\n                                       (opcode == OP_define_class_computed)) < 0)\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_get_array_el):\n            {\n                JSValue val;\n\n                val = JS_GetPropertyValue(ctx, sp[-2], sp[-1]);\n                JS_FreeValue(ctx, sp[-2]);\n                sp[-2] = val;\n                sp--;\n                if (unlikely(JS_IsException(val)))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_get_array_el2):\n            {\n                JSValue val;\n\n                val = JS_GetPropertyValue(ctx, sp[-2], sp[-1]);\n                sp[-1] = val;\n                if (unlikely(JS_IsException(val)))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_get_ref_value):\n            {\n                JSValue val;\n                if (unlikely(JS_IsUndefined(sp[-2]))) {\n                    JSAtom atom = JS_ValueToAtom(ctx, sp[-1]);\n                    if (atom != JS_ATOM_NULL) {\n                        JS_ThrowReferenceErrorNotDefined(ctx, atom);\n                        JS_FreeAtom(ctx, atom);\n                    }\n                    goto exception;\n                }\n                val = JS_GetPropertyValue(ctx, sp[-2],\n                                          JS_DupValue(ctx, sp[-1]));\n                if (unlikely(JS_IsException(val)))\n                    goto exception;\n                sp[0] = val;\n                sp++;\n            }\n            BREAK;\n\n        CASE(OP_get_super_value):\n            {\n                JSValue val;\n                JSAtom atom;\n                atom = JS_ValueToAtom(ctx, sp[-1]);\n                if (unlikely(atom == JS_ATOM_NULL))\n                    goto exception;\n                val = JS_GetPropertyInternal(ctx, sp[-2], atom, sp[-3], FALSE);\n                JS_FreeAtom(ctx, atom);\n                if (unlikely(JS_IsException(val)))\n                    goto exception;\n                JS_FreeValue(ctx, sp[-1]);\n                JS_FreeValue(ctx, sp[-2]);\n                JS_FreeValue(ctx, sp[-3]);\n                sp[-3] = val;\n                sp -= 2;\n            }\n            BREAK;\n\n        CASE(OP_put_array_el):\n            {\n                int ret;\n\n                ret = JS_SetPropertyValue(ctx, sp[-3], sp[-2], sp[-1], JS_PROP_THROW_STRICT);\n                JS_FreeValue(ctx, sp[-3]);\n                sp -= 3;\n                if (unlikely(ret < 0))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_put_ref_value):\n            {\n                int ret, flags;\n                flags = JS_PROP_THROW_STRICT;\n                if (unlikely(JS_IsUndefined(sp[-3]))) {\n                    if (is_strict_mode(ctx)) {\n                        JSAtom atom = JS_ValueToAtom(ctx, sp[-2]);\n                        if (atom != JS_ATOM_NULL) {\n                            JS_ThrowReferenceErrorNotDefined(ctx, atom);\n                            JS_FreeAtom(ctx, atom);\n                        }\n                        goto exception;\n                    } else {\n                        sp[-3] = JS_DupValue(ctx, ctx->global_obj);\n                    }\n                } else {\n                    if (is_strict_mode(ctx))\n                        flags |= JS_PROP_NO_ADD;\n                }\n                ret = JS_SetPropertyValue(ctx, sp[-3], sp[-2], sp[-1], flags);\n                JS_FreeValue(ctx, sp[-3]);\n                sp -= 3;\n                if (unlikely(ret < 0))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_put_super_value):\n            {\n                int ret;\n                JSAtom atom;\n                if (JS_VALUE_GET_TAG(sp[-3]) != JS_TAG_OBJECT) {\n                    JS_ThrowTypeErrorNotAnObject(ctx);\n                    goto exception;\n                }\n                atom = JS_ValueToAtom(ctx, sp[-2]);\n                if (unlikely(atom == JS_ATOM_NULL))\n                    goto exception;\n                ret = JS_SetPropertyGeneric(ctx, sp[-3], atom, sp[-1], sp[-4],\n                                            JS_PROP_THROW_STRICT);\n                JS_FreeAtom(ctx, atom);\n                JS_FreeValue(ctx, sp[-4]);\n                JS_FreeValue(ctx, sp[-3]);\n                JS_FreeValue(ctx, sp[-2]);\n                sp -= 4;\n                if (ret < 0)\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_define_array_el):\n            {\n                int ret;\n                ret = JS_DefinePropertyValueValue(ctx, sp[-3], JS_DupValue(ctx, sp[-2]), sp[-1],\n                                                  JS_PROP_C_W_E | JS_PROP_THROW);\n                sp -= 1;\n                if (unlikely(ret < 0))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_append):    /* array pos enumobj -- array pos */\n            {\n                if (js_append_enumerate(ctx, sp))\n                    goto exception;\n                JS_FreeValue(ctx, *--sp);\n            }\n            BREAK;\n\n        CASE(OP_copy_data_properties):    /* target source excludeList */\n            {\n                /* stack offsets (-1 based):\n                   2 bits for target,\n                   3 bits for source,\n                   2 bits for exclusionList */\n                int mask;\n\n                mask = *pc++;\n                if (JS_CopyDataProperties(ctx, sp[-1 - (mask & 3)],\n                                          sp[-1 - ((mask >> 2) & 7)],\n                                          sp[-1 - ((mask >> 5) & 7)], 0))\n                    goto exception;\n            }\n            BREAK;\n\n        CASE(OP_add):\n            {\n                JSValue op1, op2;\n                op1 = sp[-2];\n                op2 = sp[-1];\n                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {\n                    int64_t r;\n                    r = (int64_t)JS_VALUE_GET_INT(op1) + JS_VALUE_GET_INT(op2);\n                    if (unlikely((int)r != r))\n                        goto add_slow;\n                    sp[-2] = JS_NewInt32(ctx, r);\n                    sp--;\n                } else if (JS_VALUE_IS_BOTH_FLOAT(op1, op2)) {\n                    sp[-2] = __JS_NewFloat64(ctx, JS_VALUE_GET_FLOAT64(op1) +\n                                             JS_VALUE_GET_FLOAT64(op2));\n                    sp--;\n                } else {\n                add_slow:\n                    if (js_add_slow(ctx, sp))\n                        goto exception;\n                    sp--;\n                }\n            }\n            BREAK;\n        CASE(OP_add_loc):\n            {\n                JSValue *pv;\n                int idx;\n                idx = *pc;\n                pc += 1;\n\n                pv = &var_buf[idx];\n                if (likely(JS_VALUE_IS_BOTH_INT(*pv, sp[-1]))) {\n                    int64_t r;\n                    r = (int64_t)JS_VALUE_GET_INT(*pv) +\n                        JS_VALUE_GET_INT(sp[-1]);\n                    if (unlikely((int)r != r))\n                        goto add_loc_slow;\n                    *pv = JS_NewInt32(ctx, r);\n                    sp--;\n                } else if (JS_VALUE_GET_TAG(*pv) == JS_TAG_STRING) {\n                    JSValue op1;\n                    op1 = sp[-1];\n                    sp--;\n                    op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);\n                    if (JS_IsException(op1))\n                        goto exception;\n                    op1 = JS_ConcatString(ctx, JS_DupValue(ctx, *pv), op1);\n                    if (JS_IsException(op1))\n                        goto exception;\n                    set_value(ctx, pv, op1);\n                } else {\n                    JSValue ops[2];\n                add_loc_slow:\n                    /* In case of exception, js_add_slow frees ops[0]\n                       and ops[1], so we must duplicate *pv */\n                    ops[0] = JS_DupValue(ctx, *pv);\n                    ops[1] = sp[-1];\n                    sp--;\n                    if (js_add_slow(ctx, ops + 2))\n                        goto exception;\n                    set_value(ctx, pv, ops[0]);\n                }\n            }\n            BREAK;\n        CASE(OP_sub):\n            {\n                JSValue op1, op2;\n                op1 = sp[-2];\n                op2 = sp[-1];\n                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {\n                    int64_t r;\n                    r = (int64_t)JS_VALUE_GET_INT(op1) - JS_VALUE_GET_INT(op2);\n                    if (unlikely((int)r != r))\n                        goto binary_arith_slow;\n                    sp[-2] = JS_NewInt32(ctx, r);\n                    sp--;\n                } else if (JS_VALUE_IS_BOTH_FLOAT(op1, op2)) {\n                    sp[-2] = __JS_NewFloat64(ctx, JS_VALUE_GET_FLOAT64(op1) -\n                                             JS_VALUE_GET_FLOAT64(op2));\n                    sp--;\n                } else {\n                    goto binary_arith_slow;\n                }\n            }\n            BREAK;\n        CASE(OP_mul):\n            {\n                JSValue op1, op2;\n                double d;\n                op1 = sp[-2];\n                op2 = sp[-1];\n                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {\n                    int32_t v1, v2;\n                    int64_t r;\n                    v1 = JS_VALUE_GET_INT(op1);\n                    v2 = JS_VALUE_GET_INT(op2);\n                    r = (int64_t)v1 * v2;\n                    if (unlikely((int)r != r)) {\n#ifdef CONFIG_BIGNUM\n                        if (unlikely(sf->js_mode & JS_MODE_MATH) &&\n                            (r < -MAX_SAFE_INTEGER || r > MAX_SAFE_INTEGER))\n                            goto binary_arith_slow;\n#endif\n                        d = (double)r;\n                        goto mul_fp_res;\n                    }\n                    /* need to test zero case for -0 result */\n                    if (unlikely(r == 0 && (v1 | v2) < 0)) {\n                        d = -0.0;\n                        goto mul_fp_res;\n                    }\n                    sp[-2] = JS_NewInt32(ctx, r);\n                    sp--;\n                } else if (JS_VALUE_IS_BOTH_FLOAT(op1, op2)) {\n#ifdef CONFIG_BIGNUM\n                    if (unlikely(sf->js_mode & JS_MODE_MATH))\n                        goto binary_arith_slow;\n#endif\n                    d = JS_VALUE_GET_FLOAT64(op1) * JS_VALUE_GET_FLOAT64(op2);\n                mul_fp_res:\n                    sp[-2] = __JS_NewFloat64(ctx, d);\n                    sp--;\n                } else {\n                    goto binary_arith_slow;\n                }\n            }\n            BREAK;\n        CASE(OP_div):\n            {\n                JSValue op1, op2;\n                op1 = sp[-2];\n                op2 = sp[-1];\n                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {\n                    int v1, v2;\n                    if (unlikely(sf->js_mode & JS_MODE_MATH))\n                        goto binary_arith_slow;\n                    v1 = JS_VALUE_GET_INT(op1);\n                    v2 = JS_VALUE_GET_INT(op2);\n                    sp[-2] = JS_NewFloat64(ctx, (double)v1 / (double)v2);\n                    sp--;\n                } else {\n                    goto binary_arith_slow;\n                }\n            }\n            BREAK;\n        CASE(OP_mod):\n#ifdef CONFIG_BIGNUM\n        CASE(OP_math_mod):\n#endif\n            {\n                JSValue op1, op2;\n                op1 = sp[-2];\n                op2 = sp[-1];\n                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {\n                    int v1, v2, r;\n                    v1 = JS_VALUE_GET_INT(op1);\n                    v2 = JS_VALUE_GET_INT(op2);\n                    /* We must avoid v2 = 0, v1 = INT32_MIN and v2 =\n                       -1 and the cases where the result is -0. */\n                    if (unlikely(v1 < 0 || v2 <= 0))\n                        goto binary_arith_slow;\n                    r = v1 % v2;\n                    sp[-2] = JS_NewInt32(ctx, r);\n                    sp--;\n                } else {\n                    goto binary_arith_slow;\n                }\n            }\n            BREAK;\n        CASE(OP_pow):\n        binary_arith_slow:\n            if (js_binary_arith_slow(ctx, sp, opcode))\n                goto exception;\n            sp--;\n            BREAK;\n\n        CASE(OP_plus):\n            {\n                JSValue op1;\n                uint32_t tag;\n                op1 = sp[-1];\n                tag = JS_VALUE_GET_TAG(op1);\n                if (tag == JS_TAG_INT || JS_TAG_IS_FLOAT64(tag)) {\n                } else {\n                    if (js_unary_arith_slow(ctx, sp, opcode))\n                        goto exception;\n                }\n            }\n            BREAK;\n        CASE(OP_neg):\n            {\n                JSValue op1;\n                uint32_t tag;\n                int val;\n                double d;\n                op1 = sp[-1];\n                tag = JS_VALUE_GET_TAG(op1);\n                if (tag == JS_TAG_INT) {\n                    val = JS_VALUE_GET_INT(op1);\n                    /* Note: -0 cannot be expressed as integer */\n                    if (unlikely(val == 0)) {\n                        d = -0.0;\n                        goto neg_fp_res;\n                    }\n                    if (unlikely(val == INT32_MIN)) {\n                        d = -(double)val;\n                        goto neg_fp_res;\n                    }\n                    sp[-1] = JS_NewInt32(ctx, -val);\n                } else if (JS_TAG_IS_FLOAT64(tag)) {\n                    d = -JS_VALUE_GET_FLOAT64(op1);\n                neg_fp_res:\n                    sp[-1] = __JS_NewFloat64(ctx, d);\n                } else {\n                    if (js_unary_arith_slow(ctx, sp, opcode))\n                        goto exception;\n                }\n            }\n            BREAK;\n        CASE(OP_inc):\n            {\n                JSValue op1;\n                int val;\n                op1 = sp[-1];\n                if (JS_VALUE_GET_TAG(op1) == JS_TAG_INT) {\n                    val = JS_VALUE_GET_INT(op1);\n                    if (unlikely(val == INT32_MAX))\n                        goto inc_slow;\n                    sp[-1] = JS_NewInt32(ctx, val + 1);\n                } else {\n                inc_slow:\n                    if (js_unary_arith_slow(ctx, sp, opcode))\n                        goto exception;\n                }\n            }\n            BREAK;\n        CASE(OP_dec):\n            {\n                JSValue op1;\n                int val;\n                op1 = sp[-1];\n                if (JS_VALUE_GET_TAG(op1) == JS_TAG_INT) {\n                    val = JS_VALUE_GET_INT(op1);\n                    if (unlikely(val == INT32_MIN))\n                        goto dec_slow;\n                    sp[-1] = JS_NewInt32(ctx, val - 1);\n                } else {\n                dec_slow:\n                    if (js_unary_arith_slow(ctx, sp, opcode))\n                        goto exception;\n                }\n            }\n            BREAK;\n        CASE(OP_post_inc):\n        CASE(OP_post_dec):\n            if (js_post_inc_slow(ctx, sp, opcode))\n                goto exception;\n            sp++;\n            BREAK;\n        CASE(OP_inc_loc):\n            {\n                JSValue op1;\n                int val;\n                int idx;\n                idx = *pc;\n                pc += 1;\n\n                op1 = var_buf[idx];\n                if (JS_VALUE_GET_TAG(op1) == JS_TAG_INT) {\n                    val = JS_VALUE_GET_INT(op1);\n                    if (unlikely(val == INT32_MAX))\n                        goto inc_loc_slow;\n                    var_buf[idx] = JS_NewInt32(ctx, val + 1);\n                } else {\n                inc_loc_slow:\n                    /* must duplicate otherwise the variable value may\n                       be destroyed before JS code accesses it */\n                    op1 = JS_DupValue(ctx, op1);\n                    if (js_unary_arith_slow(ctx, &op1 + 1, OP_inc))\n                        goto exception;\n                    set_value(ctx, &var_buf[idx], op1);\n                }\n            }\n            BREAK;\n        CASE(OP_dec_loc):\n            {\n                JSValue op1;\n                int val;\n                int idx;\n                idx = *pc;\n                pc += 1;\n\n                op1 = var_buf[idx];\n                if (JS_VALUE_GET_TAG(op1) == JS_TAG_INT) {\n                    val = JS_VALUE_GET_INT(op1);\n                    if (unlikely(val == INT32_MIN))\n                        goto dec_loc_slow;\n                    var_buf[idx] = JS_NewInt32(ctx, val - 1);\n                } else {\n                dec_loc_slow:\n                    /* must duplicate otherwise the variable value may\n                       be destroyed before JS code accesses it */\n                    op1 = JS_DupValue(ctx, op1);\n                    if (js_unary_arith_slow(ctx, &op1 + 1, OP_dec))\n                        goto exception;\n                    set_value(ctx, &var_buf[idx], op1);\n                }\n            }\n            BREAK;\n        CASE(OP_not):\n            {\n                JSValue op1;\n                op1 = sp[-1];\n                if (JS_VALUE_GET_TAG(op1) == JS_TAG_INT) {\n                    sp[-1] = JS_NewInt32(ctx, ~JS_VALUE_GET_INT(op1));\n                } else {\n                    if (js_not_slow(ctx, sp))\n                        goto exception;\n                }\n            }\n            BREAK;\n\n        CASE(OP_shl):\n            {\n                JSValue op1, op2;\n                op1 = sp[-2];\n                op2 = sp[-1];\n                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {\n                    uint32_t v1, v2;\n                    v1 = JS_VALUE_GET_INT(op1);\n                    v2 = JS_VALUE_GET_INT(op2);\n#ifdef CONFIG_BIGNUM\n                    {\n                        int64_t r;\n                        if (unlikely(sf->js_mode & JS_MODE_MATH)) {\n                            if (v2 > 0x1f)\n                                goto shl_slow;\n                            r = (int64_t)v1 << v2;\n                            if ((int)r != r)\n                                goto shl_slow;\n                        } else {\n                            v2 &= 0x1f;\n                        }\n                    }\n#else\n                    v2 &= 0x1f;\n#endif\n                    sp[-2] = JS_NewInt32(ctx, v1 << v2);\n                    sp--;\n                } else {\n#ifdef CONFIG_BIGNUM\n                shl_slow:\n#endif\n                    if (js_binary_logic_slow(ctx, sp, opcode))\n                        goto exception;\n                    sp--;\n                }\n            }\n            BREAK;\n        CASE(OP_shr):\n            {\n                JSValue op1, op2;\n                op1 = sp[-2];\n                op2 = sp[-1];\n                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {\n                    uint32_t v2;\n                    v2 = JS_VALUE_GET_INT(op2);\n                    /* v1 >>> v2 retains its JS semantics if CONFIG_BIGNUM */\n                    v2 &= 0x1f;\n                    sp[-2] = JS_NewUint32(ctx,\n                                          (uint32_t)JS_VALUE_GET_INT(op1) >>\n                                          v2);\n                    sp--;\n                } else {\n                    if (js_shr_slow(ctx, sp))\n                        goto exception;\n                    sp--;\n                }\n            }\n            BREAK;\n        CASE(OP_sar):\n            {\n                JSValue op1, op2;\n                op1 = sp[-2];\n                op2 = sp[-1];\n                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {\n                    uint32_t v2;\n                    v2 = JS_VALUE_GET_INT(op2);\n#ifdef CONFIG_BIGNUM\n                    if (unlikely(v2 > 0x1f)) {\n                        if (unlikely(sf->js_mode & JS_MODE_MATH))\n                            goto sar_slow;\n                        else\n                            v2 &= 0x1f;\n                    }\n#else\n                    v2 &= 0x1f;\n#endif\n                    sp[-2] = JS_NewInt32(ctx,\n                                          (int)JS_VALUE_GET_INT(op1) >> v2);\n                    sp--;\n                } else {\n#ifdef CONFIG_BIGNUM\n                sar_slow:\n#endif\n                    if (js_binary_logic_slow(ctx, sp, opcode))\n                        goto exception;\n                    sp--;\n                }\n            }\n            BREAK;\n        CASE(OP_and):\n            {\n                JSValue op1, op2;\n                op1 = sp[-2];\n                op2 = sp[-1];\n                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {\n                    sp[-2] = JS_NewInt32(ctx,\n                                         JS_VALUE_GET_INT(op1) &\n                                         JS_VALUE_GET_INT(op2));\n                    sp--;\n                } else {\n                    if (js_binary_logic_slow(ctx, sp, opcode))\n                        goto exception;\n                    sp--;\n                }\n            }\n            BREAK;\n        CASE(OP_or):\n            {\n                JSValue op1, op2;\n                op1 = sp[-2];\n                op2 = sp[-1];\n                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {\n                    sp[-2] = JS_NewInt32(ctx,\n                                         JS_VALUE_GET_INT(op1) |\n                                         JS_VALUE_GET_INT(op2));\n                    sp--;\n                } else {\n                    if (js_binary_logic_slow(ctx, sp, opcode))\n                        goto exception;\n                    sp--;\n                }\n            }\n            BREAK;\n        CASE(OP_xor):\n            {\n                JSValue op1, op2;\n                op1 = sp[-2];\n                op2 = sp[-1];\n                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {\n                    sp[-2] = JS_NewInt32(ctx,\n                                         JS_VALUE_GET_INT(op1) ^\n                                         JS_VALUE_GET_INT(op2));\n                    sp--;\n                } else {\n                    if (js_binary_logic_slow(ctx, sp, opcode))\n                        goto exception;\n                    sp--;\n                }\n            }\n            BREAK;\n\n\n#define OP_CMP(opcode, binary_op, slow_call)              \\\n            CASE(opcode):                                 \\\n                {                                         \\\n                JSValue op1, op2;                         \\\n                op1 = sp[-2];                             \\\n                op2 = sp[-1];                                   \\\n                if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {           \\\n                    sp[-2] = JS_NewBool(ctx, JS_VALUE_GET_INT(op1) binary_op JS_VALUE_GET_INT(op2)); \\\n                    sp--;                                               \\\n                } else {                                                \\\n                    if (slow_call)                                      \\\n                        goto exception;                                 \\\n                    sp--;                                               \\\n                }                                                       \\\n                }                                                       \\\n            BREAK\n\n            OP_CMP(OP_lt, <, js_relational_slow(ctx, sp, opcode));\n            OP_CMP(OP_lte, <=, js_relational_slow(ctx, sp, opcode));\n            OP_CMP(OP_gt, >, js_relational_slow(ctx, sp, opcode));\n            OP_CMP(OP_gte, >=, js_relational_slow(ctx, sp, opcode));\n            OP_CMP(OP_eq, ==, js_eq_slow(ctx, sp, 0));\n            OP_CMP(OP_neq, !=, js_eq_slow(ctx, sp, 1));\n            OP_CMP(OP_strict_eq, ==, js_strict_eq_slow(ctx, sp, 0));\n            OP_CMP(OP_strict_neq, !=, js_strict_eq_slow(ctx, sp, 1));\n\n#ifdef CONFIG_BIGNUM\n        CASE(OP_mul_pow10):\n            if (rt->bigfloat_ops.mul_pow10(ctx, sp))\n                goto exception;\n            sp--;\n            BREAK;\n#endif\n        CASE(OP_in):\n            if (js_operator_in(ctx, sp))\n                goto exception;\n            sp--;\n            BREAK;\n        CASE(OP_instanceof):\n            if (js_operator_instanceof(ctx, sp))\n                goto exception;\n            sp--;\n            BREAK;\n        CASE(OP_typeof):\n            {\n                JSValue op1;\n                JSAtom atom;\n\n                op1 = sp[-1];\n                atom = js_operator_typeof(ctx, op1);\n                JS_FreeValue(ctx, op1);\n                sp[-1] = JS_AtomToString(ctx, atom);\n            }\n            BREAK;\n        CASE(OP_delete):\n            if (js_operator_delete(ctx, sp))\n                goto exception;\n            sp--;\n            BREAK;\n        CASE(OP_delete_var):\n            {\n                JSAtom atom;\n                int ret;\n\n                atom = get_u32(pc);\n                pc += 4;\n\n                ret = JS_DeleteProperty(ctx, ctx->global_obj, atom, 0);\n                if (unlikely(ret < 0))\n                    goto exception;\n                *sp++ = JS_NewBool(ctx, ret);\n            }\n            BREAK;\n\n        CASE(OP_to_object):\n            if (JS_VALUE_GET_TAG(sp[-1]) != JS_TAG_OBJECT) {\n                ret_val = JS_ToObject(ctx, sp[-1]);\n                if (JS_IsException(ret_val))\n                    goto exception;\n                JS_FreeValue(ctx, sp[-1]);\n                sp[-1] = ret_val;\n            }\n            BREAK;\n\n        CASE(OP_to_propkey):\n            switch (JS_VALUE_GET_TAG(sp[-1])) {\n            case JS_TAG_INT:\n            case JS_TAG_STRING:\n            case JS_TAG_SYMBOL:\n                break;\n            default:\n                ret_val = JS_ToPropertyKey(ctx, sp[-1]);\n                if (JS_IsException(ret_val))\n                    goto exception;\n                JS_FreeValue(ctx, sp[-1]);\n                sp[-1] = ret_val;\n                break;\n            }\n            BREAK;\n\n        CASE(OP_to_propkey2):\n            /* must be tested first */\n            if (unlikely(JS_IsUndefined(sp[-2]) || JS_IsNull(sp[-2]))) {\n                JS_ThrowTypeError(ctx, \"value has no property\");\n                goto exception;\n            }\n            switch (JS_VALUE_GET_TAG(sp[-1])) {\n            case JS_TAG_INT:\n            case JS_TAG_STRING:\n            case JS_TAG_SYMBOL:\n                break;\n            default:\n                ret_val = JS_ToPropertyKey(ctx, sp[-1]);\n                if (JS_IsException(ret_val))\n                    goto exception;\n                JS_FreeValue(ctx, sp[-1]);\n                sp[-1] = ret_val;\n                break;\n            }\n            BREAK;\n#if 0\n        CASE(OP_to_string):\n            if (JS_VALUE_GET_TAG(sp[-1]) != JS_TAG_STRING) {\n                ret_val = JS_ToString(ctx, sp[-1]);\n                if (JS_IsException(ret_val))\n                    goto exception;\n                JS_FreeValue(ctx, sp[-1]);\n                sp[-1] = ret_val;\n            }\n            BREAK;\n#endif\n        CASE(OP_with_get_var):\n        CASE(OP_with_put_var):\n        CASE(OP_with_delete_var):\n        CASE(OP_with_make_ref):\n        CASE(OP_with_get_ref):\n        CASE(OP_with_get_ref_undef):\n            {\n                JSAtom atom;\n                int32_t diff;\n                JSValue obj, val;\n                int ret, is_with;\n                atom = get_u32(pc);\n                diff = get_u32(pc + 4);\n                is_with = pc[8];\n                pc += 9;\n\n                obj = sp[-1];\n                ret = JS_HasProperty(ctx, obj, atom);\n                if (unlikely(ret < 0))\n                    goto exception;\n                if (ret) {\n                    if (is_with) {\n                        ret = js_has_unscopable(ctx, obj, atom);\n                        if (unlikely(ret < 0))\n                            goto exception;\n                        if (ret)\n                            goto no_with;\n                    }\n                    switch (opcode) {\n                    case OP_with_get_var:\n                        val = JS_GetProperty(ctx, obj, atom);\n                        if (unlikely(JS_IsException(val)))\n                            goto exception;\n                        set_value(ctx, &sp[-1], val);\n                        break;\n                    case OP_with_put_var:\n                        /* XXX: check if strict mode */\n                        ret = JS_SetPropertyInternal(ctx, obj, atom, sp[-2],\n                                                     JS_PROP_THROW_STRICT);\n                        JS_FreeValue(ctx, sp[-1]);\n                        sp -= 2;\n                        if (unlikely(ret < 0))\n                            goto exception;\n                        break;\n                    case OP_with_delete_var:\n                        ret = JS_DeleteProperty(ctx, obj, atom, 0);\n                        if (unlikely(ret < 0))\n                            goto exception;\n                        JS_FreeValue(ctx, sp[-1]);\n                        sp[-1] = JS_NewBool(ctx, ret);\n                        break;\n                    case OP_with_make_ref:\n                        /* produce a pair object/propname on the stack */\n                        *sp++ = JS_AtomToValue(ctx, atom);\n                        break;\n                    case OP_with_get_ref:\n                        /* produce a pair object/method on the stack */\n                        val = JS_GetProperty(ctx, obj, atom);\n                        if (unlikely(JS_IsException(val)))\n                            goto exception;\n                        *sp++ = val;\n                        break;\n                    case OP_with_get_ref_undef:\n                        /* produce a pair undefined/function on the stack */\n                        val = JS_GetProperty(ctx, obj, atom);\n                        if (unlikely(JS_IsException(val)))\n                            goto exception;\n                        JS_FreeValue(ctx, sp[-1]);\n                        sp[-1] = JS_UNDEFINED;\n                        *sp++ = val;\n                        break;\n                    }\n                    pc += diff - 5;\n                } else {\n                no_with:\n                    /* if not jumping, drop the object argument */\n                    JS_FreeValue(ctx, sp[-1]);\n                    sp--;\n                }\n            }\n            BREAK;\n\n        CASE(OP_await):\n            ret_val = JS_NewInt32(ctx, FUNC_RET_AWAIT);\n            goto done_generator;\n        CASE(OP_yield):\n            ret_val = JS_NewInt32(ctx, FUNC_RET_YIELD);\n            goto done_generator;\n        CASE(OP_yield_star):\n        CASE(OP_async_yield_star):\n            ret_val = JS_NewInt32(ctx, FUNC_RET_YIELD_STAR);\n            goto done_generator;\n        CASE(OP_return_async):\n        CASE(OP_initial_yield):\n            ret_val = JS_UNDEFINED;\n            goto done_generator;\n\n        CASE(OP_nop):\n            BREAK;\n        CASE(OP_is_undefined_or_null):\n            if (JS_VALUE_GET_TAG(sp[-1]) == JS_TAG_UNDEFINED ||\n                JS_VALUE_GET_TAG(sp[-1]) == JS_TAG_NULL) {\n                goto set_true;\n            } else {\n                goto free_and_set_false;\n            }\n#if SHORT_OPCODES\n        CASE(OP_is_undefined):\n            if (JS_VALUE_GET_TAG(sp[-1]) == JS_TAG_UNDEFINED) {\n                goto set_true;\n            } else {\n                goto free_and_set_false;\n            }\n        CASE(OP_is_null):\n            if (JS_VALUE_GET_TAG(sp[-1]) == JS_TAG_NULL) {\n                goto set_true;\n            } else {\n                goto free_and_set_false;\n            }\n            /* XXX: could merge to a single opcode */\n        CASE(OP_typeof_is_undefined):\n            /* different from OP_is_undefined because of isHTMLDDA */\n            if (js_operator_typeof(ctx, sp[-1]) == JS_ATOM_undefined) {\n                goto free_and_set_true;\n            } else {\n                goto free_and_set_false;\n            }\n        CASE(OP_typeof_is_function):\n            if (js_operator_typeof(ctx, sp[-1]) == JS_ATOM_function) {\n                goto free_and_set_true;\n            } else {\n                goto free_and_set_false;\n            }\n        free_and_set_true:\n            JS_FreeValue(ctx, sp[-1]);\n#endif\n        set_true:\n            sp[-1] = JS_TRUE;\n            BREAK;\n        free_and_set_false:\n            JS_FreeValue(ctx, sp[-1]);\n            sp[-1] = JS_FALSE;\n            BREAK;\n        CASE(OP_invalid):\n        DEFAULT:\n            JS_ThrowInternalError(ctx, \"invalid opcode: pc=%u opcode=0x%02x\",\n                                  (int)(pc - b->byte_code_buf - 1), opcode);\n            goto exception;\n        }\n    }\n exception:\n    if (is_backtrace_needed(ctx, rt->current_exception)) {\n        /* add the backtrace information now (it is not done\n           before if the exception happens in a bytecode\n           operation */\n        sf->cur_pc = pc;\n        build_backtrace(ctx, rt->current_exception, NULL, 0, 0);\n    }\n    if (!JS_IsUncatchableError(ctx, rt->current_exception)) {\n        while (sp > stack_buf) {\n            JSValue val = *--sp;\n            JS_FreeValue(ctx, val);\n            if (JS_VALUE_GET_TAG(val) == JS_TAG_CATCH_OFFSET) {\n                int pos = JS_VALUE_GET_INT(val);\n                if (pos == 0) {\n                    /* enumerator: close it with a throw */\n                    JS_FreeValue(ctx, sp[-1]); /* drop the next method */\n                    sp--;\n                    JS_IteratorClose(ctx, sp[-1], TRUE);\n                } else {\n                    *sp++ = rt->current_exception;\n                    rt->current_exception = JS_NULL;\n                    pc = b->byte_code_buf + pos;\n                    goto restart;\n                }\n            }\n        }\n    }\n    ret_val = JS_EXCEPTION;\n    /* the local variables are freed by the caller in the generator\n       case. Hence the label 'done' should never be reached in a\n       generator function. */\n    if (b->func_kind != JS_FUNC_NORMAL) {\n    done_generator:\n        sf->cur_pc = pc;\n        sf->cur_sp = sp;\n    } else {\n    done:\n        if (unlikely(!list_empty(&sf->var_ref_list))) {\n            /* variable references reference the stack: must close them */\n            close_var_refs(rt, sf);\n        }\n        /* free the local variables and stack */\n        for(pval = local_buf; pval < sp; pval++) {\n            JS_FreeValue(ctx, *pval);\n        }\n    }\n    rt->current_stack_frame = sf->prev_frame;\n    return ret_val;\n}\n\nJSValue JS_Call(JSContext *ctx, JSValueConst func_obj, JSValueConst this_obj,\n                int argc, JSValueConst *argv)\n{\n    return JS_CallInternal(ctx, func_obj, this_obj, JS_UNDEFINED,\n                           argc, (JSValue *)argv, JS_CALL_FLAG_COPY_ARGV);\n}\n\nstatic JSValue JS_CallFree(JSContext *ctx, JSValue func_obj, JSValueConst this_obj,\n                           int argc, JSValueConst *argv)\n{\n    JSValue res = JS_CallInternal(ctx, func_obj, this_obj, JS_UNDEFINED,\n                                  argc, (JSValue *)argv, JS_CALL_FLAG_COPY_ARGV);\n    JS_FreeValue(ctx, func_obj);\n    return res;\n}\n\n/* warning: the refcount of the context is not incremented. Return\n   NULL in case of exception (case of revoked proxy only) */\nstatic JSContext *JS_GetFunctionRealm(JSContext *ctx, JSValueConst func_obj)\n{\n    JSObject *p;\n    JSContext *realm;\n    \n    if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)\n        return ctx;\n    p = JS_VALUE_GET_OBJ(func_obj);\n    switch(p->class_id) {\n    case JS_CLASS_C_FUNCTION:\n        realm = p->u.cfunc.realm;\n        break;\n    case JS_CLASS_BYTECODE_FUNCTION:\n    case JS_CLASS_GENERATOR_FUNCTION:\n    case JS_CLASS_ASYNC_FUNCTION:\n    case JS_CLASS_ASYNC_GENERATOR_FUNCTION:\n        {\n            JSFunctionBytecode *b;\n            b = p->u.func.function_bytecode;\n            realm = b->realm;\n        }\n        break;\n    case JS_CLASS_PROXY:\n        {\n            JSProxyData *s = p->u.opaque;\n            if (!s)\n                return ctx;\n            if (s->is_revoked) {\n                JS_ThrowTypeErrorRevokedProxy(ctx);\n                return NULL;\n            } else {\n                realm = JS_GetFunctionRealm(ctx, s->target);\n            }\n        }\n        break;\n    case JS_CLASS_BOUND_FUNCTION:\n        {\n            JSBoundFunction *bf = p->u.bound_function;\n            realm = JS_GetFunctionRealm(ctx, bf->func_obj);\n        }\n        break;\n    default:\n        realm = ctx;\n        break;\n    }\n    return realm;\n}\n\nstatic JSValue js_create_from_ctor(JSContext *ctx, JSValueConst ctor,\n                                   int class_id)\n{\n    JSValue proto, obj;\n    JSContext *realm;\n    \n    if (JS_IsUndefined(ctor)) {\n        proto = JS_DupValue(ctx, ctx->class_proto[class_id]);\n    } else {\n        proto = JS_GetProperty(ctx, ctor, JS_ATOM_prototype);\n        if (JS_IsException(proto))\n            return proto;\n        if (!JS_IsObject(proto)) {\n            JS_FreeValue(ctx, proto);\n            realm = JS_GetFunctionRealm(ctx, ctor);\n            if (!realm)\n                return JS_EXCEPTION;\n            proto = JS_DupValue(ctx, realm->class_proto[class_id]);\n        }\n    }\n    obj = JS_NewObjectProtoClass(ctx, proto, class_id);\n    JS_FreeValue(ctx, proto);\n    return obj;\n}\n\n/* argv[] is modified if (flags & JS_CALL_FLAG_COPY_ARGV) = 0. */\nstatic JSValue JS_CallConstructorInternal(JSContext *ctx,\n                                          JSValueConst func_obj,\n                                          JSValueConst new_target,\n                                          int argc, JSValue *argv, int flags)\n{\n    JSObject *p;\n    JSFunctionBytecode *b;\n\n    if (js_poll_interrupts(ctx))\n        return JS_EXCEPTION;\n    flags |= JS_CALL_FLAG_CONSTRUCTOR;\n    if (unlikely(JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT))\n        goto not_a_function;\n    p = JS_VALUE_GET_OBJ(func_obj);\n    if (unlikely(!p->is_constructor))\n        return JS_ThrowTypeError(ctx, \"not a constructor\");\n    if (unlikely(p->class_id != JS_CLASS_BYTECODE_FUNCTION)) {\n        JSClassCall *call_func;\n        call_func = ctx->rt->class_array[p->class_id].call;\n        if (!call_func) {\n        not_a_function:\n            return JS_ThrowTypeError(ctx, \"not a function\");\n        }\n        return call_func(ctx, func_obj, new_target, argc,\n                         (JSValueConst *)argv, flags);\n    }\n\n    b = p->u.func.function_bytecode;\n    if (b->is_derived_class_constructor) {\n        return JS_CallInternal(ctx, func_obj, JS_UNDEFINED, new_target, argc, argv, flags);\n    } else {\n        JSValue obj, ret;\n        /* legacy constructor behavior */\n        obj = js_create_from_ctor(ctx, new_target, JS_CLASS_OBJECT);\n        if (JS_IsException(obj))\n            return JS_EXCEPTION;\n        ret = JS_CallInternal(ctx, func_obj, obj, new_target, argc, argv, flags);\n        if (JS_VALUE_GET_TAG(ret) == JS_TAG_OBJECT ||\n            JS_IsException(ret)) {\n            JS_FreeValue(ctx, obj);\n            return ret;\n        } else {\n            JS_FreeValue(ctx, ret);\n            return obj;\n        }\n    }\n}\n\nJSValue JS_CallConstructor2(JSContext *ctx, JSValueConst func_obj,\n                            JSValueConst new_target,\n                            int argc, JSValueConst *argv)\n{\n    return JS_CallConstructorInternal(ctx, func_obj, new_target,\n                                      argc, (JSValue *)argv,\n                                      JS_CALL_FLAG_COPY_ARGV);\n}\n\nJSValue JS_CallConstructor(JSContext *ctx, JSValueConst func_obj,\n                           int argc, JSValueConst *argv)\n{\n    return JS_CallConstructorInternal(ctx, func_obj, func_obj,\n                                      argc, (JSValue *)argv,\n                                      JS_CALL_FLAG_COPY_ARGV);\n}\n\nJSValue JS_Invoke(JSContext *ctx, JSValueConst this_val, JSAtom atom,\n                  int argc, JSValueConst *argv)\n{\n    JSValue func_obj;\n    func_obj = JS_GetProperty(ctx, this_val, atom);\n    if (JS_IsException(func_obj))\n        return func_obj;\n    return JS_CallFree(ctx, func_obj, this_val, argc, argv);\n}\n\nstatic JSValue JS_InvokeFree(JSContext *ctx, JSValue this_val, JSAtom atom,\n                             int argc, JSValueConst *argv)\n{\n    JSValue res = JS_Invoke(ctx, this_val, atom, argc, argv);\n    JS_FreeValue(ctx, this_val);\n    return res;\n}\n\n/* JSAsyncFunctionState (used by generator and async functions) */\nstatic __exception int async_func_init(JSContext *ctx, JSAsyncFunctionState *s,\n                                       JSValueConst func_obj, JSValueConst this_obj,\n                                       int argc, JSValueConst *argv)\n{\n    JSObject *p;\n    JSFunctionBytecode *b;\n    JSStackFrame *sf;\n    int local_count, i, arg_buf_len, n;\n\n    sf = &s->frame;\n    init_list_head(&sf->var_ref_list);\n    p = JS_VALUE_GET_OBJ(func_obj);\n    b = p->u.func.function_bytecode;\n    sf->js_mode = b->js_mode;\n    sf->cur_pc = b->byte_code_buf;\n    arg_buf_len = max_int(b->arg_count, argc);\n    local_count = arg_buf_len + b->var_count + b->stack_size;\n    sf->arg_buf = js_malloc(ctx, sizeof(JSValue) * max_int(local_count, 1));\n    if (!sf->arg_buf)\n        return -1;\n    sf->cur_func = JS_DupValue(ctx, func_obj);\n    s->this_val = JS_DupValue(ctx, this_obj);\n    s->argc = argc;\n    sf->arg_count = arg_buf_len;\n    sf->var_buf = sf->arg_buf + arg_buf_len;\n    sf->cur_sp = sf->var_buf + b->var_count;\n    for(i = 0; i < argc; i++)\n        sf->arg_buf[i] = JS_DupValue(ctx, argv[i]);\n    n = arg_buf_len + b->var_count;\n    for(i = argc; i < n; i++)\n        sf->arg_buf[i] = JS_UNDEFINED;\n    return 0;\n}\n\nstatic void async_func_mark(JSRuntime *rt, JSAsyncFunctionState *s,\n                            JS_MarkFunc *mark_func)\n{\n    JSStackFrame *sf;\n    JSValue *sp;\n\n    sf = &s->frame;\n    JS_MarkValue(rt, sf->cur_func, mark_func);\n    JS_MarkValue(rt, s->this_val, mark_func);\n    if (sf->cur_sp) {\n        /* if the function is running, cur_sp is not known so we\n           cannot mark the stack. Marking the variables is not needed\n           because a running function cannot be part of a removable\n           cycle */\n        for(sp = sf->arg_buf; sp < sf->cur_sp; sp++)\n            JS_MarkValue(rt, *sp, mark_func);\n    }\n}\n\nstatic void async_func_free(JSRuntime *rt, JSAsyncFunctionState *s)\n{\n    JSStackFrame *sf;\n    JSValue *sp;\n\n    sf = &s->frame;\n\n    /* close the closure variables. */\n    close_var_refs(rt, sf);\n    \n    if (sf->arg_buf) {\n        /* cannot free the function if it is running */\n        assert(sf->cur_sp != NULL);\n        for(sp = sf->arg_buf; sp < sf->cur_sp; sp++) {\n            JS_FreeValueRT(rt, *sp);\n        }\n        js_free_rt(rt, sf->arg_buf);\n    }\n    JS_FreeValueRT(rt, sf->cur_func);\n    JS_FreeValueRT(rt, s->this_val);\n}\n\nstatic JSValue async_func_resume(JSContext *ctx, JSAsyncFunctionState *s)\n{\n    JSValue func_obj;\n\n    if (js_check_stack_overflow(ctx->rt, 0))\n        return JS_ThrowStackOverflow(ctx);\n\n    /* the tag does not matter provided it is not an object */\n    func_obj = JS_MKPTR(JS_TAG_INT, s);\n    return JS_CallInternal(ctx, func_obj, s->this_val, JS_UNDEFINED,\n                           s->argc, s->frame.arg_buf, JS_CALL_FLAG_GENERATOR);\n}\n\n\n/* Generators */\n\ntypedef enum JSGeneratorStateEnum {\n    JS_GENERATOR_STATE_SUSPENDED_START,\n    JS_GENERATOR_STATE_SUSPENDED_YIELD,\n    JS_GENERATOR_STATE_SUSPENDED_YIELD_STAR,\n    JS_GENERATOR_STATE_EXECUTING,\n    JS_GENERATOR_STATE_COMPLETED,\n} JSGeneratorStateEnum;\n\ntypedef struct JSGeneratorData {\n    JSGeneratorStateEnum state;\n    JSAsyncFunctionState func_state;\n} JSGeneratorData;\n\nstatic void free_generator_stack_rt(JSRuntime *rt, JSGeneratorData *s)\n{\n    if (s->state == JS_GENERATOR_STATE_COMPLETED)\n        return;\n    async_func_free(rt, &s->func_state);\n    s->state = JS_GENERATOR_STATE_COMPLETED;\n}\n\nstatic void js_generator_finalizer(JSRuntime *rt, JSValue obj)\n{\n    JSGeneratorData *s = JS_GetOpaque(obj, JS_CLASS_GENERATOR);\n\n    if (s) {\n        free_generator_stack_rt(rt, s);\n        js_free_rt(rt, s);\n    }\n}\n\nstatic void free_generator_stack(JSContext *ctx, JSGeneratorData *s)\n{\n    free_generator_stack_rt(ctx->rt, s);\n}\n\nstatic void js_generator_mark(JSRuntime *rt, JSValueConst val,\n                              JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSGeneratorData *s = p->u.generator_data;\n\n    if (!s || s->state == JS_GENERATOR_STATE_COMPLETED)\n        return;\n    async_func_mark(rt, &s->func_state, mark_func);\n}\n\n/* XXX: use enum */\n#define GEN_MAGIC_NEXT   0\n#define GEN_MAGIC_RETURN 1\n#define GEN_MAGIC_THROW  2\n\nstatic JSValue js_generator_next(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv,\n                                 BOOL *pdone, int magic)\n{\n    JSGeneratorData *s = JS_GetOpaque(this_val, JS_CLASS_GENERATOR);\n    JSStackFrame *sf;\n    JSValue ret, func_ret;\n\n    *pdone = TRUE;\n    if (!s)\n        return JS_ThrowTypeError(ctx, \"not a generator\");\n    sf = &s->func_state.frame;\n    switch(s->state) {\n    default:\n    case JS_GENERATOR_STATE_SUSPENDED_START:\n        if (magic == GEN_MAGIC_NEXT) {\n            goto exec_no_arg;\n        } else {\n            free_generator_stack(ctx, s);\n            goto done;\n        }\n        break;\n    case JS_GENERATOR_STATE_SUSPENDED_YIELD_STAR:\n    case JS_GENERATOR_STATE_SUSPENDED_YIELD:\n        /* cur_sp[-1] was set to JS_UNDEFINED in the previous call */\n        ret = JS_DupValue(ctx, argv[0]);\n        if (magic == GEN_MAGIC_THROW &&\n            s->state == JS_GENERATOR_STATE_SUSPENDED_YIELD) {\n            JS_Throw(ctx, ret);\n            s->func_state.throw_flag = TRUE;\n        } else {\n            sf->cur_sp[-1] = ret;\n            sf->cur_sp[0] = JS_NewInt32(ctx, magic);\n            sf->cur_sp++;\n        exec_no_arg:\n            s->func_state.throw_flag = FALSE;\n        }\n        s->state = JS_GENERATOR_STATE_EXECUTING;\n        func_ret = async_func_resume(ctx, &s->func_state);\n        s->state = JS_GENERATOR_STATE_SUSPENDED_YIELD;\n        if (JS_IsException(func_ret)) {\n            /* finalize the execution in case of exception */\n            free_generator_stack(ctx, s);\n            return func_ret;\n        }\n        if (JS_VALUE_GET_TAG(func_ret) == JS_TAG_INT) {\n            /* get the returned yield value at the top of the stack */\n            ret = sf->cur_sp[-1];\n            sf->cur_sp[-1] = JS_UNDEFINED;\n            if (JS_VALUE_GET_INT(func_ret) == FUNC_RET_YIELD_STAR) {\n                s->state = JS_GENERATOR_STATE_SUSPENDED_YIELD_STAR;\n                /* return (value, done) object */\n                *pdone = 2;\n            } else {\n                *pdone = FALSE;\n            }\n        } else {\n            /* end of iterator */\n            ret = sf->cur_sp[-1];\n            sf->cur_sp[-1] = JS_UNDEFINED;\n            JS_FreeValue(ctx, func_ret);\n            free_generator_stack(ctx, s);\n        }\n        break;\n    case JS_GENERATOR_STATE_COMPLETED:\n    done:\n        /* execution is finished */\n        switch(magic) {\n        default:\n        case GEN_MAGIC_NEXT:\n            ret = JS_UNDEFINED;\n            break;\n        case GEN_MAGIC_RETURN:\n            ret = JS_DupValue(ctx, argv[0]);\n            break;\n        case GEN_MAGIC_THROW:\n            ret = JS_Throw(ctx, JS_DupValue(ctx, argv[0]));\n            break;\n        }\n        break;\n    case JS_GENERATOR_STATE_EXECUTING:\n        ret = JS_ThrowTypeError(ctx, \"cannot invoke a running generator\");\n        break;\n    }\n    return ret;\n}\n\nstatic JSValue js_generator_function_call(JSContext *ctx, JSValueConst func_obj,\n                                          JSValueConst this_obj,\n                                          int argc, JSValueConst *argv,\n                                          int flags)\n{\n    JSValue obj, func_ret;\n    JSGeneratorData *s;\n\n    s = js_mallocz(ctx, sizeof(*s));\n    if (!s)\n        return JS_EXCEPTION;\n    s->state = JS_GENERATOR_STATE_SUSPENDED_START;\n    if (async_func_init(ctx, &s->func_state, func_obj, this_obj, argc, argv)) {\n        s->state = JS_GENERATOR_STATE_COMPLETED;\n        goto fail;\n    }\n\n    /* execute the function up to 'OP_initial_yield' */\n    func_ret = async_func_resume(ctx, &s->func_state);\n    if (JS_IsException(func_ret))\n        goto fail;\n    JS_FreeValue(ctx, func_ret);\n\n    obj = js_create_from_ctor(ctx, func_obj, JS_CLASS_GENERATOR);\n    if (JS_IsException(obj))\n        goto fail;\n    JS_SetOpaque(obj, s);\n    return obj;\n fail:\n    free_generator_stack_rt(ctx->rt, s);\n    js_free(ctx, s);\n    return JS_EXCEPTION;\n}\n\n/* AsyncFunction */\n\nstatic void js_async_function_terminate(JSRuntime *rt, JSAsyncFunctionData *s)\n{\n    if (s->is_active) {\n        async_func_free(rt, &s->func_state);\n        s->is_active = FALSE;\n    }\n}\n\nstatic void js_async_function_free0(JSRuntime *rt, JSAsyncFunctionData *s)\n{\n    js_async_function_terminate(rt, s);\n    JS_FreeValueRT(rt, s->resolving_funcs[0]);\n    JS_FreeValueRT(rt, s->resolving_funcs[1]);\n    remove_gc_object(&s->header);\n    js_free_rt(rt, s);\n}\n\nstatic void js_async_function_free(JSRuntime *rt, JSAsyncFunctionData *s)\n{\n    if (--s->header.ref_count == 0) {\n        js_async_function_free0(rt, s);\n    }\n}\n\nstatic void js_async_function_resolve_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSAsyncFunctionData *s = p->u.async_function_data;\n    if (s) {\n        js_async_function_free(rt, s);\n    }\n}\n\nstatic void js_async_function_resolve_mark(JSRuntime *rt, JSValueConst val,\n                                           JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSAsyncFunctionData *s = p->u.async_function_data;\n    if (s) {\n        mark_func(rt, &s->header);\n    }\n}\n\nstatic int js_async_function_resolve_create(JSContext *ctx,\n                                            JSAsyncFunctionData *s,\n                                            JSValue *resolving_funcs)\n{\n    int i;\n    JSObject *p;\n\n    for(i = 0; i < 2; i++) {\n        resolving_funcs[i] =\n            JS_NewObjectProtoClass(ctx, ctx->function_proto,\n                                   JS_CLASS_ASYNC_FUNCTION_RESOLVE + i);\n        if (JS_IsException(resolving_funcs[i])) {\n            if (i == 1)\n                JS_FreeValue(ctx, resolving_funcs[0]);\n            return -1;\n        }\n        p = JS_VALUE_GET_OBJ(resolving_funcs[i]);\n        s->header.ref_count++;\n        p->u.async_function_data = s;\n    }\n    return 0;\n}\n\nstatic void js_async_function_resume(JSContext *ctx, JSAsyncFunctionData *s)\n{\n    JSValue func_ret, ret2;\n\n    func_ret = async_func_resume(ctx, &s->func_state);\n    if (JS_IsException(func_ret)) {\n        JSValue error;\n    fail:\n        error = JS_GetException(ctx);\n        ret2 = JS_Call(ctx, s->resolving_funcs[1], JS_UNDEFINED,\n                       1, (JSValueConst *)&error);\n        JS_FreeValue(ctx, error);\n        js_async_function_terminate(ctx->rt, s);\n        JS_FreeValue(ctx, ret2); /* XXX: what to do if exception ? */\n    } else {\n        JSValue value;\n        value = s->func_state.frame.cur_sp[-1];\n        s->func_state.frame.cur_sp[-1] = JS_UNDEFINED;\n        if (JS_IsUndefined(func_ret)) {\n            /* function returned */\n            ret2 = JS_Call(ctx, s->resolving_funcs[0], JS_UNDEFINED,\n                           1, (JSValueConst *)&value);\n            JS_FreeValue(ctx, ret2); /* XXX: what to do if exception ? */\n            JS_FreeValue(ctx, value);\n            js_async_function_terminate(ctx->rt, s);\n        } else {\n            JSValue promise, resolving_funcs[2], resolving_funcs1[2];\n            int i, res;\n\n            /* await */\n            JS_FreeValue(ctx, func_ret); /* not used */\n            promise = js_promise_resolve(ctx, ctx->promise_ctor,\n                                         1, (JSValueConst *)&value, 0);\n            JS_FreeValue(ctx, value);\n            if (JS_IsException(promise))\n                goto fail;\n            if (js_async_function_resolve_create(ctx, s, resolving_funcs)) {\n                JS_FreeValue(ctx, promise);\n                goto fail;\n            }\n\n            /* Note: no need to create 'thrownawayCapability' as in\n               the spec */\n            for(i = 0; i < 2; i++)\n                resolving_funcs1[i] = JS_UNDEFINED;\n            res = perform_promise_then(ctx, promise,\n                                       (JSValueConst *)resolving_funcs,\n                                       (JSValueConst *)resolving_funcs1);\n            JS_FreeValue(ctx, promise);\n            for(i = 0; i < 2; i++)\n                JS_FreeValue(ctx, resolving_funcs[i]);\n            if (res)\n                goto fail;\n        }\n    }\n}\n\nstatic JSValue js_async_function_resolve_call(JSContext *ctx,\n                                              JSValueConst func_obj,\n                                              JSValueConst this_obj,\n                                              int argc, JSValueConst *argv,\n                                              int flags)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(func_obj);\n    JSAsyncFunctionData *s = p->u.async_function_data;\n    BOOL is_reject = p->class_id - JS_CLASS_ASYNC_FUNCTION_RESOLVE;\n    JSValueConst arg;\n\n    if (argc > 0)\n        arg = argv[0];\n    else\n        arg = JS_UNDEFINED;\n    s->func_state.throw_flag = is_reject;\n    if (is_reject) {\n        JS_Throw(ctx, JS_DupValue(ctx, arg));\n    } else {\n        /* return value of await */\n        s->func_state.frame.cur_sp[-1] = JS_DupValue(ctx, arg);\n    }\n    js_async_function_resume(ctx, s);\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_async_function_call(JSContext *ctx, JSValueConst func_obj,\n                                      JSValueConst this_obj,\n                                      int argc, JSValueConst *argv, int flags)\n{\n    JSValue promise;\n    JSAsyncFunctionData *s;\n\n    s = js_mallocz(ctx, sizeof(*s));\n    if (!s)\n        return JS_EXCEPTION;\n    s->header.ref_count = 1;\n    add_gc_object(ctx->rt, &s->header, JS_GC_OBJ_TYPE_ASYNC_FUNCTION);\n    s->is_active = FALSE;\n    s->resolving_funcs[0] = JS_UNDEFINED;\n    s->resolving_funcs[1] = JS_UNDEFINED;\n\n    promise = JS_NewPromiseCapability(ctx, s->resolving_funcs);\n    if (JS_IsException(promise))\n        goto fail;\n\n    if (async_func_init(ctx, &s->func_state, func_obj, this_obj, argc, argv)) {\n    fail:\n        JS_FreeValue(ctx, promise);\n        js_async_function_free(ctx->rt, s);\n        return JS_EXCEPTION;\n    }\n    s->is_active = TRUE;\n\n    js_async_function_resume(ctx, s);\n\n    js_async_function_free(ctx->rt, s);\n\n    return promise;\n}\n\n/* AsyncGenerator */\n\ntypedef enum JSAsyncGeneratorStateEnum {\n    JS_ASYNC_GENERATOR_STATE_SUSPENDED_START,\n    JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD,\n    JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD_STAR,\n    JS_ASYNC_GENERATOR_STATE_EXECUTING,\n    JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN,\n    JS_ASYNC_GENERATOR_STATE_COMPLETED,\n} JSAsyncGeneratorStateEnum;\n\ntypedef struct JSAsyncGeneratorRequest {\n    struct list_head link;\n    /* completion */\n    int completion_type; /* GEN_MAGIC_x */\n    JSValue result;\n    /* promise capability */\n    JSValue promise;\n    JSValue resolving_funcs[2];\n} JSAsyncGeneratorRequest;\n\ntypedef struct JSAsyncGeneratorData {\n    JSObject *generator; /* back pointer to the object (const) */\n    JSAsyncGeneratorStateEnum state;\n    JSAsyncFunctionState func_state;\n    struct list_head queue; /* list of JSAsyncGeneratorRequest.link */\n} JSAsyncGeneratorData;\n\nstatic void js_async_generator_free(JSRuntime *rt,\n                                    JSAsyncGeneratorData *s)\n{\n    struct list_head *el, *el1;\n    JSAsyncGeneratorRequest *req;\n\n    list_for_each_safe(el, el1, &s->queue) {\n        req = list_entry(el, JSAsyncGeneratorRequest, link);\n        JS_FreeValueRT(rt, req->result);\n        JS_FreeValueRT(rt, req->promise);\n        JS_FreeValueRT(rt, req->resolving_funcs[0]);\n        JS_FreeValueRT(rt, req->resolving_funcs[1]);\n        js_free_rt(rt, req);\n    }\n    if (s->state != JS_ASYNC_GENERATOR_STATE_COMPLETED &&\n        s->state != JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN) {\n        async_func_free(rt, &s->func_state);\n    }\n    js_free_rt(rt, s);\n}\n\nstatic void js_async_generator_finalizer(JSRuntime *rt, JSValue obj)\n{\n    JSAsyncGeneratorData *s = JS_GetOpaque(obj, JS_CLASS_ASYNC_GENERATOR);\n\n    if (s) {\n        js_async_generator_free(rt, s);\n    }\n}\n\nstatic void js_async_generator_mark(JSRuntime *rt, JSValueConst val,\n                                    JS_MarkFunc *mark_func)\n{\n    JSAsyncGeneratorData *s = JS_GetOpaque(val, JS_CLASS_ASYNC_GENERATOR);\n    struct list_head *el;\n    JSAsyncGeneratorRequest *req;\n    if (s) {\n        list_for_each(el, &s->queue) {\n            req = list_entry(el, JSAsyncGeneratorRequest, link);\n            JS_MarkValue(rt, req->result, mark_func);\n            JS_MarkValue(rt, req->promise, mark_func);\n            JS_MarkValue(rt, req->resolving_funcs[0], mark_func);\n            JS_MarkValue(rt, req->resolving_funcs[1], mark_func);\n        }\n        if (s->state != JS_ASYNC_GENERATOR_STATE_COMPLETED &&\n            s->state != JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN) {\n            async_func_mark(rt, &s->func_state, mark_func);\n        }\n    }\n}\n\nstatic JSValue js_async_generator_resolve_function(JSContext *ctx,\n                                          JSValueConst this_obj,\n                                          int argc, JSValueConst *argv,\n                                          int magic, JSValue *func_data);\n\nstatic int js_async_generator_resolve_function_create(JSContext *ctx,\n                                                      JSValueConst generator,\n                                                      JSValue *resolving_funcs,\n                                                      BOOL is_resume_next)\n{\n    int i;\n    JSValue func;\n\n    for(i = 0; i < 2; i++) {\n        func = JS_NewCFunctionData(ctx, js_async_generator_resolve_function, 1,\n                                   i + is_resume_next * 2, 1, &generator);\n        if (JS_IsException(func)) {\n            if (i == 1)\n                JS_FreeValue(ctx, resolving_funcs[0]);\n            return -1;\n        }\n        resolving_funcs[i] = func;\n    }\n    return 0;\n}\n\nstatic int js_async_generator_await(JSContext *ctx,\n                                    JSAsyncGeneratorData *s,\n                                    JSValueConst value)\n{\n    JSValue promise, resolving_funcs[2], resolving_funcs1[2];\n    int i, res;\n\n    promise = js_promise_resolve(ctx, ctx->promise_ctor,\n                                 1, &value, 0);\n    if (JS_IsException(promise))\n        goto fail;\n\n    if (js_async_generator_resolve_function_create(ctx, JS_MKPTR(JS_TAG_OBJECT, s->generator),\n                                                   resolving_funcs, FALSE)) {\n        JS_FreeValue(ctx, promise);\n        goto fail;\n    }\n\n    /* Note: no need to create 'thrownawayCapability' as in\n       the spec */\n    for(i = 0; i < 2; i++)\n        resolving_funcs1[i] = JS_UNDEFINED;\n    res = perform_promise_then(ctx, promise,\n                               (JSValueConst *)resolving_funcs,\n                               (JSValueConst *)resolving_funcs1);\n    JS_FreeValue(ctx, promise);\n    for(i = 0; i < 2; i++)\n        JS_FreeValue(ctx, resolving_funcs[i]);\n    if (res)\n        goto fail;\n    return 0;\n fail:\n    return -1;\n}\n\nstatic void js_async_generator_resolve_or_reject(JSContext *ctx,\n                                                 JSAsyncGeneratorData *s,\n                                                 JSValueConst result,\n                                                 int is_reject)\n{\n    JSAsyncGeneratorRequest *next;\n    JSValue ret;\n\n    next = list_entry(s->queue.next, JSAsyncGeneratorRequest, link);\n    list_del(&next->link);\n    ret = JS_Call(ctx, next->resolving_funcs[is_reject], JS_UNDEFINED, 1,\n                  &result);\n    JS_FreeValue(ctx, ret);\n    JS_FreeValue(ctx, next->result);\n    JS_FreeValue(ctx, next->promise);\n    JS_FreeValue(ctx, next->resolving_funcs[0]);\n    JS_FreeValue(ctx, next->resolving_funcs[1]);\n    js_free(ctx, next);\n}\n\nstatic void js_async_generator_resolve(JSContext *ctx,\n                                       JSAsyncGeneratorData *s,\n                                       JSValueConst value,\n                                       BOOL done)\n{\n    JSValue result;\n    result = js_create_iterator_result(ctx, JS_DupValue(ctx, value), done);\n    /* XXX: better exception handling ? */\n    js_async_generator_resolve_or_reject(ctx, s, result, 0);\n    JS_FreeValue(ctx, result);\n }\n\nstatic void js_async_generator_reject(JSContext *ctx,\n                                       JSAsyncGeneratorData *s,\n                                       JSValueConst exception)\n{\n    js_async_generator_resolve_or_reject(ctx, s, exception, 1);\n}\n\nstatic void js_async_generator_complete(JSContext *ctx,\n                                        JSAsyncGeneratorData *s)\n{\n    if (s->state != JS_ASYNC_GENERATOR_STATE_COMPLETED) {\n        s->state = JS_ASYNC_GENERATOR_STATE_COMPLETED;\n        async_func_free(ctx->rt, &s->func_state);\n    }\n}\n\nstatic int js_async_generator_completed_return(JSContext *ctx,\n                                               JSAsyncGeneratorData *s,\n                                               JSValueConst value)\n{\n    JSValue promise, resolving_funcs[2], resolving_funcs1[2];\n    int res;\n\n    promise = js_promise_resolve(ctx, ctx->promise_ctor,\n                                 1, (JSValueConst *)&value, 0);\n    if (JS_IsException(promise))\n        return -1;\n    if (js_async_generator_resolve_function_create(ctx,\n                                                   JS_MKPTR(JS_TAG_OBJECT, s->generator),\n                                                   resolving_funcs1,\n                                                   TRUE)) {\n        JS_FreeValue(ctx, promise);\n        return -1;\n    }\n    resolving_funcs[0] = JS_UNDEFINED;\n    resolving_funcs[1] = JS_UNDEFINED;\n    res = perform_promise_then(ctx, promise,\n                               (JSValueConst *)resolving_funcs1,\n                               (JSValueConst *)resolving_funcs);\n    JS_FreeValue(ctx, resolving_funcs1[0]);\n    JS_FreeValue(ctx, resolving_funcs1[1]);\n    JS_FreeValue(ctx, promise);\n    return res;\n}\n\nstatic void js_async_generator_resume_next(JSContext *ctx,\n                                           JSAsyncGeneratorData *s)\n{\n    JSAsyncGeneratorRequest *next;\n    JSValue func_ret, value;\n\n    for(;;) {\n        if (list_empty(&s->queue))\n            break;\n        next = list_entry(s->queue.next, JSAsyncGeneratorRequest, link);\n        switch(s->state) {\n        case JS_ASYNC_GENERATOR_STATE_EXECUTING:\n            /* only happens when restarting execution after await() */\n            goto resume_exec;\n        case JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN:\n            goto done;\n        case JS_ASYNC_GENERATOR_STATE_SUSPENDED_START:\n            if (next->completion_type == GEN_MAGIC_NEXT) {\n                goto exec_no_arg;\n            } else {\n                js_async_generator_complete(ctx, s);\n            }\n            break;\n        case JS_ASYNC_GENERATOR_STATE_COMPLETED:\n            if (next->completion_type == GEN_MAGIC_NEXT) {\n                js_async_generator_resolve(ctx, s, JS_UNDEFINED, TRUE);\n            } else if (next->completion_type == GEN_MAGIC_RETURN) {\n                s->state = JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN;\n                js_async_generator_completed_return(ctx, s, next->result);\n                goto done;\n            } else {\n                js_async_generator_reject(ctx, s, next->result);\n            }\n            goto done;\n        case JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD:\n        case JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD_STAR:\n            value = JS_DupValue(ctx, next->result);\n            if (next->completion_type == GEN_MAGIC_THROW &&\n                s->state == JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD) {\n                JS_Throw(ctx, value);\n                s->func_state.throw_flag = TRUE;\n            } else {\n                /* 'yield' returns a value. 'yield *' also returns a value\n                   in case the 'throw' method is called */\n                s->func_state.frame.cur_sp[-1] = value;\n                s->func_state.frame.cur_sp[0] =\n                    JS_NewInt32(ctx, next->completion_type);\n                s->func_state.frame.cur_sp++;\n            exec_no_arg:\n                s->func_state.throw_flag = FALSE;\n            }\n            s->state = JS_ASYNC_GENERATOR_STATE_EXECUTING;\n        resume_exec:\n            func_ret = async_func_resume(ctx, &s->func_state);\n            if (JS_IsException(func_ret)) {\n                value = JS_GetException(ctx);\n                js_async_generator_complete(ctx, s);\n                js_async_generator_reject(ctx, s, value);\n                JS_FreeValue(ctx, value);\n            } else if (JS_VALUE_GET_TAG(func_ret) == JS_TAG_INT) {\n                int func_ret_code;\n                value = s->func_state.frame.cur_sp[-1];\n                s->func_state.frame.cur_sp[-1] = JS_UNDEFINED;\n                func_ret_code = JS_VALUE_GET_INT(func_ret);\n                switch(func_ret_code) {\n                case FUNC_RET_YIELD:\n                case FUNC_RET_YIELD_STAR:\n                    if (func_ret_code == FUNC_RET_YIELD_STAR)\n                        s->state = JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD_STAR;\n                    else\n                        s->state = JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD;\n                    js_async_generator_resolve(ctx, s, value, FALSE);\n                    JS_FreeValue(ctx, value);\n                    break;\n                case FUNC_RET_AWAIT:\n                    js_async_generator_await(ctx, s, value);\n                    JS_FreeValue(ctx, value);\n                    goto done;\n                default:\n                    abort();\n                }\n            } else {\n                assert(JS_IsUndefined(func_ret));\n                /* end of function */\n                value = s->func_state.frame.cur_sp[-1];\n                s->func_state.frame.cur_sp[-1] = JS_UNDEFINED;\n                js_async_generator_complete(ctx, s);\n                js_async_generator_resolve(ctx, s, value, TRUE);\n                JS_FreeValue(ctx, value);\n            }\n            break;\n        default:\n            abort();\n        }\n    }\n done: ;\n}\n\nstatic JSValue js_async_generator_resolve_function(JSContext *ctx,\n                                                   JSValueConst this_obj,\n                                                   int argc, JSValueConst *argv,\n                                                   int magic, JSValue *func_data)\n{\n    BOOL is_reject = magic & 1;\n    JSAsyncGeneratorData *s = JS_GetOpaque(func_data[0], JS_CLASS_ASYNC_GENERATOR);\n    JSValueConst arg = argv[0];\n\n    /* XXX: what if s == NULL */\n\n    if (magic >= 2) {\n        /* resume next case in AWAITING_RETURN state */\n        assert(s->state == JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN ||\n               s->state == JS_ASYNC_GENERATOR_STATE_COMPLETED);\n        s->state = JS_ASYNC_GENERATOR_STATE_COMPLETED;\n        if (is_reject) {\n            js_async_generator_reject(ctx, s, arg);\n        } else {\n            js_async_generator_resolve(ctx, s, arg, TRUE);\n        }\n    } else {\n        /* restart function execution after await() */\n        assert(s->state == JS_ASYNC_GENERATOR_STATE_EXECUTING);\n        s->func_state.throw_flag = is_reject;\n        if (is_reject) {\n            JS_Throw(ctx, JS_DupValue(ctx, arg));\n        } else {\n            /* return value of await */\n            s->func_state.frame.cur_sp[-1] = JS_DupValue(ctx, arg);\n        }\n        js_async_generator_resume_next(ctx, s);\n    }\n    return JS_UNDEFINED;\n}\n\n/* magic = GEN_MAGIC_x */\nstatic JSValue js_async_generator_next(JSContext *ctx, JSValueConst this_val,\n                                       int argc, JSValueConst *argv,\n                                       int magic)\n{\n    JSAsyncGeneratorData *s = JS_GetOpaque(this_val, JS_CLASS_ASYNC_GENERATOR);\n    JSValue promise, resolving_funcs[2];\n    JSAsyncGeneratorRequest *req;\n\n    promise = JS_NewPromiseCapability(ctx, resolving_funcs);\n    if (JS_IsException(promise))\n        return JS_EXCEPTION;\n    if (!s) {\n        JSValue err, res2;\n        JS_ThrowTypeError(ctx, \"not an AsyncGenerator object\");\n        err = JS_GetException(ctx);\n        res2 = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED,\n                       1, (JSValueConst *)&err);\n        JS_FreeValue(ctx, err);\n        JS_FreeValue(ctx, res2);\n        JS_FreeValue(ctx, resolving_funcs[0]);\n        JS_FreeValue(ctx, resolving_funcs[1]);\n        return promise;\n    }\n    req = js_mallocz(ctx, sizeof(*req));\n    if (!req)\n        goto fail;\n    req->completion_type = magic;\n    req->result = JS_DupValue(ctx, argv[0]);\n    req->promise = JS_DupValue(ctx, promise);\n    req->resolving_funcs[0] = resolving_funcs[0];\n    req->resolving_funcs[1] = resolving_funcs[1];\n    list_add_tail(&req->link, &s->queue);\n    if (s->state != JS_ASYNC_GENERATOR_STATE_EXECUTING) {\n        js_async_generator_resume_next(ctx, s);\n    }\n    return promise;\n fail:\n    JS_FreeValue(ctx, resolving_funcs[0]);\n    JS_FreeValue(ctx, resolving_funcs[1]);\n    JS_FreeValue(ctx, promise);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_async_generator_function_call(JSContext *ctx, JSValueConst func_obj,\n                                                JSValueConst this_obj,\n                                                int argc, JSValueConst *argv,\n                                                int flags)\n{\n    JSValue obj, func_ret;\n    JSAsyncGeneratorData *s;\n\n    s = js_mallocz(ctx, sizeof(*s));\n    if (!s)\n        return JS_EXCEPTION;\n    s->state = JS_ASYNC_GENERATOR_STATE_SUSPENDED_START;\n    init_list_head(&s->queue);\n    if (async_func_init(ctx, &s->func_state, func_obj, this_obj, argc, argv)) {\n        s->state = JS_ASYNC_GENERATOR_STATE_COMPLETED;\n        goto fail;\n    }\n\n    /* execute the function up to 'OP_initial_yield' (no yield nor\n       await are possible) */\n    func_ret = async_func_resume(ctx, &s->func_state);\n    if (JS_IsException(func_ret))\n        goto fail;\n    JS_FreeValue(ctx, func_ret);\n\n    obj = js_create_from_ctor(ctx, func_obj, JS_CLASS_ASYNC_GENERATOR);\n    if (JS_IsException(obj))\n        goto fail;\n    s->generator = JS_VALUE_GET_OBJ(obj);\n    JS_SetOpaque(obj, s);\n    return obj;\n fail:\n    js_async_generator_free(ctx->rt, s);\n    return JS_EXCEPTION;\n}\n\n/* JS parser */\n\nenum {\n    TOK_NUMBER = -128,\n    TOK_STRING,\n    TOK_TEMPLATE,\n    TOK_IDENT,\n    TOK_REGEXP,\n    /* warning: order matters (see js_parse_assign_expr) */\n    TOK_MUL_ASSIGN,\n    TOK_DIV_ASSIGN,\n    TOK_MOD_ASSIGN,\n    TOK_PLUS_ASSIGN,\n    TOK_MINUS_ASSIGN,\n    TOK_SHL_ASSIGN,\n    TOK_SAR_ASSIGN,\n    TOK_SHR_ASSIGN,\n    TOK_AND_ASSIGN,\n    TOK_XOR_ASSIGN,\n    TOK_OR_ASSIGN,\n#ifdef CONFIG_BIGNUM\n    TOK_MATH_POW_ASSIGN,\n#endif\n    TOK_POW_ASSIGN,\n    TOK_LAND_ASSIGN,\n    TOK_LOR_ASSIGN,\n    TOK_DOUBLE_QUESTION_MARK_ASSIGN,\n    TOK_DEC,\n    TOK_INC,\n    TOK_SHL,\n    TOK_SAR,\n    TOK_SHR,\n    TOK_LT,\n    TOK_LTE,\n    TOK_GT,\n    TOK_GTE,\n    TOK_EQ,\n    TOK_STRICT_EQ,\n    TOK_NEQ,\n    TOK_STRICT_NEQ,\n    TOK_LAND,\n    TOK_LOR,\n#ifdef CONFIG_BIGNUM\n    TOK_MATH_POW,\n#endif\n    TOK_POW,\n    TOK_ARROW,\n    TOK_ELLIPSIS,\n    TOK_DOUBLE_QUESTION_MARK,\n    TOK_QUESTION_MARK_DOT,\n    TOK_ERROR,\n    TOK_PRIVATE_NAME,\n    TOK_EOF,\n    /* keywords: WARNING: same order as atoms */\n    TOK_NULL, /* must be first */\n    TOK_FALSE,\n    TOK_TRUE,\n    TOK_IF,\n    TOK_ELSE,\n    TOK_RETURN,\n    TOK_VAR,\n    TOK_THIS,\n    TOK_DELETE,\n    TOK_VOID,\n    TOK_TYPEOF,\n    TOK_NEW,\n    TOK_IN,\n    TOK_INSTANCEOF,\n    TOK_DO,\n    TOK_WHILE,\n    TOK_FOR,\n    TOK_BREAK,\n    TOK_CONTINUE,\n    TOK_SWITCH,\n    TOK_CASE,\n    TOK_DEFAULT,\n    TOK_THROW,\n    TOK_TRY,\n    TOK_CATCH,\n    TOK_FINALLY,\n    TOK_FUNCTION,\n    TOK_DEBUGGER,\n    TOK_WITH,\n    /* FutureReservedWord */\n    TOK_CLASS,\n    TOK_CONST,\n    TOK_ENUM,\n    TOK_EXPORT,\n    TOK_EXTENDS,\n    TOK_IMPORT,\n    TOK_SUPER,\n    /* FutureReservedWords when parsing strict mode code */\n    TOK_IMPLEMENTS,\n    TOK_INTERFACE,\n    TOK_LET,\n    TOK_PACKAGE,\n    TOK_PRIVATE,\n    TOK_PROTECTED,\n    TOK_PUBLIC,\n    TOK_STATIC,\n    TOK_YIELD,\n    TOK_AWAIT, /* must be last */\n    TOK_OF,     /* only used for js_parse_skip_parens_token() */\n};\n\n#define TOK_FIRST_KEYWORD   TOK_NULL\n#define TOK_LAST_KEYWORD    TOK_AWAIT\n\n/* unicode code points */\n#define CP_NBSP 0x00a0\n#define CP_BOM  0xfeff\n\n#define CP_LS   0x2028\n#define CP_PS   0x2029\n\ntypedef struct BlockEnv {\n    struct BlockEnv *prev;\n    JSAtom label_name; /* JS_ATOM_NULL if none */\n    int label_break; /* -1 if none */\n    int label_cont; /* -1 if none */\n    int drop_count; /* number of stack elements to drop */\n    int label_finally; /* -1 if none */\n    int scope_level;\n    int has_iterator;\n} BlockEnv;\n\ntypedef struct JSGlobalVar {\n    int cpool_idx; /* if >= 0, index in the constant pool for hoisted\n                      function defintion*/\n    uint8_t force_init : 1; /* force initialization to undefined */\n    uint8_t is_lexical : 1; /* global let/const definition */\n    uint8_t is_const   : 1; /* const definition */\n    int scope_level;    /* scope of definition */\n    JSAtom var_name;  /* variable name */\n} JSGlobalVar;\n\ntypedef struct RelocEntry {\n    struct RelocEntry *next;\n    uint32_t addr; /* address to patch */\n    int size;   /* address size: 1, 2 or 4 bytes */\n} RelocEntry;\n\ntypedef struct JumpSlot {\n    int op;\n    int size;\n    int pos;\n    int label;\n} JumpSlot;\n\ntypedef struct LabelSlot {\n    int ref_count;\n    int pos;    /* phase 1 address, -1 means not resolved yet */\n    int pos2;   /* phase 2 address, -1 means not resolved yet */\n    int addr;   /* phase 3 address, -1 means not resolved yet */\n    RelocEntry *first_reloc;\n} LabelSlot;\n\ntypedef struct LineNumberSlot {\n    uint32_t pc;\n    int line_num;\n} LineNumberSlot;\n\ntypedef enum JSParseFunctionEnum {\n    JS_PARSE_FUNC_STATEMENT,\n    JS_PARSE_FUNC_VAR,\n    JS_PARSE_FUNC_EXPR,\n    JS_PARSE_FUNC_ARROW,\n    JS_PARSE_FUNC_GETTER,\n    JS_PARSE_FUNC_SETTER,\n    JS_PARSE_FUNC_METHOD,\n    JS_PARSE_FUNC_CLASS_CONSTRUCTOR,\n    JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR,\n} JSParseFunctionEnum;\n\ntypedef enum JSParseExportEnum {\n    JS_PARSE_EXPORT_NONE,\n    JS_PARSE_EXPORT_NAMED,\n    JS_PARSE_EXPORT_DEFAULT,\n} JSParseExportEnum;\n\ntypedef struct JSFunctionDef {\n    JSContext *ctx;\n    struct JSFunctionDef *parent;\n    int parent_cpool_idx; /* index in the constant pool of the parent\n                             or -1 if none */\n    int parent_scope_level; /* scope level in parent at point of definition */\n    struct list_head child_list; /* list of JSFunctionDef.link */\n    struct list_head link;\n\n    BOOL is_eval; /* TRUE if eval code */\n    int eval_type; /* only valid if is_eval = TRUE */\n    BOOL is_global_var; /* TRUE if variables are not defined locally:\n                           eval global, eval module or non strict eval */\n    BOOL is_func_expr; /* TRUE if function expression */\n    BOOL has_home_object; /* TRUE if the home object is available */\n    BOOL has_prototype; /* true if a prototype field is necessary */\n    BOOL has_simple_parameter_list;\n    BOOL has_parameter_expressions; /* if true, an argument scope is created */\n    BOOL has_use_strict; /* to reject directive in special cases */\n    BOOL has_eval_call; /* true if the function contains a call to eval() */\n    BOOL has_arguments_binding; /* true if the 'arguments' binding is\n                                   available in the function */\n    BOOL has_this_binding; /* true if the 'this' and new.target binding are\n                              available in the function */\n    BOOL new_target_allowed; /* true if the 'new.target' does not\n                                throw a syntax error */\n    BOOL super_call_allowed; /* true if super() is allowed */\n    BOOL super_allowed; /* true if super. or super[] is allowed */\n    BOOL arguments_allowed; /* true if the 'arguments' identifier is allowed */\n    BOOL is_derived_class_constructor;\n    BOOL in_function_body;\n    BOOL backtrace_barrier;\n    JSFunctionKindEnum func_kind : 8;\n    JSParseFunctionEnum func_type : 8;\n    uint8_t js_mode; /* bitmap of JS_MODE_x */\n    JSAtom func_name; /* JS_ATOM_NULL if no name */\n\n    JSVarDef *vars;\n    int var_size; /* allocated size for vars[] */\n    int var_count;\n    JSVarDef *args;\n    int arg_size; /* allocated size for args[] */\n    int arg_count; /* number of arguments */\n    int defined_arg_count;\n    int var_object_idx; /* -1 if none */\n    int arg_var_object_idx; /* -1 if none (var object for the argument scope) */\n    int arguments_var_idx; /* -1 if none */\n    int arguments_arg_idx; /* argument variable definition in argument scope, \n                              -1 if none */\n    int func_var_idx; /* variable containing the current function (-1\n                         if none, only used if is_func_expr is true) */\n    int eval_ret_idx; /* variable containing the return value of the eval, -1 if none */\n    int this_var_idx; /* variable containg the 'this' value, -1 if none */\n    int new_target_var_idx; /* variable containg the 'new.target' value, -1 if none */\n    int this_active_func_var_idx; /* variable containg the 'this.active_func' value, -1 if none */\n    int home_object_var_idx;\n    BOOL need_home_object;\n    \n    int scope_level;    /* index into fd->scopes if the current lexical scope */\n    int scope_first;    /* index into vd->vars of first lexically scoped variable */\n    int scope_size;     /* allocated size of fd->scopes array */\n    int scope_count;    /* number of entries used in the fd->scopes array */\n    JSVarScope *scopes;\n    JSVarScope def_scope_array[4];\n    int body_scope; /* scope of the body of the function or eval */\n\n    int global_var_count;\n    int global_var_size;\n    JSGlobalVar *global_vars;\n\n    DynBuf byte_code;\n    int last_opcode_pos; /* -1 if no last opcode */\n    int last_opcode_line_num;\n    BOOL use_short_opcodes; /* true if short opcodes are used in byte_code */\n    \n    LabelSlot *label_slots;\n    int label_size; /* allocated size for label_slots[] */\n    int label_count;\n    BlockEnv *top_break; /* break/continue label stack */\n\n    /* constant pool (strings, functions, numbers) */\n    JSValue *cpool;\n    int cpool_count;\n    int cpool_size;\n\n    /* list of variables in the closure */\n    int closure_var_count;\n    int closure_var_size;\n    JSClosureVar *closure_var;\n\n    JumpSlot *jump_slots;\n    int jump_size;\n    int jump_count;\n\n    LineNumberSlot *line_number_slots;\n    int line_number_size;\n    int line_number_count;\n    int line_number_last;\n    int line_number_last_pc;\n\n    /* pc2line table */\n    JSAtom filename;\n    int line_num;\n    DynBuf pc2line;\n\n    char *source;  /* raw source, utf-8 encoded */\n    int source_len;\n\n    JSModuleDef *module; /* != NULL when parsing a module */\n} JSFunctionDef;\n\ntypedef struct JSToken {\n    int val;\n    int line_num;   /* line number of token start */\n    const uint8_t *ptr;\n    union {\n        struct {\n            JSValue str;\n            int sep;\n        } str;\n        struct {\n            JSValue val;\n#ifdef CONFIG_BIGNUM\n            slimb_t exponent; /* may be != 0 only if val is a float */\n#endif\n        } num;\n        struct {\n            JSAtom atom;\n            BOOL has_escape;\n            BOOL is_reserved;\n        } ident;\n        struct {\n            JSValue body;\n            JSValue flags;\n        } regexp;\n    } u;\n} JSToken;\n\ntypedef struct JSParseState {\n    JSContext *ctx;\n    int last_line_num;  /* line number of last token */\n    int line_num;       /* line number of current offset */\n    const char *filename;\n    JSToken token;\n    BOOL got_lf; /* true if got line feed before the current token */\n    const uint8_t *last_ptr;\n    const uint8_t *buf_ptr;\n    const uint8_t *buf_end;\n\n    /* current function code */\n    JSFunctionDef *cur_func;\n    BOOL is_module; /* parsing a module */\n    BOOL allow_html_comments;\n    BOOL ext_json; /* true if accepting JSON superset */\n} JSParseState;\n\ntypedef struct JSOpCode {\n#ifdef DUMP_BYTECODE\n    const char *name;\n#endif\n    uint8_t size; /* in bytes */\n    /* the opcodes remove n_pop items from the top of the stack, then\n       pushes n_push items */\n    uint8_t n_pop;\n    uint8_t n_push;\n    uint8_t fmt;\n} JSOpCode;\n\nstatic const JSOpCode opcode_info[OP_COUNT + (OP_TEMP_END - OP_TEMP_START)] = {\n#define FMT(f)\n#ifdef DUMP_BYTECODE\n#define DEF(id, size, n_pop, n_push, f) { #id, size, n_pop, n_push, OP_FMT_ ## f },\n#else\n#define DEF(id, size, n_pop, n_push, f) { size, n_pop, n_push, OP_FMT_ ## f },\n#endif\n#include \"quickjs-opcode.h\"\n#undef DEF\n#undef FMT\n};\n\n#if SHORT_OPCODES\n/* After the final compilation pass, short opcodes are used. Their\n   opcodes overlap with the temporary opcodes which cannot appear in\n   the final bytecode. Their description is after the temporary\n   opcodes in opcode_info[]. */\n#define short_opcode_info(op)           \\\n    opcode_info[(op) >= OP_TEMP_START ? \\\n                (op) + (OP_TEMP_END - OP_TEMP_START) : (op)]\n#else\n#define short_opcode_info(op) opcode_info[op]\n#endif\n\nstatic __exception int next_token(JSParseState *s);\n\nstatic void free_token(JSParseState *s, JSToken *token)\n{\n    switch(token->val) {\n#ifdef CONFIG_BIGNUM\n    case TOK_NUMBER:\n        JS_FreeValue(s->ctx, token->u.num.val);\n        break;\n#endif\n    case TOK_STRING:\n    case TOK_TEMPLATE:\n        JS_FreeValue(s->ctx, token->u.str.str);\n        break;\n    case TOK_REGEXP:\n        JS_FreeValue(s->ctx, token->u.regexp.body);\n        JS_FreeValue(s->ctx, token->u.regexp.flags);\n        break;\n    case TOK_IDENT:\n    case TOK_PRIVATE_NAME:\n        JS_FreeAtom(s->ctx, token->u.ident.atom);\n        break;\n    default:\n        if (token->val >= TOK_FIRST_KEYWORD &&\n            token->val <= TOK_LAST_KEYWORD) {\n            JS_FreeAtom(s->ctx, token->u.ident.atom);\n        }\n        break;\n    }\n}\n\nstatic void __attribute((unused)) dump_token(JSParseState *s,\n                                             const JSToken *token)\n{\n    switch(token->val) {\n    case TOK_NUMBER:\n        {\n            double d;\n            JS_ToFloat64(s->ctx, &d, token->u.num.val);  /* no exception possible */\n            printf(\"number: %.14g\\n\", d);\n        }\n        break;\n    case TOK_IDENT:\n    dump_atom:\n        {\n            char buf[ATOM_GET_STR_BUF_SIZE];\n            printf(\"ident: '%s'\\n\",\n                   JS_AtomGetStr(s->ctx, buf, sizeof(buf), token->u.ident.atom));\n        }\n        break;\n    case TOK_STRING:\n        {\n            const char *str;\n            /* XXX: quote the string */\n            str = JS_ToCString(s->ctx, token->u.str.str);\n            printf(\"string: '%s'\\n\", str);\n            JS_FreeCString(s->ctx, str);\n        }\n        break;\n    case TOK_TEMPLATE:\n        {\n            const char *str;\n            str = JS_ToCString(s->ctx, token->u.str.str);\n            printf(\"template: `%s`\\n\", str);\n            JS_FreeCString(s->ctx, str);\n        }\n        break;\n    case TOK_REGEXP:\n        {\n            const char *str, *str2;\n            str = JS_ToCString(s->ctx, token->u.regexp.body);\n            str2 = JS_ToCString(s->ctx, token->u.regexp.flags);\n            printf(\"regexp: '%s' '%s'\\n\", str, str2);\n            JS_FreeCString(s->ctx, str);\n            JS_FreeCString(s->ctx, str2);\n        }\n        break;\n    case TOK_EOF:\n        printf(\"eof\\n\");\n        break;\n    default:\n        if (s->token.val >= TOK_NULL && s->token.val <= TOK_LAST_KEYWORD) {\n            goto dump_atom;\n        } else if (s->token.val >= 256) {\n            printf(\"token: %d\\n\", token->val);\n        } else {\n            printf(\"token: '%c'\\n\", token->val);\n        }\n        break;\n    }\n}\n\nint __attribute__((format(printf, 2, 3))) js_parse_error(JSParseState *s, const char *fmt, ...)\n{\n    JSContext *ctx = s->ctx;\n    va_list ap;\n    int backtrace_flags;\n    \n    va_start(ap, fmt);\n    JS_ThrowError2(ctx, JS_SYNTAX_ERROR, fmt, ap, FALSE);\n    va_end(ap);\n    backtrace_flags = 0;\n    if (s->cur_func && s->cur_func->backtrace_barrier)\n        backtrace_flags = JS_BACKTRACE_FLAG_SINGLE_LEVEL;\n    build_backtrace(ctx, ctx->rt->current_exception, s->filename, s->line_num,\n                    backtrace_flags);\n    return -1;\n}\n\nstatic int js_parse_expect(JSParseState *s, int tok)\n{\n    if (s->token.val != tok) {\n        /* XXX: dump token correctly in all cases */\n        return js_parse_error(s, \"expecting '%c'\", tok);\n    }\n    return next_token(s);\n}\n\nstatic int js_parse_expect_semi(JSParseState *s)\n{\n    if (s->token.val != ';') {\n        /* automatic insertion of ';' */\n        if (s->token.val == TOK_EOF || s->token.val == '}' || s->got_lf) {\n            return 0;\n        }\n        return js_parse_error(s, \"expecting '%c'\", ';');\n    }\n    return next_token(s);\n}\n\nstatic int js_parse_error_reserved_identifier(JSParseState *s)\n{\n    char buf1[ATOM_GET_STR_BUF_SIZE];\n    return js_parse_error(s, \"'%s' is a reserved identifier\",\n                          JS_AtomGetStr(s->ctx, buf1, sizeof(buf1),\n                                        s->token.u.ident.atom));\n}\n\nstatic __exception int js_parse_template_part(JSParseState *s, const uint8_t *p)\n{\n    uint32_t c;\n    StringBuffer b_s, *b = &b_s;\n\n    /* p points to the first byte of the template part */\n    if (string_buffer_init(s->ctx, b, 32))\n        goto fail;\n    for(;;) {\n        if (p >= s->buf_end)\n            goto unexpected_eof;\n        c = *p++;\n        if (c == '`') {\n            /* template end part */\n            break;\n        }\n        if (c == '$' && *p == '{') {\n            /* template start or middle part */\n            p++;\n            break;\n        }\n        if (c == '\\\\') {\n            if (string_buffer_putc8(b, c))\n                goto fail;\n            if (p >= s->buf_end)\n                goto unexpected_eof;\n            c = *p++;\n        }\n        /* newline sequences are normalized as single '\\n' bytes */\n        if (c == '\\r') {\n            if (*p == '\\n')\n                p++;\n            c = '\\n';\n        }\n        if (c == '\\n') {\n            s->line_num++;\n        } else if (c >= 0x80) {\n            const uint8_t *p_next;\n            c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);\n            if (c > 0x10FFFF) {\n                js_parse_error(s, \"invalid UTF-8 sequence\");\n                goto fail;\n            }\n            p = p_next;\n        }\n        if (string_buffer_putc(b, c))\n            goto fail;\n    }\n    s->token.val = TOK_TEMPLATE;\n    s->token.u.str.sep = c;\n    s->token.u.str.str = string_buffer_end(b);\n    s->buf_ptr = p;\n    return 0;\n\n unexpected_eof:\n    js_parse_error(s, \"unexpected end of string\");\n fail:\n    string_buffer_free(b);\n    return -1;\n}\n\nstatic __exception int js_parse_string(JSParseState *s, int sep,\n                                       BOOL do_throw, const uint8_t *p,\n                                       JSToken *token, const uint8_t **pp)\n{\n    int ret;\n    uint32_t c;\n    StringBuffer b_s, *b = &b_s;\n\n    /* string */\n    if (string_buffer_init(s->ctx, b, 32))\n        goto fail;\n    for(;;) {\n        if (p >= s->buf_end)\n            goto invalid_char;\n        c = *p;\n        if (c < 0x20) {\n            if (!s->cur_func) {\n                if (do_throw)\n                    js_parse_error(s, \"invalid character in a JSON string\");\n                goto fail;\n            }\n            if (sep == '`') {\n                if (c == '\\r') {\n                    if (p[1] == '\\n')\n                        p++;\n                    c = '\\n';\n                }\n                /* do not update s->line_num */\n            } else if (c == '\\n' || c == '\\r')\n                goto invalid_char;\n        }\n        p++;\n        if (c == sep)\n            break;\n        if (c == '$' && *p == '{' && sep == '`') {\n            /* template start or middle part */\n            p++;\n            break;\n        }\n        if (c == '\\\\') {\n            c = *p;\n            /* XXX: need a specific JSON case to avoid\n               accepting invalid escapes */\n            switch(c) {\n            case '\\0':\n                if (p >= s->buf_end)\n                    goto invalid_char;\n                p++;\n                break;\n            case '\\'':\n            case '\\\"':\n            case '\\\\':\n                p++;\n                break;\n            case '\\r':  /* accept DOS and MAC newline sequences */\n                if (p[1] == '\\n') {\n                    p++;\n                }\n                /* fall thru */\n            case '\\n':\n                /* ignore escaped newline sequence */\n                p++;\n                if (sep != '`')\n                    s->line_num++;\n                continue;\n            default:\n                if (c >= '0' && c <= '9') {\n                    if (!s->cur_func)\n                        goto invalid_escape; /* JSON case */\n                    if (!(s->cur_func->js_mode & JS_MODE_STRICT) && sep != '`')\n                        goto parse_escape;\n                    if (c == '0' && !(p[1] >= '0' && p[1] <= '9')) {\n                        p++;\n                        c = '\\0';\n                    } else {\n                        if (c >= '8' || sep == '`') {\n                            /* Note: according to ES2021, \\8 and \\9 are not\n                               accepted in strict mode or in templates. */\n                            goto invalid_escape;\n                        } else {\n                            if (do_throw)\n                                js_parse_error(s, \"octal escape sequences are not allowed in strict mode\");\n                        }\n                        goto fail;\n                    }\n                } else if (c >= 0x80) {\n                    const uint8_t *p_next;\n                    c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);\n                    if (c > 0x10FFFF) {\n                        goto invalid_utf8;\n                    }\n                    p = p_next;\n                    /* LS or PS are skipped */\n                    if (c == CP_LS || c == CP_PS)\n                        continue;\n                } else {\n                parse_escape:\n                    ret = lre_parse_escape(&p, TRUE);\n                    if (ret == -1) {\n                    invalid_escape:\n                        if (do_throw)\n                            js_parse_error(s, \"malformed escape sequence in string literal\");\n                        goto fail;\n                    } else if (ret < 0) {\n                        /* ignore the '\\' (could output a warning) */\n                        p++;\n                    } else {\n                        c = ret;\n                    }\n                }\n                break;\n            }\n        } else if (c >= 0x80) {\n            const uint8_t *p_next;\n            c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);\n            if (c > 0x10FFFF)\n                goto invalid_utf8;\n            p = p_next;\n        }\n        if (string_buffer_putc(b, c))\n            goto fail;\n    }\n    token->val = TOK_STRING;\n    token->u.str.sep = c;\n    token->u.str.str = string_buffer_end(b);\n    *pp = p;\n    return 0;\n\n invalid_utf8:\n    if (do_throw)\n        js_parse_error(s, \"invalid UTF-8 sequence\");\n    goto fail;\n invalid_char:\n    if (do_throw)\n        js_parse_error(s, \"unexpected end of string\");\n fail:\n    string_buffer_free(b);\n    return -1;\n}\n\nstatic inline BOOL token_is_pseudo_keyword(JSParseState *s, JSAtom atom) {\n    return s->token.val == TOK_IDENT && s->token.u.ident.atom == atom &&\n        !s->token.u.ident.has_escape;\n}\n\nstatic __exception int js_parse_regexp(JSParseState *s)\n{\n    const uint8_t *p;\n    BOOL in_class;\n    StringBuffer b_s, *b = &b_s;\n    StringBuffer b2_s, *b2 = &b2_s;\n    uint32_t c;\n\n    p = s->buf_ptr;\n    p++;\n    in_class = FALSE;\n    if (string_buffer_init(s->ctx, b, 32))\n        return -1;\n    if (string_buffer_init(s->ctx, b2, 1))\n        goto fail;\n    for(;;) {\n        if (p >= s->buf_end) {\n        eof_error:\n            js_parse_error(s, \"unexpected end of regexp\");\n            goto fail;\n        }\n        c = *p++;\n        if (c == '\\n' || c == '\\r') {\n            goto eol_error;\n        } else if (c == '/') {\n            if (!in_class)\n                break;\n        } else if (c == '[') {\n            in_class = TRUE;\n        } else if (c == ']') {\n            /* XXX: incorrect as the first character in a class */\n            in_class = FALSE;\n        } else if (c == '\\\\') {\n            if (string_buffer_putc8(b, c))\n                goto fail;\n            c = *p++;\n            if (c == '\\n' || c == '\\r')\n                goto eol_error;\n            else if (c == '\\0' && p >= s->buf_end)\n                goto eof_error;\n            else if (c >= 0x80) {\n                const uint8_t *p_next;\n                c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);\n                if (c > 0x10FFFF) {\n                    goto invalid_utf8;\n                }\n                p = p_next;\n                if (c == CP_LS || c == CP_PS)\n                    goto eol_error;\n            }\n        } else if (c >= 0x80) {\n            const uint8_t *p_next;\n            c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);\n            if (c > 0x10FFFF) {\n            invalid_utf8:\n                js_parse_error(s, \"invalid UTF-8 sequence\");\n                goto fail;\n            }\n            p = p_next;\n            /* LS or PS are considered as line terminator */\n            if (c == CP_LS || c == CP_PS) {\n            eol_error:\n                js_parse_error(s, \"unexpected line terminator in regexp\");\n                goto fail;\n            }\n        }\n        if (string_buffer_putc(b, c))\n            goto fail;\n    }\n\n    /* flags */\n    for(;;) {\n        const uint8_t *p_next = p;\n        c = *p_next++;\n        if (c >= 0x80) {\n            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);\n            if (c > 0x10FFFF) {\n                goto invalid_utf8;\n            }\n        }\n        if (!lre_js_is_ident_next(c))\n            break;\n        if (string_buffer_putc(b2, c))\n            goto fail;\n        p = p_next;\n    }\n\n    s->token.val = TOK_REGEXP;\n    s->token.u.regexp.body = string_buffer_end(b);\n    s->token.u.regexp.flags = string_buffer_end(b2);\n    s->buf_ptr = p;\n    return 0;\n fail:\n    string_buffer_free(b);\n    string_buffer_free(b2);\n    return -1;\n}\n\nstatic __exception int ident_realloc(JSContext *ctx, char **pbuf, size_t *psize,\n                                     char *static_buf)\n{\n    char *buf, *new_buf;\n    size_t size, new_size;\n    \n    buf = *pbuf;\n    size = *psize;\n    if (size >= (SIZE_MAX / 3) * 2)\n        new_size = SIZE_MAX;\n    else\n        new_size = size + (size >> 1);\n    if (buf == static_buf) {\n        new_buf = js_malloc(ctx, new_size);\n        if (!new_buf)\n            return -1;\n        memcpy(new_buf, buf, size);\n    } else {\n        new_buf = js_realloc(ctx, buf, new_size);\n        if (!new_buf)\n            return -1;\n    }\n    *pbuf = new_buf;\n    *psize = new_size;\n    return 0;\n}\n\n/* 'c' is the first character. Return JS_ATOM_NULL in case of error */\nstatic JSAtom parse_ident(JSParseState *s, const uint8_t **pp,\n                          BOOL *pident_has_escape, int c, BOOL is_private)\n{\n    const uint8_t *p, *p1;\n    char ident_buf[128], *buf;\n    size_t ident_size, ident_pos;\n    JSAtom atom;\n    \n    p = *pp;\n    buf = ident_buf;\n    ident_size = sizeof(ident_buf);\n    ident_pos = 0;\n    if (is_private)\n        buf[ident_pos++] = '#';\n    for(;;) {\n        p1 = p;\n        \n        if (c < 128) {\n            buf[ident_pos++] = c;\n        } else {\n            ident_pos += unicode_to_utf8((uint8_t*)buf + ident_pos, c);\n        }\n        c = *p1++;\n        if (c == '\\\\' && *p1 == 'u') {\n            c = lre_parse_escape(&p1, TRUE);\n            *pident_has_escape = TRUE;\n        } else if (c >= 128) {\n            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);\n        }\n        if (!lre_js_is_ident_next(c))\n            break;\n        p = p1;\n        if (unlikely(ident_pos >= ident_size - UTF8_CHAR_LEN_MAX)) {\n            if (ident_realloc(s->ctx, &buf, &ident_size, ident_buf)) {\n                atom = JS_ATOM_NULL;\n                goto done;\n            }\n        }\n    }\n    atom = JS_NewAtomLen(s->ctx, buf, ident_pos);\n done:\n    if (unlikely(buf != ident_buf))\n        js_free(s->ctx, buf);\n    *pp = p;\n    return atom;\n}\n\n\nstatic __exception int next_token(JSParseState *s)\n{\n    const uint8_t *p;\n    int c;\n    BOOL ident_has_escape;\n    JSAtom atom;\n    \n    if (js_check_stack_overflow(s->ctx->rt, 0)) {\n        return js_parse_error(s, \"stack overflow\");\n    }\n    \n    free_token(s, &s->token);\n\n    p = s->last_ptr = s->buf_ptr;\n    s->got_lf = FALSE;\n    s->last_line_num = s->token.line_num;\n redo:\n    s->token.line_num = s->line_num;\n    s->token.ptr = p;\n    c = *p;\n    switch(c) {\n    case 0:\n        if (p >= s->buf_end) {\n            s->token.val = TOK_EOF;\n        } else {\n            goto def_token;\n        }\n        break;\n    case '`':\n        if (js_parse_template_part(s, p + 1))\n            goto fail;\n        p = s->buf_ptr;\n        break;\n    case '\\'':\n    case '\\\"':\n        if (js_parse_string(s, c, TRUE, p + 1, &s->token, &p))\n            goto fail;\n        break;\n    case '\\r':  /* accept DOS and MAC newline sequences */\n        if (p[1] == '\\n') {\n            p++;\n        }\n        /* fall thru */\n    case '\\n':\n        p++;\n    line_terminator:\n        s->got_lf = TRUE;\n        s->line_num++;\n        goto redo;\n    case '\\f':\n    case '\\v':\n    case ' ':\n    case '\\t':\n        p++;\n        goto redo;\n    case '/':\n        if (p[1] == '*') {\n            /* comment */\n            p += 2;\n            for(;;) {\n                if (*p == '\\0' && p >= s->buf_end) {\n                    js_parse_error(s, \"unexpected end of comment\");\n                    goto fail;\n                }\n                if (p[0] == '*' && p[1] == '/') {\n                    p += 2;\n                    break;\n                }\n                if (*p == '\\n') {\n                    s->line_num++;\n                    s->got_lf = TRUE; /* considered as LF for ASI */\n                    p++;\n                } else if (*p == '\\r') {\n                    s->got_lf = TRUE; /* considered as LF for ASI */\n                    p++;\n                } else if (*p >= 0x80) {\n                    c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);\n                    if (c == CP_LS || c == CP_PS) {\n                        s->got_lf = TRUE; /* considered as LF for ASI */\n                    } else if (c == -1) {\n                        p++; /* skip invalid UTF-8 */\n                    }\n                } else {\n                    p++;\n                }\n            }\n            goto redo;\n        } else if (p[1] == '/') {\n            /* line comment */\n            p += 2;\n        skip_line_comment:\n            for(;;) {\n                if (*p == '\\0' && p >= s->buf_end)\n                    break;\n                if (*p == '\\r' || *p == '\\n')\n                    break;\n                if (*p >= 0x80) {\n                    c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);\n                    /* LS or PS are considered as line terminator */\n                    if (c == CP_LS || c == CP_PS) {\n                        break;\n                    } else if (c == -1) {\n                        p++; /* skip invalid UTF-8 */\n                    }\n                } else {\n                    p++;\n                }\n            }\n            goto redo;\n        } else if (p[1] == '=') {\n            p += 2;\n            s->token.val = TOK_DIV_ASSIGN;\n        } else {\n            p++;\n            s->token.val = c;\n        }\n        break;\n    case '\\\\':\n        if (p[1] == 'u') {\n            const uint8_t *p1 = p + 1;\n            int c1 = lre_parse_escape(&p1, TRUE);\n            if (c1 >= 0 && lre_js_is_ident_first(c1)) {\n                c = c1;\n                p = p1;\n                ident_has_escape = TRUE;\n                goto has_ident;\n            } else {\n                /* XXX: syntax error? */\n            }\n        }\n        goto def_token;\n    case 'a': case 'b': case 'c': case 'd':\n    case 'e': case 'f': case 'g': case 'h':\n    case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p':\n    case 'q': case 'r': case 's': case 't':\n    case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z': \n    case 'A': case 'B': case 'C': case 'D':\n    case 'E': case 'F': case 'G': case 'H':\n    case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P':\n    case 'Q': case 'R': case 'S': case 'T':\n    case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z': \n    case '_':\n    case '$':\n        /* identifier */\n        p++;\n        ident_has_escape = FALSE;\n    has_ident:\n        atom = parse_ident(s, &p, &ident_has_escape, c, FALSE);\n        if (atom == JS_ATOM_NULL)\n            goto fail;\n        s->token.u.ident.atom = atom;\n        s->token.u.ident.has_escape = ident_has_escape;\n        s->token.u.ident.is_reserved = FALSE;\n        if (s->token.u.ident.atom <= JS_ATOM_LAST_KEYWORD ||\n            (s->token.u.ident.atom <= JS_ATOM_LAST_STRICT_KEYWORD &&\n             (s->cur_func->js_mode & JS_MODE_STRICT)) ||\n            (s->token.u.ident.atom == JS_ATOM_yield &&\n             ((s->cur_func->func_kind & JS_FUNC_GENERATOR) ||\n              (s->cur_func->func_type == JS_PARSE_FUNC_ARROW &&\n               !s->cur_func->in_function_body && s->cur_func->parent &&\n               (s->cur_func->parent->func_kind & JS_FUNC_GENERATOR)))) ||\n            (s->token.u.ident.atom == JS_ATOM_await &&\n             (s->is_module ||\n              (((s->cur_func->func_kind & JS_FUNC_ASYNC) ||\n                (s->cur_func->func_type == JS_PARSE_FUNC_ARROW &&\n                 !s->cur_func->in_function_body && s->cur_func->parent &&\n                 (s->cur_func->parent->func_kind & JS_FUNC_ASYNC))))))) {\n                  if (ident_has_escape) {\n                      s->token.u.ident.is_reserved = TRUE;\n                      s->token.val = TOK_IDENT;\n                  } else {\n                      /* The keywords atoms are pre allocated */\n                      s->token.val = s->token.u.ident.atom - 1 + TOK_FIRST_KEYWORD;\n                  }\n        } else {\n            s->token.val = TOK_IDENT;\n        }\n        break;\n    case '#':\n        /* private name */\n        {\n            const uint8_t *p1;\n            p++;\n            p1 = p;\n            c = *p1++;\n            if (c == '\\\\' && *p1 == 'u') {\n                c = lre_parse_escape(&p1, TRUE);\n            } else if (c >= 128) {\n                c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);\n            }\n            if (!lre_js_is_ident_first(c)) {\n                js_parse_error(s, \"invalid first character of private name\");\n                goto fail;\n            }\n            p = p1;\n            ident_has_escape = FALSE; /* not used */\n            atom = parse_ident(s, &p, &ident_has_escape, c, TRUE);\n            if (atom == JS_ATOM_NULL)\n                goto fail;\n            s->token.u.ident.atom = atom;\n            s->token.val = TOK_PRIVATE_NAME;\n        }\n        break;\n    case '.':\n        if (p[1] == '.' && p[2] == '.') {\n            p += 3;\n            s->token.val = TOK_ELLIPSIS;\n            break;\n        }\n        if (p[1] >= '0' && p[1] <= '9') {\n            goto parse_number;\n        } else {\n            goto def_token;\n        }\n        break;\n    case '0':\n        /* in strict mode, octal literals are not accepted */\n        if (is_digit(p[1]) && (s->cur_func->js_mode & JS_MODE_STRICT)) {\n            js_parse_error(s, \"octal literals are deprecated in strict mode\");\n            goto fail;\n        }\n        goto parse_number;\n    case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8':\n    case '9': \n        /* number */\n    parse_number:\n        {\n            JSValue ret;\n            const uint8_t *p1;\n            int flags, radix;\n            flags = ATOD_ACCEPT_BIN_OCT | ATOD_ACCEPT_LEGACY_OCTAL |\n                ATOD_ACCEPT_UNDERSCORES;\n#ifdef CONFIG_BIGNUM\n            flags |= ATOD_ACCEPT_SUFFIX;\n            if (s->cur_func->js_mode & JS_MODE_MATH) {\n                flags |= ATOD_MODE_BIGINT;\n                if (s->cur_func->js_mode & JS_MODE_MATH)\n                    flags |= ATOD_TYPE_BIG_FLOAT;\n            }\n#endif\n            radix = 0;\n#ifdef CONFIG_BIGNUM\n            s->token.u.num.exponent = 0;\n            ret = js_atof2(s->ctx, (const char *)p, (const char **)&p, radix,\n                           flags, &s->token.u.num.exponent);\n#else\n            ret = js_atof(s->ctx, (const char *)p, (const char **)&p, radix,\n                          flags);\n#endif\n            if (JS_IsException(ret))\n                goto fail;\n            /* reject `10instanceof Number` */\n            if (JS_VALUE_IS_NAN(ret) ||\n                lre_js_is_ident_next(unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1))) {\n                JS_FreeValue(s->ctx, ret);\n                js_parse_error(s, \"invalid number literal\");\n                goto fail;\n            }\n            s->token.val = TOK_NUMBER;\n            s->token.u.num.val = ret;\n        }\n        break;\n    case '*':\n        if (p[1] == '=') {\n            p += 2;\n            s->token.val = TOK_MUL_ASSIGN;\n        } else if (p[1] == '*') {\n            if (p[2] == '=') {\n                p += 3;\n                s->token.val = TOK_POW_ASSIGN;\n            } else {\n                p += 2;\n                s->token.val = TOK_POW;\n            }\n        } else {\n            goto def_token;\n        }\n        break;\n    case '%':\n        if (p[1] == '=') {\n            p += 2;\n            s->token.val = TOK_MOD_ASSIGN;\n        } else {\n            goto def_token;\n        }\n        break;\n    case '+':\n        if (p[1] == '=') {\n            p += 2;\n            s->token.val = TOK_PLUS_ASSIGN;\n        } else if (p[1] == '+') {\n            p += 2;\n            s->token.val = TOK_INC;\n        } else {\n            goto def_token;\n        }\n        break;\n    case '-':\n        if (p[1] == '=') {\n            p += 2;\n            s->token.val = TOK_MINUS_ASSIGN;\n        } else if (p[1] == '-') {\n            if (s->allow_html_comments &&\n                p[2] == '>' && s->last_line_num != s->line_num) {\n                /* Annex B: `-->` at beginning of line is an html comment end.\n                   It extends to the end of the line.\n                 */\n                goto skip_line_comment;\n            }\n            p += 2;\n            s->token.val = TOK_DEC;\n        } else {\n            goto def_token;\n        }\n        break;\n    case '<':\n        if (p[1] == '=') {\n            p += 2;\n            s->token.val = TOK_LTE;\n        } else if (p[1] == '<') {\n            if (p[2] == '=') {\n                p += 3;\n                s->token.val = TOK_SHL_ASSIGN;\n            } else {\n                p += 2;\n                s->token.val = TOK_SHL;\n            }\n        } else if (s->allow_html_comments &&\n                   p[1] == '!' && p[2] == '-' && p[3] == '-') {\n            /* Annex B: handle `<!--` single line html comments */\n            goto skip_line_comment;\n        } else {\n            goto def_token;\n        }\n        break;\n    case '>':\n        if (p[1] == '=') {\n            p += 2;\n            s->token.val = TOK_GTE;\n        } else if (p[1] == '>') {\n            if (p[2] == '>') {\n                if (p[3] == '=') {\n                    p += 4;\n                    s->token.val = TOK_SHR_ASSIGN;\n                } else {\n                    p += 3;\n                    s->token.val = TOK_SHR;\n                }\n            } else if (p[2] == '=') {\n                p += 3;\n                s->token.val = TOK_SAR_ASSIGN;\n            } else {\n                p += 2;\n                s->token.val = TOK_SAR;\n            }\n        } else {\n            goto def_token;\n        }\n        break;\n    case '=':\n        if (p[1] == '=') {\n            if (p[2] == '=') {\n                p += 3;\n                s->token.val = TOK_STRICT_EQ;\n            } else {\n                p += 2;\n                s->token.val = TOK_EQ;\n            }\n        } else if (p[1] == '>') {\n            p += 2;\n            s->token.val = TOK_ARROW;\n        } else {\n            goto def_token;\n        }\n        break;\n    case '!':\n        if (p[1] == '=') {\n            if (p[2] == '=') {\n                p += 3;\n                s->token.val = TOK_STRICT_NEQ;\n            } else {\n                p += 2;\n                s->token.val = TOK_NEQ;\n            }\n        } else {\n            goto def_token;\n        }\n        break;\n    case '&':\n        if (p[1] == '=') {\n            p += 2;\n            s->token.val = TOK_AND_ASSIGN;\n        } else if (p[1] == '&') {\n            if (p[2] == '=') {\n                p += 3;\n                s->token.val = TOK_LAND_ASSIGN;\n            } else {\n                p += 2;\n                s->token.val = TOK_LAND;\n            }\n        } else {\n            goto def_token;\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n        /* in math mode, '^' is the power operator. '^^' is always the\n           xor operator and '**' is always the power operator */\n    case '^':\n        if (p[1] == '=') {\n            p += 2;\n            if (s->cur_func->js_mode & JS_MODE_MATH)\n                s->token.val = TOK_MATH_POW_ASSIGN;\n            else\n                s->token.val = TOK_XOR_ASSIGN;\n        } else if (p[1] == '^') {\n            if (p[2] == '=') {\n                p += 3;\n                s->token.val = TOK_XOR_ASSIGN;\n            } else {\n                p += 2;\n                s->token.val = '^';\n            }\n        } else {\n            p++;\n            if (s->cur_func->js_mode & JS_MODE_MATH)\n                s->token.val = TOK_MATH_POW;\n            else\n                s->token.val = '^';\n        }\n        break;\n#else\n    case '^':\n        if (p[1] == '=') {\n            p += 2;\n            s->token.val = TOK_XOR_ASSIGN;\n        } else {\n            goto def_token;\n        }\n        break;\n#endif\n    case '|':\n        if (p[1] == '=') {\n            p += 2;\n            s->token.val = TOK_OR_ASSIGN;\n        } else if (p[1] == '|') {\n            if (p[2] == '=') {\n                p += 3;\n                s->token.val = TOK_LOR_ASSIGN;\n            } else {\n                p += 2;\n                s->token.val = TOK_LOR;\n            }\n        } else {\n            goto def_token;\n        }\n        break;\n    case '?':\n        if (p[1] == '?') {\n            if (p[2] == '=') {\n                p += 3;\n                s->token.val = TOK_DOUBLE_QUESTION_MARK_ASSIGN;\n            } else {\n                p += 2;\n                s->token.val = TOK_DOUBLE_QUESTION_MARK;\n            }\n        } else if (p[1] == '.' && !(p[2] >= '0' && p[2] <= '9')) {\n            p += 2;\n            s->token.val = TOK_QUESTION_MARK_DOT;\n        } else {\n            goto def_token;\n        }\n        break;\n    default:\n        if (c >= 128) {\n            /* unicode value */\n            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);\n            switch(c) {\n            case CP_PS:\n            case CP_LS:\n                /* XXX: should avoid incrementing line_number, but\n                   needed to handle HTML comments */\n                goto line_terminator; \n            default:\n                if (lre_is_space(c)) {\n                    goto redo;\n                } else if (lre_js_is_ident_first(c)) {\n                    ident_has_escape = FALSE;\n                    goto has_ident;\n                } else {\n                    js_parse_error(s, \"unexpected character\");\n                    goto fail;\n                }\n            }\n        }\n    def_token:\n        s->token.val = c;\n        p++;\n        break;\n    }\n    s->buf_ptr = p;\n\n    //    dump_token(s, &s->token);\n    return 0;\n\n fail:\n    s->token.val = TOK_ERROR;\n    return -1;\n}\n\n/* 'c' is the first character. Return JS_ATOM_NULL in case of error */\nstatic JSAtom json_parse_ident(JSParseState *s, const uint8_t **pp, int c)\n{\n    const uint8_t *p;\n    char ident_buf[128], *buf;\n    size_t ident_size, ident_pos;\n    JSAtom atom;\n    \n    p = *pp;\n    buf = ident_buf;\n    ident_size = sizeof(ident_buf);\n    ident_pos = 0;\n    for(;;) {\n        buf[ident_pos++] = c;\n        c = *p;\n        if (c >= 128 ||\n            !((lre_id_continue_table_ascii[c >> 5] >> (c & 31)) & 1))\n            break;\n        p++;\n        if (unlikely(ident_pos >= ident_size - UTF8_CHAR_LEN_MAX)) {\n            if (ident_realloc(s->ctx, &buf, &ident_size, ident_buf)) {\n                atom = JS_ATOM_NULL;\n                goto done;\n            }\n        }\n    }\n    atom = JS_NewAtomLen(s->ctx, buf, ident_pos);\n done:\n    if (unlikely(buf != ident_buf))\n        js_free(s->ctx, buf);\n    *pp = p;\n    return atom;\n}\n\nstatic __exception int json_next_token(JSParseState *s)\n{\n    const uint8_t *p;\n    int c;\n    JSAtom atom;\n    \n    if (js_check_stack_overflow(s->ctx->rt, 0)) {\n        return js_parse_error(s, \"stack overflow\");\n    }\n    \n    free_token(s, &s->token);\n\n    p = s->last_ptr = s->buf_ptr;\n    s->last_line_num = s->token.line_num;\n redo:\n    s->token.line_num = s->line_num;\n    s->token.ptr = p;\n    c = *p;\n    switch(c) {\n    case 0:\n        if (p >= s->buf_end) {\n            s->token.val = TOK_EOF;\n        } else {\n            goto def_token;\n        }\n        break;\n    case '\\'':\n        if (!s->ext_json) {\n            /* JSON does not accept single quoted strings */\n            goto def_token;\n        }\n        /* fall through */\n    case '\\\"':\n        if (js_parse_string(s, c, TRUE, p + 1, &s->token, &p))\n            goto fail;\n        break;\n    case '\\r':  /* accept DOS and MAC newline sequences */\n        if (p[1] == '\\n') {\n            p++;\n        }\n        /* fall thru */\n    case '\\n':\n        p++;\n        s->line_num++;\n        goto redo;\n    case '\\f':\n    case '\\v':\n        if (!s->ext_json) {\n            /* JSONWhitespace does not match <VT>, nor <FF> */\n            goto def_token;\n        }\n        /* fall through */\n    case ' ':\n    case '\\t':\n        p++;\n        goto redo;\n    case '/':\n        if (!s->ext_json) {\n            /* JSON does not accept comments */\n            goto def_token;\n        }\n        if (p[1] == '*') {\n            /* comment */\n            p += 2;\n            for(;;) {\n                if (*p == '\\0' && p >= s->buf_end) {\n                    js_parse_error(s, \"unexpected end of comment\");\n                    goto fail;\n                }\n                if (p[0] == '*' && p[1] == '/') {\n                    p += 2;\n                    break;\n                }\n                if (*p == '\\n') {\n                    s->line_num++;\n                    p++;\n                } else if (*p == '\\r') {\n                    p++;\n                } else if (*p >= 0x80) {\n                    c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);\n                    if (c == -1) {\n                        p++; /* skip invalid UTF-8 */\n                    }\n                } else {\n                    p++;\n                }\n            }\n            goto redo;\n        } else if (p[1] == '/') {\n            /* line comment */\n            p += 2;\n            for(;;) {\n                if (*p == '\\0' && p >= s->buf_end)\n                    break;\n                if (*p == '\\r' || *p == '\\n')\n                    break;\n                if (*p >= 0x80) {\n                    c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);\n                    /* LS or PS are considered as line terminator */\n                    if (c == CP_LS || c == CP_PS) {\n                        break;\n                    } else if (c == -1) {\n                        p++; /* skip invalid UTF-8 */\n                    }\n                } else {\n                    p++;\n                }\n            }\n            goto redo;\n        } else {\n            goto def_token;\n        }\n        break;\n    case 'a': case 'b': case 'c': case 'd':\n    case 'e': case 'f': case 'g': case 'h':\n    case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p':\n    case 'q': case 'r': case 's': case 't':\n    case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z': \n    case 'A': case 'B': case 'C': case 'D':\n    case 'E': case 'F': case 'G': case 'H':\n    case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P':\n    case 'Q': case 'R': case 'S': case 'T':\n    case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z': \n    case '_':\n    case '$':\n        /* identifier : only pure ascii characters are accepted */\n        p++;\n        atom = json_parse_ident(s, &p, c);\n        if (atom == JS_ATOM_NULL)\n            goto fail;\n        s->token.u.ident.atom = atom;\n        s->token.u.ident.has_escape = FALSE;\n        s->token.u.ident.is_reserved = FALSE;\n        s->token.val = TOK_IDENT;\n        break;\n    case '+':\n        if (!s->ext_json || !is_digit(p[1]))\n            goto def_token;\n        goto parse_number;\n    case '0':\n        if (is_digit(p[1]))\n            goto def_token;\n        goto parse_number;\n    case '-':\n        if (!is_digit(p[1]))\n            goto def_token;\n        goto parse_number;\n    case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8':\n    case '9': \n        /* number */\n    parse_number:\n        {\n            JSValue ret;\n            int flags, radix;\n            if (!s->ext_json) {\n                flags = 0;\n                radix = 10;\n            } else {\n                flags = ATOD_ACCEPT_BIN_OCT;\n                radix = 0;\n            }\n            ret = js_atof(s->ctx, (const char *)p, (const char **)&p, radix,\n                          flags);\n            if (JS_IsException(ret))\n                goto fail;\n            s->token.val = TOK_NUMBER;\n            s->token.u.num.val = ret;\n        }\n        break;\n    default:\n        if (c >= 128) {\n            js_parse_error(s, \"unexpected character\");\n            goto fail;\n        }\n    def_token:\n        s->token.val = c;\n        p++;\n        break;\n    }\n    s->buf_ptr = p;\n\n    //    dump_token(s, &s->token);\n    return 0;\n\n fail:\n    s->token.val = TOK_ERROR;\n    return -1;\n}\n\n/* only used for ':' and '=>', 'let' or 'function' look-ahead. *pp is\n   only set if TOK_IMPORT is returned */\n/* XXX: handle all unicode cases */\nstatic int simple_next_token(const uint8_t **pp, BOOL no_line_terminator)\n{\n    const uint8_t *p;\n    uint32_t c;\n    \n    /* skip spaces and comments */\n    p = *pp;\n    for (;;) {\n        switch(c = *p++) {\n        case '\\r':\n        case '\\n':\n            if (no_line_terminator)\n                return '\\n';\n            continue;\n        case ' ':\n        case '\\t':\n        case '\\v':\n        case '\\f':\n            continue;\n        case '/':\n            if (*p == '/') {\n                if (no_line_terminator)\n                    return '\\n';\n                while (*p && *p != '\\r' && *p != '\\n')\n                    p++;\n                continue;\n            }\n            if (*p == '*') {\n                while (*++p) {\n                    if ((*p == '\\r' || *p == '\\n') && no_line_terminator)\n                        return '\\n';\n                    if (*p == '*' && p[1] == '/') {\n                        p += 2;\n                        break;\n                    }\n                }\n                continue;\n            }\n            break;\n        case '=':\n            if (*p == '>')\n                return TOK_ARROW;\n            break;\n        default:\n            if (lre_js_is_ident_first(c)) {\n                if (c == 'i') {\n                    if (p[0] == 'n' && !lre_js_is_ident_next(p[1])) {\n                        return TOK_IN;\n                    }\n                    if (p[0] == 'm' && p[1] == 'p' && p[2] == 'o' &&\n                        p[3] == 'r' && p[4] == 't' &&\n                        !lre_js_is_ident_next(p[5])) {\n                        *pp = p + 5;\n                        return TOK_IMPORT;\n                    }\n                } else if (c == 'o' && *p == 'f' && !lre_js_is_ident_next(p[1])) {\n                    return TOK_OF;\n                } else if (c == 'e' &&\n                           p[0] == 'x' && p[1] == 'p' && p[2] == 'o' &&\n                           p[3] == 'r' && p[4] == 't' &&\n                           !lre_js_is_ident_next(p[5])) {\n                    *pp = p + 5;\n                    return TOK_EXPORT;\n                } else if (c == 'f' && p[0] == 'u' && p[1] == 'n' &&\n                         p[2] == 'c' && p[3] == 't' && p[4] == 'i' &&\n                         p[5] == 'o' && p[6] == 'n' && !lre_js_is_ident_next(p[7])) {\n                    return TOK_FUNCTION;\n                }\n                return TOK_IDENT;\n            }\n            break;\n        }\n        return c;\n    }\n}\n\nstatic int peek_token(JSParseState *s, BOOL no_line_terminator)\n{\n    const uint8_t *p = s->buf_ptr;\n    return simple_next_token(&p, no_line_terminator);\n}\n\n/* return true if 'input' contains the source of a module\n   (heuristic). 'input' must be a zero terminated.\n\n   Heuristic: skip comments and expect 'import' keyword not followed\n   by '(' or '.' or export keyword.\n*/\nBOOL JS_DetectModule(const char *input, size_t input_len)\n{\n    const uint8_t *p = (const uint8_t *)input;\n    int tok;\n    switch(simple_next_token(&p, FALSE)) {\n    case TOK_IMPORT:\n        tok = simple_next_token(&p, FALSE);\n        return (tok != '.' && tok != '(');\n    case TOK_EXPORT:\n        return TRUE;\n    default:\n        return FALSE;\n    }\n}\n\nstatic inline int get_prev_opcode(JSFunctionDef *fd) {\n    if (fd->last_opcode_pos < 0)\n        return OP_invalid;\n    else\n        return fd->byte_code.buf[fd->last_opcode_pos];\n}\n\nstatic BOOL js_is_live_code(JSParseState *s) {\n    switch (get_prev_opcode(s->cur_func)) {\n    case OP_tail_call:\n    case OP_tail_call_method:\n    case OP_return:\n    case OP_return_undef:\n    case OP_return_async:\n    case OP_throw:\n    case OP_throw_error:\n    case OP_goto:\n#if SHORT_OPCODES\n    case OP_goto8:\n    case OP_goto16:\n#endif\n    case OP_ret:\n        return FALSE;\n    default:\n        return TRUE;\n    }\n}\n\nstatic void emit_u8(JSParseState *s, uint8_t val)\n{\n    dbuf_putc(&s->cur_func->byte_code, val);\n}\n\nstatic void emit_u16(JSParseState *s, uint16_t val)\n{\n    dbuf_put_u16(&s->cur_func->byte_code, val);\n}\n\nstatic void emit_u32(JSParseState *s, uint32_t val)\n{\n    dbuf_put_u32(&s->cur_func->byte_code, val);\n}\n\nstatic void emit_op(JSParseState *s, uint8_t val)\n{\n    JSFunctionDef *fd = s->cur_func;\n    DynBuf *bc = &fd->byte_code;\n\n    /* Use the line number of the last token used, not the next token,\n       nor the current offset in the source file.\n     */\n    if (unlikely(fd->last_opcode_line_num != s->last_line_num)) {\n        dbuf_putc(bc, OP_line_num);\n        dbuf_put_u32(bc, s->last_line_num);\n        fd->last_opcode_line_num = s->last_line_num;\n    }\n    fd->last_opcode_pos = bc->size;\n    dbuf_putc(bc, val);\n}\n\nstatic void emit_atom(JSParseState *s, JSAtom name)\n{\n    emit_u32(s, JS_DupAtom(s->ctx, name));\n}\n\nstatic int update_label(JSFunctionDef *s, int label, int delta)\n{\n    LabelSlot *ls;\n\n    assert(label >= 0 && label < s->label_count);\n    ls = &s->label_slots[label];\n    ls->ref_count += delta;\n    assert(ls->ref_count >= 0);\n    return ls->ref_count;\n}\n\nstatic int new_label_fd(JSFunctionDef *fd, int label)\n{\n    LabelSlot *ls;\n\n    if (label < 0) {\n        if (js_resize_array(fd->ctx, (void *)&fd->label_slots,\n                            sizeof(fd->label_slots[0]),\n                            &fd->label_size, fd->label_count + 1))\n            return -1;\n        label = fd->label_count++;\n        ls = &fd->label_slots[label];\n        ls->ref_count = 0;\n        ls->pos = -1;\n        ls->pos2 = -1;\n        ls->addr = -1;\n        ls->first_reloc = NULL;\n    }\n    return label;\n}\n\nstatic int new_label(JSParseState *s)\n{\n    return new_label_fd(s->cur_func, -1);\n}\n\n/* return the label ID offset */\nstatic int emit_label(JSParseState *s, int label)\n{\n    if (label >= 0) {\n        emit_op(s, OP_label);\n        emit_u32(s, label);\n        s->cur_func->label_slots[label].pos = s->cur_func->byte_code.size;\n        return s->cur_func->byte_code.size - 4;\n    } else {\n        return -1;\n    }\n}\n\n/* return label or -1 if dead code */\nstatic int emit_goto(JSParseState *s, int opcode, int label)\n{\n    if (js_is_live_code(s)) {\n        if (label < 0)\n            label = new_label(s);\n        emit_op(s, opcode);\n        emit_u32(s, label);\n        s->cur_func->label_slots[label].ref_count++;\n        return label;\n    }\n    return -1;\n}\n\n/* return the constant pool index. 'val' is not duplicated. */\nstatic int cpool_add(JSParseState *s, JSValue val)\n{\n    JSFunctionDef *fd = s->cur_func;\n    \n    if (js_resize_array(s->ctx, (void *)&fd->cpool, sizeof(fd->cpool[0]),\n                        &fd->cpool_size, fd->cpool_count + 1))\n        return -1;\n    fd->cpool[fd->cpool_count++] = val;\n    return fd->cpool_count - 1;\n}\n\nstatic __exception int emit_push_const(JSParseState *s, JSValueConst val,\n                                       BOOL as_atom)\n{\n    int idx;\n\n    if (JS_VALUE_GET_TAG(val) == JS_TAG_STRING && as_atom) {\n        JSAtom atom;\n        /* warning: JS_NewAtomStr frees the string value */\n        JS_DupValue(s->ctx, val);\n        atom = JS_NewAtomStr(s->ctx, JS_VALUE_GET_STRING(val));\n        if (atom != JS_ATOM_NULL && !__JS_AtomIsTaggedInt(atom)) {\n            emit_op(s, OP_push_atom_value);\n            emit_u32(s, atom);\n            return 0;\n        }\n    }\n\n    idx = cpool_add(s, JS_DupValue(s->ctx, val));\n    if (idx < 0)\n        return -1;\n    emit_op(s, OP_push_const);\n    emit_u32(s, idx);\n    return 0;\n}\n\n/* return the variable index or -1 if not found,\n   add ARGUMENT_VAR_OFFSET for argument variables */\nstatic int find_arg(JSContext *ctx, JSFunctionDef *fd, JSAtom name)\n{\n    int i;\n    for(i = fd->arg_count; i-- > 0;) {\n        if (fd->args[i].var_name == name)\n            return i | ARGUMENT_VAR_OFFSET;\n    }\n    return -1;\n}\n\nstatic int find_var(JSContext *ctx, JSFunctionDef *fd, JSAtom name)\n{\n    int i;\n    for(i = fd->var_count; i-- > 0;) {\n        if (fd->vars[i].var_name == name && fd->vars[i].scope_level == 0)\n            return i;\n    }\n    return find_arg(ctx, fd, name);\n}\n\n/* find a variable declaration in a given scope */\nstatic int find_var_in_scope(JSContext *ctx, JSFunctionDef *fd,\n                             JSAtom name, int scope_level)\n{\n    int scope_idx;\n    for(scope_idx = fd->scopes[scope_level].first; scope_idx >= 0;\n        scope_idx = fd->vars[scope_idx].scope_next) {\n        if (fd->vars[scope_idx].scope_level != scope_level)\n            break;\n        if (fd->vars[scope_idx].var_name == name)\n            return scope_idx;\n    }\n    return -1;\n}\n\n/* return true if scope == parent_scope or if scope is a child of\n   parent_scope */\nstatic BOOL is_child_scope(JSContext *ctx, JSFunctionDef *fd,\n                           int scope, int parent_scope)\n{\n    while (scope >= 0) {\n        if (scope == parent_scope)\n            return TRUE;\n        scope = fd->scopes[scope].parent;\n    }\n    return FALSE;\n}\n\n/* find a 'var' declaration in the same scope or a child scope */\nstatic int find_var_in_child_scope(JSContext *ctx, JSFunctionDef *fd,\n                                   JSAtom name, int scope_level)\n{\n    int i;\n    for(i = 0; i < fd->var_count; i++) {\n        JSVarDef *vd = &fd->vars[i];\n        if (vd->var_name == name && vd->scope_level == 0) {\n            if (is_child_scope(ctx, fd, vd->scope_next,\n                               scope_level))\n                return i;\n        }\n    }\n    return -1;\n}\n\n\nstatic JSGlobalVar *find_global_var(JSFunctionDef *fd, JSAtom name)\n{\n    int i;\n    for(i = 0; i < fd->global_var_count; i++) {\n        JSGlobalVar *hf = &fd->global_vars[i];\n        if (hf->var_name == name)\n            return hf;\n    }\n    return NULL;\n\n}\n\nstatic JSGlobalVar *find_lexical_global_var(JSFunctionDef *fd, JSAtom name)\n{\n    JSGlobalVar *hf = find_global_var(fd, name);\n    if (hf && hf->is_lexical)\n        return hf;\n    else\n        return NULL;\n}\n\nstatic int find_lexical_decl(JSContext *ctx, JSFunctionDef *fd, JSAtom name,\n                             int scope_idx, BOOL check_catch_var)\n{\n    while (scope_idx >= 0) {\n        JSVarDef *vd = &fd->vars[scope_idx];\n        if (vd->var_name == name &&\n            (vd->is_lexical || (vd->var_kind == JS_VAR_CATCH &&\n                                check_catch_var)))\n            return scope_idx;\n        scope_idx = vd->scope_next;\n    }\n\n    if (fd->is_eval && fd->eval_type == JS_EVAL_TYPE_GLOBAL) {\n        if (find_lexical_global_var(fd, name))\n            return GLOBAL_VAR_OFFSET;\n    }\n    return -1;\n}\n\nstatic int push_scope(JSParseState *s) {\n    if (s->cur_func) {\n        JSFunctionDef *fd = s->cur_func;\n        int scope = fd->scope_count;\n        /* XXX: should check for scope overflow */\n        if ((fd->scope_count + 1) > fd->scope_size) {\n            int new_size;\n            size_t slack;\n            JSVarScope *new_buf;\n            /* XXX: potential arithmetic overflow */\n            new_size = max_int(fd->scope_count + 1, fd->scope_size * 3 / 2);\n            if (fd->scopes == fd->def_scope_array) {\n                new_buf = js_realloc2(s->ctx, NULL, new_size * sizeof(*fd->scopes), &slack);\n                if (!new_buf)\n                    return -1;\n                memcpy(new_buf, fd->scopes, fd->scope_count * sizeof(*fd->scopes));\n            } else {\n                new_buf = js_realloc2(s->ctx, fd->scopes, new_size * sizeof(*fd->scopes), &slack);\n                if (!new_buf)\n                    return -1;\n            }\n            new_size += slack / sizeof(*new_buf);\n            fd->scopes = new_buf;\n            fd->scope_size = new_size;\n        }\n        fd->scope_count++;\n        fd->scopes[scope].parent = fd->scope_level;\n        fd->scopes[scope].first = fd->scope_first;\n        emit_op(s, OP_enter_scope);\n        emit_u16(s, scope);\n        return fd->scope_level = scope;\n    }\n    return 0;\n}\n\nstatic int get_first_lexical_var(JSFunctionDef *fd, int scope)\n{\n    while (scope >= 0) {\n        int scope_idx = fd->scopes[scope].first;\n        if (scope_idx >= 0)\n            return scope_idx;\n        scope = fd->scopes[scope].parent;\n    }\n    return -1;\n}\n\nstatic void pop_scope(JSParseState *s) {\n    if (s->cur_func) {\n        /* disable scoped variables */\n        JSFunctionDef *fd = s->cur_func;\n        int scope = fd->scope_level;\n        emit_op(s, OP_leave_scope);\n        emit_u16(s, scope);\n        fd->scope_level = fd->scopes[scope].parent;\n        fd->scope_first = get_first_lexical_var(fd, fd->scope_level);\n    }\n}\n\nstatic void close_scopes(JSParseState *s, int scope, int scope_stop)\n{\n    while (scope > scope_stop) {\n        emit_op(s, OP_leave_scope);\n        emit_u16(s, scope);\n        scope = s->cur_func->scopes[scope].parent;\n    }\n}\n\n/* return the variable index or -1 if error */\nstatic int add_var(JSContext *ctx, JSFunctionDef *fd, JSAtom name)\n{\n    JSVarDef *vd;\n\n    /* the local variable indexes are currently stored on 16 bits */\n    if (fd->var_count >= JS_MAX_LOCAL_VARS) {\n        JS_ThrowInternalError(ctx, \"too many local variables\");\n        return -1;\n    }\n    if (js_resize_array(ctx, (void **)&fd->vars, sizeof(fd->vars[0]),\n                        &fd->var_size, fd->var_count + 1))\n        return -1;\n    vd = &fd->vars[fd->var_count++];\n    memset(vd, 0, sizeof(*vd));\n    vd->var_name = JS_DupAtom(ctx, name);\n    vd->func_pool_idx = -1;\n    return fd->var_count - 1;\n}\n\nstatic int add_scope_var(JSContext *ctx, JSFunctionDef *fd, JSAtom name,\n                         JSVarKindEnum var_kind)\n{\n    int idx = add_var(ctx, fd, name);\n    if (idx >= 0) {\n        JSVarDef *vd = &fd->vars[idx];\n        vd->var_kind = var_kind;\n        vd->scope_level = fd->scope_level;\n        vd->scope_next = fd->scope_first;\n        fd->scopes[fd->scope_level].first = idx;\n        fd->scope_first = idx;\n    }\n    return idx;\n}\n\nstatic int add_func_var(JSContext *ctx, JSFunctionDef *fd, JSAtom name)\n{\n    int idx = fd->func_var_idx;\n    if (idx < 0 && (idx = add_var(ctx, fd, name)) >= 0) {\n        fd->func_var_idx = idx;\n        fd->vars[idx].var_kind = JS_VAR_FUNCTION_NAME;\n        if (fd->js_mode & JS_MODE_STRICT)\n            fd->vars[idx].is_const = TRUE;\n    }\n    return idx;\n}\n\nstatic int add_arguments_var(JSContext *ctx, JSFunctionDef *fd)\n{\n    int idx = fd->arguments_var_idx;\n    if (idx < 0 && (idx = add_var(ctx, fd, JS_ATOM_arguments)) >= 0) {\n        fd->arguments_var_idx = idx;\n    }\n    return idx;\n}\n\n/* add an argument definition in the argument scope. Only needed when\n   \"eval()\" may be called in the argument scope. Return 0 if OK. */\nstatic int add_arguments_arg(JSContext *ctx, JSFunctionDef *fd)\n{\n    int idx;\n    if (fd->arguments_arg_idx < 0) {\n        idx = find_var_in_scope(ctx, fd, JS_ATOM_arguments, ARG_SCOPE_INDEX);\n        if (idx < 0) {\n            /* XXX: the scope links are not fully updated. May be an\n               issue if there are child scopes of the argument\n               scope */\n            idx = add_var(ctx, fd, JS_ATOM_arguments);\n            if (idx < 0)\n                return -1;\n            fd->vars[idx].scope_next = fd->scopes[ARG_SCOPE_INDEX].first;\n            fd->scopes[ARG_SCOPE_INDEX].first = idx;\n            fd->vars[idx].scope_level = ARG_SCOPE_INDEX;\n            fd->vars[idx].is_lexical = TRUE;\n\n            fd->arguments_arg_idx = idx;\n        }\n    }\n    return 0;\n}\n\nstatic int add_arg(JSContext *ctx, JSFunctionDef *fd, JSAtom name)\n{\n    JSVarDef *vd;\n\n    /* the local variable indexes are currently stored on 16 bits */\n    if (fd->arg_count >= JS_MAX_LOCAL_VARS) {\n        JS_ThrowInternalError(ctx, \"too many arguments\");\n        return -1;\n    }\n    if (js_resize_array(ctx, (void **)&fd->args, sizeof(fd->args[0]),\n                        &fd->arg_size, fd->arg_count + 1))\n        return -1;\n    vd = &fd->args[fd->arg_count++];\n    memset(vd, 0, sizeof(*vd));\n    vd->var_name = JS_DupAtom(ctx, name);\n    vd->func_pool_idx = -1;\n    return fd->arg_count - 1;\n}\n\n/* add a global variable definition */\nstatic JSGlobalVar *add_global_var(JSContext *ctx, JSFunctionDef *s,\n                                     JSAtom name)\n{\n    JSGlobalVar *hf;\n\n    if (js_resize_array(ctx, (void **)&s->global_vars,\n                        sizeof(s->global_vars[0]),\n                        &s->global_var_size, s->global_var_count + 1))\n        return NULL;\n    hf = &s->global_vars[s->global_var_count++];\n    hf->cpool_idx = -1;\n    hf->force_init = FALSE;\n    hf->is_lexical = FALSE;\n    hf->is_const = FALSE;\n    hf->scope_level = s->scope_level;\n    hf->var_name = JS_DupAtom(ctx, name);\n    return hf;\n}\n\ntypedef enum {\n    JS_VAR_DEF_WITH,\n    JS_VAR_DEF_LET,\n    JS_VAR_DEF_CONST,\n    JS_VAR_DEF_FUNCTION_DECL, /* function declaration */\n    JS_VAR_DEF_NEW_FUNCTION_DECL, /* async/generator function declaration */\n    JS_VAR_DEF_CATCH,\n    JS_VAR_DEF_VAR,\n} JSVarDefEnum;\n\nstatic int define_var(JSParseState *s, JSFunctionDef *fd, JSAtom name,\n                      JSVarDefEnum var_def_type)\n{\n    JSContext *ctx = s->ctx;\n    JSVarDef *vd;\n    int idx;\n\n    switch (var_def_type) {\n    case JS_VAR_DEF_WITH:\n        idx = add_scope_var(ctx, fd, name, JS_VAR_NORMAL);\n        break;\n\n    case JS_VAR_DEF_LET:\n    case JS_VAR_DEF_CONST:\n    case JS_VAR_DEF_FUNCTION_DECL:\n    case JS_VAR_DEF_NEW_FUNCTION_DECL:\n        idx = find_lexical_decl(ctx, fd, name, fd->scope_first, TRUE);\n        if (idx >= 0) {\n            if (idx < GLOBAL_VAR_OFFSET) {\n                if (fd->vars[idx].scope_level == fd->scope_level) {\n                    /* same scope: in non strict mode, functions\n                       can be redefined (annex B.3.3.4). */\n                    if (!(!(fd->js_mode & JS_MODE_STRICT) &&\n                          var_def_type == JS_VAR_DEF_FUNCTION_DECL &&\n                          fd->vars[idx].var_kind == JS_VAR_FUNCTION_DECL)) {\n                        goto redef_lex_error;\n                    }\n                } else if (fd->vars[idx].var_kind == JS_VAR_CATCH && (fd->vars[idx].scope_level + 2) == fd->scope_level) {\n                    goto redef_lex_error;\n                }\n            } else {\n                if (fd->scope_level == fd->body_scope) {\n                redef_lex_error:\n                    /* redefining a scoped var in the same scope: error */\n                    return js_parse_error(s, \"invalid redefinition of lexical identifier\");\n                }\n            }\n        }\n        if (var_def_type != JS_VAR_DEF_FUNCTION_DECL &&\n            var_def_type != JS_VAR_DEF_NEW_FUNCTION_DECL &&\n            fd->scope_level == fd->body_scope &&\n            find_arg(ctx, fd, name) >= 0) {\n            /* lexical variable redefines a parameter name */\n            return js_parse_error(s, \"invalid redefinition of parameter name\");\n        }\n\n        if (find_var_in_child_scope(ctx, fd, name, fd->scope_level) >= 0) {\n            return js_parse_error(s, \"invalid redefinition of a variable\");\n        }\n        \n        if (fd->is_global_var) {\n            JSGlobalVar *hf;\n            hf = find_global_var(fd, name);\n            if (hf && is_child_scope(ctx, fd, hf->scope_level,\n                                     fd->scope_level)) {\n                return js_parse_error(s, \"invalid redefinition of global identifier\");\n            }\n        }\n        \n        if (fd->is_eval &&\n            (fd->eval_type == JS_EVAL_TYPE_GLOBAL ||\n             fd->eval_type == JS_EVAL_TYPE_MODULE) &&\n            fd->scope_level == fd->body_scope) {\n            JSGlobalVar *hf;\n            hf = add_global_var(s->ctx, fd, name);\n            if (!hf)\n                return -1;\n            hf->is_lexical = TRUE;\n            hf->is_const = (var_def_type == JS_VAR_DEF_CONST);\n            idx = GLOBAL_VAR_OFFSET;\n        } else {\n            JSVarKindEnum var_kind;\n            if (var_def_type == JS_VAR_DEF_FUNCTION_DECL)\n                var_kind = JS_VAR_FUNCTION_DECL;\n            else if (var_def_type == JS_VAR_DEF_NEW_FUNCTION_DECL)\n                var_kind = JS_VAR_NEW_FUNCTION_DECL;\n            else\n                var_kind = JS_VAR_NORMAL;\n            idx = add_scope_var(ctx, fd, name, var_kind);\n            if (idx >= 0) {\n                vd = &fd->vars[idx];\n                vd->is_lexical = 1;\n                vd->is_const = (var_def_type == JS_VAR_DEF_CONST);\n            }\n        }\n        break;\n\n    case JS_VAR_DEF_CATCH:\n        idx = add_scope_var(ctx, fd, name, JS_VAR_CATCH);\n        break;\n\n    case JS_VAR_DEF_VAR:\n        if (find_lexical_decl(ctx, fd, name, fd->scope_first,\n                              FALSE) >= 0) {\n       invalid_lexical_redefinition:\n            /* error to redefine a var that inside a lexical scope */\n            return js_parse_error(s, \"invalid redefinition of lexical identifier\");\n        }\n        if (fd->is_global_var) {\n            JSGlobalVar *hf;\n            hf = find_global_var(fd, name);\n            if (hf && hf->is_lexical && hf->scope_level == fd->scope_level &&\n                fd->eval_type == JS_EVAL_TYPE_MODULE) {\n                goto invalid_lexical_redefinition;\n            }\n            hf = add_global_var(s->ctx, fd, name);\n            if (!hf)\n                return -1;\n            idx = GLOBAL_VAR_OFFSET;\n        } else {\n            /* if the variable already exists, don't add it again  */\n            idx = find_var(ctx, fd, name);\n            if (idx >= 0)\n                break;\n            idx = add_var(ctx, fd, name);\n            if (idx >= 0) {\n                if (name == JS_ATOM_arguments && fd->has_arguments_binding)\n                    fd->arguments_var_idx = idx;\n                fd->vars[idx].scope_next = fd->scope_level;\n            }\n        }\n        break;\n    default:\n        abort();\n    }\n    return idx;\n}\n\n/* add a private field variable in the current scope */\nstatic int add_private_class_field(JSParseState *s, JSFunctionDef *fd,\n                                   JSAtom name, JSVarKindEnum var_kind)\n{\n    JSContext *ctx = s->ctx;\n    JSVarDef *vd;\n    int idx;\n\n    idx = add_scope_var(ctx, fd, name, var_kind);\n    if (idx < 0)\n        return idx;\n    vd = &fd->vars[idx];\n    vd->is_lexical = 1;\n    vd->is_const = 1;\n    return idx;\n}\n\nstatic __exception int js_parse_expr(JSParseState *s);\nstatic __exception int js_parse_function_decl(JSParseState *s,\n                                              JSParseFunctionEnum func_type,\n                                              JSFunctionKindEnum func_kind,\n                                              JSAtom func_name, const uint8_t *ptr,\n                                              int start_line);\nstatic JSFunctionDef *js_parse_function_class_fields_init(JSParseState *s);\nstatic __exception int js_parse_function_decl2(JSParseState *s,\n                                               JSParseFunctionEnum func_type,\n                                               JSFunctionKindEnum func_kind,\n                                               JSAtom func_name,\n                                               const uint8_t *ptr,\n                                               int function_line_num,\n                                               JSParseExportEnum export_flag,\n                                               JSFunctionDef **pfd);\nstatic __exception int js_parse_assign_expr2(JSParseState *s, int parse_flags);\nstatic __exception int js_parse_assign_expr(JSParseState *s);\nstatic __exception int js_parse_unary(JSParseState *s, int parse_flags);\nstatic void push_break_entry(JSFunctionDef *fd, BlockEnv *be,\n                             JSAtom label_name,\n                             int label_break, int label_cont,\n                             int drop_count);\nstatic void pop_break_entry(JSFunctionDef *fd);\nstatic JSExportEntry *add_export_entry(JSParseState *s, JSModuleDef *m,\n                                       JSAtom local_name, JSAtom export_name,\n                                       JSExportTypeEnum export_type);\n\n/* Note: all the fields are already sealed except length */\nstatic int seal_template_obj(JSContext *ctx, JSValueConst obj)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n\n    p = JS_VALUE_GET_OBJ(obj);\n    prs = find_own_property1(p, JS_ATOM_length);\n    if (prs) {\n        if (js_update_property_flags(ctx, p, &prs,\n                                     prs->flags & ~(JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE)))\n            return -1;\n    }\n    p->extensible = FALSE;\n    return 0;\n}\n\nstatic __exception int js_parse_template(JSParseState *s, int call, int *argc)\n{\n    JSContext *ctx = s->ctx;\n    JSValue raw_array, template_object;\n    JSToken cooked;\n    int depth, ret;\n\n    raw_array = JS_UNDEFINED; /* avoid warning */\n    template_object = JS_UNDEFINED; /* avoid warning */\n    if (call) {\n        /* Create a template object: an array of cooked strings */\n        /* Create an array of raw strings and store it to the raw property */\n        template_object = JS_NewArray(ctx);\n        if (JS_IsException(template_object))\n            return -1;\n        //        pool_idx = s->cur_func->cpool_count;\n        ret = emit_push_const(s, template_object, 0);\n        JS_FreeValue(ctx, template_object);\n        if (ret)\n            return -1;\n        raw_array = JS_NewArray(ctx);\n        if (JS_IsException(raw_array))\n            return -1;\n        if (JS_DefinePropertyValue(ctx, template_object, JS_ATOM_raw,\n                                   raw_array, JS_PROP_THROW) < 0) {\n            return -1;\n        }\n    }\n\n    depth = 0;\n    while (s->token.val == TOK_TEMPLATE) {\n        const uint8_t *p = s->token.ptr + 1;\n        cooked = s->token;\n        if (call) {\n            if (JS_DefinePropertyValueUint32(ctx, raw_array, depth,\n                                             JS_DupValue(ctx, s->token.u.str.str),\n                                             JS_PROP_ENUMERABLE | JS_PROP_THROW) < 0) {\n                return -1;\n            }\n            /* re-parse the string with escape sequences but do not throw a\n               syntax error if it contains invalid sequences\n             */\n            if (js_parse_string(s, '`', FALSE, p, &cooked, &p)) {\n                cooked.u.str.str = JS_UNDEFINED;\n            }\n            if (JS_DefinePropertyValueUint32(ctx, template_object, depth,\n                                             cooked.u.str.str,\n                                             JS_PROP_ENUMERABLE | JS_PROP_THROW) < 0) {\n                return -1;\n            }\n        } else {\n            JSString *str;\n            /* re-parse the string with escape sequences and throw a\n               syntax error if it contains invalid sequences\n             */\n            JS_FreeValue(ctx, s->token.u.str.str);\n            s->token.u.str.str = JS_UNDEFINED;\n            if (js_parse_string(s, '`', TRUE, p, &cooked, &p))\n                return -1;\n            str = JS_VALUE_GET_STRING(cooked.u.str.str);\n            if (str->len != 0 || depth == 0) {\n                ret = emit_push_const(s, cooked.u.str.str, 1);\n                JS_FreeValue(s->ctx, cooked.u.str.str);\n                if (ret)\n                    return -1;\n                if (depth == 0) {\n                    if (s->token.u.str.sep == '`')\n                        goto done1;\n                    emit_op(s, OP_get_field2);\n                    emit_atom(s, JS_ATOM_concat);\n                }\n                depth++;\n            } else {\n                JS_FreeValue(s->ctx, cooked.u.str.str);\n            }\n        }\n        if (s->token.u.str.sep == '`')\n            goto done;\n        if (next_token(s))\n            return -1;\n        if (js_parse_expr(s))\n            return -1;\n        depth++;\n        if (s->token.val != '}') {\n            return js_parse_error(s, \"expected '}' after template expression\");\n        }\n        /* XXX: should convert to string at this stage? */\n        free_token(s, &s->token);\n        /* Resume TOK_TEMPLATE parsing (s->token.line_num and\n         * s->token.ptr are OK) */\n        s->got_lf = FALSE;\n        s->last_line_num = s->token.line_num;\n        if (js_parse_template_part(s, s->buf_ptr))\n            return -1;\n    }\n    return js_parse_expect(s, TOK_TEMPLATE);\n\n done:\n    if (call) {\n        /* Seal the objects */\n        seal_template_obj(ctx, raw_array);\n        seal_template_obj(ctx, template_object);\n        *argc = depth + 1;\n    } else {\n        emit_op(s, OP_call_method);\n        emit_u16(s, depth - 1);\n    }\n done1:\n    return next_token(s);\n}\n\n\n#define PROP_TYPE_IDENT 0\n#define PROP_TYPE_VAR   1\n#define PROP_TYPE_GET   2\n#define PROP_TYPE_SET   3\n#define PROP_TYPE_STAR  4\n#define PROP_TYPE_ASYNC 5\n#define PROP_TYPE_ASYNC_STAR 6\n\n#define PROP_TYPE_PRIVATE (1 << 4)\n\nstatic BOOL token_is_ident(int tok)\n{\n    /* Accept keywords and reserved words as property names */\n    return (tok == TOK_IDENT ||\n            (tok >= TOK_FIRST_KEYWORD &&\n             tok <= TOK_LAST_KEYWORD));\n}\n\n/* if the property is an expression, name = JS_ATOM_NULL */\nstatic int __exception js_parse_property_name(JSParseState *s,\n                                              JSAtom *pname,\n                                              BOOL allow_method, BOOL allow_var,\n                                              BOOL allow_private)\n{\n    int is_private = 0;\n    BOOL is_non_reserved_ident;\n    JSAtom name;\n    int prop_type;\n    \n    prop_type = PROP_TYPE_IDENT;\n    if (allow_method) {\n        if (token_is_pseudo_keyword(s, JS_ATOM_get)\n        ||  token_is_pseudo_keyword(s, JS_ATOM_set)) {\n            /* get x(), set x() */\n            name = JS_DupAtom(s->ctx, s->token.u.ident.atom);\n            if (next_token(s))\n                goto fail1;\n            if (s->token.val == ':' || s->token.val == ',' ||\n                s->token.val == '}' || s->token.val == '(') {\n                is_non_reserved_ident = TRUE;\n                goto ident_found;\n            }\n            prop_type = PROP_TYPE_GET + (name == JS_ATOM_set);\n            JS_FreeAtom(s->ctx, name);\n        } else if (s->token.val == '*') {\n            if (next_token(s))\n                goto fail;\n            prop_type = PROP_TYPE_STAR;\n        } else if (token_is_pseudo_keyword(s, JS_ATOM_async) &&\n                   peek_token(s, TRUE) != '\\n') {\n            name = JS_DupAtom(s->ctx, s->token.u.ident.atom);\n            if (next_token(s))\n                goto fail1;\n            if (s->token.val == ':' || s->token.val == ',' ||\n                s->token.val == '}' || s->token.val == '(') {\n                is_non_reserved_ident = TRUE;\n                goto ident_found;\n            }\n            JS_FreeAtom(s->ctx, name);\n            if (s->token.val == '*') {\n                if (next_token(s))\n                    goto fail;\n                prop_type = PROP_TYPE_ASYNC_STAR;\n            } else {\n                prop_type = PROP_TYPE_ASYNC;\n            }\n        }\n    }\n\n    if (token_is_ident(s->token.val)) {\n        /* variable can only be a non-reserved identifier */\n        is_non_reserved_ident =\n            (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved);\n        /* keywords and reserved words have a valid atom */\n        name = JS_DupAtom(s->ctx, s->token.u.ident.atom);\n        if (next_token(s))\n            goto fail1;\n    ident_found:\n        if (is_non_reserved_ident &&\n            prop_type == PROP_TYPE_IDENT && allow_var) {\n            if (!(s->token.val == ':' ||\n                  (s->token.val == '(' && allow_method))) {\n                prop_type = PROP_TYPE_VAR;\n            }\n        }\n    } else if (s->token.val == TOK_STRING) {\n        name = JS_ValueToAtom(s->ctx, s->token.u.str.str);\n        if (name == JS_ATOM_NULL)\n            goto fail;\n        if (next_token(s))\n            goto fail1;\n    } else if (s->token.val == TOK_NUMBER) {\n        JSValue val;\n        val = s->token.u.num.val;\n#ifdef CONFIG_BIGNUM\n        if (JS_VALUE_GET_TAG(val) == JS_TAG_BIG_FLOAT) {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            val = s->ctx->rt->bigfloat_ops.\n                mul_pow10_to_float64(s->ctx, &p->num,\n                                     s->token.u.num.exponent);\n            if (JS_IsException(val))\n                goto fail;\n            name = JS_ValueToAtom(s->ctx, val);\n            JS_FreeValue(s->ctx, val);\n        } else\n#endif\n        {\n            name = JS_ValueToAtom(s->ctx, val);\n        }\n        if (name == JS_ATOM_NULL)\n            goto fail;\n        if (next_token(s))\n            goto fail1;\n    } else if (s->token.val == '[') {\n        if (next_token(s))\n            goto fail;\n        if (js_parse_expr(s))\n            goto fail;\n        if (js_parse_expect(s, ']'))\n            goto fail;\n        name = JS_ATOM_NULL;\n    } else if (s->token.val == TOK_PRIVATE_NAME && allow_private) {\n        name = JS_DupAtom(s->ctx, s->token.u.ident.atom);\n        if (next_token(s))\n            goto fail1;\n        is_private = PROP_TYPE_PRIVATE;\n    } else {\n        goto invalid_prop;\n    }\n    if (prop_type != PROP_TYPE_IDENT && prop_type != PROP_TYPE_VAR &&\n        s->token.val != '(') {\n        JS_FreeAtom(s->ctx, name);\n    invalid_prop:\n        js_parse_error(s, \"invalid property name\");\n        goto fail;\n    }\n    *pname = name;\n    return prop_type | is_private;\n fail1:\n    JS_FreeAtom(s->ctx, name);\n fail:\n    *pname = JS_ATOM_NULL;\n    return -1;\n}\n\ntypedef struct JSParsePos {\n    int last_line_num;\n    int line_num;\n    BOOL got_lf;\n    const uint8_t *ptr;\n} JSParsePos;\n\nstatic int js_parse_get_pos(JSParseState *s, JSParsePos *sp)\n{\n    sp->last_line_num = s->last_line_num;\n    sp->line_num = s->token.line_num;\n    sp->ptr = s->token.ptr;\n    sp->got_lf = s->got_lf;\n    return 0;\n}\n\nstatic __exception int js_parse_seek_token(JSParseState *s, const JSParsePos *sp)\n{\n    s->token.line_num = sp->last_line_num;\n    s->line_num = sp->line_num;\n    s->buf_ptr = sp->ptr;\n    s->got_lf = sp->got_lf;\n    return next_token(s);\n}\n\n/* return TRUE if a regexp literal is allowed after this token */\nstatic BOOL is_regexp_allowed(int tok)\n{\n    switch (tok) {\n    case TOK_NUMBER:\n    case TOK_STRING:\n    case TOK_REGEXP:\n    case TOK_DEC:\n    case TOK_INC:\n    case TOK_NULL:\n    case TOK_FALSE:\n    case TOK_TRUE:\n    case TOK_THIS:\n    case ')':\n    case ']':\n    case '}': /* XXX: regexp may occur after */\n    case TOK_IDENT:\n        return FALSE;\n    default:\n        return TRUE;\n    }\n}\n\n#define SKIP_HAS_SEMI       (1 << 0)\n#define SKIP_HAS_ELLIPSIS   (1 << 1)\n#define SKIP_HAS_ASSIGNMENT (1 << 2)\n\n/* XXX: improve speed with early bailout */\n/* XXX: no longer works if regexps are present. Could use previous\n   regexp parsing heuristics to handle most cases */\nstatic int js_parse_skip_parens_token(JSParseState *s, int *pbits, BOOL no_line_terminator)\n{\n    char state[256];\n    size_t level = 0;\n    JSParsePos pos;\n    int last_tok, tok = TOK_EOF;\n    int c, tok_len, bits = 0;\n\n    /* protect from underflow */\n    state[level++] = 0;\n\n    js_parse_get_pos(s, &pos);\n    last_tok = 0;\n    for (;;) {\n        switch(s->token.val) {\n        case '(':\n        case '[':\n        case '{':\n            if (level >= sizeof(state))\n                goto done;\n            state[level++] = s->token.val;\n            break;\n        case ')':\n            if (state[--level] != '(')\n                goto done;\n            break;\n        case ']':\n            if (state[--level] != '[')\n                goto done;\n            break;\n        case '}':\n            c = state[--level];\n            if (c == '`') {\n                /* continue the parsing of the template */\n                free_token(s, &s->token);\n                /* Resume TOK_TEMPLATE parsing (s->token.line_num and\n                 * s->token.ptr are OK) */\n                s->got_lf = FALSE;\n                s->last_line_num = s->token.line_num;\n                if (js_parse_template_part(s, s->buf_ptr))\n                    goto done;\n                goto handle_template;\n            } else if (c != '{') {\n                goto done;\n            }\n            break;\n        case TOK_TEMPLATE:\n        handle_template:\n            if (s->token.u.str.sep != '`') {\n                /* '${' inside the template : closing '}' and continue\n                   parsing the template */\n                if (level >= sizeof(state))\n                    goto done;\n                state[level++] = '`';\n            } \n            break;\n        case TOK_EOF:\n            goto done;\n        case ';':\n            if (level == 2) {\n                bits |= SKIP_HAS_SEMI;\n            }\n            break;\n        case TOK_ELLIPSIS:\n            if (level == 2) {\n                bits |= SKIP_HAS_ELLIPSIS;\n            }\n            break;\n        case '=':\n            bits |= SKIP_HAS_ASSIGNMENT;\n            break;\n            \n        case TOK_DIV_ASSIGN:\n            tok_len = 2;\n            goto parse_regexp;\n        case '/':\n            tok_len = 1;\n        parse_regexp:\n            if (is_regexp_allowed(last_tok)) {\n                s->buf_ptr -= tok_len;\n                if (js_parse_regexp(s)) {\n                    /* XXX: should clear the exception */\n                    goto done;\n                }\n            }\n            break;\n        }\n        /* last_tok is only used to recognize regexps */\n        if (s->token.val == TOK_IDENT &&\n            (token_is_pseudo_keyword(s, JS_ATOM_of) ||\n             token_is_pseudo_keyword(s, JS_ATOM_yield))) {\n            last_tok = TOK_OF;\n        } else {\n            last_tok = s->token.val;\n        }\n        if (next_token(s)) {\n            /* XXX: should clear the exception generated by next_token() */\n            break;\n        }\n        if (level <= 1) {\n            tok = s->token.val;\n            if (token_is_pseudo_keyword(s, JS_ATOM_of))\n                tok = TOK_OF;\n            if (no_line_terminator && s->last_line_num != s->token.line_num)\n                tok = '\\n';\n            break;\n        }\n    }\n done:\n    if (pbits) {\n        *pbits = bits;\n    }\n    if (js_parse_seek_token(s, &pos))\n        return -1;\n    return tok;\n}\n\nstatic void set_object_name(JSParseState *s, JSAtom name)\n{\n    JSFunctionDef *fd = s->cur_func;\n    int opcode;\n\n    opcode = get_prev_opcode(fd);\n    if (opcode == OP_set_name) {\n        /* XXX: should free atom after OP_set_name? */\n        fd->byte_code.size = fd->last_opcode_pos;\n        fd->last_opcode_pos = -1;\n        emit_op(s, OP_set_name);\n        emit_atom(s, name);\n    } else if (opcode == OP_set_class_name) {\n        int define_class_pos;\n        JSAtom atom;\n        define_class_pos = fd->last_opcode_pos + 1 -\n            get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);\n        assert(fd->byte_code.buf[define_class_pos] == OP_define_class);\n        /* for consistency we free the previous atom which is\n           JS_ATOM_empty_string */\n        atom = get_u32(fd->byte_code.buf + define_class_pos + 1);\n        JS_FreeAtom(s->ctx, atom);\n        put_u32(fd->byte_code.buf + define_class_pos + 1,\n                JS_DupAtom(s->ctx, name));\n        fd->last_opcode_pos = -1;\n    }\n}\n\nstatic void set_object_name_computed(JSParseState *s)\n{\n    JSFunctionDef *fd = s->cur_func;\n    int opcode;\n\n    opcode = get_prev_opcode(fd);\n    if (opcode == OP_set_name) {\n        /* XXX: should free atom after OP_set_name? */\n        fd->byte_code.size = fd->last_opcode_pos;\n        fd->last_opcode_pos = -1;\n        emit_op(s, OP_set_name_computed);\n    } else if (opcode == OP_set_class_name) {\n        int define_class_pos;\n        define_class_pos = fd->last_opcode_pos + 1 -\n            get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);\n        assert(fd->byte_code.buf[define_class_pos] == OP_define_class);\n        fd->byte_code.buf[define_class_pos] = OP_define_class_computed;\n        fd->last_opcode_pos = -1;\n    }\n}\n\nstatic __exception int js_parse_object_literal(JSParseState *s)\n{\n    JSAtom name = JS_ATOM_NULL;\n    const uint8_t *start_ptr;\n    int start_line, prop_type;\n    BOOL has_proto;\n\n    if (next_token(s))\n        goto fail;\n    /* XXX: add an initial length that will be patched back */\n    emit_op(s, OP_object);\n    has_proto = FALSE;\n    while (s->token.val != '}') {\n        /* specific case for getter/setter */\n        start_ptr = s->token.ptr;\n        start_line = s->token.line_num;\n\n        if (s->token.val == TOK_ELLIPSIS) {\n            if (next_token(s))\n                return -1;\n            if (js_parse_assign_expr(s))\n                return -1;\n            emit_op(s, OP_null);  /* dummy excludeList */\n            emit_op(s, OP_copy_data_properties);\n            emit_u8(s, 2 | (1 << 2) | (0 << 5));\n            emit_op(s, OP_drop); /* pop excludeList */\n            emit_op(s, OP_drop); /* pop src object */\n            goto next;\n        }\n\n        prop_type = js_parse_property_name(s, &name, TRUE, TRUE, FALSE);\n        if (prop_type < 0)\n            goto fail;\n\n        if (prop_type == PROP_TYPE_VAR) {\n            /* shortcut for x: x */\n            emit_op(s, OP_scope_get_var);\n            emit_atom(s, name);\n            emit_u16(s, s->cur_func->scope_level);\n            emit_op(s, OP_define_field);\n            emit_atom(s, name);\n        } else if (s->token.val == '(') {\n            BOOL is_getset = (prop_type == PROP_TYPE_GET ||\n                              prop_type == PROP_TYPE_SET);\n            JSParseFunctionEnum func_type;\n            JSFunctionKindEnum func_kind;\n            int op_flags;\n\n            func_kind = JS_FUNC_NORMAL;\n            if (is_getset) {\n                func_type = JS_PARSE_FUNC_GETTER + prop_type - PROP_TYPE_GET;\n            } else {\n                func_type = JS_PARSE_FUNC_METHOD;\n                if (prop_type == PROP_TYPE_STAR)\n                    func_kind = JS_FUNC_GENERATOR;\n                else if (prop_type == PROP_TYPE_ASYNC)\n                    func_kind = JS_FUNC_ASYNC;\n                else if (prop_type == PROP_TYPE_ASYNC_STAR)\n                    func_kind = JS_FUNC_ASYNC_GENERATOR;\n            }\n            if (js_parse_function_decl(s, func_type, func_kind, JS_ATOM_NULL,\n                                       start_ptr, start_line))\n                goto fail;\n            if (name == JS_ATOM_NULL) {\n                emit_op(s, OP_define_method_computed);\n            } else {\n                emit_op(s, OP_define_method);\n                emit_atom(s, name);\n            }\n            if (is_getset) {\n                op_flags = OP_DEFINE_METHOD_GETTER +\n                    prop_type - PROP_TYPE_GET;\n            } else {\n                op_flags = OP_DEFINE_METHOD_METHOD;\n            }\n            emit_u8(s, op_flags | OP_DEFINE_METHOD_ENUMERABLE);\n        } else {\n            if (js_parse_expect(s, ':'))\n                goto fail;\n            if (js_parse_assign_expr(s))\n                goto fail;\n            if (name == JS_ATOM_NULL) {\n                set_object_name_computed(s);\n                emit_op(s, OP_define_array_el);\n                emit_op(s, OP_drop);\n            } else if (name == JS_ATOM___proto__) {\n                if (has_proto) {\n                    js_parse_error(s, \"duplicate __proto__ property name\");\n                    goto fail;\n                }\n                emit_op(s, OP_set_proto);\n                has_proto = TRUE;\n            } else {\n                set_object_name(s, name);\n                emit_op(s, OP_define_field);\n                emit_atom(s, name);\n            }\n        }\n        JS_FreeAtom(s->ctx, name);\n    next:\n        name = JS_ATOM_NULL;\n        if (s->token.val != ',')\n            break;\n        if (next_token(s))\n            goto fail;\n    }\n    if (js_parse_expect(s, '}'))\n        goto fail;\n    return 0;\n fail:\n    JS_FreeAtom(s->ctx, name);\n    return -1;\n}\n\n/* allow the 'in' binary operator */\n#define PF_IN_ACCEPTED  (1 << 0) \n/* allow function calls parsing in js_parse_postfix_expr() */\n#define PF_POSTFIX_CALL (1 << 1) \n/* allow arrow functions parsing in js_parse_postfix_expr() */\n#define PF_ARROW_FUNC   (1 << 2) \n/* allow the exponentiation operator in js_parse_unary() */\n#define PF_POW_ALLOWED  (1 << 3) \n/* forbid the exponentiation operator in js_parse_unary() */\n#define PF_POW_FORBIDDEN (1 << 4) \n\nstatic __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags);\n\nstatic __exception int js_parse_left_hand_side_expr(JSParseState *s)\n{\n    return js_parse_postfix_expr(s, PF_POSTFIX_CALL);\n}\n\n/* XXX: could generate specific bytecode */\nstatic __exception int js_parse_class_default_ctor(JSParseState *s,\n                                                   BOOL has_super,\n                                                   JSFunctionDef **pfd)\n{\n    JSParsePos pos;\n    const char *str;\n    int ret, line_num;\n    JSParseFunctionEnum func_type;\n    const uint8_t *saved_buf_end;\n    \n    js_parse_get_pos(s, &pos);\n    if (has_super) {\n        /* spec change: no argument evaluation */\n        str = \"(){super(...arguments);}\";\n        func_type = JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR;\n    } else {\n        str = \"(){}\";\n        func_type = JS_PARSE_FUNC_CLASS_CONSTRUCTOR;\n    }\n    line_num = s->token.line_num;\n    saved_buf_end = s->buf_end;\n    s->buf_ptr = (uint8_t *)str;\n    s->buf_end = (uint8_t *)(str + strlen(str));\n    ret = next_token(s);\n    if (!ret) {\n        ret = js_parse_function_decl2(s, func_type, JS_FUNC_NORMAL,\n                                      JS_ATOM_NULL, (uint8_t *)str,\n                                      line_num, JS_PARSE_EXPORT_NONE, pfd);\n    }\n    s->buf_end = saved_buf_end;\n    ret |= js_parse_seek_token(s, &pos);\n    return ret;\n}\n\n/* find field in the current scope */\nstatic int find_private_class_field(JSContext *ctx, JSFunctionDef *fd,\n                                    JSAtom name, int scope_level)\n{\n    int idx;\n    idx = fd->scopes[scope_level].first;\n    while (idx != -1) {\n        if (fd->vars[idx].scope_level != scope_level)\n            break;\n        if (fd->vars[idx].var_name == name)\n            return idx;\n        idx = fd->vars[idx].scope_next;\n    }\n    return -1;\n}\n\n/* initialize the class fields, called by the constructor. Note:\n   super() can be called in an arrow function, so <this> and\n   <class_fields_init> can be variable references */\nstatic void emit_class_field_init(JSParseState *s)\n{\n    int label_next;\n    \n    emit_op(s, OP_scope_get_var);\n    emit_atom(s, JS_ATOM_class_fields_init);\n    emit_u16(s, s->cur_func->scope_level);\n\n    /* no need to call the class field initializer if not defined */\n    emit_op(s, OP_dup);\n    label_next = emit_goto(s, OP_if_false, -1);\n    \n    emit_op(s, OP_scope_get_var);\n    emit_atom(s, JS_ATOM_this);\n    emit_u16(s, 0);\n    \n    emit_op(s, OP_swap);\n    \n    emit_op(s, OP_call_method);\n    emit_u16(s, 0);\n\n    emit_label(s, label_next);\n    emit_op(s, OP_drop);\n}\n\n/* build a private setter function name from the private getter name */\nstatic JSAtom get_private_setter_name(JSContext *ctx, JSAtom name)\n{\n    return js_atom_concat_str(ctx, name, \"<set>\");\n}\n\ntypedef struct {\n    JSFunctionDef *fields_init_fd;\n    int computed_fields_count;\n    BOOL has_brand;\n    int brand_push_pos;\n} ClassFieldsDef;\n\nstatic __exception int emit_class_init_start(JSParseState *s,\n                                             ClassFieldsDef *cf)\n{\n    int label_add_brand;\n    \n    cf->fields_init_fd = js_parse_function_class_fields_init(s);\n    if (!cf->fields_init_fd)\n        return -1;\n\n    s->cur_func = cf->fields_init_fd;\n    \n    /* XXX: would be better to add the code only if needed, maybe in a\n       later pass */\n    emit_op(s, OP_push_false); /* will be patched later */\n    cf->brand_push_pos = cf->fields_init_fd->last_opcode_pos;\n    label_add_brand = emit_goto(s, OP_if_false, -1);\n    \n    emit_op(s, OP_scope_get_var);\n    emit_atom(s, JS_ATOM_this);\n    emit_u16(s, 0);\n    \n    emit_op(s, OP_scope_get_var);\n    emit_atom(s, JS_ATOM_home_object);\n    emit_u16(s, 0);\n    \n    emit_op(s, OP_add_brand);\n    \n    emit_label(s, label_add_brand);\n\n    s->cur_func = s->cur_func->parent;\n    return 0;\n}\n\nstatic __exception int add_brand(JSParseState *s, ClassFieldsDef *cf)\n{\n    if (!cf->has_brand) {\n        /* define the brand field in 'this' of the initializer */\n        if (!cf->fields_init_fd) {\n            if (emit_class_init_start(s, cf))\n                return -1;\n        }\n        /* patch the start of the function to enable the OP_add_brand code */\n        cf->fields_init_fd->byte_code.buf[cf->brand_push_pos] = OP_push_true;\n        \n        cf->has_brand = TRUE;\n    }\n    return 0;\n}\n\nstatic void emit_class_init_end(JSParseState *s, ClassFieldsDef *cf)\n{\n    int cpool_idx;\n        \n    s->cur_func = cf->fields_init_fd;\n    emit_op(s, OP_return_undef);\n    s->cur_func = s->cur_func->parent;\n    \n    cpool_idx = cpool_add(s, JS_NULL);\n    cf->fields_init_fd->parent_cpool_idx = cpool_idx;\n    emit_op(s, OP_fclosure);\n    emit_u32(s, cpool_idx);\n    emit_op(s, OP_set_home_object);\n}\n\n\nstatic __exception int js_parse_class(JSParseState *s, BOOL is_class_expr,\n                                      JSParseExportEnum export_flag)\n{\n    JSContext *ctx = s->ctx;\n    JSFunctionDef *fd = s->cur_func;\n    JSAtom name = JS_ATOM_NULL, class_name = JS_ATOM_NULL, class_name1;\n    JSAtom class_var_name = JS_ATOM_NULL;\n    JSFunctionDef *method_fd, *ctor_fd;\n    int saved_js_mode, class_name_var_idx, prop_type, ctor_cpool_offset;\n    int class_flags = 0, i, define_class_offset;\n    BOOL is_static, is_private;\n    const uint8_t *class_start_ptr = s->token.ptr;\n    const uint8_t *start_ptr;\n    ClassFieldsDef class_fields[2];\n        \n    /* classes are parsed and executed in strict mode */\n    saved_js_mode = fd->js_mode;\n    fd->js_mode |= JS_MODE_STRICT;\n    if (next_token(s))\n        goto fail;\n    if (s->token.val == TOK_IDENT) {\n        if (s->token.u.ident.is_reserved) {\n            js_parse_error_reserved_identifier(s);\n            goto fail;\n        }\n        class_name = JS_DupAtom(ctx, s->token.u.ident.atom);\n        if (next_token(s))\n            goto fail;\n    } else if (!is_class_expr && export_flag != JS_PARSE_EXPORT_DEFAULT) {\n        js_parse_error(s, \"class statement requires a name\");\n        goto fail;\n    }\n    if (!is_class_expr) {\n        if (class_name == JS_ATOM_NULL)\n            class_var_name = JS_ATOM__default_; /* export default */\n        else\n            class_var_name = class_name;\n        class_var_name = JS_DupAtom(ctx, class_var_name);\n    }\n\n    push_scope(s);\n\n    if (s->token.val == TOK_EXTENDS) {\n        class_flags = JS_DEFINE_CLASS_HAS_HERITAGE;\n        if (next_token(s))\n            goto fail;\n        if (js_parse_left_hand_side_expr(s))\n            goto fail;\n    } else {\n        emit_op(s, OP_undefined);\n    }\n\n    /* add a 'const' definition for the class name */\n    if (class_name != JS_ATOM_NULL) {\n        class_name_var_idx = define_var(s, fd, class_name, JS_VAR_DEF_CONST);\n        if (class_name_var_idx < 0)\n            goto fail;\n    }\n\n    if (js_parse_expect(s, '{'))\n        goto fail;\n\n    /* this scope contains the private fields */\n    push_scope(s);\n\n    emit_op(s, OP_push_const);\n    ctor_cpool_offset = fd->byte_code.size;\n    emit_u32(s, 0); /* will be patched at the end of the class parsing */\n\n    if (class_name == JS_ATOM_NULL) {\n        if (class_var_name != JS_ATOM_NULL)\n            class_name1 = JS_ATOM_default;\n        else\n            class_name1 = JS_ATOM_empty_string;\n    } else {\n        class_name1 = class_name;\n    }\n    \n    emit_op(s, OP_define_class);\n    emit_atom(s, class_name1);\n    emit_u8(s, class_flags);\n    define_class_offset = fd->last_opcode_pos;\n\n    for(i = 0; i < 2; i++) {\n        ClassFieldsDef *cf = &class_fields[i];\n        cf->fields_init_fd = NULL;\n        cf->computed_fields_count = 0;\n        cf->has_brand = FALSE;\n    }\n    \n    ctor_fd = NULL;\n    while (s->token.val != '}') {\n        if (s->token.val == ';') {\n            if (next_token(s))\n                goto fail;\n            continue;\n        }\n        is_static = (s->token.val == TOK_STATIC);\n        prop_type = -1;\n        if (is_static) {\n            if (next_token(s))\n                goto fail;\n            /* allow \"static\" field name */\n            if (s->token.val == ';' || s->token.val == '=') {\n                is_static = FALSE;\n                name = JS_DupAtom(ctx, JS_ATOM_static);\n                prop_type = PROP_TYPE_IDENT;\n            }\n        }\n        if (is_static)\n            emit_op(s, OP_swap);\n        start_ptr = s->token.ptr;\n        if (prop_type < 0) {\n            prop_type = js_parse_property_name(s, &name, TRUE, FALSE, TRUE);\n            if (prop_type < 0)\n                goto fail;\n        }\n        is_private = prop_type & PROP_TYPE_PRIVATE;\n        prop_type &= ~PROP_TYPE_PRIVATE;\n        \n        if ((name == JS_ATOM_constructor && !is_static &&\n             prop_type != PROP_TYPE_IDENT) ||\n            (name == JS_ATOM_prototype && is_static) ||\n            name == JS_ATOM_hash_constructor) {\n            js_parse_error(s, \"invalid method name\");\n            goto fail;\n        }\n        if (prop_type == PROP_TYPE_GET || prop_type == PROP_TYPE_SET) {\n            BOOL is_set = prop_type - PROP_TYPE_GET;\n            JSFunctionDef *method_fd;\n\n            if (is_private) {\n                int idx, var_kind;\n                idx = find_private_class_field(ctx, fd, name, fd->scope_level);\n                if (idx >= 0) {\n                    var_kind = fd->vars[idx].var_kind;\n                    if (var_kind == JS_VAR_PRIVATE_FIELD ||\n                        var_kind == JS_VAR_PRIVATE_METHOD ||\n                        var_kind == JS_VAR_PRIVATE_GETTER_SETTER ||\n                        var_kind == (JS_VAR_PRIVATE_GETTER + is_set)) {\n                        goto private_field_already_defined;\n                    }\n                    fd->vars[idx].var_kind = JS_VAR_PRIVATE_GETTER_SETTER;\n                } else {\n                    if (add_private_class_field(s, fd, name,\n                                                JS_VAR_PRIVATE_GETTER + is_set) < 0)\n                        goto fail;\n                }\n                if (add_brand(s, &class_fields[is_static]) < 0)\n                    goto fail;\n            }\n\n            if (js_parse_function_decl2(s, JS_PARSE_FUNC_GETTER + is_set,\n                                        JS_FUNC_NORMAL, JS_ATOM_NULL,\n                                        start_ptr, s->token.line_num,\n                                        JS_PARSE_EXPORT_NONE, &method_fd))\n                goto fail;\n            if (is_private) {\n                method_fd->need_home_object = TRUE; /* needed for brand check */\n                emit_op(s, OP_set_home_object);\n                /* XXX: missing function name */\n                emit_op(s, OP_scope_put_var_init);\n                if (is_set) {\n                    JSAtom setter_name;\n                    int ret;\n                    \n                    setter_name = get_private_setter_name(ctx, name);\n                    if (setter_name == JS_ATOM_NULL)\n                        goto fail;\n                    emit_atom(s, setter_name);\n                    ret = add_private_class_field(s, fd, setter_name,\n                                                  JS_VAR_PRIVATE_SETTER);\n                    JS_FreeAtom(ctx, setter_name);\n                    if (ret < 0)\n                        goto fail;\n                } else {\n                    emit_atom(s, name);\n                }\n                emit_u16(s, s->cur_func->scope_level);\n            } else {\n                if (name == JS_ATOM_NULL) {\n                    emit_op(s, OP_define_method_computed);\n                } else {\n                    emit_op(s, OP_define_method);\n                    emit_atom(s, name);\n                }\n                emit_u8(s, OP_DEFINE_METHOD_GETTER + is_set);\n            }\n        } else if (prop_type == PROP_TYPE_IDENT && s->token.val != '(') {\n            ClassFieldsDef *cf = &class_fields[is_static];\n            JSAtom field_var_name = JS_ATOM_NULL;\n            \n            /* class field */\n\n            /* XXX: spec: not consistent with method name checks */\n            if (name == JS_ATOM_constructor || name == JS_ATOM_prototype) {\n                js_parse_error(s, \"invalid field name\");\n                goto fail;\n            }\n            \n            if (is_private) {\n                if (find_private_class_field(ctx, fd, name,\n                                             fd->scope_level) >= 0) {\n                    goto private_field_already_defined;\n                }\n                if (add_private_class_field(s, fd, name,\n                                            JS_VAR_PRIVATE_FIELD) < 0)\n                    goto fail;\n                emit_op(s, OP_private_symbol);\n                emit_atom(s, name);\n                emit_op(s, OP_scope_put_var_init);\n                emit_atom(s, name);\n                emit_u16(s, s->cur_func->scope_level);\n            }\n\n            if (!cf->fields_init_fd) {\n                if (emit_class_init_start(s, cf))\n                    goto fail;\n            }\n            if (name == JS_ATOM_NULL ) {\n                /* save the computed field name into a variable */\n                field_var_name = js_atom_concat_num(ctx, JS_ATOM_computed_field + is_static, cf->computed_fields_count);\n                if (field_var_name == JS_ATOM_NULL)\n                    goto fail;\n                if (define_var(s, fd, field_var_name, JS_VAR_DEF_CONST) < 0) {\n                    JS_FreeAtom(ctx, field_var_name);\n                    goto fail;\n                }\n                emit_op(s, OP_to_propkey);\n                emit_op(s, OP_scope_put_var_init);\n                emit_atom(s, field_var_name);\n                emit_u16(s, s->cur_func->scope_level);\n            }\n            s->cur_func = cf->fields_init_fd;\n            emit_op(s, OP_scope_get_var);\n            emit_atom(s, JS_ATOM_this);\n            emit_u16(s, 0);\n\n            if (name == JS_ATOM_NULL) {\n                emit_op(s, OP_scope_get_var);\n                emit_atom(s, field_var_name);\n                emit_u16(s, s->cur_func->scope_level);\n                cf->computed_fields_count++;\n                JS_FreeAtom(ctx, field_var_name);\n            } else if (is_private) {\n                emit_op(s, OP_scope_get_var);\n                emit_atom(s, name);\n                emit_u16(s, s->cur_func->scope_level);\n            }\n            \n            if (s->token.val == '=') {\n                if (next_token(s))\n                    goto fail;\n                if (js_parse_assign_expr(s))\n                    goto fail;\n            } else {\n                emit_op(s, OP_undefined);\n            }\n            if (is_private) {\n                set_object_name_computed(s);\n                emit_op(s, OP_define_private_field);\n            } else if (name == JS_ATOM_NULL) {\n                set_object_name_computed(s);\n                emit_op(s, OP_define_array_el);\n                emit_op(s, OP_drop);\n            } else {\n                set_object_name(s, name);\n                emit_op(s, OP_define_field);\n                emit_atom(s, name);\n            }\n            s->cur_func = s->cur_func->parent;\n            if (js_parse_expect_semi(s))\n                goto fail;\n        } else {\n            JSParseFunctionEnum func_type;\n            JSFunctionKindEnum func_kind;\n            \n            func_type = JS_PARSE_FUNC_METHOD;\n            func_kind = JS_FUNC_NORMAL;\n            if (prop_type == PROP_TYPE_STAR) {\n                func_kind = JS_FUNC_GENERATOR;\n            } else if (prop_type == PROP_TYPE_ASYNC) {\n                func_kind = JS_FUNC_ASYNC;\n            } else if (prop_type == PROP_TYPE_ASYNC_STAR) {\n                func_kind = JS_FUNC_ASYNC_GENERATOR;\n            } else if (name == JS_ATOM_constructor && !is_static) {\n                if (ctor_fd) {\n                    js_parse_error(s, \"property constructor appears more than once\");\n                    goto fail;\n                }\n                if (class_flags & JS_DEFINE_CLASS_HAS_HERITAGE)\n                    func_type = JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR;\n                else\n                    func_type = JS_PARSE_FUNC_CLASS_CONSTRUCTOR;\n            }\n            if (is_private) {\n                if (add_brand(s, &class_fields[is_static]) < 0)\n                    goto fail;\n            }\n            if (js_parse_function_decl2(s, func_type, func_kind, JS_ATOM_NULL, start_ptr, s->token.line_num, JS_PARSE_EXPORT_NONE, &method_fd))\n                goto fail;\n            if (func_type == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR ||\n                func_type == JS_PARSE_FUNC_CLASS_CONSTRUCTOR) {\n                ctor_fd = method_fd;\n            } else if (is_private) {\n                method_fd->need_home_object = TRUE; /* needed for brand check */\n                if (find_private_class_field(ctx, fd, name,\n                                             fd->scope_level) >= 0) {\n                private_field_already_defined:\n                    js_parse_error(s, \"private class field is already defined\");\n                    goto fail;\n                }\n                if (add_private_class_field(s, fd, name,\n                                            JS_VAR_PRIVATE_METHOD) < 0)\n                    goto fail;\n                emit_op(s, OP_set_home_object);\n                emit_op(s, OP_set_name);\n                emit_atom(s, name);\n                emit_op(s, OP_scope_put_var_init);\n                emit_atom(s, name);\n                emit_u16(s, s->cur_func->scope_level);\n            } else {\n                if (name == JS_ATOM_NULL) {\n                    emit_op(s, OP_define_method_computed);\n                } else {\n                    emit_op(s, OP_define_method);\n                    emit_atom(s, name);\n                }\n                emit_u8(s, OP_DEFINE_METHOD_METHOD);\n            }\n        }\n        if (is_static)\n            emit_op(s, OP_swap);\n        JS_FreeAtom(ctx, name);\n        name = JS_ATOM_NULL;\n    }\n\n    if (s->token.val != '}') {\n        js_parse_error(s, \"expecting '%c'\", '}');\n        goto fail;\n    }\n\n    if (!ctor_fd) {\n        if (js_parse_class_default_ctor(s, class_flags & JS_DEFINE_CLASS_HAS_HERITAGE, &ctor_fd))\n            goto fail;\n    }\n    /* patch the constant pool index for the constructor */\n    put_u32(fd->byte_code.buf + ctor_cpool_offset, ctor_fd->parent_cpool_idx);\n\n    /* store the class source code in the constructor. */\n    if (!(fd->js_mode & JS_MODE_STRIP)) {\n        js_free(ctx, ctor_fd->source);\n        ctor_fd->source_len = s->buf_ptr - class_start_ptr;\n        ctor_fd->source = js_strndup(ctx, (const char *)class_start_ptr,\n                                     ctor_fd->source_len);\n        if (!ctor_fd->source)\n            goto fail;\n    }\n\n    /* consume the '}' */\n    if (next_token(s))\n        goto fail;\n\n    /* store the function to initialize the fields to that it can be\n       referenced by the constructor */\n    {\n        ClassFieldsDef *cf = &class_fields[0];\n        int var_idx;\n        \n        var_idx = define_var(s, fd, JS_ATOM_class_fields_init,\n                             JS_VAR_DEF_CONST);\n        if (var_idx < 0)\n            goto fail;\n        if (cf->fields_init_fd) {\n            emit_class_init_end(s, cf);\n        } else {\n            emit_op(s, OP_undefined);\n        }\n        emit_op(s, OP_scope_put_var_init);\n        emit_atom(s, JS_ATOM_class_fields_init);\n        emit_u16(s, s->cur_func->scope_level);\n    }\n\n    /* drop the prototype */\n    emit_op(s, OP_drop);\n\n    /* initialize the static fields */\n    if (class_fields[1].fields_init_fd != NULL) {\n        ClassFieldsDef *cf = &class_fields[1];\n        emit_op(s, OP_dup);\n        emit_class_init_end(s, cf);\n        emit_op(s, OP_call_method);\n        emit_u16(s, 0);\n        emit_op(s, OP_drop);\n    }\n    \n    if (class_name != JS_ATOM_NULL) {\n        /* store the class name in the scoped class name variable (it\n           is independent from the class statement variable\n           definition) */\n        emit_op(s, OP_dup);\n        emit_op(s, OP_scope_put_var_init);\n        emit_atom(s, class_name);\n        emit_u16(s, fd->scope_level);\n    }\n    pop_scope(s);\n    pop_scope(s);\n\n    /* the class statements have a block level scope */\n    if (class_var_name != JS_ATOM_NULL) {\n        if (define_var(s, fd, class_var_name, JS_VAR_DEF_LET) < 0)\n            goto fail;\n        emit_op(s, OP_scope_put_var_init);\n        emit_atom(s, class_var_name);\n        emit_u16(s, fd->scope_level);\n    } else {\n        if (class_name == JS_ATOM_NULL) {\n            /* cannot use OP_set_name because the name of the class\n               must be defined before the static initializers are\n               executed */\n            emit_op(s, OP_set_class_name);\n            emit_u32(s, fd->last_opcode_pos + 1 - define_class_offset);\n        }\n    }\n\n    if (export_flag != JS_PARSE_EXPORT_NONE) {\n        if (!add_export_entry(s, fd->module,\n                              class_var_name,\n                              export_flag == JS_PARSE_EXPORT_NAMED ? class_var_name : JS_ATOM_default,\n                              JS_EXPORT_TYPE_LOCAL))\n            goto fail;\n    }\n\n    JS_FreeAtom(ctx, class_name);\n    JS_FreeAtom(ctx, class_var_name);\n    fd->js_mode = saved_js_mode;\n    return 0;\n fail:\n    JS_FreeAtom(ctx, name);\n    JS_FreeAtom(ctx, class_name);\n    JS_FreeAtom(ctx, class_var_name);\n    fd->js_mode = saved_js_mode;\n    return -1;\n}\n\nstatic __exception int js_parse_array_literal(JSParseState *s)\n{\n    uint32_t idx;\n    BOOL need_length;\n\n    if (next_token(s))\n        return -1;\n    /* small regular arrays are created on the stack */\n    idx = 0;\n    while (s->token.val != ']' && idx < 32) {\n        if (s->token.val == ',' || s->token.val == TOK_ELLIPSIS)\n            break;\n        if (js_parse_assign_expr(s))\n            return -1;\n        idx++;\n        /* accept trailing comma */\n        if (s->token.val == ',') {\n            if (next_token(s))\n                return -1;\n        } else\n        if (s->token.val != ']')\n            goto done;\n    }\n    emit_op(s, OP_array_from);\n    emit_u16(s, idx);\n\n    /* larger arrays and holes are handled with explicit indices */\n    need_length = FALSE;\n    while (s->token.val != ']' && idx < 0x7fffffff) {\n        if (s->token.val == TOK_ELLIPSIS)\n            break;\n        need_length = TRUE;\n        if (s->token.val != ',') {\n            if (js_parse_assign_expr(s))\n                return -1;\n            emit_op(s, OP_define_field);\n            emit_u32(s, __JS_AtomFromUInt32(idx));\n            need_length = FALSE;\n        }\n        idx++;\n        /* accept trailing comma */\n        if (s->token.val == ',') {\n            if (next_token(s))\n                return -1;\n        }\n    }\n    if (s->token.val == ']') {\n        if (need_length) {\n            /* Set the length: Cannot use OP_define_field because\n               length is not configurable */\n            emit_op(s, OP_dup);\n            emit_op(s, OP_push_i32);\n            emit_u32(s, idx);\n            emit_op(s, OP_put_field);\n            emit_atom(s, JS_ATOM_length);\n        }\n        goto done;\n    }\n\n    /* huge arrays and spread elements require a dynamic index on the stack */\n    emit_op(s, OP_push_i32);\n    emit_u32(s, idx);\n\n    /* stack has array, index */\n    while (s->token.val != ']') {\n        if (s->token.val == TOK_ELLIPSIS) {\n            if (next_token(s))\n                return -1;\n            if (js_parse_assign_expr(s))\n                return -1;\n#if 1\n            emit_op(s, OP_append);\n#else\n            int label_next, label_done;\n            label_next = new_label(s);\n            label_done = new_label(s);\n            /* enumerate object */\n            emit_op(s, OP_for_of_start);\n            emit_op(s, OP_rot5l);\n            emit_op(s, OP_rot5l);\n            emit_label(s, label_next);\n            /* on stack: enum_rec array idx */\n            emit_op(s, OP_for_of_next);\n            emit_u8(s, 2);\n            emit_goto(s, OP_if_true, label_done);\n            /* append element */\n            /* enum_rec array idx val -> enum_rec array new_idx */\n            emit_op(s, OP_define_array_el);\n            emit_op(s, OP_inc);\n            emit_goto(s, OP_goto, label_next);\n            emit_label(s, label_done);\n            /* close enumeration */\n            emit_op(s, OP_drop); /* drop undef val */\n            emit_op(s, OP_nip1); /* drop enum_rec */\n            emit_op(s, OP_nip1);\n            emit_op(s, OP_nip1);\n#endif\n        } else {\n            need_length = TRUE;\n            if (s->token.val != ',') {\n                if (js_parse_assign_expr(s))\n                    return -1;\n                /* a idx val */\n                emit_op(s, OP_define_array_el);\n                need_length = FALSE;\n            }\n            emit_op(s, OP_inc);\n        }\n        if (s->token.val != ',')\n            break;\n        if (next_token(s))\n            return -1;\n    }\n    if (need_length) {\n        /* Set the length: cannot use OP_define_field because\n           length is not configurable */\n        emit_op(s, OP_dup1);    /* array length - array array length */\n        emit_op(s, OP_put_field);\n        emit_atom(s, JS_ATOM_length);\n    } else {\n        emit_op(s, OP_drop);    /* array length - array */\n    }\ndone:\n    return js_parse_expect(s, ']');\n}\n\n/* XXX: remove */\nstatic BOOL has_with_scope(JSFunctionDef *s, int scope_level)\n{\n    /* check if scope chain contains a with statement */\n    while (s) {\n        int scope_idx = s->scopes[scope_level].first;\n        while (scope_idx >= 0) {\n            JSVarDef *vd = &s->vars[scope_idx];\n\n            if (vd->var_name == JS_ATOM__with_)\n                return TRUE;\n            scope_idx = vd->scope_next;\n        }\n        /* check parent scopes */\n        scope_level = s->parent_scope_level;\n        s = s->parent;\n    }\n    return FALSE;\n}\n\nstatic __exception int get_lvalue(JSParseState *s, int *popcode, int *pscope,\n                                  JSAtom *pname, int *plabel, int *pdepth, BOOL keep,\n                                  int tok)\n{\n    JSFunctionDef *fd;\n    int opcode, scope, label, depth;\n    JSAtom name;\n\n    /* we check the last opcode to get the lvalue type */\n    fd = s->cur_func;\n    scope = 0;\n    name = JS_ATOM_NULL;\n    label = -1;\n    depth = 0;\n    switch(opcode = get_prev_opcode(fd)) {\n    case OP_scope_get_var:\n        name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);\n        scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);\n        if ((name == JS_ATOM_arguments || name == JS_ATOM_eval) &&\n            (fd->js_mode & JS_MODE_STRICT)) {\n            return js_parse_error(s, \"invalid lvalue in strict mode\");\n        }\n        if (name == JS_ATOM_this || name == JS_ATOM_new_target)\n            goto invalid_lvalue;\n        depth = 2;  /* will generate OP_get_ref_value */\n        break;\n    case OP_get_field:\n        name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);\n        depth = 1;\n        break;\n    case OP_scope_get_private_field:\n        name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);\n        scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);\n        depth = 1;\n        break;\n    case OP_get_array_el:\n        depth = 2;\n        break;\n    case OP_get_super_value:\n        depth = 3;\n        break;\n    default:\n    invalid_lvalue:\n        if (tok == TOK_FOR) {\n            return js_parse_error(s, \"invalid for in/of left hand-side\");\n        } else if (tok == TOK_INC || tok == TOK_DEC) {\n            return js_parse_error(s, \"invalid increment/decrement operand\");\n        } else if (tok == '[' || tok == '{') {\n            return js_parse_error(s, \"invalid destructuring target\");\n        } else {\n            return js_parse_error(s, \"invalid assignment left-hand side\");\n        }\n    }\n    /* remove the last opcode */\n    fd->byte_code.size = fd->last_opcode_pos;\n    fd->last_opcode_pos = -1;\n\n    if (keep) {\n        /* get the value but keep the object/fields on the stack */\n        switch(opcode) {\n        case OP_scope_get_var:\n            label = new_label(s);\n            emit_op(s, OP_scope_make_ref);\n            emit_atom(s, name);\n            emit_u32(s, label);\n            emit_u16(s, scope);\n            update_label(fd, label, 1);\n            emit_op(s, OP_get_ref_value);\n            opcode = OP_get_ref_value;\n            break;\n        case OP_get_field:\n            emit_op(s, OP_get_field2);\n            emit_atom(s, name);\n            break;\n        case OP_scope_get_private_field:\n            emit_op(s, OP_scope_get_private_field2);\n            emit_atom(s, name);\n            emit_u16(s, scope);\n            break;\n        case OP_get_array_el:\n            /* XXX: replace by a single opcode ? */\n            emit_op(s, OP_to_propkey2);\n            emit_op(s, OP_dup2);\n            emit_op(s, OP_get_array_el);\n            break;\n        case OP_get_super_value:\n            emit_op(s, OP_to_propkey);\n            emit_op(s, OP_dup3);\n            emit_op(s, OP_get_super_value);\n            break;\n        default:\n            abort();\n        }\n    } else {\n        switch(opcode) {\n        case OP_scope_get_var:\n            label = new_label(s);\n            emit_op(s, OP_scope_make_ref);\n            emit_atom(s, name);\n            emit_u32(s, label);\n            emit_u16(s, scope);\n            update_label(fd, label, 1);\n            opcode = OP_get_ref_value;\n            break;\n        case OP_get_array_el:\n            emit_op(s, OP_to_propkey2);\n            break;\n        case OP_get_super_value:\n            emit_op(s, OP_to_propkey);\n            break;\n        }\n    }\n\n    *popcode = opcode;\n    *pscope = scope;\n    /* name has refcount for OP_get_field and OP_get_ref_value,\n       and JS_ATOM_NULL for other opcodes */\n    *pname = name;\n    *plabel = label;\n    if (pdepth)\n        *pdepth = depth;\n    return 0;\n}\n\ntypedef enum {\n    PUT_LVALUE_NOKEEP, /* [depth] v -> */\n    PUT_LVALUE_NOKEEP_DEPTH, /* [depth] v -> , keep depth (currently\n                                just disable optimizations) */\n    PUT_LVALUE_KEEP_TOP,  /* [depth] v -> v */\n    PUT_LVALUE_KEEP_SECOND, /* [depth] v0 v -> v0 */\n    PUT_LVALUE_NOKEEP_BOTTOM, /* v [depth] -> */\n} PutLValueEnum;\n\n/* name has a live reference. 'is_let' is only used with opcode =\n   OP_scope_get_var which is never generated by get_lvalue(). */\nstatic void put_lvalue(JSParseState *s, int opcode, int scope,\n                       JSAtom name, int label, PutLValueEnum special,\n                       BOOL is_let)\n{\n    switch(opcode) {\n    case OP_get_field:\n    case OP_scope_get_private_field:\n        /* depth = 1 */\n        switch(special) {\n        case PUT_LVALUE_NOKEEP:\n        case PUT_LVALUE_NOKEEP_DEPTH:\n            break;\n        case PUT_LVALUE_KEEP_TOP:\n            emit_op(s, OP_insert2); /* obj v -> v obj v */\n            break;\n        case PUT_LVALUE_KEEP_SECOND:\n            emit_op(s, OP_perm3); /* obj v0 v -> v0 obj v */\n            break;\n        case PUT_LVALUE_NOKEEP_BOTTOM:\n            emit_op(s, OP_swap);\n            break;\n        default:\n            abort();\n        }\n        break;\n    case OP_get_array_el:\n    case OP_get_ref_value:\n        /* depth = 2 */\n        if (opcode == OP_get_ref_value) {\n            JS_FreeAtom(s->ctx, name);\n            emit_label(s, label);\n        }\n        switch(special) {\n        case PUT_LVALUE_NOKEEP:\n            emit_op(s, OP_nop); /* will trigger optimization */\n            break;\n        case PUT_LVALUE_NOKEEP_DEPTH:\n            break;\n        case PUT_LVALUE_KEEP_TOP:\n            emit_op(s, OP_insert3); /* obj prop v -> v obj prop v */\n            break;\n        case PUT_LVALUE_KEEP_SECOND:\n            emit_op(s, OP_perm4); /* obj prop v0 v -> v0 obj prop v */\n            break;\n        case PUT_LVALUE_NOKEEP_BOTTOM:\n            emit_op(s, OP_rot3l);\n            break;\n        default:\n            abort();\n        }\n        break;\n    case OP_get_super_value:\n        /* depth = 3 */\n        switch(special) {\n        case PUT_LVALUE_NOKEEP:\n        case PUT_LVALUE_NOKEEP_DEPTH:\n            break;\n        case PUT_LVALUE_KEEP_TOP:\n            emit_op(s, OP_insert4); /* this obj prop v -> v this obj prop v */\n            break;\n        case PUT_LVALUE_KEEP_SECOND:\n            emit_op(s, OP_perm5); /* this obj prop v0 v -> v0 this obj prop v */\n            break;\n        case PUT_LVALUE_NOKEEP_BOTTOM:\n            emit_op(s, OP_rot4l);\n            break;\n        default:\n            abort();\n        }\n        break;\n    default:\n        break;\n    }\n    \n    switch(opcode) {\n    case OP_scope_get_var:  /* val -- */\n        assert(special == PUT_LVALUE_NOKEEP ||\n               special == PUT_LVALUE_NOKEEP_DEPTH);\n        emit_op(s, is_let ? OP_scope_put_var_init : OP_scope_put_var);\n        emit_u32(s, name);  /* has refcount */\n        emit_u16(s, scope);\n        break;\n    case OP_get_field:\n        emit_op(s, OP_put_field);\n        emit_u32(s, name);  /* name has refcount */\n        break;\n    case OP_scope_get_private_field:\n        emit_op(s, OP_scope_put_private_field);\n        emit_u32(s, name);  /* name has refcount */\n        emit_u16(s, scope);\n        break;\n    case OP_get_array_el:\n        emit_op(s, OP_put_array_el);\n        break;\n    case OP_get_ref_value:\n        emit_op(s, OP_put_ref_value);\n        break;\n    case OP_get_super_value:\n        emit_op(s, OP_put_super_value);\n        break;\n    default:\n        abort();\n    }\n}\n\nstatic __exception int js_parse_expr_paren(JSParseState *s)\n{\n    if (js_parse_expect(s, '('))\n        return -1;\n    if (js_parse_expr(s))\n        return -1;\n    if (js_parse_expect(s, ')'))\n        return -1;\n    return 0;\n}\n\nstatic int js_unsupported_keyword(JSParseState *s, JSAtom atom)\n{\n    char buf[ATOM_GET_STR_BUF_SIZE];\n    return js_parse_error(s, \"unsupported keyword: %s\",\n                          JS_AtomGetStr(s->ctx, buf, sizeof(buf), atom));\n}\n\nstatic __exception int js_define_var(JSParseState *s, JSAtom name, int tok)\n{\n    JSFunctionDef *fd = s->cur_func;\n    JSVarDefEnum var_def_type;\n    \n    if (name == JS_ATOM_yield && fd->func_kind == JS_FUNC_GENERATOR) {\n        return js_parse_error(s, \"yield is a reserved identifier\");\n    }\n    if ((name == JS_ATOM_arguments || name == JS_ATOM_eval)\n    &&  (fd->js_mode & JS_MODE_STRICT)) {\n        return js_parse_error(s, \"invalid variable name in strict mode\");\n    }\n    if ((name == JS_ATOM_let || name == JS_ATOM_undefined)\n    &&  (tok == TOK_LET || tok == TOK_CONST)) {\n        return js_parse_error(s, \"invalid lexical variable name\");\n    }\n    switch(tok) {\n    case TOK_LET:\n        var_def_type = JS_VAR_DEF_LET;\n        break;\n    case TOK_CONST:\n        var_def_type = JS_VAR_DEF_CONST;\n        break;\n    case TOK_VAR:\n        var_def_type = JS_VAR_DEF_VAR;\n        break;\n    case TOK_CATCH:\n        var_def_type = JS_VAR_DEF_CATCH;\n        break;\n    default:\n        abort();\n    }\n    if (define_var(s, fd, name, var_def_type) < 0)\n        return -1;\n    return 0;\n}\n\nstatic void js_emit_spread_code(JSParseState *s, int depth)\n{\n    int label_rest_next, label_rest_done;\n\n    /* XXX: could check if enum object is an actual array and optimize\n       slice extraction. enumeration record and target array are in a\n       different order from OP_append case. */\n    /* enum_rec xxx -- enum_rec xxx array 0 */\n    emit_op(s, OP_array_from);\n    emit_u16(s, 0);\n    emit_op(s, OP_push_i32);\n    emit_u32(s, 0);\n    emit_label(s, label_rest_next = new_label(s));\n    emit_op(s, OP_for_of_next);\n    emit_u8(s, 2 + depth);\n    label_rest_done = emit_goto(s, OP_if_true, -1);\n    /* array idx val -- array idx */\n    emit_op(s, OP_define_array_el);\n    emit_op(s, OP_inc);\n    emit_goto(s, OP_goto, label_rest_next);\n    emit_label(s, label_rest_done);\n    /* enum_rec xxx array idx undef -- enum_rec xxx array */\n    emit_op(s, OP_drop);\n    emit_op(s, OP_drop);\n}\n\nstatic int js_parse_check_duplicate_parameter(JSParseState *s, JSAtom name)\n{\n    /* Check for duplicate parameter names */\n    JSFunctionDef *fd = s->cur_func;\n    int i;\n    for (i = 0; i < fd->arg_count; i++) {\n        if (fd->args[i].var_name == name)\n            goto duplicate;\n    }\n    for (i = 0; i < fd->var_count; i++) {\n        if (fd->vars[i].var_name == name)\n            goto duplicate;\n    }\n    return 0;\n\nduplicate:\n    return js_parse_error(s, \"duplicate parameter names not allowed in this context\");\n}\n\nstatic JSAtom js_parse_destructuring_var(JSParseState *s, int tok, int is_arg)\n{\n    JSAtom name;\n\n    if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)\n    ||  ((s->cur_func->js_mode & JS_MODE_STRICT) &&\n         (s->token.u.ident.atom == JS_ATOM_eval || s->token.u.ident.atom == JS_ATOM_arguments))) {\n        js_parse_error(s, \"invalid destructuring target\");\n        return JS_ATOM_NULL;\n    }\n    name = JS_DupAtom(s->ctx, s->token.u.ident.atom);\n    if (is_arg && js_parse_check_duplicate_parameter(s, name))\n        goto fail;\n    if (next_token(s))\n        goto fail;\n\n    return name;\nfail:\n    JS_FreeAtom(s->ctx, name);\n    return JS_ATOM_NULL;\n}\n\n/* Return -1 if error, 0 if no initializer, 1 if an initializer is\n   present at the top level. */\nstatic int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,\n                                        int hasval, int has_ellipsis,\n                                        BOOL allow_initializer)\n{\n    int label_parse, label_assign, label_done, label_lvalue, depth_lvalue;\n    int start_addr, assign_addr;\n    JSAtom prop_name, var_name;\n    int opcode, scope, tok1, skip_bits;\n    BOOL has_initializer;\n    \n    if (has_ellipsis < 0) {\n        /* pre-parse destructuration target for spread detection */\n        js_parse_skip_parens_token(s, &skip_bits, FALSE);\n        has_ellipsis = skip_bits & SKIP_HAS_ELLIPSIS;\n    }\n\n    label_parse = new_label(s);\n    label_assign = new_label(s);\n\n    start_addr = s->cur_func->byte_code.size;\n    if (hasval) {\n        /* consume value from the stack */\n        emit_op(s, OP_dup);\n        emit_op(s, OP_undefined);\n        emit_op(s, OP_strict_eq);\n        emit_goto(s, OP_if_true, label_parse);\n        emit_label(s, label_assign);\n    } else {\n        emit_goto(s, OP_goto, label_parse);\n        emit_label(s, label_assign);\n        /* leave value on the stack */\n        emit_op(s, OP_dup);\n    }\n    assign_addr = s->cur_func->byte_code.size;\n    if (s->token.val == '{') {\n        if (next_token(s))\n            return -1;\n        /* throw an exception if the value cannot be converted to an object */\n        emit_op(s, OP_to_object);\n        if (has_ellipsis) {\n            /* add excludeList on stack just below src object */\n            emit_op(s, OP_object);\n            emit_op(s, OP_swap);\n        }\n        while (s->token.val != '}') {\n            int prop_type;\n            if (s->token.val == TOK_ELLIPSIS) {\n                if (!has_ellipsis) {\n                    JS_ThrowInternalError(s->ctx, \"unexpected ellipsis token\");\n                    return -1;\n                }\n                if (next_token(s))\n                    return -1;\n                if (tok) {\n                    var_name = js_parse_destructuring_var(s, tok, is_arg);\n                    if (var_name == JS_ATOM_NULL)\n                        return -1;\n                    opcode = OP_scope_get_var;\n                    scope = s->cur_func->scope_level;\n                    label_lvalue = -1;\n                    depth_lvalue = 0;\n                } else {\n                    if (js_parse_left_hand_side_expr(s))\n                        return -1;\n\n                    if (get_lvalue(s, &opcode, &scope, &var_name,\n                                   &label_lvalue, &depth_lvalue, FALSE, '{'))\n                        return -1;\n                }\n                if (s->token.val != '}') {\n                    js_parse_error(s, \"assignment rest property must be last\");\n                    goto var_error;\n                }\n                emit_op(s, OP_object);  /* target */\n                emit_op(s, OP_copy_data_properties);\n                emit_u8(s, 0 | ((depth_lvalue + 1) << 2) | ((depth_lvalue + 2) << 5));\n                goto set_val;\n            }\n            prop_type = js_parse_property_name(s, &prop_name, FALSE, TRUE, FALSE);\n            if (prop_type < 0)\n                return -1;\n            var_name = JS_ATOM_NULL;\n            opcode = OP_scope_get_var;\n            scope = s->cur_func->scope_level;\n            label_lvalue = -1;\n            depth_lvalue = 0;\n            if (prop_type == PROP_TYPE_IDENT) {\n                if (next_token(s))\n                    goto prop_error;\n                if ((s->token.val == '[' || s->token.val == '{')\n                    &&  ((tok1 = js_parse_skip_parens_token(s, &skip_bits, FALSE)) == ',' ||\n                         tok1 == '=' || tok1 == '}')) {\n                    if (prop_name == JS_ATOM_NULL) {\n                        /* computed property name on stack */\n                        if (has_ellipsis) {\n                            /* define the property in excludeList */\n                            emit_op(s, OP_to_propkey); /* avoid calling ToString twice */\n                            emit_op(s, OP_perm3); /* TOS: src excludeList prop */\n                            emit_op(s, OP_null); /* TOS: src excludeList prop null */\n                            emit_op(s, OP_define_array_el); /* TOS: src excludeList prop */\n                            emit_op(s, OP_perm3); /* TOS: excludeList src prop */\n                        }\n                        /* get the computed property from the source object */\n                        emit_op(s, OP_get_array_el2);\n                    } else {\n                        /* named property */\n                        if (has_ellipsis) {\n                            /* define the property in excludeList */\n                            emit_op(s, OP_swap); /* TOS: src excludeList */\n                            emit_op(s, OP_null); /* TOS: src excludeList null */\n                            emit_op(s, OP_define_field); /* TOS: src excludeList */\n                            emit_atom(s, prop_name);\n                            emit_op(s, OP_swap); /* TOS: excludeList src */\n                        }\n                        /* get the named property from the source object */\n                        emit_op(s, OP_get_field2);\n                        emit_u32(s, prop_name);\n                    }\n                    if (js_parse_destructuring_element(s, tok, is_arg, TRUE, -1, TRUE) < 0)\n                        return -1;\n                    if (s->token.val == '}')\n                        break;\n                    /* accept a trailing comma before the '}' */\n                    if (js_parse_expect(s, ','))\n                        return -1;\n                    continue;\n                }\n                if (prop_name == JS_ATOM_NULL) {\n                    emit_op(s, OP_to_propkey2);\n                    if (has_ellipsis) {\n                        /* define the property in excludeList */\n                        emit_op(s, OP_perm3);\n                        emit_op(s, OP_null);\n                        emit_op(s, OP_define_array_el);\n                        emit_op(s, OP_perm3);\n                    }\n                    /* source prop -- source source prop */\n                    emit_op(s, OP_dup1);\n                } else {\n                    if (has_ellipsis) {\n                        /* define the property in excludeList */\n                        emit_op(s, OP_swap);\n                        emit_op(s, OP_null);\n                        emit_op(s, OP_define_field);\n                        emit_atom(s, prop_name);\n                        emit_op(s, OP_swap);\n                    }\n                    /* source -- source source */\n                    emit_op(s, OP_dup);\n                }\n                if (tok) {\n                    var_name = js_parse_destructuring_var(s, tok, is_arg);\n                    if (var_name == JS_ATOM_NULL)\n                        goto prop_error;\n                } else {\n                    if (js_parse_left_hand_side_expr(s))\n                        goto prop_error;\n                lvalue:\n                    if (get_lvalue(s, &opcode, &scope, &var_name,\n                                   &label_lvalue, &depth_lvalue, FALSE, '{'))\n                        goto prop_error;\n                    /* swap ref and lvalue object if any */\n                    if (prop_name == JS_ATOM_NULL) {\n                        switch(depth_lvalue) {\n                        case 1:\n                            /* source prop x -> x source prop */\n                            emit_op(s, OP_rot3r);\n                            break;\n                        case 2:\n                            /* source prop x y -> x y source prop */\n                            emit_op(s, OP_swap2);   /* t p2 s p1 */\n                            break;\n                        case 3:\n                            /* source prop x y z -> x y z source prop */\n                            emit_op(s, OP_rot5l);\n                            emit_op(s, OP_rot5l);\n                            break;\n                        }\n                    } else {\n                        switch(depth_lvalue) {\n                        case 1:\n                            /* source x -> x source */\n                            emit_op(s, OP_swap);\n                            break;\n                        case 2:\n                            /* source x y -> x y source */\n                            emit_op(s, OP_rot3l);\n                            break;\n                        case 3:\n                            /* source x y z -> x y z source */\n                            emit_op(s, OP_rot4l);\n                            break;\n                        }\n                    }\n                }\n                if (prop_name == JS_ATOM_NULL) {\n                    /* computed property name on stack */\n                    /* XXX: should have OP_get_array_el2x with depth */\n                    /* source prop -- val */\n                    emit_op(s, OP_get_array_el);\n                } else {\n                    /* named property */\n                    /* XXX: should have OP_get_field2x with depth */\n                    /* source -- val */\n                    emit_op(s, OP_get_field);\n                    emit_u32(s, prop_name);\n                }\n            } else {\n                /* prop_type = PROP_TYPE_VAR, cannot be a computed property */\n                if (is_arg && js_parse_check_duplicate_parameter(s, prop_name))\n                    goto prop_error;\n                if ((s->cur_func->js_mode & JS_MODE_STRICT) &&\n                    (prop_name == JS_ATOM_eval || prop_name == JS_ATOM_arguments)) {\n                    js_parse_error(s, \"invalid destructuring target\");\n                    goto prop_error;\n                }\n                if (has_ellipsis) {\n                    /* define the property in excludeList */\n                    emit_op(s, OP_swap);\n                    emit_op(s, OP_null);\n                    emit_op(s, OP_define_field);\n                    emit_atom(s, prop_name);\n                    emit_op(s, OP_swap);\n                }\n                if (!tok || tok == TOK_VAR) {\n                    /* generate reference */\n                    /* source -- source source */\n                    emit_op(s, OP_dup);\n                    emit_op(s, OP_scope_get_var);\n                    emit_atom(s, prop_name);\n                    emit_u16(s, s->cur_func->scope_level);\n                    goto lvalue;\n                }\n                var_name = JS_DupAtom(s->ctx, prop_name);\n                /* source -- source val */\n                emit_op(s, OP_get_field2);\n                emit_u32(s, prop_name);\n            }\n        set_val:\n            if (tok) {\n                if (js_define_var(s, var_name, tok))\n                    goto var_error;\n                scope = s->cur_func->scope_level;\n            }\n            if (s->token.val == '=') {  /* handle optional default value */\n                int label_hasval;\n                emit_op(s, OP_dup);\n                emit_op(s, OP_undefined);\n                emit_op(s, OP_strict_eq);\n                label_hasval = emit_goto(s, OP_if_false, -1);\n                if (next_token(s))\n                    goto var_error;\n                emit_op(s, OP_drop);\n                if (js_parse_assign_expr(s))\n                    goto var_error;\n                if (opcode == OP_scope_get_var || opcode == OP_get_ref_value)\n                    set_object_name(s, var_name);\n                emit_label(s, label_hasval);\n            }\n            /* store value into lvalue object */\n            put_lvalue(s, opcode, scope, var_name, label_lvalue,\n                       PUT_LVALUE_NOKEEP_DEPTH,\n                       (tok == TOK_CONST || tok == TOK_LET));\n            if (s->token.val == '}')\n                break;\n            /* accept a trailing comma before the '}' */\n            if (js_parse_expect(s, ','))\n                return -1;\n        }\n        /* drop the source object */\n        emit_op(s, OP_drop);\n        if (has_ellipsis) {\n            emit_op(s, OP_drop); /* pop excludeList */\n        }\n        if (next_token(s))\n            return -1;\n    } else if (s->token.val == '[') {\n        BOOL has_spread;\n        int enum_depth;\n        BlockEnv block_env;\n\n        if (next_token(s))\n            return -1;\n        /* the block environment is only needed in generators in case\n           'yield' triggers a 'return' */\n        push_break_entry(s->cur_func, &block_env,\n                         JS_ATOM_NULL, -1, -1, 2);\n        block_env.has_iterator = TRUE;\n        emit_op(s, OP_for_of_start);\n        has_spread = FALSE;\n        while (s->token.val != ']') {\n            /* get the next value */\n            if (s->token.val == TOK_ELLIPSIS) {\n                if (next_token(s))\n                    return -1;\n                if (s->token.val == ',' || s->token.val == ']')\n                    return js_parse_error(s, \"missing binding pattern...\");\n                has_spread = TRUE;\n            }\n            if (s->token.val == ',') {\n                /* do nothing, skip the value, has_spread is false */\n                emit_op(s, OP_for_of_next);\n                emit_u8(s, 0);\n                emit_op(s, OP_drop);\n                emit_op(s, OP_drop);\n            } else if ((s->token.val == '[' || s->token.val == '{')\n                   &&  ((tok1 = js_parse_skip_parens_token(s, &skip_bits, FALSE)) == ',' ||\n                        tok1 == '=' || tok1 == ']')) {\n                if (has_spread) {\n                    if (tok1 == '=')\n                        return js_parse_error(s, \"rest element cannot have a default value\");\n                    js_emit_spread_code(s, 0);\n                } else {\n                    emit_op(s, OP_for_of_next);\n                    emit_u8(s, 0);\n                    emit_op(s, OP_drop);\n                }\n                if (js_parse_destructuring_element(s, tok, is_arg, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)\n                    return -1;\n            } else {\n                var_name = JS_ATOM_NULL;\n                enum_depth = 0;\n                if (tok) {\n                    var_name = js_parse_destructuring_var(s, tok, is_arg);\n                    if (var_name == JS_ATOM_NULL)\n                        goto var_error;\n                    if (js_define_var(s, var_name, tok))\n                        goto var_error;\n                    opcode = OP_scope_get_var;\n                    scope = s->cur_func->scope_level;\n                } else {\n                    if (js_parse_left_hand_side_expr(s))\n                        return -1;\n                    if (get_lvalue(s, &opcode, &scope, &var_name,\n                                   &label_lvalue, &enum_depth, FALSE, '[')) {\n                        return -1;\n                    }\n                }\n                if (has_spread) {\n                    js_emit_spread_code(s, enum_depth);\n                } else {\n                    emit_op(s, OP_for_of_next);\n                    emit_u8(s, enum_depth);\n                    emit_op(s, OP_drop);\n                }\n                if (s->token.val == '=' && !has_spread) {\n                    /* handle optional default value */\n                    int label_hasval;\n                    emit_op(s, OP_dup);\n                    emit_op(s, OP_undefined);\n                    emit_op(s, OP_strict_eq);\n                    label_hasval = emit_goto(s, OP_if_false, -1);\n                    if (next_token(s))\n                        goto var_error;\n                    emit_op(s, OP_drop);\n                    if (js_parse_assign_expr(s))\n                        goto var_error;\n                    if (opcode == OP_scope_get_var || opcode == OP_get_ref_value)\n                        set_object_name(s, var_name);\n                    emit_label(s, label_hasval);\n                }\n                /* store value into lvalue object */\n                put_lvalue(s, opcode, scope, var_name,\n                           label_lvalue, PUT_LVALUE_NOKEEP_DEPTH,\n                           (tok == TOK_CONST || tok == TOK_LET));\n            }\n            if (s->token.val == ']')\n                break;\n            if (has_spread)\n                return js_parse_error(s, \"rest element must be the last one\");\n            /* accept a trailing comma before the ']' */\n            if (js_parse_expect(s, ','))\n                return -1;\n        }\n        /* close iterator object:\n           if completed, enum_obj has been replaced by undefined */\n        emit_op(s, OP_iterator_close);\n        pop_break_entry(s->cur_func);\n        if (next_token(s))\n            return -1;\n    } else {\n        return js_parse_error(s, \"invalid assignment syntax\");\n    }\n    if (s->token.val == '=' && allow_initializer) {\n        label_done = emit_goto(s, OP_goto, -1);\n        if (next_token(s))\n            return -1;\n        emit_label(s, label_parse);\n        if (hasval)\n            emit_op(s, OP_drop);\n        if (js_parse_assign_expr(s))\n            return -1;\n        emit_goto(s, OP_goto, label_assign);\n        emit_label(s, label_done);\n        has_initializer = TRUE;\n    } else {\n        /* normally hasval is true except if\n           js_parse_skip_parens_token() was wrong in the parsing */\n        //        assert(hasval);\n        if (!hasval) {\n            js_parse_error(s, \"too complicated destructuring expression\");\n            return -1;\n        }\n        /* remove test and decrement label ref count */\n        memset(s->cur_func->byte_code.buf + start_addr, OP_nop,\n               assign_addr - start_addr);\n        s->cur_func->label_slots[label_parse].ref_count--;\n        has_initializer = FALSE;\n    }\n    return has_initializer;\n\n prop_error:\n    JS_FreeAtom(s->ctx, prop_name);\n var_error:\n    JS_FreeAtom(s->ctx, var_name);\n    return -1;\n}\n\ntypedef enum FuncCallType {\n    FUNC_CALL_NORMAL,\n    FUNC_CALL_NEW,\n    FUNC_CALL_SUPER_CTOR,\n    FUNC_CALL_TEMPLATE,\n} FuncCallType;\n\nstatic void optional_chain_test(JSParseState *s, int *poptional_chaining_label,\n                                int drop_count)\n{\n    int label_next, i;\n    if (*poptional_chaining_label < 0)\n        *poptional_chaining_label = new_label(s);\n   /* XXX: could be more efficient with a specific opcode */\n    emit_op(s, OP_dup);\n    emit_op(s, OP_is_undefined_or_null);\n    label_next = emit_goto(s, OP_if_false, -1);\n    for(i = 0; i < drop_count; i++)\n        emit_op(s, OP_drop);\n    emit_op(s, OP_undefined);\n    emit_goto(s, OP_goto, *poptional_chaining_label);\n    emit_label(s, label_next);\n}\n\n/* allowed parse_flags: PF_POSTFIX_CALL, PF_ARROW_FUNC */\nstatic __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)\n{\n    FuncCallType call_type;\n    int optional_chaining_label;\n    BOOL accept_lparen = (parse_flags & PF_POSTFIX_CALL) != 0;\n    \n    call_type = FUNC_CALL_NORMAL;\n    switch(s->token.val) {\n    case TOK_NUMBER:\n        {\n            JSValue val;\n            val = s->token.u.num.val;\n\n            if (JS_VALUE_GET_TAG(val) == JS_TAG_INT) {\n                emit_op(s, OP_push_i32);\n                emit_u32(s, JS_VALUE_GET_INT(val));\n            } else\n#ifdef CONFIG_BIGNUM\n            if (JS_VALUE_GET_TAG(val) == JS_TAG_BIG_FLOAT) {\n                slimb_t e;\n                int ret;\n\n                /* need a runtime conversion */\n                /* XXX: could add a cache and/or do it once at\n                   the start of the function */\n                if (emit_push_const(s, val, 0) < 0)\n                    return -1;\n                e = s->token.u.num.exponent;\n                if (e == (int32_t)e) {\n                    emit_op(s, OP_push_i32);\n                    emit_u32(s, e);\n                } else {\n                    val = JS_NewBigInt64_1(s->ctx, e);\n                    if (JS_IsException(val))\n                        return -1;\n                    ret = emit_push_const(s, val, 0);\n                    JS_FreeValue(s->ctx, val);\n                    if (ret < 0)\n                        return -1;\n                }\n                emit_op(s, OP_mul_pow10);\n            } else\n#endif\n            {\n                if (emit_push_const(s, val, 0) < 0)\n                    return -1;\n            }\n        }\n        if (next_token(s))\n            return -1;\n        break;\n    case TOK_TEMPLATE:\n        if (js_parse_template(s, 0, NULL))\n            return -1;\n        break;\n    case TOK_STRING:\n        if (emit_push_const(s, s->token.u.str.str, 1))\n            return -1;\n        if (next_token(s))\n            return -1;\n        break;\n        \n    case TOK_DIV_ASSIGN:\n        s->buf_ptr -= 2;\n        goto parse_regexp;\n    case '/':\n        s->buf_ptr--;\n    parse_regexp:\n        {\n            JSValue str;\n            int ret, backtrace_flags;\n            if (!s->ctx->compile_regexp)\n                return js_parse_error(s, \"RegExp are not supported\");\n            /* the previous token is '/' or '/=', so no need to free */\n            if (js_parse_regexp(s))\n                return -1;\n            ret = emit_push_const(s, s->token.u.regexp.body, 0);\n            str = s->ctx->compile_regexp(s->ctx, s->token.u.regexp.body,\n                                         s->token.u.regexp.flags);\n            if (JS_IsException(str)) {\n                /* add the line number info */\n                backtrace_flags = 0;\n                if (s->cur_func && s->cur_func->backtrace_barrier)\n                    backtrace_flags = JS_BACKTRACE_FLAG_SINGLE_LEVEL;\n                build_backtrace(s->ctx, s->ctx->rt->current_exception,\n                                s->filename, s->token.line_num,\n                                backtrace_flags);\n                return -1;\n            }\n            ret = emit_push_const(s, str, 0);\n            JS_FreeValue(s->ctx, str);\n            if (ret)\n                return -1;\n            /* we use a specific opcode to be sure the correct\n               function is called (otherwise the bytecode would have\n               to be verified by the RegExp constructor) */\n            emit_op(s, OP_regexp);\n            if (next_token(s))\n                return -1;\n        }\n        break;\n    case '(':\n        if ((parse_flags & PF_ARROW_FUNC) &&\n            js_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) {\n            if (js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,\n                                       JS_FUNC_NORMAL, JS_ATOM_NULL,\n                                       s->token.ptr, s->token.line_num))\n                return -1;\n        } else {\n            if (js_parse_expr_paren(s))\n                return -1;\n        }\n        break;\n    case TOK_FUNCTION:\n        if (js_parse_function_decl(s, JS_PARSE_FUNC_EXPR,\n                                   JS_FUNC_NORMAL, JS_ATOM_NULL,\n                                   s->token.ptr, s->token.line_num))\n            return -1;\n        break;\n    case TOK_CLASS:\n        if (js_parse_class(s, TRUE, JS_PARSE_EXPORT_NONE))\n            return -1;\n        break;\n    case TOK_NULL:\n        if (next_token(s))\n            return -1;\n        emit_op(s, OP_null);\n        break;\n    case TOK_THIS:\n        if (next_token(s))\n            return -1;\n        emit_op(s, OP_scope_get_var);\n        emit_atom(s, JS_ATOM_this);\n        emit_u16(s, 0);\n        break;\n    case TOK_FALSE:\n        if (next_token(s))\n            return -1;\n        emit_op(s, OP_push_false);\n        break;\n    case TOK_TRUE:\n        if (next_token(s))\n            return -1;\n        emit_op(s, OP_push_true);\n        break;\n    case TOK_IDENT:\n        {\n            JSAtom name;\n            if (s->token.u.ident.is_reserved) {\n                return js_parse_error_reserved_identifier(s);\n            }\n            if ((parse_flags & PF_ARROW_FUNC) &&\n                peek_token(s, TRUE) == TOK_ARROW) {\n                if (js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,\n                                           JS_FUNC_NORMAL, JS_ATOM_NULL,\n                                           s->token.ptr, s->token.line_num))\n                    return -1;\n            } else if (token_is_pseudo_keyword(s, JS_ATOM_async) &&\n                       peek_token(s, TRUE) != '\\n') {\n                const uint8_t *source_ptr;\n                int source_line_num;\n\n                source_ptr = s->token.ptr;\n                source_line_num = s->token.line_num;\n                if (next_token(s))\n                    return -1;\n                if (s->token.val == TOK_FUNCTION) {\n                    if (js_parse_function_decl(s, JS_PARSE_FUNC_EXPR,\n                                               JS_FUNC_ASYNC, JS_ATOM_NULL,\n                                               source_ptr, source_line_num))\n                        return -1;\n                } else if ((parse_flags & PF_ARROW_FUNC) &&\n                           ((s->token.val == '(' &&\n                             js_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) ||\n                            (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved &&\n                             peek_token(s, TRUE) == TOK_ARROW))) {\n                    if (js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,\n                                               JS_FUNC_ASYNC, JS_ATOM_NULL,\n                                               source_ptr, source_line_num))\n                        return -1;\n                } else {\n                    name = JS_DupAtom(s->ctx, JS_ATOM_async);\n                    goto do_get_var;\n                }\n            } else {\n                if (s->token.u.ident.atom == JS_ATOM_arguments &&\n                    !s->cur_func->arguments_allowed) {\n                    js_parse_error(s, \"'arguments' identifier is not allowed in class field initializer\");\n                    return -1;\n                }\n                name = JS_DupAtom(s->ctx, s->token.u.ident.atom);\n                if (next_token(s))  /* update line number before emitting code */\n                    return -1;\n            do_get_var:\n                emit_op(s, OP_scope_get_var);\n                emit_u32(s, name);\n                emit_u16(s, s->cur_func->scope_level);\n            }\n        }\n        break;\n    case '{':\n    case '[':\n        {\n            int skip_bits;\n            if (js_parse_skip_parens_token(s, &skip_bits, FALSE) == '=') {\n                if (js_parse_destructuring_element(s, 0, 0, FALSE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)\n                    return -1;\n            } else {\n                if (s->token.val == '{') {\n                    if (js_parse_object_literal(s))\n                        return -1;\n                } else {\n                    if (js_parse_array_literal(s))\n                        return -1;\n                }\n            }\n        }\n        break;\n    case TOK_NEW:\n        if (next_token(s))\n            return -1;\n        if (s->token.val == '.') {\n            if (next_token(s))\n                return -1;\n            if (!token_is_pseudo_keyword(s, JS_ATOM_target))\n                return js_parse_error(s, \"expecting target\");\n            if (!s->cur_func->new_target_allowed)\n                return js_parse_error(s, \"new.target only allowed within functions\");\n            if (next_token(s))\n                return -1;\n            emit_op(s, OP_scope_get_var);\n            emit_atom(s, JS_ATOM_new_target);\n            emit_u16(s, 0);\n        } else {\n            if (js_parse_postfix_expr(s, 0))\n                return -1;\n            accept_lparen = TRUE;\n            if (s->token.val != '(') {\n                /* new operator on an object */\n                emit_op(s, OP_dup);\n                emit_op(s, OP_call_constructor);\n                emit_u16(s, 0);\n            } else {\n                call_type = FUNC_CALL_NEW;\n            }\n        }\n        break;\n    case TOK_SUPER:\n        if (next_token(s))\n            return -1;\n        if (s->token.val == '(') {\n            if (!s->cur_func->super_call_allowed)\n                return js_parse_error(s, \"super() is only valid in a derived class constructor\");\n            call_type = FUNC_CALL_SUPER_CTOR;\n        } else if (s->token.val == '.' || s->token.val == '[') {\n            if (!s->cur_func->super_allowed)\n                return js_parse_error(s, \"'super' is only valid in a method\");\n            emit_op(s, OP_scope_get_var);\n            emit_atom(s, JS_ATOM_this);\n            emit_u16(s, 0);\n            emit_op(s, OP_scope_get_var);\n            emit_atom(s, JS_ATOM_home_object);\n            emit_u16(s, 0);\n            emit_op(s, OP_get_super);\n        } else {\n            return js_parse_error(s, \"invalid use of 'super'\");\n        }\n        break;\n    case TOK_IMPORT:\n        if (next_token(s))\n            return -1;\n        if (s->token.val == '.') {\n            if (next_token(s))\n                return -1;\n            if (!token_is_pseudo_keyword(s, JS_ATOM_meta))\n                return js_parse_error(s, \"meta expected\");\n            if (!s->is_module)\n                return js_parse_error(s, \"import.meta only valid in module code\");\n            if (next_token(s))\n                return -1;\n            emit_op(s, OP_special_object);\n            emit_u8(s, OP_SPECIAL_OBJECT_IMPORT_META);\n        } else {\n            if (js_parse_expect(s, '('))\n                return -1;\n            if (!accept_lparen)\n                return js_parse_error(s, \"invalid use of 'import()'\");\n            if (js_parse_assign_expr(s))\n                return -1;\n            if (js_parse_expect(s, ')'))\n                return -1;\n            emit_op(s, OP_import);\n        }\n        break;\n    default:\n        return js_parse_error(s, \"unexpected token in expression: '%.*s'\",\n                              (int)(s->buf_ptr - s->token.ptr), s->token.ptr);\n    }\n\n    optional_chaining_label = -1;\n    for(;;) {\n        JSFunctionDef *fd = s->cur_func;\n        BOOL has_optional_chain = FALSE;\n        \n        if (s->token.val == TOK_QUESTION_MARK_DOT) {\n            /* optional chaining */\n            if (next_token(s))\n                return -1;\n            has_optional_chain = TRUE;\n            if (s->token.val == '(' && accept_lparen) {\n                goto parse_func_call;\n            } else if (s->token.val == '[') {\n                goto parse_array_access;\n            } else {\n                goto parse_property;\n            }\n        } else if (s->token.val == TOK_TEMPLATE &&\n                   call_type == FUNC_CALL_NORMAL) {\n            if (optional_chaining_label >= 0) {\n                return js_parse_error(s, \"template literal cannot appear in an optional chain\");\n            }\n            call_type = FUNC_CALL_TEMPLATE;\n            goto parse_func_call2;\n        } else if (s->token.val == '(' && accept_lparen) {\n            int opcode, arg_count, drop_count;\n\n            /* function call */\n        parse_func_call:\n            if (next_token(s))\n                return -1;\n\n            if (call_type == FUNC_CALL_NORMAL) {\n            parse_func_call2:\n                switch(opcode = get_prev_opcode(fd)) {\n                case OP_get_field:\n                    /* keep the object on the stack */\n                    fd->byte_code.buf[fd->last_opcode_pos] = OP_get_field2;\n                    drop_count = 2;\n                    break;\n                case OP_scope_get_private_field:\n                    /* keep the object on the stack */\n                    fd->byte_code.buf[fd->last_opcode_pos] = OP_scope_get_private_field2;\n                    drop_count = 2;\n                    break;\n                case OP_get_array_el:\n                    /* keep the object on the stack */\n                    fd->byte_code.buf[fd->last_opcode_pos] = OP_get_array_el2;\n                    drop_count = 2;\n                    break;\n                case OP_scope_get_var:\n                    {\n                        JSAtom name;\n                        int scope;\n                        name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);\n                        scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);\n                        if (name == JS_ATOM_eval && call_type == FUNC_CALL_NORMAL && !has_optional_chain) {\n                            /* direct 'eval' */\n                            opcode = OP_eval;\n                        } else {\n                            /* verify if function name resolves to a simple\n                               get_loc/get_arg: a function call inside a `with`\n                               statement can resolve to a method call of the\n                               `with` context object\n                             */\n                            /* XXX: always generate the OP_scope_get_ref\n                               and remove it in variable resolution\n                               pass ? */\n                            if (has_with_scope(fd, scope)) {\n                                opcode = OP_scope_get_ref;\n                                fd->byte_code.buf[fd->last_opcode_pos] = opcode;\n                            }\n                        }\n                        drop_count = 1;\n                    }\n                    break;\n                case OP_get_super_value:\n                    fd->byte_code.buf[fd->last_opcode_pos] = OP_get_array_el;\n                    /* on stack: this func_obj */\n                    opcode = OP_get_array_el;\n                    drop_count = 2;\n                    break;\n                default:\n                    opcode = OP_invalid;\n                    drop_count = 1;\n                    break;\n                }\n                if (has_optional_chain) {\n                    optional_chain_test(s, &optional_chaining_label,\n                                        drop_count);\n                }\n            } else {\n                opcode = OP_invalid;\n            }\n\n            if (call_type == FUNC_CALL_TEMPLATE) {\n                if (js_parse_template(s, 1, &arg_count))\n                    return -1;\n                goto emit_func_call;\n            } else if (call_type == FUNC_CALL_SUPER_CTOR) {\n                emit_op(s, OP_scope_get_var);\n                emit_atom(s, JS_ATOM_this_active_func);\n                emit_u16(s, 0);\n\n                emit_op(s, OP_get_super);\n\n                emit_op(s, OP_scope_get_var);\n                emit_atom(s, JS_ATOM_new_target);\n                emit_u16(s, 0);\n            } else if (call_type == FUNC_CALL_NEW) {\n                emit_op(s, OP_dup); /* new.target = function */\n            }\n\n            /* parse arguments */\n            arg_count = 0;\n            while (s->token.val != ')') {\n                if (arg_count >= 65535) {\n                    return js_parse_error(s, \"Too many call arguments\");\n                }\n                if (s->token.val == TOK_ELLIPSIS)\n                    break;\n                if (js_parse_assign_expr(s))\n                    return -1;\n                arg_count++;\n                if (s->token.val == ')')\n                    break;\n                /* accept a trailing comma before the ')' */\n                if (js_parse_expect(s, ','))\n                    return -1;\n            }\n            if (s->token.val == TOK_ELLIPSIS) {\n                emit_op(s, OP_array_from);\n                emit_u16(s, arg_count);\n                emit_op(s, OP_push_i32);\n                emit_u32(s, arg_count);\n\n                /* on stack: array idx */\n                while (s->token.val != ')') {\n                    if (s->token.val == TOK_ELLIPSIS) {\n                        if (next_token(s))\n                            return -1;\n                        if (js_parse_assign_expr(s))\n                            return -1;\n#if 1\n                        /* XXX: could pass is_last indicator? */\n                        emit_op(s, OP_append);\n#else\n                        int label_next, label_done;\n                        label_next = new_label(s);\n                        label_done = new_label(s);\n                        /* push enumerate object below array/idx pair */\n                        emit_op(s, OP_for_of_start);\n                        emit_op(s, OP_rot5l);\n                        emit_op(s, OP_rot5l);\n                        emit_label(s, label_next);\n                        /* on stack: enum_rec array idx */\n                        emit_op(s, OP_for_of_next);\n                        emit_u8(s, 2);\n                        emit_goto(s, OP_if_true, label_done);\n                        /* append element */\n                        /* enum_rec array idx val -> enum_rec array new_idx */\n                        emit_op(s, OP_define_array_el);\n                        emit_op(s, OP_inc);\n                        emit_goto(s, OP_goto, label_next);\n                        emit_label(s, label_done);\n                        /* close enumeration, drop enum_rec and idx */\n                        emit_op(s, OP_drop); /* drop undef */\n                        emit_op(s, OP_nip1); /* drop enum_rec */\n                        emit_op(s, OP_nip1);\n                        emit_op(s, OP_nip1);\n#endif\n                    } else {\n                        if (js_parse_assign_expr(s))\n                            return -1;\n                        /* array idx val */\n                        emit_op(s, OP_define_array_el);\n                        emit_op(s, OP_inc);\n                    }\n                    if (s->token.val == ')')\n                        break;\n                    /* accept a trailing comma before the ')' */\n                    if (js_parse_expect(s, ','))\n                        return -1;\n                }\n                if (next_token(s))\n                    return -1;\n                /* drop the index */\n                emit_op(s, OP_drop);\n\n                /* apply function call */\n                switch(opcode) {\n                case OP_get_field:\n                case OP_scope_get_private_field:\n                case OP_get_array_el:\n                case OP_scope_get_ref:\n                    /* obj func array -> func obj array */\n                    emit_op(s, OP_perm3);\n                    emit_op(s, OP_apply);\n                    emit_u16(s, call_type == FUNC_CALL_NEW);\n                    break;\n                case OP_eval:\n                    emit_op(s, OP_apply_eval);\n                    emit_u16(s, fd->scope_level);\n                    fd->has_eval_call = TRUE;\n                    break;\n                default:\n                    if (call_type == FUNC_CALL_SUPER_CTOR) {\n                        emit_op(s, OP_apply);\n                        emit_u16(s, 1);\n                        /* set the 'this' value */\n                        emit_op(s, OP_dup);\n                        emit_op(s, OP_scope_put_var_init);\n                        emit_atom(s, JS_ATOM_this);\n                        emit_u16(s, 0);\n\n                        emit_class_field_init(s);\n                    } else if (call_type == FUNC_CALL_NEW) {\n                        /* obj func array -> func obj array */\n                        emit_op(s, OP_perm3);\n                        emit_op(s, OP_apply);\n                        emit_u16(s, 1);\n                    } else {\n                        /* func array -> func undef array */\n                        emit_op(s, OP_undefined);\n                        emit_op(s, OP_swap);\n                        emit_op(s, OP_apply);\n                        emit_u16(s, 0);\n                    }\n                    break;\n                }\n            } else {\n                if (next_token(s))\n                    return -1;\n            emit_func_call:\n                switch(opcode) {\n                case OP_get_field:\n                case OP_scope_get_private_field:\n                case OP_get_array_el:\n                case OP_scope_get_ref:\n                    emit_op(s, OP_call_method);\n                    emit_u16(s, arg_count);\n                    break;\n                case OP_eval:\n                    emit_op(s, OP_eval);\n                    emit_u16(s, arg_count);\n                    emit_u16(s, fd->scope_level);\n                    fd->has_eval_call = TRUE;\n                    break;\n                default:\n                    if (call_type == FUNC_CALL_SUPER_CTOR) {\n                        emit_op(s, OP_call_constructor);\n                        emit_u16(s, arg_count);\n\n                        /* set the 'this' value */\n                        emit_op(s, OP_dup);\n                        emit_op(s, OP_scope_put_var_init);\n                        emit_atom(s, JS_ATOM_this);\n                        emit_u16(s, 0);\n\n                        emit_class_field_init(s);\n                    } else if (call_type == FUNC_CALL_NEW) {\n                        emit_op(s, OP_call_constructor);\n                        emit_u16(s, arg_count);\n                    } else {\n                        emit_op(s, OP_call);\n                        emit_u16(s, arg_count);\n                    }\n                    break;\n                }\n            }\n            call_type = FUNC_CALL_NORMAL;\n        } else if (s->token.val == '.') {\n            if (next_token(s))\n                return -1;\n        parse_property:\n            if (s->token.val == TOK_PRIVATE_NAME) {\n                /* private class field */\n                if (get_prev_opcode(fd) == OP_get_super) {\n                    return js_parse_error(s, \"private class field forbidden after super\");\n                }\n                if (has_optional_chain) {\n                    optional_chain_test(s, &optional_chaining_label, 1);\n                }\n                emit_op(s, OP_scope_get_private_field);\n                emit_atom(s, s->token.u.ident.atom);\n                emit_u16(s, s->cur_func->scope_level);\n            } else {\n                if (!token_is_ident(s->token.val)) {\n                    return js_parse_error(s, \"expecting field name\");\n                }\n                if (get_prev_opcode(fd) == OP_get_super) {\n                    JSValue val;\n                    int ret;\n                    val = JS_AtomToValue(s->ctx, s->token.u.ident.atom);\n                    ret = emit_push_const(s, val, 1);\n                    JS_FreeValue(s->ctx, val);\n                    if (ret)\n                        return -1;\n                    emit_op(s, OP_get_super_value);\n                } else {\n                    if (has_optional_chain) {\n                        optional_chain_test(s, &optional_chaining_label, 1);\n                    }\n                    emit_op(s, OP_get_field);\n                    emit_atom(s, s->token.u.ident.atom);\n                }\n            }\n            if (next_token(s))\n                return -1;\n        } else if (s->token.val == '[') {\n            int prev_op;\n\n        parse_array_access:\n            prev_op = get_prev_opcode(fd);\n            if (has_optional_chain) {\n                optional_chain_test(s, &optional_chaining_label, 1);\n            }\n            if (next_token(s))\n                return -1;\n            if (js_parse_expr(s))\n                return -1;\n            if (js_parse_expect(s, ']'))\n                return -1;\n            if (prev_op == OP_get_super) {\n                emit_op(s, OP_get_super_value);\n            } else {\n                emit_op(s, OP_get_array_el);\n            }\n        } else {\n            break;\n        }\n    }\n    if (optional_chaining_label >= 0)\n        emit_label(s, optional_chaining_label);\n    return 0;\n}\n\nstatic __exception int js_parse_delete(JSParseState *s)\n{\n    JSFunctionDef *fd = s->cur_func;\n    JSAtom name;\n    int opcode;\n\n    if (next_token(s))\n        return -1;\n    if (js_parse_unary(s, PF_POW_FORBIDDEN))\n        return -1;\n    switch(opcode = get_prev_opcode(fd)) {\n    case OP_get_field:\n        {\n            JSValue val;\n            int ret;\n\n            name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);\n            fd->byte_code.size = fd->last_opcode_pos;\n            fd->last_opcode_pos = -1;\n            val = JS_AtomToValue(s->ctx, name);\n            ret = emit_push_const(s, val, 1);\n            JS_FreeValue(s->ctx, val);\n            JS_FreeAtom(s->ctx, name);\n            if (ret)\n                return ret;\n        }\n        goto do_delete;\n    case OP_get_array_el:\n        fd->byte_code.size = fd->last_opcode_pos;\n        fd->last_opcode_pos = -1;\n    do_delete:\n        emit_op(s, OP_delete);\n        break;\n    case OP_scope_get_var:\n        /* 'delete this': this is not a reference */\n        name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);\n        if (name == JS_ATOM_this || name == JS_ATOM_new_target)\n            goto ret_true;\n        if (fd->js_mode & JS_MODE_STRICT) {\n            return js_parse_error(s, \"cannot delete a direct reference in strict mode\");\n        } else {\n            fd->byte_code.buf[fd->last_opcode_pos] = OP_scope_delete_var;\n        }\n        break;\n    case OP_scope_get_private_field:\n        return js_parse_error(s, \"cannot delete a private class field\");\n    case OP_get_super_value:\n        emit_op(s, OP_throw_error);\n        emit_atom(s, JS_ATOM_NULL);\n        emit_u8(s, JS_THROW_ERROR_DELETE_SUPER);\n        break;\n    default:\n    ret_true:\n        emit_op(s, OP_drop);\n        emit_op(s, OP_push_true);\n        break;\n    }\n    return 0;\n}\n\n/* allowed parse_flags: PF_ARROW_FUNC, PF_POW_ALLOWED, PF_POW_FORBIDDEN */\nstatic __exception int js_parse_unary(JSParseState *s, int parse_flags)\n{\n    int op;\n\n    switch(s->token.val) {\n    case '+':\n    case '-':\n    case '!':\n    case '~':\n    case TOK_VOID:\n        op = s->token.val;\n        if (next_token(s))\n            return -1;\n        if (js_parse_unary(s, PF_POW_FORBIDDEN))\n            return -1;\n        switch(op) {\n        case '-':\n            emit_op(s, OP_neg);\n            break;\n        case '+':\n            emit_op(s, OP_plus);\n            break;\n        case '!':\n            emit_op(s, OP_lnot);\n            break;\n        case '~':\n            emit_op(s, OP_not);\n            break;\n        case TOK_VOID:\n            emit_op(s, OP_drop);\n            emit_op(s, OP_undefined);\n            break;\n        default:\n            abort();\n        }\n        parse_flags = 0;\n        break;\n    case TOK_DEC:\n    case TOK_INC:\n        {\n            int opcode, op, scope, label;\n            JSAtom name;\n            op = s->token.val;\n            if (next_token(s))\n                return -1;\n            if (js_parse_unary(s, 0))\n                return -1;\n            if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, TRUE, op))\n                return -1;\n            emit_op(s, OP_dec + op - TOK_DEC);\n            put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_TOP,\n                       FALSE);\n        }\n        break;\n    case TOK_TYPEOF:\n        {\n            JSFunctionDef *fd;\n            if (next_token(s))\n                return -1;\n            if (js_parse_unary(s, PF_POW_FORBIDDEN))\n                return -1;\n            /* reference access should not return an exception, so we\n               patch the get_var */\n            fd = s->cur_func;\n            if (get_prev_opcode(fd) == OP_scope_get_var) {\n                fd->byte_code.buf[fd->last_opcode_pos] = OP_scope_get_var_undef;\n            }\n            emit_op(s, OP_typeof);\n            parse_flags = 0;\n        }\n        break;\n    case TOK_DELETE:\n        if (js_parse_delete(s))\n            return -1;\n        parse_flags = 0;\n        break;\n    case TOK_AWAIT:\n        if (!(s->cur_func->func_kind & JS_FUNC_ASYNC))\n            return js_parse_error(s, \"unexpected 'await' keyword\");\n        if (!s->cur_func->in_function_body)\n            return js_parse_error(s, \"await in default expression\");\n        if (next_token(s))\n            return -1;\n        if (js_parse_unary(s, PF_POW_FORBIDDEN))\n            return -1;\n        emit_op(s, OP_await);\n        parse_flags = 0;\n        break;\n    default:\n        if (js_parse_postfix_expr(s, (parse_flags & PF_ARROW_FUNC) |\n                                  PF_POSTFIX_CALL))\n            return -1;\n        if (!s->got_lf &&\n            (s->token.val == TOK_DEC || s->token.val == TOK_INC)) {\n            int opcode, op, scope, label;\n            JSAtom name;\n            op = s->token.val;\n            if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, TRUE, op))\n                return -1;\n            emit_op(s, OP_post_dec + op - TOK_DEC);\n            put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_SECOND,\n                       FALSE);\n            if (next_token(s))\n                return -1;        \n        }\n        break;\n    }\n    if (parse_flags & (PF_POW_ALLOWED | PF_POW_FORBIDDEN)) {\n#ifdef CONFIG_BIGNUM\n        if (s->token.val == TOK_POW || s->token.val == TOK_MATH_POW) {\n            /* Extended exponentiation syntax rules: we extend the ES7\n               grammar in order to have more intuitive semantics:\n               -2**2 evaluates to -4. */\n            if (!(s->cur_func->js_mode & JS_MODE_MATH)) {\n                if (parse_flags & PF_POW_FORBIDDEN) {\n                    JS_ThrowSyntaxError(s->ctx, \"unparenthesized unary expression can't appear on the left-hand side of '**'\");\n                    return -1;\n                }\n            }\n            if (next_token(s))\n                return -1;\n            if (js_parse_unary(s, PF_POW_ALLOWED))\n                return -1;\n            emit_op(s, OP_pow);\n        }\n#else\n        if (s->token.val == TOK_POW) {\n            /* Strict ES7 exponentiation syntax rules: To solve\n               conficting semantics between different implementations\n               regarding the precedence of prefix operators and the\n               postifx exponential, ES7 specifies that -2**2 is a\n               syntax error. */\n            if (parse_flags & PF_POW_FORBIDDEN) {\n                JS_ThrowSyntaxError(s->ctx, \"unparenthesized unary expression can't appear on the left-hand side of '**'\");\n                return -1;\n            }\n            if (next_token(s))\n                return -1;\n            if (js_parse_unary(s, PF_POW_ALLOWED))\n                return -1;\n            emit_op(s, OP_pow);\n        }\n#endif\n    }\n    return 0;\n}\n\n/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */\nstatic __exception int js_parse_expr_binary(JSParseState *s, int level,\n                                            int parse_flags)\n{\n    int op, opcode;\n\n    if (level == 0) {\n        return js_parse_unary(s, (parse_flags & PF_ARROW_FUNC) |\n                              PF_POW_ALLOWED);\n    }\n    if (js_parse_expr_binary(s, level - 1, parse_flags))\n        return -1;\n    for(;;) {\n        op = s->token.val;\n        switch(level) {\n        case 1:\n            switch(op) {\n            case '*':\n                opcode = OP_mul;\n                break;\n            case '/':\n                opcode = OP_div;\n                break;\n            case '%':\n#ifdef CONFIG_BIGNUM\n                if (s->cur_func->js_mode & JS_MODE_MATH)\n                    opcode = OP_math_mod;\n                else\n#endif\n                    opcode = OP_mod;\n                break;\n            default:\n                return 0;\n            }\n            break;\n        case 2:\n            switch(op) {\n            case '+':\n                opcode = OP_add;\n                break;\n            case '-':\n                opcode = OP_sub;\n                break;\n            default:\n                return 0;\n            }\n            break;\n        case 3:\n            switch(op) {\n            case TOK_SHL:\n                opcode = OP_shl;\n                break;\n            case TOK_SAR:\n                opcode = OP_sar;\n                break;\n            case TOK_SHR:\n                opcode = OP_shr;\n                break;\n            default:\n                return 0;\n            }\n            break;\n        case 4:\n            switch(op) {\n            case '<':\n                opcode = OP_lt;\n                break;\n            case '>':\n                opcode = OP_gt;\n                break;\n            case TOK_LTE:\n                opcode = OP_lte;\n                break;\n            case TOK_GTE:\n                opcode = OP_gte;\n                break;\n            case TOK_INSTANCEOF:\n                opcode = OP_instanceof;\n                break;\n            case TOK_IN:\n                if (parse_flags & PF_IN_ACCEPTED) {\n                    opcode = OP_in;\n                } else {\n                    return 0;\n                }\n                break;\n            default:\n                return 0;\n            }\n            break;\n        case 5:\n            switch(op) {\n            case TOK_EQ:\n                opcode = OP_eq;\n                break;\n            case TOK_NEQ:\n                opcode = OP_neq;\n                break;\n            case TOK_STRICT_EQ:\n                opcode = OP_strict_eq;\n                break;\n            case TOK_STRICT_NEQ:\n                opcode = OP_strict_neq;\n                break;\n            default:\n                return 0;\n            }\n            break;\n        case 6:\n            switch(op) {\n            case '&':\n                opcode = OP_and;\n                break;\n            default:\n                return 0;\n            }\n            break;\n        case 7:\n            switch(op) {\n            case '^':\n                opcode = OP_xor;\n                break;\n            default:\n                return 0;\n            }\n            break;\n        case 8:\n            switch(op) {\n            case '|':\n                opcode = OP_or;\n                break;\n            default:\n                return 0;\n            }\n            break;\n        default:\n            abort();\n        }\n        if (next_token(s))\n            return -1;\n        if (js_parse_expr_binary(s, level - 1, parse_flags & ~PF_ARROW_FUNC))\n            return -1;\n        emit_op(s, opcode);\n    }\n    return 0;\n}\n\n/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */\nstatic __exception int js_parse_logical_and_or(JSParseState *s, int op,\n                                               int parse_flags)\n{\n    int label1;\n\n    if (op == TOK_LAND) {\n        if (js_parse_expr_binary(s, 8, parse_flags))\n            return -1;\n    } else {\n        if (js_parse_logical_and_or(s, TOK_LAND, parse_flags))\n            return -1;\n    }\n    if (s->token.val == op) {\n        label1 = new_label(s);\n\n        for(;;) {\n            if (next_token(s))\n                return -1;\n            emit_op(s, OP_dup);\n            emit_goto(s, op == TOK_LAND ? OP_if_false : OP_if_true, label1);\n            emit_op(s, OP_drop);\n\n            if (op == TOK_LAND) {\n                if (js_parse_expr_binary(s, 8, parse_flags & ~PF_ARROW_FUNC))\n                    return -1;\n            } else {\n                if (js_parse_logical_and_or(s, TOK_LAND,\n                                            parse_flags & ~PF_ARROW_FUNC))\n                    return -1;\n            }\n            if (s->token.val != op) {\n                if (s->token.val == TOK_DOUBLE_QUESTION_MARK)\n                    return js_parse_error(s, \"cannot mix ?? with && or ||\");\n                break;\n            }\n        }\n\n        emit_label(s, label1);\n    }\n    return 0;\n}\n\nstatic __exception int js_parse_coalesce_expr(JSParseState *s, int parse_flags)\n{\n    int label1;\n    \n    if (js_parse_logical_and_or(s, TOK_LOR, parse_flags))\n        return -1;\n    if (s->token.val == TOK_DOUBLE_QUESTION_MARK) {\n        label1 = new_label(s);\n        for(;;) {\n            if (next_token(s))\n                return -1;\n            \n            emit_op(s, OP_dup);\n            emit_op(s, OP_is_undefined_or_null);\n            emit_goto(s, OP_if_false, label1);\n            emit_op(s, OP_drop);\n            \n            if (js_parse_expr_binary(s, 8, parse_flags & ~PF_ARROW_FUNC))\n                return -1;\n            if (s->token.val != TOK_DOUBLE_QUESTION_MARK)\n                break;\n        }\n        emit_label(s, label1);\n    }\n    return 0;\n}\n\n/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */\nstatic __exception int js_parse_cond_expr(JSParseState *s, int parse_flags)\n{\n    int label1, label2;\n\n    if (js_parse_coalesce_expr(s, parse_flags))\n        return -1;\n    if (s->token.val == '?') {\n        if (next_token(s))\n            return -1;\n        label1 = emit_goto(s, OP_if_false, -1);\n\n        if (js_parse_assign_expr(s))\n            return -1;\n        if (js_parse_expect(s, ':'))\n            return -1;\n\n        label2 = emit_goto(s, OP_goto, -1);\n\n        emit_label(s, label1);\n\n        if (js_parse_assign_expr2(s, parse_flags & PF_IN_ACCEPTED))\n            return -1;\n\n        emit_label(s, label2);\n    }\n    return 0;\n}\n\nstatic void emit_return(JSParseState *s, BOOL hasval);\n\n/* allowed parse_flags: PF_IN_ACCEPTED */\nstatic __exception int js_parse_assign_expr2(JSParseState *s, int parse_flags)\n{\n    int opcode, op, scope;\n    JSAtom name0 = JS_ATOM_NULL;\n    JSAtom name;\n\n    if (s->token.val == TOK_YIELD) {\n        BOOL is_star = FALSE, is_async;\n        \n        if (!(s->cur_func->func_kind & JS_FUNC_GENERATOR))\n            return js_parse_error(s, \"unexpected 'yield' keyword\");\n        if (!s->cur_func->in_function_body)\n            return js_parse_error(s, \"yield in default expression\");\n        if (next_token(s))\n            return -1;\n        /* XXX: is there a better method to detect 'yield' without\n           parameters ? */\n        if (s->token.val != ';' && s->token.val != ')' &&\n            s->token.val != ']' && s->token.val != '}' &&\n            s->token.val != ',' && s->token.val != ':' && !s->got_lf) {\n            if (s->token.val == '*') {\n                is_star = TRUE;\n                if (next_token(s))\n                    return -1;\n            }\n            if (js_parse_assign_expr2(s, parse_flags))\n                return -1;\n        } else {\n            emit_op(s, OP_undefined);\n        }\n        is_async = (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR);\n\n        if (is_star) {\n            int label_loop, label_return, label_next;\n            int label_return1, label_yield, label_throw, label_throw1;\n            int label_throw2;\n\n            label_loop = new_label(s);\n            label_yield = new_label(s);\n\n            emit_op(s, is_async ? OP_for_await_of_start : OP_for_of_start);\n\n            /* remove the catch offset (XXX: could avoid pushing back\n               undefined) */\n            emit_op(s, OP_drop);\n            emit_op(s, OP_undefined);\n            \n            emit_op(s, OP_undefined); /* initial value */\n            \n            emit_label(s, label_loop);\n            emit_op(s, OP_iterator_next);\n            if (is_async)\n                emit_op(s, OP_await);\n            emit_op(s, OP_iterator_check_object);\n            emit_op(s, OP_get_field2);\n            emit_atom(s, JS_ATOM_done);\n            label_next = emit_goto(s, OP_if_true, -1); /* end of loop */\n            emit_label(s, label_yield);\n            if (is_async) {\n                /* OP_async_yield_star takes the value as parameter */\n                emit_op(s, OP_get_field);\n                emit_atom(s, JS_ATOM_value);\n                emit_op(s, OP_await);\n                emit_op(s, OP_async_yield_star);\n            } else {\n                /* OP_yield_star takes (value, done) as parameter */\n                emit_op(s, OP_yield_star);\n            }\n            emit_op(s, OP_dup);\n            label_return = emit_goto(s, OP_if_true, -1);\n            emit_op(s, OP_drop);\n            emit_goto(s, OP_goto, label_loop);\n            \n            emit_label(s, label_return);\n            emit_op(s, OP_push_i32);\n            emit_u32(s, 2);\n            emit_op(s, OP_strict_eq);\n            label_throw = emit_goto(s, OP_if_true, -1);\n            \n            /* return handling */\n            if (is_async)\n                emit_op(s, OP_await);\n            emit_op(s, OP_iterator_call);\n            emit_u8(s, 0);\n            label_return1 = emit_goto(s, OP_if_true, -1);\n            if (is_async)\n                emit_op(s, OP_await);\n            emit_op(s, OP_iterator_check_object);\n            emit_op(s, OP_get_field2);\n            emit_atom(s, JS_ATOM_done);\n            emit_goto(s, OP_if_false, label_yield);\n\n            emit_op(s, OP_get_field);\n            emit_atom(s, JS_ATOM_value);\n            \n            emit_label(s, label_return1);\n            emit_op(s, OP_nip);\n            emit_op(s, OP_nip);\n            emit_op(s, OP_nip);\n            emit_return(s, TRUE);\n            \n            /* throw handling */\n            emit_label(s, label_throw);\n            emit_op(s, OP_iterator_call);\n            emit_u8(s, 1);\n            label_throw1 = emit_goto(s, OP_if_true, -1);\n            if (is_async)\n                emit_op(s, OP_await);\n            emit_op(s, OP_iterator_check_object);\n            emit_op(s, OP_get_field2);\n            emit_atom(s, JS_ATOM_done);\n            emit_goto(s, OP_if_false, label_yield);\n            emit_goto(s, OP_goto, label_next);\n            /* close the iterator and throw a type error exception */\n            emit_label(s, label_throw1);\n            emit_op(s, OP_iterator_call);\n            emit_u8(s, 2);\n            label_throw2 = emit_goto(s, OP_if_true, -1);\n            if (is_async)\n                emit_op(s, OP_await);\n            emit_label(s, label_throw2);\n\n            emit_op(s, OP_throw_error);\n            emit_atom(s, JS_ATOM_NULL);\n            emit_u8(s, JS_THROW_ERROR_ITERATOR_THROW);\n            \n            emit_label(s, label_next);\n            emit_op(s, OP_get_field);\n            emit_atom(s, JS_ATOM_value);\n            emit_op(s, OP_nip); /* keep the value associated with\n                                   done = true */\n            emit_op(s, OP_nip);\n            emit_op(s, OP_nip);\n        } else {\n            int label_next;\n            \n            if (is_async)\n                emit_op(s, OP_await);\n            emit_op(s, OP_yield);\n            label_next = emit_goto(s, OP_if_false, -1);\n            emit_return(s, TRUE);\n            emit_label(s, label_next);\n        }\n        return 0;\n    }\n    if (s->token.val == TOK_IDENT) {\n        /* name0 is used to check for OP_set_name pattern, not duplicated */\n        name0 = s->token.u.ident.atom;\n    }\n    if (js_parse_cond_expr(s, parse_flags | PF_ARROW_FUNC))\n        return -1;\n\n    op = s->token.val;\n    if (op == '=' || (op >= TOK_MUL_ASSIGN && op <= TOK_POW_ASSIGN)) {\n        int label;\n        if (next_token(s))\n            return -1;\n        if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, (op != '='), op) < 0)\n            return -1;\n\n        if (js_parse_assign_expr2(s, parse_flags)) {\n            JS_FreeAtom(s->ctx, name);\n            return -1;\n        }\n\n        if (op == '=') {\n            if (opcode == OP_get_ref_value && name == name0) {\n                set_object_name(s, name);\n            }\n        } else {\n            static const uint8_t assign_opcodes[] = {\n                OP_mul, OP_div, OP_mod, OP_add, OP_sub,\n                OP_shl, OP_sar, OP_shr, OP_and, OP_xor, OP_or,\n#ifdef CONFIG_BIGNUM\n                OP_pow,\n#endif\n                OP_pow,\n            };\n            op = assign_opcodes[op - TOK_MUL_ASSIGN];\n#ifdef CONFIG_BIGNUM\n            if (s->cur_func->js_mode & JS_MODE_MATH) {\n                if (op == OP_mod)\n                    op = OP_math_mod;\n            }\n#endif\n            emit_op(s, op);\n        }\n        put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_TOP, FALSE);\n    } else if (op >= TOK_LAND_ASSIGN && op <= TOK_DOUBLE_QUESTION_MARK_ASSIGN) {\n        int label, label1, depth_lvalue, label2;\n        \n        if (next_token(s))\n            return -1;\n        if (get_lvalue(s, &opcode, &scope, &name, &label,\n                       &depth_lvalue, TRUE, op) < 0)\n            return -1;\n\n        emit_op(s, OP_dup);\n        if (op == TOK_DOUBLE_QUESTION_MARK_ASSIGN)\n            emit_op(s, OP_is_undefined_or_null);\n        label1 = emit_goto(s, op == TOK_LOR_ASSIGN ? OP_if_true : OP_if_false,\n                           -1);\n        emit_op(s, OP_drop);\n        \n        if (js_parse_assign_expr2(s, parse_flags)) {\n            JS_FreeAtom(s->ctx, name);\n            return -1;\n        }\n\n        if (opcode == OP_get_ref_value && name == name0) {\n            set_object_name(s, name);\n        }\n        \n        switch(depth_lvalue) {\n        case 1:\n            emit_op(s, OP_insert2);\n            break;\n        case 2:\n            emit_op(s, OP_insert3);\n            break;\n        case 3:\n            emit_op(s, OP_insert4);\n            break;\n        default:\n            abort();\n        }\n\n        /* XXX: we disable the OP_put_ref_value optimization by not\n           using put_lvalue() otherwise depth_lvalue is not correct */\n        put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_NOKEEP_DEPTH,\n                   FALSE);\n        label2 = emit_goto(s, OP_goto, -1);\n        \n        emit_label(s, label1);\n\n        /* remove the lvalue stack entries */\n        while (depth_lvalue != 0) {\n            emit_op(s, OP_nip);\n            depth_lvalue--;\n        }\n\n        emit_label(s, label2);\n    }\n    return 0;\n}\n\nstatic __exception int js_parse_assign_expr(JSParseState *s)\n{\n    return js_parse_assign_expr2(s, PF_IN_ACCEPTED);\n}\n\n/* allowed parse_flags: PF_IN_ACCEPTED */\nstatic __exception int js_parse_expr2(JSParseState *s, int parse_flags)\n{\n    BOOL comma = FALSE;\n    for(;;) {\n        if (js_parse_assign_expr2(s, parse_flags))\n            return -1;\n        if (comma) {\n            /* prevent get_lvalue from using the last expression\n               as an lvalue. This also prevents the conversion of\n               of get_var to get_ref for method lookup in function\n               call inside `with` statement.\n             */\n            s->cur_func->last_opcode_pos = -1;\n        }\n        if (s->token.val != ',')\n            break;\n        comma = TRUE;\n        if (next_token(s))\n            return -1;\n        emit_op(s, OP_drop);\n    }\n    return 0;\n}\n\nstatic __exception int js_parse_expr(JSParseState *s)\n{\n    return js_parse_expr2(s, PF_IN_ACCEPTED);\n}\n\nstatic void push_break_entry(JSFunctionDef *fd, BlockEnv *be,\n                             JSAtom label_name,\n                             int label_break, int label_cont,\n                             int drop_count)\n{\n    be->prev = fd->top_break;\n    fd->top_break = be;\n    be->label_name = label_name;\n    be->label_break = label_break;\n    be->label_cont = label_cont;\n    be->drop_count = drop_count;\n    be->label_finally = -1;\n    be->scope_level = fd->scope_level;\n    be->has_iterator = FALSE;\n}\n\nstatic void pop_break_entry(JSFunctionDef *fd)\n{\n    BlockEnv *be;\n    be = fd->top_break;\n    fd->top_break = be->prev;\n}\n\nstatic __exception int emit_break(JSParseState *s, JSAtom name, int is_cont)\n{\n    BlockEnv *top;\n    int i, scope_level;\n\n    scope_level = s->cur_func->scope_level;\n    top = s->cur_func->top_break;\n    while (top != NULL) {\n        close_scopes(s, scope_level, top->scope_level);\n        scope_level = top->scope_level;\n        if (is_cont &&\n            top->label_cont != -1 &&\n            (name == JS_ATOM_NULL || top->label_name == name)) {\n            /* continue stays inside the same block */\n            emit_goto(s, OP_goto, top->label_cont);\n            return 0;\n        }\n        if (!is_cont &&\n            top->label_break != -1 &&\n            (name == JS_ATOM_NULL || top->label_name == name)) {\n            emit_goto(s, OP_goto, top->label_break);\n            return 0;\n        }\n        i = 0;\n        if (top->has_iterator) {\n            emit_op(s, OP_iterator_close);\n            i += 3;\n        }\n        for(; i < top->drop_count; i++)\n            emit_op(s, OP_drop);\n        if (top->label_finally != -1) {\n            /* must push dummy value to keep same stack depth */\n            emit_op(s, OP_undefined);\n            emit_goto(s, OP_gosub, top->label_finally);\n            emit_op(s, OP_drop);\n        }\n        top = top->prev;\n    }\n    if (name == JS_ATOM_NULL) {\n        if (is_cont)\n            return js_parse_error(s, \"continue must be inside loop\");\n        else\n            return js_parse_error(s, \"break must be inside loop or switch\");\n    } else {\n        return js_parse_error(s, \"break/continue label not found\");\n    }\n}\n\n/* execute the finally blocks before return */\nstatic void emit_return(JSParseState *s, BOOL hasval)\n{\n    BlockEnv *top;\n    int drop_count;\n\n    drop_count = 0;\n    top = s->cur_func->top_break;\n    while (top != NULL) {\n        /* XXX: emit the appropriate OP_leave_scope opcodes? Probably not\n           required as all local variables will be closed upon returning\n           from JS_CallInternal, but not in the same order. */\n        if (top->has_iterator) {\n            /* with 'yield', the exact number of OP_drop to emit is\n               unknown, so we use a specific operation to look for\n               the catch offset */\n            if (!hasval) {\n                emit_op(s, OP_undefined);\n                hasval = TRUE;\n            }\n            emit_op(s, OP_iterator_close_return);\n            if (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR) {\n                int label_next, label_next2;\n\n                emit_op(s, OP_drop); /* catch offset */\n                emit_op(s, OP_drop); /* next */\n                emit_op(s, OP_get_field2);\n                emit_atom(s, JS_ATOM_return);\n                /* stack: iter_obj return_func */\n                emit_op(s, OP_dup);\n                emit_op(s, OP_is_undefined_or_null);\n                label_next = emit_goto(s, OP_if_true, -1);\n                emit_op(s, OP_call_method);\n                emit_u16(s, 0);\n                emit_op(s, OP_iterator_check_object);\n                emit_op(s, OP_await);\n                label_next2 = emit_goto(s, OP_goto, -1);\n                emit_label(s, label_next);\n                emit_op(s, OP_drop);\n                emit_label(s, label_next2);\n                emit_op(s, OP_drop);\n            } else {\n                emit_op(s, OP_iterator_close);\n            }\n            drop_count = -3;\n        }\n        drop_count += top->drop_count;\n        if (top->label_finally != -1) {\n            while(drop_count) {\n                /* must keep the stack top if hasval */\n                emit_op(s, hasval ? OP_nip : OP_drop);\n                drop_count--;\n            }\n            if (!hasval) {\n                /* must push return value to keep same stack size */\n                emit_op(s, OP_undefined);\n                hasval = TRUE;\n            }\n            emit_goto(s, OP_gosub, top->label_finally);\n        }\n        top = top->prev;\n    }\n    if (s->cur_func->is_derived_class_constructor) {\n        int label_return;\n\n        /* 'this' can be uninitialized, so it may be accessed only if\n           the derived class constructor does not return an object */\n        if (hasval) {\n            emit_op(s, OP_check_ctor_return);\n            label_return = emit_goto(s, OP_if_false, -1);\n            emit_op(s, OP_drop);\n        } else {\n            label_return = -1;\n        }\n\n        /* XXX: if this is not initialized, should throw the\n           ReferenceError in the caller realm */\n        emit_op(s, OP_scope_get_var);\n        emit_atom(s, JS_ATOM_this);\n        emit_u16(s, 0);\n\n        emit_label(s, label_return);\n        emit_op(s, OP_return);\n    } else if (s->cur_func->func_kind != JS_FUNC_NORMAL) {\n        if (!hasval) {\n            emit_op(s, OP_undefined);\n        } else if (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR) {\n            emit_op(s, OP_await);\n        }\n        emit_op(s, OP_return_async);\n    } else {\n        emit_op(s, hasval ? OP_return : OP_return_undef);\n    }\n}\n\n#define DECL_MASK_FUNC  (1 << 0) /* allow normal function declaration */\n/* ored with DECL_MASK_FUNC if function declarations are allowed with a label */\n#define DECL_MASK_FUNC_WITH_LABEL (1 << 1)\n#define DECL_MASK_OTHER (1 << 2) /* all other declarations */\n#define DECL_MASK_ALL   (DECL_MASK_FUNC | DECL_MASK_FUNC_WITH_LABEL | DECL_MASK_OTHER)\n\nstatic __exception int js_parse_statement_or_decl(JSParseState *s,\n                                                  int decl_mask);\n\nstatic __exception int js_parse_statement(JSParseState *s)\n{\n    return js_parse_statement_or_decl(s, 0);\n}\n\nstatic __exception int js_parse_block(JSParseState *s)\n{\n    if (js_parse_expect(s, '{'))\n        return -1;\n    if (s->token.val != '}') {\n        push_scope(s);\n        for(;;) {\n            if (js_parse_statement_or_decl(s, DECL_MASK_ALL))\n                return -1;\n            if (s->token.val == '}')\n                break;\n        }\n        pop_scope(s);\n    }\n    if (next_token(s))\n        return -1;\n    return 0;\n}\n\n/* allowed parse_flags: PF_IN_ACCEPTED */\nstatic __exception int js_parse_var(JSParseState *s, int parse_flags, int tok,\n                                    BOOL export_flag)\n{\n    JSContext *ctx = s->ctx;\n    JSFunctionDef *fd = s->cur_func;\n    JSAtom name = JS_ATOM_NULL;\n\n    for (;;) {\n        if (s->token.val == TOK_IDENT) {\n            if (s->token.u.ident.is_reserved) {\n                return js_parse_error_reserved_identifier(s);\n            }\n            name = JS_DupAtom(ctx, s->token.u.ident.atom);\n            if (name == JS_ATOM_let && (tok == TOK_LET || tok == TOK_CONST)) {\n                js_parse_error(s, \"'let' is not a valid lexical identifier\");\n                goto var_error;\n            }\n            if (next_token(s))\n                goto var_error;\n            if (js_define_var(s, name, tok))\n                goto var_error;\n            if (export_flag) {\n                if (!add_export_entry(s, s->cur_func->module, name, name,\n                                      JS_EXPORT_TYPE_LOCAL))\n                    goto var_error;\n            }\n\n            if (s->token.val == '=') {\n                if (next_token(s))\n                    goto var_error;\n                if (tok == TOK_VAR) {\n                    /* Must make a reference for proper `with` semantics */\n                    int opcode, scope, label;\n                    JSAtom name1;\n\n                    emit_op(s, OP_scope_get_var);\n                    emit_atom(s, name);\n                    emit_u16(s, fd->scope_level);\n                    if (get_lvalue(s, &opcode, &scope, &name1, &label, NULL, FALSE, '=') < 0)\n                        goto var_error;\n                    if (js_parse_assign_expr2(s, parse_flags)) {\n                        JS_FreeAtom(ctx, name1);\n                        goto var_error;\n                    }\n                    set_object_name(s, name);\n                    put_lvalue(s, opcode, scope, name1, label,\n                               PUT_LVALUE_NOKEEP, FALSE);\n                } else {\n                    if (js_parse_assign_expr2(s, parse_flags))\n                        goto var_error;\n                    set_object_name(s, name);\n                    emit_op(s, (tok == TOK_CONST || tok == TOK_LET) ?\n                        OP_scope_put_var_init : OP_scope_put_var);\n                    emit_atom(s, name);\n                    emit_u16(s, fd->scope_level);\n                }\n            } else {\n                if (tok == TOK_CONST) {\n                    js_parse_error(s, \"missing initializer for const variable\");\n                    goto var_error;\n                }\n                if (tok == TOK_LET) {\n                    /* initialize lexical variable upon entering its scope */\n                    emit_op(s, OP_undefined);\n                    emit_op(s, OP_scope_put_var_init);\n                    emit_atom(s, name);\n                    emit_u16(s, fd->scope_level);\n                }\n            }\n            JS_FreeAtom(ctx, name);\n        } else {\n            int skip_bits;\n            if ((s->token.val == '[' || s->token.val == '{')\n            &&  js_parse_skip_parens_token(s, &skip_bits, FALSE) == '=') {\n                emit_op(s, OP_undefined);\n                if (js_parse_destructuring_element(s, tok, 0, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)\n                    return -1;\n            } else {\n                return js_parse_error(s, \"variable name expected\");\n            }\n        }\n        if (s->token.val != ',')\n            break;\n        if (next_token(s))\n            return -1;\n    }\n    return 0;\n\n var_error:\n    JS_FreeAtom(ctx, name);\n    return -1;\n}\n\n/* test if the current token is a label. Use simplistic look-ahead scanner */\nstatic BOOL is_label(JSParseState *s)\n{\n    return (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved &&\n            peek_token(s, FALSE) == ':');\n}\n\n/* test if the current token is a let keyword. Use simplistic look-ahead scanner */\nstatic int is_let(JSParseState *s, int decl_mask)\n{\n    int res = FALSE;\n\n    if (token_is_pseudo_keyword(s, JS_ATOM_let)) {\n#if 1\n        JSParsePos pos;\n        js_parse_get_pos(s, &pos);\n        for (;;) {\n            if (next_token(s)) {\n                res = -1;\n                break;\n            }\n            if (s->token.val == '[') {\n                /* let [ is a syntax restriction:\n                   it never introduces an ExpressionStatement */\n                res = TRUE;\n                break;\n            }\n            if (s->token.val == '{' ||\n                (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved) ||\n                s->token.val == TOK_LET ||\n                s->token.val == TOK_YIELD ||\n                s->token.val == TOK_AWAIT) {\n                /* Check for possible ASI if not scanning for Declaration */\n                /* XXX: should also check that `{` introduces a BindingPattern,\n                   but Firefox does not and rejects eval(\"let=1;let\\n{if(1)2;}\") */\n                if (s->last_line_num == s->token.line_num || (decl_mask & DECL_MASK_OTHER)) {\n                    res = TRUE;\n                    break;\n                }\n                break;\n            }\n            break;\n        }\n        if (js_parse_seek_token(s, &pos)) {\n            res = -1;\n        }\n#else\n        int tok = peek_token(s, TRUE);\n        if (tok == '{' || tok == TOK_IDENT || peek_token(s, FALSE) == '[') {\n            res = TRUE;\n        }\n#endif\n    }\n    return res;\n}\n\n/* XXX: handle IteratorClose when exiting the loop before the\n   enumeration is done */\nstatic __exception int js_parse_for_in_of(JSParseState *s, int label_name,\n                                          BOOL is_async)\n{\n    JSContext *ctx = s->ctx;\n    JSFunctionDef *fd = s->cur_func;\n    JSAtom var_name;\n    BOOL has_initializer, is_for_of, has_destructuring;\n    int tok, tok1, opcode, scope, block_scope_level;\n    int label_next, label_expr, label_cont, label_body, label_break;\n    int pos_next, pos_expr;\n    BlockEnv break_entry;\n\n    has_initializer = FALSE;\n    has_destructuring = FALSE;\n    is_for_of = FALSE;\n    block_scope_level = fd->scope_level;\n    label_cont = new_label(s);\n    label_body = new_label(s);\n    label_break = new_label(s);\n    label_next = new_label(s);\n\n    /* create scope for the lexical variables declared in the enumeration\n       expressions. XXX: Not completely correct because of weird capturing\n       semantics in `for (i of o) a.push(function(){return i})` */\n    push_scope(s);\n\n    /* local for_in scope starts here so individual elements\n       can be closed in statement. */\n    push_break_entry(s->cur_func, &break_entry,\n                     label_name, label_break, label_cont, 1);\n    break_entry.scope_level = block_scope_level;\n\n    label_expr = emit_goto(s, OP_goto, -1);\n\n    pos_next = s->cur_func->byte_code.size;\n    emit_label(s, label_next);\n\n    tok = s->token.val;\n    switch (is_let(s, DECL_MASK_OTHER)) {\n    case TRUE:\n        tok = TOK_LET;\n        break;\n    case FALSE:\n        break;\n    default:\n        return -1;\n    }\n    if (tok == TOK_VAR || tok == TOK_LET || tok == TOK_CONST) {\n        if (next_token(s))\n            return -1;\n\n        if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)) {\n            if (s->token.val == '[' || s->token.val == '{') {\n                if (js_parse_destructuring_element(s, tok, 0, TRUE, -1, FALSE) < 0)\n                    return -1;\n                has_destructuring = TRUE;\n            } else {\n                return js_parse_error(s, \"variable name expected\");\n            }\n            var_name = JS_ATOM_NULL;\n        } else {\n            var_name = JS_DupAtom(ctx, s->token.u.ident.atom);\n            if (next_token(s)) {\n                JS_FreeAtom(s->ctx, var_name);\n                return -1;\n            }\n            if (js_define_var(s, var_name, tok)) {\n                JS_FreeAtom(s->ctx, var_name);\n                return -1;\n            }\n            emit_op(s, (tok == TOK_CONST || tok == TOK_LET) ?\n                    OP_scope_put_var_init : OP_scope_put_var);\n            emit_atom(s, var_name);\n            emit_u16(s, fd->scope_level);\n        }\n    } else {\n        int skip_bits;\n        if ((s->token.val == '[' || s->token.val == '{')\n        &&  ((tok1 = js_parse_skip_parens_token(s, &skip_bits, FALSE)) == TOK_IN || tok1 == TOK_OF)) {\n            if (js_parse_destructuring_element(s, 0, 0, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)\n                return -1;\n        } else {\n            int lvalue_label;\n            if (js_parse_left_hand_side_expr(s))\n                return -1;\n            if (get_lvalue(s, &opcode, &scope, &var_name, &lvalue_label,\n                           NULL, FALSE, TOK_FOR))\n                return -1;\n            put_lvalue(s, opcode, scope, var_name, lvalue_label,\n                       PUT_LVALUE_NOKEEP_BOTTOM, FALSE);\n        }\n        var_name = JS_ATOM_NULL;\n    }\n    emit_goto(s, OP_goto, label_body);\n\n    pos_expr = s->cur_func->byte_code.size;\n    emit_label(s, label_expr);\n    if (s->token.val == '=') {\n        /* XXX: potential scoping issue if inside `with` statement */\n        has_initializer = TRUE;\n        /* parse and evaluate initializer prior to evaluating the\n           object (only used with \"for in\" with a non lexical variable\n           in non strict mode */\n        if (next_token(s) || js_parse_assign_expr2(s, 0)) {\n            JS_FreeAtom(ctx, var_name);\n            return -1;\n        }\n        if (var_name != JS_ATOM_NULL) {\n            emit_op(s, OP_scope_put_var);\n            emit_atom(s, var_name);\n            emit_u16(s, fd->scope_level);\n        }\n    }\n    JS_FreeAtom(ctx, var_name);\n\n    if (token_is_pseudo_keyword(s, JS_ATOM_of)) {\n        break_entry.has_iterator = is_for_of = TRUE;\n        break_entry.drop_count += 2;\n        if (has_initializer)\n            goto initializer_error;\n    } else if (s->token.val == TOK_IN) {\n        if (is_async)\n            return js_parse_error(s, \"'for await' loop should be used with 'of'\");\n        if (has_initializer &&\n            (tok != TOK_VAR || (fd->js_mode & JS_MODE_STRICT) ||\n             has_destructuring)) {\n        initializer_error:\n            return js_parse_error(s, \"a declaration in the head of a for-%s loop can't have an initializer\",\n                                  is_for_of ? \"of\" : \"in\");\n        }\n    } else {\n        return js_parse_error(s, \"expected 'of' or 'in' in for control expression\");\n    }\n    if (next_token(s))\n        return -1;\n    if (is_for_of) {\n        if (js_parse_assign_expr(s))\n            return -1;\n    } else {\n        if (js_parse_expr(s))\n            return -1;\n    }\n    /* close the scope after having evaluated the expression so that\n       the TDZ values are in the closures */\n    close_scopes(s, s->cur_func->scope_level, block_scope_level);\n    if (is_for_of) {\n        if (is_async)\n            emit_op(s, OP_for_await_of_start);\n        else\n            emit_op(s, OP_for_of_start);\n        /* on stack: enum_rec */\n    } else {\n        emit_op(s, OP_for_in_start);\n        /* on stack: enum_obj */\n    }\n    emit_goto(s, OP_goto, label_cont);\n\n    if (js_parse_expect(s, ')'))\n        return -1;\n\n    if (OPTIMIZE) {\n        /* move the `next` code here */\n        DynBuf *bc = &s->cur_func->byte_code;\n        int chunk_size = pos_expr - pos_next;\n        int offset = bc->size - pos_next;\n        int i;\n        dbuf_realloc(bc, bc->size + chunk_size);\n        dbuf_put(bc, bc->buf + pos_next, chunk_size);\n        memset(bc->buf + pos_next, OP_nop, chunk_size);\n        /* `next` part ends with a goto */\n        s->cur_func->last_opcode_pos = bc->size - 5;\n        /* relocate labels */\n        for (i = label_cont; i < s->cur_func->label_count; i++) {\n            LabelSlot *ls = &s->cur_func->label_slots[i];\n            if (ls->pos >= pos_next && ls->pos < pos_expr)\n                ls->pos += offset;\n        }\n    }\n\n    emit_label(s, label_body);\n    if (js_parse_statement(s))\n        return -1;\n\n    close_scopes(s, s->cur_func->scope_level, block_scope_level);\n\n    emit_label(s, label_cont);\n    if (is_for_of) {\n        if (is_async) {\n            /* call the next method */\n            /* stack: iter_obj next catch_offset */\n            emit_op(s, OP_dup3);\n            emit_op(s, OP_drop);\n            emit_op(s, OP_call_method);\n            emit_u16(s, 0);\n            /* get the result of the promise */\n            emit_op(s, OP_await);\n            /* unwrap the value and done values */\n            emit_op(s, OP_iterator_get_value_done);\n        } else {\n            emit_op(s, OP_for_of_next);\n            emit_u8(s, 0);\n        }\n    } else {\n        emit_op(s, OP_for_in_next);\n    }\n    /* on stack: enum_rec / enum_obj value bool */\n    emit_goto(s, OP_if_false, label_next);\n    /* drop the undefined value from for_xx_next */\n    emit_op(s, OP_drop);\n\n    emit_label(s, label_break);\n    if (is_for_of) {\n        /* close and drop enum_rec */\n        emit_op(s, OP_iterator_close);\n    } else {\n        emit_op(s, OP_drop);\n    }\n    pop_break_entry(s->cur_func);\n    pop_scope(s);\n    return 0;\n}\n\nstatic void set_eval_ret_undefined(JSParseState *s)\n{\n    if (s->cur_func->eval_ret_idx >= 0) {\n        emit_op(s, OP_undefined);\n        emit_op(s, OP_put_loc);\n        emit_u16(s, s->cur_func->eval_ret_idx);\n    }\n}\n\nstatic __exception int js_parse_statement_or_decl(JSParseState *s,\n                                                  int decl_mask)\n{\n    JSContext *ctx = s->ctx;\n    JSAtom label_name;\n    int tok;\n\n    /* specific label handling */\n    /* XXX: support multiple labels on loop statements */\n    label_name = JS_ATOM_NULL;\n    if (is_label(s)) {\n        BlockEnv *be;\n\n        label_name = JS_DupAtom(ctx, s->token.u.ident.atom);\n\n        for (be = s->cur_func->top_break; be; be = be->prev) {\n            if (be->label_name == label_name) {\n                js_parse_error(s, \"duplicate label name\");\n                goto fail;\n            }\n        }\n\n        if (next_token(s))\n            goto fail;\n        if (js_parse_expect(s, ':'))\n            goto fail;\n        if (s->token.val != TOK_FOR\n        &&  s->token.val != TOK_DO\n        &&  s->token.val != TOK_WHILE) {\n            /* labelled regular statement */\n            int label_break, mask;\n            BlockEnv break_entry;\n\n            label_break = new_label(s);\n            push_break_entry(s->cur_func, &break_entry,\n                             label_name, label_break, -1, 0);\n            if (!(s->cur_func->js_mode & JS_MODE_STRICT) &&\n                (decl_mask & DECL_MASK_FUNC_WITH_LABEL)) {\n                mask = DECL_MASK_FUNC | DECL_MASK_FUNC_WITH_LABEL;\n            } else {\n                mask = 0;\n            }\n            if (js_parse_statement_or_decl(s, mask))\n                goto fail;\n            emit_label(s, label_break);\n            pop_break_entry(s->cur_func);\n            goto done;\n        }\n    }\n\n    switch(tok = s->token.val) {\n    case '{':\n        if (js_parse_block(s))\n            goto fail;\n        break;\n    case TOK_RETURN:\n        if (s->cur_func->is_eval) {\n            js_parse_error(s, \"return not in a function\");\n            goto fail;\n        }\n        if (next_token(s))\n            goto fail;\n        if (s->token.val != ';' && s->token.val != '}' && !s->got_lf) {\n            if (js_parse_expr(s))\n                goto fail;\n            emit_return(s, TRUE);\n        } else {\n            emit_return(s, FALSE);\n        }\n        if (js_parse_expect_semi(s))\n            goto fail;\n        break;\n    case TOK_THROW:\n        if (next_token(s))\n            goto fail;\n        if (s->got_lf) {\n            js_parse_error(s, \"line terminator not allowed after throw\");\n            goto fail;\n        }\n        if (js_parse_expr(s))\n            goto fail;\n        emit_op(s, OP_throw);\n        if (js_parse_expect_semi(s))\n            goto fail;\n        break;\n    case TOK_LET:\n    case TOK_CONST:\n    haslet:\n        if (!(decl_mask & DECL_MASK_OTHER)) {\n            js_parse_error(s, \"lexical declarations can't appear in single-statement context\");\n            goto fail;\n        }\n        /* fall thru */\n    case TOK_VAR:\n        if (next_token(s))\n            goto fail;\n        if (js_parse_var(s, TRUE, tok, FALSE))\n            goto fail;\n        if (js_parse_expect_semi(s))\n            goto fail;\n        break;\n    case TOK_IF:\n        {\n            int label1, label2, mask;\n            if (next_token(s))\n                goto fail;\n            /* create a new scope for `let f;if(1) function f(){}` */\n            push_scope(s);\n            set_eval_ret_undefined(s);\n            if (js_parse_expr_paren(s))\n                goto fail;\n            label1 = emit_goto(s, OP_if_false, -1);\n            if (s->cur_func->js_mode & JS_MODE_STRICT)\n                mask = 0;\n            else\n                mask = DECL_MASK_FUNC; /* Annex B.3.4 */\n\n            if (js_parse_statement_or_decl(s, mask))\n                goto fail;\n\n            if (s->token.val == TOK_ELSE) {\n                label2 = emit_goto(s, OP_goto, -1);\n                if (next_token(s))\n                    goto fail;\n\n                emit_label(s, label1);\n                if (js_parse_statement_or_decl(s, mask))\n                    goto fail;\n\n                label1 = label2;\n            }\n            emit_label(s, label1);\n            pop_scope(s);\n        }\n        break;\n    case TOK_WHILE:\n        {\n            int label_cont, label_break;\n            BlockEnv break_entry;\n\n            label_cont = new_label(s);\n            label_break = new_label(s);\n\n            push_break_entry(s->cur_func, &break_entry,\n                             label_name, label_break, label_cont, 0);\n\n            if (next_token(s))\n                goto fail;\n\n            set_eval_ret_undefined(s);\n\n            emit_label(s, label_cont);\n            if (js_parse_expr_paren(s))\n                goto fail;\n            emit_goto(s, OP_if_false, label_break);\n\n            if (js_parse_statement(s))\n                goto fail;\n            emit_goto(s, OP_goto, label_cont);\n\n            emit_label(s, label_break);\n\n            pop_break_entry(s->cur_func);\n        }\n        break;\n    case TOK_DO:\n        {\n            int label_cont, label_break, label1;\n            BlockEnv break_entry;\n\n            label_cont = new_label(s);\n            label_break = new_label(s);\n            label1 = new_label(s);\n\n            push_break_entry(s->cur_func, &break_entry,\n                             label_name, label_break, label_cont, 0);\n\n            if (next_token(s))\n                goto fail;\n\n            emit_label(s, label1);\n\n            set_eval_ret_undefined(s);\n\n            if (js_parse_statement(s))\n                goto fail;\n\n            emit_label(s, label_cont);\n            if (js_parse_expect(s, TOK_WHILE))\n                goto fail;\n            if (js_parse_expr_paren(s))\n                goto fail;\n            /* Insert semicolon if missing */\n            if (s->token.val == ';') {\n                if (next_token(s))\n                    goto fail;\n            }\n            emit_goto(s, OP_if_true, label1);\n\n            emit_label(s, label_break);\n\n            pop_break_entry(s->cur_func);\n        }\n        break;\n    case TOK_FOR:\n        {\n            int label_cont, label_break, label_body, label_test;\n            int pos_cont, pos_body, block_scope_level;\n            BlockEnv break_entry;\n            int tok, bits;\n            BOOL is_async;\n\n            if (next_token(s))\n                goto fail;\n\n            set_eval_ret_undefined(s);\n            bits = 0;\n            is_async = FALSE;\n            if (s->token.val == '(') {\n                js_parse_skip_parens_token(s, &bits, FALSE);\n            } else if (s->token.val == TOK_AWAIT) {\n                if (!(s->cur_func->func_kind & JS_FUNC_ASYNC)) {\n                    js_parse_error(s, \"for await is only valid in asynchronous functions\");\n                    goto fail;\n                }\n                is_async = TRUE;\n                if (next_token(s))\n                    goto fail;\n            }\n            if (js_parse_expect(s, '('))\n                goto fail;\n\n            if (!(bits & SKIP_HAS_SEMI)) {\n                /* parse for/in or for/of */\n                if (js_parse_for_in_of(s, label_name, is_async))\n                    goto fail;\n                break;\n            }\n            block_scope_level = s->cur_func->scope_level;\n\n            /* create scope for the lexical variables declared in the initial,\n               test and increment expressions */\n            push_scope(s);\n            /* initial expression */\n            tok = s->token.val;\n            if (tok != ';') {\n                switch (is_let(s, DECL_MASK_OTHER)) {\n                case TRUE:\n                    tok = TOK_LET;\n                    break;\n                case FALSE:\n                    break;\n                default:\n                    goto fail;\n                }\n                if (tok == TOK_VAR || tok == TOK_LET || tok == TOK_CONST) {\n                    if (next_token(s))\n                        goto fail;\n                    if (js_parse_var(s, FALSE, tok, FALSE))\n                        goto fail;\n                } else {\n                    if (js_parse_expr2(s, FALSE))\n                        goto fail;\n                    emit_op(s, OP_drop);\n                }\n\n                /* close the closures before the first iteration */\n                close_scopes(s, s->cur_func->scope_level, block_scope_level);\n            }\n            if (js_parse_expect(s, ';'))\n                goto fail;\n\n            label_test = new_label(s);\n            label_cont = new_label(s);\n            label_body = new_label(s);\n            label_break = new_label(s);\n\n            push_break_entry(s->cur_func, &break_entry,\n                             label_name, label_break, label_cont, 0);\n\n            /* test expression */\n            if (s->token.val == ';') {\n                /* no test expression */\n                label_test = label_body;\n            } else {\n                emit_label(s, label_test);\n                if (js_parse_expr(s))\n                    goto fail;\n                emit_goto(s, OP_if_false, label_break);\n            }\n            if (js_parse_expect(s, ';'))\n                goto fail;\n\n            if (s->token.val == ')') {\n                /* no end expression */\n                break_entry.label_cont = label_cont = label_test;\n                pos_cont = 0; /* avoid warning */\n            } else {\n                /* skip the end expression */\n                emit_goto(s, OP_goto, label_body);\n\n                pos_cont = s->cur_func->byte_code.size;\n                emit_label(s, label_cont);\n                if (js_parse_expr(s))\n                    goto fail;\n                emit_op(s, OP_drop);\n                if (label_test != label_body)\n                    emit_goto(s, OP_goto, label_test);\n            }\n            if (js_parse_expect(s, ')'))\n                goto fail;\n\n            pos_body = s->cur_func->byte_code.size;\n            emit_label(s, label_body);\n            if (js_parse_statement(s))\n                goto fail;\n\n            /* close the closures before the next iteration */\n            /* XXX: check continue case */\n            close_scopes(s, s->cur_func->scope_level, block_scope_level);\n\n            if (OPTIMIZE && label_test != label_body && label_cont != label_test) {\n                /* move the increment code here */\n                DynBuf *bc = &s->cur_func->byte_code;\n                int chunk_size = pos_body - pos_cont;\n                int offset = bc->size - pos_cont;\n                int i;\n                dbuf_realloc(bc, bc->size + chunk_size);\n                dbuf_put(bc, bc->buf + pos_cont, chunk_size);\n                memset(bc->buf + pos_cont, OP_nop, chunk_size);\n                /* increment part ends with a goto */\n                s->cur_func->last_opcode_pos = bc->size - 5;\n                /* relocate labels */\n                for (i = label_cont; i < s->cur_func->label_count; i++) {\n                    LabelSlot *ls = &s->cur_func->label_slots[i];\n                    if (ls->pos >= pos_cont && ls->pos < pos_body)\n                        ls->pos += offset;\n                }\n            } else {\n                emit_goto(s, OP_goto, label_cont);\n            }\n\n            emit_label(s, label_break);\n\n            pop_break_entry(s->cur_func);\n            pop_scope(s);\n        }\n        break;\n    case TOK_BREAK:\n    case TOK_CONTINUE:\n        {\n            int is_cont = s->token.val - TOK_BREAK;\n            int label;\n\n            if (next_token(s))\n                goto fail;\n            if (!s->got_lf && s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)\n                label = s->token.u.ident.atom;\n            else\n                label = JS_ATOM_NULL;\n            if (emit_break(s, label, is_cont))\n                goto fail;\n            if (label != JS_ATOM_NULL) {\n                if (next_token(s))\n                    goto fail;\n            }\n            if (js_parse_expect_semi(s))\n                goto fail;\n        }\n        break;\n    case TOK_SWITCH:\n        {\n            int label_case, label_break, label1;\n            int default_label_pos;\n            BlockEnv break_entry;\n\n            if (next_token(s))\n                goto fail;\n\n            set_eval_ret_undefined(s);\n            if (js_parse_expr_paren(s))\n                goto fail;\n\n            push_scope(s);\n            label_break = new_label(s);\n            push_break_entry(s->cur_func, &break_entry,\n                             label_name, label_break, -1, 1);\n\n            if (js_parse_expect(s, '{'))\n                goto fail;\n\n            default_label_pos = -1;\n            label_case = -1;\n            while (s->token.val != '}') {\n                if (s->token.val == TOK_CASE) {\n                    label1 = -1;\n                    if (label_case >= 0) {\n                        /* skip the case if needed */\n                        label1 = emit_goto(s, OP_goto, -1);\n                    }\n                    emit_label(s, label_case);\n                    label_case = -1;\n                    for (;;) {\n                        /* parse a sequence of case clauses */\n                        if (next_token(s))\n                            goto fail;\n                        emit_op(s, OP_dup);\n                        if (js_parse_expr(s))\n                            goto fail;\n                        if (js_parse_expect(s, ':'))\n                            goto fail;\n                        emit_op(s, OP_strict_eq);\n                        if (s->token.val == TOK_CASE) {\n                            label1 = emit_goto(s, OP_if_true, label1);\n                        } else {\n                            label_case = emit_goto(s, OP_if_false, -1);\n                            emit_label(s, label1);\n                            break;\n                        }\n                    }\n                } else if (s->token.val == TOK_DEFAULT) {\n                    if (next_token(s))\n                        goto fail;\n                    if (js_parse_expect(s, ':'))\n                        goto fail;\n                    if (default_label_pos >= 0) {\n                        js_parse_error(s, \"duplicate default\");\n                        goto fail;\n                    }\n                    if (label_case < 0) {\n                        /* falling thru direct from switch expression */\n                        label_case = emit_goto(s, OP_goto, -1);\n                    }\n                    /* Emit a dummy label opcode. Label will be patched after\n                       the end of the switch body. Do not use emit_label(s, 0)\n                       because it would clobber label 0 address, preventing\n                       proper optimizer operation.\n                     */\n                    emit_op(s, OP_label);\n                    emit_u32(s, 0);\n                    default_label_pos = s->cur_func->byte_code.size - 4;\n                } else {\n                    if (label_case < 0) {\n                        /* falling thru direct from switch expression */\n                        js_parse_error(s, \"invalid switch statement\");\n                        goto fail;\n                    }\n                    if (js_parse_statement_or_decl(s, DECL_MASK_ALL))\n                        goto fail;\n                }\n            }\n            if (js_parse_expect(s, '}'))\n                goto fail;\n            if (default_label_pos >= 0) {\n                /* Ugly patch for the the `default` label, shameful and risky */\n                put_u32(s->cur_func->byte_code.buf + default_label_pos,\n                        label_case);\n                s->cur_func->label_slots[label_case].pos = default_label_pos + 4;\n            } else {\n                emit_label(s, label_case);\n            }\n            emit_label(s, label_break);\n            emit_op(s, OP_drop); /* drop the switch expression */\n\n            pop_break_entry(s->cur_func);\n            pop_scope(s);\n        }\n        break;\n    case TOK_TRY:\n        {\n            int label_catch, label_catch2, label_finally, label_end;\n            JSAtom name;\n            BlockEnv block_env;\n\n            set_eval_ret_undefined(s);\n            if (next_token(s))\n                goto fail;\n            label_catch = new_label(s);\n            label_catch2 = new_label(s);\n            label_finally = new_label(s);\n            label_end = new_label(s);\n\n            emit_goto(s, OP_catch, label_catch);\n\n            push_break_entry(s->cur_func, &block_env,\n                             JS_ATOM_NULL, -1, -1, 1);\n            block_env.label_finally = label_finally;\n\n            if (js_parse_block(s))\n                goto fail;\n\n            pop_break_entry(s->cur_func);\n\n            if (js_is_live_code(s)) {\n                /* drop the catch offset */\n                emit_op(s, OP_drop);\n                /* must push dummy value to keep same stack size */\n                emit_op(s, OP_undefined);\n                emit_goto(s, OP_gosub, label_finally);\n                emit_op(s, OP_drop);\n\n                emit_goto(s, OP_goto, label_end);\n            }\n\n            if (s->token.val == TOK_CATCH) {\n                if (next_token(s))\n                    goto fail;\n\n                push_scope(s);  /* catch variable */\n                emit_label(s, label_catch);\n\n                if (s->token.val == '{') {\n                    /* support optional-catch-binding feature */\n                    emit_op(s, OP_drop);    /* pop the exception object */\n                } else {\n                    if (js_parse_expect(s, '('))\n                        goto fail;\n                    if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)) {\n                        if (s->token.val == '[' || s->token.val == '{') {\n                            /* XXX: TOK_LET is not completely correct */\n                            if (js_parse_destructuring_element(s, TOK_LET, 0, TRUE, -1, TRUE) < 0)\n                                goto fail;\n                        } else {\n                            js_parse_error(s, \"identifier expected\");\n                            goto fail;\n                        }\n                    } else {\n                        name = JS_DupAtom(ctx, s->token.u.ident.atom);\n                        if (next_token(s)\n                        ||  js_define_var(s, name, TOK_CATCH) < 0) {\n                            JS_FreeAtom(ctx, name);\n                            goto fail;\n                        }\n                        /* store the exception value in the catch variable */\n                        emit_op(s, OP_scope_put_var);\n                        emit_u32(s, name);\n                        emit_u16(s, s->cur_func->scope_level);\n                    }\n                    if (js_parse_expect(s, ')'))\n                        goto fail;\n                }\n                /* XXX: should keep the address to nop it out if there is no finally block */\n                emit_goto(s, OP_catch, label_catch2);\n\n                push_scope(s);  /* catch block */\n                push_break_entry(s->cur_func, &block_env, JS_ATOM_NULL,\n                                 -1, -1, 1);\n                block_env.label_finally = label_finally;\n\n                if (js_parse_block(s))\n                    goto fail;\n\n                pop_break_entry(s->cur_func);\n                pop_scope(s);  /* catch block */\n                pop_scope(s);  /* catch variable */\n\n                if (js_is_live_code(s)) {\n                    /* drop the catch2 offset */\n                    emit_op(s, OP_drop);\n                    /* XXX: should keep the address to nop it out if there is no finally block */\n                    /* must push dummy value to keep same stack size */\n                    emit_op(s, OP_undefined);\n                    emit_goto(s, OP_gosub, label_finally);\n                    emit_op(s, OP_drop);\n                    emit_goto(s, OP_goto, label_end);\n                }\n                /* catch exceptions thrown in the catch block to execute the\n                 * finally clause and rethrow the exception */\n                emit_label(s, label_catch2);\n                /* catch value is at TOS, no need to push undefined */\n                emit_goto(s, OP_gosub, label_finally);\n                emit_op(s, OP_throw);\n\n            } else if (s->token.val == TOK_FINALLY) {\n                /* finally without catch : execute the finally clause\n                 * and rethrow the exception */\n                emit_label(s, label_catch);\n                /* catch value is at TOS, no need to push undefined */\n                emit_goto(s, OP_gosub, label_finally);\n                emit_op(s, OP_throw);\n            } else {\n                js_parse_error(s, \"expecting catch or finally\");\n                goto fail;\n            }\n            emit_label(s, label_finally);\n            if (s->token.val == TOK_FINALLY) {\n                int saved_eval_ret_idx = 0; /* avoid warning */\n                \n                if (next_token(s))\n                    goto fail;\n                /* on the stack: ret_value gosub_ret_value */\n                push_break_entry(s->cur_func, &block_env, JS_ATOM_NULL,\n                                 -1, -1, 2);\n\n                if (s->cur_func->eval_ret_idx >= 0) {\n                    /* 'finally' updates eval_ret only if not a normal\n                       termination */\n                    saved_eval_ret_idx =\n                        add_var(s->ctx, s->cur_func, JS_ATOM__ret_);\n                    if (saved_eval_ret_idx < 0)\n                        goto fail;\n                    emit_op(s, OP_get_loc);\n                    emit_u16(s, s->cur_func->eval_ret_idx);\n                    emit_op(s, OP_put_loc);\n                    emit_u16(s, saved_eval_ret_idx);\n                    set_eval_ret_undefined(s);\n                }\n                \n                if (js_parse_block(s))\n                    goto fail;\n\n                if (s->cur_func->eval_ret_idx >= 0) {\n                    emit_op(s, OP_get_loc);\n                    emit_u16(s, saved_eval_ret_idx);\n                    emit_op(s, OP_put_loc);\n                    emit_u16(s, s->cur_func->eval_ret_idx);\n                }\n                pop_break_entry(s->cur_func);\n            }\n            emit_op(s, OP_ret);\n            emit_label(s, label_end);\n        }\n        break;\n    case ';':\n        /* empty statement */\n        if (next_token(s))\n            goto fail;\n        break;\n    case TOK_WITH:\n        if (s->cur_func->js_mode & JS_MODE_STRICT) {\n            js_parse_error(s, \"invalid keyword: with\");\n            goto fail;\n        } else {\n            int with_idx;\n\n            if (next_token(s))\n                goto fail;\n\n            if (js_parse_expr_paren(s))\n                goto fail;\n\n            push_scope(s);\n            with_idx = define_var(s, s->cur_func, JS_ATOM__with_,\n                                  JS_VAR_DEF_WITH);\n            if (with_idx < 0)\n                goto fail;\n            emit_op(s, OP_to_object);\n            emit_op(s, OP_put_loc);\n            emit_u16(s, with_idx);\n\n            set_eval_ret_undefined(s);\n            if (js_parse_statement(s))\n                goto fail;\n\n            /* Popping scope drops lexical context for the with object variable */\n            pop_scope(s);\n        }\n        break;\n    case TOK_FUNCTION:\n        /* ES6 Annex B.3.2 and B.3.3 semantics */\n        if (!(decl_mask & DECL_MASK_FUNC))\n            goto func_decl_error;\n        if (!(decl_mask & DECL_MASK_OTHER) && peek_token(s, FALSE) == '*')\n            goto func_decl_error;\n        goto parse_func_var;\n    case TOK_IDENT:\n        if (s->token.u.ident.is_reserved) {\n            js_parse_error_reserved_identifier(s);\n            goto fail;\n        }\n        /* Determine if `let` introduces a Declaration or an ExpressionStatement */\n        switch (is_let(s, decl_mask)) {\n        case TRUE:\n            tok = TOK_LET;\n            goto haslet;\n        case FALSE:\n            break;\n        default:\n            goto fail;\n        }\n        if (token_is_pseudo_keyword(s, JS_ATOM_async) &&\n            peek_token(s, TRUE) == TOK_FUNCTION) {\n            if (!(decl_mask & DECL_MASK_OTHER)) {\n            func_decl_error:\n                js_parse_error(s, \"function declarations can't appear in single-statement context\");\n                goto fail;\n            }\n        parse_func_var:\n            if (js_parse_function_decl(s, JS_PARSE_FUNC_VAR,\n                                       JS_FUNC_NORMAL, JS_ATOM_NULL,\n                                       s->token.ptr, s->token.line_num))\n                goto fail;\n            break;\n        }\n        goto hasexpr;\n\n    case TOK_CLASS:\n        if (!(decl_mask & DECL_MASK_OTHER)) {\n            js_parse_error(s, \"class declarations can't appear in single-statement context\");\n            goto fail;\n        }\n        if (js_parse_class(s, FALSE, JS_PARSE_EXPORT_NONE))\n            return -1;\n        break;\n\n    case TOK_DEBUGGER:\n        /* currently no debugger, so just skip the keyword */\n        if (next_token(s))\n            goto fail;\n        if (js_parse_expect_semi(s))\n            goto fail;\n        break;\n        \n    case TOK_ENUM:\n    case TOK_EXPORT:\n    case TOK_EXTENDS:\n        js_unsupported_keyword(s, s->token.u.ident.atom);\n        goto fail;\n\n    default:\n    hasexpr:\n        if (js_parse_expr(s))\n            goto fail;\n        if (s->cur_func->eval_ret_idx >= 0) {\n            /* store the expression value so that it can be returned\n               by eval() */\n            emit_op(s, OP_put_loc);\n            emit_u16(s, s->cur_func->eval_ret_idx);\n        } else {\n            emit_op(s, OP_drop); /* drop the result */\n        }\n        if (js_parse_expect_semi(s))\n            goto fail;\n        break;\n    }\ndone:\n    JS_FreeAtom(ctx, label_name);\n    return 0;\nfail:\n    JS_FreeAtom(ctx, label_name);\n    return -1;\n}\n\n/* 'name' is freed */\nstatic JSModuleDef *js_new_module_def(JSContext *ctx, JSAtom name)\n{\n    JSModuleDef *m;\n    m = js_mallocz(ctx, sizeof(*m));\n    if (!m) {\n        JS_FreeAtom(ctx, name);\n        return NULL;\n    }\n    m->header.ref_count = 1;\n    m->module_name = name;\n    m->module_ns = JS_UNDEFINED;\n    m->func_obj = JS_UNDEFINED;\n    m->eval_exception = JS_UNDEFINED;\n    m->meta_obj = JS_UNDEFINED;\n    list_add_tail(&m->link, &ctx->loaded_modules);\n    return m;\n}\n\nstatic void js_mark_module_def(JSRuntime *rt, JSModuleDef *m,\n                               JS_MarkFunc *mark_func)\n{\n    int i;\n\n    for(i = 0; i < m->export_entries_count; i++) {\n        JSExportEntry *me = &m->export_entries[i];\n        if (me->export_type == JS_EXPORT_TYPE_LOCAL &&\n            me->u.local.var_ref) {\n            mark_func(rt, &me->u.local.var_ref->header);\n        }\n    }\n\n    JS_MarkValue(rt, m->module_ns, mark_func);\n    JS_MarkValue(rt, m->func_obj, mark_func);\n    JS_MarkValue(rt, m->eval_exception, mark_func);\n    JS_MarkValue(rt, m->meta_obj, mark_func);\n}\n\nstatic void js_free_module_def(JSContext *ctx, JSModuleDef *m)\n{\n    int i;\n\n    JS_FreeAtom(ctx, m->module_name);\n\n    for(i = 0; i < m->req_module_entries_count; i++) {\n        JSReqModuleEntry *rme = &m->req_module_entries[i];\n        JS_FreeAtom(ctx, rme->module_name);\n    }\n    js_free(ctx, m->req_module_entries);\n\n    for(i = 0; i < m->export_entries_count; i++) {\n        JSExportEntry *me = &m->export_entries[i];\n        if (me->export_type == JS_EXPORT_TYPE_LOCAL)\n            free_var_ref(ctx->rt, me->u.local.var_ref);\n        JS_FreeAtom(ctx, me->export_name);\n        JS_FreeAtom(ctx, me->local_name);\n    }\n    js_free(ctx, m->export_entries);\n\n    js_free(ctx, m->star_export_entries);\n\n    for(i = 0; i < m->import_entries_count; i++) {\n        JSImportEntry *mi = &m->import_entries[i];\n        JS_FreeAtom(ctx, mi->import_name);\n    }\n    js_free(ctx, m->import_entries);\n\n    JS_FreeValue(ctx, m->module_ns);\n    JS_FreeValue(ctx, m->func_obj);\n    JS_FreeValue(ctx, m->eval_exception);\n    JS_FreeValue(ctx, m->meta_obj);\n    list_del(&m->link);\n    js_free(ctx, m);\n}\n\nstatic int add_req_module_entry(JSContext *ctx, JSModuleDef *m,\n                                JSAtom module_name)\n{\n    JSReqModuleEntry *rme;\n    int i;\n\n    /* no need to add the module request if it is already present */\n    for(i = 0; i < m->req_module_entries_count; i++) {\n        rme = &m->req_module_entries[i];\n        if (rme->module_name == module_name)\n            return i;\n    }\n\n    if (js_resize_array(ctx, (void **)&m->req_module_entries,\n                        sizeof(JSReqModuleEntry),\n                        &m->req_module_entries_size,\n                        m->req_module_entries_count + 1))\n        return -1;\n    rme = &m->req_module_entries[m->req_module_entries_count++];\n    rme->module_name = JS_DupAtom(ctx, module_name);\n    rme->module = NULL;\n    return i;\n}\n\nstatic JSExportEntry *find_export_entry(JSContext *ctx, JSModuleDef *m,\n                                        JSAtom export_name)\n{\n    JSExportEntry *me;\n    int i;\n    for(i = 0; i < m->export_entries_count; i++) {\n        me = &m->export_entries[i];\n        if (me->export_name == export_name)\n            return me;\n    }\n    return NULL;\n}\n\nstatic JSExportEntry *add_export_entry2(JSContext *ctx,\n                                        JSParseState *s, JSModuleDef *m,\n                                       JSAtom local_name, JSAtom export_name,\n                                       JSExportTypeEnum export_type)\n{\n    JSExportEntry *me;\n\n    if (find_export_entry(ctx, m, export_name)) {\n        char buf1[ATOM_GET_STR_BUF_SIZE];\n        if (s) {\n            js_parse_error(s, \"duplicate exported name '%s'\",\n                           JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name));\n        } else {\n            JS_ThrowSyntaxErrorAtom(ctx, \"duplicate exported name '%s'\", export_name);\n        }\n        return NULL;\n    }\n\n    if (js_resize_array(ctx, (void **)&m->export_entries,\n                        sizeof(JSExportEntry),\n                        &m->export_entries_size,\n                        m->export_entries_count + 1))\n        return NULL;\n    me = &m->export_entries[m->export_entries_count++];\n    memset(me, 0, sizeof(*me));\n    me->local_name = JS_DupAtom(ctx, local_name);\n    me->export_name = JS_DupAtom(ctx, export_name);\n    me->export_type = export_type;\n    return me;\n}\n\nstatic JSExportEntry *add_export_entry(JSParseState *s, JSModuleDef *m,\n                                       JSAtom local_name, JSAtom export_name,\n                                       JSExportTypeEnum export_type)\n{\n    return add_export_entry2(s->ctx, s, m, local_name, export_name,\n                             export_type);\n}\n\nstatic int add_star_export_entry(JSContext *ctx, JSModuleDef *m,\n                                 int req_module_idx)\n{\n    JSStarExportEntry *se;\n\n    if (js_resize_array(ctx, (void **)&m->star_export_entries,\n                        sizeof(JSStarExportEntry),\n                        &m->star_export_entries_size,\n                        m->star_export_entries_count + 1))\n        return -1;\n    se = &m->star_export_entries[m->star_export_entries_count++];\n    se->req_module_idx = req_module_idx;\n    return 0;\n}\n\n/* create a C module */\nJSModuleDef *JS_NewCModule(JSContext *ctx, const char *name_str,\n                           JSModuleInitFunc *func)\n{\n    JSModuleDef *m;\n    JSAtom name;\n    name = JS_NewAtom(ctx, name_str);\n    if (name == JS_ATOM_NULL)\n        return NULL;\n    m = js_new_module_def(ctx, name);\n    m->init_func = func;\n    return m;\n}\n\nint JS_AddModuleExport(JSContext *ctx, JSModuleDef *m, const char *export_name)\n{\n    JSExportEntry *me;\n    JSAtom name;\n    name = JS_NewAtom(ctx, export_name);\n    if (name == JS_ATOM_NULL)\n        return -1;\n    me = add_export_entry2(ctx, NULL, m, JS_ATOM_NULL, name,\n                           JS_EXPORT_TYPE_LOCAL);\n    JS_FreeAtom(ctx, name);\n    if (!me)\n        return -1;\n    else\n        return 0;\n}\n\nint JS_SetModuleExport(JSContext *ctx, JSModuleDef *m, const char *export_name,\n                       JSValue val)\n{\n    JSExportEntry *me;\n    JSAtom name;\n    name = JS_NewAtom(ctx, export_name);\n    if (name == JS_ATOM_NULL)\n        goto fail;\n    me = find_export_entry(ctx, m, name);\n    JS_FreeAtom(ctx, name);\n    if (!me)\n        goto fail;\n    set_value(ctx, me->u.local.var_ref->pvalue, val);\n    return 0;\n fail:\n    JS_FreeValue(ctx, val);\n    return -1;\n}\n\nvoid JS_SetModuleLoaderFunc(JSRuntime *rt,\n                            JSModuleNormalizeFunc *module_normalize,\n                            JSModuleLoaderFunc *module_loader, void *opaque)\n{\n    rt->module_normalize_func = module_normalize;\n    rt->module_loader_func = module_loader;\n    rt->module_loader_opaque = opaque;\n}\n\n/* default module filename normalizer */\nstatic char *js_default_module_normalize_name(JSContext *ctx,\n                                              const char *base_name,\n                                              const char *name)\n{\n    char *filename, *p;\n    const char *r;\n    int len;\n\n    if (name[0] != '.') {\n        /* if no initial dot, the module name is not modified */\n        return js_strdup(ctx, name);\n    }\n\n    p = strrchr(base_name, '/');\n    if (p)\n        len = p - base_name;\n    else\n        len = 0;\n\n    filename = js_malloc(ctx, len + strlen(name) + 1 + 1);\n    if (!filename)\n        return NULL;\n    memcpy(filename, base_name, len);\n    filename[len] = '\\0';\n\n    /* we only normalize the leading '..' or '.' */\n    r = name;\n    for(;;) {\n        if (r[0] == '.' && r[1] == '/') {\n            r += 2;\n        } else if (r[0] == '.' && r[1] == '.' && r[2] == '/') {\n            /* remove the last path element of filename, except if \".\"\n               or \"..\" */\n            if (filename[0] == '\\0')\n                break;\n            p = strrchr(filename, '/');\n            if (!p)\n                p = filename;\n            else\n                p++;\n            if (!strcmp(p, \".\") || !strcmp(p, \"..\"))\n                break;\n            if (p > filename)\n                p--;\n            *p = '\\0';\n            r += 3;\n        } else {\n            break;\n        }\n    }\n    if (filename[0] != '\\0')\n        strcat(filename, \"/\");\n    strcat(filename, r);\n    //    printf(\"normalize: %s %s -> %s\\n\", base_name, name, filename);\n    return filename;\n}\n\nstatic JSModuleDef *js_find_loaded_module(JSContext *ctx, JSAtom name)\n{\n    struct list_head *el;\n    JSModuleDef *m;\n    \n    /* first look at the loaded modules */\n    list_for_each(el, &ctx->loaded_modules) {\n        m = list_entry(el, JSModuleDef, link);\n        if (m->module_name == name)\n            return m;\n    }\n    return NULL;\n}\n\n/* return NULL in case of exception (e.g. module could not be loaded) */\nstatic JSModuleDef *js_host_resolve_imported_module(JSContext *ctx,\n                                                    const char *base_cname,\n                                                    const char *cname1)\n{\n    JSRuntime *rt = ctx->rt;\n    JSModuleDef *m;\n    char *cname;\n    JSAtom module_name;\n\n    if (!rt->module_normalize_func) {\n        cname = js_default_module_normalize_name(ctx, base_cname, cname1);\n    } else {\n        cname = rt->module_normalize_func(ctx, base_cname, cname1,\n                                          rt->module_loader_opaque);\n    }\n    if (!cname)\n        return NULL;\n\n    module_name = JS_NewAtom(ctx, cname);\n    if (module_name == JS_ATOM_NULL) {\n        js_free(ctx, cname);\n        return NULL;\n    }\n\n    /* first look at the loaded modules */\n    m = js_find_loaded_module(ctx, module_name);\n    if (m) {\n        js_free(ctx, cname);\n        JS_FreeAtom(ctx, module_name);\n        return m;\n    }\n\n    JS_FreeAtom(ctx, module_name);\n\n    /* load the module */\n    if (!rt->module_loader_func) {\n        /* XXX: use a syntax error ? */\n        JS_ThrowReferenceError(ctx, \"could not load module '%s'\",\n                               cname);\n        js_free(ctx, cname);\n        return NULL;\n    }\n\n    m = rt->module_loader_func(ctx, cname, rt->module_loader_opaque);\n    js_free(ctx, cname);\n    return m;\n}\n\nstatic JSModuleDef *js_host_resolve_imported_module_atom(JSContext *ctx,\n                                                    JSAtom base_module_name,\n                                                    JSAtom module_name1)\n{\n    const char *base_cname, *cname;\n    JSModuleDef *m;\n    \n    base_cname = JS_AtomToCString(ctx, base_module_name);\n    if (!base_cname)\n        return NULL;\n    cname = JS_AtomToCString(ctx, module_name1);\n    if (!cname) {\n        JS_FreeCString(ctx, base_cname);\n        return NULL;\n    }\n    m = js_host_resolve_imported_module(ctx, base_cname, cname);\n    JS_FreeCString(ctx, base_cname);\n    JS_FreeCString(ctx, cname);\n    return m;\n}\n\ntypedef struct JSResolveEntry {\n    JSModuleDef *module;\n    JSAtom name;\n} JSResolveEntry;\n\ntypedef struct JSResolveState {\n    JSResolveEntry *array;\n    int size;\n    int count;\n} JSResolveState;\n\nstatic int find_resolve_entry(JSResolveState *s,\n                              JSModuleDef *m, JSAtom name)\n{\n    int i;\n    for(i = 0; i < s->count; i++) {\n        JSResolveEntry *re = &s->array[i];\n        if (re->module == m && re->name == name)\n            return i;\n    }\n    return -1;\n}\n\nstatic int add_resolve_entry(JSContext *ctx, JSResolveState *s,\n                             JSModuleDef *m, JSAtom name)\n{\n    JSResolveEntry *re;\n\n    if (js_resize_array(ctx, (void **)&s->array,\n                        sizeof(JSResolveEntry),\n                        &s->size, s->count + 1))\n        return -1;\n    re = &s->array[s->count++];\n    re->module = m;\n    re->name = JS_DupAtom(ctx, name);\n    return 0;\n}\n\ntypedef enum JSResolveResultEnum {\n    JS_RESOLVE_RES_EXCEPTION = -1, /* memory alloc error */\n    JS_RESOLVE_RES_FOUND = 0,\n    JS_RESOLVE_RES_NOT_FOUND,\n    JS_RESOLVE_RES_CIRCULAR,\n    JS_RESOLVE_RES_AMBIGUOUS,\n} JSResolveResultEnum;\n\nstatic JSResolveResultEnum js_resolve_export1(JSContext *ctx,\n                                              JSModuleDef **pmodule,\n                                              JSExportEntry **pme,\n                                              JSModuleDef *m,\n                                              JSAtom export_name,\n                                              JSResolveState *s)\n{\n    JSExportEntry *me;\n\n    *pmodule = NULL;\n    *pme = NULL;\n    if (find_resolve_entry(s, m, export_name) >= 0)\n        return JS_RESOLVE_RES_CIRCULAR;\n    if (add_resolve_entry(ctx, s, m, export_name) < 0)\n        return JS_RESOLVE_RES_EXCEPTION;\n    me = find_export_entry(ctx, m, export_name);\n    if (me) {\n        if (me->export_type == JS_EXPORT_TYPE_LOCAL) {\n            /* local export */\n            *pmodule = m;\n            *pme = me;\n            return JS_RESOLVE_RES_FOUND;\n        } else {\n            /* indirect export */\n            JSModuleDef *m1;\n            m1 = m->req_module_entries[me->u.req_module_idx].module;\n            if (me->local_name == JS_ATOM__star_) {\n                /* export ns from */\n                *pmodule = m;\n                *pme = me;\n                return JS_RESOLVE_RES_FOUND;\n            } else {\n                return js_resolve_export1(ctx, pmodule, pme, m1,\n                                          me->local_name, s);\n            }\n        }\n    } else {\n        if (export_name != JS_ATOM_default) {\n            /* not found in direct or indirect exports: try star exports */\n            int i;\n\n            for(i = 0; i < m->star_export_entries_count; i++) {\n                JSStarExportEntry *se = &m->star_export_entries[i];\n                JSModuleDef *m1, *res_m;\n                JSExportEntry *res_me;\n                JSResolveResultEnum ret;\n\n                m1 = m->req_module_entries[se->req_module_idx].module;\n                ret = js_resolve_export1(ctx, &res_m, &res_me, m1,\n                                         export_name, s);\n                if (ret == JS_RESOLVE_RES_AMBIGUOUS ||\n                    ret == JS_RESOLVE_RES_EXCEPTION) {\n                    return ret;\n                } else if (ret == JS_RESOLVE_RES_FOUND) {\n                    if (*pme != NULL) {\n                        if (*pmodule != res_m ||\n                            res_me->local_name != (*pme)->local_name) {\n                            *pmodule = NULL;\n                            *pme = NULL;\n                            return JS_RESOLVE_RES_AMBIGUOUS;\n                        }\n                    } else {\n                        *pmodule = res_m;\n                        *pme = res_me;\n                    }\n                }\n            }\n            if (*pme != NULL)\n                return JS_RESOLVE_RES_FOUND;\n        }\n        return JS_RESOLVE_RES_NOT_FOUND;\n    }\n}\n\n/* If the return value is JS_RESOLVE_RES_FOUND, return the module\n  (*pmodule) and the corresponding local export entry\n  (*pme). Otherwise return (NULL, NULL) */\nstatic JSResolveResultEnum js_resolve_export(JSContext *ctx,\n                                             JSModuleDef **pmodule,\n                                             JSExportEntry **pme,\n                                             JSModuleDef *m,\n                                             JSAtom export_name)\n{\n    JSResolveState ss, *s = &ss;\n    int i;\n    JSResolveResultEnum ret;\n\n    s->array = NULL;\n    s->size = 0;\n    s->count = 0;\n\n    ret = js_resolve_export1(ctx, pmodule, pme, m, export_name, s);\n\n    for(i = 0; i < s->count; i++)\n        JS_FreeAtom(ctx, s->array[i].name);\n    js_free(ctx, s->array);\n\n    return ret;\n}\n\nstatic void js_resolve_export_throw_error(JSContext *ctx,\n                                          JSResolveResultEnum res,\n                                          JSModuleDef *m, JSAtom export_name)\n{\n    char buf1[ATOM_GET_STR_BUF_SIZE];\n    char buf2[ATOM_GET_STR_BUF_SIZE];\n    switch(res) {\n    case JS_RESOLVE_RES_EXCEPTION:\n        break;\n    default:\n    case JS_RESOLVE_RES_NOT_FOUND:\n        JS_ThrowSyntaxError(ctx, \"Could not find export '%s' in module '%s'\",\n                            JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),\n                            JS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));\n        break;\n    case JS_RESOLVE_RES_CIRCULAR:\n        JS_ThrowSyntaxError(ctx, \"circular reference when looking for export '%s' in module '%s'\",\n                            JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),\n                            JS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));\n        break;\n    case JS_RESOLVE_RES_AMBIGUOUS:\n        JS_ThrowSyntaxError(ctx, \"export '%s' in module '%s' is ambiguous\",\n                            JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),\n                            JS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));\n        break;\n    }\n}\n\n\ntypedef enum {\n    EXPORTED_NAME_AMBIGUOUS,\n    EXPORTED_NAME_NORMAL,\n    EXPORTED_NAME_NS,\n} ExportedNameEntryEnum;\n\ntypedef struct ExportedNameEntry {\n    JSAtom export_name;\n    ExportedNameEntryEnum export_type;\n    union {\n        JSExportEntry *me; /* using when the list is built */\n        JSVarRef *var_ref; /* EXPORTED_NAME_NORMAL */\n        JSModuleDef *module; /* for EXPORTED_NAME_NS */\n    } u;\n} ExportedNameEntry;\n\ntypedef struct GetExportNamesState {\n    JSModuleDef **modules;\n    int modules_size;\n    int modules_count;\n\n    ExportedNameEntry *exported_names;\n    int exported_names_size;\n    int exported_names_count;\n} GetExportNamesState;\n\nstatic int find_exported_name(GetExportNamesState *s, JSAtom name)\n{\n    int i;\n    for(i = 0; i < s->exported_names_count; i++) {\n        if (s->exported_names[i].export_name == name)\n            return i;\n    }\n    return -1;\n}\n\nstatic __exception int get_exported_names(JSContext *ctx,\n                                          GetExportNamesState *s,\n                                          JSModuleDef *m, BOOL from_star)\n{\n    ExportedNameEntry *en;\n    int i, j;\n\n    /* check circular reference */\n    for(i = 0; i < s->modules_count; i++) {\n        if (s->modules[i] == m)\n            return 0;\n    }\n    if (js_resize_array(ctx, (void **)&s->modules, sizeof(s->modules[0]),\n                        &s->modules_size, s->modules_count + 1))\n        return -1;\n    s->modules[s->modules_count++] = m;\n\n    for(i = 0; i < m->export_entries_count; i++) {\n        JSExportEntry *me = &m->export_entries[i];\n        if (from_star && me->export_name == JS_ATOM_default)\n            continue;\n        j = find_exported_name(s, me->export_name);\n        if (j < 0) {\n            if (js_resize_array(ctx, (void **)&s->exported_names, sizeof(s->exported_names[0]),\n                                &s->exported_names_size,\n                                s->exported_names_count + 1))\n                return -1;\n            en = &s->exported_names[s->exported_names_count++];\n            en->export_name = me->export_name;\n            /* avoid a second lookup for simple module exports */\n            if (from_star || me->export_type != JS_EXPORT_TYPE_LOCAL)\n                en->u.me = NULL;\n            else\n                en->u.me = me;\n        } else {\n            en = &s->exported_names[j];\n            en->u.me = NULL;\n        }\n    }\n    for(i = 0; i < m->star_export_entries_count; i++) {\n        JSStarExportEntry *se = &m->star_export_entries[i];\n        JSModuleDef *m1;\n        m1 = m->req_module_entries[se->req_module_idx].module;\n        if (get_exported_names(ctx, s, m1, TRUE))\n            return -1;\n    }\n    return 0;\n}\n\n/* Unfortunately, the spec gives a different behavior from GetOwnProperty ! */\nstatic int js_module_ns_has(JSContext *ctx, JSValueConst obj, JSAtom atom)\n{\n    return (find_own_property1(JS_VALUE_GET_OBJ(obj), atom) != NULL);\n}\n\nstatic const JSClassExoticMethods js_module_ns_exotic_methods = {\n    .has_property = js_module_ns_has,\n};\n\nstatic int exported_names_cmp(const void *p1, const void *p2, void *opaque)\n{\n    JSContext *ctx = opaque;\n    const ExportedNameEntry *me1 = p1;\n    const ExportedNameEntry *me2 = p2;\n    JSValue str1, str2;\n    int ret;\n\n    /* XXX: should avoid allocation memory in atom comparison */\n    str1 = JS_AtomToString(ctx, me1->export_name);\n    str2 = JS_AtomToString(ctx, me2->export_name);\n    if (JS_IsException(str1) || JS_IsException(str2)) {\n        /* XXX: raise an error ? */\n        ret = 0;\n    } else {\n        ret = js_string_compare(ctx, JS_VALUE_GET_STRING(str1),\n                                JS_VALUE_GET_STRING(str2));\n    }\n    JS_FreeValue(ctx, str1);\n    JS_FreeValue(ctx, str2);\n    return ret;\n}\n\nstatic JSValue js_get_module_ns(JSContext *ctx, JSModuleDef *m);\n\nstatic JSValue js_module_ns_autoinit(JSContext *ctx, JSObject *p, JSAtom atom,\n                                     void *opaque)\n{\n    JSModuleDef *m = opaque;\n    return js_get_module_ns(ctx, m);\n}\n\nstatic JSValue js_build_module_ns(JSContext *ctx, JSModuleDef *m)\n{\n    JSValue obj;\n    JSObject *p;\n    GetExportNamesState s_s, *s = &s_s;\n    int i, ret;\n    JSProperty *pr;\n\n    obj = JS_NewObjectClass(ctx, JS_CLASS_MODULE_NS);\n    if (JS_IsException(obj))\n        return obj;\n    p = JS_VALUE_GET_OBJ(obj);\n\n    memset(s, 0, sizeof(*s));\n    ret = get_exported_names(ctx, s, m, FALSE);\n    js_free(ctx, s->modules);\n    if (ret)\n        goto fail;\n\n    /* Resolve the exported names. The ambiguous exports are removed */\n    for(i = 0; i < s->exported_names_count; i++) {\n        ExportedNameEntry *en = &s->exported_names[i];\n        JSResolveResultEnum res;\n        JSExportEntry *res_me;\n        JSModuleDef *res_m;\n\n        if (en->u.me) {\n            res_me = en->u.me; /* fast case: no resolution needed */\n            res_m = m;\n            res = JS_RESOLVE_RES_FOUND;\n        } else {\n            res = js_resolve_export(ctx, &res_m, &res_me, m,\n                                    en->export_name);\n        }\n        if (res != JS_RESOLVE_RES_FOUND) {\n            if (res != JS_RESOLVE_RES_AMBIGUOUS) {\n                js_resolve_export_throw_error(ctx, res, m, en->export_name);\n                goto fail;\n            }\n            en->export_type = EXPORTED_NAME_AMBIGUOUS;\n        } else {\n            if (res_me->local_name == JS_ATOM__star_) {\n                en->export_type = EXPORTED_NAME_NS;\n                en->u.module = res_m->req_module_entries[res_me->u.req_module_idx].module;\n            } else {\n                en->export_type = EXPORTED_NAME_NORMAL;\n                if (res_me->u.local.var_ref) {\n                    en->u.var_ref = res_me->u.local.var_ref;\n                } else {\n                    JSObject *p1 = JS_VALUE_GET_OBJ(res_m->func_obj);\n                    p1 = JS_VALUE_GET_OBJ(res_m->func_obj);\n                    en->u.var_ref = p1->u.func.var_refs[res_me->u.local.var_idx];\n                }\n            }\n        }\n    }\n\n    /* sort the exported names */\n    rqsort(s->exported_names, s->exported_names_count,\n           sizeof(s->exported_names[0]), exported_names_cmp, ctx);\n\n    for(i = 0; i < s->exported_names_count; i++) {\n        ExportedNameEntry *en = &s->exported_names[i];\n        switch(en->export_type) {\n        case EXPORTED_NAME_NORMAL:\n            {\n                JSVarRef *var_ref = en->u.var_ref;\n                pr = add_property(ctx, p, en->export_name,\n                                  JS_PROP_ENUMERABLE | JS_PROP_WRITABLE |\n                                  JS_PROP_VARREF);\n                if (!pr)\n                    goto fail;\n                var_ref->header.ref_count++;\n                pr->u.var_ref = var_ref;\n            }\n            break;\n        case EXPORTED_NAME_NS:\n            /* the exported namespace must be created on demand */\n            if (JS_DefineAutoInitProperty(ctx, obj,\n                                          en->export_name,\n                                          JS_AUTOINIT_ID_MODULE_NS,\n                                          en->u.module, JS_PROP_ENUMERABLE | JS_PROP_WRITABLE) < 0)\n                goto fail;\n            break;\n        default:\n            break;\n        }\n    }\n\n    js_free(ctx, s->exported_names);\n\n    JS_DefinePropertyValue(ctx, obj, JS_ATOM_Symbol_toStringTag,\n                           JS_AtomToString(ctx, JS_ATOM_Module),\n                           0);\n\n    p->extensible = FALSE;\n    return obj;\n fail:\n    js_free(ctx, s->exported_names);\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_get_module_ns(JSContext *ctx, JSModuleDef *m)\n{\n    if (JS_IsUndefined(m->module_ns)) {\n        JSValue val;\n        val = js_build_module_ns(ctx, m);\n        if (JS_IsException(val))\n            return JS_EXCEPTION;\n        m->module_ns = val;\n    }\n    return JS_DupValue(ctx, m->module_ns);\n}\n\n/* Load all the required modules for module 'm' */\nstatic int js_resolve_module(JSContext *ctx, JSModuleDef *m)\n{\n    int i;\n    JSModuleDef *m1;\n\n    if (m->resolved)\n        return 0;\n#ifdef DUMP_MODULE_RESOLVE\n    {\n        char buf1[ATOM_GET_STR_BUF_SIZE];\n        printf(\"resolving module '%s':\\n\", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));\n    }\n#endif\n    m->resolved = TRUE;\n    /* resolve each requested module */\n    for(i = 0; i < m->req_module_entries_count; i++) {\n        JSReqModuleEntry *rme = &m->req_module_entries[i];\n        m1 = js_host_resolve_imported_module_atom(ctx, m->module_name,\n                                                  rme->module_name);\n        if (!m1)\n            return -1;\n        rme->module = m1;\n        /* already done in js_host_resolve_imported_module() except if\n           the module was loaded with JS_EvalBinary() */\n        if (js_resolve_module(ctx, m1) < 0)\n            return -1;\n    }\n    return 0;\n}\n\nstatic JSVarRef *js_create_module_var(JSContext *ctx, BOOL is_lexical)\n{\n    JSVarRef *var_ref;\n    var_ref = js_malloc(ctx, sizeof(JSVarRef));\n    if (!var_ref)\n        return NULL;\n    var_ref->header.ref_count = 1;\n    if (is_lexical)\n        var_ref->value = JS_UNINITIALIZED;\n    else\n        var_ref->value = JS_UNDEFINED;\n    var_ref->pvalue = &var_ref->value;\n    var_ref->is_detached = TRUE;\n    add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);\n    return var_ref;\n}\n\n/* Create the <eval> function associated with the module */\nstatic int js_create_module_bytecode_function(JSContext *ctx, JSModuleDef *m)\n{\n    JSFunctionBytecode *b;\n    int i;\n    JSVarRef **var_refs;\n    JSValue func_obj, bfunc;\n    JSObject *p;\n\n    bfunc = m->func_obj;\n    func_obj = JS_NewObjectProtoClass(ctx, ctx->function_proto,\n                                      JS_CLASS_BYTECODE_FUNCTION);\n\n    if (JS_IsException(func_obj))\n        return -1;\n    b = JS_VALUE_GET_PTR(bfunc);\n\n    p = JS_VALUE_GET_OBJ(func_obj);\n    p->u.func.function_bytecode = b;\n    b->header.ref_count++;\n    p->u.func.home_object = NULL;\n    p->u.func.var_refs = NULL;\n    if (b->closure_var_count) {\n        var_refs = js_mallocz(ctx, sizeof(var_refs[0]) * b->closure_var_count);\n        if (!var_refs)\n            goto fail;\n        p->u.func.var_refs = var_refs;\n\n        /* create the global variables. The other variables are\n           imported from other modules */\n        for(i = 0; i < b->closure_var_count; i++) {\n            JSClosureVar *cv = &b->closure_var[i];\n            JSVarRef *var_ref;\n            if (cv->is_local) {\n                var_ref = js_create_module_var(ctx, cv->is_lexical);\n                if (!var_ref)\n                    goto fail;\n#ifdef DUMP_MODULE_RESOLVE\n                printf(\"local %d: %p\\n\", i, var_ref);\n#endif\n                var_refs[i] = var_ref;\n            }\n        }\n    }\n    m->func_obj = func_obj;\n    JS_FreeValue(ctx, bfunc);\n    return 0;\n fail:\n    JS_FreeValue(ctx, func_obj);\n    return -1;\n}\n\n/* must be done before js_link_module() because of cyclic references */\nstatic int js_create_module_function(JSContext *ctx, JSModuleDef *m)\n{\n    BOOL is_c_module;\n    int i;\n    JSVarRef *var_ref;\n    \n    if (m->func_created)\n        return 0;\n\n    is_c_module = (m->init_func != NULL);\n\n    if (is_c_module) {\n        /* initialize the exported variables */\n        for(i = 0; i < m->export_entries_count; i++) {\n            JSExportEntry *me = &m->export_entries[i];\n            if (me->export_type == JS_EXPORT_TYPE_LOCAL) {\n                var_ref = js_create_module_var(ctx, FALSE);\n                if (!var_ref)\n                    return -1;\n                me->u.local.var_ref = var_ref;\n            }\n        }\n    } else {\n        if (js_create_module_bytecode_function(ctx, m))\n            return -1;\n    }\n    m->func_created = TRUE;\n\n    /* do it on the dependencies */\n    \n    for(i = 0; i < m->req_module_entries_count; i++) {\n        JSReqModuleEntry *rme = &m->req_module_entries[i];\n        if (js_create_module_function(ctx, rme->module) < 0)\n            return -1;\n    }\n\n    return 0;\n}    \n\n    \n/* Prepare a module to be executed by resolving all the imported\n   variables. */\nstatic int js_link_module(JSContext *ctx, JSModuleDef *m)\n{\n    int i;\n    JSImportEntry *mi;\n    JSModuleDef *m1;\n    JSVarRef **var_refs, *var_ref;\n    JSObject *p;\n    BOOL is_c_module;\n    JSValue ret_val;\n    \n    if (m->instantiated)\n        return 0;\n    m->instantiated = TRUE;\n\n#ifdef DUMP_MODULE_RESOLVE\n    {\n        char buf1[ATOM_GET_STR_BUF_SIZE];\n        printf(\"start instantiating module '%s':\\n\", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));\n    }\n#endif\n\n    for(i = 0; i < m->req_module_entries_count; i++) {\n        JSReqModuleEntry *rme = &m->req_module_entries[i];\n        if (js_link_module(ctx, rme->module) < 0)\n            goto fail;\n    }\n\n#ifdef DUMP_MODULE_RESOLVE\n    {\n        char buf1[ATOM_GET_STR_BUF_SIZE];\n        printf(\"instantiating module '%s':\\n\", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));\n    }\n#endif\n    /* check the indirect exports */\n    for(i = 0; i < m->export_entries_count; i++) {\n        JSExportEntry *me = &m->export_entries[i];\n        if (me->export_type == JS_EXPORT_TYPE_INDIRECT &&\n            me->local_name != JS_ATOM__star_) {\n            JSResolveResultEnum ret;\n            JSExportEntry *res_me;\n            JSModuleDef *res_m, *m1;\n            m1 = m->req_module_entries[me->u.req_module_idx].module;\n            ret = js_resolve_export(ctx, &res_m, &res_me, m1, me->local_name);\n            if (ret != JS_RESOLVE_RES_FOUND) {\n                js_resolve_export_throw_error(ctx, ret, m, me->export_name);\n                goto fail;\n            }\n        }\n    }\n\n#ifdef DUMP_MODULE_RESOLVE\n    {\n        printf(\"exported bindings:\\n\");\n        for(i = 0; i < m->export_entries_count; i++) {\n            JSExportEntry *me = &m->export_entries[i];\n            printf(\" name=\"); print_atom(ctx, me->export_name);\n            printf(\" local=\"); print_atom(ctx, me->local_name);\n            printf(\" type=%d idx=%d\\n\", me->export_type, me->u.local.var_idx);\n        }\n    }\n#endif\n\n    is_c_module = (m->init_func != NULL);\n\n    if (!is_c_module) {\n        p = JS_VALUE_GET_OBJ(m->func_obj);\n        var_refs = p->u.func.var_refs;\n\n        for(i = 0; i < m->import_entries_count; i++) {\n            mi = &m->import_entries[i];\n#ifdef DUMP_MODULE_RESOLVE\n            printf(\"import var_idx=%d name=\", mi->var_idx);\n            print_atom(ctx, mi->import_name);\n            printf(\": \");\n#endif\n            m1 = m->req_module_entries[mi->req_module_idx].module;\n            if (mi->import_name == JS_ATOM__star_) {\n                JSValue val;\n                /* name space import */\n                val = js_get_module_ns(ctx, m1);\n                if (JS_IsException(val))\n                    goto fail;\n                set_value(ctx, &var_refs[mi->var_idx]->value, val);\n#ifdef DUMP_MODULE_RESOLVE\n                printf(\"namespace\\n\");\n#endif\n            } else {\n                JSResolveResultEnum ret;\n                JSExportEntry *res_me;\n                JSModuleDef *res_m;\n                JSObject *p1;\n\n                ret = js_resolve_export(ctx, &res_m,\n                                        &res_me, m1, mi->import_name);\n                if (ret != JS_RESOLVE_RES_FOUND) {\n                    js_resolve_export_throw_error(ctx, ret, m1, mi->import_name);\n                    goto fail;\n                }\n                if (res_me->local_name == JS_ATOM__star_) {\n                    JSValue val;\n                    JSModuleDef *m2;\n                    /* name space import from */\n                    m2 = res_m->req_module_entries[res_me->u.req_module_idx].module;\n                    val = js_get_module_ns(ctx, m2);\n                    if (JS_IsException(val))\n                        goto fail;\n                    var_ref = js_create_module_var(ctx, TRUE);\n                    if (!var_ref) {\n                        JS_FreeValue(ctx, val);\n                        goto fail;\n                    }\n                    set_value(ctx, &var_ref->value, val);\n                    var_refs[mi->var_idx] = var_ref;\n#ifdef DUMP_MODULE_RESOLVE\n                    printf(\"namespace from\\n\");\n#endif\n                } else {\n                    var_ref = res_me->u.local.var_ref;\n                    if (!var_ref) {\n                        p1 = JS_VALUE_GET_OBJ(res_m->func_obj);\n                        var_ref = p1->u.func.var_refs[res_me->u.local.var_idx];\n                    }\n                    var_ref->header.ref_count++;\n                    var_refs[mi->var_idx] = var_ref;\n#ifdef DUMP_MODULE_RESOLVE\n                    printf(\"local export (var_ref=%p)\\n\", var_ref);\n#endif\n                }\n            }\n        }\n\n        /* keep the exported variables in the module export entries (they\n           are used when the eval function is deleted and cannot be\n           initialized before in case imports are exported) */\n        for(i = 0; i < m->export_entries_count; i++) {\n            JSExportEntry *me = &m->export_entries[i];\n            if (me->export_type == JS_EXPORT_TYPE_LOCAL) {\n                var_ref = var_refs[me->u.local.var_idx];\n                var_ref->header.ref_count++;\n                me->u.local.var_ref = var_ref;\n            }\n        }\n\n        /* initialize the global variables */\n        ret_val = JS_Call(ctx, m->func_obj, JS_TRUE, 0, NULL);\n        if (JS_IsException(ret_val))\n            goto fail;\n        JS_FreeValue(ctx, ret_val);\n    }\n\n#ifdef DUMP_MODULE_RESOLVE\n    printf(\"done instantiate\\n\");\n#endif\n    return 0;\n fail:\n    return -1;\n}\n\n/* return JS_ATOM_NULL if the name cannot be found. Only works with\n   not striped bytecode functions. */\nJSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels)\n{\n    JSStackFrame *sf;\n    JSFunctionBytecode *b;\n    JSObject *p;\n    /* XXX: currently we just use the filename of the englobing\n       function. It does not work for eval(). Need to add a\n       ScriptOrModule info in JSFunctionBytecode */\n    sf = ctx->rt->current_stack_frame;\n    if (!sf)\n        return JS_ATOM_NULL;\n    while (n_stack_levels-- > 0) {\n        sf = sf->prev_frame;\n        if (!sf)\n            return JS_ATOM_NULL;\n    }\n    if (JS_VALUE_GET_TAG(sf->cur_func) != JS_TAG_OBJECT)\n        return JS_ATOM_NULL;\n    p = JS_VALUE_GET_OBJ(sf->cur_func);\n    if (!js_class_has_bytecode(p->class_id))\n        return JS_ATOM_NULL;\n    b = p->u.func.function_bytecode;\n    if (!b->has_debug)\n        return JS_ATOM_NULL;\n    return JS_DupAtom(ctx, b->debug.filename);\n}\n\nJSAtom JS_GetModuleName(JSContext *ctx, JSModuleDef *m)\n{\n    return JS_DupAtom(ctx, m->module_name);\n}\n\nJSValue JS_GetImportMeta(JSContext *ctx, JSModuleDef *m)\n{\n    JSValue obj;\n    /* allocate meta_obj only if requested to save memory */\n    obj = m->meta_obj;\n    if (JS_IsUndefined(obj)) {\n        obj = JS_NewObjectProto(ctx, JS_NULL);\n        if (JS_IsException(obj))\n            return JS_EXCEPTION;\n        m->meta_obj = obj;\n    }\n    return JS_DupValue(ctx, obj);\n}\n\nstatic JSValue js_import_meta(JSContext *ctx)\n{\n    JSAtom filename;\n    JSModuleDef *m;\n    \n    filename = JS_GetScriptOrModuleName(ctx, 0);\n    if (filename == JS_ATOM_NULL)\n        goto fail;\n\n    /* XXX: inefficient, need to add a module or script pointer in\n       JSFunctionBytecode */\n    m = js_find_loaded_module(ctx, filename);\n    JS_FreeAtom(ctx, filename);\n    if (!m) {\n    fail:\n        JS_ThrowTypeError(ctx, \"import.meta not supported in this context\");\n        return JS_EXCEPTION;\n    }\n    return JS_GetImportMeta(ctx, m);\n}\n\n/* used by os.Worker() and import() */\nJSModuleDef *JS_RunModule(JSContext *ctx, const char *basename,\n                          const char *filename)\n{\n    JSModuleDef *m;\n    JSValue ret, func_obj;\n    \n    m = js_host_resolve_imported_module(ctx, basename, filename);\n    if (!m)\n        return NULL;\n    \n    if (js_resolve_module(ctx, m) < 0) {\n        js_free_modules(ctx, JS_FREE_MODULE_NOT_RESOLVED);\n        return NULL;\n    }\n\n    /* Evaluate the module code */\n    func_obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));\n    ret = JS_EvalFunction(ctx, func_obj);\n    if (JS_IsException(ret))\n        return NULL;\n    JS_FreeValue(ctx, ret);\n    return m;\n}\n\nstatic JSValue js_dynamic_import_job(JSContext *ctx,\n                                     int argc, JSValueConst *argv)\n{\n    JSValueConst *resolving_funcs = argv;\n    JSValueConst basename_val = argv[2];\n    JSValueConst specifier = argv[3];\n    JSModuleDef *m;\n    const char *basename = NULL, *filename;\n    JSValue ret, err, ns;\n\n    if (!JS_IsString(basename_val)) {\n        JS_ThrowTypeError(ctx, \"no function filename for import()\");\n        goto exception;\n    }\n    basename = JS_ToCString(ctx, basename_val);\n    if (!basename)\n        goto exception;\n\n    filename = JS_ToCString(ctx, specifier);\n    if (!filename)\n        goto exception;\n                     \n    m = JS_RunModule(ctx, basename, filename);\n    JS_FreeCString(ctx, filename);\n    if (!m)\n        goto exception;\n\n    /* return the module namespace */\n    ns = js_get_module_ns(ctx, m);\n    if (JS_IsException(ns))\n        goto exception;\n\n    ret = JS_Call(ctx, resolving_funcs[0], JS_UNDEFINED,\n                   1, (JSValueConst *)&ns);\n    JS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */\n    JS_FreeValue(ctx, ns);\n    JS_FreeCString(ctx, basename);\n    return JS_UNDEFINED;\n exception:\n\n    err = JS_GetException(ctx);\n    ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED,\n                   1, (JSValueConst *)&err);\n    JS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */\n    JS_FreeValue(ctx, err);\n    JS_FreeCString(ctx, basename);\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier)\n{\n    JSAtom basename;\n    JSValue promise, resolving_funcs[2], basename_val;\n    JSValueConst args[4];\n\n    basename = JS_GetScriptOrModuleName(ctx, 0);\n    if (basename == JS_ATOM_NULL)\n        basename_val = JS_NULL;\n    else\n        basename_val = JS_AtomToValue(ctx, basename);\n    JS_FreeAtom(ctx, basename);\n    if (JS_IsException(basename_val))\n        return basename_val;\n    \n    promise = JS_NewPromiseCapability(ctx, resolving_funcs);\n    if (JS_IsException(promise)) {\n        JS_FreeValue(ctx, basename_val);\n        return promise;\n    }\n\n    args[0] = resolving_funcs[0];\n    args[1] = resolving_funcs[1];\n    args[2] = basename_val;\n    args[3] = specifier;\n    \n    JS_EnqueueJob(ctx, js_dynamic_import_job, 4, args);\n\n    JS_FreeValue(ctx, basename_val);\n    JS_FreeValue(ctx, resolving_funcs[0]);\n    JS_FreeValue(ctx, resolving_funcs[1]);\n    return promise;\n}\n\n/* Run the <eval> function of the module and of all its requested\n   modules. */\nstatic JSValue js_evaluate_module(JSContext *ctx, JSModuleDef *m)\n{\n    JSModuleDef *m1;\n    int i;\n    JSValue ret_val;\n\n    if (m->eval_mark)\n        return JS_UNDEFINED; /* avoid cycles */\n\n    if (m->evaluated) {\n        /* if the module was already evaluated, rethrow the exception\n           it raised */\n        if (m->eval_has_exception) {\n            return JS_Throw(ctx, JS_DupValue(ctx, m->eval_exception));\n        } else {\n            return JS_UNDEFINED;\n        }\n    }\n\n    m->eval_mark = TRUE;\n\n    for(i = 0; i < m->req_module_entries_count; i++) {\n        JSReqModuleEntry *rme = &m->req_module_entries[i];\n        m1 = rme->module;\n        if (!m1->eval_mark) {\n            ret_val = js_evaluate_module(ctx, m1);\n            if (JS_IsException(ret_val)) {\n                m->eval_mark = FALSE;\n                return ret_val;\n            }\n            JS_FreeValue(ctx, ret_val);\n        }\n    }\n\n    if (m->init_func) {\n        /* C module init */\n        if (m->init_func(ctx, m) < 0)\n            ret_val = JS_EXCEPTION;\n        else\n            ret_val = JS_UNDEFINED;\n    } else {\n        ret_val = JS_CallFree(ctx, m->func_obj, JS_UNDEFINED, 0, NULL);\n        m->func_obj = JS_UNDEFINED;\n    }\n    if (JS_IsException(ret_val)) {\n        /* save the thrown exception value */\n        m->eval_has_exception = TRUE;\n        m->eval_exception = JS_DupValue(ctx, ctx->rt->current_exception);\n    }\n    m->eval_mark = FALSE;\n    m->evaluated = TRUE;\n    return ret_val;\n}\n\nstatic __exception JSAtom js_parse_from_clause(JSParseState *s)\n{\n    JSAtom module_name;\n    if (!token_is_pseudo_keyword(s, JS_ATOM_from)) {\n        js_parse_error(s, \"from clause expected\");\n        return JS_ATOM_NULL;\n    }\n    if (next_token(s))\n        return JS_ATOM_NULL;\n    if (s->token.val != TOK_STRING) {\n        js_parse_error(s, \"string expected\");\n        return JS_ATOM_NULL;\n    }\n    module_name = JS_ValueToAtom(s->ctx, s->token.u.str.str);\n    if (module_name == JS_ATOM_NULL)\n        return JS_ATOM_NULL;\n    if (next_token(s)) {\n        JS_FreeAtom(s->ctx, module_name);\n        return JS_ATOM_NULL;\n    }\n    return module_name;\n}\n\nstatic __exception int js_parse_export(JSParseState *s)\n{\n    JSContext *ctx = s->ctx;\n    JSModuleDef *m = s->cur_func->module;\n    JSAtom local_name, export_name;\n    int first_export, idx, i, tok;\n    JSAtom module_name;\n    JSExportEntry *me;\n\n    if (next_token(s))\n        return -1;\n\n    tok = s->token.val;\n    if (tok == TOK_CLASS) {\n        return js_parse_class(s, FALSE, JS_PARSE_EXPORT_NAMED);\n    } else if (tok == TOK_FUNCTION ||\n               (token_is_pseudo_keyword(s, JS_ATOM_async) &&\n                peek_token(s, TRUE) == TOK_FUNCTION)) {\n        return js_parse_function_decl2(s, JS_PARSE_FUNC_STATEMENT,\n                                       JS_FUNC_NORMAL, JS_ATOM_NULL,\n                                       s->token.ptr, s->token.line_num,\n                                       JS_PARSE_EXPORT_NAMED, NULL);\n    }\n\n    if (next_token(s))\n        return -1;\n\n    switch(tok) {\n    case '{':\n        first_export = m->export_entries_count;\n        while (s->token.val != '}') {\n            if (!token_is_ident(s->token.val)) {\n                js_parse_error(s, \"identifier expected\");\n                return -1;\n            }\n            local_name = JS_DupAtom(ctx, s->token.u.ident.atom);\n            export_name = JS_ATOM_NULL;\n            if (next_token(s))\n                goto fail;\n            if (token_is_pseudo_keyword(s, JS_ATOM_as)) {\n                if (next_token(s))\n                    goto fail;\n                if (!token_is_ident(s->token.val)) {\n                    js_parse_error(s, \"identifier expected\");\n                    goto fail;\n                }\n                export_name = JS_DupAtom(ctx, s->token.u.ident.atom);\n                if (next_token(s)) {\n                fail:\n                    JS_FreeAtom(ctx, local_name);\n                fail1:\n                    JS_FreeAtom(ctx, export_name);\n                    return -1;\n                }\n            } else {\n                export_name = JS_DupAtom(ctx, local_name);\n            }\n            me = add_export_entry(s, m, local_name, export_name,\n                                  JS_EXPORT_TYPE_LOCAL);\n            JS_FreeAtom(ctx, local_name);\n            JS_FreeAtom(ctx, export_name);\n            if (!me)\n                return -1;\n            if (s->token.val != ',')\n                break;\n            if (next_token(s))\n                return -1;\n        }\n        if (js_parse_expect(s, '}'))\n            return -1;\n        if (token_is_pseudo_keyword(s, JS_ATOM_from)) {\n            module_name = js_parse_from_clause(s);\n            if (module_name == JS_ATOM_NULL)\n                return -1;\n            idx = add_req_module_entry(ctx, m, module_name);\n            JS_FreeAtom(ctx, module_name);\n            if (idx < 0)\n                return -1;\n            for(i = first_export; i < m->export_entries_count; i++) {\n                me = &m->export_entries[i];\n                me->export_type = JS_EXPORT_TYPE_INDIRECT;\n                me->u.req_module_idx = idx;\n            }\n        }\n        break;\n    case '*':\n        if (token_is_pseudo_keyword(s, JS_ATOM_as)) {\n            /* export ns from */\n            if (next_token(s))\n                return -1;\n            if (!token_is_ident(s->token.val)) {\n                js_parse_error(s, \"identifier expected\");\n                return -1;\n            }\n            export_name = JS_DupAtom(ctx, s->token.u.ident.atom);\n            if (next_token(s))\n                goto fail1;\n            module_name = js_parse_from_clause(s);\n            if (module_name == JS_ATOM_NULL)\n                goto fail1;\n            idx = add_req_module_entry(ctx, m, module_name);\n            JS_FreeAtom(ctx, module_name);\n            if (idx < 0)\n                goto fail1;\n            me = add_export_entry(s, m, JS_ATOM__star_, export_name,\n                                  JS_EXPORT_TYPE_INDIRECT);\n            JS_FreeAtom(ctx, export_name);\n            if (!me)\n                return -1;\n            me->u.req_module_idx = idx;\n        } else {\n            module_name = js_parse_from_clause(s);\n            if (module_name == JS_ATOM_NULL)\n                return -1;\n            idx = add_req_module_entry(ctx, m, module_name);\n            JS_FreeAtom(ctx, module_name);\n            if (idx < 0)\n                return -1;\n            if (add_star_export_entry(ctx, m, idx) < 0)\n                return -1;\n        }\n        break;\n    case TOK_DEFAULT:\n        if (s->token.val == TOK_CLASS) {\n            return js_parse_class(s, FALSE, JS_PARSE_EXPORT_DEFAULT);\n        } else if (s->token.val == TOK_FUNCTION ||\n                   (token_is_pseudo_keyword(s, JS_ATOM_async) &&\n                    peek_token(s, TRUE) == TOK_FUNCTION)) {\n            return js_parse_function_decl2(s, JS_PARSE_FUNC_STATEMENT,\n                                           JS_FUNC_NORMAL, JS_ATOM_NULL,\n                                           s->token.ptr, s->token.line_num,\n                                           JS_PARSE_EXPORT_DEFAULT, NULL);\n        } else {\n            if (js_parse_assign_expr(s))\n                return -1;\n        }\n        /* set the name of anonymous functions */\n        set_object_name(s, JS_ATOM_default);\n\n        /* store the value in the _default_ global variable and export\n           it */\n        local_name = JS_ATOM__default_;\n        if (define_var(s, s->cur_func, local_name, JS_VAR_DEF_LET) < 0)\n            return -1;\n        emit_op(s, OP_scope_put_var_init);\n        emit_atom(s, local_name);\n        emit_u16(s, 0);\n\n        if (!add_export_entry(s, m, local_name, JS_ATOM_default,\n                              JS_EXPORT_TYPE_LOCAL))\n            return -1;\n        break;\n    case TOK_VAR:\n    case TOK_LET:\n    case TOK_CONST:\n        return js_parse_var(s, TRUE, tok, TRUE);\n    default:\n        return js_parse_error(s, \"invalid export syntax\");\n    }\n    return js_parse_expect_semi(s);\n}\n\nstatic int add_closure_var(JSContext *ctx, JSFunctionDef *s,\n                           BOOL is_local, BOOL is_arg,\n                           int var_idx, JSAtom var_name,\n                           BOOL is_const, BOOL is_lexical,\n                           JSVarKindEnum var_kind);\n\nstatic int add_import(JSParseState *s, JSModuleDef *m,\n                      JSAtom local_name, JSAtom import_name)\n{\n    JSContext *ctx = s->ctx;\n    int i, var_idx;\n    JSImportEntry *mi;\n    BOOL is_local;\n\n    if (local_name == JS_ATOM_arguments || local_name == JS_ATOM_eval)\n        return js_parse_error(s, \"invalid import binding\");\n\n    if (local_name != JS_ATOM_default) {\n        for (i = 0; i < s->cur_func->closure_var_count; i++) {\n            if (s->cur_func->closure_var[i].var_name == local_name)\n                return js_parse_error(s, \"duplicate import binding\");\n        }\n    }\n\n    is_local = (import_name == JS_ATOM__star_);\n    var_idx = add_closure_var(ctx, s->cur_func, is_local, FALSE,\n                              m->import_entries_count,\n                              local_name, TRUE, TRUE, FALSE);\n    if (var_idx < 0)\n        return -1;\n    if (js_resize_array(ctx, (void **)&m->import_entries,\n                        sizeof(JSImportEntry),\n                        &m->import_entries_size,\n                        m->import_entries_count + 1))\n        return -1;\n    mi = &m->import_entries[m->import_entries_count++];\n    mi->import_name = JS_DupAtom(ctx, import_name);\n    mi->var_idx = var_idx;\n    return 0;\n}\n\nstatic __exception int js_parse_import(JSParseState *s)\n{\n    JSContext *ctx = s->ctx;\n    JSModuleDef *m = s->cur_func->module;\n    JSAtom local_name, import_name, module_name;\n    int first_import, i, idx;\n\n    if (next_token(s))\n        return -1;\n\n    first_import = m->import_entries_count;\n    if (s->token.val == TOK_STRING) {\n        module_name = JS_ValueToAtom(ctx, s->token.u.str.str);\n        if (module_name == JS_ATOM_NULL)\n            return -1;\n        if (next_token(s)) {\n            JS_FreeAtom(ctx, module_name);\n            return -1;\n        }\n    } else {\n        if (s->token.val == TOK_IDENT) {\n            if (s->token.u.ident.is_reserved) {\n                return js_parse_error_reserved_identifier(s);\n            }\n            /* \"default\" import */\n            local_name = JS_DupAtom(ctx, s->token.u.ident.atom);\n            import_name = JS_ATOM_default;\n            if (next_token(s))\n                goto fail;\n            if (add_import(s, m, local_name, import_name))\n                goto fail;\n            JS_FreeAtom(ctx, local_name);\n\n            if (s->token.val != ',')\n                goto end_import_clause;\n            if (next_token(s))\n                return -1;\n        }\n\n        if (s->token.val == '*') {\n            /* name space import */\n            if (next_token(s))\n                return -1;\n            if (!token_is_pseudo_keyword(s, JS_ATOM_as))\n                return js_parse_error(s, \"expecting 'as'\");\n            if (next_token(s))\n                return -1;\n            if (!token_is_ident(s->token.val)) {\n                js_parse_error(s, \"identifier expected\");\n                return -1;\n            }\n            local_name = JS_DupAtom(ctx, s->token.u.ident.atom);\n            import_name = JS_ATOM__star_;\n            if (next_token(s))\n                goto fail;\n            if (add_import(s, m, local_name, import_name))\n                goto fail;\n            JS_FreeAtom(ctx, local_name);\n        } else if (s->token.val == '{') {\n            if (next_token(s))\n                return -1;\n\n            while (s->token.val != '}') {\n                if (!token_is_ident(s->token.val)) {\n                    js_parse_error(s, \"identifier expected\");\n                    return -1;\n                }\n                import_name = JS_DupAtom(ctx, s->token.u.ident.atom);\n                local_name = JS_ATOM_NULL;\n                if (next_token(s))\n                    goto fail;\n                if (token_is_pseudo_keyword(s, JS_ATOM_as)) {\n                    if (next_token(s))\n                        goto fail;\n                    if (!token_is_ident(s->token.val)) {\n                        js_parse_error(s, \"identifier expected\");\n                        goto fail;\n                    }\n                    local_name = JS_DupAtom(ctx, s->token.u.ident.atom);\n                    if (next_token(s)) {\n                    fail:\n                        JS_FreeAtom(ctx, local_name);\n                        JS_FreeAtom(ctx, import_name);\n                        return -1;\n                    }\n                } else {\n                    local_name = JS_DupAtom(ctx, import_name);\n                }\n                if (add_import(s, m, local_name, import_name))\n                    goto fail;\n                JS_FreeAtom(ctx, local_name);\n                JS_FreeAtom(ctx, import_name);\n                if (s->token.val != ',')\n                    break;\n                if (next_token(s))\n                    return -1;\n            }\n            if (js_parse_expect(s, '}'))\n                return -1;\n        }\n    end_import_clause:\n        module_name = js_parse_from_clause(s);\n        if (module_name == JS_ATOM_NULL)\n            return -1;\n    }\n    idx = add_req_module_entry(ctx, m, module_name);\n    JS_FreeAtom(ctx, module_name);\n    if (idx < 0)\n        return -1;\n    for(i = first_import; i < m->import_entries_count; i++)\n        m->import_entries[i].req_module_idx = idx;\n\n    return js_parse_expect_semi(s);\n}\n\nstatic __exception int js_parse_source_element(JSParseState *s)\n{\n    JSFunctionDef *fd = s->cur_func;\n    int tok;\n    \n    if (s->token.val == TOK_FUNCTION ||\n        (token_is_pseudo_keyword(s, JS_ATOM_async) &&\n         peek_token(s, TRUE) == TOK_FUNCTION)) {\n        if (js_parse_function_decl(s, JS_PARSE_FUNC_STATEMENT,\n                                   JS_FUNC_NORMAL, JS_ATOM_NULL,\n                                   s->token.ptr, s->token.line_num))\n            return -1;\n    } else if (s->token.val == TOK_EXPORT && fd->module) {\n        if (js_parse_export(s))\n            return -1;\n    } else if (s->token.val == TOK_IMPORT && fd->module &&\n               ((tok = peek_token(s, FALSE)) != '(' && tok != '.'))  {\n        /* the peek_token is needed to avoid confusion with ImportCall\n           (dynamic import) or import.meta */\n        if (js_parse_import(s))\n            return -1;\n    } else {\n        if (js_parse_statement_or_decl(s, DECL_MASK_ALL))\n            return -1;\n    }\n    return 0;\n}\n\nstatic JSFunctionDef *js_new_function_def(JSContext *ctx,\n                                          JSFunctionDef *parent,\n                                          BOOL is_eval,\n                                          BOOL is_func_expr,\n                                          const char *filename, int line_num)\n{\n    JSFunctionDef *fd;\n\n    fd = js_mallocz(ctx, sizeof(*fd));\n    if (!fd)\n        return NULL;\n\n    fd->ctx = ctx;\n    init_list_head(&fd->child_list);\n\n    /* insert in parent list */\n    fd->parent = parent;\n    fd->parent_cpool_idx = -1;\n    if (parent) {\n        list_add_tail(&fd->link, &parent->child_list);\n        fd->js_mode = parent->js_mode;\n        fd->parent_scope_level = parent->scope_level;\n    }\n\n    fd->is_eval = is_eval;\n    fd->is_func_expr = is_func_expr;\n    js_dbuf_init(ctx, &fd->byte_code);\n    fd->last_opcode_pos = -1;\n    fd->func_name = JS_ATOM_NULL;\n    fd->var_object_idx = -1;\n    fd->arg_var_object_idx = -1;\n    fd->arguments_var_idx = -1;\n    fd->arguments_arg_idx = -1;\n    fd->func_var_idx = -1;\n    fd->eval_ret_idx = -1;\n    fd->this_var_idx = -1;\n    fd->new_target_var_idx = -1;\n    fd->this_active_func_var_idx = -1;\n    fd->home_object_var_idx = -1;\n\n    /* XXX: should distinguish arg, var and var object and body scopes */\n    fd->scopes = fd->def_scope_array;\n    fd->scope_size = countof(fd->def_scope_array);\n    fd->scope_count = 1;\n    fd->scopes[0].first = -1;\n    fd->scopes[0].parent = -1;\n    fd->scope_level = 0;  /* 0: var/arg scope */\n    fd->scope_first = -1;\n    fd->body_scope = -1;\n\n    fd->filename = JS_NewAtom(ctx, filename);\n    fd->line_num = line_num;\n\n    js_dbuf_init(ctx, &fd->pc2line);\n    //fd->pc2line_last_line_num = line_num;\n    //fd->pc2line_last_pc = 0;\n    fd->last_opcode_line_num = line_num;\n\n    return fd;\n}\n\nstatic void free_bytecode_atoms(JSRuntime *rt,\n                                const uint8_t *bc_buf, int bc_len,\n                                BOOL use_short_opcodes)\n{\n    int pos, len, op;\n    JSAtom atom;\n    const JSOpCode *oi;\n    \n    pos = 0;\n    while (pos < bc_len) {\n        op = bc_buf[pos];\n        if (use_short_opcodes)\n            oi = &short_opcode_info(op);\n        else\n            oi = &opcode_info[op];\n            \n        len = oi->size;\n        switch(oi->fmt) {\n        case OP_FMT_atom:\n        case OP_FMT_atom_u8:\n        case OP_FMT_atom_u16:\n        case OP_FMT_atom_label_u8:\n        case OP_FMT_atom_label_u16:\n            atom = get_u32(bc_buf + pos + 1);\n            JS_FreeAtomRT(rt, atom);\n            break;\n        default:\n            break;\n        }\n        pos += len;\n    }\n}\n\nstatic void js_free_function_def(JSContext *ctx, JSFunctionDef *fd)\n{\n    int i;\n    struct list_head *el, *el1;\n\n    /* free the child functions */\n    list_for_each_safe(el, el1, &fd->child_list) {\n        JSFunctionDef *fd1;\n        fd1 = list_entry(el, JSFunctionDef, link);\n        js_free_function_def(ctx, fd1);\n    }\n\n    free_bytecode_atoms(ctx->rt, fd->byte_code.buf, fd->byte_code.size,\n                        fd->use_short_opcodes);\n    dbuf_free(&fd->byte_code);\n    js_free(ctx, fd->jump_slots);\n    js_free(ctx, fd->label_slots);\n    js_free(ctx, fd->line_number_slots);\n\n    for(i = 0; i < fd->cpool_count; i++) {\n        JS_FreeValue(ctx, fd->cpool[i]);\n    }\n    js_free(ctx, fd->cpool);\n\n    JS_FreeAtom(ctx, fd->func_name);\n\n    for(i = 0; i < fd->var_count; i++) {\n        JS_FreeAtom(ctx, fd->vars[i].var_name);\n    }\n    js_free(ctx, fd->vars);\n    for(i = 0; i < fd->arg_count; i++) {\n        JS_FreeAtom(ctx, fd->args[i].var_name);\n    }\n    js_free(ctx, fd->args);\n\n    for(i = 0; i < fd->global_var_count; i++) {\n        JS_FreeAtom(ctx, fd->global_vars[i].var_name);\n    }\n    js_free(ctx, fd->global_vars);\n\n    for(i = 0; i < fd->closure_var_count; i++) {\n        JSClosureVar *cv = &fd->closure_var[i];\n        JS_FreeAtom(ctx, cv->var_name);\n    }\n    js_free(ctx, fd->closure_var);\n\n    if (fd->scopes != fd->def_scope_array)\n        js_free(ctx, fd->scopes);\n\n    JS_FreeAtom(ctx, fd->filename);\n    dbuf_free(&fd->pc2line);\n\n    js_free(ctx, fd->source);\n\n    if (fd->parent) {\n        /* remove in parent list */\n        list_del(&fd->link);\n    }\n    js_free(ctx, fd);\n}\n\n#ifdef DUMP_BYTECODE\nstatic const char *skip_lines(const char *p, int n) {\n    while (n-- > 0 && *p) {\n        while (*p && *p++ != '\\n')\n            continue;\n    }\n    return p;\n}\n\nstatic void print_lines(const char *source, int line, int line1) {\n    const char *s = source;\n    const char *p = skip_lines(s, line);\n    if (*p) {\n        while (line++ < line1) {\n            p = skip_lines(s = p, 1);\n            printf(\";; %.*s\", (int)(p - s), s);\n            if (!*p) {\n                if (p[-1] != '\\n')\n                    printf(\"\\n\");\n                break;\n            }\n        }\n    }\n}\n\nstatic void dump_byte_code(JSContext *ctx, int pass,\n                           const uint8_t *tab, int len,\n                           const JSVarDef *args, int arg_count,\n                           const JSVarDef *vars, int var_count,\n                           const JSClosureVar *closure_var, int closure_var_count,\n                           const JSValue *cpool, uint32_t cpool_count,\n                           const char *source, int line_num,\n                           const LabelSlot *label_slots, JSFunctionBytecode *b)\n{\n    const JSOpCode *oi;\n    int pos, pos_next, op, size, idx, addr, line, line1, in_source;\n    uint8_t *bits = js_mallocz(ctx, len * sizeof(*bits));\n    BOOL use_short_opcodes = (b != NULL);\n\n    /* scan for jump targets */\n    for (pos = 0; pos < len; pos = pos_next) {\n        op = tab[pos];\n        if (use_short_opcodes)\n            oi = &short_opcode_info(op);\n        else\n            oi = &opcode_info[op];\n        pos_next = pos + oi->size;\n        if (op < OP_COUNT) {\n            switch (oi->fmt) {\n#if SHORT_OPCODES\n            case OP_FMT_label8:\n                pos++;\n                addr = (int8_t)tab[pos];\n                goto has_addr;\n            case OP_FMT_label16:\n                pos++;\n                addr = (int16_t)get_u16(tab + pos);\n                goto has_addr;\n#endif\n            case OP_FMT_atom_label_u8:\n            case OP_FMT_atom_label_u16:\n                pos += 4;\n                /* fall thru */\n            case OP_FMT_label:\n            case OP_FMT_label_u16:\n                pos++;\n                addr = get_u32(tab + pos);\n                goto has_addr;\n            has_addr:\n                if (pass == 1)\n                    addr = label_slots[addr].pos;\n                if (pass == 2)\n                    addr = label_slots[addr].pos2;\n                if (pass == 3)\n                    addr += pos;\n                if (addr >= 0 && addr < len)\n                    bits[addr] |= 1;\n                break;\n            }\n        }\n    }\n    in_source = 0;\n    if (source) {\n        /* Always print first line: needed if single line */\n        print_lines(source, 0, 1);\n        in_source = 1;\n    }\n    line1 = line = 1;\n    pos = 0;\n    while (pos < len) {\n        op = tab[pos];\n        if (source) {\n            if (b) {\n                line1 = find_line_num(ctx, b, pos) - line_num + 1;\n            } else if (op == OP_line_num) {\n                line1 = get_u32(tab + pos + 1) - line_num + 1;\n            }\n            if (line1 > line) {\n                if (!in_source)\n                    printf(\"\\n\");\n                in_source = 1;\n                print_lines(source, line, line1);\n                line = line1;\n                //bits[pos] |= 2;\n            }\n        }\n        if (in_source)\n            printf(\"\\n\");\n        in_source = 0;\n        if (op >= OP_COUNT) {\n            printf(\"invalid opcode (0x%02x)\\n\", op);\n            pos++;\n            continue;\n        }\n        if (use_short_opcodes)\n            oi = &short_opcode_info(op);\n        else\n            oi = &opcode_info[op];\n        size = oi->size;\n        if (pos + size > len) {\n            printf(\"truncated opcode (0x%02x)\\n\", op);\n            break;\n        }\n#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 16)\n        {\n            int i, x, x0;\n            x = x0 = printf(\"%5d \", pos);\n            for (i = 0; i < size; i++) {\n                if (i == 6) {\n                    printf(\"\\n%*s\", x = x0, \"\");\n                }\n                x += printf(\" %02X\", tab[pos + i]);\n            }\n            printf(\"%*s\", x0 + 20 - x, \"\");\n        }\n#endif\n        if (bits[pos]) {\n            printf(\"%5d:  \", pos);\n        } else {\n            printf(\"        \");\n        }\n        printf(\"%s\", oi->name);\n        pos++;\n        switch(oi->fmt) {\n        case OP_FMT_none_int:\n            printf(\" %d\", op - OP_push_0);\n            break;\n        case OP_FMT_npopx:\n            printf(\" %d\", op - OP_call0);\n            break;\n        case OP_FMT_u8:\n            printf(\" %u\", get_u8(tab + pos));\n            break;\n        case OP_FMT_i8:\n            printf(\" %d\", get_i8(tab + pos));\n            break;\n        case OP_FMT_u16:\n        case OP_FMT_npop:\n            printf(\" %u\", get_u16(tab + pos));\n            break;\n        case OP_FMT_npop_u16:\n            printf(\" %u,%u\", get_u16(tab + pos), get_u16(tab + pos + 2));\n            break;\n        case OP_FMT_i16:\n            printf(\" %d\", get_i16(tab + pos));\n            break;\n        case OP_FMT_i32:\n            printf(\" %d\", get_i32(tab + pos));\n            break;\n        case OP_FMT_u32:\n            printf(\" %u\", get_u32(tab + pos));\n            break;\n#if SHORT_OPCODES\n        case OP_FMT_label8:\n            addr = get_i8(tab + pos);\n            goto has_addr1;\n        case OP_FMT_label16:\n            addr = get_i16(tab + pos);\n            goto has_addr1;\n#endif\n        case OP_FMT_label:\n            addr = get_u32(tab + pos);\n            goto has_addr1;\n        has_addr1:\n            if (pass == 1)\n                printf(\" %u:%u\", addr, label_slots[addr].pos);\n            if (pass == 2)\n                printf(\" %u:%u\", addr, label_slots[addr].pos2);\n            if (pass == 3)\n                printf(\" %u\", addr + pos);\n            break;\n        case OP_FMT_label_u16:\n            addr = get_u32(tab + pos);\n            if (pass == 1)\n                printf(\" %u:%u\", addr, label_slots[addr].pos);\n            if (pass == 2)\n                printf(\" %u:%u\", addr, label_slots[addr].pos2);\n            if (pass == 3)\n                printf(\" %u\", addr + pos);\n            printf(\",%u\", get_u16(tab + pos + 4));\n            break;\n#if SHORT_OPCODES\n        case OP_FMT_const8:\n            idx = get_u8(tab + pos);\n            goto has_pool_idx;\n#endif\n        case OP_FMT_const:\n            idx = get_u32(tab + pos);\n            goto has_pool_idx;\n        has_pool_idx:\n            printf(\" %u: \", idx);\n            if (idx < cpool_count) {\n                JS_DumpValue(ctx, cpool[idx]);\n            }\n            break;\n        case OP_FMT_atom:\n            printf(\" \");\n            print_atom(ctx, get_u32(tab + pos));\n            break;\n        case OP_FMT_atom_u8:\n            printf(\" \");\n            print_atom(ctx, get_u32(tab + pos));\n            printf(\",%d\", get_u8(tab + pos + 4));\n            break;\n        case OP_FMT_atom_u16:\n            printf(\" \");\n            print_atom(ctx, get_u32(tab + pos));\n            printf(\",%d\", get_u16(tab + pos + 4));\n            break;\n        case OP_FMT_atom_label_u8:\n        case OP_FMT_atom_label_u16:\n            printf(\" \");\n            print_atom(ctx, get_u32(tab + pos));\n            addr = get_u32(tab + pos + 4);\n            if (pass == 1)\n                printf(\",%u:%u\", addr, label_slots[addr].pos);\n            if (pass == 2)\n                printf(\",%u:%u\", addr, label_slots[addr].pos2);\n            if (pass == 3)\n                printf(\",%u\", addr + pos + 4);\n            if (oi->fmt == OP_FMT_atom_label_u8)\n                printf(\",%u\", get_u8(tab + pos + 8));\n            else\n                printf(\",%u\", get_u16(tab + pos + 8));\n            break;\n        case OP_FMT_none_loc:\n            idx = (op - OP_get_loc0) % 4;\n            goto has_loc;\n        case OP_FMT_loc8:\n            idx = get_u8(tab + pos);\n            goto has_loc;\n        case OP_FMT_loc:\n            idx = get_u16(tab + pos);\n        has_loc:\n            printf(\" %d: \", idx);\n            if (idx < var_count) {\n                print_atom(ctx, vars[idx].var_name);\n            }\n            break;\n        case OP_FMT_none_arg:\n            idx = (op - OP_get_arg0) % 4;\n            goto has_arg;\n        case OP_FMT_arg:\n            idx = get_u16(tab + pos);\n        has_arg:\n            printf(\" %d: \", idx);\n            if (idx < arg_count) {\n                print_atom(ctx, args[idx].var_name);\n            }\n            break;\n        case OP_FMT_none_var_ref:\n            idx = (op - OP_get_var_ref0) % 4;\n            goto has_var_ref;\n        case OP_FMT_var_ref:\n            idx = get_u16(tab + pos);\n        has_var_ref:\n            printf(\" %d: \", idx);\n            if (idx < closure_var_count) {\n                print_atom(ctx, closure_var[idx].var_name);\n            }\n            break;\n        default:\n            break;\n        }\n        printf(\"\\n\");\n        pos += oi->size - 1;\n    }\n    if (source) {\n        if (!in_source)\n            printf(\"\\n\");\n        print_lines(source, line, INT32_MAX);\n    }\n    js_free(ctx, bits);\n}\n\nstatic __maybe_unused void dump_pc2line(JSContext *ctx, const uint8_t *buf, int len,\n                                                 int line_num)\n{\n    const uint8_t *p_end, *p_next, *p;\n    int pc, v;\n    unsigned int op;\n\n    if (len <= 0)\n        return;\n\n    printf(\"%5s %5s\\n\", \"PC\", \"LINE\");\n\n    p = buf;\n    p_end = buf + len;\n    pc = 0;\n    while (p < p_end) {\n        op = *p++;\n        if (op == 0) {\n            v = unicode_from_utf8(p, p_end - p, &p_next);\n            if (v < 0)\n                goto fail;\n            pc += v;\n            p = p_next;\n            v = unicode_from_utf8(p, p_end - p, &p_next);\n            if (v < 0) {\n            fail:\n                printf(\"invalid pc2line encode pos=%d\\n\", (int)(p - buf));\n                return;\n            }\n            if (!(v & 1)) {\n                v = v >> 1;\n            } else {\n                v = -(v >> 1) - 1;\n            }\n            line_num += v;\n            p = p_next;\n        } else {\n            op -= PC2LINE_OP_FIRST;\n            pc += (op / PC2LINE_RANGE);\n            line_num += (op % PC2LINE_RANGE) + PC2LINE_BASE;\n        }\n        printf(\"%5d %5d\\n\", pc, line_num);\n    }\n}\n\nstatic __maybe_unused void js_dump_function_bytecode(JSContext *ctx, JSFunctionBytecode *b)\n{\n    int i;\n    char atom_buf[ATOM_GET_STR_BUF_SIZE];\n    const char *str;\n\n    if (b->has_debug && b->debug.filename != JS_ATOM_NULL) {\n        str = JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), b->debug.filename);\n        printf(\"%s:%d: \", str, b->debug.line_num);\n    }\n\n    str = JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), b->func_name);\n    printf(\"function: %s%s\\n\", &\"*\"[b->func_kind != JS_FUNC_GENERATOR], str);\n    if (b->js_mode) {\n        printf(\"  mode:\");\n        if (b->js_mode & JS_MODE_STRICT)\n            printf(\" strict\");\n#ifdef CONFIG_BIGNUM\n        if (b->js_mode & JS_MODE_MATH)\n            printf(\" math\");\n#endif\n        printf(\"\\n\");\n    }\n    if (b->arg_count && b->vardefs) {\n        printf(\"  args:\");\n        for(i = 0; i < b->arg_count; i++) {\n            printf(\" %s\", JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf),\n                                        b->vardefs[i].var_name));\n        }\n        printf(\"\\n\");\n    }\n    if (b->var_count && b->vardefs) {\n        printf(\"  locals:\\n\");\n        for(i = 0; i < b->var_count; i++) {\n            JSVarDef *vd = &b->vardefs[b->arg_count + i];\n            printf(\"%5d: %s %s\", i,\n                   vd->var_kind == JS_VAR_CATCH ? \"catch\" :\n                   (vd->var_kind == JS_VAR_FUNCTION_DECL ||\n                    vd->var_kind == JS_VAR_NEW_FUNCTION_DECL) ? \"function\" :\n                   vd->is_const ? \"const\" :\n                   vd->is_lexical ? \"let\" : \"var\",\n                   JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), vd->var_name));\n            if (vd->scope_level)\n                printf(\" [level:%d next:%d]\", vd->scope_level, vd->scope_next);\n            printf(\"\\n\");\n        }\n    }\n    if (b->closure_var_count) {\n        printf(\"  closure vars:\\n\");\n        for(i = 0; i < b->closure_var_count; i++) {\n            JSClosureVar *cv = &b->closure_var[i];\n            printf(\"%5d: %s %s:%s%d %s\\n\", i,\n                   JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), cv->var_name),\n                   cv->is_local ? \"local\" : \"parent\",\n                   cv->is_arg ? \"arg\" : \"loc\", cv->var_idx,\n                   cv->is_const ? \"const\" :\n                   cv->is_lexical ? \"let\" : \"var\");\n        }\n    }\n    printf(\"  stack_size: %d\\n\", b->stack_size);\n    printf(\"  opcodes:\\n\");\n    dump_byte_code(ctx, 3, b->byte_code_buf, b->byte_code_len,\n                   b->vardefs, b->arg_count,\n                   b->vardefs ? b->vardefs + b->arg_count : NULL, b->var_count,\n                   b->closure_var, b->closure_var_count,\n                   b->cpool, b->cpool_count,\n                   b->has_debug ? b->debug.source : NULL,\n                   b->has_debug ? b->debug.line_num : -1, NULL, b);\n#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 32)\n    if (b->has_debug)\n        dump_pc2line(ctx, b->debug.pc2line_buf, b->debug.pc2line_len, b->debug.line_num);\n#endif\n    printf(\"\\n\");\n}\n#endif\n\nstatic int add_closure_var(JSContext *ctx, JSFunctionDef *s,\n                           BOOL is_local, BOOL is_arg,\n                           int var_idx, JSAtom var_name,\n                           BOOL is_const, BOOL is_lexical,\n                           JSVarKindEnum var_kind)\n{\n    JSClosureVar *cv;\n\n    /* the closure variable indexes are currently stored on 16 bits */\n    if (s->closure_var_count >= JS_MAX_LOCAL_VARS) {\n        JS_ThrowInternalError(ctx, \"too many closure variables\");\n        return -1;\n    }\n\n    if (js_resize_array(ctx, (void **)&s->closure_var,\n                        sizeof(s->closure_var[0]),\n                        &s->closure_var_size, s->closure_var_count + 1))\n        return -1;\n    cv = &s->closure_var[s->closure_var_count++];\n    cv->is_local = is_local;\n    cv->is_arg = is_arg;\n    cv->is_const = is_const;\n    cv->is_lexical = is_lexical;\n    cv->var_kind = var_kind;\n    cv->var_idx = var_idx;\n    cv->var_name = JS_DupAtom(ctx, var_name);\n    return s->closure_var_count - 1;\n}\n\nstatic int find_closure_var(JSContext *ctx, JSFunctionDef *s,\n                            JSAtom var_name)\n{\n    int i;\n    for(i = 0; i < s->closure_var_count; i++) {\n        JSClosureVar *cv = &s->closure_var[i];\n        if (cv->var_name == var_name)\n            return i;\n    }\n    return -1;\n}\n\n/* 'fd' must be a parent of 's'. Create in 's' a closure referencing a\n   local variable (is_local = TRUE) or a closure (is_local = FALSE) in\n   'fd' */\nstatic int get_closure_var2(JSContext *ctx, JSFunctionDef *s,\n                            JSFunctionDef *fd, BOOL is_local,\n                            BOOL is_arg, int var_idx, JSAtom var_name,\n                            BOOL is_const, BOOL is_lexical,\n                            JSVarKindEnum var_kind)\n{\n    int i;\n\n    if (fd != s->parent) {\n        var_idx = get_closure_var2(ctx, s->parent, fd, is_local,\n                                   is_arg, var_idx, var_name,\n                                   is_const, is_lexical, var_kind);\n        if (var_idx < 0)\n            return -1;\n        is_local = FALSE;\n    }\n    for(i = 0; i < s->closure_var_count; i++) {\n        JSClosureVar *cv = &s->closure_var[i];\n        if (cv->var_idx == var_idx && cv->is_arg == is_arg &&\n            cv->is_local == is_local)\n            return i;\n    }\n    return add_closure_var(ctx, s, is_local, is_arg, var_idx, var_name,\n                           is_const, is_lexical, var_kind);\n}\n\nstatic int get_closure_var(JSContext *ctx, JSFunctionDef *s,\n                           JSFunctionDef *fd, BOOL is_arg,\n                           int var_idx, JSAtom var_name,\n                           BOOL is_const, BOOL is_lexical,\n                           JSVarKindEnum var_kind)\n{\n    return get_closure_var2(ctx, s, fd, TRUE, is_arg,\n                            var_idx, var_name, is_const, is_lexical,\n                            var_kind);\n}\n\nstatic int get_with_scope_opcode(int op)\n{\n    if (op == OP_scope_get_var_undef)\n        return OP_with_get_var;\n    else\n        return OP_with_get_var + (op - OP_scope_get_var);\n}\n\nstatic BOOL can_opt_put_ref_value(const uint8_t *bc_buf, int pos)\n{\n    int opcode = bc_buf[pos];\n    return (bc_buf[pos + 1] == OP_put_ref_value &&\n            (opcode == OP_insert3 ||\n             opcode == OP_perm4 ||\n             opcode == OP_nop ||\n             opcode == OP_rot3l));\n}\n\nstatic BOOL can_opt_put_global_ref_value(const uint8_t *bc_buf, int pos)\n{\n    int opcode = bc_buf[pos];\n    return (bc_buf[pos + 1] == OP_put_ref_value &&\n            (opcode == OP_insert3 ||\n             opcode == OP_perm4 ||\n             opcode == OP_nop ||\n             opcode == OP_rot3l));\n}\n\nstatic int optimize_scope_make_ref(JSContext *ctx, JSFunctionDef *s,\n                                   DynBuf *bc, uint8_t *bc_buf,\n                                   LabelSlot *ls, int pos_next,\n                                   int get_op, int var_idx)\n{\n    int label_pos, end_pos, pos;\n\n    /* XXX: should optimize `loc(a) += expr` as `expr add_loc(a)`\n       but only if expr does not modify `a`.\n       should scan the code between pos_next and label_pos\n       for operations that can potentially change `a`:\n       OP_scope_make_ref(a), function calls, jumps and gosub.\n     */\n    /* replace the reference get/put with normal variable\n       accesses */\n    if (bc_buf[pos_next] == OP_get_ref_value) {\n        dbuf_putc(bc, get_op);\n        dbuf_put_u16(bc, var_idx);\n        pos_next++;\n    }\n    /* remove the OP_label to make room for replacement */\n    /* label should have a refcount of 0 anyway */\n    /* XXX: should avoid this patch by inserting nops in phase 1 */\n    label_pos = ls->pos;\n    pos = label_pos - 5;\n    assert(bc_buf[pos] == OP_label);\n    /* label points to an instruction pair:\n       - insert3 / put_ref_value\n       - perm4 / put_ref_value\n       - rot3l / put_ref_value\n       - nop / put_ref_value\n     */\n    end_pos = label_pos + 2;\n    if (bc_buf[label_pos] == OP_insert3)\n        bc_buf[pos++] = OP_dup;\n    bc_buf[pos] = get_op + 1;\n    put_u16(bc_buf + pos + 1, var_idx);\n    pos += 3;\n    /* pad with OP_nop */\n    while (pos < end_pos)\n        bc_buf[pos++] = OP_nop;\n    return pos_next;\n}\n\nstatic int optimize_scope_make_global_ref(JSContext *ctx, JSFunctionDef *s,\n                                          DynBuf *bc, uint8_t *bc_buf,\n                                          LabelSlot *ls, int pos_next,\n                                          JSAtom var_name)\n{\n    int label_pos, end_pos, pos, op;\n    BOOL is_strict;\n    is_strict = ((s->js_mode & JS_MODE_STRICT) != 0);\n\n    /* replace the reference get/put with normal variable\n       accesses */\n    if (is_strict) {\n        /* need to check if the variable exists before evaluating the right\n           expression */\n        /* XXX: need an extra OP_true if destructuring an array */\n        dbuf_putc(bc, OP_check_var);\n        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n    } else {\n        /* XXX: need 2 extra OP_true if destructuring an array */\n    }\n    if (bc_buf[pos_next] == OP_get_ref_value) {\n        dbuf_putc(bc, OP_get_var);\n        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n        pos_next++;\n    }\n    /* remove the OP_label to make room for replacement */\n    /* label should have a refcount of 0 anyway */\n    /* XXX: should have emitted several OP_nop to avoid this kludge */\n    label_pos = ls->pos;\n    pos = label_pos - 5;\n    assert(bc_buf[pos] == OP_label);\n    end_pos = label_pos + 2;\n    op = bc_buf[label_pos];\n    if (is_strict) {\n        if (op != OP_nop) {\n            switch(op) {\n            case OP_insert3:\n                op = OP_insert2;\n                break;\n            case OP_perm4:\n                op = OP_perm3;\n                break;\n            case OP_rot3l:\n                op = OP_swap;\n                break;\n            default:\n                abort();\n            }\n            bc_buf[pos++] = op;\n        }\n    } else {\n        if (op == OP_insert3)\n            bc_buf[pos++] = OP_dup;\n    }\n    if (is_strict) {\n        bc_buf[pos] = OP_put_var_strict;\n        /* XXX: need 1 extra OP_drop if destructuring an array */\n    } else {\n        bc_buf[pos] = OP_put_var;\n        /* XXX: need 2 extra OP_drop if destructuring an array */\n    }\n    put_u32(bc_buf + pos + 1, JS_DupAtom(ctx, var_name));\n    pos += 5;\n    /* pad with OP_nop */\n    while (pos < end_pos)\n        bc_buf[pos++] = OP_nop;\n    return pos_next;\n}\n\nstatic int add_var_this(JSContext *ctx, JSFunctionDef *fd)\n{\n    int idx;\n    idx = add_var(ctx, fd, JS_ATOM_this);\n    if (idx >= 0 && fd->is_derived_class_constructor) {\n        JSVarDef *vd = &fd->vars[idx];\n        /* XXX: should have is_this flag or var type */\n        vd->is_lexical = 1; /* used to trigger 'uninitialized' checks\n                               in a derived class constructor */\n    }\n    return idx;\n}\n\nstatic int resolve_pseudo_var(JSContext *ctx, JSFunctionDef *s,\n                               JSAtom var_name)\n{\n    int var_idx;\n\n    if (!s->has_this_binding)\n        return -1;\n    switch(var_name) {\n    case JS_ATOM_home_object:\n        /* 'home_object' pseudo variable */\n        if (s->home_object_var_idx < 0)\n            s->home_object_var_idx = add_var(ctx, s, var_name);\n        var_idx = s->home_object_var_idx;\n        break;\n    case JS_ATOM_this_active_func:\n        /* 'this.active_func' pseudo variable */\n        if (s->this_active_func_var_idx < 0)\n            s->this_active_func_var_idx = add_var(ctx, s, var_name);\n        var_idx = s->this_active_func_var_idx;\n        break;\n    case JS_ATOM_new_target:\n        /* 'new.target' pseudo variable */\n        if (s->new_target_var_idx < 0)\n            s->new_target_var_idx = add_var(ctx, s, var_name);\n        var_idx = s->new_target_var_idx;\n        break;\n    case JS_ATOM_this:\n        /* 'this' pseudo variable */\n        if (s->this_var_idx < 0)\n            s->this_var_idx = add_var_this(ctx, s);\n        var_idx = s->this_var_idx;\n        break;\n    default:\n        var_idx = -1;\n        break;\n    }\n    return var_idx;\n}\n\n/* test if 'var_name' is in the variable object on the stack. If is it\n   the case, handle it and jump to 'label_done' */\nstatic void var_object_test(JSContext *ctx, JSFunctionDef *s,\n                            JSAtom var_name, int op, DynBuf *bc,\n                            int *plabel_done, BOOL is_with)\n{\n    dbuf_putc(bc, get_with_scope_opcode(op));\n    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n    *plabel_done = new_label_fd(s, *plabel_done);\n    dbuf_put_u32(bc, *plabel_done);\n    dbuf_putc(bc, is_with);\n    update_label(s, *plabel_done, 1);\n    s->jump_size++;\n}\n    \n/* return the position of the next opcode */\nstatic int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,\n                             JSAtom var_name, int scope_level, int op,\n                             DynBuf *bc, uint8_t *bc_buf,\n                             LabelSlot *ls, int pos_next)\n{\n    int idx, var_idx, is_put;\n    int label_done;\n    JSFunctionDef *fd;\n    JSVarDef *vd;\n    BOOL is_pseudo_var, is_arg_scope;\n\n    label_done = -1;\n\n    /* XXX: could be simpler to use a specific function to\n       resolve the pseudo variables */\n    is_pseudo_var = (var_name == JS_ATOM_home_object ||\n                     var_name == JS_ATOM_this_active_func ||\n                     var_name == JS_ATOM_new_target ||\n                     var_name == JS_ATOM_this);\n\n    /* resolve local scoped variables */\n    var_idx = -1;\n    for (idx = s->scopes[scope_level].first; idx >= 0;) {\n        vd = &s->vars[idx];\n        if (vd->var_name == var_name) {\n            if (op == OP_scope_put_var || op == OP_scope_make_ref) {\n                if (vd->is_const) {\n                    dbuf_putc(bc, OP_throw_error);\n                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n                    dbuf_putc(bc, JS_THROW_VAR_RO);\n                    goto done;\n                }\n            }\n            var_idx = idx;\n            break;\n        } else\n        if (vd->var_name == JS_ATOM__with_ && !is_pseudo_var) {\n            dbuf_putc(bc, OP_get_loc);\n            dbuf_put_u16(bc, idx);\n            var_object_test(ctx, s, var_name, op, bc, &label_done, 1);\n        }\n        idx = vd->scope_next;\n    }\n    is_arg_scope = (idx == ARG_SCOPE_END);\n    if (var_idx < 0) {\n        /* argument scope: variables are not visible but pseudo\n           variables are visible */\n        if (!is_arg_scope) {\n            var_idx = find_var(ctx, s, var_name);\n        }\n\n        if (var_idx < 0 && is_pseudo_var)\n            var_idx = resolve_pseudo_var(ctx, s, var_name);\n\n        if (var_idx < 0 && var_name == JS_ATOM_arguments &&\n            s->has_arguments_binding) {\n            /* 'arguments' pseudo variable */\n            var_idx = add_arguments_var(ctx, s);\n        }\n        if (var_idx < 0 && s->is_func_expr && var_name == s->func_name) {\n            /* add a new variable with the function name */\n            var_idx = add_func_var(ctx, s, var_name);\n        }\n    }\n    if (var_idx >= 0) {\n        if ((op == OP_scope_put_var || op == OP_scope_make_ref) &&\n            !(var_idx & ARGUMENT_VAR_OFFSET) &&\n            s->vars[var_idx].is_const) {\n            /* only happens when assigning a function expression name\n               in strict mode */\n            dbuf_putc(bc, OP_throw_error);\n            dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n            dbuf_putc(bc, JS_THROW_VAR_RO);\n            goto done;\n        }\n        /* OP_scope_put_var_init is only used to initialize a\n           lexical variable, so it is never used in a with or var object. It\n           can be used with a closure (module global variable case). */\n        switch (op) {\n        case OP_scope_make_ref:\n            if (!(var_idx & ARGUMENT_VAR_OFFSET) &&\n                s->vars[var_idx].var_kind == JS_VAR_FUNCTION_NAME) {\n                /* Create a dummy object reference for the func_var */\n                dbuf_putc(bc, OP_object);\n                dbuf_putc(bc, OP_get_loc);\n                dbuf_put_u16(bc, var_idx);\n                dbuf_putc(bc, OP_define_field);\n                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n                dbuf_putc(bc, OP_push_atom_value);\n                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n            } else\n            if (label_done == -1 && can_opt_put_ref_value(bc_buf, ls->pos)) {\n                int get_op;\n                if (var_idx & ARGUMENT_VAR_OFFSET) {\n                    get_op = OP_get_arg;\n                    var_idx -= ARGUMENT_VAR_OFFSET;\n                } else {\n                    if (s->vars[var_idx].is_lexical)\n                        get_op = OP_get_loc_check;\n                    else\n                        get_op = OP_get_loc;\n                }\n                pos_next = optimize_scope_make_ref(ctx, s, bc, bc_buf, ls,\n                                                   pos_next, get_op, var_idx);\n            } else {\n                /* Create a dummy object with a named slot that is\n                   a reference to the local variable */\n                if (var_idx & ARGUMENT_VAR_OFFSET) {\n                    dbuf_putc(bc, OP_make_arg_ref);\n                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n                    dbuf_put_u16(bc, var_idx - ARGUMENT_VAR_OFFSET);\n                } else {\n                    dbuf_putc(bc, OP_make_loc_ref);\n                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n                    dbuf_put_u16(bc, var_idx);\n                }\n            }\n            break;\n        case OP_scope_get_ref:\n            dbuf_putc(bc, OP_undefined);\n            /* fall thru */\n        case OP_scope_get_var_undef:\n        case OP_scope_get_var:\n        case OP_scope_put_var:\n        case OP_scope_put_var_init:\n            is_put = (op == OP_scope_put_var || op == OP_scope_put_var_init);\n            if (var_idx & ARGUMENT_VAR_OFFSET) {\n                dbuf_putc(bc, OP_get_arg + is_put);\n                dbuf_put_u16(bc, var_idx - ARGUMENT_VAR_OFFSET);\n            } else {\n                if (is_put) {\n                    if (s->vars[var_idx].is_lexical) {\n                        if (op == OP_scope_put_var_init) {\n                            /* 'this' can only be initialized once */\n                            if (var_name == JS_ATOM_this)\n                                dbuf_putc(bc, OP_put_loc_check_init);\n                            else\n                                dbuf_putc(bc, OP_put_loc);\n                        } else {\n                            dbuf_putc(bc, OP_put_loc_check);\n                        }\n                    } else {\n                        dbuf_putc(bc, OP_put_loc);\n                    }\n                } else {\n                    if (s->vars[var_idx].is_lexical) {\n                        dbuf_putc(bc, OP_get_loc_check);\n                    } else {\n                        dbuf_putc(bc, OP_get_loc);\n                    }\n                }\n                dbuf_put_u16(bc, var_idx);\n            }\n            break;\n        case OP_scope_delete_var:\n            dbuf_putc(bc, OP_push_false);\n            break;\n        }\n        goto done;\n    }\n    /* check eval object */\n    if (!is_arg_scope && s->var_object_idx >= 0 && !is_pseudo_var) {\n        dbuf_putc(bc, OP_get_loc);\n        dbuf_put_u16(bc, s->var_object_idx);\n        var_object_test(ctx, s, var_name, op, bc, &label_done, 0);\n    }\n    /* check eval object in argument scope */\n    if (s->arg_var_object_idx >= 0 && !is_pseudo_var) {\n        dbuf_putc(bc, OP_get_loc);\n        dbuf_put_u16(bc, s->arg_var_object_idx);\n        var_object_test(ctx, s, var_name, op, bc, &label_done, 0);\n    }\n\n    /* check parent scopes */\n    for (fd = s; fd->parent;) {\n        scope_level = fd->parent_scope_level;\n        fd = fd->parent;\n        for (idx = fd->scopes[scope_level].first; idx >= 0;) {\n            vd = &fd->vars[idx];\n            if (vd->var_name == var_name) {\n                if (op == OP_scope_put_var || op == OP_scope_make_ref) {\n                    if (vd->is_const) {\n                        dbuf_putc(bc, OP_throw_error);\n                        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n                        dbuf_putc(bc, JS_THROW_VAR_RO);\n                        goto done;\n                    }\n                }\n                var_idx = idx;\n                break;\n            } else if (vd->var_name == JS_ATOM__with_ && !is_pseudo_var) {\n                vd->is_captured = 1;\n                idx = get_closure_var(ctx, s, fd, FALSE, idx, vd->var_name, FALSE, FALSE, JS_VAR_NORMAL);\n                if (idx >= 0) {\n                    dbuf_putc(bc, OP_get_var_ref);\n                    dbuf_put_u16(bc, idx);\n                    var_object_test(ctx, s, var_name, op, bc, &label_done, 1);\n                }\n            }\n            idx = vd->scope_next;\n        }\n        is_arg_scope = (idx == ARG_SCOPE_END);\n        if (var_idx >= 0)\n            break;\n        \n        if (!is_arg_scope) {\n            var_idx = find_var(ctx, fd, var_name);\n            if (var_idx >= 0)\n                break;\n        }\n        if (is_pseudo_var) {\n            var_idx = resolve_pseudo_var(ctx, fd, var_name);\n            if (var_idx >= 0)\n                break;\n        }\n        if (var_name == JS_ATOM_arguments && fd->has_arguments_binding) {\n            var_idx = add_arguments_var(ctx, fd);\n            break;\n        }\n        if (fd->is_func_expr && fd->func_name == var_name) {\n            /* add a new variable with the function name */\n            var_idx = add_func_var(ctx, fd, var_name);\n            break;\n        }\n\n        /* check eval object */\n        if (!is_arg_scope && fd->var_object_idx >= 0 && !is_pseudo_var) {\n            vd = &fd->vars[fd->var_object_idx];\n            vd->is_captured = 1;\n            idx = get_closure_var(ctx, s, fd, FALSE,\n                                  fd->var_object_idx, vd->var_name,\n                                  FALSE, FALSE, JS_VAR_NORMAL);\n            dbuf_putc(bc, OP_get_var_ref);\n            dbuf_put_u16(bc, idx);\n            var_object_test(ctx, s, var_name, op, bc, &label_done, 0);\n        }\n\n        /* check eval object in argument scope */\n        if (fd->arg_var_object_idx >= 0 && !is_pseudo_var) {\n            vd = &fd->vars[fd->arg_var_object_idx];\n            vd->is_captured = 1;\n            idx = get_closure_var(ctx, s, fd, FALSE,\n                                  fd->arg_var_object_idx, vd->var_name,\n                                  FALSE, FALSE, JS_VAR_NORMAL);\n            dbuf_putc(bc, OP_get_var_ref);\n            dbuf_put_u16(bc, idx);\n            var_object_test(ctx, s, var_name, op, bc, &label_done, 0);\n        }\n        \n        if (fd->is_eval)\n            break; /* it it necessarily the top level function */\n    }\n\n    /* check direct eval scope (in the closure of the eval function\n       which is necessarily at the top level) */\n    if (!fd)\n        fd = s;\n    if (var_idx < 0 && fd->is_eval) {\n        int idx1;\n        for (idx1 = 0; idx1 < fd->closure_var_count; idx1++) {\n            JSClosureVar *cv = &fd->closure_var[idx1];\n            if (var_name == cv->var_name) {\n                if (fd != s) {\n                    idx = get_closure_var2(ctx, s, fd,\n                                           FALSE,\n                                           cv->is_arg, idx1,\n                                           cv->var_name, cv->is_const,\n                                           cv->is_lexical, cv->var_kind);\n                } else {\n                    idx = idx1;\n                }\n                goto has_idx;\n            } else if ((cv->var_name == JS_ATOM__var_ ||\n                        cv->var_name == JS_ATOM__arg_var_ ||\n                        cv->var_name == JS_ATOM__with_) && !is_pseudo_var) {\n                int is_with = (cv->var_name == JS_ATOM__with_);\n                if (fd != s) {\n                    idx = get_closure_var2(ctx, s, fd,\n                                           FALSE,\n                                           cv->is_arg, idx1,\n                                           cv->var_name, FALSE, FALSE,\n                                           JS_VAR_NORMAL);\n                } else {\n                    idx = idx1;\n                }\n                dbuf_putc(bc, OP_get_var_ref);\n                dbuf_put_u16(bc, idx);\n                var_object_test(ctx, s, var_name, op, bc, &label_done, is_with);\n            }\n        }\n    }\n\n    if (var_idx >= 0) {\n        /* find the corresponding closure variable */\n        if (var_idx & ARGUMENT_VAR_OFFSET) {\n            fd->args[var_idx - ARGUMENT_VAR_OFFSET].is_captured = 1;\n            idx = get_closure_var(ctx, s, fd,\n                                  TRUE, var_idx - ARGUMENT_VAR_OFFSET,\n                                  var_name, FALSE, FALSE, JS_VAR_NORMAL);\n        } else {\n            fd->vars[var_idx].is_captured = 1;\n            idx = get_closure_var(ctx, s, fd,\n                                  FALSE, var_idx,\n                                  var_name,\n                                  fd->vars[var_idx].is_const,\n                                  fd->vars[var_idx].is_lexical,\n                                  fd->vars[var_idx].var_kind);\n        }\n        if (idx >= 0) {\n        has_idx:\n            if ((op == OP_scope_put_var || op == OP_scope_make_ref) &&\n                s->closure_var[idx].is_const) {\n                dbuf_putc(bc, OP_throw_error);\n                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n                dbuf_putc(bc, JS_THROW_VAR_RO);\n                goto done;\n            }\n            switch (op) {\n            case OP_scope_make_ref:\n                if (s->closure_var[idx].var_kind == JS_VAR_FUNCTION_NAME) {\n                    /* Create a dummy object reference for the func_var */\n                    dbuf_putc(bc, OP_object);\n                    dbuf_putc(bc, OP_get_var_ref);\n                    dbuf_put_u16(bc, idx);\n                    dbuf_putc(bc, OP_define_field);\n                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n                    dbuf_putc(bc, OP_push_atom_value);\n                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n                } else\n                if (label_done == -1 &&\n                    can_opt_put_ref_value(bc_buf, ls->pos)) {\n                    int get_op;\n                    if (s->closure_var[idx].is_lexical)\n                        get_op = OP_get_var_ref_check;\n                    else\n                        get_op = OP_get_var_ref;\n                    pos_next = optimize_scope_make_ref(ctx, s, bc, bc_buf, ls,\n                                                       pos_next,\n                                                       get_op, idx);\n                } else {\n                    /* Create a dummy object with a named slot that is\n                       a reference to the closure variable */\n                    dbuf_putc(bc, OP_make_var_ref_ref);\n                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n                    dbuf_put_u16(bc, idx);\n                }\n                break;\n            case OP_scope_get_ref:\n                /* XXX: should create a dummy object with a named slot that is\n                   a reference to the closure variable */\n                dbuf_putc(bc, OP_undefined);\n                /* fall thru */\n            case OP_scope_get_var_undef:\n            case OP_scope_get_var:\n            case OP_scope_put_var:\n            case OP_scope_put_var_init:\n                is_put = (op == OP_scope_put_var ||\n                          op == OP_scope_put_var_init);\n                if (is_put) {\n                    if (s->closure_var[idx].is_lexical) {\n                        if (op == OP_scope_put_var_init) {\n                            /* 'this' can only be initialized once */\n                            if (var_name == JS_ATOM_this)\n                                dbuf_putc(bc, OP_put_var_ref_check_init);\n                            else\n                                dbuf_putc(bc, OP_put_var_ref);\n                        } else {\n                            dbuf_putc(bc, OP_put_var_ref_check);\n                        }\n                    } else {\n                        dbuf_putc(bc, OP_put_var_ref);\n                    }\n                } else {\n                    if (s->closure_var[idx].is_lexical) {\n                        dbuf_putc(bc, OP_get_var_ref_check);\n                    } else {\n                        dbuf_putc(bc, OP_get_var_ref);\n                    }\n                }\n                dbuf_put_u16(bc, idx);\n                break;\n            case OP_scope_delete_var:\n                dbuf_putc(bc, OP_push_false);\n                break;\n            }\n            goto done;\n        }\n    }\n\n    /* global variable access */\n\n    switch (op) {\n    case OP_scope_make_ref:\n        if (label_done == -1 && can_opt_put_global_ref_value(bc_buf, ls->pos)) {\n            pos_next = optimize_scope_make_global_ref(ctx, s, bc, bc_buf, ls,\n                                                      pos_next, var_name);\n        } else {\n            dbuf_putc(bc, OP_make_var_ref);\n            dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n        }\n        break;\n    case OP_scope_get_ref:\n        /* XXX: should create a dummy object with a named slot that is\n           a reference to the global variable */\n        dbuf_putc(bc, OP_undefined);\n        dbuf_putc(bc, OP_get_var);\n        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n        break;\n    case OP_scope_get_var_undef:\n    case OP_scope_get_var:\n    case OP_scope_put_var:\n        dbuf_putc(bc, OP_get_var_undef + (op - OP_scope_get_var_undef));\n        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n        break;\n    case OP_scope_put_var_init:\n        dbuf_putc(bc, OP_put_var_init);\n        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n        break;\n    case OP_scope_delete_var:\n        dbuf_putc(bc, OP_delete_var);\n        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n        break;\n    }\ndone:\n    if (label_done >= 0) {\n        dbuf_putc(bc, OP_label);\n        dbuf_put_u32(bc, label_done);\n        s->label_slots[label_done].pos2 = bc->size;\n    }\n    return pos_next;\n}\n\n/* search in all scopes */\nstatic int find_private_class_field_all(JSContext *ctx, JSFunctionDef *fd,\n                                        JSAtom name, int scope_level)\n{\n    int idx;\n\n    idx = fd->scopes[scope_level].first;\n    while (idx >= 0) {\n        if (fd->vars[idx].var_name == name)\n            return idx;\n        idx = fd->vars[idx].scope_next;\n    }\n    return -1;\n}\n\nstatic void get_loc_or_ref(DynBuf *bc, BOOL is_ref, int idx)\n{\n    /* if the field is not initialized, the error is catched when\n       accessing it */\n    if (is_ref) \n        dbuf_putc(bc, OP_get_var_ref);\n    else\n        dbuf_putc(bc, OP_get_loc);\n    dbuf_put_u16(bc, idx);\n}\n\nstatic int resolve_scope_private_field1(JSContext *ctx,\n                                        BOOL *pis_ref, int *pvar_kind,\n                                        JSFunctionDef *s,\n                                        JSAtom var_name, int scope_level)\n{\n    int idx, var_kind;\n    JSFunctionDef *fd;\n    BOOL is_ref;\n    \n    fd = s;\n    is_ref = FALSE;\n    for(;;) {\n        idx = find_private_class_field_all(ctx, fd, var_name, scope_level);\n        if (idx >= 0) {\n            var_kind = fd->vars[idx].var_kind;\n            if (is_ref) {\n                idx = get_closure_var(ctx, s, fd, FALSE, idx, var_name,\n                                      TRUE, TRUE, JS_VAR_NORMAL);\n                if (idx < 0)\n                    return -1;\n            }\n            break;\n        }\n        scope_level = fd->parent_scope_level;\n        if (!fd->parent) {\n            if (fd->is_eval) {\n                /* closure of the eval function (top level) */\n                for (idx = 0; idx < fd->closure_var_count; idx++) {\n                    JSClosureVar *cv = &fd->closure_var[idx];\n                    if (cv->var_name == var_name) {\n                        var_kind = cv->var_kind;\n                        is_ref = TRUE;\n                        if (fd != s) {\n                            idx = get_closure_var2(ctx, s, fd,\n                                                   FALSE,\n                                                   cv->is_arg, idx,\n                                                   cv->var_name, cv->is_const,\n                                                   cv->is_lexical,\n                                                   cv->var_kind);\n                            if (idx < 0)\n                                return -1;\n                        }\n                        goto done;\n                    }\n                }\n            }\n            /* XXX: no line number info */\n            JS_ThrowSyntaxErrorAtom(ctx, \"undefined private field '%s'\",\n                                    var_name);\n            return -1;\n        } else {\n            fd = fd->parent;\n        }\n        is_ref = TRUE;\n    }\n done:\n    *pis_ref = is_ref;\n    *pvar_kind = var_kind;\n    return idx;\n}\n\n/* return 0 if OK or -1 if the private field could not be resolved */\nstatic int resolve_scope_private_field(JSContext *ctx, JSFunctionDef *s,\n                                       JSAtom var_name, int scope_level, int op,\n                                       DynBuf *bc)\n{\n    int idx, var_kind;\n    BOOL is_ref;\n\n    idx = resolve_scope_private_field1(ctx, &is_ref, &var_kind, s,\n                                       var_name, scope_level);\n    if (idx < 0)\n        return -1;\n    assert(var_kind != JS_VAR_NORMAL);\n    switch (op) {\n    case OP_scope_get_private_field:\n    case OP_scope_get_private_field2:\n        switch(var_kind) {\n        case JS_VAR_PRIVATE_FIELD:\n            if (op == OP_scope_get_private_field2)\n                dbuf_putc(bc, OP_dup);\n            get_loc_or_ref(bc, is_ref, idx);\n            dbuf_putc(bc, OP_get_private_field);\n            break;\n        case JS_VAR_PRIVATE_METHOD:\n            get_loc_or_ref(bc, is_ref, idx);\n            dbuf_putc(bc, OP_check_brand);\n            if (op != OP_scope_get_private_field2)\n                dbuf_putc(bc, OP_nip);\n            break;\n        case JS_VAR_PRIVATE_GETTER:\n        case JS_VAR_PRIVATE_GETTER_SETTER:\n            if (op == OP_scope_get_private_field2)\n                dbuf_putc(bc, OP_dup);\n            get_loc_or_ref(bc, is_ref, idx);\n            dbuf_putc(bc, OP_check_brand);\n            dbuf_putc(bc, OP_call_method);\n            dbuf_put_u16(bc, 0);\n            break;\n        case JS_VAR_PRIVATE_SETTER:\n            /* XXX: add clearer error message */\n            dbuf_putc(bc, OP_throw_error);\n            dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n            dbuf_putc(bc, JS_THROW_VAR_RO);\n            break;\n        default:\n            abort();\n        }\n        break;\n    case OP_scope_put_private_field:\n        switch(var_kind) {\n        case JS_VAR_PRIVATE_FIELD:\n            get_loc_or_ref(bc, is_ref, idx);\n            dbuf_putc(bc, OP_put_private_field);\n            break;\n        case JS_VAR_PRIVATE_METHOD:\n        case JS_VAR_PRIVATE_GETTER:\n            /* XXX: add clearer error message */\n            dbuf_putc(bc, OP_throw_error);\n            dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));\n            dbuf_putc(bc, JS_THROW_VAR_RO);\n            break;\n        case JS_VAR_PRIVATE_SETTER:\n        case JS_VAR_PRIVATE_GETTER_SETTER:\n            {\n                JSAtom setter_name = get_private_setter_name(ctx, var_name);\n                if (setter_name == JS_ATOM_NULL)\n                    return -1;\n                idx = resolve_scope_private_field1(ctx, &is_ref,\n                                                   &var_kind, s,\n                                                   setter_name, scope_level);\n                JS_FreeAtom(ctx, setter_name);\n                if (idx < 0)\n                    return -1;\n                assert(var_kind == JS_VAR_PRIVATE_SETTER);\n                get_loc_or_ref(bc, is_ref, idx);\n                dbuf_putc(bc, OP_swap);\n                /* obj func value */\n                dbuf_putc(bc, OP_rot3r);\n                /* value obj func */\n                dbuf_putc(bc, OP_check_brand);\n                dbuf_putc(bc, OP_rot3l);\n                /* obj func value */\n                dbuf_putc(bc, OP_call_method);\n                dbuf_put_u16(bc, 1);\n            }\n            break;\n        default:\n            abort();\n        }\n        break;\n    default:\n        abort();\n    }\n    return 0;\n}\n\nstatic void mark_eval_captured_variables(JSContext *ctx, JSFunctionDef *s,\n                                         int scope_level)\n{\n    int idx;\n    JSVarDef *vd;\n\n    for (idx = s->scopes[scope_level].first; idx >= 0;) {\n        vd = &s->vars[idx];\n        vd->is_captured = 1;\n        idx = vd->scope_next;\n    }\n}\n\n/* XXX: should handle the argument scope generically */\nstatic BOOL is_var_in_arg_scope(const JSVarDef *vd)\n{\n    return (vd->var_name == JS_ATOM_home_object ||\n            vd->var_name == JS_ATOM_this_active_func ||\n            vd->var_name == JS_ATOM_new_target ||\n            vd->var_name == JS_ATOM_this ||\n            vd->var_name == JS_ATOM__arg_var_ ||\n            vd->var_kind == JS_VAR_FUNCTION_NAME);\n}\n\nstatic void add_eval_variables(JSContext *ctx, JSFunctionDef *s)\n{\n    JSFunctionDef *fd;\n    JSVarDef *vd;\n    int i, scope_level, scope_idx;\n    BOOL has_arguments_binding, has_this_binding, is_arg_scope;\n\n    /* in non strict mode, variables are created in the caller's\n       environment object */\n    if (!s->is_eval && !(s->js_mode & JS_MODE_STRICT)) {\n        s->var_object_idx = add_var(ctx, s, JS_ATOM__var_);\n        if (s->has_parameter_expressions) {\n            /* an additional variable object is needed for the\n               argument scope */\n            s->arg_var_object_idx = add_var(ctx, s, JS_ATOM__arg_var_);\n        }\n    }\n\n    /* eval can potentially use 'arguments' so we must define it */\n    has_this_binding = s->has_this_binding;\n    if (has_this_binding) {\n        if (s->this_var_idx < 0)\n            s->this_var_idx = add_var_this(ctx, s);\n        if (s->new_target_var_idx < 0)\n            s->new_target_var_idx = add_var(ctx, s, JS_ATOM_new_target);\n        if (s->is_derived_class_constructor && s->this_active_func_var_idx < 0)\n            s->this_active_func_var_idx = add_var(ctx, s, JS_ATOM_this_active_func);\n        if (s->has_home_object && s->home_object_var_idx < 0)\n            s->home_object_var_idx = add_var(ctx, s, JS_ATOM_home_object);\n    }\n    has_arguments_binding = s->has_arguments_binding;\n    if (has_arguments_binding) {\n        add_arguments_var(ctx, s);\n        /* also add an arguments binding in the argument scope to\n           raise an error if a direct eval in the argument scope tries\n           to redefine it */\n        if (s->has_parameter_expressions && !(s->js_mode & JS_MODE_STRICT))\n            add_arguments_arg(ctx, s);\n    }\n    if (s->is_func_expr && s->func_name != JS_ATOM_NULL)\n        add_func_var(ctx, s, s->func_name);\n\n    /* eval can use all the variables of the enclosing functions, so\n       they must be all put in the closure. The closure variables are\n       ordered by scope. It works only because no closure are created\n       before. */\n    assert(s->is_eval || s->closure_var_count == 0);\n\n    /* XXX: inefficient, but eval performance is less critical */\n    fd = s;\n    for(;;) {\n        scope_level = fd->parent_scope_level;\n        fd = fd->parent;\n        if (!fd)\n            break;\n        /* add 'this' if it was not previously added */\n        if (!has_this_binding && fd->has_this_binding) {\n            if (fd->this_var_idx < 0)\n                fd->this_var_idx = add_var_this(ctx, fd);\n            if (fd->new_target_var_idx < 0)\n                fd->new_target_var_idx = add_var(ctx, fd, JS_ATOM_new_target);\n            if (fd->is_derived_class_constructor && fd->this_active_func_var_idx < 0)\n                fd->this_active_func_var_idx = add_var(ctx, fd, JS_ATOM_this_active_func);\n            if (fd->has_home_object && fd->home_object_var_idx < 0)\n                fd->home_object_var_idx = add_var(ctx, fd, JS_ATOM_home_object);\n            has_this_binding = TRUE;\n        }\n        /* add 'arguments' if it was not previously added */\n        if (!has_arguments_binding && fd->has_arguments_binding) {\n            add_arguments_var(ctx, fd);\n            has_arguments_binding = TRUE;\n        }\n        /* add function name */\n        if (fd->is_func_expr && fd->func_name != JS_ATOM_NULL)\n            add_func_var(ctx, fd, fd->func_name);\n\n        /* add lexical variables */\n        scope_idx = fd->scopes[scope_level].first;\n        while (scope_idx >= 0) {\n            vd = &fd->vars[scope_idx];\n            vd->is_captured = 1;\n            get_closure_var(ctx, s, fd, FALSE, scope_idx,\n                            vd->var_name, vd->is_const, vd->is_lexical, vd->var_kind);\n            scope_idx = vd->scope_next;\n        }\n        is_arg_scope = (scope_idx == ARG_SCOPE_END);\n        if (!is_arg_scope) {\n            /* add unscoped variables */\n            for(i = 0; i < fd->arg_count; i++) {\n                vd = &fd->args[i];\n                if (vd->var_name != JS_ATOM_NULL) {\n                    get_closure_var(ctx, s, fd,\n                                    TRUE, i, vd->var_name, FALSE, FALSE,\n                                    JS_VAR_NORMAL);\n                }\n            }\n            for(i = 0; i < fd->var_count; i++) {\n                vd = &fd->vars[i];\n                /* do not close top level last result */\n                if (vd->scope_level == 0 &&\n                    vd->var_name != JS_ATOM__ret_ &&\n                    vd->var_name != JS_ATOM_NULL) {\n                    get_closure_var(ctx, s, fd,\n                                    FALSE, i, vd->var_name, FALSE, FALSE,\n                                    JS_VAR_NORMAL);\n                }\n            }\n        } else {\n            for(i = 0; i < fd->var_count; i++) {\n                vd = &fd->vars[i];\n                /* do not close top level last result */\n                if (vd->scope_level == 0 && is_var_in_arg_scope(vd)) {\n                    get_closure_var(ctx, s, fd,\n                                    FALSE, i, vd->var_name, FALSE, FALSE,\n                                    JS_VAR_NORMAL);\n                }\n            }\n        }\n        if (fd->is_eval) {\n            int idx;\n            /* add direct eval variables (we are necessarily at the\n               top level) */\n            for (idx = 0; idx < fd->closure_var_count; idx++) {\n                JSClosureVar *cv = &fd->closure_var[idx];\n                get_closure_var2(ctx, s, fd,\n                                 FALSE, cv->is_arg,\n                                 idx, cv->var_name, cv->is_const,\n                                 cv->is_lexical, cv->var_kind);\n            }\n        }\n    }\n}\n\nstatic void set_closure_from_var(JSContext *ctx, JSClosureVar *cv,\n                                 JSVarDef *vd, int var_idx)\n{\n    cv->is_local = TRUE;\n    cv->is_arg = FALSE;\n    cv->is_const = vd->is_const;\n    cv->is_lexical = vd->is_lexical;\n    cv->var_kind = vd->var_kind;\n    cv->var_idx = var_idx;\n    cv->var_name = JS_DupAtom(ctx, vd->var_name);\n}\n\n/* for direct eval compilation: add references to the variables of the\n   calling function */\nstatic __exception int add_closure_variables(JSContext *ctx, JSFunctionDef *s,\n                                             JSFunctionBytecode *b, int scope_idx)\n{\n    int i, count;\n    JSVarDef *vd;\n    BOOL is_arg_scope;\n    \n    count = b->arg_count + b->var_count + b->closure_var_count;\n    s->closure_var = NULL;\n    s->closure_var_count = 0;\n    s->closure_var_size = count;\n    if (count == 0)\n        return 0;\n    s->closure_var = js_malloc(ctx, sizeof(s->closure_var[0]) * count);\n    if (!s->closure_var)\n        return -1;\n    /* Add lexical variables in scope at the point of evaluation */\n    for (i = scope_idx; i >= 0;) {\n        vd = &b->vardefs[b->arg_count + i];\n        if (vd->scope_level > 0) {\n            JSClosureVar *cv = &s->closure_var[s->closure_var_count++];\n            set_closure_from_var(ctx, cv, vd, i);\n        }\n        i = vd->scope_next;\n    }\n    is_arg_scope = (i == ARG_SCOPE_END);\n    if (!is_arg_scope) {\n        /* Add argument variables */\n        for(i = 0; i < b->arg_count; i++) {\n            JSClosureVar *cv = &s->closure_var[s->closure_var_count++];\n            vd = &b->vardefs[i];\n            cv->is_local = TRUE;\n            cv->is_arg = TRUE;\n            cv->is_const = FALSE;\n            cv->is_lexical = FALSE;\n            cv->var_kind = JS_VAR_NORMAL;\n            cv->var_idx = i;\n            cv->var_name = JS_DupAtom(ctx, vd->var_name);\n        }\n        /* Add local non lexical variables */\n        for(i = 0; i < b->var_count; i++) {\n            vd = &b->vardefs[b->arg_count + i];\n            if (vd->scope_level == 0 && vd->var_name != JS_ATOM__ret_) {\n                JSClosureVar *cv = &s->closure_var[s->closure_var_count++];\n                set_closure_from_var(ctx, cv, vd, i);\n            }\n        }\n    } else {\n        /* only add pseudo variables */\n        for(i = 0; i < b->var_count; i++) {\n            vd = &b->vardefs[b->arg_count + i];\n            if (vd->scope_level == 0 && is_var_in_arg_scope(vd)) {\n                JSClosureVar *cv = &s->closure_var[s->closure_var_count++];\n                set_closure_from_var(ctx, cv, vd, i);\n            }\n        }\n    }\n    for(i = 0; i < b->closure_var_count; i++) {\n        JSClosureVar *cv0 = &b->closure_var[i];\n        JSClosureVar *cv = &s->closure_var[s->closure_var_count++];\n        cv->is_local = FALSE;\n        cv->is_arg = cv0->is_arg;\n        cv->is_const = cv0->is_const;\n        cv->is_lexical = cv0->is_lexical;\n        cv->var_kind = cv0->var_kind;\n        cv->var_idx = i;\n        cv->var_name = JS_DupAtom(ctx, cv0->var_name);\n    }\n    return 0;\n}\n\ntypedef struct CodeContext {\n    const uint8_t *bc_buf; /* code buffer */\n    int bc_len;   /* length of the code buffer */\n    int pos;      /* position past the matched code pattern */\n    int line_num; /* last visited OP_line_num parameter or -1 */\n    int op;\n    int idx;\n    int label;\n    int val;\n    JSAtom atom;\n} CodeContext;\n\n#define M2(op1, op2)            ((op1) | ((op2) << 8))\n#define M3(op1, op2, op3)       ((op1) | ((op2) << 8) | ((op3) << 16))\n#define M4(op1, op2, op3, op4)  ((op1) | ((op2) << 8) | ((op3) << 16) | ((op4) << 24))\n\nstatic BOOL code_match(CodeContext *s, int pos, ...)\n{\n    const uint8_t *tab = s->bc_buf;\n    int op, len, op1, line_num, pos_next;\n    va_list ap;\n    BOOL ret = FALSE;\n\n    line_num = -1;\n    va_start(ap, pos);\n\n    for(;;) {\n        op1 = va_arg(ap, int);\n        if (op1 == -1) {\n            s->pos = pos;\n            s->line_num = line_num;\n            ret = TRUE;\n            break;\n        }\n        for (;;) {\n            if (pos >= s->bc_len)\n                goto done;\n            op = tab[pos];\n            len = opcode_info[op].size;\n            pos_next = pos + len;\n            if (pos_next > s->bc_len)\n                goto done;\n            if (op == OP_line_num) {\n                line_num = get_u32(tab + pos + 1);\n                pos = pos_next;\n            } else {\n                break;\n            }\n        }\n        if (op != op1) {\n            if (op1 == (uint8_t)op1 || !op)\n                break;\n            if (op != (uint8_t)op1\n            &&  op != (uint8_t)(op1 >> 8)\n            &&  op != (uint8_t)(op1 >> 16)\n            &&  op != (uint8_t)(op1 >> 24)) {\n                break;\n            }\n            s->op = op;\n        }\n\n        pos++;\n        switch(opcode_info[op].fmt) {\n        case OP_FMT_loc8:\n        case OP_FMT_u8:\n            {\n                int idx = tab[pos];\n                int arg = va_arg(ap, int);\n                if (arg == -1) {\n                    s->idx = idx;\n                } else {\n                    if (arg != idx)\n                        goto done;\n                }\n                break;\n            }\n        case OP_FMT_u16:\n        case OP_FMT_npop:\n        case OP_FMT_loc:\n        case OP_FMT_arg:\n        case OP_FMT_var_ref:\n            {\n                int idx = get_u16(tab + pos);\n                int arg = va_arg(ap, int);\n                if (arg == -1) {\n                    s->idx = idx;\n                } else {\n                    if (arg != idx)\n                        goto done;\n                }\n                break;\n            }\n        case OP_FMT_i32:\n        case OP_FMT_u32:\n        case OP_FMT_label:\n        case OP_FMT_const:\n            {\n                s->label = get_u32(tab + pos);\n                break;\n            }\n        case OP_FMT_label_u16:\n            {\n                s->label = get_u32(tab + pos);\n                s->val = get_u16(tab + pos + 4);\n                break;\n            }\n        case OP_FMT_atom:\n            {\n                s->atom = get_u32(tab + pos);\n                break;\n            }\n        case OP_FMT_atom_u8:\n            {\n                s->atom = get_u32(tab + pos);\n                s->val = get_u8(tab + pos + 4);\n                break;\n            }\n        case OP_FMT_atom_u16:\n            {\n                s->atom = get_u32(tab + pos);\n                s->val = get_u16(tab + pos + 4);\n                break;\n            }\n        case OP_FMT_atom_label_u8:\n            {\n                s->atom = get_u32(tab + pos);\n                s->label = get_u32(tab + pos + 4);\n                s->val = get_u8(tab + pos + 8);\n                break;\n            }\n        default:\n            break;\n        }\n        pos = pos_next;\n    }\n done:\n    va_end(ap);\n    return ret;\n}\n\nstatic void instantiate_hoisted_definitions(JSContext *ctx, JSFunctionDef *s, DynBuf *bc)\n{\n    int i, idx, label_next = -1;\n\n    /* add the hoisted functions in arguments and local variables */\n    for(i = 0; i < s->arg_count; i++) {\n        JSVarDef *vd = &s->args[i];\n        if (vd->func_pool_idx >= 0) {\n            dbuf_putc(bc, OP_fclosure);\n            dbuf_put_u32(bc, vd->func_pool_idx);\n            dbuf_putc(bc, OP_put_arg);\n            dbuf_put_u16(bc, i);\n        }\n    }\n    for(i = 0; i < s->var_count; i++) {\n        JSVarDef *vd = &s->vars[i];\n        if (vd->scope_level == 0 && vd->func_pool_idx >= 0) {\n            dbuf_putc(bc, OP_fclosure);\n            dbuf_put_u32(bc, vd->func_pool_idx);\n            dbuf_putc(bc, OP_put_loc);\n            dbuf_put_u16(bc, i);\n        }\n    }\n\n    /* the module global variables must be initialized before\n       evaluating the module so that the exported functions are\n       visible if there are cyclic module references */\n    if (s->module) {\n        label_next = new_label_fd(s, -1);\n        \n        /* if 'this' is true, initialize the global variables and return */\n        dbuf_putc(bc, OP_push_this);\n        dbuf_putc(bc, OP_if_false);\n        dbuf_put_u32(bc, label_next);\n        update_label(s, label_next, 1);\n        s->jump_size++;\n    }\n    \n    /* add the global variables (only happens if s->is_global_var is\n       true) */\n    for(i = 0; i < s->global_var_count; i++) {\n        JSGlobalVar *hf = &s->global_vars[i];\n        int has_closure = 0;\n        BOOL force_init = hf->force_init;\n        /* we are in an eval, so the closure contains all the\n           enclosing variables */\n        /* If the outer function has a variable environment,\n           create a property for the variable there */\n        for(idx = 0; idx < s->closure_var_count; idx++) {\n            JSClosureVar *cv = &s->closure_var[idx];\n            if (cv->var_name == hf->var_name) {\n                has_closure = 2;\n                force_init = FALSE;\n                break;\n            }\n            if (cv->var_name == JS_ATOM__var_ ||\n                cv->var_name == JS_ATOM__arg_var_) {\n                dbuf_putc(bc, OP_get_var_ref);\n                dbuf_put_u16(bc, idx);\n                has_closure = 1;\n                force_init = TRUE;\n                break;\n            }\n        }\n        if (!has_closure) {\n            int flags;\n            \n            flags = 0;\n            if (s->eval_type != JS_EVAL_TYPE_GLOBAL)\n                flags |= JS_PROP_CONFIGURABLE;\n            if (hf->cpool_idx >= 0 && !hf->is_lexical) {\n                /* global function definitions need a specific handling */\n                dbuf_putc(bc, OP_fclosure);\n                dbuf_put_u32(bc, hf->cpool_idx);\n                \n                dbuf_putc(bc, OP_define_func);\n                dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));\n                dbuf_putc(bc, flags);\n                \n                goto done_global_var;\n            } else {\n                if (hf->is_lexical) {\n                    flags |= DEFINE_GLOBAL_LEX_VAR;\n                    if (!hf->is_const)\n                        flags |= JS_PROP_WRITABLE;\n                }\n                dbuf_putc(bc, OP_define_var);\n                dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));\n                dbuf_putc(bc, flags);\n            }\n        }\n        if (hf->cpool_idx >= 0 || force_init) {\n            if (hf->cpool_idx >= 0) {\n                dbuf_putc(bc, OP_fclosure);\n                dbuf_put_u32(bc, hf->cpool_idx);\n                if (hf->var_name == JS_ATOM__default_) {\n                    /* set default export function name */\n                    dbuf_putc(bc, OP_set_name);\n                    dbuf_put_u32(bc, JS_DupAtom(ctx, JS_ATOM_default));\n                }\n            } else {\n                dbuf_putc(bc, OP_undefined);\n            }\n            if (has_closure == 2) {\n                dbuf_putc(bc, OP_put_var_ref);\n                dbuf_put_u16(bc, idx);\n            } else if (has_closure == 1) {\n                dbuf_putc(bc, OP_define_field);\n                dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));\n                dbuf_putc(bc, OP_drop);\n            } else {\n                /* XXX: Check if variable is writable and enumerable */\n                dbuf_putc(bc, OP_put_var);\n                dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));\n            }\n        }\n    done_global_var:\n        JS_FreeAtom(ctx, hf->var_name);\n    }\n\n    if (s->module) {\n        dbuf_putc(bc, OP_return_undef);\n        \n        dbuf_putc(bc, OP_label);\n        dbuf_put_u32(bc, label_next);\n        s->label_slots[label_next].pos2 = bc->size;\n    }\n\n    js_free(ctx, s->global_vars);\n    s->global_vars = NULL;\n    s->global_var_count = 0;\n    s->global_var_size = 0;\n}\n\nstatic int skip_dead_code(JSFunctionDef *s, const uint8_t *bc_buf, int bc_len,\n                          int pos, int *linep)\n{\n    int op, len, label;\n\n    for (; pos < bc_len; pos += len) {\n        op = bc_buf[pos];\n        len = opcode_info[op].size;\n        if (op == OP_line_num) {\n            *linep = get_u32(bc_buf + pos + 1);\n        } else\n        if (op == OP_label) {\n            label = get_u32(bc_buf + pos + 1);\n            if (update_label(s, label, 0) > 0)\n                break;\n#if 0\n            if (s->label_slots[label].first_reloc) {\n                printf(\"line %d: unreferenced label %d:%d has relocations\\n\",\n                       *linep, label, s->label_slots[label].pos2);\n            }\n#endif\n            assert(s->label_slots[label].first_reloc == NULL);\n        } else {\n            /* XXX: output a warning for unreachable code? */\n            JSAtom atom;\n            switch(opcode_info[op].fmt) {\n            case OP_FMT_label:\n            case OP_FMT_label_u16:\n                label = get_u32(bc_buf + pos + 1);\n                update_label(s, label, -1);\n                break;\n            case OP_FMT_atom_label_u8:\n            case OP_FMT_atom_label_u16:\n                label = get_u32(bc_buf + pos + 5);\n                update_label(s, label, -1);\n                /* fall thru */\n            case OP_FMT_atom:\n            case OP_FMT_atom_u8:\n            case OP_FMT_atom_u16:\n                atom = get_u32(bc_buf + pos + 1);\n                JS_FreeAtom(s->ctx, atom);\n                break;\n            default:\n                break;\n            }\n        }\n    }\n    return pos;\n}\n\nstatic int get_label_pos(JSFunctionDef *s, int label)\n{\n    int i, pos;\n    for (i = 0; i < 20; i++) {\n        pos = s->label_slots[label].pos;\n        for (;;) {\n            switch (s->byte_code.buf[pos]) {\n            case OP_line_num:\n            case OP_label:\n                pos += 5;\n                continue;\n            case OP_goto:\n                label = get_u32(s->byte_code.buf + pos + 1);\n                break;\n            default:\n                return pos;\n            }\n            break;\n        }\n    }\n    return pos;\n}\n\n/* convert global variable accesses to local variables or closure\n   variables when necessary */\nstatic __exception int resolve_variables(JSContext *ctx, JSFunctionDef *s)\n{\n    int pos, pos_next, bc_len, op, len, i, idx, line_num;\n    uint8_t *bc_buf;\n    JSAtom var_name;\n    DynBuf bc_out;\n    CodeContext cc;\n    int scope;\n\n    cc.bc_buf = bc_buf = s->byte_code.buf;\n    cc.bc_len = bc_len = s->byte_code.size;\n    js_dbuf_init(ctx, &bc_out);\n\n    /* first pass for runtime checks (must be done before the\n       variables are created) */\n    for(i = 0; i < s->global_var_count; i++) {\n        JSGlobalVar *hf = &s->global_vars[i];\n        int flags;\n        \n        /* check if global variable (XXX: simplify) */\n        for(idx = 0; idx < s->closure_var_count; idx++) {\n            JSClosureVar *cv = &s->closure_var[idx];\n            if (cv->var_name == hf->var_name) {\n                if (s->eval_type == JS_EVAL_TYPE_DIRECT &&\n                    cv->is_lexical) {\n                    /* Check if a lexical variable is\n                       redefined as 'var'. XXX: Could abort\n                       compilation here, but for consistency\n                       with the other checks, we delay the\n                       error generation. */\n                    dbuf_putc(&bc_out, OP_throw_error);\n                    dbuf_put_u32(&bc_out, JS_DupAtom(ctx, hf->var_name));\n                    dbuf_putc(&bc_out, JS_THROW_VAR_REDECL);\n                }\n                goto next;\n            }\n            if (cv->var_name == JS_ATOM__var_ ||\n                cv->var_name == JS_ATOM__arg_var_)\n                goto next;\n        }\n        \n        dbuf_putc(&bc_out, OP_check_define_var);\n        dbuf_put_u32(&bc_out, JS_DupAtom(ctx, hf->var_name));\n        flags = 0;\n        if (hf->is_lexical)\n            flags |= DEFINE_GLOBAL_LEX_VAR;\n        if (hf->cpool_idx >= 0)\n            flags |= DEFINE_GLOBAL_FUNC_VAR;\n        dbuf_putc(&bc_out, flags);\n    next: ;\n    }\n\n    line_num = 0; /* avoid warning */\n    for (pos = 0; pos < bc_len; pos = pos_next) {\n        op = bc_buf[pos];\n        len = opcode_info[op].size;\n        pos_next = pos + len;\n        switch(op) {\n        case OP_line_num:\n            line_num = get_u32(bc_buf + pos + 1);\n            s->line_number_size++;\n            goto no_change;\n\n        case OP_eval: /* convert scope index to adjusted variable index */\n            {\n                int call_argc = get_u16(bc_buf + pos + 1);\n                scope = get_u16(bc_buf + pos + 1 + 2);\n                mark_eval_captured_variables(ctx, s, scope);\n                dbuf_putc(&bc_out, op);\n                dbuf_put_u16(&bc_out, call_argc);\n                dbuf_put_u16(&bc_out, s->scopes[scope].first + 1);\n            }\n            break;\n        case OP_apply_eval: /* convert scope index to adjusted variable index */\n            scope = get_u16(bc_buf + pos + 1);\n            mark_eval_captured_variables(ctx, s, scope);\n            dbuf_putc(&bc_out, op);\n            dbuf_put_u16(&bc_out, s->scopes[scope].first + 1);\n            break;\n        case OP_scope_get_var_undef:\n        case OP_scope_get_var:\n        case OP_scope_put_var:\n        case OP_scope_delete_var:\n        case OP_scope_get_ref:\n        case OP_scope_put_var_init:\n            var_name = get_u32(bc_buf + pos + 1);\n            scope = get_u16(bc_buf + pos + 5);\n            pos_next = resolve_scope_var(ctx, s, var_name, scope, op, &bc_out,\n                                         NULL, NULL, pos_next);\n            JS_FreeAtom(ctx, var_name);\n            break;\n        case OP_scope_make_ref:\n            {\n                int label;\n                LabelSlot *ls;\n                var_name = get_u32(bc_buf + pos + 1);\n                label = get_u32(bc_buf + pos + 5);\n                scope = get_u16(bc_buf + pos + 9);\n                ls = &s->label_slots[label];\n                ls->ref_count--;  /* always remove label reference */\n                pos_next = resolve_scope_var(ctx, s, var_name, scope, op, &bc_out,\n                                             bc_buf, ls, pos_next);\n                JS_FreeAtom(ctx, var_name);\n            }\n            break;\n        case OP_scope_get_private_field:\n        case OP_scope_get_private_field2:\n        case OP_scope_put_private_field:\n            {\n                int ret;\n                var_name = get_u32(bc_buf + pos + 1);\n                scope = get_u16(bc_buf + pos + 5);\n                ret = resolve_scope_private_field(ctx, s, var_name, scope, op, &bc_out);\n                if (ret < 0)\n                    goto fail;\n                JS_FreeAtom(ctx, var_name);\n            }\n            break;\n        case OP_gosub:\n            s->jump_size++;\n            if (OPTIMIZE) {\n                /* remove calls to empty finalizers  */\n                int label;\n                LabelSlot *ls;\n\n                label = get_u32(bc_buf + pos + 1);\n                assert(label >= 0 && label < s->label_count);\n                ls = &s->label_slots[label];\n                if (code_match(&cc, ls->pos, OP_ret, -1)) {\n                    ls->ref_count--;\n                    break;\n                }\n            }\n            goto no_change;\n        case OP_drop:\n            if (0) {\n                /* remove drops before return_undef */\n                /* do not perform this optimization in pass2 because\n                   it breaks patterns recognised in resolve_labels */\n                int pos1 = pos_next;\n                int line1 = line_num;\n                while (code_match(&cc, pos1, OP_drop, -1)) {\n                    if (cc.line_num >= 0) line1 = cc.line_num;\n                    pos1 = cc.pos;\n                }\n                if (code_match(&cc, pos1, OP_return_undef, -1)) {\n                    pos_next = pos1;\n                    if (line1 != -1 && line1 != line_num) {\n                        line_num = line1;\n                        s->line_number_size++;\n                        dbuf_putc(&bc_out, OP_line_num);\n                        dbuf_put_u32(&bc_out, line_num);\n                    }\n                    break;\n                }\n            }\n            goto no_change;\n        case OP_insert3:\n            if (OPTIMIZE) {\n                /* Transformation: insert3 put_array_el|put_ref_value drop -> put_array_el|put_ref_value */\n                if (code_match(&cc, pos_next, M2(OP_put_array_el, OP_put_ref_value), OP_drop, -1)) {\n                    dbuf_putc(&bc_out, cc.op);\n                    pos_next = cc.pos;\n                    if (cc.line_num != -1 && cc.line_num != line_num) {\n                        line_num = cc.line_num;\n                        s->line_number_size++;\n                        dbuf_putc(&bc_out, OP_line_num);\n                        dbuf_put_u32(&bc_out, line_num);\n                    }\n                    break;\n                }\n            }\n            goto no_change;\n\n        case OP_goto:\n            s->jump_size++;\n            /* fall thru */\n        case OP_tail_call:\n        case OP_tail_call_method:\n        case OP_return:\n        case OP_return_undef:\n        case OP_throw:\n        case OP_throw_error:\n        case OP_ret:\n            if (OPTIMIZE) {\n                /* remove dead code */\n                int line = -1;\n                dbuf_put(&bc_out, bc_buf + pos, len);\n                pos = skip_dead_code(s, bc_buf, bc_len, pos + len, &line);\n                pos_next = pos;\n                if (pos < bc_len && line >= 0 && line_num != line) {\n                    line_num = line;\n                    s->line_number_size++;\n                    dbuf_putc(&bc_out, OP_line_num);\n                    dbuf_put_u32(&bc_out, line_num);\n                }\n                break;\n            }\n            goto no_change;\n\n        case OP_label:\n            {\n                int label;\n                LabelSlot *ls;\n\n                label = get_u32(bc_buf + pos + 1);\n                assert(label >= 0 && label < s->label_count);\n                ls = &s->label_slots[label];\n                ls->pos2 = bc_out.size + opcode_info[op].size;\n            }\n            goto no_change;\n\n        case OP_enter_scope:\n            {\n                int scope_idx, scope = get_u16(bc_buf + pos + 1);\n\n                if (scope == s->body_scope) {\n                    instantiate_hoisted_definitions(ctx, s, &bc_out);\n                }\n\n                for(scope_idx = s->scopes[scope].first; scope_idx >= 0;) {\n                    JSVarDef *vd = &s->vars[scope_idx];\n                    if (vd->scope_level == scope) {\n                        if (scope_idx != s->arguments_arg_idx) {\n                            if (vd->var_kind == JS_VAR_FUNCTION_DECL ||\n                                vd->var_kind == JS_VAR_NEW_FUNCTION_DECL) {\n                                /* Initialize lexical variable upon entering scope */\n                                dbuf_putc(&bc_out, OP_fclosure);\n                                dbuf_put_u32(&bc_out, vd->func_pool_idx);\n                                dbuf_putc(&bc_out, OP_put_loc);\n                                dbuf_put_u16(&bc_out, scope_idx);\n                            } else {\n                                /* XXX: should check if variable can be used\n                                   before initialization */\n                                dbuf_putc(&bc_out, OP_set_loc_uninitialized);\n                                dbuf_put_u16(&bc_out, scope_idx);\n                            }\n                        }\n                        scope_idx = vd->scope_next;\n                    } else {\n                        break;\n                    }\n                }\n            }\n            break;\n\n        case OP_leave_scope:\n            {\n                int scope_idx, scope = get_u16(bc_buf + pos + 1);\n\n                for(scope_idx = s->scopes[scope].first; scope_idx >= 0;) {\n                    JSVarDef *vd = &s->vars[scope_idx];\n                    if (vd->scope_level == scope) {\n                        if (vd->is_captured) {\n                            dbuf_putc(&bc_out, OP_close_loc);\n                            dbuf_put_u16(&bc_out, scope_idx);\n                        }\n                        scope_idx = vd->scope_next;\n                    } else {\n                        break;\n                    }\n                }\n            }\n            break;\n\n        case OP_set_name:\n            {\n                /* remove dummy set_name opcodes */\n                JSAtom name = get_u32(bc_buf + pos + 1);\n                if (name == JS_ATOM_NULL)\n                    break;\n            }\n            goto no_change;\n\n        case OP_if_false:\n        case OP_if_true:\n        case OP_catch:\n            s->jump_size++;\n            goto no_change;\n\n        case OP_dup:\n            if (OPTIMIZE) {\n                /* Transformation: dup if_false(l1) drop, l1: if_false(l2) -> if_false(l2) */\n                /* Transformation: dup if_true(l1) drop, l1: if_true(l2) -> if_true(l2) */\n                if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), OP_drop, -1)) {\n                    int lab0, lab1, op1, pos1, line1, pos2;\n                    lab0 = lab1 = cc.label;\n                    assert(lab1 >= 0 && lab1 < s->label_count);\n                    op1 = cc.op;\n                    pos1 = cc.pos;\n                    line1 = cc.line_num;\n                    while (code_match(&cc, (pos2 = get_label_pos(s, lab1)), OP_dup, op1, OP_drop, -1)) {\n                        lab1 = cc.label;\n                    }\n                    if (code_match(&cc, pos2, op1, -1)) {\n                        s->jump_size++;\n                        update_label(s, lab0, -1);\n                        update_label(s, cc.label, +1);\n                        dbuf_putc(&bc_out, op1);\n                        dbuf_put_u32(&bc_out, cc.label);\n                        pos_next = pos1;\n                        if (line1 != -1 && line1 != line_num) {\n                            line_num = line1;\n                            s->line_number_size++;\n                            dbuf_putc(&bc_out, OP_line_num);\n                            dbuf_put_u32(&bc_out, line_num);\n                        }\n                        break;\n                    }\n                }\n            }\n            goto no_change;\n\n        case OP_nop:\n            /* remove erased code */\n            break;\n        case OP_set_class_name:\n            /* only used during parsing */\n            break;\n            \n        default:\n        no_change:\n            dbuf_put(&bc_out, bc_buf + pos, len);\n            break;\n        }\n    }\n\n    /* set the new byte code */\n    dbuf_free(&s->byte_code);\n    s->byte_code = bc_out;\n    if (dbuf_error(&s->byte_code)) {\n        JS_ThrowOutOfMemory(ctx);\n        return -1;\n    }\n    return 0;\n fail:\n    /* continue the copy to keep the atom refcounts consistent */\n    /* XXX: find a better solution ? */\n    for (; pos < bc_len; pos = pos_next) {\n        op = bc_buf[pos];\n        len = opcode_info[op].size;\n        pos_next = pos + len;\n        dbuf_put(&bc_out, bc_buf + pos, len);\n    }\n    dbuf_free(&s->byte_code);\n    s->byte_code = bc_out;\n    return -1;\n}\n\n/* the pc2line table gives a line number for each PC value */\nstatic void add_pc2line_info(JSFunctionDef *s, uint32_t pc, int line_num)\n{\n    if (s->line_number_slots != NULL\n    &&  s->line_number_count < s->line_number_size\n    &&  pc >= s->line_number_last_pc\n    &&  line_num != s->line_number_last) {\n        s->line_number_slots[s->line_number_count].pc = pc;\n        s->line_number_slots[s->line_number_count].line_num = line_num;\n        s->line_number_count++;\n        s->line_number_last_pc = pc;\n        s->line_number_last = line_num;\n    }\n}\n\nstatic void compute_pc2line_info(JSFunctionDef *s)\n{\n    if (!(s->js_mode & JS_MODE_STRIP) && s->line_number_slots) {\n        int last_line_num = s->line_num;\n        uint32_t last_pc = 0;\n        int i;\n\n        js_dbuf_init(s->ctx, &s->pc2line);\n        for (i = 0; i < s->line_number_count; i++) {\n            uint32_t pc = s->line_number_slots[i].pc;\n            int line_num = s->line_number_slots[i].line_num;\n            int diff_pc, diff_line;\n\n            if (line_num < 0)\n                continue;\n\n            diff_pc = pc - last_pc;\n            diff_line = line_num - last_line_num;\n            if (diff_line == 0 || diff_pc < 0)\n                continue;\n\n            if (diff_line >= PC2LINE_BASE &&\n                diff_line < PC2LINE_BASE + PC2LINE_RANGE &&\n                diff_pc <= PC2LINE_DIFF_PC_MAX) {\n                dbuf_putc(&s->pc2line, (diff_line - PC2LINE_BASE) +\n                          diff_pc * PC2LINE_RANGE + PC2LINE_OP_FIRST);\n            } else {\n                /* longer encoding */\n                dbuf_putc(&s->pc2line, 0);\n                dbuf_put_leb128(&s->pc2line, diff_pc);\n                dbuf_put_sleb128(&s->pc2line, diff_line);\n            }\n            last_pc = pc;\n            last_line_num = line_num;\n        }\n    }\n}\n\nstatic RelocEntry *add_reloc(JSContext *ctx, LabelSlot *ls, uint32_t addr, int size)\n{\n    RelocEntry *re;\n    re = js_malloc(ctx, sizeof(*re));\n    if (!re)\n        return NULL;\n    re->addr = addr;\n    re->size = size;\n    re->next = ls->first_reloc;\n    ls->first_reloc = re;\n    return re;\n}\n\nstatic BOOL code_has_label(CodeContext *s, int pos, int label)\n{\n    while (pos < s->bc_len) {\n        int op = s->bc_buf[pos];\n        if (op == OP_line_num) {\n            pos += 5;\n            continue;\n        }\n        if (op == OP_label) {\n            int lab = get_u32(s->bc_buf + pos + 1);\n            if (lab == label)\n                return TRUE;\n            pos += 5;\n            continue;\n        }\n        if (op == OP_goto) {\n            int lab = get_u32(s->bc_buf + pos + 1);\n            if (lab == label)\n                return TRUE;\n        }\n        break;\n    }\n    return FALSE;\n}\n\n/* return the target label, following the OP_goto jumps\n   the first opcode at destination is stored in *pop\n */\nstatic int find_jump_target(JSFunctionDef *s, int label, int *pop, int *pline)\n{\n    int i, pos, op;\n\n    update_label(s, label, -1);\n    for (i = 0; i < 10; i++) {\n        assert(label >= 0 && label < s->label_count);\n        pos = s->label_slots[label].pos2;\n        for (;;) {\n            switch(op = s->byte_code.buf[pos]) {\n            case OP_line_num:\n                if (pline)\n                    *pline = get_u32(s->byte_code.buf + pos + 1);\n                /* fall thru */\n            case OP_label:\n                pos += opcode_info[op].size;\n                continue;\n            case OP_goto:\n                label = get_u32(s->byte_code.buf + pos + 1);\n                break;\n            case OP_drop:\n                /* ignore drop opcodes if followed by OP_return_undef */\n                while (s->byte_code.buf[++pos] == OP_drop)\n                    continue;\n                if (s->byte_code.buf[pos] == OP_return_undef)\n                    op = OP_return_undef;\n                /* fall thru */\n            default:\n                goto done;\n            }\n            break;\n        }\n    }\n    /* cycle detected, could issue a warning */\n done:\n    *pop = op;\n    update_label(s, label, +1);\n    return label;\n}\n\nstatic void push_short_int(DynBuf *bc_out, int val)\n{\n#if SHORT_OPCODES\n    if (val >= -1 && val <= 7) {\n        dbuf_putc(bc_out, OP_push_0 + val);\n        return;\n    }\n    if (val == (int8_t)val) {\n        dbuf_putc(bc_out, OP_push_i8);\n        dbuf_putc(bc_out, val);\n        return;\n    }\n    if (val == (int16_t)val) {\n        dbuf_putc(bc_out, OP_push_i16);\n        dbuf_put_u16(bc_out, val);\n        return;\n    }\n#endif\n    dbuf_putc(bc_out, OP_push_i32);\n    dbuf_put_u32(bc_out, val);\n}\n\nstatic void put_short_code(DynBuf *bc_out, int op, int idx)\n{\n#if SHORT_OPCODES\n    if (idx < 4) {\n        switch (op) {\n        case OP_get_loc:\n            dbuf_putc(bc_out, OP_get_loc0 + idx);\n            return;\n        case OP_put_loc:\n            dbuf_putc(bc_out, OP_put_loc0 + idx);\n            return;\n        case OP_set_loc:\n            dbuf_putc(bc_out, OP_set_loc0 + idx);\n            return;\n        case OP_get_arg:\n            dbuf_putc(bc_out, OP_get_arg0 + idx);\n            return;\n        case OP_put_arg:\n            dbuf_putc(bc_out, OP_put_arg0 + idx);\n            return;\n        case OP_set_arg:\n            dbuf_putc(bc_out, OP_set_arg0 + idx);\n            return;\n        case OP_get_var_ref:\n            dbuf_putc(bc_out, OP_get_var_ref0 + idx);\n            return;\n        case OP_put_var_ref:\n            dbuf_putc(bc_out, OP_put_var_ref0 + idx);\n            return;\n        case OP_set_var_ref:\n            dbuf_putc(bc_out, OP_set_var_ref0 + idx);\n            return;\n        case OP_call:\n            dbuf_putc(bc_out, OP_call0 + idx);\n            return;\n        }\n    }\n    if (idx < 256) {\n        switch (op) {\n        case OP_get_loc:\n            dbuf_putc(bc_out, OP_get_loc8);\n            dbuf_putc(bc_out, idx);\n            return;\n        case OP_put_loc:\n            dbuf_putc(bc_out, OP_put_loc8);\n            dbuf_putc(bc_out, idx);\n            return;\n        case OP_set_loc:\n            dbuf_putc(bc_out, OP_set_loc8);\n            dbuf_putc(bc_out, idx);\n            return;\n        }\n    }\n#endif\n    dbuf_putc(bc_out, op);\n    dbuf_put_u16(bc_out, idx);\n}\n\n/* peephole optimizations and resolve goto/labels */\nstatic __exception int resolve_labels(JSContext *ctx, JSFunctionDef *s)\n{\n    int pos, pos_next, bc_len, op, op1, len, i, line_num;\n    const uint8_t *bc_buf;\n    DynBuf bc_out;\n    LabelSlot *label_slots, *ls;\n    RelocEntry *re, *re_next;\n    CodeContext cc;\n    int label;\n#if SHORT_OPCODES\n    JumpSlot *jp;\n#endif\n\n    label_slots = s->label_slots;\n\n    line_num = s->line_num;\n\n    cc.bc_buf = bc_buf = s->byte_code.buf;\n    cc.bc_len = bc_len = s->byte_code.size;\n    js_dbuf_init(ctx, &bc_out);\n\n#if SHORT_OPCODES\n    if (s->jump_size) {\n        s->jump_slots = js_mallocz(s->ctx, sizeof(*s->jump_slots) * s->jump_size);\n        if (s->jump_slots == NULL)\n            return -1;\n    }\n#endif\n    /* XXX: Should skip this phase if not generating SHORT_OPCODES */\n    if (s->line_number_size && !(s->js_mode & JS_MODE_STRIP)) {\n        s->line_number_slots = js_mallocz(s->ctx, sizeof(*s->line_number_slots) * s->line_number_size);\n        if (s->line_number_slots == NULL)\n            return -1;\n        s->line_number_last = s->line_num;\n        s->line_number_last_pc = 0;\n    }\n\n    /* initialize the 'home_object' variable if needed */\n    if (s->home_object_var_idx >= 0) {\n        dbuf_putc(&bc_out, OP_special_object);\n        dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_HOME_OBJECT);\n        put_short_code(&bc_out, OP_put_loc, s->home_object_var_idx);\n    }\n    /* initialize the 'this.active_func' variable if needed */\n    if (s->this_active_func_var_idx >= 0) {\n        dbuf_putc(&bc_out, OP_special_object);\n        dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_THIS_FUNC);\n        put_short_code(&bc_out, OP_put_loc, s->this_active_func_var_idx);\n    }\n    /* initialize the 'new.target' variable if needed */\n    if (s->new_target_var_idx >= 0) {\n        dbuf_putc(&bc_out, OP_special_object);\n        dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_NEW_TARGET);\n        put_short_code(&bc_out, OP_put_loc, s->new_target_var_idx);\n    }\n    /* initialize the 'this' variable if needed. In a derived class\n       constructor, this is initially uninitialized. */\n    if (s->this_var_idx >= 0) {\n        if (s->is_derived_class_constructor) {\n            dbuf_putc(&bc_out, OP_set_loc_uninitialized);\n            dbuf_put_u16(&bc_out, s->this_var_idx);\n        } else {\n            dbuf_putc(&bc_out, OP_push_this);\n            put_short_code(&bc_out, OP_put_loc, s->this_var_idx);\n        }\n    }\n    /* initialize the 'arguments' variable if needed */\n    if (s->arguments_var_idx >= 0) {\n        if ((s->js_mode & JS_MODE_STRICT) || !s->has_simple_parameter_list) {\n            dbuf_putc(&bc_out, OP_special_object);\n            dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_ARGUMENTS);\n        } else {\n            dbuf_putc(&bc_out, OP_special_object);\n            dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_MAPPED_ARGUMENTS);\n        }\n        if (s->arguments_arg_idx >= 0)\n            put_short_code(&bc_out, OP_set_loc, s->arguments_arg_idx);\n        put_short_code(&bc_out, OP_put_loc, s->arguments_var_idx);\n    }\n    /* initialize a reference to the current function if needed */\n    if (s->func_var_idx >= 0) {\n        dbuf_putc(&bc_out, OP_special_object);\n        dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_THIS_FUNC);\n        put_short_code(&bc_out, OP_put_loc, s->func_var_idx);\n    }\n    /* initialize the variable environment object if needed */\n    if (s->var_object_idx >= 0) {\n        dbuf_putc(&bc_out, OP_special_object);\n        dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT);\n        put_short_code(&bc_out, OP_put_loc, s->var_object_idx);\n    }\n    if (s->arg_var_object_idx >= 0) {\n        dbuf_putc(&bc_out, OP_special_object);\n        dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT);\n        put_short_code(&bc_out, OP_put_loc, s->arg_var_object_idx);\n    }\n\n    for (pos = 0; pos < bc_len; pos = pos_next) {\n        int val;\n        op = bc_buf[pos];\n        len = opcode_info[op].size;\n        pos_next = pos + len;\n        switch(op) {\n        case OP_line_num:\n            /* line number info (for debug). We put it in a separate\n               compressed table to reduce memory usage and get better\n               performance */\n            line_num = get_u32(bc_buf + pos + 1);\n            break;\n\n        case OP_label:\n            {\n                label = get_u32(bc_buf + pos + 1);\n                assert(label >= 0 && label < s->label_count);\n                ls = &label_slots[label];\n                assert(ls->addr == -1);\n                ls->addr = bc_out.size;\n                /* resolve the relocation entries */\n                for(re = ls->first_reloc; re != NULL; re = re_next) {\n                    int diff = ls->addr - re->addr;\n                    re_next = re->next;\n                    switch (re->size) {\n                    case 4:\n                        put_u32(bc_out.buf + re->addr, diff);\n                        break;\n                    case 2:\n                        assert(diff == (int16_t)diff);\n                        put_u16(bc_out.buf + re->addr, diff);\n                        break;\n                    case 1:\n                        assert(diff == (int8_t)diff);\n                        put_u8(bc_out.buf + re->addr, diff);\n                        break;\n                    }\n                    js_free(ctx, re);\n                }\n                ls->first_reloc = NULL;\n            }\n            break;\n\n        case OP_call:\n        case OP_call_method:\n            {\n                /* detect and transform tail calls */\n                int argc;\n                argc = get_u16(bc_buf + pos + 1);\n                if (code_match(&cc, pos_next, OP_return, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    put_short_code(&bc_out, op + 1, argc);\n                    pos_next = skip_dead_code(s, bc_buf, bc_len, cc.pos, &line_num);\n                    break;\n                }\n                add_pc2line_info(s, bc_out.size, line_num);\n                put_short_code(&bc_out, op, argc);\n                break;\n            }\n            goto no_change;\n\n        case OP_return:\n        case OP_return_undef:\n        case OP_return_async:\n        case OP_throw:\n        case OP_throw_error:\n            pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &line_num);\n            goto no_change;\n\n        case OP_goto:\n            label = get_u32(bc_buf + pos + 1);\n        has_goto:\n            if (OPTIMIZE) {\n                int line1 = -1;\n                /* Use custom matcher because multiple labels can follow */\n                label = find_jump_target(s, label, &op1, &line1);\n                if (code_has_label(&cc, pos_next, label)) {\n                    /* jump to next instruction: remove jump */\n                    update_label(s, label, -1);\n                    break;\n                }\n                if (op1 == OP_return || op1 == OP_return_undef || op1 == OP_throw) {\n                    /* jump to return/throw: remove jump, append return/throw */\n                    /* updating the line number obfuscates assembly listing */\n                    //if (line1 >= 0) line_num = line1;\n                    update_label(s, label, -1);\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    dbuf_putc(&bc_out, op1);\n                    pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &line_num);\n                    break;\n                }\n                /* XXX: should duplicate single instructions followed by goto or return */\n                /* For example, can match one of these followed by return:\n                   push_i32 / push_const / push_atom_value / get_var /\n                   undefined / null / push_false / push_true / get_ref_value /\n                   get_loc / get_arg / get_var_ref\n                 */\n            }\n            goto has_label;\n\n        case OP_gosub:\n            label = get_u32(bc_buf + pos + 1);\n            if (0 && OPTIMIZE) {\n                label = find_jump_target(s, label, &op1, NULL);\n                if (op1 == OP_ret) {\n                    update_label(s, label, -1);\n                    /* empty finally clause: remove gosub */\n                    break;\n                }\n            }\n            goto has_label;\n\n        case OP_catch:\n            label = get_u32(bc_buf + pos + 1);\n            goto has_label;\n\n        case OP_if_true:\n        case OP_if_false:\n            label = get_u32(bc_buf + pos + 1);\n            if (OPTIMIZE) {\n                label = find_jump_target(s, label, &op1, NULL);\n                /* transform if_false/if_true(l1) label(l1) -> drop label(l1) */\n                if (code_has_label(&cc, pos_next, label)) {\n                    update_label(s, label, -1);\n                    dbuf_putc(&bc_out, OP_drop);\n                    break;\n                }\n                /* transform if_false(l1) goto(l2) label(l1) -> if_false(l2) label(l1) */\n                if (code_match(&cc, pos_next, OP_goto, -1)) {\n                    int pos1 = cc.pos;\n                    int line1 = cc.line_num;\n                    if (code_has_label(&cc, pos1, label)) {\n                        if (line1 >= 0) line_num = line1;\n                        pos_next = pos1;\n                        update_label(s, label, -1);\n                        label = cc.label;\n                        op ^= OP_if_true ^ OP_if_false;\n                    }\n                }\n            }\n        has_label:\n            add_pc2line_info(s, bc_out.size, line_num);\n            if (op == OP_goto) {\n                pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &line_num);\n            }\n            assert(label >= 0 && label < s->label_count);\n            ls = &label_slots[label];\n#if SHORT_OPCODES\n            jp = &s->jump_slots[s->jump_count++];\n            jp->op = op;\n            jp->size = 4;\n            jp->pos = bc_out.size + 1;\n            jp->label = label;\n\n            if (ls->addr == -1) {\n                int diff = ls->pos2 - pos - 1;\n                if (diff < 128 && (op == OP_if_false || op == OP_if_true || op == OP_goto)) {\n                    jp->size = 1;\n                    jp->op = OP_if_false8 + (op - OP_if_false);\n                    dbuf_putc(&bc_out, OP_if_false8 + (op - OP_if_false));\n                    dbuf_putc(&bc_out, 0);\n                    if (!add_reloc(ctx, ls, bc_out.size - 1, 1))\n                        goto fail;\n                    break;\n                }\n                if (diff < 32768 && op == OP_goto) {\n                    jp->size = 2;\n                    jp->op = OP_goto16;\n                    dbuf_putc(&bc_out, OP_goto16);\n                    dbuf_put_u16(&bc_out, 0);\n                    if (!add_reloc(ctx, ls, bc_out.size - 2, 2))\n                        goto fail;\n                    break;\n                }\n            } else {\n                int diff = ls->addr - bc_out.size - 1;\n                if (diff == (int8_t)diff && (op == OP_if_false || op == OP_if_true || op == OP_goto)) {\n                    jp->size = 1;\n                    jp->op = OP_if_false8 + (op - OP_if_false);\n                    dbuf_putc(&bc_out, OP_if_false8 + (op - OP_if_false));\n                    dbuf_putc(&bc_out, diff);\n                    break;\n                }\n                if (diff == (int16_t)diff && op == OP_goto) {\n                    jp->size = 2;\n                    jp->op = OP_goto16;\n                    dbuf_putc(&bc_out, OP_goto16);\n                    dbuf_put_u16(&bc_out, diff);\n                    break;\n                }\n            }\n#endif\n            dbuf_putc(&bc_out, op);\n            dbuf_put_u32(&bc_out, ls->addr - bc_out.size);\n            if (ls->addr == -1) {\n                /* unresolved yet: create a new relocation entry */\n                if (!add_reloc(ctx, ls, bc_out.size - 4, 4))\n                    goto fail;\n            }\n            break;\n        case OP_with_get_var:\n        case OP_with_put_var:\n        case OP_with_delete_var:\n        case OP_with_make_ref:\n        case OP_with_get_ref:\n        case OP_with_get_ref_undef:\n            {\n                JSAtom atom;\n                int is_with;\n\n                atom = get_u32(bc_buf + pos + 1);\n                label = get_u32(bc_buf + pos + 5);\n                is_with = bc_buf[pos + 9];\n                if (OPTIMIZE) {\n                    label = find_jump_target(s, label, &op1, NULL);\n                }\n                assert(label >= 0 && label < s->label_count);\n                ls = &label_slots[label];\n                add_pc2line_info(s, bc_out.size, line_num);\n#if SHORT_OPCODES\n                jp = &s->jump_slots[s->jump_count++];\n                jp->op = op;\n                jp->size = 4;\n                jp->pos = bc_out.size + 5;\n                jp->label = label;\n#endif\n                dbuf_putc(&bc_out, op);\n                dbuf_put_u32(&bc_out, atom);\n                dbuf_put_u32(&bc_out, ls->addr - bc_out.size);\n                if (ls->addr == -1) {\n                    /* unresolved yet: create a new relocation entry */\n                    if (!add_reloc(ctx, ls, bc_out.size - 4, 4))\n                        goto fail;\n                }\n                dbuf_putc(&bc_out, is_with);\n            }\n            break;\n\n        case OP_drop:\n            if (OPTIMIZE) {\n                /* remove useless drops before return */\n                if (code_match(&cc, pos_next, OP_return_undef, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    break;\n                }\n            }\n            goto no_change;\n\n        case OP_null:\n#if SHORT_OPCODES\n            if (OPTIMIZE) {\n                /* transform null strict_eq into is_null */\n                if (code_match(&cc, pos_next, OP_strict_eq, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    dbuf_putc(&bc_out, OP_is_null);\n                    pos_next = cc.pos;\n                    break;\n                }\n                /* transform null strict_neq if_false/if_true -> is_null if_true/if_false */\n                if (code_match(&cc, pos_next, OP_strict_neq, M2(OP_if_false, OP_if_true), -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    dbuf_putc(&bc_out, OP_is_null);\n                    pos_next = cc.pos;\n                    label = cc.label;\n                    op = cc.op ^ OP_if_false ^ OP_if_true;\n                    goto has_label;\n                }\n            }\n#endif\n            /* fall thru */\n        case OP_push_false:\n        case OP_push_true:\n            if (OPTIMIZE) {\n                val = (op == OP_push_true);\n                if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), -1)) {\n                has_constant_test:\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    if (val == cc.op - OP_if_false) {\n                        /* transform null if_false(l1) -> goto l1 */\n                        /* transform false if_false(l1) -> goto l1 */\n                        /* transform true if_true(l1) -> goto l1 */\n                        pos_next = cc.pos;\n                        op = OP_goto;\n                        label = cc.label;\n                        goto has_goto;\n                    } else {\n                        /* transform null if_true(l1) -> nop */\n                        /* transform false if_true(l1) -> nop */\n                        /* transform true if_false(l1) -> nop */\n                        pos_next = cc.pos;\n                        update_label(s, cc.label, -1);\n                        break;\n                    }\n                }\n            }\n            goto no_change;\n\n        case OP_push_i32:\n            if (OPTIMIZE) {\n                /* transform i32(val) neg -> i32(-val) */\n                val = get_i32(bc_buf + pos + 1);\n                if ((val != INT32_MIN && val != 0)\n                &&  code_match(&cc, pos_next, OP_neg, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    if (code_match(&cc, cc.pos, OP_drop, -1)) {\n                        if (cc.line_num >= 0) line_num = cc.line_num;\n                    } else {\n                        add_pc2line_info(s, bc_out.size, line_num);\n                        push_short_int(&bc_out, -val);\n                    }\n                    pos_next = cc.pos;\n                    break;\n                }\n                /* remove push/drop pairs generated by the parser */\n                if (code_match(&cc, pos_next, OP_drop, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    pos_next = cc.pos;\n                    break;\n                }\n                /* Optimize constant tests: `if (0)`, `if (1)`, `if (!0)`... */\n                if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), -1)) {\n                    val = (val != 0);\n                    goto has_constant_test;\n                }\n                add_pc2line_info(s, bc_out.size, line_num);\n                push_short_int(&bc_out, val);\n                break;\n            }\n            goto no_change;\n\n#if SHORT_OPCODES\n        case OP_push_const:\n        case OP_fclosure:\n            if (OPTIMIZE) {\n                int idx = get_u32(bc_buf + pos + 1);\n                if (idx < 256) {\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    dbuf_putc(&bc_out, OP_push_const8 + op - OP_push_const);\n                    dbuf_putc(&bc_out, idx);\n                    break;\n                }\n            }\n            goto no_change;\n\n        case OP_get_field:\n            if (OPTIMIZE) {\n                JSAtom atom = get_u32(bc_buf + pos + 1);\n                if (atom == JS_ATOM_length) {\n                    JS_FreeAtom(ctx, atom);\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    dbuf_putc(&bc_out, OP_get_length);\n                    break;\n                }\n            }\n            goto no_change;\n#endif\n        case OP_push_atom_value:\n            if (OPTIMIZE) {\n                JSAtom atom = get_u32(bc_buf + pos + 1);\n                /* remove push/drop pairs generated by the parser */\n                if (code_match(&cc, pos_next, OP_drop, -1)) {\n                    JS_FreeAtom(ctx, atom);\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    pos_next = cc.pos;\n                    break;\n                }\n#if SHORT_OPCODES\n                if (atom == JS_ATOM_empty_string) {\n                    JS_FreeAtom(ctx, atom);\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    dbuf_putc(&bc_out, OP_push_empty_string);\n                    break;\n                }\n#endif\n            }\n            goto no_change;\n\n        case OP_to_propkey:\n        case OP_to_propkey2:\n            if (OPTIMIZE) {\n                /* remove redundant to_propkey/to_propkey2 opcodes when storing simple data */\n                if (code_match(&cc, pos_next, M3(OP_get_loc, OP_get_arg, OP_get_var_ref), -1, OP_put_array_el, -1)\n                ||  code_match(&cc, pos_next, M3(OP_push_i32, OP_push_const, OP_push_atom_value), OP_put_array_el, -1)\n                ||  code_match(&cc, pos_next, M4(OP_undefined, OP_null, OP_push_true, OP_push_false), OP_put_array_el, -1)) {\n                    break;\n                }\n            }\n            goto no_change;\n\n        case OP_undefined:\n            if (OPTIMIZE) {\n                /* remove push/drop pairs generated by the parser */\n                if (code_match(&cc, pos_next, OP_drop, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    pos_next = cc.pos;\n                    break;\n                }\n                /* transform undefined return -> return_undefined */\n                if (code_match(&cc, pos_next, OP_return, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    dbuf_putc(&bc_out, OP_return_undef);\n                    pos_next = cc.pos;\n                    break;\n                }\n                /* transform undefined if_true(l1)/if_false(l1) -> nop/goto(l1) */\n                if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), -1)) {\n                    val = 0;\n                    goto has_constant_test;\n                }\n#if SHORT_OPCODES\n                /* transform undefined strict_eq -> is_undefined */\n                if (code_match(&cc, pos_next, OP_strict_eq, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    dbuf_putc(&bc_out, OP_is_undefined);\n                    pos_next = cc.pos;\n                    break;\n                }\n                /* transform undefined strict_neq if_false/if_true -> is_undefined if_true/if_false */\n                if (code_match(&cc, pos_next, OP_strict_neq, M2(OP_if_false, OP_if_true), -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    dbuf_putc(&bc_out, OP_is_undefined);\n                    pos_next = cc.pos;\n                    label = cc.label;\n                    op = cc.op ^ OP_if_false ^ OP_if_true;\n                    goto has_label;\n                }\n#endif\n            }\n            goto no_change;\n\n        case OP_insert2:\n            if (OPTIMIZE) {\n                /* Transformation:\n                   insert2 put_field(a) drop -> put_field(a)\n                   insert2 put_var_strict(a) drop -> put_var_strict(a)\n                */\n                if (code_match(&cc, pos_next, M2(OP_put_field, OP_put_var_strict), OP_drop, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    dbuf_putc(&bc_out, cc.op);\n                    dbuf_put_u32(&bc_out, cc.atom);\n                    pos_next = cc.pos;\n                    break;\n                }\n            }\n            goto no_change;\n\n        case OP_dup:\n            if (OPTIMIZE) {\n                /* Transformation: dup put_x(n) drop -> put_x(n) */\n                int op1, line2 = -1;\n                /* Transformation: dup put_x(n) -> set_x(n) */\n                if (code_match(&cc, pos_next, M3(OP_put_loc, OP_put_arg, OP_put_var_ref), -1, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    op1 = cc.op + 1;  /* put_x -> set_x */\n                    pos_next = cc.pos;\n                    if (code_match(&cc, cc.pos, OP_drop, -1)) {\n                        if (cc.line_num >= 0) line_num = cc.line_num;\n                        op1 -= 1; /* set_x drop -> put_x */\n                        pos_next = cc.pos;\n                        if (code_match(&cc, cc.pos, op1 - 1, cc.idx, -1)) {\n                            line2 = cc.line_num; /* delay line number update */\n                            op1 += 1;   /* put_x(n) get_x(n) -> set_x(n) */\n                            pos_next = cc.pos;\n                        }\n                    }\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    put_short_code(&bc_out, op1, cc.idx);\n                    if (line2 >= 0) line_num = line2;\n                    break;\n                }\n            }\n            goto no_change;\n\n        case OP_get_loc:\n            if (OPTIMIZE) {\n                /* transformation:\n                   get_loc(n) post_dec put_loc(n) drop -> dec_loc(n)\n                   get_loc(n) post_inc put_loc(n) drop -> inc_loc(n)\n                   get_loc(n) dec dup put_loc(n) drop -> dec_loc(n)\n                   get_loc(n) inc dup put_loc(n) drop -> inc_loc(n)\n                 */\n                int idx;\n                idx = get_u16(bc_buf + pos + 1);\n                if (idx >= 256)\n                    goto no_change;\n                if (code_match(&cc, pos_next, M2(OP_post_dec, OP_post_inc), OP_put_loc, idx, OP_drop, -1) ||\n                    code_match(&cc, pos_next, M2(OP_dec, OP_inc), OP_dup, OP_put_loc, idx, OP_drop, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    dbuf_putc(&bc_out, (cc.op == OP_inc || cc.op == OP_post_inc) ? OP_inc_loc : OP_dec_loc);\n                    dbuf_putc(&bc_out, idx);\n                    pos_next = cc.pos;\n                    break;\n                }\n                /* transformation:\n                   get_loc(n) push_atom_value(x) add dup put_loc(n) drop -> push_atom_value(x) add_loc(n)\n                 */\n                if (code_match(&cc, pos_next, OP_push_atom_value, OP_add, OP_dup, OP_put_loc, idx, OP_drop, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    add_pc2line_info(s, bc_out.size, line_num);\n#if SHORT_OPCODES\n                    if (cc.atom == JS_ATOM_empty_string) {\n                        JS_FreeAtom(ctx, cc.atom);\n                        dbuf_putc(&bc_out, OP_push_empty_string);\n                    } else\n#endif\n                    {\n                        dbuf_putc(&bc_out, OP_push_atom_value);\n                        dbuf_put_u32(&bc_out, cc.atom);\n                    }\n                    dbuf_putc(&bc_out, OP_add_loc);\n                    dbuf_putc(&bc_out, idx);\n                    pos_next = cc.pos;\n                    break;\n                }\n                /* transformation:\n                   get_loc(n) push_i32(x) add dup put_loc(n) drop -> push_i32(x) add_loc(n)\n                 */\n                if (code_match(&cc, pos_next, OP_push_i32, OP_add, OP_dup, OP_put_loc, idx, OP_drop, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    push_short_int(&bc_out, cc.label);\n                    dbuf_putc(&bc_out, OP_add_loc);\n                    dbuf_putc(&bc_out, idx);\n                    pos_next = cc.pos;\n                    break;\n                }\n                /* transformation: XXX: also do these:\n                   get_loc(n) get_loc(x) add dup put_loc(n) drop -> get_loc(x) add_loc(n)\n                   get_loc(n) get_arg(x) add dup put_loc(n) drop -> get_arg(x) add_loc(n)\n                   get_loc(n) get_var_ref(x) add dup put_loc(n) drop -> get_var_ref(x) add_loc(n)\n                 */\n                if (code_match(&cc, pos_next, M3(OP_get_loc, OP_get_arg, OP_get_var_ref), -1, OP_add, OP_dup, OP_put_loc, idx, OP_drop, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    put_short_code(&bc_out, cc.op, cc.idx);\n                    dbuf_putc(&bc_out, OP_add_loc);\n                    dbuf_putc(&bc_out, idx);\n                    pos_next = cc.pos;\n                    break;\n                }\n                add_pc2line_info(s, bc_out.size, line_num);\n                put_short_code(&bc_out, op, idx);\n                break;\n            }\n            goto no_change;\n#if SHORT_OPCODES\n        case OP_get_arg:\n        case OP_get_var_ref:\n            if (OPTIMIZE) {\n                int idx;\n                idx = get_u16(bc_buf + pos + 1);\n                add_pc2line_info(s, bc_out.size, line_num);\n                put_short_code(&bc_out, op, idx);\n                break;\n            }\n            goto no_change;\n#endif\n        case OP_put_loc:\n        case OP_put_arg:\n        case OP_put_var_ref:\n            if (OPTIMIZE) {\n                /* transformation: put_x(n) get_x(n) -> set_x(n) */\n                int idx;\n                idx = get_u16(bc_buf + pos + 1);\n                if (code_match(&cc, pos_next, op - 1, idx, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    put_short_code(&bc_out, op + 1, idx);\n                    pos_next = cc.pos;\n                    break;\n                }\n                add_pc2line_info(s, bc_out.size, line_num);\n                put_short_code(&bc_out, op, idx);\n                break;\n            }\n            goto no_change;\n\n        case OP_post_inc:\n        case OP_post_dec:\n            if (OPTIMIZE) {\n                /* transformation:\n                   post_inc put_x drop -> inc put_x\n                   post_inc perm3 put_field drop -> inc put_field\n                   post_inc perm3 put_var_strict drop -> inc put_var_strict\n                   post_inc perm4 put_array_el drop -> inc put_array_el\n                 */\n                int op1, idx;\n                if (code_match(&cc, pos_next, M3(OP_put_loc, OP_put_arg, OP_put_var_ref), -1, OP_drop, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    op1 = cc.op;\n                    idx = cc.idx;\n                    pos_next = cc.pos;\n                    if (code_match(&cc, cc.pos, op1 - 1, idx, -1)) {\n                        if (cc.line_num >= 0) line_num = cc.line_num;\n                        op1 += 1;   /* put_x(n) get_x(n) -> set_x(n) */\n                        pos_next = cc.pos;\n                    }\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    dbuf_putc(&bc_out, OP_dec + (op - OP_post_dec));\n                    put_short_code(&bc_out, op1, idx);\n                    break;\n                }\n                if (code_match(&cc, pos_next, OP_perm3, M2(OP_put_field, OP_put_var_strict), OP_drop, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    dbuf_putc(&bc_out, OP_dec + (op - OP_post_dec));\n                    dbuf_putc(&bc_out, cc.op);\n                    dbuf_put_u32(&bc_out, cc.atom);\n                    pos_next = cc.pos;\n                    break;\n                }\n                if (code_match(&cc, pos_next, OP_perm4, OP_put_array_el, OP_drop, -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    add_pc2line_info(s, bc_out.size, line_num);\n                    dbuf_putc(&bc_out, OP_dec + (op - OP_post_dec));\n                    dbuf_putc(&bc_out, OP_put_array_el);\n                    pos_next = cc.pos;\n                    break;\n                }\n            }\n            goto no_change;\n\n#if SHORT_OPCODES\n        case OP_typeof:\n            if (OPTIMIZE) {\n                /* simplify typeof tests */\n                if (code_match(&cc, pos_next, OP_push_atom_value, M4(OP_strict_eq, OP_strict_neq, OP_eq, OP_neq), -1)) {\n                    if (cc.line_num >= 0) line_num = cc.line_num;\n                    int op1 = (cc.op == OP_strict_eq || cc.op == OP_eq) ? OP_strict_eq : OP_strict_neq;\n                    int op2 = -1;\n                    switch (cc.atom) {\n                    case JS_ATOM_undefined:\n                        op2 = OP_typeof_is_undefined;\n                        break;\n                    case JS_ATOM_function:\n                        op2 = OP_typeof_is_function;\n                        break;\n                    }\n                    if (op2 >= 0) {\n                        /* transform typeof(s) == \"<type>\" into is_<type> */\n                        if (op1 == OP_strict_eq) {\n                            add_pc2line_info(s, bc_out.size, line_num);\n                            dbuf_putc(&bc_out, op2);\n                            JS_FreeAtom(ctx, cc.atom);\n                            pos_next = cc.pos;\n                            break;\n                        }\n                        if (op1 == OP_strict_neq && code_match(&cc, cc.pos, OP_if_false, -1)) {\n                            /* transform typeof(s) != \"<type>\" if_false into is_<type> if_true */\n                            if (cc.line_num >= 0) line_num = cc.line_num;\n                            add_pc2line_info(s, bc_out.size, line_num);\n                            dbuf_putc(&bc_out, op2);\n                            JS_FreeAtom(ctx, cc.atom);\n                            pos_next = cc.pos;\n                            label = cc.label;\n                            op = OP_if_true;\n                            goto has_label;\n                        }\n                    }\n                }\n            }\n            goto no_change;\n#endif\n\n        default:\n        no_change:\n            add_pc2line_info(s, bc_out.size, line_num);\n            dbuf_put(&bc_out, bc_buf + pos, len);\n            break;\n        }\n    }\n\n    /* check that there were no missing labels */\n    for(i = 0; i < s->label_count; i++) {\n        assert(label_slots[i].first_reloc == NULL);\n    }\n#if SHORT_OPCODES\n    if (OPTIMIZE) {\n        /* more jump optimizations */\n        int patch_offsets = 0;\n        for (i = 0, jp = s->jump_slots; i < s->jump_count; i++, jp++) {\n            LabelSlot *ls;\n            JumpSlot *jp1;\n            int j, pos, diff, delta;\n\n            delta = 3;\n            switch (op = jp->op) {\n            case OP_goto16:\n                delta = 1;\n                /* fall thru */\n            case OP_if_false:\n            case OP_if_true:\n            case OP_goto:\n                pos = jp->pos;\n                diff = s->label_slots[jp->label].addr - pos;\n                if (diff >= -128 && diff <= 127 + delta) {\n                    //put_u8(bc_out.buf + pos, diff);\n                    jp->size = 1;\n                    if (op == OP_goto16) {\n                        bc_out.buf[pos - 1] = jp->op = OP_goto8;\n                    } else {\n                        bc_out.buf[pos - 1] = jp->op = OP_if_false8 + (op - OP_if_false);\n                    }\n                    goto shrink;\n                } else\n                if (diff == (int16_t)diff && op == OP_goto) {\n                    //put_u16(bc_out.buf + pos, diff);\n                    jp->size = 2;\n                    delta = 2;\n                    bc_out.buf[pos - 1] = jp->op = OP_goto16;\n                shrink:\n                    /* XXX: should reduce complexity, using 2 finger copy scheme */\n                    memmove(bc_out.buf + pos + jp->size, bc_out.buf + pos + jp->size + delta,\n                            bc_out.size - pos - jp->size - delta);\n                    bc_out.size -= delta;\n                    patch_offsets++;\n                    for (j = 0, ls = s->label_slots; j < s->label_count; j++, ls++) {\n                        if (ls->addr > pos)\n                            ls->addr -= delta;\n                    }\n                    for (j = i + 1, jp1 = jp + 1; j < s->jump_count; j++, jp1++) {\n                        if (jp1->pos > pos)\n                            jp1->pos -= delta;\n                    }\n                    for (j = 0; j < s->line_number_count; j++) {\n                        if (s->line_number_slots[j].pc > pos)\n                            s->line_number_slots[j].pc -= delta;\n                    }\n                    continue;\n                }\n                break;\n            }\n        }\n        if (patch_offsets) {\n            JumpSlot *jp1;\n            int j;\n            for (j = 0, jp1 = s->jump_slots; j < s->jump_count; j++, jp1++) {\n                int diff1 = s->label_slots[jp1->label].addr - jp1->pos;\n                switch (jp1->size) {\n                case 1:\n                    put_u8(bc_out.buf + jp1->pos, diff1);\n                    break;\n                case 2:\n                    put_u16(bc_out.buf + jp1->pos, diff1);\n                    break;\n                case 4:\n                    put_u32(bc_out.buf + jp1->pos, diff1);\n                    break;\n                }\n            }\n        }\n    }\n    js_free(ctx, s->jump_slots);\n    s->jump_slots = NULL;\n#endif\n    js_free(ctx, s->label_slots);\n    s->label_slots = NULL;\n    /* XXX: should delay until copying to runtime bytecode function */\n    compute_pc2line_info(s);\n    js_free(ctx, s->line_number_slots);\n    s->line_number_slots = NULL;\n    /* set the new byte code */\n    dbuf_free(&s->byte_code);\n    s->byte_code = bc_out;\n    s->use_short_opcodes = TRUE;\n    if (dbuf_error(&s->byte_code)) {\n        JS_ThrowOutOfMemory(ctx);\n        return -1;\n    }\n    return 0;\n fail:\n    /* XXX: not safe */\n    dbuf_free(&bc_out);\n    return -1;\n}\n\n/* compute the maximum stack size needed by the function */\n\ntypedef struct StackSizeState {\n    int bc_len;\n    int stack_len_max;\n    uint16_t *stack_level_tab;\n    int *pc_stack;\n    int pc_stack_len;\n    int pc_stack_size;\n} StackSizeState;\n\n/* 'op' is only used for error indication */\nstatic __exception int ss_check(JSContext *ctx, StackSizeState *s,\n                                int pos, int op, int stack_len)\n{\n    if ((unsigned)pos >= s->bc_len) {\n        JS_ThrowInternalError(ctx, \"bytecode buffer overflow (op=%d, pc=%d)\", op, pos);\n        return -1;\n    }\n    if (stack_len > s->stack_len_max) {\n        s->stack_len_max = stack_len;\n        if (s->stack_len_max > JS_STACK_SIZE_MAX) {\n            JS_ThrowInternalError(ctx, \"stack overflow (op=%d, pc=%d)\", op, pos);\n            return -1;\n        }\n    }\n    if (s->stack_level_tab[pos] != 0xffff) {\n        /* already explored: check that the stack size is consistent */\n        if (s->stack_level_tab[pos] != stack_len) {\n            JS_ThrowInternalError(ctx, \"unconsistent stack size: %d %d (pc=%d)\",\n                                  s->stack_level_tab[pos], stack_len, pos);\n            return -1;\n        } else {\n            return 0;\n        }\n    }\n\n    /* mark as explored and store the stack size */\n    s->stack_level_tab[pos] = stack_len;\n\n    /* queue the new PC to explore */\n    if (js_resize_array(ctx, (void **)&s->pc_stack, sizeof(s->pc_stack[0]),\n                        &s->pc_stack_size, s->pc_stack_len + 1))\n        return -1;\n    s->pc_stack[s->pc_stack_len++] = pos;\n    return 0;\n}\n\nstatic __exception int compute_stack_size(JSContext *ctx,\n                                          JSFunctionDef *fd,\n                                          int *pstack_size)\n{\n    StackSizeState s_s, *s = &s_s;\n    int i, diff, n_pop, pos_next, stack_len, pos, op;\n    const JSOpCode *oi;\n    const uint8_t *bc_buf;\n\n    bc_buf = fd->byte_code.buf;\n    s->bc_len = fd->byte_code.size;\n    /* bc_len > 0 */\n    s->stack_level_tab = js_malloc(ctx, sizeof(s->stack_level_tab[0]) *\n                                   s->bc_len);\n    if (!s->stack_level_tab)\n        return -1;\n    for(i = 0; i < s->bc_len; i++)\n        s->stack_level_tab[i] = 0xffff;\n    s->stack_len_max = 0;\n    s->pc_stack = NULL;\n    s->pc_stack_len = 0;\n    s->pc_stack_size = 0;\n\n    /* breadth-first graph exploration */\n    if (ss_check(ctx, s, 0, OP_invalid, 0))\n        goto fail;\n\n    while (s->pc_stack_len > 0) {\n        pos = s->pc_stack[--s->pc_stack_len];\n        stack_len = s->stack_level_tab[pos];\n        op = bc_buf[pos];\n        if (op == 0 || op >= OP_COUNT) {\n            JS_ThrowInternalError(ctx, \"invalid opcode (op=%d, pc=%d)\", op, pos);\n            goto fail;\n        }\n        oi = &short_opcode_info(op);\n        pos_next = pos + oi->size;\n        if (pos_next > s->bc_len) {\n            JS_ThrowInternalError(ctx, \"bytecode buffer overflow (op=%d, pc=%d)\", op, pos);\n            goto fail;\n        }\n        n_pop = oi->n_pop;\n        /* call pops a variable number of arguments */\n        if (oi->fmt == OP_FMT_npop || oi->fmt == OP_FMT_npop_u16) {\n            n_pop += get_u16(bc_buf + pos + 1);\n        } else {\n#if SHORT_OPCODES\n            if (oi->fmt == OP_FMT_npopx) {\n                n_pop += op - OP_call0;\n            }\n#endif\n        }\n\n        if (stack_len < n_pop) {\n            JS_ThrowInternalError(ctx, \"stack underflow (op=%d, pc=%d)\", op, pos);\n            goto fail;\n        }\n        stack_len += oi->n_push - n_pop;\n        if (stack_len > s->stack_len_max) {\n            s->stack_len_max = stack_len;\n            if (s->stack_len_max > JS_STACK_SIZE_MAX) {\n                JS_ThrowInternalError(ctx, \"stack overflow (op=%d, pc=%d)\", op, pos);\n                goto fail;\n            }\n        }\n        switch(op) {\n        case OP_tail_call:\n        case OP_tail_call_method:\n        case OP_return:\n        case OP_return_undef:\n        case OP_return_async:\n        case OP_throw:\n        case OP_throw_error:\n        case OP_ret:\n            goto done_insn;\n        case OP_goto:\n            diff = get_u32(bc_buf + pos + 1);\n            pos_next = pos + 1 + diff;\n            break;\n#if SHORT_OPCODES\n        case OP_goto16:\n            diff = (int16_t)get_u16(bc_buf + pos + 1);\n            pos_next = pos + 1 + diff;\n            break;\n        case OP_goto8:\n            diff = (int8_t)bc_buf[pos + 1];\n            pos_next = pos + 1 + diff;\n            break;\n        case OP_if_true8:\n        case OP_if_false8:\n            diff = (int8_t)bc_buf[pos + 1];\n            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len))\n                goto fail;\n            break;\n#endif\n        case OP_if_true:\n        case OP_if_false:\n        case OP_catch:\n            diff = get_u32(bc_buf + pos + 1);\n            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len))\n                goto fail;\n            break;\n        case OP_gosub:\n            diff = get_u32(bc_buf + pos + 1);\n            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len + 1))\n                goto fail;\n            break;\n        case OP_with_get_var:\n        case OP_with_delete_var:\n            diff = get_u32(bc_buf + pos + 5);\n            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len + 1))\n                goto fail;\n            break;\n        case OP_with_make_ref:\n        case OP_with_get_ref:\n        case OP_with_get_ref_undef:\n            diff = get_u32(bc_buf + pos + 5);\n            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len + 2))\n                goto fail;\n            break;\n        case OP_with_put_var:\n            diff = get_u32(bc_buf + pos + 5);\n            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len - 1))\n                goto fail;\n            break;\n\n        default:\n            break;\n        }\n        if (ss_check(ctx, s, pos_next, op, stack_len))\n            goto fail;\n    done_insn: ;\n    }\n    js_free(ctx, s->stack_level_tab);\n    js_free(ctx, s->pc_stack);\n    *pstack_size = s->stack_len_max;\n    return 0;\n fail:\n    js_free(ctx, s->stack_level_tab);\n    js_free(ctx, s->pc_stack);\n    *pstack_size = 0;\n    return -1;\n}\n\nstatic int add_module_variables(JSContext *ctx, JSFunctionDef *fd)\n{\n    int i, idx;\n    JSModuleDef *m = fd->module;\n    JSExportEntry *me;\n    JSGlobalVar *hf;\n\n    /* The imported global variables were added as closure variables\n       in js_parse_import(). We add here the module global\n       variables. */\n\n    for(i = 0; i < fd->global_var_count; i++) {\n        hf = &fd->global_vars[i];\n        if (add_closure_var(ctx, fd, TRUE, FALSE, i, hf->var_name, hf->is_const,\n                            hf->is_lexical, FALSE) < 0)\n            return -1;\n    }\n\n    /* resolve the variable names of the local exports */\n    for(i = 0; i < m->export_entries_count; i++) {\n        me = &m->export_entries[i];\n        if (me->export_type == JS_EXPORT_TYPE_LOCAL) {\n            idx = find_closure_var(ctx, fd, me->local_name);\n            if (idx < 0) {\n                JS_ThrowSyntaxErrorAtom(ctx, \"exported variable '%s' does not exist\",\n                                        me->local_name);\n                return -1;\n            }\n            me->u.local.var_idx = idx;\n        }\n    }\n    return 0;\n}\n\n/* create a function object from a function definition. The function\n   definition is freed. All the child functions are also created. It\n   must be done this way to resolve all the variables. */\nstatic JSValue js_create_function(JSContext *ctx, JSFunctionDef *fd)\n{\n    JSValue func_obj;\n    JSFunctionBytecode *b;\n    struct list_head *el, *el1;\n    int stack_size, scope, idx;\n    int function_size, byte_code_offset, cpool_offset;\n    int closure_var_offset, vardefs_offset;\n\n    /* recompute scope linkage */\n    for (scope = 0; scope < fd->scope_count; scope++) {\n        fd->scopes[scope].first = -1;\n    }\n    if (fd->has_parameter_expressions) {\n        /* special end of variable list marker for the argument scope */\n        fd->scopes[ARG_SCOPE_INDEX].first = ARG_SCOPE_END;\n    }\n    for (idx = 0; idx < fd->var_count; idx++) {\n        JSVarDef *vd = &fd->vars[idx];\n        vd->scope_next = fd->scopes[vd->scope_level].first;\n        fd->scopes[vd->scope_level].first = idx;\n    }\n    for (scope = 2; scope < fd->scope_count; scope++) {\n        JSVarScope *sd = &fd->scopes[scope];\n        if (sd->first < 0)\n            sd->first = fd->scopes[sd->parent].first;\n    }\n    for (idx = 0; idx < fd->var_count; idx++) {\n        JSVarDef *vd = &fd->vars[idx];\n        if (vd->scope_next < 0 && vd->scope_level > 1) {\n            scope = fd->scopes[vd->scope_level].parent;\n            vd->scope_next = fd->scopes[scope].first;\n        }\n    }\n\n    /* if the function contains an eval call, the closure variables\n       are used to compile the eval and they must be ordered by scope,\n       so it is necessary to create the closure variables before any\n       other variable lookup is done. */\n    if (fd->has_eval_call)\n        add_eval_variables(ctx, fd);\n\n    /* add the module global variables in the closure */\n    if (fd->module) {\n        if (add_module_variables(ctx, fd))\n            goto fail;\n    }\n\n    /* first create all the child functions */\n    list_for_each_safe(el, el1, &fd->child_list) {\n        JSFunctionDef *fd1;\n        int cpool_idx;\n\n        fd1 = list_entry(el, JSFunctionDef, link);\n        cpool_idx = fd1->parent_cpool_idx;\n        func_obj = js_create_function(ctx, fd1);\n        if (JS_IsException(func_obj))\n            goto fail;\n        /* save it in the constant pool */\n        assert(cpool_idx >= 0);\n        fd->cpool[cpool_idx] = func_obj;\n    }\n\n#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 4)\n    if (!(fd->js_mode & JS_MODE_STRIP)) {\n        printf(\"pass 1\\n\");\n        dump_byte_code(ctx, 1, fd->byte_code.buf, fd->byte_code.size,\n                       fd->args, fd->arg_count, fd->vars, fd->var_count,\n                       fd->closure_var, fd->closure_var_count,\n                       fd->cpool, fd->cpool_count, fd->source, fd->line_num,\n                       fd->label_slots, NULL);\n        printf(\"\\n\");\n    }\n#endif\n\n    if (resolve_variables(ctx, fd))\n        goto fail;\n\n#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 2)\n    if (!(fd->js_mode & JS_MODE_STRIP)) {\n        printf(\"pass 2\\n\");\n        dump_byte_code(ctx, 2, fd->byte_code.buf, fd->byte_code.size,\n                       fd->args, fd->arg_count, fd->vars, fd->var_count,\n                       fd->closure_var, fd->closure_var_count,\n                       fd->cpool, fd->cpool_count, fd->source, fd->line_num,\n                       fd->label_slots, NULL);\n        printf(\"\\n\");\n    }\n#endif\n\n    if (resolve_labels(ctx, fd))\n        goto fail;\n\n    if (compute_stack_size(ctx, fd, &stack_size) < 0)\n        goto fail;\n\n    if (fd->js_mode & JS_MODE_STRIP) {\n        function_size = offsetof(JSFunctionBytecode, debug);\n    } else {\n        function_size = sizeof(*b);\n    }\n    cpool_offset = function_size;\n    function_size += fd->cpool_count * sizeof(*fd->cpool);\n    vardefs_offset = function_size;\n    if (!(fd->js_mode & JS_MODE_STRIP) || fd->has_eval_call) {\n        function_size += (fd->arg_count + fd->var_count) * sizeof(*b->vardefs);\n    }\n    closure_var_offset = function_size;\n    function_size += fd->closure_var_count * sizeof(*fd->closure_var);\n    byte_code_offset = function_size;\n    function_size += fd->byte_code.size;\n\n    b = js_mallocz(ctx, function_size);\n    if (!b)\n        goto fail;\n    b->header.ref_count = 1;\n\n    b->byte_code_buf = (void *)((uint8_t*)b + byte_code_offset);\n    b->byte_code_len = fd->byte_code.size;\n    memcpy(b->byte_code_buf, fd->byte_code.buf, fd->byte_code.size);\n    js_free(ctx, fd->byte_code.buf);\n    fd->byte_code.buf = NULL;\n\n    b->func_name = fd->func_name;\n    if (fd->arg_count + fd->var_count > 0) {\n        if ((fd->js_mode & JS_MODE_STRIP) && !fd->has_eval_call) {\n            /* Strip variable definitions not needed at runtime */\n            int i;\n            for(i = 0; i < fd->var_count; i++) {\n                JS_FreeAtom(ctx, fd->vars[i].var_name);\n            }\n            for(i = 0; i < fd->arg_count; i++) {\n                JS_FreeAtom(ctx, fd->args[i].var_name);\n            }\n            for(i = 0; i < fd->closure_var_count; i++) {\n                JS_FreeAtom(ctx, fd->closure_var[i].var_name);\n                fd->closure_var[i].var_name = JS_ATOM_NULL;\n            }\n        } else {\n            b->vardefs = (void *)((uint8_t*)b + vardefs_offset);\n            memcpy(b->vardefs, fd->args, fd->arg_count * sizeof(fd->args[0]));\n            memcpy(b->vardefs + fd->arg_count, fd->vars, fd->var_count * sizeof(fd->vars[0]));\n        }\n        b->var_count = fd->var_count;\n        b->arg_count = fd->arg_count;\n        b->defined_arg_count = fd->defined_arg_count;\n        js_free(ctx, fd->args);\n        js_free(ctx, fd->vars);\n    }\n    b->cpool_count = fd->cpool_count;\n    if (b->cpool_count) {\n        b->cpool = (void *)((uint8_t*)b + cpool_offset);\n        memcpy(b->cpool, fd->cpool, b->cpool_count * sizeof(*b->cpool));\n    }\n    js_free(ctx, fd->cpool);\n    fd->cpool = NULL;\n\n    b->stack_size = stack_size;\n\n    if (fd->js_mode & JS_MODE_STRIP) {\n        JS_FreeAtom(ctx, fd->filename);\n        dbuf_free(&fd->pc2line);    // probably useless\n    } else {\n        /* XXX: source and pc2line info should be packed at the end of the\n           JSFunctionBytecode structure, avoiding allocation overhead\n         */\n        b->has_debug = 1;\n        b->debug.filename = fd->filename;\n        b->debug.line_num = fd->line_num;\n\n        //DynBuf pc2line;\n        //compute_pc2line_info(fd, &pc2line);\n        //js_free(ctx, fd->line_number_slots)\n        b->debug.pc2line_buf = js_realloc(ctx, fd->pc2line.buf, fd->pc2line.size);\n        if (!b->debug.pc2line_buf)\n            b->debug.pc2line_buf = fd->pc2line.buf;\n        b->debug.pc2line_len = fd->pc2line.size;\n        b->debug.source = fd->source;\n        b->debug.source_len = fd->source_len;\n    }\n    if (fd->scopes != fd->def_scope_array)\n        js_free(ctx, fd->scopes);\n\n    b->closure_var_count = fd->closure_var_count;\n    if (b->closure_var_count) {\n        b->closure_var = (void *)((uint8_t*)b + closure_var_offset);\n        memcpy(b->closure_var, fd->closure_var, b->closure_var_count * sizeof(*b->closure_var));\n    }\n    js_free(ctx, fd->closure_var);\n    fd->closure_var = NULL;\n\n    b->has_prototype = fd->has_prototype;\n    b->has_simple_parameter_list = fd->has_simple_parameter_list;\n    b->js_mode = fd->js_mode;\n    b->is_derived_class_constructor = fd->is_derived_class_constructor;\n    b->func_kind = fd->func_kind;\n    b->need_home_object = (fd->home_object_var_idx >= 0 ||\n                           fd->need_home_object);\n    b->new_target_allowed = fd->new_target_allowed;\n    b->super_call_allowed = fd->super_call_allowed;\n    b->super_allowed = fd->super_allowed;\n    b->arguments_allowed = fd->arguments_allowed;\n    b->backtrace_barrier = fd->backtrace_barrier;\n    b->realm = JS_DupContext(ctx);\n\n    add_gc_object(ctx->rt, &b->header, JS_GC_OBJ_TYPE_FUNCTION_BYTECODE);\n    \n#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 1)\n    if (!(fd->js_mode & JS_MODE_STRIP)) {\n        js_dump_function_bytecode(ctx, b);\n    }\n#endif\n\n    if (fd->parent) {\n        /* remove from parent list */\n        list_del(&fd->link);\n    }\n\n    js_free(ctx, fd);\n    return JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, b);\n fail:\n    js_free_function_def(ctx, fd);\n    return JS_EXCEPTION;\n}\n\nstatic void free_function_bytecode(JSRuntime *rt, JSFunctionBytecode *b)\n{\n    int i;\n\n#if 0\n    {\n        char buf[ATOM_GET_STR_BUF_SIZE];\n        printf(\"freeing %s\\n\",\n               JS_AtomGetStrRT(rt, buf, sizeof(buf), b->func_name));\n    }\n#endif\n    free_bytecode_atoms(rt, b->byte_code_buf, b->byte_code_len, TRUE);\n\n    if (b->vardefs) {\n        for(i = 0; i < b->arg_count + b->var_count; i++) {\n            JS_FreeAtomRT(rt, b->vardefs[i].var_name);\n        }\n    }\n    for(i = 0; i < b->cpool_count; i++)\n        JS_FreeValueRT(rt, b->cpool[i]);\n\n    for(i = 0; i < b->closure_var_count; i++) {\n        JSClosureVar *cv = &b->closure_var[i];\n        JS_FreeAtomRT(rt, cv->var_name);\n    }\n    if (b->realm)\n        JS_FreeContext(b->realm);\n\n    JS_FreeAtomRT(rt, b->func_name);\n    if (b->has_debug) {\n        JS_FreeAtomRT(rt, b->debug.filename);\n        js_free_rt(rt, b->debug.pc2line_buf);\n        js_free_rt(rt, b->debug.source);\n#ifdef CONFIG_DEBUGGER\n        if (b->debugger.breakpoints)\n            js_free_rt(rt, b->debugger.breakpoints);\n#endif\n    }\n\n    remove_gc_object(&b->header);\n    if (rt->gc_phase == JS_GC_PHASE_REMOVE_CYCLES && b->header.ref_count != 0) {\n        list_add_tail(&b->header.link, &rt->gc_zero_ref_count_list);\n    } else {\n        js_free_rt(rt, b);\n    }\n}\n\nstatic __exception int js_parse_directives(JSParseState *s)\n{\n    char str[20];\n    JSParsePos pos;\n    BOOL has_semi;\n\n    if (s->token.val != TOK_STRING)\n        return 0;\n\n    js_parse_get_pos(s, &pos);\n\n    while(s->token.val == TOK_STRING) {\n        /* Copy actual source string representation */\n        snprintf(str, sizeof str, \"%.*s\",\n                 (int)(s->buf_ptr - s->token.ptr - 2), s->token.ptr + 1);\n\n        if (next_token(s))\n            return -1;\n\n        has_semi = FALSE;\n        switch (s->token.val) {\n        case ';':\n            if (next_token(s))\n                return -1;\n            has_semi = TRUE;\n            break;\n        case '}':\n        case TOK_EOF:\n            has_semi = TRUE;\n            break;\n        case TOK_NUMBER:\n        case TOK_STRING:\n        case TOK_TEMPLATE:\n        case TOK_IDENT:\n        case TOK_REGEXP:\n        case TOK_DEC:\n        case TOK_INC:\n        case TOK_NULL:\n        case TOK_FALSE:\n        case TOK_TRUE:\n        case TOK_IF:\n        case TOK_RETURN:\n        case TOK_VAR:\n        case TOK_THIS:\n        case TOK_DELETE:\n        case TOK_TYPEOF:\n        case TOK_NEW:\n        case TOK_DO:\n        case TOK_WHILE:\n        case TOK_FOR:\n        case TOK_SWITCH:\n        case TOK_THROW:\n        case TOK_TRY:\n        case TOK_FUNCTION:\n        case TOK_DEBUGGER:\n        case TOK_WITH:\n        case TOK_CLASS:\n        case TOK_CONST:\n        case TOK_ENUM:\n        case TOK_EXPORT:\n        case TOK_IMPORT:\n        case TOK_SUPER:\n        case TOK_INTERFACE:\n        case TOK_LET:\n        case TOK_PACKAGE:\n        case TOK_PRIVATE:\n        case TOK_PROTECTED:\n        case TOK_PUBLIC:\n        case TOK_STATIC:\n            /* automatic insertion of ';' */\n            if (s->got_lf)\n                has_semi = TRUE;\n            break;\n        default:\n            break;\n        }\n        if (!has_semi)\n            break;\n        if (!strcmp(str, \"use strict\")) {\n            s->cur_func->has_use_strict = TRUE;\n            s->cur_func->js_mode |= JS_MODE_STRICT;\n        }\n#if !defined(DUMP_BYTECODE) || !(DUMP_BYTECODE & 8)\n        else if (!strcmp(str, \"use strip\")) {\n            s->cur_func->js_mode |= JS_MODE_STRIP;\n        }\n#endif\n#ifdef CONFIG_BIGNUM\n        else if (s->ctx->bignum_ext && !strcmp(str, \"use math\")) {\n            s->cur_func->js_mode |= JS_MODE_MATH;\n        }\n#endif\n    }\n    return js_parse_seek_token(s, &pos);\n}\n\nstatic int js_parse_function_check_names(JSParseState *s, JSFunctionDef *fd,\n                                         JSAtom func_name)\n{\n    JSAtom name;\n    int i, idx;\n\n    if (fd->js_mode & JS_MODE_STRICT) {\n        if (!fd->has_simple_parameter_list && fd->has_use_strict) {\n            return js_parse_error(s, \"\\\"use strict\\\" not allowed in function with default or destructuring parameter\");\n        }\n        if (func_name == JS_ATOM_eval || func_name == JS_ATOM_arguments) {\n            return js_parse_error(s, \"invalid function name in strict code\");\n        }\n        for (idx = 0; idx < fd->arg_count; idx++) {\n            name = fd->args[idx].var_name;\n\n            if (name == JS_ATOM_eval || name == JS_ATOM_arguments) {\n                return js_parse_error(s, \"invalid argument name in strict code\");\n            }\n        }\n    }\n    /* check async_generator case */\n    if ((fd->js_mode & JS_MODE_STRICT)\n    ||  !fd->has_simple_parameter_list\n    ||  (fd->func_type == JS_PARSE_FUNC_METHOD && fd->func_kind == JS_FUNC_ASYNC)\n    ||  fd->func_type == JS_PARSE_FUNC_ARROW\n    ||  fd->func_type == JS_PARSE_FUNC_METHOD) {\n        for (idx = 0; idx < fd->arg_count; idx++) {\n            name = fd->args[idx].var_name;\n            if (name != JS_ATOM_NULL) {\n                for (i = 0; i < idx; i++) {\n                    if (fd->args[i].var_name == name)\n                        goto duplicate;\n                }\n                /* Check if argument name duplicates a destructuring parameter */\n                /* XXX: should have a flag for such variables */\n                for (i = 0; i < fd->var_count; i++) {\n                    if (fd->vars[i].var_name == name &&\n                        fd->vars[i].scope_level == 0)\n                        goto duplicate;\n                }\n            }\n        }\n    }\n    return 0;\n\nduplicate:\n    return js_parse_error(s, \"duplicate argument names not allowed in this context\");\n}\n\n/* create a function to initialize class fields */\nstatic JSFunctionDef *js_parse_function_class_fields_init(JSParseState *s)\n{\n    JSFunctionDef *fd;\n    \n    fd = js_new_function_def(s->ctx, s->cur_func, FALSE, FALSE,\n                             s->filename, 0);\n    if (!fd)\n        return NULL;\n    fd->func_name = JS_ATOM_NULL;\n    fd->has_prototype = FALSE;\n    fd->has_home_object = TRUE;\n    \n    fd->has_arguments_binding = FALSE;\n    fd->has_this_binding = TRUE;\n    fd->is_derived_class_constructor = FALSE;\n    fd->new_target_allowed = TRUE;\n    fd->super_call_allowed = FALSE;\n    fd->super_allowed = fd->has_home_object;\n    fd->arguments_allowed = FALSE;\n    \n    fd->func_kind = JS_FUNC_NORMAL;\n    fd->func_type = JS_PARSE_FUNC_METHOD;\n    return fd;\n}\n\n/* func_name must be JS_ATOM_NULL for JS_PARSE_FUNC_STATEMENT and\n   JS_PARSE_FUNC_EXPR, JS_PARSE_FUNC_ARROW and JS_PARSE_FUNC_VAR */\nstatic __exception int js_parse_function_decl2(JSParseState *s,\n                                               JSParseFunctionEnum func_type,\n                                               JSFunctionKindEnum func_kind,\n                                               JSAtom func_name,\n                                               const uint8_t *ptr,\n                                               int function_line_num,\n                                               JSParseExportEnum export_flag,\n                                               JSFunctionDef **pfd)\n{\n    JSContext *ctx = s->ctx;\n    JSFunctionDef *fd = s->cur_func;\n    BOOL is_expr;\n    int func_idx, lexical_func_idx = -1;\n    BOOL has_opt_arg;\n    BOOL create_func_var = FALSE;\n\n    is_expr = (func_type != JS_PARSE_FUNC_STATEMENT &&\n               func_type != JS_PARSE_FUNC_VAR);\n\n    if (func_type == JS_PARSE_FUNC_STATEMENT ||\n        func_type == JS_PARSE_FUNC_VAR ||\n        func_type == JS_PARSE_FUNC_EXPR) {\n        if (func_kind == JS_FUNC_NORMAL &&\n            token_is_pseudo_keyword(s, JS_ATOM_async) &&\n            peek_token(s, TRUE) != '\\n') {\n            if (next_token(s))\n                return -1;\n            func_kind = JS_FUNC_ASYNC;\n        }\n        if (next_token(s))\n            return -1;\n        if (s->token.val == '*') {\n            if (next_token(s))\n                return -1;\n            func_kind |= JS_FUNC_GENERATOR;\n        }\n\n        if (s->token.val == TOK_IDENT) {\n            if (s->token.u.ident.is_reserved ||\n                (s->token.u.ident.atom == JS_ATOM_yield &&\n                 func_type == JS_PARSE_FUNC_EXPR &&\n                 (func_kind & JS_FUNC_GENERATOR)) ||\n                (s->token.u.ident.atom == JS_ATOM_await &&\n                 func_type == JS_PARSE_FUNC_EXPR &&\n                 (func_kind & JS_FUNC_ASYNC))) {\n                return js_parse_error_reserved_identifier(s);\n            }\n        }\n        if (s->token.val == TOK_IDENT ||\n            (((s->token.val == TOK_YIELD && !(fd->js_mode & JS_MODE_STRICT)) ||\n             (s->token.val == TOK_AWAIT && !s->is_module)) &&\n             func_type == JS_PARSE_FUNC_EXPR)) {\n            func_name = JS_DupAtom(ctx, s->token.u.ident.atom);\n            if (next_token(s)) {\n                JS_FreeAtom(ctx, func_name);\n                return -1;\n            }\n        } else {\n            if (func_type != JS_PARSE_FUNC_EXPR &&\n                export_flag != JS_PARSE_EXPORT_DEFAULT) {\n                return js_parse_error(s, \"function name expected\");\n            }\n        }\n    } else if (func_type != JS_PARSE_FUNC_ARROW) {\n        func_name = JS_DupAtom(ctx, func_name);\n    }\n\n    if (fd->is_eval && fd->eval_type == JS_EVAL_TYPE_MODULE &&\n        (func_type == JS_PARSE_FUNC_STATEMENT || func_type == JS_PARSE_FUNC_VAR)) {\n        JSGlobalVar *hf;\n        hf = find_global_var(fd, func_name);\n        /* XXX: should check scope chain */\n        if (hf && hf->scope_level == fd->scope_level) {\n            js_parse_error(s, \"invalid redefinition of global identifier in module code\");\n            JS_FreeAtom(ctx, func_name);\n            return -1;\n        }\n    }\n\n    if (func_type == JS_PARSE_FUNC_VAR) {\n        if (!(fd->js_mode & JS_MODE_STRICT)\n        && func_kind == JS_FUNC_NORMAL\n        &&  find_lexical_decl(ctx, fd, func_name, fd->scope_first, FALSE) < 0\n        &&  !((func_idx = find_var(ctx, fd, func_name)) >= 0 && (func_idx & ARGUMENT_VAR_OFFSET))\n        &&  !(func_name == JS_ATOM_arguments && fd->has_arguments_binding)) {\n            create_func_var = TRUE;\n        }\n        /* Create the lexical name here so that the function closure\n           contains it */\n        if (fd->is_eval &&\n            (fd->eval_type == JS_EVAL_TYPE_GLOBAL ||\n             fd->eval_type == JS_EVAL_TYPE_MODULE) &&\n            fd->scope_level == fd->body_scope) {\n            /* avoid creating a lexical variable in the global\n               scope. XXX: check annex B */\n            JSGlobalVar *hf;\n            hf = find_global_var(fd, func_name);\n            /* XXX: should check scope chain */\n            if (hf && hf->scope_level == fd->scope_level) {\n                js_parse_error(s, \"invalid redefinition of global identifier\");\n                JS_FreeAtom(ctx, func_name);\n                return -1;\n            }\n        } else {\n            /* Always create a lexical name, fail if at the same scope as\n               existing name */\n            /* Lexical variable will be initialized upon entering scope */\n            lexical_func_idx = define_var(s, fd, func_name,\n                                          func_kind != JS_FUNC_NORMAL ?\n                                          JS_VAR_DEF_NEW_FUNCTION_DECL :\n                                          JS_VAR_DEF_FUNCTION_DECL);\n            if (lexical_func_idx < 0) {\n                JS_FreeAtom(ctx, func_name);\n                return -1;\n            }\n        }\n    }\n\n    fd = js_new_function_def(ctx, fd, FALSE, is_expr,\n                             s->filename, function_line_num);\n    if (!fd) {\n        JS_FreeAtom(ctx, func_name);\n        return -1;\n    }\n    if (pfd)\n        *pfd = fd;\n    s->cur_func = fd;\n    fd->func_name = func_name;\n    /* XXX: test !fd->is_generator is always false */\n    fd->has_prototype = (func_type == JS_PARSE_FUNC_STATEMENT ||\n                         func_type == JS_PARSE_FUNC_VAR ||\n                         func_type == JS_PARSE_FUNC_EXPR) &&\n                        func_kind == JS_FUNC_NORMAL;\n    fd->has_home_object = (func_type == JS_PARSE_FUNC_METHOD ||\n                           func_type == JS_PARSE_FUNC_GETTER ||\n                           func_type == JS_PARSE_FUNC_SETTER ||\n                           func_type == JS_PARSE_FUNC_CLASS_CONSTRUCTOR ||\n                           func_type == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR);\n    fd->has_arguments_binding = (func_type != JS_PARSE_FUNC_ARROW);\n    fd->has_this_binding = fd->has_arguments_binding;\n    fd->is_derived_class_constructor = (func_type == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR);\n    if (func_type == JS_PARSE_FUNC_ARROW) {\n        fd->new_target_allowed = fd->parent->new_target_allowed;\n        fd->super_call_allowed = fd->parent->super_call_allowed;\n        fd->super_allowed = fd->parent->super_allowed;\n        fd->arguments_allowed = fd->parent->arguments_allowed;\n    } else {\n        fd->new_target_allowed = TRUE;\n        fd->super_call_allowed = fd->is_derived_class_constructor;\n        fd->super_allowed = fd->has_home_object;\n        fd->arguments_allowed = TRUE;\n    }\n\n    /* fd->in_function_body == FALSE prevents yield/await during the parsing\n       of the arguments in generator/async functions. They are parsed as\n       regular identifiers for other function kinds. */\n    fd->func_kind = func_kind;\n    fd->func_type = func_type;\n\n    if (func_type == JS_PARSE_FUNC_CLASS_CONSTRUCTOR ||\n        func_type == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR) {\n        /* error if not invoked as a constructor */\n        emit_op(s, OP_check_ctor);\n    }\n\n    if (func_type == JS_PARSE_FUNC_CLASS_CONSTRUCTOR) {\n        emit_class_field_init(s);\n    }\n    \n    /* parse arguments */\n    fd->has_simple_parameter_list = TRUE;\n    fd->has_parameter_expressions = FALSE;\n    has_opt_arg = FALSE;\n    if (func_type == JS_PARSE_FUNC_ARROW && s->token.val == TOK_IDENT) {\n        JSAtom name;\n        if (s->token.u.ident.is_reserved) {\n            js_parse_error_reserved_identifier(s);\n            goto fail;\n        }\n        name = s->token.u.ident.atom;\n        if (add_arg(ctx, fd, name) < 0)\n            goto fail;\n        fd->defined_arg_count = 1;\n    } else {\n        if (s->token.val == '(') {\n            int skip_bits;\n            /* if there is an '=' inside the parameter list, we\n               consider there is a parameter expression inside */\n            js_parse_skip_parens_token(s, &skip_bits, FALSE);\n            if (skip_bits & SKIP_HAS_ASSIGNMENT)\n                fd->has_parameter_expressions = TRUE;\n            if (next_token(s))\n                goto fail;\n        } else {\n            if (js_parse_expect(s, '('))\n                goto fail;\n        }\n\n        if (fd->has_parameter_expressions) {\n            fd->scope_level = -1; /* force no parent scope */\n            if (push_scope(s) < 0)\n                return -1;\n        }\n        \n        while (s->token.val != ')') {\n            JSAtom name;\n            BOOL rest = FALSE;\n            int idx, has_initializer;\n\n            if (s->token.val == TOK_ELLIPSIS) {\n                fd->has_simple_parameter_list = FALSE;\n                rest = TRUE;\n                if (next_token(s))\n                    goto fail;\n            }\n            if (s->token.val == '[' || s->token.val == '{') {\n                fd->has_simple_parameter_list = FALSE;\n                if (rest) {\n                    emit_op(s, OP_rest);\n                    emit_u16(s, fd->arg_count);\n                } else {\n                    /* unnamed arg for destructuring */\n                    idx = add_arg(ctx, fd, JS_ATOM_NULL);\n                    emit_op(s, OP_get_arg);\n                    emit_u16(s, idx);\n                }\n                has_initializer = js_parse_destructuring_element(s, fd->has_parameter_expressions ? TOK_LET : TOK_VAR, 1, TRUE, -1, TRUE);\n                if (has_initializer < 0)\n                    goto fail;\n                if (has_initializer)\n                    has_opt_arg = TRUE;\n                if (!has_opt_arg)\n                    fd->defined_arg_count++;\n            } else if (s->token.val == TOK_IDENT) {\n                if (s->token.u.ident.is_reserved) {\n                    js_parse_error_reserved_identifier(s);\n                    goto fail;\n                }\n                name = s->token.u.ident.atom;\n                if (name == JS_ATOM_yield && fd->func_kind == JS_FUNC_GENERATOR) {\n                    js_parse_error_reserved_identifier(s);\n                    goto fail;\n                }\n                if (fd->has_parameter_expressions) {\n                    if (define_var(s, fd, name, JS_VAR_DEF_LET) < 0)\n                        goto fail;\n                }\n                /* XXX: could avoid allocating an argument if rest is true */\n                idx = add_arg(ctx, fd, name);\n                if (idx < 0)\n                    goto fail;\n                if (next_token(s))\n                    goto fail;\n                if (rest) {\n                    emit_op(s, OP_rest);\n                    emit_u16(s, idx);\n                    if (fd->has_parameter_expressions) {\n                        emit_op(s, OP_dup);\n                        emit_op(s, OP_scope_put_var_init);\n                        emit_atom(s, name);\n                        emit_u16(s, fd->scope_level);\n                    }\n                    emit_op(s, OP_put_arg);\n                    emit_u16(s, idx);\n                    fd->has_simple_parameter_list = FALSE;\n                    has_opt_arg = TRUE;\n                } else if (s->token.val == '=') {\n                    int label;\n                    \n                    fd->has_simple_parameter_list = FALSE;\n                    has_opt_arg = TRUE;\n\n                    if (next_token(s))\n                        goto fail;\n\n                    label = new_label(s);\n                    emit_op(s, OP_get_arg);\n                    emit_u16(s, idx);\n                    emit_op(s, OP_dup);\n                    emit_op(s, OP_undefined);\n                    emit_op(s, OP_strict_eq);\n                    emit_goto(s, OP_if_false, label);\n                    emit_op(s, OP_drop);\n                    if (js_parse_assign_expr(s))\n                        goto fail;\n                    set_object_name(s, name);\n                    emit_op(s, OP_dup);\n                    emit_op(s, OP_put_arg);\n                    emit_u16(s, idx);\n                    emit_label(s, label);\n                    emit_op(s, OP_scope_put_var_init);\n                    emit_atom(s, name);\n                    emit_u16(s, fd->scope_level);\n                } else {\n                    if (!has_opt_arg) {\n                        fd->defined_arg_count++;\n                    }\n                    if (fd->has_parameter_expressions) {\n                        /* copy the argument to the argument scope */\n                        emit_op(s, OP_get_arg);\n                        emit_u16(s, idx);\n                        emit_op(s, OP_scope_put_var_init);\n                        emit_atom(s, name);\n                        emit_u16(s, fd->scope_level);\n                    }\n                }\n            } else {\n                js_parse_error(s, \"missing formal parameter\");\n                goto fail;\n            }\n            if (rest && s->token.val != ')') {\n                js_parse_expect(s, ')');\n                goto fail;\n            }\n            if (s->token.val == ')')\n                break;\n            if (js_parse_expect(s, ','))\n                goto fail;\n        }\n        if ((func_type == JS_PARSE_FUNC_GETTER && fd->arg_count != 0) ||\n            (func_type == JS_PARSE_FUNC_SETTER && fd->arg_count != 1)) {\n            js_parse_error(s, \"invalid number of arguments for getter or setter\");\n            goto fail;\n        }\n    }\n\n    if (fd->has_parameter_expressions) {\n        int idx;\n\n        /* Copy the variables in the argument scope to the variable\n           scope (see FunctionDeclarationInstantiation() in spec). The\n           normal arguments are already present, so no need to copy\n           them. */\n        idx = fd->scopes[fd->scope_level].first;\n        while (idx >= 0) {\n            JSVarDef *vd = &fd->vars[idx];\n            if (vd->scope_level != fd->scope_level)\n                break;\n            if (find_var(ctx, fd, vd->var_name) < 0) {\n                if (add_var(ctx, fd, vd->var_name) < 0)\n                    goto fail;\n                vd = &fd->vars[idx]; /* fd->vars may have been reallocated */\n                emit_op(s, OP_scope_get_var);\n                emit_atom(s, vd->var_name);\n                emit_u16(s, fd->scope_level);\n                emit_op(s, OP_scope_put_var);\n                emit_atom(s, vd->var_name);\n                emit_u16(s, 0);\n            }\n            idx = vd->scope_next;\n        }\n        \n        /* the argument scope has no parent, hence we don't use pop_scope(s) */\n        emit_op(s, OP_leave_scope);\n        emit_u16(s, fd->scope_level);\n\n        /* set the variable scope as the current scope */\n        fd->scope_level = 0;\n        fd->scope_first = fd->scopes[fd->scope_level].first;\n    }\n    \n    if (next_token(s))\n        goto fail;\n\n    /* generator function: yield after the parameters are evaluated */\n    if (func_kind == JS_FUNC_GENERATOR ||\n        func_kind == JS_FUNC_ASYNC_GENERATOR)\n        emit_op(s, OP_initial_yield);\n\n    /* in generators, yield expression is forbidden during the parsing\n       of the arguments */\n    fd->in_function_body = TRUE;\n    push_scope(s);  /* enter body scope */\n    fd->body_scope = fd->scope_level;\n\n    if (s->token.val == TOK_ARROW) {\n        if (next_token(s))\n            goto fail;\n\n        if (s->token.val != '{') {\n            if (js_parse_function_check_names(s, fd, func_name))\n                goto fail;\n\n            if (js_parse_assign_expr(s))\n                goto fail;\n\n            if (func_kind != JS_FUNC_NORMAL)\n                emit_op(s, OP_return_async);\n            else\n                emit_op(s, OP_return);\n\n            if (!(fd->js_mode & JS_MODE_STRIP)) {\n                /* save the function source code */\n                /* the end of the function source code is after the last\n                   token of the function source stored into s->last_ptr */\n                fd->source_len = s->last_ptr - ptr;\n                fd->source = js_strndup(ctx, (const char *)ptr, fd->source_len);\n                if (!fd->source)\n                    goto fail;\n            }\n            goto done;\n        }\n    }\n\n    if (js_parse_expect(s, '{'))\n        goto fail;\n\n    if (js_parse_directives(s))\n        goto fail;\n\n    /* in strict_mode, check function and argument names */\n    if (js_parse_function_check_names(s, fd, func_name))\n        goto fail;\n\n    while (s->token.val != '}') {\n        if (js_parse_source_element(s))\n            goto fail;\n    }\n    if (!(fd->js_mode & JS_MODE_STRIP)) {\n        /* save the function source code */\n        fd->source_len = s->buf_ptr - ptr;\n        fd->source = js_strndup(ctx, (const char *)ptr, fd->source_len);\n        if (!fd->source)\n            goto fail;\n    }\n\n    if (next_token(s)) {\n        /* consume the '}' */\n        goto fail;\n    }\n\n    /* in case there is no return, add one */\n    if (js_is_live_code(s)) {\n        emit_return(s, FALSE);\n    }\ndone:\n    s->cur_func = fd->parent;\n\n    /* create the function object */\n    {\n        int idx;\n        JSAtom func_name = fd->func_name;\n\n        /* the real object will be set at the end of the compilation */\n        idx = cpool_add(s, JS_NULL);\n        fd->parent_cpool_idx = idx;\n\n        if (is_expr) {\n            /* for constructors, no code needs to be generated here */\n            if (func_type != JS_PARSE_FUNC_CLASS_CONSTRUCTOR &&\n                func_type != JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR) {\n                /* OP_fclosure creates the function object from the bytecode\n                   and adds the scope information */\n                emit_op(s, OP_fclosure);\n                emit_u32(s, idx);\n                if (func_name == JS_ATOM_NULL) {\n                    emit_op(s, OP_set_name);\n                    emit_u32(s, JS_ATOM_NULL);\n                }\n            }\n        } else if (func_type == JS_PARSE_FUNC_VAR) {\n            emit_op(s, OP_fclosure);\n            emit_u32(s, idx);\n            if (create_func_var) {\n                if (s->cur_func->is_global_var) {\n                    JSGlobalVar *hf;\n                    /* the global variable must be defined at the start of the\n                       function */\n                    hf = add_global_var(ctx, s->cur_func, func_name);\n                    if (!hf)\n                        goto fail;\n                    /* it is considered as defined at the top level\n                       (needed for annex B.3.3.4 and B.3.3.5\n                       checks) */\n                    hf->scope_level = 0; \n                    hf->force_init = ((s->cur_func->js_mode & JS_MODE_STRICT) != 0);\n                    /* store directly into global var, bypass lexical scope */\n                    emit_op(s, OP_dup);\n                    emit_op(s, OP_scope_put_var);\n                    emit_atom(s, func_name);\n                    emit_u16(s, 0);\n                } else {\n                    /* do not call define_var to bypass lexical scope check */\n                    func_idx = find_var(ctx, s->cur_func, func_name);\n                    if (func_idx < 0) {\n                        func_idx = add_var(ctx, s->cur_func, func_name);\n                        if (func_idx < 0)\n                            goto fail;\n                    }\n                    /* store directly into local var, bypass lexical catch scope */\n                    emit_op(s, OP_dup);\n                    emit_op(s, OP_scope_put_var);\n                    emit_atom(s, func_name);\n                    emit_u16(s, 0);\n                }\n            }\n            if (lexical_func_idx >= 0) {\n                /* lexical variable will be initialized upon entering scope */\n                s->cur_func->vars[lexical_func_idx].func_pool_idx = idx;\n                emit_op(s, OP_drop);\n            } else {\n                /* store function object into its lexical name */\n                /* XXX: could use OP_put_loc directly */\n                emit_op(s, OP_scope_put_var_init);\n                emit_atom(s, func_name);\n                emit_u16(s, s->cur_func->scope_level);\n            }\n        } else {\n            if (!s->cur_func->is_global_var) {\n                int var_idx = define_var(s, s->cur_func, func_name, JS_VAR_DEF_VAR);\n\n                if (var_idx < 0)\n                    goto fail;\n                /* the variable will be assigned at the top of the function */\n                if (var_idx & ARGUMENT_VAR_OFFSET) {\n                    s->cur_func->args[var_idx - ARGUMENT_VAR_OFFSET].func_pool_idx = idx;\n                } else {\n                    s->cur_func->vars[var_idx].func_pool_idx = idx;\n                }\n            } else {\n                JSAtom func_var_name;\n                JSGlobalVar *hf;\n                if (func_name == JS_ATOM_NULL)\n                    func_var_name = JS_ATOM__default_; /* export default */\n                else\n                    func_var_name = func_name;\n                /* the variable will be assigned at the top of the function */\n                hf = add_global_var(ctx, s->cur_func, func_var_name);\n                if (!hf)\n                    goto fail;\n                hf->cpool_idx = idx;\n                if (export_flag != JS_PARSE_EXPORT_NONE) {\n                    if (!add_export_entry(s, s->cur_func->module, func_var_name,\n                                          export_flag == JS_PARSE_EXPORT_NAMED ? func_var_name : JS_ATOM_default, JS_EXPORT_TYPE_LOCAL))\n                        goto fail;\n                }\n            }\n        }\n    }\n    return 0;\n fail:\n    s->cur_func = fd->parent;\n    js_free_function_def(ctx, fd);\n    if (pfd)\n        *pfd = NULL;\n    return -1;\n}\n\nstatic __exception int js_parse_function_decl(JSParseState *s,\n                                              JSParseFunctionEnum func_type,\n                                              JSFunctionKindEnum func_kind,\n                                              JSAtom func_name,\n                                              const uint8_t *ptr,\n                                              int function_line_num)\n{\n    return js_parse_function_decl2(s, func_type, func_kind, func_name, ptr,\n                                   function_line_num, JS_PARSE_EXPORT_NONE,\n                                   NULL);\n}\n\nstatic __exception int js_parse_program(JSParseState *s)\n{\n    JSFunctionDef *fd = s->cur_func;\n    int idx;\n\n    if (next_token(s))\n        return -1;\n\n    if (js_parse_directives(s))\n        return -1;\n\n    fd->is_global_var = (fd->eval_type == JS_EVAL_TYPE_GLOBAL) ||\n        (fd->eval_type == JS_EVAL_TYPE_MODULE) ||\n        !(fd->js_mode & JS_MODE_STRICT);\n\n    if (!s->is_module) {\n        /* hidden variable for the return value */\n        fd->eval_ret_idx = idx = add_var(s->ctx, fd, JS_ATOM__ret_);\n        if (idx < 0)\n            return -1;\n    }\n\n    while (s->token.val != TOK_EOF) {\n        if (js_parse_source_element(s))\n            return -1;\n    }\n\n    if (!s->is_module) {\n        /* return the value of the hidden variable eval_ret_idx  */\n        emit_op(s, OP_get_loc);\n        emit_u16(s, fd->eval_ret_idx);\n\n        emit_op(s, OP_return);\n    } else {\n        emit_op(s, OP_return_undef);\n    }\n\n    return 0;\n}\n\nstatic void js_parse_init(JSContext *ctx, JSParseState *s,\n                          const char *input, size_t input_len,\n                          const char *filename)\n{\n    memset(s, 0, sizeof(*s));\n    s->ctx = ctx;\n    s->filename = filename;\n    s->line_num = 1;\n    s->buf_ptr = (const uint8_t *)input;\n    s->buf_end = s->buf_ptr + input_len;\n    s->token.val = ' ';\n    s->token.line_num = 1;\n}\n\nstatic JSValue JS_EvalFunctionInternal(JSContext *ctx, JSValue fun_obj,\n                                       JSValueConst this_obj,\n                                       JSVarRef **var_refs, JSStackFrame *sf)\n{\n    JSValue ret_val;\n    uint32_t tag;\n\n    tag = JS_VALUE_GET_TAG(fun_obj);\n    if (tag == JS_TAG_FUNCTION_BYTECODE) {\n        fun_obj = js_closure(ctx, fun_obj, var_refs, sf);\n        ret_val = JS_CallFree(ctx, fun_obj, this_obj, 0, NULL);\n    } else if (tag == JS_TAG_MODULE) {\n        JSModuleDef *m;\n        m = JS_VALUE_GET_PTR(fun_obj);\n        /* the module refcount should be >= 2 */\n        JS_FreeValue(ctx, fun_obj);\n        if (js_create_module_function(ctx, m) < 0)\n            goto fail;\n        if (js_link_module(ctx, m) < 0)\n            goto fail;\n        ret_val = js_evaluate_module(ctx, m);\n        if (JS_IsException(ret_val)) {\n        fail:\n            js_free_modules(ctx, JS_FREE_MODULE_NOT_EVALUATED);\n            return JS_EXCEPTION;\n        }\n    } else {\n        JS_FreeValue(ctx, fun_obj);\n        ret_val = JS_ThrowTypeError(ctx, \"bytecode function expected\");\n    }\n    return ret_val;\n}\n\nJSValue JS_EvalFunction(JSContext *ctx, JSValue fun_obj)\n{\n    return JS_EvalFunctionInternal(ctx, fun_obj, ctx->global_obj, NULL, NULL);\n}\n\nstatic void skip_shebang(JSParseState *s)\n{\n    const uint8_t *p = s->buf_ptr;\n    int c;\n\n    if (p[0] == '#' && p[1] == '!') {\n        p += 2;\n        while (p < s->buf_end) {\n            if (*p == '\\n' || *p == '\\r') {\n                break;\n            } else if (*p >= 0x80) {\n                c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);\n                if (c == CP_LS || c == CP_PS) {\n                    break;\n                } else if (c == -1) {\n                    p++; /* skip invalid UTF-8 */\n                }\n            } else {\n                p++;\n            }\n        }\n        s->buf_ptr = p;\n    }\n}\n\n/* 'input' must be zero terminated i.e. input[input_len] = '\\0'. */\nstatic JSValue __JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,\n                                 const char *input, size_t input_len,\n                                 const char *filename, int flags, int scope_idx)\n{\n    JSParseState s1, *s = &s1;\n    int err, js_mode, eval_type;\n    JSValue fun_obj, ret_val;\n    JSStackFrame *sf;\n    JSVarRef **var_refs;\n    JSFunctionBytecode *b;\n    JSFunctionDef *fd;\n    JSModuleDef *m;\n\n    js_parse_init(ctx, s, input, input_len, filename);\n    skip_shebang(s);\n\n    eval_type = flags & JS_EVAL_TYPE_MASK;\n    m = NULL;\n    if (eval_type == JS_EVAL_TYPE_DIRECT) {\n        JSObject *p;\n        sf = ctx->rt->current_stack_frame;\n        assert(sf != NULL);\n        assert(JS_VALUE_GET_TAG(sf->cur_func) == JS_TAG_OBJECT);\n        p = JS_VALUE_GET_OBJ(sf->cur_func);\n        assert(js_class_has_bytecode(p->class_id));\n        b = p->u.func.function_bytecode;\n        var_refs = p->u.func.var_refs;\n        js_mode = b->js_mode;\n    } else {\n        sf = NULL;\n        b = NULL;\n        var_refs = NULL;\n        js_mode = 0;\n        if (flags & JS_EVAL_FLAG_STRICT)\n            js_mode |= JS_MODE_STRICT;\n        if (flags & JS_EVAL_FLAG_STRIP)\n            js_mode |= JS_MODE_STRIP;\n        if (eval_type == JS_EVAL_TYPE_MODULE) {\n            JSAtom module_name = JS_NewAtom(ctx, filename);\n            if (module_name == JS_ATOM_NULL)\n                return JS_EXCEPTION;\n            m = js_new_module_def(ctx, module_name);\n            if (!m)\n                return JS_EXCEPTION;\n            js_mode |= JS_MODE_STRICT;\n        }\n    }\n    fd = js_new_function_def(ctx, NULL, TRUE, FALSE, filename, 1);\n    if (!fd)\n        goto fail1;\n    s->cur_func = fd;\n    fd->eval_type = eval_type;\n    fd->has_this_binding = (eval_type != JS_EVAL_TYPE_DIRECT);\n    fd->backtrace_barrier = ((flags & JS_EVAL_FLAG_BACKTRACE_BARRIER) != 0);\n    if (eval_type == JS_EVAL_TYPE_DIRECT) {\n        fd->new_target_allowed = b->new_target_allowed;\n        fd->super_call_allowed = b->super_call_allowed;\n        fd->super_allowed = b->super_allowed;\n        fd->arguments_allowed = b->arguments_allowed;\n    } else {\n        fd->new_target_allowed = FALSE;\n        fd->super_call_allowed = FALSE;\n        fd->super_allowed = FALSE;\n        fd->arguments_allowed = TRUE;\n    }\n    fd->js_mode = js_mode;\n    fd->func_name = JS_DupAtom(ctx, JS_ATOM__eval_);\n    if (b) {\n        if (add_closure_variables(ctx, fd, b, scope_idx))\n            goto fail;\n    }\n    fd->module = m;\n    s->is_module = (m != NULL);\n    s->allow_html_comments = !s->is_module;\n\n    push_scope(s); /* body scope */\n    fd->body_scope = fd->scope_level;\n    \n    err = js_parse_program(s);\n    if (err) {\n    fail:\n        free_token(s, &s->token);\n        js_free_function_def(ctx, fd);\n        goto fail1;\n    }\n\n    /* create the function object and all the enclosed functions */\n    fun_obj = js_create_function(ctx, fd);\n    if (JS_IsException(fun_obj))\n        goto fail1;\n    /* Could add a flag to avoid resolution if necessary */\n    if (m) {\n        m->func_obj = fun_obj;\n        if (js_resolve_module(ctx, m) < 0)\n            goto fail1;\n        fun_obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));\n    }\n    if (flags & JS_EVAL_FLAG_COMPILE_ONLY) {\n        ret_val = fun_obj;\n    } else {\n        ret_val = JS_EvalFunctionInternal(ctx, fun_obj, this_obj, var_refs, sf);\n    }\n    return ret_val;\n fail1:\n    /* XXX: should free all the unresolved dependencies */\n    if (m)\n        js_free_module_def(ctx, m);\n    return JS_EXCEPTION;\n}\n\n/* the indirection is needed to make 'eval' optional */\nstatic JSValue JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,\n                               const char *input, size_t input_len,\n                               const char *filename, int flags, int scope_idx)\n{\n    if (unlikely(!ctx->eval_internal)) {\n        return JS_ThrowTypeError(ctx, \"eval is not supported\");\n    }\n    return ctx->eval_internal(ctx, this_obj, input, input_len, filename,\n                              flags, scope_idx);\n}\n\nstatic JSValue JS_EvalObject(JSContext *ctx, JSValueConst this_obj,\n                             JSValueConst val, int flags, int scope_idx)\n{\n    JSValue ret;\n    const char *str;\n    size_t len;\n\n    if (!JS_IsString(val))\n        return JS_DupValue(ctx, val);\n    str = JS_ToCStringLen(ctx, &len, val);\n    if (!str)\n        return JS_EXCEPTION;\n    ret = JS_EvalInternal(ctx, this_obj, str, len, \"<input>\", flags, scope_idx);\n    JS_FreeCString(ctx, str);\n    return ret;\n\n}\n\nJSValue JS_EvalThis(JSContext *ctx, JSValueConst this_obj,\n                    const char *input, size_t input_len,\n                    const char *filename, int eval_flags)\n{\n    int eval_type = eval_flags & JS_EVAL_TYPE_MASK;\n    JSValue ret;\n\n    assert(eval_type == JS_EVAL_TYPE_GLOBAL ||\n           eval_type == JS_EVAL_TYPE_MODULE);\n    ret = JS_EvalInternal(ctx, this_obj, input, input_len, filename,\n                          eval_flags, -1);\n    return ret;\n}\n\nJSValue JS_Eval(JSContext *ctx, const char *input, size_t input_len,\n                const char *filename, int eval_flags)\n{\n    return JS_EvalThis(ctx, ctx->global_obj, input, input_len, filename,\n                       eval_flags);\n}\n\nint JS_ResolveModule(JSContext *ctx, JSValueConst obj)\n{\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_MODULE) {\n        JSModuleDef *m = JS_VALUE_GET_PTR(obj);\n        if (js_resolve_module(ctx, m) < 0) {\n            js_free_modules(ctx, JS_FREE_MODULE_NOT_RESOLVED);\n            return -1;\n        }\n    }\n    return 0;\n}\n\n/*******************************************************************/\n/* object list */\n\ntypedef struct {\n    JSObject *obj;\n    uint32_t hash_next; /* -1 if no next entry */\n} JSObjectListEntry;\n\n/* XXX: reuse it to optimize weak references */\ntypedef struct {\n    JSObjectListEntry *object_tab;\n    int object_count;\n    int object_size;\n    uint32_t *hash_table;\n    uint32_t hash_size;\n} JSObjectList;\n\nstatic void js_object_list_init(JSObjectList *s)\n{\n    memset(s, 0, sizeof(*s));\n}\n\nstatic uint32_t js_object_list_get_hash(JSObject *p, uint32_t hash_size)\n{\n    return ((uintptr_t)p * 3163) & (hash_size - 1);\n}\n\nstatic int js_object_list_resize_hash(JSContext *ctx, JSObjectList *s,\n                                 uint32_t new_hash_size)\n{\n    JSObjectListEntry *e;\n    uint32_t i, h, *new_hash_table;\n\n    new_hash_table = js_malloc(ctx, sizeof(new_hash_table[0]) * new_hash_size);\n    if (!new_hash_table)\n        return -1;\n    js_free(ctx, s->hash_table);\n    s->hash_table = new_hash_table;\n    s->hash_size = new_hash_size;\n    \n    for(i = 0; i < s->hash_size; i++) {\n        s->hash_table[i] = -1;\n    }\n    for(i = 0; i < s->object_count; i++) {\n        e = &s->object_tab[i];\n        h = js_object_list_get_hash(e->obj, s->hash_size); \n        e->hash_next = s->hash_table[h];\n        s->hash_table[h] = i;\n    }\n    return 0;\n}\n\n/* the reference count of 'obj' is not modified. Return 0 if OK, -1 if\n   memory error */\nstatic int js_object_list_add(JSContext *ctx, JSObjectList *s, JSObject *obj)\n{\n    JSObjectListEntry *e;\n    uint32_t h, new_hash_size;\n    \n    if (js_resize_array(ctx, (void *)&s->object_tab,\n                        sizeof(s->object_tab[0]),\n                        &s->object_size, s->object_count + 1))\n        return -1;\n    if (unlikely((s->object_count + 1) >= s->hash_size)) {\n        new_hash_size = max_uint32(s->hash_size, 4);\n        while (new_hash_size <= s->object_count)\n            new_hash_size *= 2;\n        if (js_object_list_resize_hash(ctx, s, new_hash_size))\n            return -1;\n    }\n    e = &s->object_tab[s->object_count++];\n    h = js_object_list_get_hash(obj, s->hash_size); \n    e->obj = obj;\n    e->hash_next = s->hash_table[h];\n    s->hash_table[h] = s->object_count - 1;\n    return 0;\n}\n\n/* return -1 if not present or the object index */\nstatic int js_object_list_find(JSContext *ctx, JSObjectList *s, JSObject *obj)\n{\n    JSObjectListEntry *e;\n    uint32_t h, p;\n\n    /* must test empty size because there is no hash table */\n    if (s->object_count == 0)\n        return -1;\n    h = js_object_list_get_hash(obj, s->hash_size); \n    p = s->hash_table[h];\n    while (p != -1) {\n        e = &s->object_tab[p];\n        if (e->obj == obj)\n            return p;\n        p = e->hash_next;\n    }\n    return -1;\n}\n\nstatic void js_object_list_end(JSContext *ctx, JSObjectList *s)\n{\n    js_free(ctx, s->object_tab);\n    js_free(ctx, s->hash_table);\n}\n\n/*******************************************************************/\n/* binary object writer & reader */\n\ntypedef enum BCTagEnum {\n    BC_TAG_NULL = 1,\n    BC_TAG_UNDEFINED,\n    BC_TAG_BOOL_FALSE,\n    BC_TAG_BOOL_TRUE,\n    BC_TAG_INT32,\n    BC_TAG_FLOAT64,\n    BC_TAG_STRING,\n    BC_TAG_OBJECT,\n    BC_TAG_ARRAY,\n    BC_TAG_BIG_INT,\n    BC_TAG_BIG_FLOAT,\n    BC_TAG_BIG_DECIMAL,\n    BC_TAG_TEMPLATE_OBJECT,\n    BC_TAG_FUNCTION_BYTECODE,\n    BC_TAG_MODULE,\n    BC_TAG_TYPED_ARRAY,\n    BC_TAG_ARRAY_BUFFER,\n    BC_TAG_SHARED_ARRAY_BUFFER,\n    BC_TAG_DATE,\n    BC_TAG_OBJECT_VALUE,\n    BC_TAG_OBJECT_REFERENCE,\n} BCTagEnum;\n\n#ifdef CONFIG_BIGNUM\n#define BC_BASE_VERSION 2\n#else\n#define BC_BASE_VERSION 1\n#endif\n#define BC_BE_VERSION 0x40\n#ifdef WORDS_BIGENDIAN\n#define BC_VERSION (BC_BASE_VERSION | BC_BE_VERSION)\n#else\n#define BC_VERSION BC_BASE_VERSION\n#endif\n\ntypedef struct BCWriterState {\n    JSContext *ctx;\n    DynBuf dbuf;\n    BOOL byte_swap : 8;\n    BOOL allow_bytecode : 8;\n    BOOL allow_sab : 8;\n    BOOL allow_reference : 8;\n    uint32_t first_atom;\n    uint32_t *atom_to_idx;\n    int atom_to_idx_size;\n    JSAtom *idx_to_atom;\n    int idx_to_atom_count;\n    int idx_to_atom_size;\n    uint8_t **sab_tab;\n    int sab_tab_len;\n    int sab_tab_size;\n    /* list of referenced objects (used if allow_reference = TRUE) */\n    JSObjectList object_list;\n} BCWriterState;\n\n#ifdef DUMP_READ_OBJECT\nstatic const char * const bc_tag_str[] = {\n    \"invalid\",\n    \"null\",\n    \"undefined\",\n    \"false\",\n    \"true\",\n    \"int32\",\n    \"float64\",\n    \"string\",\n    \"object\",\n    \"array\",\n    \"bigint\",\n    \"bigfloat\",\n    \"bigdecimal\",\n    \"template\",\n    \"function\",\n    \"module\",\n    \"TypedArray\",\n    \"ArrayBuffer\",\n    \"SharedArrayBuffer\",\n    \"Date\",\n    \"ObjectValue\",\n    \"ObjectReference\",\n};\n#endif\n\nstatic void bc_put_u8(BCWriterState *s, uint8_t v)\n{\n    dbuf_putc(&s->dbuf, v);\n}\n\nstatic void bc_put_u16(BCWriterState *s, uint16_t v)\n{\n    if (s->byte_swap)\n        v = bswap16(v);\n    dbuf_put_u16(&s->dbuf, v);\n}\n\nstatic __maybe_unused void bc_put_u32(BCWriterState *s, uint32_t v)\n{\n    if (s->byte_swap)\n        v = bswap32(v);\n    dbuf_put_u32(&s->dbuf, v);\n}\n\nstatic void bc_put_u64(BCWriterState *s, uint64_t v)\n{\n    if (s->byte_swap)\n        v = bswap64(v);\n    dbuf_put(&s->dbuf, (uint8_t *)&v, sizeof(v));\n}\n\nstatic void bc_put_leb128(BCWriterState *s, uint32_t v)\n{\n    dbuf_put_leb128(&s->dbuf, v);\n}\n\nstatic void bc_put_sleb128(BCWriterState *s, int32_t v)\n{\n    dbuf_put_sleb128(&s->dbuf, v);\n}\n\nstatic void bc_set_flags(uint32_t *pflags, int *pidx, uint32_t val, int n)\n{\n    *pflags = *pflags | (val << *pidx);\n    *pidx += n;\n}\n\nstatic int bc_atom_to_idx(BCWriterState *s, uint32_t *pres, JSAtom atom)\n{\n    uint32_t v;\n\n    if (atom < s->first_atom || __JS_AtomIsTaggedInt(atom)) {\n        *pres = atom;\n        return 0;\n    }\n    atom -= s->first_atom;\n    if (atom < s->atom_to_idx_size && s->atom_to_idx[atom] != 0) {\n        *pres = s->atom_to_idx[atom];\n        return 0;\n    }\n    if (atom >= s->atom_to_idx_size) {\n        int old_size, i;\n        old_size = s->atom_to_idx_size;\n        if (js_resize_array(s->ctx, (void **)&s->atom_to_idx,\n                            sizeof(s->atom_to_idx[0]), &s->atom_to_idx_size,\n                            atom + 1))\n            return -1;\n        /* XXX: could add a specific js_resize_array() function to do it */\n        for(i = old_size; i < s->atom_to_idx_size; i++)\n            s->atom_to_idx[i] = 0;\n    }\n    if (js_resize_array(s->ctx, (void **)&s->idx_to_atom,\n                        sizeof(s->idx_to_atom[0]),\n                        &s->idx_to_atom_size, s->idx_to_atom_count + 1))\n        goto fail;\n\n    v = s->idx_to_atom_count++;\n    s->idx_to_atom[v] = atom + s->first_atom;\n    v += s->first_atom;\n    s->atom_to_idx[atom] = v;\n    *pres = v;\n    return 0;\n fail:\n    *pres = 0;\n    return -1;\n}\n\nstatic int bc_put_atom(BCWriterState *s, JSAtom atom)\n{\n    uint32_t v;\n\n    if (__JS_AtomIsTaggedInt(atom)) {\n        v = (__JS_AtomToUInt32(atom) << 1) | 1;\n    } else {\n        if (bc_atom_to_idx(s, &v, atom))\n            return -1;\n        v <<= 1;\n    }\n    bc_put_leb128(s, v);\n    return 0;\n}\n\nstatic void bc_byte_swap(uint8_t *bc_buf, int bc_len)\n{\n    int pos, len, op, fmt;\n\n    pos = 0;\n    while (pos < bc_len) {\n        op = bc_buf[pos];\n        len = short_opcode_info(op).size;\n        fmt = short_opcode_info(op).fmt;\n        switch(fmt) {\n        case OP_FMT_u16:\n        case OP_FMT_i16:\n        case OP_FMT_label16:\n        case OP_FMT_npop:\n        case OP_FMT_loc:\n        case OP_FMT_arg:\n        case OP_FMT_var_ref:\n            put_u16(bc_buf + pos + 1,\n                    bswap16(get_u16(bc_buf + pos + 1)));\n            break;\n        case OP_FMT_i32:\n        case OP_FMT_u32:\n        case OP_FMT_const:\n        case OP_FMT_label:\n        case OP_FMT_atom:\n        case OP_FMT_atom_u8:\n            put_u32(bc_buf + pos + 1,\n                    bswap32(get_u32(bc_buf + pos + 1)));\n            break;\n        case OP_FMT_atom_u16:\n        case OP_FMT_label_u16:\n            put_u32(bc_buf + pos + 1,\n                    bswap32(get_u32(bc_buf + pos + 1)));\n            put_u16(bc_buf + pos + 1 + 4,\n                    bswap16(get_u16(bc_buf + pos + 1 + 4)));\n            break;\n        case OP_FMT_atom_label_u8:\n        case OP_FMT_atom_label_u16:\n            put_u32(bc_buf + pos + 1,\n                    bswap32(get_u32(bc_buf + pos + 1)));\n            put_u32(bc_buf + pos + 1 + 4,\n                    bswap32(get_u32(bc_buf + pos + 1 + 4)));\n            if (fmt == OP_FMT_atom_label_u16) {\n                put_u16(bc_buf + pos + 1 + 4 + 4,\n                        bswap16(get_u16(bc_buf + pos + 1 + 4 + 4)));\n            }\n            break;\n        case OP_FMT_npop_u16:\n            put_u16(bc_buf + pos + 1,\n                    bswap16(get_u16(bc_buf + pos + 1)));\n            put_u16(bc_buf + pos + 1 + 2,\n                    bswap16(get_u16(bc_buf + pos + 1 + 2)));\n            break;\n        default:\n            break;\n        }\n        pos += len;\n    }\n}\n\nstatic int JS_WriteFunctionBytecode(BCWriterState *s,\n                                    const uint8_t *bc_buf1, int bc_len)\n{\n    int pos, len, op;\n    JSAtom atom;\n    uint8_t *bc_buf;\n    uint32_t val;\n\n    bc_buf = js_malloc(s->ctx, bc_len);\n    if (!bc_buf)\n        return -1;\n    memcpy(bc_buf, bc_buf1, bc_len);\n\n    pos = 0;\n    while (pos < bc_len) {\n        op = bc_buf[pos];\n        len = short_opcode_info(op).size;\n        switch(short_opcode_info(op).fmt) {\n        case OP_FMT_atom:\n        case OP_FMT_atom_u8:\n        case OP_FMT_atom_u16:\n        case OP_FMT_atom_label_u8:\n        case OP_FMT_atom_label_u16:\n            atom = get_u32(bc_buf + pos + 1);\n            if (bc_atom_to_idx(s, &val, atom))\n                goto fail;\n            put_u32(bc_buf + pos + 1, val);\n            break;\n        default:\n            break;\n        }\n        pos += len;\n    }\n\n    if (s->byte_swap)\n        bc_byte_swap(bc_buf, bc_len);\n\n    dbuf_put(&s->dbuf, bc_buf, bc_len);\n\n    js_free(s->ctx, bc_buf);\n    return 0;\n fail:\n    js_free(s->ctx, bc_buf);\n    return -1;\n}\n\nstatic void JS_WriteString(BCWriterState *s, JSString *p)\n{\n    int i;\n    bc_put_leb128(s, ((uint32_t)p->len << 1) | p->is_wide_char);\n    if (p->is_wide_char) {\n        for(i = 0; i < p->len; i++)\n            bc_put_u16(s, p->u.str16[i]);\n    } else {\n        dbuf_put(&s->dbuf, p->u.str8, p->len);\n    }\n}\n\n#ifdef CONFIG_BIGNUM\nstatic int JS_WriteBigNum(BCWriterState *s, JSValueConst obj)\n{\n    uint32_t tag, tag1;\n    int64_t e;\n    JSBigFloat *bf = JS_VALUE_GET_PTR(obj);\n    bf_t *a = &bf->num;\n    size_t len, i, n1, j;\n    limb_t v;\n\n    tag = JS_VALUE_GET_TAG(obj);\n    switch(tag) {\n    case JS_TAG_BIG_INT:\n        tag1 = BC_TAG_BIG_INT;\n        break;\n    case JS_TAG_BIG_FLOAT:\n        tag1 = BC_TAG_BIG_FLOAT;\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        tag1 = BC_TAG_BIG_DECIMAL;\n        break;\n    default:\n        abort();\n    }\n    bc_put_u8(s, tag1);\n\n    /* sign + exponent */\n    if (a->expn == BF_EXP_ZERO)\n        e = 0;\n    else if (a->expn == BF_EXP_INF)\n        e = 1;\n    else if (a->expn == BF_EXP_NAN)\n        e = 2;\n    else if (a->expn >= 0)\n        e = a->expn + 3;\n    else\n        e = a->expn;\n    e = (e << 1) | a->sign;\n    if (e < INT32_MIN || e > INT32_MAX) {\n        JS_ThrowInternalError(s->ctx, \"bignum exponent is too large\");\n        return -1;\n    }\n    bc_put_sleb128(s, e);\n\n    /* mantissa */\n    if (a->len != 0) {\n        if (tag != JS_TAG_BIG_DECIMAL) {\n            i = 0;\n            while (i < a->len && a->tab[i] == 0)\n                i++;\n            assert(i < a->len);\n            v = a->tab[i];\n            n1 = sizeof(limb_t);\n            while ((v & 0xff) == 0) {\n                n1--;\n                v >>= 8;\n            }\n            i++;\n            len = (a->len - i) * sizeof(limb_t) + n1;\n            if (len > INT32_MAX) {\n                JS_ThrowInternalError(s->ctx, \"bignum is too large\");\n                return -1;\n            }\n            bc_put_leb128(s, len);\n            /* always saved in byte based little endian representation */\n            for(j = 0; j < n1; j++) {\n                dbuf_putc(&s->dbuf, v >> (j * 8));\n            }\n            for(; i < a->len; i++) {\n                limb_t v = a->tab[i];\n#if LIMB_BITS == 32\n#ifdef WORDS_BIGENDIAN\n                v = bswap32(v);\n#endif\n                dbuf_put_u32(&s->dbuf, v);\n#else\n#ifdef WORDS_BIGENDIAN\n                v = bswap64(v);\n#endif\n                dbuf_put_u64(&s->dbuf, v);\n#endif\n            }\n        } else {\n            int bpos, d;\n            uint8_t v8;\n            size_t i0;\n            \n            /* little endian BCD */\n            i = 0;\n            while (i < a->len && a->tab[i] == 0)\n                i++;\n            assert(i < a->len);\n            len = a->len * LIMB_DIGITS;\n            v = a->tab[i];\n            j = 0;\n            while ((v % 10) == 0) {\n                j++;\n                v /= 10;\n            }\n            len -= j;\n            assert(len > 0);\n            if (len > INT32_MAX) {\n                JS_ThrowInternalError(s->ctx, \"bignum is too large\");\n                return -1;\n            }\n            bc_put_leb128(s, len);\n            \n            bpos = 0;\n            v8 = 0;\n            i0 = i;\n            for(; i < a->len; i++) {\n                if (i != i0) {\n                    v = a->tab[i];\n                    j = 0;\n                }\n                for(; j < LIMB_DIGITS; j++) {\n                    d = v % 10;\n                    v /= 10;\n                    if (bpos == 0) {\n                        v8 = d;\n                        bpos = 1;\n                    } else {\n                        dbuf_putc(&s->dbuf, v8 | (d << 4));\n                        bpos = 0;\n                    }\n                }\n            }\n            /* flush the last digit */\n            if (bpos) {\n                dbuf_putc(&s->dbuf, v8);\n            }\n        }\n    }\n    return 0;\n}\n#endif /* CONFIG_BIGNUM */\n\nstatic int JS_WriteObjectRec(BCWriterState *s, JSValueConst obj);\n\nstatic int JS_WriteFunctionTag(BCWriterState *s, JSValueConst obj)\n{\n    JSFunctionBytecode *b = JS_VALUE_GET_PTR(obj);\n    uint32_t flags;\n    int idx, i;\n    \n    bc_put_u8(s, BC_TAG_FUNCTION_BYTECODE);\n    flags = idx = 0;\n    bc_set_flags(&flags, &idx, b->has_prototype, 1);\n    bc_set_flags(&flags, &idx, b->has_simple_parameter_list, 1);\n    bc_set_flags(&flags, &idx, b->is_derived_class_constructor, 1);\n    bc_set_flags(&flags, &idx, b->need_home_object, 1);\n    bc_set_flags(&flags, &idx, b->func_kind, 2);\n    bc_set_flags(&flags, &idx, b->new_target_allowed, 1);\n    bc_set_flags(&flags, &idx, b->super_call_allowed, 1);\n    bc_set_flags(&flags, &idx, b->super_allowed, 1);\n    bc_set_flags(&flags, &idx, b->arguments_allowed, 1);\n    bc_set_flags(&flags, &idx, b->has_debug, 1);\n    bc_set_flags(&flags, &idx, b->backtrace_barrier, 1);\n    assert(idx <= 16);\n    bc_put_u16(s, flags);\n    bc_put_u8(s, b->js_mode);\n    bc_put_atom(s, b->func_name);\n    \n    bc_put_leb128(s, b->arg_count);\n    bc_put_leb128(s, b->var_count);\n    bc_put_leb128(s, b->defined_arg_count);\n    bc_put_leb128(s, b->stack_size);\n    bc_put_leb128(s, b->closure_var_count);\n    bc_put_leb128(s, b->cpool_count);\n    bc_put_leb128(s, b->byte_code_len);\n    if (b->vardefs) {\n        /* XXX: this field is redundant */\n        bc_put_leb128(s, b->arg_count + b->var_count);\n        for(i = 0; i < b->arg_count + b->var_count; i++) {\n            JSVarDef *vd = &b->vardefs[i];\n            bc_put_atom(s, vd->var_name);\n            bc_put_leb128(s, vd->scope_level);\n            bc_put_leb128(s, vd->scope_next + 1);\n            flags = idx = 0;\n            bc_set_flags(&flags, &idx, vd->var_kind, 4);\n            bc_set_flags(&flags, &idx, vd->is_const, 1);\n            bc_set_flags(&flags, &idx, vd->is_lexical, 1);\n            bc_set_flags(&flags, &idx, vd->is_captured, 1);\n            assert(idx <= 8);\n            bc_put_u8(s, flags);\n        }\n    } else {\n        bc_put_leb128(s, 0);\n    }\n    \n    for(i = 0; i < b->closure_var_count; i++) {\n        JSClosureVar *cv = &b->closure_var[i];\n        bc_put_atom(s, cv->var_name);\n        bc_put_leb128(s, cv->var_idx);\n        flags = idx = 0;\n        bc_set_flags(&flags, &idx, cv->is_local, 1);\n        bc_set_flags(&flags, &idx, cv->is_arg, 1);\n        bc_set_flags(&flags, &idx, cv->is_const, 1);\n        bc_set_flags(&flags, &idx, cv->is_lexical, 1);\n        bc_set_flags(&flags, &idx, cv->var_kind, 4);\n        assert(idx <= 8);\n        bc_put_u8(s, flags);\n    }\n    \n    if (JS_WriteFunctionBytecode(s, b->byte_code_buf, b->byte_code_len))\n        goto fail;\n    \n    if (b->has_debug) {\n        bc_put_atom(s, b->debug.filename);\n        bc_put_leb128(s, b->debug.line_num);\n        bc_put_leb128(s, b->debug.pc2line_len);\n        dbuf_put(&s->dbuf, b->debug.pc2line_buf, b->debug.pc2line_len);\n    }\n    \n    for(i = 0; i < b->cpool_count; i++) {\n        if (JS_WriteObjectRec(s, b->cpool[i]))\n            goto fail;\n    }\n    return 0;\n fail:\n    return -1;\n}\n\nstatic int JS_WriteModule(BCWriterState *s, JSValueConst obj)\n{\n    JSModuleDef *m = JS_VALUE_GET_PTR(obj);\n    int i;\n    \n    bc_put_u8(s, BC_TAG_MODULE);\n    bc_put_atom(s, m->module_name);\n    \n    bc_put_leb128(s, m->req_module_entries_count);\n    for(i = 0; i < m->req_module_entries_count; i++) {\n        JSReqModuleEntry *rme = &m->req_module_entries[i];\n        bc_put_atom(s, rme->module_name);\n    }\n    \n    bc_put_leb128(s, m->export_entries_count);\n    for(i = 0; i < m->export_entries_count; i++) {\n        JSExportEntry *me = &m->export_entries[i];\n        bc_put_u8(s, me->export_type);\n        if (me->export_type == JS_EXPORT_TYPE_LOCAL) {\n            bc_put_leb128(s, me->u.local.var_idx);\n        } else {\n            bc_put_leb128(s, me->u.req_module_idx);\n            bc_put_atom(s, me->local_name);\n        }\n        bc_put_atom(s, me->export_name);\n    }\n    \n    bc_put_leb128(s, m->star_export_entries_count);\n    for(i = 0; i < m->star_export_entries_count; i++) {\n        JSStarExportEntry *se = &m->star_export_entries[i];\n        bc_put_leb128(s, se->req_module_idx);\n    }\n    \n    bc_put_leb128(s, m->import_entries_count);\n    for(i = 0; i < m->import_entries_count; i++) {\n        JSImportEntry *mi = &m->import_entries[i];\n        bc_put_leb128(s, mi->var_idx);\n        bc_put_atom(s, mi->import_name);\n        bc_put_leb128(s, mi->req_module_idx);\n    }\n    \n    if (JS_WriteObjectRec(s, m->func_obj))\n        goto fail;\n    return 0;\n fail:\n    return -1;\n}\n\nstatic int JS_WriteArray(BCWriterState *s, JSValueConst obj)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(obj);\n    uint32_t i, len;\n    JSValue val;\n    int ret;\n    BOOL is_template;\n    \n    if (s->allow_bytecode && !p->extensible) {\n        /* not extensible array: we consider it is a\n           template when we are saving bytecode */\n        bc_put_u8(s, BC_TAG_TEMPLATE_OBJECT);\n        is_template = TRUE;\n    } else {\n        bc_put_u8(s, BC_TAG_ARRAY);\n        is_template = FALSE;\n    }\n    if (js_get_length32(s->ctx, &len, obj))\n        goto fail1;\n    bc_put_leb128(s, len);\n    for(i = 0; i < len; i++) {\n        val = JS_GetPropertyUint32(s->ctx, obj, i);\n        if (JS_IsException(val))\n            goto fail1;\n        ret = JS_WriteObjectRec(s, val);\n        JS_FreeValue(s->ctx, val);\n        if (ret)\n            goto fail1;\n    }\n    if (is_template) {\n        val = JS_GetProperty(s->ctx, obj, JS_ATOM_raw);\n        if (JS_IsException(val))\n            goto fail1;\n        ret = JS_WriteObjectRec(s, val);\n        JS_FreeValue(s->ctx, val);\n        if (ret)\n            goto fail1;\n    }\n    return 0;\n fail1:\n    return -1;\n}\n\nstatic int JS_WriteObjectTag(BCWriterState *s, JSValueConst obj)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(obj);\n    uint32_t i, prop_count;\n    JSShape *sh;\n    JSShapeProperty *pr;\n    int pass;\n    JSAtom atom;\n\n    bc_put_u8(s, BC_TAG_OBJECT);\n    prop_count = 0;\n    sh = p->shape;\n    for(pass = 0; pass < 2; pass++) {\n        if (pass == 1)\n            bc_put_leb128(s, prop_count);\n        for(i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {\n            atom = pr->atom;\n            if (atom != JS_ATOM_NULL &&\n                JS_AtomIsString(s->ctx, atom) &&\n                (pr->flags & JS_PROP_ENUMERABLE)) {\n                if (pr->flags & JS_PROP_TMASK) {\n                    JS_ThrowTypeError(s->ctx, \"only value properties are supported\");\n                    goto fail;\n                }\n                if (pass == 0) {\n                    prop_count++;\n                } else {\n                    bc_put_atom(s, atom);\n                    if (JS_WriteObjectRec(s, p->prop[i].u.value))\n                        goto fail;\n                }\n            }\n        }\n    }\n    return 0;\n fail:\n    return -1;\n}\n\nstatic int JS_WriteTypedArray(BCWriterState *s, JSValueConst obj)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(obj);\n    JSTypedArray *ta = p->u.typed_array;\n\n    bc_put_u8(s, BC_TAG_TYPED_ARRAY);\n    bc_put_u8(s, p->class_id - JS_CLASS_UINT8C_ARRAY);\n    bc_put_leb128(s, p->u.array.count);\n    bc_put_leb128(s, ta->offset);\n    if (JS_WriteObjectRec(s, JS_MKPTR(JS_TAG_OBJECT, ta->buffer)))\n        return -1;\n    return 0;\n}\n\nstatic int JS_WriteArrayBuffer(BCWriterState *s, JSValueConst obj)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(obj);\n    JSArrayBuffer *abuf = p->u.array_buffer;\n    if (abuf->detached) {\n        JS_ThrowTypeErrorDetachedArrayBuffer(s->ctx);\n        return -1;\n    }\n    bc_put_u8(s, BC_TAG_ARRAY_BUFFER);\n    bc_put_leb128(s, abuf->byte_length);\n    dbuf_put(&s->dbuf, abuf->data, abuf->byte_length);\n    return 0;\n}\n\nstatic int JS_WriteSharedArrayBuffer(BCWriterState *s, JSValueConst obj)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(obj);\n    JSArrayBuffer *abuf = p->u.array_buffer;\n    assert(!abuf->detached); /* SharedArrayBuffer are never detached */\n    bc_put_u8(s, BC_TAG_SHARED_ARRAY_BUFFER);\n    bc_put_leb128(s, abuf->byte_length);\n    bc_put_u64(s, (uintptr_t)abuf->data);\n    if (js_resize_array(s->ctx, (void **)&s->sab_tab, sizeof(s->sab_tab[0]),\n                        &s->sab_tab_size, s->sab_tab_len + 1))\n        return -1;\n    /* keep the SAB pointer so that the user can clone it or free it */\n    s->sab_tab[s->sab_tab_len++] = abuf->data;\n    return 0;\n}\n\nstatic int JS_WriteObjectRec(BCWriterState *s, JSValueConst obj)\n{\n    uint32_t tag;\n\n    if (js_check_stack_overflow(s->ctx->rt, 0)) {\n        JS_ThrowStackOverflow(s->ctx);\n        return -1;\n    }\n\n    tag = JS_VALUE_GET_NORM_TAG(obj);\n    switch(tag) {\n    case JS_TAG_NULL:\n        bc_put_u8(s, BC_TAG_NULL);\n        break;\n    case JS_TAG_UNDEFINED:\n        bc_put_u8(s, BC_TAG_UNDEFINED);\n        break;\n    case JS_TAG_BOOL:\n        bc_put_u8(s, BC_TAG_BOOL_FALSE + JS_VALUE_GET_INT(obj));\n        break;\n    case JS_TAG_INT:\n        bc_put_u8(s, BC_TAG_INT32);\n        bc_put_sleb128(s, JS_VALUE_GET_INT(obj));\n        break;\n    case JS_TAG_FLOAT64:\n        {\n            JSFloat64Union u;\n            bc_put_u8(s, BC_TAG_FLOAT64);\n            u.d = JS_VALUE_GET_FLOAT64(obj);\n            bc_put_u64(s, u.u64);\n        }\n        break;\n    case JS_TAG_STRING:\n        {\n            JSString *p = JS_VALUE_GET_STRING(obj);\n            bc_put_u8(s, BC_TAG_STRING);\n            JS_WriteString(s, p);\n        }\n        break;\n    case JS_TAG_FUNCTION_BYTECODE:\n        if (!s->allow_bytecode)\n            goto invalid_tag;\n        if (JS_WriteFunctionTag(s, obj))\n            goto fail;\n        break;\n    case JS_TAG_MODULE:\n        if (!s->allow_bytecode)\n            goto invalid_tag;\n        if (JS_WriteModule(s, obj))\n            goto fail;\n        break;\n    case JS_TAG_OBJECT:\n        {\n            JSObject *p = JS_VALUE_GET_OBJ(obj);\n            int ret, idx;\n            \n            if (s->allow_reference) {\n                idx = js_object_list_find(s->ctx, &s->object_list, p);\n                if (idx >= 0) {\n                    bc_put_u8(s, BC_TAG_OBJECT_REFERENCE);\n                    bc_put_leb128(s, idx);\n                    break;\n                } else {\n                    if (js_object_list_add(s->ctx, &s->object_list, p))\n                        goto fail;\n                }\n            } else {\n                if (p->tmp_mark) {\n                    JS_ThrowTypeError(s->ctx, \"circular reference\");\n                    goto fail;\n                }\n                p->tmp_mark = 1;\n            }\n            switch(p->class_id) {\n            case JS_CLASS_ARRAY:\n                ret = JS_WriteArray(s, obj);\n                break;\n            case JS_CLASS_OBJECT:\n                ret = JS_WriteObjectTag(s, obj);\n                break;\n            case JS_CLASS_ARRAY_BUFFER:\n                ret = JS_WriteArrayBuffer(s, obj);\n                break;\n            case JS_CLASS_SHARED_ARRAY_BUFFER:\n                if (!s->allow_sab)\n                    goto invalid_tag;\n                ret = JS_WriteSharedArrayBuffer(s, obj);\n                break;\n            case JS_CLASS_DATE:\n                bc_put_u8(s, BC_TAG_DATE);\n                ret = JS_WriteObjectRec(s, p->u.object_data);\n                break;\n            case JS_CLASS_NUMBER:\n            case JS_CLASS_STRING:\n            case JS_CLASS_BOOLEAN:\n#ifdef CONFIG_BIGNUM\n            case JS_CLASS_BIG_INT:\n            case JS_CLASS_BIG_FLOAT:\n            case JS_CLASS_BIG_DECIMAL:\n#endif\n                bc_put_u8(s, BC_TAG_OBJECT_VALUE);\n                ret = JS_WriteObjectRec(s, p->u.object_data);\n                break;\n            default:\n                if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n                    p->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n                    ret = JS_WriteTypedArray(s, obj);\n                } else {\n                    JS_ThrowTypeError(s->ctx, \"unsupported object class\");\n                    ret = -1;\n                }\n                break;\n            }\n            p->tmp_mark = 0;\n            if (ret)\n                goto fail;\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n    case JS_TAG_BIG_FLOAT:\n    case JS_TAG_BIG_DECIMAL:\n        if (JS_WriteBigNum(s, obj))\n            goto fail;\n        break;\n#endif\n    default:\n    invalid_tag:\n        JS_ThrowInternalError(s->ctx, \"unsupported tag (%d)\", tag);\n        goto fail;\n    }\n    return 0;\n\n fail:\n    return -1;\n}\n\n/* create the atom table */\nstatic int JS_WriteObjectAtoms(BCWriterState *s)\n{\n    JSRuntime *rt = s->ctx->rt;\n    DynBuf dbuf1;\n    int i, atoms_size;\n    uint8_t version;\n\n    dbuf1 = s->dbuf;\n    js_dbuf_init(s->ctx, &s->dbuf);\n\n    version = BC_VERSION;\n    if (s->byte_swap)\n        version ^= BC_BE_VERSION;\n    bc_put_u8(s, version);\n\n    bc_put_leb128(s, s->idx_to_atom_count);\n    for(i = 0; i < s->idx_to_atom_count; i++) {\n        JSAtomStruct *p = rt->atom_array[s->idx_to_atom[i]];\n        JS_WriteString(s, p);\n    }\n    /* XXX: should check for OOM in above phase */\n\n    /* move the atoms at the start */\n    /* XXX: could just append dbuf1 data, but it uses more memory if\n       dbuf1 is larger than dbuf */\n    atoms_size = s->dbuf.size;\n    if (dbuf_realloc(&dbuf1, dbuf1.size + atoms_size))\n        goto fail;\n    memmove(dbuf1.buf + atoms_size, dbuf1.buf, dbuf1.size);\n    memcpy(dbuf1.buf, s->dbuf.buf, atoms_size);\n    dbuf1.size += atoms_size;\n    dbuf_free(&s->dbuf);\n    s->dbuf = dbuf1;\n    return 0;\n fail:\n    dbuf_free(&dbuf1);\n    return -1;\n}\n\nuint8_t *JS_WriteObject2(JSContext *ctx, size_t *psize, JSValueConst obj,\n                         int flags, uint8_t ***psab_tab, size_t *psab_tab_len)\n{\n    BCWriterState ss, *s = &ss;\n\n    memset(s, 0, sizeof(*s));\n    s->ctx = ctx;\n    /* XXX: byte swapped output is untested */\n    s->byte_swap = ((flags & JS_WRITE_OBJ_BSWAP) != 0);\n    s->allow_bytecode = ((flags & JS_WRITE_OBJ_BYTECODE) != 0);\n    s->allow_sab = ((flags & JS_WRITE_OBJ_SAB) != 0);\n    s->allow_reference = ((flags & JS_WRITE_OBJ_REFERENCE) != 0);\n    /* XXX: could use a different version when bytecode is included */\n    if (s->allow_bytecode)\n        s->first_atom = JS_ATOM_END;\n    else\n        s->first_atom = 1;\n    js_dbuf_init(ctx, &s->dbuf);\n    js_object_list_init(&s->object_list);\n    \n    if (JS_WriteObjectRec(s, obj))\n        goto fail;\n    if (JS_WriteObjectAtoms(s))\n        goto fail;\n    js_object_list_end(ctx, &s->object_list);\n    js_free(ctx, s->atom_to_idx);\n    js_free(ctx, s->idx_to_atom);\n    *psize = s->dbuf.size;\n    if (psab_tab)\n        *psab_tab = s->sab_tab;\n    if (psab_tab_len)\n        *psab_tab_len = s->sab_tab_len;\n    return s->dbuf.buf;\n fail:\n    js_object_list_end(ctx, &s->object_list);\n    js_free(ctx, s->atom_to_idx);\n    js_free(ctx, s->idx_to_atom);\n    dbuf_free(&s->dbuf);\n    *psize = 0;\n    if (psab_tab)\n        *psab_tab = NULL;\n    if (psab_tab_len)\n        *psab_tab_len = 0;\n    return NULL;\n}\n\nuint8_t *JS_WriteObject(JSContext *ctx, size_t *psize, JSValueConst obj,\n                        int flags)\n{\n    return JS_WriteObject2(ctx, psize, obj, flags, NULL, NULL);\n}\n\ntypedef struct BCReaderState {\n    JSContext *ctx;\n    const uint8_t *buf_start, *ptr, *buf_end;\n    uint32_t first_atom;\n    uint32_t idx_to_atom_count;\n    JSAtom *idx_to_atom;\n    int error_state;\n    BOOL allow_sab : 8;\n    BOOL allow_bytecode : 8;\n    BOOL is_rom_data : 8;\n    BOOL allow_reference : 8;\n    /* object references */\n    JSObject **objects;\n    int objects_count;\n    int objects_size;\n    \n#ifdef DUMP_READ_OBJECT\n    const uint8_t *ptr_last;\n    int level;\n#endif\n} BCReaderState;\n\n#ifdef DUMP_READ_OBJECT\nstatic void __attribute__((format(printf, 2, 3))) bc_read_trace(BCReaderState *s, const char *fmt, ...) {\n    va_list ap;\n    int i, n, n0;\n\n    if (!s->ptr_last)\n        s->ptr_last = s->buf_start;\n\n    n = n0 = 0;\n    if (s->ptr > s->ptr_last || s->ptr == s->buf_start) {\n        n0 = printf(\"%04x: \", (int)(s->ptr_last - s->buf_start));\n        n += n0;\n    }\n    for (i = 0; s->ptr_last < s->ptr; i++) {\n        if ((i & 7) == 0 && i > 0) {\n            printf(\"\\n%*s\", n0, \"\");\n            n = n0;\n        }\n        n += printf(\" %02x\", *s->ptr_last++);\n    }\n    if (*fmt == '}')\n        s->level--;\n    if (n < 32 + s->level * 2) {\n        printf(\"%*s\", 32 + s->level * 2 - n, \"\");\n    }\n    va_start(ap, fmt);\n    vfprintf(stdout, fmt, ap);\n    va_end(ap);\n    if (strchr(fmt, '{'))\n        s->level++;\n}\n#else\n#define bc_read_trace(...)\n#endif\n\nstatic int bc_read_error_end(BCReaderState *s)\n{\n    if (!s->error_state) {\n        JS_ThrowSyntaxError(s->ctx, \"read after the end of the buffer\");\n    }\n    return s->error_state = -1;\n}\n\nstatic int bc_get_u8(BCReaderState *s, uint8_t *pval)\n{\n    if (unlikely(s->buf_end - s->ptr < 1)) {\n        *pval = 0; /* avoid warning */\n        return bc_read_error_end(s);\n    }\n    *pval = *s->ptr++;\n    return 0;\n}\n\nstatic int bc_get_u16(BCReaderState *s, uint16_t *pval)\n{\n    if (unlikely(s->buf_end - s->ptr < 2)) {\n        *pval = 0; /* avoid warning */\n        return bc_read_error_end(s);\n    }\n    *pval = get_u16(s->ptr);\n    s->ptr += 2;\n    return 0;\n}\n\nstatic __maybe_unused int bc_get_u32(BCReaderState *s, uint32_t *pval)\n{\n    if (unlikely(s->buf_end - s->ptr < 4)) {\n        *pval = 0; /* avoid warning */\n        return bc_read_error_end(s);\n    }\n    *pval = get_u32(s->ptr);\n    s->ptr += 4;\n    return 0;\n}\n\nstatic int bc_get_u64(BCReaderState *s, uint64_t *pval)\n{\n    if (unlikely(s->buf_end - s->ptr < 8)) {\n        *pval = 0; /* avoid warning */\n        return bc_read_error_end(s);\n    }\n    *pval = get_u64(s->ptr);\n    s->ptr += 8;\n    return 0;\n}\n\nstatic int bc_get_leb128(BCReaderState *s, uint32_t *pval)\n{\n    int ret;\n    ret = get_leb128(pval, s->ptr, s->buf_end);\n    if (unlikely(ret < 0))\n        return bc_read_error_end(s);\n    s->ptr += ret;\n    return 0;\n}\n\nstatic int bc_get_sleb128(BCReaderState *s, int32_t *pval)\n{\n    int ret;\n    ret = get_sleb128(pval, s->ptr, s->buf_end);\n    if (unlikely(ret < 0))\n        return bc_read_error_end(s);\n    s->ptr += ret;\n    return 0;\n}\n\n/* XXX: used to read an `int` with a positive value */\nstatic int bc_get_leb128_int(BCReaderState *s, int *pval)\n{\n    return bc_get_leb128(s, (uint32_t *)pval);\n}\n\nstatic int bc_get_leb128_u16(BCReaderState *s, uint16_t *pval)\n{\n    uint32_t val;\n    if (bc_get_leb128(s, &val)) {\n        *pval = 0;\n        return -1;\n    }\n    *pval = val;\n    return 0;\n}\n\nstatic int bc_get_buf(BCReaderState *s, uint8_t *buf, uint32_t buf_len)\n{\n    if (buf_len != 0) {\n        if (unlikely(!buf || s->buf_end - s->ptr < buf_len))\n            return bc_read_error_end(s);\n        memcpy(buf, s->ptr, buf_len);\n        s->ptr += buf_len;\n    }\n    return 0;\n}\n\nstatic int bc_idx_to_atom(BCReaderState *s, JSAtom *patom, uint32_t idx)\n{\n    JSAtom atom;\n\n    if (__JS_AtomIsTaggedInt(idx)) {\n        atom = idx;\n    } else if (idx < s->first_atom) {\n        atom = JS_DupAtom(s->ctx, idx);\n    } else {\n        idx -= s->first_atom;\n        if (idx >= s->idx_to_atom_count) {\n            JS_ThrowSyntaxError(s->ctx, \"invalid atom index (pos=%u)\",\n                                (unsigned int)(s->ptr - s->buf_start));\n            *patom = JS_ATOM_NULL;\n            return s->error_state = -1;\n        }\n        atom = JS_DupAtom(s->ctx, s->idx_to_atom[idx]);\n    }\n    *patom = atom;\n    return 0;\n}\n\nstatic int bc_get_atom(BCReaderState *s, JSAtom *patom)\n{\n    uint32_t v;\n    if (bc_get_leb128(s, &v))\n        return -1;\n    if (v & 1) {\n        *patom = __JS_AtomFromUInt32(v >> 1);\n        return 0;\n    } else {\n        return bc_idx_to_atom(s, patom, v >> 1);\n    }\n}\n\nstatic JSString *JS_ReadString(BCReaderState *s)\n{\n    uint32_t len;\n    size_t size;\n    BOOL is_wide_char;\n    JSString *p;\n\n    if (bc_get_leb128(s, &len))\n        return NULL;\n    is_wide_char = len & 1;\n    len >>= 1;\n    p = js_alloc_string(s->ctx, len, is_wide_char);\n    if (!p) {\n        s->error_state = -1;\n        return NULL;\n    }\n    size = (size_t)len << is_wide_char;\n    if ((s->buf_end - s->ptr) < size) {\n        bc_read_error_end(s);\n        js_free_string(s->ctx->rt, p);\n        return NULL;\n    }\n    memcpy(p->u.str8, s->ptr, size);\n    s->ptr += size;\n    if (!is_wide_char) {\n        p->u.str8[size] = '\\0'; /* add the trailing zero for 8 bit strings */\n    }\n#ifdef DUMP_READ_OBJECT\n    JS_DumpString(s->ctx->rt, p); printf(\"\\n\");\n#endif\n    return p;\n}\n\nstatic uint32_t bc_get_flags(uint32_t flags, int *pidx, int n)\n{\n    uint32_t val;\n    /* XXX: this does not work for n == 32 */\n    val = (flags >> *pidx) & ((1U << n) - 1);\n    *pidx += n;\n    return val;\n}\n\nstatic int JS_ReadFunctionBytecode(BCReaderState *s, JSFunctionBytecode *b,\n                                   int byte_code_offset, uint32_t bc_len)\n{\n    uint8_t *bc_buf;\n    int pos, len, op;\n    JSAtom atom;\n    uint32_t idx;\n\n    if (s->is_rom_data) {\n        /* directly use the input buffer */\n        if (unlikely(s->buf_end - s->ptr < bc_len))\n            return bc_read_error_end(s);\n        bc_buf = (uint8_t *)s->ptr;\n        s->ptr += bc_len;\n    } else {\n        bc_buf = (void *)((uint8_t*)b + byte_code_offset);\n        if (bc_get_buf(s, bc_buf, bc_len))\n            return -1;\n    }\n    b->byte_code_buf = bc_buf;\n\n    pos = 0;\n    while (pos < bc_len) {\n        op = bc_buf[pos];\n        len = short_opcode_info(op).size;\n        switch(short_opcode_info(op).fmt) {\n        case OP_FMT_atom:\n        case OP_FMT_atom_u8:\n        case OP_FMT_atom_u16:\n        case OP_FMT_atom_label_u8:\n        case OP_FMT_atom_label_u16:\n            idx = get_u32(bc_buf + pos + 1);\n            if (s->is_rom_data) {\n                /* just increment the reference count of the atom */\n                JS_DupAtom(s->ctx, (JSAtom)idx);\n            } else {\n                if (bc_idx_to_atom(s, &atom, idx)) {\n                    /* Note: the atoms will be freed up to this position */\n                    b->byte_code_len = pos;\n                    return -1;\n                }\n                put_u32(bc_buf + pos + 1, atom);\n#ifdef DUMP_READ_OBJECT\n                bc_read_trace(s, \"at %d, fixup atom: \", pos + 1); print_atom(s->ctx, atom); printf(\"\\n\");\n#endif\n            }\n            break;\n        default:\n            break;\n        }\n        pos += len;\n    }\n    return 0;\n}\n\n#ifdef CONFIG_BIGNUM\nstatic JSValue JS_ReadBigNum(BCReaderState *s, int tag)\n{\n    JSValue obj = JS_UNDEFINED;\n    uint8_t v8;\n    int32_t e;\n    uint32_t len;\n    limb_t l, i, n, j;\n    JSBigFloat *p;\n    limb_t v;\n    bf_t *a;\n    int bpos, d;\n    \n    p = js_new_bf(s->ctx);\n    if (!p)\n        goto fail;\n    switch(tag) {\n    case BC_TAG_BIG_INT:\n        obj = JS_MKPTR(JS_TAG_BIG_INT, p);\n        break;\n    case BC_TAG_BIG_FLOAT:\n        obj = JS_MKPTR(JS_TAG_BIG_FLOAT, p);\n        break;\n    case BC_TAG_BIG_DECIMAL:\n        obj = JS_MKPTR(JS_TAG_BIG_DECIMAL, p);\n        break;\n    default:\n        abort();\n    }\n\n    /* sign + exponent */\n    if (bc_get_sleb128(s, &e))\n        goto fail;\n\n    a = &p->num;\n    a->sign = e & 1;\n    e >>= 1;\n    if (e == 0)\n        a->expn = BF_EXP_ZERO;\n    else if (e == 1)\n        a->expn = BF_EXP_INF;\n    else if (e == 2)\n        a->expn = BF_EXP_NAN;\n    else if (e >= 3)\n        a->expn = e - 3;\n    else\n        a->expn = e;\n\n    /* mantissa */\n    if (a->expn != BF_EXP_ZERO &&\n        a->expn != BF_EXP_INF &&\n        a->expn != BF_EXP_NAN) {\n        if (bc_get_leb128(s, &len))\n            goto fail;\n        bc_read_trace(s, \"len=%\" PRId64 \"\\n\", (int64_t)len);\n        if (len == 0) {\n            JS_ThrowInternalError(s->ctx, \"invalid bignum length\");\n            goto fail;\n        }\n        if (tag != BC_TAG_BIG_DECIMAL)\n            l = (len + sizeof(limb_t) - 1) / sizeof(limb_t);\n        else\n            l = (len + LIMB_DIGITS - 1) / LIMB_DIGITS;\n        if (bf_resize(a, l)) {\n            JS_ThrowOutOfMemory(s->ctx);\n            goto fail;\n        }\n        if (tag != BC_TAG_BIG_DECIMAL) {\n            n = len & (sizeof(limb_t) - 1);\n            if (n != 0) {\n                v = 0;\n                for(i = 0; i < n; i++) {\n                    if (bc_get_u8(s, &v8))\n                        goto fail;\n                    v |= (limb_t)v8 << ((sizeof(limb_t) - n + i) * 8);\n                }\n                a->tab[0] = v;\n                i = 1;\n            } else {\n                i = 0;\n            }\n            for(; i < l; i++) {\n#if LIMB_BITS == 32\n                if (bc_get_u32(s, &v))\n                    goto fail;\n#ifdef WORDS_BIGENDIAN\n                v = bswap32(v);\n#endif\n#else\n                if (bc_get_u64(s, &v))\n                    goto fail;\n#ifdef WORDS_BIGENDIAN\n                v = bswap64(v);\n#endif\n#endif\n                a->tab[i] = v;\n            }\n        } else {\n            bpos = 0;\n            for(i = 0; i < l; i++) {\n                if (i == 0 && (n = len % LIMB_DIGITS) != 0) {\n                    j = LIMB_DIGITS - n;\n                } else {\n                    j = 0;\n                }\n                v = 0;\n                for(; j < LIMB_DIGITS; j++) {\n                    if (bpos == 0) {\n                        if (bc_get_u8(s, &v8))\n                            goto fail;\n                        d = v8 & 0xf;\n                        bpos = 1;\n                    } else {\n                        d = v8 >> 4;\n                        bpos = 0;\n                    }\n                    if (d >= 10) {\n                        JS_ThrowInternalError(s->ctx, \"invalid digit\");\n                        goto fail;\n                    }\n                    v += mp_pow_dec[j] * d;\n                }\n                a->tab[i] = v;\n            }\n        }\n    }\n    bc_read_trace(s, \"}\\n\");\n    return obj;\n fail:\n    JS_FreeValue(s->ctx, obj);\n    return JS_EXCEPTION;\n}\n#endif /* CONFIG_BIGNUM */\n\nstatic JSValue JS_ReadObjectRec(BCReaderState *s);\n\nstatic int BC_add_object_ref1(BCReaderState *s, JSObject *p)\n{\n    if (s->allow_reference) {\n        if (js_resize_array(s->ctx, (void *)&s->objects,\n                            sizeof(s->objects[0]),\n                            &s->objects_size, s->objects_count + 1))\n            return -1;\n        s->objects[s->objects_count++] = p;\n    }\n    return 0;\n}\n\nstatic int BC_add_object_ref(BCReaderState *s, JSValueConst obj)\n{\n    return BC_add_object_ref1(s, JS_VALUE_GET_OBJ(obj));\n}\n\nstatic JSValue JS_ReadFunctionTag(BCReaderState *s)\n{\n    JSContext *ctx = s->ctx;\n    JSFunctionBytecode bc, *b;\n    JSValue obj = JS_UNDEFINED;\n    uint16_t v16;\n    uint8_t v8;\n    int idx, i, local_count;\n    int function_size, cpool_offset, byte_code_offset;\n    int closure_var_offset, vardefs_offset;\n\n    memset(&bc, 0, sizeof(bc));\n    bc.header.ref_count = 1;\n    //bc.gc_header.mark = 0;\n\n    if (bc_get_u16(s, &v16))\n        goto fail;\n    idx = 0;\n    bc.has_prototype = bc_get_flags(v16, &idx, 1);\n    bc.has_simple_parameter_list = bc_get_flags(v16, &idx, 1);\n    bc.is_derived_class_constructor = bc_get_flags(v16, &idx, 1);\n    bc.need_home_object = bc_get_flags(v16, &idx, 1);\n    bc.func_kind = bc_get_flags(v16, &idx, 2);\n    bc.new_target_allowed = bc_get_flags(v16, &idx, 1);\n    bc.super_call_allowed = bc_get_flags(v16, &idx, 1);\n    bc.super_allowed = bc_get_flags(v16, &idx, 1);\n    bc.arguments_allowed = bc_get_flags(v16, &idx, 1);\n    bc.has_debug = bc_get_flags(v16, &idx, 1);\n    bc.backtrace_barrier = bc_get_flags(v16, &idx, 1);\n    bc.read_only_bytecode = s->is_rom_data;\n    if (bc_get_u8(s, &v8))\n        goto fail;\n    bc.js_mode = v8;\n    if (bc_get_atom(s, &bc.func_name))  //@ atom leak if failure\n        goto fail;\n    if (bc_get_leb128_u16(s, &bc.arg_count))\n        goto fail;\n    if (bc_get_leb128_u16(s, &bc.var_count))\n        goto fail;\n    if (bc_get_leb128_u16(s, &bc.defined_arg_count))\n        goto fail;\n    if (bc_get_leb128_u16(s, &bc.stack_size))\n        goto fail;\n    if (bc_get_leb128_int(s, &bc.closure_var_count))\n        goto fail;\n    if (bc_get_leb128_int(s, &bc.cpool_count))\n        goto fail;\n    if (bc_get_leb128_int(s, &bc.byte_code_len))\n        goto fail;\n    if (bc_get_leb128_int(s, &local_count))\n        goto fail;\n\n    if (bc.has_debug) {\n        function_size = sizeof(*b);\n    } else {\n        function_size = offsetof(JSFunctionBytecode, debug);\n    }\n    cpool_offset = function_size;\n    function_size += bc.cpool_count * sizeof(*bc.cpool);\n    vardefs_offset = function_size;\n    function_size += local_count * sizeof(*bc.vardefs);\n    closure_var_offset = function_size;\n    function_size += bc.closure_var_count * sizeof(*bc.closure_var);\n    byte_code_offset = function_size;\n    if (!bc.read_only_bytecode) {\n        function_size += bc.byte_code_len;\n    }\n\n    b = js_mallocz(ctx, function_size);\n    if (!b)\n        return JS_EXCEPTION;\n            \n    memcpy(b, &bc, offsetof(JSFunctionBytecode, debug));\n    b->header.ref_count = 1;\n    if (local_count != 0) {\n        b->vardefs = (void *)((uint8_t*)b + vardefs_offset);\n    }\n    if (b->closure_var_count != 0) {\n        b->closure_var = (void *)((uint8_t*)b + closure_var_offset);\n    }\n    if (b->cpool_count != 0) {\n        b->cpool = (void *)((uint8_t*)b + cpool_offset);\n    }\n    \n    add_gc_object(ctx->rt, &b->header, JS_GC_OBJ_TYPE_FUNCTION_BYTECODE);\n            \n    obj = JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, b);\n\n#ifdef DUMP_READ_OBJECT\n    bc_read_trace(s, \"name: \"); print_atom(s->ctx, b->func_name); printf(\"\\n\");\n#endif\n    bc_read_trace(s, \"args=%d vars=%d defargs=%d closures=%d cpool=%d\\n\",\n                  b->arg_count, b->var_count, b->defined_arg_count,\n                  b->closure_var_count, b->cpool_count);\n    bc_read_trace(s, \"stack=%d bclen=%d locals=%d\\n\",\n                  b->stack_size, b->byte_code_len, local_count);\n\n    if (local_count != 0) {\n        bc_read_trace(s, \"vars {\\n\");\n        for(i = 0; i < local_count; i++) {\n            JSVarDef *vd = &b->vardefs[i];\n            if (bc_get_atom(s, &vd->var_name))\n                goto fail;\n            if (bc_get_leb128_int(s, &vd->scope_level))\n                goto fail;\n            if (bc_get_leb128_int(s, &vd->scope_next))\n                goto fail;\n            vd->scope_next--;\n            if (bc_get_u8(s, &v8))\n                goto fail;\n            idx = 0;\n            vd->var_kind = bc_get_flags(v8, &idx, 4);\n            vd->is_const = bc_get_flags(v8, &idx, 1);\n            vd->is_lexical = bc_get_flags(v8, &idx, 1);\n            vd->is_captured = bc_get_flags(v8, &idx, 1);\n#ifdef DUMP_READ_OBJECT\n            bc_read_trace(s, \"name: \"); print_atom(s->ctx, vd->var_name); printf(\"\\n\");\n#endif\n        }\n        bc_read_trace(s, \"}\\n\");\n    }\n    if (b->closure_var_count != 0) {\n        bc_read_trace(s, \"closure vars {\\n\");\n        for(i = 0; i < b->closure_var_count; i++) {\n            JSClosureVar *cv = &b->closure_var[i];\n            int var_idx;\n            if (bc_get_atom(s, &cv->var_name))\n                goto fail;\n            if (bc_get_leb128_int(s, &var_idx))\n                goto fail;\n            cv->var_idx = var_idx;\n            if (bc_get_u8(s, &v8))\n                goto fail;\n            idx = 0;\n            cv->is_local = bc_get_flags(v8, &idx, 1);\n            cv->is_arg = bc_get_flags(v8, &idx, 1);\n            cv->is_const = bc_get_flags(v8, &idx, 1);\n            cv->is_lexical = bc_get_flags(v8, &idx, 1);\n            cv->var_kind = bc_get_flags(v8, &idx, 4);\n#ifdef DUMP_READ_OBJECT\n            bc_read_trace(s, \"name: \"); print_atom(s->ctx, cv->var_name); printf(\"\\n\");\n#endif\n        }\n        bc_read_trace(s, \"}\\n\");\n    }\n    {\n        bc_read_trace(s, \"bytecode {\\n\");\n        if (JS_ReadFunctionBytecode(s, b, byte_code_offset, b->byte_code_len))\n            goto fail;\n        bc_read_trace(s, \"}\\n\");\n    }\n    if (b->has_debug) {\n        /* read optional debug information */\n        bc_read_trace(s, \"debug {\\n\");\n        if (bc_get_atom(s, &b->debug.filename))\n            goto fail;\n        if (bc_get_leb128_int(s, &b->debug.line_num))\n            goto fail;\n        if (bc_get_leb128_int(s, &b->debug.pc2line_len))\n            goto fail;\n        if (b->debug.pc2line_len) {\n            b->debug.pc2line_buf = js_mallocz(ctx, b->debug.pc2line_len);\n            if (!b->debug.pc2line_buf)\n                goto fail;\n            if (bc_get_buf(s, b->debug.pc2line_buf, b->debug.pc2line_len))\n                goto fail;\n        }\n#ifdef DUMP_READ_OBJECT\n        bc_read_trace(s, \"filename: \"); print_atom(s->ctx, b->debug.filename); printf(\"\\n\");\n#endif\n        bc_read_trace(s, \"}\\n\");\n    }\n    if (b->cpool_count != 0) {\n        bc_read_trace(s, \"cpool {\\n\");\n        for(i = 0; i < b->cpool_count; i++) {\n            JSValue val;\n            val = JS_ReadObjectRec(s);\n            if (JS_IsException(val))\n                goto fail;\n            b->cpool[i] = val;\n        }\n        bc_read_trace(s, \"}\\n\");\n    }\n    b->realm = JS_DupContext(ctx);\n    return obj;\n fail:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ReadModule(BCReaderState *s)\n{\n    JSContext *ctx = s->ctx;\n    JSValue obj;\n    JSModuleDef *m = NULL;\n    JSAtom module_name;\n    int i;\n    uint8_t v8;\n    \n    if (bc_get_atom(s, &module_name))\n        goto fail;\n#ifdef DUMP_READ_OBJECT\n    bc_read_trace(s, \"name: \"); print_atom(s->ctx, module_name); printf(\"\\n\");\n#endif\n    m = js_new_module_def(ctx, module_name);\n    if (!m)\n        goto fail;\n    obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));\n    if (bc_get_leb128_int(s, &m->req_module_entries_count))\n        goto fail;\n    if (m->req_module_entries_count != 0) {\n        m->req_module_entries_size = m->req_module_entries_count;\n        m->req_module_entries = js_mallocz(ctx, sizeof(m->req_module_entries[0]) * m->req_module_entries_size);\n        if (!m->req_module_entries)\n            goto fail;\n        for(i = 0; i < m->req_module_entries_count; i++) {\n            JSReqModuleEntry *rme = &m->req_module_entries[i];\n            if (bc_get_atom(s, &rme->module_name))\n                goto fail;\n        }\n    }\n\n    if (bc_get_leb128_int(s, &m->export_entries_count))\n        goto fail;\n    if (m->export_entries_count != 0) {\n        m->export_entries_size = m->export_entries_count;\n        m->export_entries = js_mallocz(ctx, sizeof(m->export_entries[0]) * m->export_entries_size);\n        if (!m->export_entries)\n            goto fail;\n        for(i = 0; i < m->export_entries_count; i++) {\n            JSExportEntry *me = &m->export_entries[i];\n            if (bc_get_u8(s, &v8))\n                goto fail;\n            me->export_type = v8;\n            if (me->export_type == JS_EXPORT_TYPE_LOCAL) {\n                if (bc_get_leb128_int(s, &me->u.local.var_idx))\n                    goto fail;\n            } else {\n                if (bc_get_leb128_int(s, &me->u.req_module_idx))\n                    goto fail;\n                if (bc_get_atom(s, &me->local_name))\n                    goto fail;\n            }\n            if (bc_get_atom(s, &me->export_name))\n                goto fail;\n        }\n    }\n\n    if (bc_get_leb128_int(s, &m->star_export_entries_count))\n        goto fail;\n    if (m->star_export_entries_count != 0) {\n        m->star_export_entries_size = m->star_export_entries_count;\n        m->star_export_entries = js_mallocz(ctx, sizeof(m->star_export_entries[0]) * m->star_export_entries_size);\n        if (!m->star_export_entries)\n            goto fail;\n        for(i = 0; i < m->star_export_entries_count; i++) {\n            JSStarExportEntry *se = &m->star_export_entries[i];\n            if (bc_get_leb128_int(s, &se->req_module_idx))\n                goto fail;\n        }\n    }\n\n    if (bc_get_leb128_int(s, &m->import_entries_count))\n        goto fail;\n    if (m->import_entries_count != 0) {\n        m->import_entries_size = m->import_entries_count;\n        m->import_entries = js_mallocz(ctx, sizeof(m->import_entries[0]) * m->import_entries_size);\n        if (!m->import_entries)\n            goto fail;\n        for(i = 0; i < m->import_entries_count; i++) {\n            JSImportEntry *mi = &m->import_entries[i];\n            if (bc_get_leb128_int(s, &mi->var_idx))\n                goto fail;\n            if (bc_get_atom(s, &mi->import_name))\n                goto fail;\n            if (bc_get_leb128_int(s, &mi->req_module_idx))\n                goto fail;\n        }\n    }\n\n    m->func_obj = JS_ReadObjectRec(s);\n    if (JS_IsException(m->func_obj))\n        goto fail;\n    return obj;\n fail:\n    if (m) {\n        js_free_module_def(ctx, m);\n    }\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ReadObjectTag(BCReaderState *s)\n{\n    JSContext *ctx = s->ctx;\n    JSValue obj;\n    uint32_t prop_count, i;\n    JSAtom atom;\n    JSValue val;\n    int ret;\n    \n    obj = JS_NewObject(ctx);\n    if (BC_add_object_ref(s, obj))\n        goto fail;\n    if (bc_get_leb128(s, &prop_count))\n        goto fail;\n    for(i = 0; i < prop_count; i++) {\n        if (bc_get_atom(s, &atom))\n            goto fail;\n#ifdef DUMP_READ_OBJECT\n        bc_read_trace(s, \"propname: \"); print_atom(s->ctx, atom); printf(\"\\n\");\n#endif\n        val = JS_ReadObjectRec(s);\n        if (JS_IsException(val)) {\n            JS_FreeAtom(ctx, atom);\n            goto fail;\n        }\n        ret = JS_DefinePropertyValue(ctx, obj, atom, val, JS_PROP_C_W_E);\n        JS_FreeAtom(ctx, atom);\n        if (ret < 0)\n            goto fail;\n    }\n    return obj;\n fail:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ReadArray(BCReaderState *s, int tag)\n{\n    JSContext *ctx = s->ctx;\n    JSValue obj;\n    uint32_t len, i;\n    JSValue val;\n    int ret, prop_flags;\n    BOOL is_template;\n\n    obj = JS_NewArray(ctx);\n    if (BC_add_object_ref(s, obj))\n        goto fail;\n    is_template = (tag == BC_TAG_TEMPLATE_OBJECT);\n    if (bc_get_leb128(s, &len))\n        goto fail;\n    for(i = 0; i < len; i++) {\n        val = JS_ReadObjectRec(s);\n        if (JS_IsException(val))\n            goto fail;\n        if (is_template)\n            prop_flags = JS_PROP_ENUMERABLE;\n        else\n            prop_flags = JS_PROP_C_W_E;\n        ret = JS_DefinePropertyValueUint32(ctx, obj, i, val,\n                                           prop_flags);\n        if (ret < 0)\n            goto fail;\n    }\n    if (is_template) {\n        val = JS_ReadObjectRec(s);\n        if (JS_IsException(val))\n            goto fail;\n        if (!JS_IsUndefined(val)) {\n            ret = JS_DefinePropertyValue(ctx, obj, JS_ATOM_raw, val, 0);\n            if (ret < 0)\n                goto fail;\n        }\n        JS_PreventExtensions(ctx, obj);\n    }\n    return obj;\n fail:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ReadTypedArray(BCReaderState *s)\n{\n    JSContext *ctx = s->ctx;\n    JSValue obj = JS_UNDEFINED, array_buffer = JS_UNDEFINED;\n    uint8_t array_tag;\n    JSValueConst args[3];\n    uint32_t offset, len, idx;\n    \n    if (bc_get_u8(s, &array_tag))\n        return JS_EXCEPTION;\n    if (array_tag >= JS_TYPED_ARRAY_COUNT)\n        return JS_ThrowTypeError(ctx, \"invalid typed array\");\n    if (bc_get_leb128(s, &len))\n        return JS_EXCEPTION;\n    if (bc_get_leb128(s, &offset))\n        return JS_EXCEPTION;\n    /* XXX: this hack could be avoided if the typed array could be\n       created before the array buffer */\n    idx = s->objects_count;\n    if (BC_add_object_ref1(s, NULL))\n        goto fail;\n    array_buffer = JS_ReadObjectRec(s);\n    if (JS_IsException(array_buffer))\n        return JS_EXCEPTION;\n    if (!js_get_array_buffer(ctx, array_buffer)) {\n        JS_FreeValue(ctx, array_buffer);\n        return JS_EXCEPTION;\n    }\n    args[0] = array_buffer;\n    args[1] = JS_NewInt64(ctx, offset);\n    args[2] = JS_NewInt64(ctx, len);\n    obj = js_typed_array_constructor(ctx, JS_UNDEFINED,\n                                     3, args,\n                                     JS_CLASS_UINT8C_ARRAY + array_tag);\n    if (JS_IsException(obj))\n        goto fail;\n    if (s->allow_reference) {\n        s->objects[idx] = JS_VALUE_GET_OBJ(obj);\n    }\n    JS_FreeValue(ctx, array_buffer);\n    return obj;\n fail:\n    JS_FreeValue(ctx, array_buffer);\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ReadArrayBuffer(BCReaderState *s)\n{\n    JSContext *ctx = s->ctx;\n    uint32_t byte_length;\n    JSValue obj;\n    \n    if (bc_get_leb128(s, &byte_length))\n        return JS_EXCEPTION;\n    if (unlikely(s->buf_end - s->ptr < byte_length)) {\n        bc_read_error_end(s);\n        return JS_EXCEPTION;\n    }\n    obj = JS_NewArrayBufferCopy(ctx, s->ptr, byte_length);\n    if (JS_IsException(obj))\n        goto fail;\n    if (BC_add_object_ref(s, obj))\n        goto fail;\n    s->ptr += byte_length;\n    return obj;\n fail:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ReadSharedArrayBuffer(BCReaderState *s)\n{\n    JSContext *ctx = s->ctx;\n    uint32_t byte_length;\n    uint8_t *data_ptr;\n    JSValue obj;\n    uint64_t u64;\n    \n    if (bc_get_leb128(s, &byte_length))\n        return JS_EXCEPTION;\n    if (bc_get_u64(s, &u64))\n        return JS_EXCEPTION;\n    data_ptr = (uint8_t *)(uintptr_t)u64;\n    /* the SharedArrayBuffer is cloned */\n    obj = js_array_buffer_constructor3(ctx, JS_UNDEFINED, byte_length,\n                                       JS_CLASS_SHARED_ARRAY_BUFFER,\n                                       data_ptr,\n                                       NULL, NULL, FALSE);\n    if (JS_IsException(obj))\n        goto fail;\n    if (BC_add_object_ref(s, obj))\n        goto fail;\n    return obj;\n fail:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ReadDate(BCReaderState *s)\n{\n    JSContext *ctx = s->ctx;\n    JSValue val, obj = JS_UNDEFINED;\n\n    val = JS_ReadObjectRec(s);\n    if (JS_IsException(val))\n        goto fail;\n    if (!JS_IsNumber(val)) {\n        JS_ThrowTypeError(ctx, \"Number tag expected for date\");\n        goto fail;\n    }\n    obj = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_DATE],\n                                 JS_CLASS_DATE);\n    if (JS_IsException(obj))\n        goto fail;\n    if (BC_add_object_ref(s, obj))\n        goto fail;\n    JS_SetObjectData(ctx, obj, val);\n    return obj;\n fail:\n    JS_FreeValue(ctx, val);\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ReadObjectValue(BCReaderState *s)\n{\n    JSContext *ctx = s->ctx;\n    JSValue val, obj = JS_UNDEFINED;\n\n    val = JS_ReadObjectRec(s);\n    if (JS_IsException(val))\n        goto fail;\n    obj = JS_ToObject(ctx, val);\n    if (JS_IsException(obj))\n        goto fail;\n    if (BC_add_object_ref(s, obj))\n        goto fail;\n    JS_FreeValue(ctx, val);\n    return obj;\n fail:\n    JS_FreeValue(ctx, val);\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ReadObjectRec(BCReaderState *s)\n{\n    JSContext *ctx = s->ctx;\n    uint8_t tag;\n    JSValue obj = JS_UNDEFINED;\n\n    if (js_check_stack_overflow(ctx->rt, 0))\n        return JS_ThrowStackOverflow(ctx);\n\n    if (bc_get_u8(s, &tag))\n        return JS_EXCEPTION;\n\n    bc_read_trace(s, \"%s {\\n\", bc_tag_str[tag]);\n\n    switch(tag) {\n    case BC_TAG_NULL:\n        obj = JS_NULL;\n        break;\n    case BC_TAG_UNDEFINED:\n        obj = JS_UNDEFINED;\n        break;\n    case BC_TAG_BOOL_FALSE:\n    case BC_TAG_BOOL_TRUE:\n        obj = JS_NewBool(ctx, tag - BC_TAG_BOOL_FALSE);\n        break;\n    case BC_TAG_INT32:\n        {\n            int32_t val;\n            if (bc_get_sleb128(s, &val))\n                return JS_EXCEPTION;\n            bc_read_trace(s, \"%d\\n\", val);\n            obj = JS_NewInt32(ctx, val);\n        }\n        break;\n    case BC_TAG_FLOAT64:\n        {\n            JSFloat64Union u;\n            if (bc_get_u64(s, &u.u64))\n                return JS_EXCEPTION;\n            bc_read_trace(s, \"%g\\n\", u.d);\n            obj = __JS_NewFloat64(ctx, u.d);\n        }\n        break;\n    case BC_TAG_STRING:\n        {\n            JSString *p;\n            p = JS_ReadString(s);\n            if (!p)\n                return JS_EXCEPTION;\n            obj = JS_MKPTR(JS_TAG_STRING, p);\n        }\n        break;\n    case BC_TAG_FUNCTION_BYTECODE:\n        if (!s->allow_bytecode)\n            goto invalid_tag;\n        obj = JS_ReadFunctionTag(s);\n        break;\n    case BC_TAG_MODULE:\n        if (!s->allow_bytecode)\n            goto invalid_tag;\n        obj = JS_ReadModule(s);\n        break;\n    case BC_TAG_OBJECT:\n        obj = JS_ReadObjectTag(s);\n        break;\n    case BC_TAG_ARRAY:\n    case BC_TAG_TEMPLATE_OBJECT:\n        obj = JS_ReadArray(s, tag);\n        break;\n    case BC_TAG_TYPED_ARRAY:\n        obj = JS_ReadTypedArray(s);\n        break;\n    case BC_TAG_ARRAY_BUFFER:\n        obj = JS_ReadArrayBuffer(s);\n        break;\n    case BC_TAG_SHARED_ARRAY_BUFFER:\n        if (!s->allow_sab || !ctx->rt->sab_funcs.sab_dup)\n            goto invalid_tag;\n        obj = JS_ReadSharedArrayBuffer(s);\n        break;\n    case BC_TAG_DATE:\n        obj = JS_ReadDate(s);\n        break;\n    case BC_TAG_OBJECT_VALUE:\n        obj = JS_ReadObjectValue(s);\n        break;\n#ifdef CONFIG_BIGNUM\n    case BC_TAG_BIG_INT:\n    case BC_TAG_BIG_FLOAT:\n    case BC_TAG_BIG_DECIMAL:\n        obj = JS_ReadBigNum(s, tag);\n        break;\n#endif\n    case BC_TAG_OBJECT_REFERENCE:\n        {\n            uint32_t val;\n            if (!s->allow_reference)\n                return JS_ThrowSyntaxError(ctx, \"object references are not allowed\");\n            if (bc_get_leb128(s, &val))\n                return JS_EXCEPTION;\n            bc_read_trace(s, \"%u\\n\", val);\n            if (val >= s->objects_count) {\n                return JS_ThrowSyntaxError(ctx, \"invalid object reference (%u >= %u)\",\n                                           val, s->objects_count);\n            }\n            obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, s->objects[val]));\n        }\n        break;\n    default:\n    invalid_tag:\n        return JS_ThrowSyntaxError(ctx, \"invalid tag (tag=%d pos=%u)\",\n                                   tag, (unsigned int)(s->ptr - s->buf_start));\n    }\n    bc_read_trace(s, \"}\\n\");\n    return obj;\n}\n\nstatic int JS_ReadObjectAtoms(BCReaderState *s)\n{\n    uint8_t v8;\n    JSString *p;\n    int i;\n    JSAtom atom;\n\n    if (bc_get_u8(s, &v8))\n        return -1;\n    /* XXX: could support byte swapped input */\n    if (v8 != BC_VERSION) {\n        JS_ThrowSyntaxError(s->ctx, \"invalid version (%d expected=%d)\",\n                            v8, BC_VERSION);\n        return -1;\n    }\n    if (bc_get_leb128(s, &s->idx_to_atom_count))\n        return -1;\n\n    bc_read_trace(s, \"%d atom indexes {\\n\", s->idx_to_atom_count);\n\n    if (s->idx_to_atom_count != 0) {\n        s->idx_to_atom = js_mallocz(s->ctx, s->idx_to_atom_count *\n                                    sizeof(s->idx_to_atom[0]));\n        if (!s->idx_to_atom)\n            return s->error_state = -1;\n    }\n    for(i = 0; i < s->idx_to_atom_count; i++) {\n        p = JS_ReadString(s);\n        if (!p)\n            return -1;\n        atom = JS_NewAtomStr(s->ctx, p);\n        if (atom == JS_ATOM_NULL)\n            return s->error_state = -1;\n        s->idx_to_atom[i] = atom;\n        if (s->is_rom_data && (atom != (i + s->first_atom)))\n            s->is_rom_data = FALSE; /* atoms must be relocated */\n    }\n    bc_read_trace(s, \"}\\n\");\n    return 0;\n}\n\nstatic void bc_reader_free(BCReaderState *s)\n{\n    int i;\n    if (s->idx_to_atom) {\n        for(i = 0; i < s->idx_to_atom_count; i++) {\n            JS_FreeAtom(s->ctx, s->idx_to_atom[i]);\n        }\n        js_free(s->ctx, s->idx_to_atom);\n    }\n    js_free(s->ctx, s->objects);\n}\n\nJSValue JS_ReadObject(JSContext *ctx, const uint8_t *buf, size_t buf_len,\n                       int flags)\n{\n    BCReaderState ss, *s = &ss;\n    JSValue obj;\n\n    ctx->binary_object_count += 1;\n    ctx->binary_object_size += buf_len;\n\n    memset(s, 0, sizeof(*s));\n    s->ctx = ctx;\n    s->buf_start = buf;\n    s->buf_end = buf + buf_len;\n    s->ptr = buf;\n    s->allow_bytecode = ((flags & JS_READ_OBJ_BYTECODE) != 0);\n    s->is_rom_data = ((flags & JS_READ_OBJ_ROM_DATA) != 0);\n    s->allow_sab = ((flags & JS_READ_OBJ_SAB) != 0);\n    s->allow_reference = ((flags & JS_READ_OBJ_REFERENCE) != 0);\n    if (s->allow_bytecode)\n        s->first_atom = JS_ATOM_END;\n    else\n        s->first_atom = 1;\n    if (JS_ReadObjectAtoms(s)) {\n        obj = JS_EXCEPTION;\n    } else {\n        obj = JS_ReadObjectRec(s);\n    }\n    bc_reader_free(s);\n    return obj;\n}\n\n/*******************************************************************/\n/* runtime functions & objects */\n\nstatic JSValue js_string_constructor(JSContext *ctx, JSValueConst this_val,\n                                     int argc, JSValueConst *argv);\nstatic JSValue js_boolean_constructor(JSContext *ctx, JSValueConst this_val,\n                                      int argc, JSValueConst *argv);\nstatic JSValue js_number_constructor(JSContext *ctx, JSValueConst this_val,\n                                     int argc, JSValueConst *argv);\n\nstatic int check_function(JSContext *ctx, JSValueConst obj)\n{\n    if (likely(JS_IsFunction(ctx, obj)))\n        return 0;\n    JS_ThrowTypeError(ctx, \"not a function\");\n    return -1;\n}\n\nstatic int check_exception_free(JSContext *ctx, JSValue obj)\n{\n    JS_FreeValue(ctx, obj);\n    return JS_IsException(obj);\n}\n\nstatic JSAtom find_atom(JSContext *ctx, const char *name)\n{\n    JSAtom atom;\n    int len;\n\n    if (*name == '[') {\n        name++;\n        len = strlen(name) - 1;\n        /* We assume 8 bit non null strings, which is the case for these\n           symbols */\n        for(atom = JS_ATOM_Symbol_toPrimitive; atom < JS_ATOM_END; atom++) {\n            JSAtomStruct *p = ctx->rt->atom_array[atom];\n            JSString *str = p;\n            if (str->len == len && !memcmp(str->u.str8, name, len))\n                return JS_DupAtom(ctx, atom);\n        }\n        abort();\n    } else {\n        atom = JS_NewAtom(ctx, name);\n    }\n    return atom;\n}\n\nstatic JSValue JS_InstantiateFunctionListItem2(JSContext *ctx, JSObject *p,\n                                               JSAtom atom, void *opaque)\n{\n    const JSCFunctionListEntry *e = opaque;\n    JSValue val;\n\n    switch(e->def_type) {\n    case JS_DEF_CFUNC:\n        val = JS_NewCFunction2(ctx, e->u.func.cfunc.generic,\n                               e->name, e->u.func.length, e->u.func.cproto, e->magic);\n        break;\n    case JS_DEF_PROP_STRING:\n        val = JS_NewAtomString(ctx, e->u.str);\n        break;\n    case JS_DEF_OBJECT:\n        val = JS_NewObject(ctx);\n        JS_SetPropertyFunctionList(ctx, val, e->u.prop_list.tab, e->u.prop_list.len);\n        break;\n    default:\n        abort();\n    }\n    return val;\n}\n\nstatic int JS_InstantiateFunctionListItem(JSContext *ctx, JSValueConst obj,\n                                          JSAtom atom,\n                                          const JSCFunctionListEntry *e)\n{\n    JSValue val;\n    int prop_flags = e->prop_flags;\n\n    switch(e->def_type) {\n    case JS_DEF_ALIAS: /* using autoinit for aliases is not safe */\n        {\n            JSAtom atom1 = find_atom(ctx, e->u.alias.name);\n            switch (e->u.alias.base) {\n            case -1:\n                val = JS_GetProperty(ctx, obj, atom1);\n                break;\n            case 0:\n                val = JS_GetProperty(ctx, ctx->global_obj, atom1);\n                break;\n            case 1:\n                val = JS_GetProperty(ctx, ctx->class_proto[JS_CLASS_ARRAY], atom1);\n                break;\n            default:\n                abort();\n            }\n            JS_FreeAtom(ctx, atom1);\n            if (atom == JS_ATOM_Symbol_toPrimitive) {\n                /* Symbol.toPrimitive functions are not writable */\n                prop_flags = JS_PROP_CONFIGURABLE;\n            } else if (atom == JS_ATOM_Symbol_hasInstance) {\n                /* Function.prototype[Symbol.hasInstance] is not writable nor configurable */\n                prop_flags = 0;\n            }\n        }\n        break;\n    case JS_DEF_CFUNC:\n        if (atom == JS_ATOM_Symbol_toPrimitive) {\n            /* Symbol.toPrimitive functions are not writable */\n            prop_flags = JS_PROP_CONFIGURABLE;\n        } else if (atom == JS_ATOM_Symbol_hasInstance) {\n            /* Function.prototype[Symbol.hasInstance] is not writable nor configurable */\n            prop_flags = 0;\n        }\n        JS_DefineAutoInitProperty(ctx, obj, atom, JS_AUTOINIT_ID_PROP,\n                                  (void *)e, prop_flags);\n        return 0;\n    case JS_DEF_CGETSET: /* XXX: use autoinit again ? */\n    case JS_DEF_CGETSET_MAGIC:\n        {\n            JSValue getter, setter;\n            char buf[64];\n\n            getter = JS_UNDEFINED;\n            if (e->u.getset.get.generic) {\n                snprintf(buf, sizeof(buf), \"get %s\", e->name);\n                getter = JS_NewCFunction2(ctx, e->u.getset.get.generic,\n                                          buf, 0, e->def_type == JS_DEF_CGETSET_MAGIC ? JS_CFUNC_getter_magic : JS_CFUNC_getter,\n                                          e->magic);\n            }\n            setter = JS_UNDEFINED;\n            if (e->u.getset.set.generic) {\n                snprintf(buf, sizeof(buf), \"set %s\", e->name);\n                setter = JS_NewCFunction2(ctx, e->u.getset.set.generic,\n                                          buf, 1, e->def_type == JS_DEF_CGETSET_MAGIC ? JS_CFUNC_setter_magic : JS_CFUNC_setter,\n                                          e->magic);\n            }\n            JS_DefinePropertyGetSet(ctx, obj, atom, getter, setter, prop_flags);\n            return 0;\n        }\n        break;\n    case JS_DEF_PROP_INT32:\n        val = JS_NewInt32(ctx, e->u.i32);\n        break;\n    case JS_DEF_PROP_INT64:\n        val = JS_NewInt64(ctx, e->u.i64);\n        break;\n    case JS_DEF_PROP_DOUBLE:\n        val = __JS_NewFloat64(ctx, e->u.f64);\n        break;\n    case JS_DEF_PROP_UNDEFINED:\n        val = JS_UNDEFINED;\n        break;\n    case JS_DEF_PROP_STRING:\n    case JS_DEF_OBJECT:\n        JS_DefineAutoInitProperty(ctx, obj, atom, JS_AUTOINIT_ID_PROP,\n                                  (void *)e, prop_flags);\n        return 0;\n    default:\n        abort();\n    }\n    JS_DefinePropertyValue(ctx, obj, atom, val, prop_flags);\n    return 0;\n}\n\nvoid JS_SetPropertyFunctionList(JSContext *ctx, JSValueConst obj,\n                                const JSCFunctionListEntry *tab, int len)\n{\n    int i;\n\n    for (i = 0; i < len; i++) {\n        const JSCFunctionListEntry *e = &tab[i];\n        JSAtom atom = find_atom(ctx, e->name);\n        JS_InstantiateFunctionListItem(ctx, obj, atom, e);\n        JS_FreeAtom(ctx, atom);\n    }\n}\n\nint JS_AddModuleExportList(JSContext *ctx, JSModuleDef *m,\n                           const JSCFunctionListEntry *tab, int len)\n{\n    int i;\n    for(i = 0; i < len; i++) {\n        if (JS_AddModuleExport(ctx, m, tab[i].name))\n            return -1;\n    }\n    return 0;\n}\n\nint JS_SetModuleExportList(JSContext *ctx, JSModuleDef *m,\n                           const JSCFunctionListEntry *tab, int len)\n{\n    int i;\n    JSValue val;\n\n    for(i = 0; i < len; i++) {\n        const JSCFunctionListEntry *e = &tab[i];\n        switch(e->def_type) {\n        case JS_DEF_CFUNC:\n            val = JS_NewCFunction2(ctx, e->u.func.cfunc.generic,\n                                   e->name, e->u.func.length, e->u.func.cproto, e->magic);\n            break;\n        case JS_DEF_PROP_STRING:\n            val = JS_NewString(ctx, e->u.str);\n            break;\n        case JS_DEF_PROP_INT32:\n            val = JS_NewInt32(ctx, e->u.i32);\n            break;\n        case JS_DEF_PROP_INT64:\n            val = JS_NewInt64(ctx, e->u.i64);\n            break;\n        case JS_DEF_PROP_DOUBLE:\n            val = __JS_NewFloat64(ctx, e->u.f64);\n            break;\n        case JS_DEF_OBJECT:\n            val = JS_NewObject(ctx);\n            JS_SetPropertyFunctionList(ctx, val, e->u.prop_list.tab, e->u.prop_list.len);\n            break;\n        default:\n            abort();\n        }\n        if (JS_SetModuleExport(ctx, m, e->name, val))\n            return -1;\n    }\n    return 0;\n}\n\n/* Note: 'func_obj' is not necessarily a constructor */\nstatic void JS_SetConstructor2(JSContext *ctx,\n                               JSValueConst func_obj,\n                               JSValueConst proto,\n                               int proto_flags, int ctor_flags)\n{\n    JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_prototype,\n                           JS_DupValue(ctx, proto), proto_flags);\n    JS_DefinePropertyValue(ctx, proto, JS_ATOM_constructor,\n                           JS_DupValue(ctx, func_obj),\n                           ctor_flags);\n    set_cycle_flag(ctx, func_obj);\n    set_cycle_flag(ctx, proto);\n}\n\nvoid JS_SetConstructor(JSContext *ctx, JSValueConst func_obj, \n                       JSValueConst proto)\n{\n    JS_SetConstructor2(ctx, func_obj, proto,\n                       0, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n}\n\nstatic void JS_NewGlobalCConstructor2(JSContext *ctx,\n                                      JSValue func_obj,\n                                      const char *name,\n                                      JSValueConst proto)\n{\n    JS_DefinePropertyValueStr(ctx, ctx->global_obj, name,\n                           JS_DupValue(ctx, func_obj),\n                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    JS_SetConstructor(ctx, func_obj, proto);\n    JS_FreeValue(ctx, func_obj);\n}\n\nstatic JSValueConst JS_NewGlobalCConstructor(JSContext *ctx, const char *name,\n                                             JSCFunction *func, int length,\n                                             JSValueConst proto)\n{\n    JSValue func_obj;\n    func_obj = JS_NewCFunction2(ctx, func, name, length, JS_CFUNC_constructor_or_func, 0);\n    JS_NewGlobalCConstructor2(ctx, func_obj, name, proto);\n    return func_obj;\n}\n\nstatic JSValueConst JS_NewGlobalCConstructorOnly(JSContext *ctx, const char *name,\n                                                 JSCFunction *func, int length,\n                                                 JSValueConst proto)\n{\n    JSValue func_obj;\n    func_obj = JS_NewCFunction2(ctx, func, name, length, JS_CFUNC_constructor, 0);\n    JS_NewGlobalCConstructor2(ctx, func_obj, name, proto);\n    return func_obj;\n}\n\nstatic JSValue js_global_eval(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv)\n{\n    return JS_EvalObject(ctx, ctx->global_obj, argv[0], JS_EVAL_TYPE_INDIRECT, -1);\n}\n\nstatic JSValue js_global_isNaN(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    double d;\n\n    /* XXX: does this work for bigfloat? */\n    if (unlikely(JS_ToFloat64(ctx, &d, argv[0])))\n        return JS_EXCEPTION;\n    return JS_NewBool(ctx, isnan(d));\n}\n\nstatic JSValue js_global_isFinite(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    BOOL res;\n    double d;\n    if (unlikely(JS_ToFloat64(ctx, &d, argv[0])))\n        return JS_EXCEPTION;\n    res = isfinite(d);\n    return JS_NewBool(ctx, res);\n}\n\n/* Object class */\n\nstatic JSValue JS_ToObject(JSContext *ctx, JSValueConst val)\n{\n    int tag = JS_VALUE_GET_NORM_TAG(val);\n    JSValue obj;\n\n    switch(tag) {\n    default:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        return JS_ThrowTypeError(ctx, \"cannot convert to object\");\n    case JS_TAG_OBJECT:\n    case JS_TAG_EXCEPTION:\n        return JS_DupValue(ctx, val);\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n        obj = JS_NewObjectClass(ctx, JS_CLASS_BIG_INT);\n        goto set_value;\n    case JS_TAG_BIG_FLOAT:\n        obj = JS_NewObjectClass(ctx, JS_CLASS_BIG_FLOAT);\n        goto set_value;\n    case JS_TAG_BIG_DECIMAL:\n        obj = JS_NewObjectClass(ctx, JS_CLASS_BIG_DECIMAL);\n        goto set_value;\n#endif\n    case JS_TAG_INT:\n    case JS_TAG_FLOAT64:\n        obj = JS_NewObjectClass(ctx, JS_CLASS_NUMBER);\n        goto set_value;\n    case JS_TAG_STRING:\n        /* XXX: should call the string constructor */\n        {\n            JSString *p1 = JS_VALUE_GET_STRING(val);\n            obj = JS_NewObjectClass(ctx, JS_CLASS_STRING);\n            JS_DefinePropertyValue(ctx, obj, JS_ATOM_length, JS_NewInt32(ctx, p1->len), 0);\n        }\n        goto set_value;\n    case JS_TAG_BOOL:\n        obj = JS_NewObjectClass(ctx, JS_CLASS_BOOLEAN);\n        goto set_value;\n    case JS_TAG_SYMBOL:\n        obj = JS_NewObjectClass(ctx, JS_CLASS_SYMBOL);\n    set_value:\n        if (!JS_IsException(obj))\n            JS_SetObjectData(ctx, obj, JS_DupValue(ctx, val));\n        return obj;\n    }\n}\n\nstatic JSValue JS_ToObjectFree(JSContext *ctx, JSValue val)\n{\n    JSValue obj = JS_ToObject(ctx, val);\n    JS_FreeValue(ctx, val);\n    return obj;\n}\n\nstatic int js_obj_to_desc(JSContext *ctx, JSPropertyDescriptor *d,\n                          JSValueConst desc)\n{\n    JSValue val, getter, setter;\n    int flags;\n\n    if (!JS_IsObject(desc)) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        return -1;\n    }\n    flags = 0;\n    val = JS_UNDEFINED;\n    getter = JS_UNDEFINED;\n    setter = JS_UNDEFINED;\n    if (JS_HasProperty(ctx, desc, JS_ATOM_configurable)) {\n        JSValue prop = JS_GetProperty(ctx, desc, JS_ATOM_configurable);\n        if (JS_IsException(prop))\n            goto fail;\n        flags |= JS_PROP_HAS_CONFIGURABLE;\n        if (JS_ToBoolFree(ctx, prop))\n            flags |= JS_PROP_CONFIGURABLE;\n    }\n    if (JS_HasProperty(ctx, desc, JS_ATOM_writable)) {\n        JSValue prop = JS_GetProperty(ctx, desc, JS_ATOM_writable);\n        if (JS_IsException(prop))\n            goto fail;\n        flags |= JS_PROP_HAS_WRITABLE;\n        if (JS_ToBoolFree(ctx, prop))\n            flags |= JS_PROP_WRITABLE;\n    }\n    if (JS_HasProperty(ctx, desc, JS_ATOM_enumerable)) {\n        JSValue prop = JS_GetProperty(ctx, desc, JS_ATOM_enumerable);\n        if (JS_IsException(prop))\n            goto fail;\n        flags |= JS_PROP_HAS_ENUMERABLE;\n        if (JS_ToBoolFree(ctx, prop))\n            flags |= JS_PROP_ENUMERABLE;\n    }\n    if (JS_HasProperty(ctx, desc, JS_ATOM_value)) {\n        flags |= JS_PROP_HAS_VALUE;\n        val = JS_GetProperty(ctx, desc, JS_ATOM_value);\n        if (JS_IsException(val))\n            goto fail;\n    }\n    if (JS_HasProperty(ctx, desc, JS_ATOM_get)) {\n        flags |= JS_PROP_HAS_GET;\n        getter = JS_GetProperty(ctx, desc, JS_ATOM_get);\n        if (JS_IsException(getter) ||\n            !(JS_IsUndefined(getter) || JS_IsFunction(ctx, getter))) {\n            JS_ThrowTypeError(ctx, \"invalid getter\");\n            goto fail;\n        }\n    }\n    if (JS_HasProperty(ctx, desc, JS_ATOM_set)) {\n        flags |= JS_PROP_HAS_SET;\n        setter = JS_GetProperty(ctx, desc, JS_ATOM_set);\n        if (JS_IsException(setter) ||\n            !(JS_IsUndefined(setter) || JS_IsFunction(ctx, setter))) {\n            JS_ThrowTypeError(ctx, \"invalid setter\");\n            goto fail;\n        }\n    }\n    if ((flags & (JS_PROP_HAS_SET | JS_PROP_HAS_GET)) &&\n        (flags & (JS_PROP_HAS_VALUE | JS_PROP_HAS_WRITABLE))) {\n        JS_ThrowTypeError(ctx, \"cannot have setter/getter and value or writable\");\n        goto fail;\n    }\n    d->flags = flags;\n    d->value = val;\n    d->getter = getter;\n    d->setter = setter;\n    return 0;\n fail:\n    JS_FreeValue(ctx, val);\n    JS_FreeValue(ctx, getter);\n    JS_FreeValue(ctx, setter);\n    return -1;\n}\n\nstatic __exception int JS_DefinePropertyDesc(JSContext *ctx, JSValueConst obj,\n                                             JSAtom prop, JSValueConst desc,\n                                             int flags)\n{\n    JSPropertyDescriptor d;\n    int ret;\n\n    if (js_obj_to_desc(ctx, &d, desc) < 0)\n        return -1;\n\n    ret = JS_DefineProperty(ctx, obj, prop,\n                            d.value, d.getter, d.setter, d.flags | flags);\n    js_free_desc(ctx, &d);\n    return ret;\n}\n\nstatic __exception int JS_ObjectDefineProperties(JSContext *ctx,\n                                                 JSValueConst obj,\n                                                 JSValueConst properties)\n{\n    JSValue props, desc;\n    JSObject *p;\n    JSPropertyEnum *atoms;\n    uint32_t len, i;\n    int ret = -1;\n\n    if (!JS_IsObject(obj)) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        return -1;\n    }\n    desc = JS_UNDEFINED;\n    props = JS_ToObject(ctx, properties);\n    if (JS_IsException(props))\n        return -1;\n    p = JS_VALUE_GET_OBJ(props);\n    if (JS_GetOwnPropertyNamesInternal(ctx, &atoms, &len, p, JS_GPN_ENUM_ONLY | JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK) < 0)\n        goto exception;\n    for(i = 0; i < len; i++) {\n        JS_FreeValue(ctx, desc);\n        desc = JS_GetProperty(ctx, props, atoms[i].atom);\n        if (JS_IsException(desc))\n            goto exception;\n        if (JS_DefinePropertyDesc(ctx, obj, atoms[i].atom, desc, JS_PROP_THROW) < 0)\n            goto exception;\n    }\n    ret = 0;\n\nexception:\n    js_free_prop_enum(ctx, atoms, len);\n    JS_FreeValue(ctx, props);\n    JS_FreeValue(ctx, desc);\n    return ret;\n}\n\nstatic JSValue js_object_constructor(JSContext *ctx, JSValueConst new_target,\n                                     int argc, JSValueConst *argv)\n{\n    JSValue ret;\n    if (!JS_IsUndefined(new_target) &&\n        JS_VALUE_GET_OBJ(new_target) !=\n        JS_VALUE_GET_OBJ(JS_GetActiveFunction(ctx))) {\n        ret = js_create_from_ctor(ctx, new_target, JS_CLASS_OBJECT);\n    } else {\n        int tag = JS_VALUE_GET_NORM_TAG(argv[0]);\n        switch(tag) {\n        case JS_TAG_NULL:\n        case JS_TAG_UNDEFINED:\n            ret = JS_NewObject(ctx);\n            break;\n        default:\n            ret = JS_ToObject(ctx, argv[0]);\n            break;\n        }\n    }\n    return ret;\n}\n\nstatic JSValue js_object_create(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    JSValueConst proto, props;\n    JSValue obj;\n\n    proto = argv[0];\n    if (!JS_IsObject(proto) && !JS_IsNull(proto))\n        return JS_ThrowTypeError(ctx, \"not a prototype\");\n    obj = JS_NewObjectProto(ctx, proto);\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n    props = argv[1];\n    if (!JS_IsUndefined(props)) {\n        if (JS_ObjectDefineProperties(ctx, obj, props)) {\n            JS_FreeValue(ctx, obj);\n            return JS_EXCEPTION;\n        }\n    }\n    return obj;\n}\n\nstatic JSValue js_object_getPrototypeOf(JSContext *ctx, JSValueConst this_val,\n                                        int argc, JSValueConst *argv, int magic)\n{\n    JSValueConst val;\n\n    val = argv[0];\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT) {\n        /* ES6 feature non compatible with ES5.1: primitive types are\n           accepted */\n        if (magic || JS_VALUE_GET_TAG(val) == JS_TAG_NULL ||\n            JS_VALUE_GET_TAG(val) == JS_TAG_UNDEFINED)\n            return JS_ThrowTypeErrorNotAnObject(ctx);\n    }\n    return JS_GetPrototype(ctx, val);\n}\n\nstatic JSValue js_object_setPrototypeOf(JSContext *ctx, JSValueConst this_val,\n                                        int argc, JSValueConst *argv)\n{\n    JSValueConst obj;\n    obj = argv[0];\n    if (JS_SetPrototypeInternal(ctx, obj, argv[1], TRUE) < 0)\n        return JS_EXCEPTION;\n    return JS_DupValue(ctx, obj);\n}\n\n/* magic = 1 if called as Reflect.defineProperty */\nstatic JSValue js_object_defineProperty(JSContext *ctx, JSValueConst this_val,\n                                        int argc, JSValueConst *argv, int magic)\n{\n    JSValueConst obj, prop, desc;\n    int ret, flags;\n    JSAtom atom;\n\n    obj = argv[0];\n    prop = argv[1];\n    desc = argv[2];\n\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    atom = JS_ValueToAtom(ctx, prop);\n    if (unlikely(atom == JS_ATOM_NULL))\n        return JS_EXCEPTION;\n    flags = 0;\n    if (!magic)\n        flags |= JS_PROP_THROW;\n    ret = JS_DefinePropertyDesc(ctx, obj, atom, desc, flags);\n    JS_FreeAtom(ctx, atom);\n    if (ret < 0) {\n        return JS_EXCEPTION;\n    } else if (magic) {\n        return JS_NewBool(ctx, ret);\n    } else {\n        return JS_DupValue(ctx, obj);\n    }\n}\n\nstatic JSValue js_object_defineProperties(JSContext *ctx, JSValueConst this_val,\n                                          int argc, JSValueConst *argv)\n{\n    // defineProperties(obj, properties)\n    JSValueConst obj = argv[0];\n\n    if (JS_ObjectDefineProperties(ctx, obj, argv[1]))\n        return JS_EXCEPTION;\n    else\n        return JS_DupValue(ctx, obj);\n}\n\n/* magic = 1 if called as __defineSetter__ */\nstatic JSValue js_object___defineGetter__(JSContext *ctx, JSValueConst this_val,\n                                          int argc, JSValueConst *argv, int magic)\n{\n    JSValue obj;\n    JSValueConst prop, value, get, set;\n    int ret, flags;\n    JSAtom atom;\n\n    prop = argv[0];\n    value = argv[1];\n\n    obj = JS_ToObject(ctx, this_val);\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n\n    if (check_function(ctx, value)) {\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    atom = JS_ValueToAtom(ctx, prop);\n    if (unlikely(atom == JS_ATOM_NULL)) {\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    flags = JS_PROP_THROW |\n        JS_PROP_HAS_ENUMERABLE | JS_PROP_ENUMERABLE |\n        JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE;\n    if (magic) {\n        get = JS_UNDEFINED;\n        set = value;\n        flags |= JS_PROP_HAS_SET;\n    } else {\n        get = value;\n        set = JS_UNDEFINED;\n        flags |= JS_PROP_HAS_GET;\n    }\n    ret = JS_DefineProperty(ctx, obj, atom, JS_UNDEFINED, get, set, flags);\n    JS_FreeValue(ctx, obj);\n    JS_FreeAtom(ctx, atom);\n    if (ret < 0) {\n        return JS_EXCEPTION;\n    } else {\n        return JS_UNDEFINED;\n    }\n}\n\nstatic JSValue js_object_getOwnPropertyDescriptor(JSContext *ctx, JSValueConst this_val,\n                                                  int argc, JSValueConst *argv, int magic)\n{\n    JSValueConst prop;\n    JSAtom atom;\n    JSValue ret, obj;\n    JSPropertyDescriptor desc;\n    int res, flags;\n\n    if (magic) {\n        /* Reflect.getOwnPropertyDescriptor case */\n        if (JS_VALUE_GET_TAG(argv[0]) != JS_TAG_OBJECT)\n            return JS_ThrowTypeErrorNotAnObject(ctx);\n        obj = JS_DupValue(ctx, argv[0]);\n    } else {\n        obj = JS_ToObject(ctx, argv[0]);\n        if (JS_IsException(obj))\n            return obj;\n    }\n    prop = argv[1];\n    atom = JS_ValueToAtom(ctx, prop);\n    if (unlikely(atom == JS_ATOM_NULL))\n        goto exception;\n    ret = JS_UNDEFINED;\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        res = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(obj), atom);\n        if (res < 0)\n            goto exception;\n        if (res) {\n            ret = JS_NewObject(ctx);\n            if (JS_IsException(ret))\n                goto exception1;\n            flags = JS_PROP_C_W_E | JS_PROP_THROW;\n            if (desc.flags & JS_PROP_GETSET) {\n                if (JS_DefinePropertyValue(ctx, ret, JS_ATOM_get, JS_DupValue(ctx, desc.getter), flags) < 0\n                ||  JS_DefinePropertyValue(ctx, ret, JS_ATOM_set, JS_DupValue(ctx, desc.setter), flags) < 0)\n                    goto exception1;\n            } else {\n                if (JS_DefinePropertyValue(ctx, ret, JS_ATOM_value, JS_DupValue(ctx, desc.value), flags) < 0\n                ||  JS_DefinePropertyValue(ctx, ret, JS_ATOM_writable,\n                                           JS_NewBool(ctx, (desc.flags & JS_PROP_WRITABLE) != 0), flags) < 0)\n                    goto exception1;\n            }\n            if (JS_DefinePropertyValue(ctx, ret, JS_ATOM_enumerable,\n                                       JS_NewBool(ctx, (desc.flags & JS_PROP_ENUMERABLE) != 0), flags) < 0\n            ||  JS_DefinePropertyValue(ctx, ret, JS_ATOM_configurable,\n                                       JS_NewBool(ctx, (desc.flags & JS_PROP_CONFIGURABLE) != 0), flags) < 0)\n                goto exception1;\n            js_free_desc(ctx, &desc);\n        }\n    }\n    JS_FreeAtom(ctx, atom);\n    JS_FreeValue(ctx, obj);\n    return ret;\n\nexception1:\n    js_free_desc(ctx, &desc);\n    JS_FreeValue(ctx, ret);\nexception:\n    JS_FreeAtom(ctx, atom);\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_object_getOwnPropertyDescriptors(JSContext *ctx, JSValueConst this_val,\n                                                   int argc, JSValueConst *argv)\n{\n    //getOwnPropertyDescriptors(obj)\n    JSValue obj, r;\n    JSObject *p;\n    JSPropertyEnum *props;\n    uint32_t len, i;\n\n    r = JS_UNDEFINED;\n    obj = JS_ToObject(ctx, argv[0]);\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n\n    p = JS_VALUE_GET_OBJ(obj);\n    if (JS_GetOwnPropertyNamesInternal(ctx, &props, &len, p,\n                               JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK))\n        goto exception;\n    r = JS_NewObject(ctx);\n    if (JS_IsException(r))\n        goto exception;\n    for(i = 0; i < len; i++) {\n        JSValue atomValue, desc;\n        JSValueConst args[2];\n\n        atomValue = JS_AtomToValue(ctx, props[i].atom);\n        if (JS_IsException(atomValue))\n            goto exception;\n        args[0] = obj;\n        args[1] = atomValue;\n        desc = js_object_getOwnPropertyDescriptor(ctx, JS_UNDEFINED, 2, args, 0);\n        JS_FreeValue(ctx, atomValue);\n        if (JS_IsException(desc))\n            goto exception;\n        if (!JS_IsUndefined(desc)) {\n            if (JS_DefinePropertyValue(ctx, r, props[i].atom, desc,\n                                       JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n                goto exception;\n        }\n    }\n    js_free_prop_enum(ctx, props, len);\n    JS_FreeValue(ctx, obj);\n    return r;\n\nexception:\n    js_free_prop_enum(ctx, props, len);\n    JS_FreeValue(ctx, obj);\n    JS_FreeValue(ctx, r);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_GetOwnPropertyNames2(JSContext *ctx, JSValueConst obj1,\n                                       int flags, int kind)\n{\n    JSValue obj, r, val, key, value;\n    JSObject *p;\n    JSPropertyEnum *atoms;\n    uint32_t len, i, j;\n\n    r = JS_UNDEFINED;\n    val = JS_UNDEFINED;\n    obj = JS_ToObject(ctx, obj1);\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n    p = JS_VALUE_GET_OBJ(obj);\n    if (JS_GetOwnPropertyNamesInternal(ctx, &atoms, &len, p, flags & ~JS_GPN_ENUM_ONLY))\n        goto exception;\n    r = JS_NewArray(ctx);\n    if (JS_IsException(r))\n        goto exception;\n    for(j = i = 0; i < len; i++) {\n        JSAtom atom = atoms[i].atom;\n        if (flags & JS_GPN_ENUM_ONLY) {\n            JSPropertyDescriptor desc;\n            int res;\n\n            /* Check if property is still enumerable */\n            res = JS_GetOwnPropertyInternal(ctx, &desc, p, atom);\n            if (res < 0)\n                goto exception;\n            if (!res)\n                continue;\n            js_free_desc(ctx, &desc);\n            if (!(desc.flags & JS_PROP_ENUMERABLE))\n                continue;\n        }\n        switch(kind) {\n        default:\n        case JS_ITERATOR_KIND_KEY:\n            val = JS_AtomToValue(ctx, atom);\n            if (JS_IsException(val))\n                goto exception;\n            break;\n        case JS_ITERATOR_KIND_VALUE:\n            val = JS_GetProperty(ctx, obj, atom);\n            if (JS_IsException(val))\n                goto exception;\n            break;\n        case JS_ITERATOR_KIND_KEY_AND_VALUE:\n            val = JS_NewArray(ctx);\n            if (JS_IsException(val))\n                goto exception;\n            key = JS_AtomToValue(ctx, atom);\n            if (JS_IsException(key))\n                goto exception1;\n            if (JS_CreateDataPropertyUint32(ctx, val, 0, key, JS_PROP_THROW) < 0)\n                goto exception1;\n            value = JS_GetProperty(ctx, obj, atom);\n            if (JS_IsException(value))\n                goto exception1;\n            if (JS_CreateDataPropertyUint32(ctx, val, 1, value, JS_PROP_THROW) < 0)\n                goto exception1;\n            break;\n        }\n        if (JS_CreateDataPropertyUint32(ctx, r, j++, val, 0) < 0)\n            goto exception;\n    }\n    goto done;\n\nexception1:\n    JS_FreeValue(ctx, val);\nexception:\n    JS_FreeValue(ctx, r);\n    r = JS_EXCEPTION;\ndone:\n    js_free_prop_enum(ctx, atoms, len);\n    JS_FreeValue(ctx, obj);\n    return r;\n}\n\nstatic JSValue js_object_getOwnPropertyNames(JSContext *ctx, JSValueConst this_val,\n                                             int argc, JSValueConst *argv)\n{\n    return JS_GetOwnPropertyNames2(ctx, argv[0],\n                                   JS_GPN_STRING_MASK, JS_ITERATOR_KIND_KEY);\n}\n\nstatic JSValue js_object_getOwnPropertySymbols(JSContext *ctx, JSValueConst this_val,\n                                             int argc, JSValueConst *argv)\n{\n    return JS_GetOwnPropertyNames2(ctx, argv[0],\n                                   JS_GPN_SYMBOL_MASK, JS_ITERATOR_KIND_KEY);\n}\n\nstatic JSValue js_object_keys(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv, int kind)\n{\n    return JS_GetOwnPropertyNames2(ctx, argv[0],\n                                   JS_GPN_ENUM_ONLY | JS_GPN_STRING_MASK, kind);\n}\n\nstatic JSValue js_object_isExtensible(JSContext *ctx, JSValueConst this_val,\n                                      int argc, JSValueConst *argv, int reflect)\n{\n    JSValueConst obj;\n    int ret;\n\n    obj = argv[0];\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT) {\n        if (reflect)\n            return JS_ThrowTypeErrorNotAnObject(ctx);\n        else\n            return JS_FALSE;\n    }\n    ret = JS_IsExtensible(ctx, obj);\n    if (ret < 0)\n        return JS_EXCEPTION;\n    else\n        return JS_NewBool(ctx, ret);\n}\n\nstatic JSValue js_object_preventExtensions(JSContext *ctx, JSValueConst this_val,\n                                           int argc, JSValueConst *argv, int reflect)\n{\n    JSValueConst obj;\n    int ret;\n\n    obj = argv[0];\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT) {\n        if (reflect)\n            return JS_ThrowTypeErrorNotAnObject(ctx);\n        else\n            return JS_DupValue(ctx, obj);\n    }\n    ret = JS_PreventExtensions(ctx, obj);\n    if (ret < 0)\n        return JS_EXCEPTION;\n    if (reflect) {\n        return JS_NewBool(ctx, ret);\n    } else {\n        if (!ret)\n            return JS_ThrowTypeError(ctx, \"proxy preventExtensions handler returned false\");\n        return JS_DupValue(ctx, obj);\n    }\n}\n\nstatic JSValue js_object_hasOwnProperty(JSContext *ctx, JSValueConst this_val,\n                                        int argc, JSValueConst *argv)\n{\n    JSValue obj;\n    JSAtom atom;\n    JSObject *p;\n    BOOL ret;\n\n    atom = JS_ValueToAtom(ctx, argv[0]); /* must be done first */\n    if (unlikely(atom == JS_ATOM_NULL))\n        return JS_EXCEPTION;\n    obj = JS_ToObject(ctx, this_val);\n    if (JS_IsException(obj)) {\n        JS_FreeAtom(ctx, atom);\n        return obj;\n    }\n    p = JS_VALUE_GET_OBJ(obj);\n    ret = JS_GetOwnPropertyInternal(ctx, NULL, p, atom);\n    JS_FreeAtom(ctx, atom);\n    JS_FreeValue(ctx, obj);\n    if (ret < 0)\n        return JS_EXCEPTION;\n    else\n        return JS_NewBool(ctx, ret);\n}\n\nstatic JSValue js_object_valueOf(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    return JS_ToObject(ctx, this_val);\n}\n\nstatic JSValue js_object_toString(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    JSValue obj, tag;\n    int is_array;\n    JSAtom atom;\n    JSObject *p;\n\n    if (JS_IsNull(this_val)) {\n        tag = JS_NewString(ctx, \"Null\");\n    } else if (JS_IsUndefined(this_val)) {\n        tag = JS_NewString(ctx, \"Undefined\");\n    } else {\n        obj = JS_ToObject(ctx, this_val);\n        if (JS_IsException(obj))\n            return obj;\n        is_array = JS_IsArray(ctx, obj);\n        if (is_array < 0) {\n            JS_FreeValue(ctx, obj);\n            return JS_EXCEPTION;\n        }\n        if (is_array) {\n            atom = JS_ATOM_Array;\n        } else if (JS_IsFunction(ctx, obj)) {\n            atom = JS_ATOM_Function;\n        } else {\n            p = JS_VALUE_GET_OBJ(obj);\n            switch(p->class_id) {\n            case JS_CLASS_STRING:\n            case JS_CLASS_ARGUMENTS:\n            case JS_CLASS_MAPPED_ARGUMENTS:\n            case JS_CLASS_ERROR:\n            case JS_CLASS_BOOLEAN:\n            case JS_CLASS_NUMBER:\n            case JS_CLASS_DATE:\n            case JS_CLASS_REGEXP:\n                atom = ctx->rt->class_array[p->class_id].class_name;\n                break;\n            default:\n                atom = JS_ATOM_Object;\n                break;\n            }\n        }\n        tag = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_toStringTag);\n        JS_FreeValue(ctx, obj);\n        if (JS_IsException(tag))\n            return JS_EXCEPTION;\n        if (!JS_IsString(tag)) {\n            JS_FreeValue(ctx, tag);\n            tag = JS_AtomToString(ctx, atom);\n        }\n    }\n    return JS_ConcatString3(ctx, \"[object \", tag, \"]\");\n}\n\nstatic JSValue js_object_toLocaleString(JSContext *ctx, JSValueConst this_val,\n                                        int argc, JSValueConst *argv)\n{\n    return JS_Invoke(ctx, this_val, JS_ATOM_toString, 0, NULL);\n}\n\nstatic JSValue js_object_assign(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    // Object.assign(obj, source1)\n    JSValue obj, s;\n    int i;\n\n    s = JS_UNDEFINED;\n    obj = JS_ToObject(ctx, argv[0]);\n    if (JS_IsException(obj))\n        goto exception;\n    for (i = 1; i < argc; i++) {\n        if (!JS_IsNull(argv[i]) && !JS_IsUndefined(argv[i])) {\n            s = JS_ToObject(ctx, argv[i]);\n            if (JS_IsException(s))\n                goto exception;\n            if (JS_CopyDataProperties(ctx, obj, s, JS_UNDEFINED, TRUE))\n                goto exception;\n            JS_FreeValue(ctx, s);\n        }\n    }\n    return obj;\nexception:\n    JS_FreeValue(ctx, obj);\n    JS_FreeValue(ctx, s);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_object_seal(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv, int freeze_flag)\n{\n    JSValueConst obj = argv[0];\n    JSObject *p;\n    JSPropertyEnum *props;\n    uint32_t len, i;\n    int flags, desc_flags, res;\n\n    if (!JS_IsObject(obj))\n        return JS_DupValue(ctx, obj);\n\n    res = JS_PreventExtensions(ctx, obj);\n    if (res < 0)\n        return JS_EXCEPTION;\n    if (!res) {\n        return JS_ThrowTypeError(ctx, \"proxy preventExtensions handler returned false\");\n    }\n    \n    p = JS_VALUE_GET_OBJ(obj);\n    flags = JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK;\n    if (JS_GetOwnPropertyNamesInternal(ctx, &props, &len, p, flags))\n        return JS_EXCEPTION;\n\n    for(i = 0; i < len; i++) {\n        JSPropertyDescriptor desc;\n        JSAtom prop = props[i].atom;\n\n        desc_flags = JS_PROP_THROW | JS_PROP_HAS_CONFIGURABLE;\n        if (freeze_flag) {\n            res = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);\n            if (res < 0)\n                goto exception;\n            if (res) {\n                if (desc.flags & JS_PROP_WRITABLE)\n                    desc_flags |= JS_PROP_HAS_WRITABLE;\n                js_free_desc(ctx, &desc);\n            }\n        }\n        if (JS_DefineProperty(ctx, obj, prop, JS_UNDEFINED,\n                              JS_UNDEFINED, JS_UNDEFINED, desc_flags) < 0)\n            goto exception;\n    }\n    js_free_prop_enum(ctx, props, len);\n    return JS_DupValue(ctx, obj);\n\n exception:\n    js_free_prop_enum(ctx, props, len);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_object_isSealed(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv, int is_frozen)\n{\n    JSValueConst obj = argv[0];\n    JSObject *p;\n    JSPropertyEnum *props;\n    uint32_t len, i;\n    int flags, res;\n    \n    if (!JS_IsObject(obj))\n        return JS_TRUE;\n\n    p = JS_VALUE_GET_OBJ(obj);\n    flags = JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK;\n    if (JS_GetOwnPropertyNamesInternal(ctx, &props, &len, p, flags))\n        return JS_EXCEPTION;\n\n    for(i = 0; i < len; i++) {\n        JSPropertyDescriptor desc;\n        JSAtom prop = props[i].atom;\n\n        res = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);\n        if (res < 0)\n            goto exception;\n        if (res) {\n            js_free_desc(ctx, &desc);\n            if ((desc.flags & JS_PROP_CONFIGURABLE)\n            ||  (is_frozen && (desc.flags & JS_PROP_WRITABLE))) {\n                res = FALSE;\n                goto done;\n            }\n        }\n    }\n    res = JS_IsExtensible(ctx, obj);\n    if (res < 0)\n        return JS_EXCEPTION;\n    res ^= 1;\ndone:        \n    js_free_prop_enum(ctx, props, len);\n    return JS_NewBool(ctx, res);\n\nexception:\n    js_free_prop_enum(ctx, props, len);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_object_fromEntries(JSContext *ctx, JSValueConst this_val,\n                                     int argc, JSValueConst *argv)\n{\n    JSValue obj, iter, next_method = JS_UNDEFINED;\n    JSValueConst iterable;\n    BOOL done;\n\n    /*  RequireObjectCoercible() not necessary because it is tested in\n        JS_GetIterator() by JS_GetProperty() */\n    iterable = argv[0];\n\n    obj = JS_NewObject(ctx);\n    if (JS_IsException(obj))\n        return obj;\n    \n    iter = JS_GetIterator(ctx, iterable, FALSE);\n    if (JS_IsException(iter))\n        goto fail;\n    next_method = JS_GetProperty(ctx, iter, JS_ATOM_next);\n    if (JS_IsException(next_method))\n        goto fail;\n    \n    for(;;) {\n        JSValue key, value, item;\n        item = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);\n        if (JS_IsException(item))\n            goto fail;\n        if (done) {\n            JS_FreeValue(ctx, item);\n            break;\n        }\n        \n        key = JS_UNDEFINED;\n        value = JS_UNDEFINED;\n        if (!JS_IsObject(item)) {\n            JS_ThrowTypeErrorNotAnObject(ctx);\n            goto fail1;\n        }\n        key = JS_GetPropertyUint32(ctx, item, 0);\n        if (JS_IsException(key))\n            goto fail1;\n        value = JS_GetPropertyUint32(ctx, item, 1);\n        if (JS_IsException(value)) {\n            JS_FreeValue(ctx, key);\n            goto fail1;\n        }\n        if (JS_DefinePropertyValueValue(ctx, obj, key, value,\n                                        JS_PROP_C_W_E | JS_PROP_THROW) < 0) {\n        fail1:\n            JS_FreeValue(ctx, item);\n            goto fail;\n        }\n        JS_FreeValue(ctx, item);\n    }\n    JS_FreeValue(ctx, next_method);\n    JS_FreeValue(ctx, iter);\n    return obj;\n fail:\n    if (JS_IsObject(iter)) {\n        /* close the iterator object, preserving pending exception */\n        JS_IteratorClose(ctx, iter, TRUE);\n    }\n    JS_FreeValue(ctx, next_method);\n    JS_FreeValue(ctx, iter);\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\n#if 0\n/* Note: corresponds to ECMA spec: CreateDataPropertyOrThrow() */\nstatic JSValue js_object___setOwnProperty(JSContext *ctx, JSValueConst this_val,\n                                          int argc, JSValueConst *argv)\n{\n    int ret;\n    ret = JS_DefinePropertyValueValue(ctx, argv[0], JS_DupValue(ctx, argv[1]),\n                                      JS_DupValue(ctx, argv[2]),\n                                      JS_PROP_C_W_E | JS_PROP_THROW);\n    if (ret < 0)\n        return JS_EXCEPTION;\n    else\n        return JS_NewBool(ctx, ret);\n}\n\nstatic JSValue js_object___toObject(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv)\n{\n    return JS_ToObject(ctx, argv[0]);\n}\n\nstatic JSValue js_object___toPrimitive(JSContext *ctx, JSValueConst this_val,\n                                       int argc, JSValueConst *argv)\n{\n    int hint = HINT_NONE;\n\n    if (JS_VALUE_GET_TAG(argv[1]) == JS_TAG_INT)\n        hint = JS_VALUE_GET_INT(argv[1]);\n\n    return JS_ToPrimitive(ctx, argv[0], hint);\n}\n#endif\n\n/* return an empty string if not an object */\nstatic JSValue js_object___getClass(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv)\n{\n    JSAtom atom;\n    JSObject *p;\n    uint32_t tag;\n    int class_id;\n\n    tag = JS_VALUE_GET_NORM_TAG(argv[0]);\n    if (tag == JS_TAG_OBJECT) {\n        p = JS_VALUE_GET_OBJ(argv[0]);\n        class_id = p->class_id;\n        if (class_id == JS_CLASS_PROXY && JS_IsFunction(ctx, argv[0]))\n            class_id = JS_CLASS_BYTECODE_FUNCTION;\n        atom = ctx->rt->class_array[class_id].class_name;\n    } else {\n        atom = JS_ATOM_empty_string;\n    }\n    return JS_AtomToString(ctx, atom);\n}\n\nstatic JSValue js_object_is(JSContext *ctx, JSValueConst this_val,\n                            int argc, JSValueConst *argv)\n{\n    return JS_NewBool(ctx, js_same_value(ctx, argv[0], argv[1]));\n}\n\n#if 0\nstatic JSValue js_object___getObjectData(JSContext *ctx, JSValueConst this_val,\n                                         int argc, JSValueConst *argv)\n{\n    return JS_GetObjectData(ctx, argv[0]);\n}\n\nstatic JSValue js_object___setObjectData(JSContext *ctx, JSValueConst this_val,\n                                         int argc, JSValueConst *argv)\n{\n    if (JS_SetObjectData(ctx, argv[0], JS_DupValue(ctx, argv[1])))\n        return JS_EXCEPTION;\n    return JS_DupValue(ctx, argv[1]);\n}\n\nstatic JSValue js_object___toPropertyKey(JSContext *ctx, JSValueConst this_val,\n                                         int argc, JSValueConst *argv)\n{\n    return JS_ToPropertyKey(ctx, argv[0]);\n}\n\nstatic JSValue js_object___isObject(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv)\n{\n    return JS_NewBool(ctx, JS_IsObject(argv[0]));\n}\n\nstatic JSValue js_object___isSameValueZero(JSContext *ctx, JSValueConst this_val,\n                                           int argc, JSValueConst *argv)\n{\n    return JS_NewBool(ctx, js_same_value_zero(ctx, argv[0], argv[1]));\n}\n\nstatic JSValue js_object___isConstructor(JSContext *ctx, JSValueConst this_val,\n                                         int argc, JSValueConst *argv)\n{\n    return JS_NewBool(ctx, JS_IsConstructor(ctx, argv[0]));\n}\n#endif\n\nstatic JSValue JS_SpeciesConstructor(JSContext *ctx, JSValueConst obj,\n                                     JSValueConst defaultConstructor)\n{\n    JSValue ctor, species;\n\n    if (!JS_IsObject(obj))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    ctor = JS_GetProperty(ctx, obj, JS_ATOM_constructor);\n    if (JS_IsException(ctor))\n        return ctor;\n    if (JS_IsUndefined(ctor))\n        return JS_DupValue(ctx, defaultConstructor);\n    if (!JS_IsObject(ctor)) {\n        JS_FreeValue(ctx, ctor);\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    }\n    species = JS_GetProperty(ctx, ctor, JS_ATOM_Symbol_species);\n    JS_FreeValue(ctx, ctor);\n    if (JS_IsException(species))\n        return species;\n    if (JS_IsUndefined(species) || JS_IsNull(species))\n        return JS_DupValue(ctx, defaultConstructor);\n    if (!JS_IsConstructor(ctx, species)) {\n        JS_FreeValue(ctx, species);\n        return JS_ThrowTypeError(ctx, \"not a constructor\");\n    }\n    return species;\n}\n\n#if 0\nstatic JSValue js_object___speciesConstructor(JSContext *ctx, JSValueConst this_val,\n                                              int argc, JSValueConst *argv)\n{\n    return JS_SpeciesConstructor(ctx, argv[0], argv[1]);\n}\n#endif\n\nstatic JSValue js_object_get___proto__(JSContext *ctx, JSValueConst this_val)\n{\n    JSValue val, ret;\n\n    val = JS_ToObject(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    ret = JS_GetPrototype(ctx, val);\n    JS_FreeValue(ctx, val);\n    return ret;\n}\n\nstatic JSValue js_object_set___proto__(JSContext *ctx, JSValueConst this_val,\n                                       JSValueConst proto)\n{\n    if (JS_IsUndefined(this_val) || JS_IsNull(this_val))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    if (!JS_IsObject(proto) && !JS_IsNull(proto))\n        return JS_UNDEFINED;\n    if (JS_SetPrototypeInternal(ctx, this_val, proto, TRUE) < 0)\n        return JS_EXCEPTION;\n    else\n        return JS_UNDEFINED;\n}\n\nstatic JSValue js_object_isPrototypeOf(JSContext *ctx, JSValueConst this_val,\n                                       int argc, JSValueConst *argv)\n{\n    JSValue obj, v1;\n    JSValueConst v;\n    int res;\n\n    v = argv[0];\n    if (!JS_IsObject(v))\n        return JS_FALSE;\n    obj = JS_ToObject(ctx, this_val);\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n    v1 = JS_DupValue(ctx, v);\n    for(;;) {\n        v1 = JS_GetPrototypeFree(ctx, v1);\n        if (JS_IsException(v1))\n            goto exception;\n        if (JS_IsNull(v1)) {\n            res = FALSE;\n            break;\n        }\n        if (JS_VALUE_GET_OBJ(obj) == JS_VALUE_GET_OBJ(v1)) {\n            res = TRUE;\n            break;\n        }\n        /* avoid infinite loop (possible with proxies) */\n        if (js_poll_interrupts(ctx))\n            goto exception;\n    }\n    JS_FreeValue(ctx, v1);\n    JS_FreeValue(ctx, obj);\n    return JS_NewBool(ctx, res);\n\nexception:\n    JS_FreeValue(ctx, v1);\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_object_propertyIsEnumerable(JSContext *ctx, JSValueConst this_val,\n                                              int argc, JSValueConst *argv)\n{\n    JSValue obj, res = JS_EXCEPTION;\n    JSAtom prop = JS_ATOM_NULL;\n    JSPropertyDescriptor desc;\n    int has_prop;\n\n    obj = JS_ToObject(ctx, this_val);\n    if (JS_IsException(obj))\n        goto exception;\n    prop = JS_ValueToAtom(ctx, argv[0]);\n    if (unlikely(prop == JS_ATOM_NULL))\n        goto exception;\n\n    has_prop = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(obj), prop);\n    if (has_prop < 0)\n        goto exception;\n    if (has_prop) {\n        res = JS_NewBool(ctx, (desc.flags & JS_PROP_ENUMERABLE) != 0);\n        js_free_desc(ctx, &desc);\n    } else {\n        res = JS_FALSE;\n    }\n\nexception:\n    JS_FreeAtom(ctx, prop);\n    JS_FreeValue(ctx, obj);\n    return res;\n}\n\nstatic JSValue js_object___lookupGetter__(JSContext *ctx, JSValueConst this_val,\n                                          int argc, JSValueConst *argv, int setter)\n{\n    JSValue obj, res = JS_EXCEPTION;\n    JSAtom prop = JS_ATOM_NULL;\n    JSPropertyDescriptor desc;\n    int has_prop;\n\n    obj = JS_ToObject(ctx, this_val);\n    if (JS_IsException(obj))\n        goto exception;\n    prop = JS_ValueToAtom(ctx, argv[0]);\n    if (unlikely(prop == JS_ATOM_NULL))\n        goto exception;\n\n    for (;;) {\n        has_prop = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(obj), prop);\n        if (has_prop < 0)\n            goto exception;\n        if (has_prop) {\n            if (desc.flags & JS_PROP_GETSET)\n                res = JS_DupValue(ctx, setter ? desc.setter : desc.getter);\n            else\n                res = JS_UNDEFINED;\n            js_free_desc(ctx, &desc);\n            break;\n        }\n        obj = JS_GetPrototypeFree(ctx, obj);\n        if (JS_IsException(obj))\n            goto exception;\n        if (JS_IsNull(obj)) {\n            res = JS_UNDEFINED;\n            break;\n        }\n        /* avoid infinite loop (possible with proxies) */\n        if (js_poll_interrupts(ctx))\n            goto exception;\n    }\n\nexception:\n    JS_FreeAtom(ctx, prop);\n    JS_FreeValue(ctx, obj);\n    return res;\n}\n\nstatic const JSCFunctionListEntry js_object_funcs[] = {\n    JS_CFUNC_DEF(\"create\", 2, js_object_create ),\n    JS_CFUNC_MAGIC_DEF(\"getPrototypeOf\", 1, js_object_getPrototypeOf, 0 ),\n    JS_CFUNC_DEF(\"setPrototypeOf\", 2, js_object_setPrototypeOf ),\n    JS_CFUNC_MAGIC_DEF(\"defineProperty\", 3, js_object_defineProperty, 0 ),\n    JS_CFUNC_DEF(\"defineProperties\", 2, js_object_defineProperties ),\n    JS_CFUNC_DEF(\"getOwnPropertyNames\", 1, js_object_getOwnPropertyNames ),\n    JS_CFUNC_DEF(\"getOwnPropertySymbols\", 1, js_object_getOwnPropertySymbols ),\n    JS_CFUNC_MAGIC_DEF(\"keys\", 1, js_object_keys, JS_ITERATOR_KIND_KEY ),\n    JS_CFUNC_MAGIC_DEF(\"values\", 1, js_object_keys, JS_ITERATOR_KIND_VALUE ),\n    JS_CFUNC_MAGIC_DEF(\"entries\", 1, js_object_keys, JS_ITERATOR_KIND_KEY_AND_VALUE ),\n    JS_CFUNC_MAGIC_DEF(\"isExtensible\", 1, js_object_isExtensible, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"preventExtensions\", 1, js_object_preventExtensions, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"getOwnPropertyDescriptor\", 2, js_object_getOwnPropertyDescriptor, 0 ),\n    JS_CFUNC_DEF(\"getOwnPropertyDescriptors\", 1, js_object_getOwnPropertyDescriptors ),\n    JS_CFUNC_DEF(\"is\", 2, js_object_is ),\n    JS_CFUNC_DEF(\"assign\", 2, js_object_assign ),\n    JS_CFUNC_MAGIC_DEF(\"seal\", 1, js_object_seal, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"freeze\", 1, js_object_seal, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"isSealed\", 1, js_object_isSealed, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"isFrozen\", 1, js_object_isSealed, 1 ),\n    JS_CFUNC_DEF(\"__getClass\", 1, js_object___getClass ),\n    //JS_CFUNC_DEF(\"__isObject\", 1, js_object___isObject ),\n    //JS_CFUNC_DEF(\"__isConstructor\", 1, js_object___isConstructor ),\n    //JS_CFUNC_DEF(\"__toObject\", 1, js_object___toObject ),\n    //JS_CFUNC_DEF(\"__setOwnProperty\", 3, js_object___setOwnProperty ),\n    //JS_CFUNC_DEF(\"__toPrimitive\", 2, js_object___toPrimitive ),\n    //JS_CFUNC_DEF(\"__toPropertyKey\", 1, js_object___toPropertyKey ),\n    //JS_CFUNC_DEF(\"__speciesConstructor\", 2, js_object___speciesConstructor ),\n    //JS_CFUNC_DEF(\"__isSameValueZero\", 2, js_object___isSameValueZero ),\n    //JS_CFUNC_DEF(\"__getObjectData\", 1, js_object___getObjectData ),\n    //JS_CFUNC_DEF(\"__setObjectData\", 2, js_object___setObjectData ),\n    JS_CFUNC_DEF(\"fromEntries\", 1, js_object_fromEntries ),\n};\n\nstatic const JSCFunctionListEntry js_object_proto_funcs[] = {\n    JS_CFUNC_DEF(\"toString\", 0, js_object_toString ),\n    JS_CFUNC_DEF(\"toLocaleString\", 0, js_object_toLocaleString ),\n    JS_CFUNC_DEF(\"valueOf\", 0, js_object_valueOf ),\n    JS_CFUNC_DEF(\"hasOwnProperty\", 1, js_object_hasOwnProperty ),\n    JS_CFUNC_DEF(\"isPrototypeOf\", 1, js_object_isPrototypeOf ),\n    JS_CFUNC_DEF(\"propertyIsEnumerable\", 1, js_object_propertyIsEnumerable ),\n    JS_CGETSET_DEF(\"__proto__\", js_object_get___proto__, js_object_set___proto__ ),\n    JS_CFUNC_MAGIC_DEF(\"__defineGetter__\", 2, js_object___defineGetter__, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"__defineSetter__\", 2, js_object___defineGetter__, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"__lookupGetter__\", 1, js_object___lookupGetter__, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"__lookupSetter__\", 1, js_object___lookupGetter__, 1 ),\n};\n\n/* Function class */\n\nstatic JSValue js_function_proto(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    return JS_UNDEFINED;\n}\n\n/* XXX: add a specific eval mode so that Function(\"}), ({\") is rejected */\nstatic JSValue js_function_constructor(JSContext *ctx, JSValueConst new_target,\n                                       int argc, JSValueConst *argv, int magic)\n{\n    JSFunctionKindEnum func_kind = magic;\n    int i, n, ret;\n    JSValue s, proto, obj = JS_UNDEFINED;\n    StringBuffer b_s, *b = &b_s;\n\n    string_buffer_init(ctx, b, 0);\n    string_buffer_putc8(b, '(');\n    \n    if (func_kind == JS_FUNC_ASYNC || func_kind == JS_FUNC_ASYNC_GENERATOR) {\n        string_buffer_puts8(b, \"async \");\n    }\n    string_buffer_puts8(b, \"function\");\n\n    if (func_kind == JS_FUNC_GENERATOR || func_kind == JS_FUNC_ASYNC_GENERATOR) {\n        string_buffer_putc8(b, '*');\n    }\n    string_buffer_puts8(b, \" anonymous(\");\n\n    n = argc - 1;\n    for(i = 0; i < n; i++) {\n        if (i != 0) {\n            string_buffer_putc8(b, ',');\n        }\n        if (string_buffer_concat_value(b, argv[i]))\n            goto fail;\n    }\n    string_buffer_puts8(b, \"\\n) {\\n\");\n    if (n >= 0) {\n        if (string_buffer_concat_value(b, argv[n]))\n            goto fail;\n    }\n    string_buffer_puts8(b, \"\\n})\");\n    s = string_buffer_end(b);\n    if (JS_IsException(s))\n        goto fail1;\n\n    obj = JS_EvalObject(ctx, ctx->global_obj, s, JS_EVAL_TYPE_INDIRECT, -1);\n    JS_FreeValue(ctx, s);\n    if (JS_IsException(obj))\n        goto fail1;\n    if (!JS_IsUndefined(new_target)) {\n        /* set the prototype */\n        proto = JS_GetProperty(ctx, new_target, JS_ATOM_prototype);\n        if (JS_IsException(proto))\n            goto fail1;\n        if (!JS_IsObject(proto)) {\n            JSContext *realm;\n            JS_FreeValue(ctx, proto);\n            realm = JS_GetFunctionRealm(ctx, new_target);\n            if (!realm)\n                goto fail1;\n            proto = JS_DupValue(ctx, realm->class_proto[func_kind_to_class_id[func_kind]]);\n        }\n        ret = JS_SetPrototypeInternal(ctx, obj, proto, TRUE);\n        JS_FreeValue(ctx, proto);\n        if (ret < 0)\n            goto fail1;\n    }\n    return obj;\n\n fail:\n    string_buffer_free(b);\n fail1:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic __exception int js_get_length32(JSContext *ctx, uint32_t *pres,\n                                       JSValueConst obj)\n{\n    JSValue len_val;\n    len_val = JS_GetProperty(ctx, obj, JS_ATOM_length);\n    if (JS_IsException(len_val)) {\n        *pres = 0;\n        return -1;\n    }\n    return JS_ToUint32Free(ctx, pres, len_val);\n}\n\nstatic __exception int js_get_length64(JSContext *ctx, int64_t *pres,\n                                       JSValueConst obj)\n{\n    JSValue len_val;\n    len_val = JS_GetProperty(ctx, obj, JS_ATOM_length);\n    if (JS_IsException(len_val)) {\n        *pres = 0;\n        return -1;\n    }\n    return JS_ToLengthFree(ctx, pres, len_val);\n}\n\nstatic void free_arg_list(JSContext *ctx, JSValue *tab, uint32_t len)\n{\n    uint32_t i;\n    for(i = 0; i < len; i++) {\n        JS_FreeValue(ctx, tab[i]);\n    }\n    js_free(ctx, tab);\n}\n\n/* XXX: should use ValueArray */\nstatic JSValue *build_arg_list(JSContext *ctx, uint32_t *plen,\n                               JSValueConst array_arg)\n{\n    uint32_t len, i;\n    JSValue *tab, ret;\n    JSObject *p;\n\n    if (JS_VALUE_GET_TAG(array_arg) != JS_TAG_OBJECT) {\n        JS_ThrowTypeError(ctx, \"not a object\");\n        return NULL;\n    }\n    if (js_get_length32(ctx, &len, array_arg))\n        return NULL;\n    if (len > JS_MAX_LOCAL_VARS) {\n        JS_ThrowInternalError(ctx, \"too many arguments\");\n        return NULL;\n    }\n    /* avoid allocating 0 bytes */\n    tab = js_mallocz(ctx, sizeof(tab[0]) * max_uint32(1, len));\n    if (!tab)\n        return NULL;\n    p = JS_VALUE_GET_OBJ(array_arg);\n    if ((p->class_id == JS_CLASS_ARRAY || p->class_id == JS_CLASS_ARGUMENTS) &&\n        p->fast_array &&\n        len == p->u.array.count) {\n        for(i = 0; i < len; i++) {\n            tab[i] = JS_DupValue(ctx, p->u.array.u.values[i]);\n        }\n    } else {\n        for(i = 0; i < len; i++) {\n            ret = JS_GetPropertyUint32(ctx, array_arg, i);\n            if (JS_IsException(ret)) {\n                free_arg_list(ctx, tab, i);\n                return NULL;\n            }\n            tab[i] = ret;\n        }\n    }\n    *plen = len;\n    return tab;\n}\n\n/* magic value: 0 = normal apply, 1 = apply for constructor, 2 =\n   Reflect.apply */\nstatic JSValue js_function_apply(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv, int magic)\n{\n    JSValueConst this_arg, array_arg;\n    uint32_t len;\n    JSValue *tab, ret;\n\n    if (check_function(ctx, this_val))\n        return JS_EXCEPTION;\n    this_arg = argv[0];\n    array_arg = argv[1];\n    if ((JS_VALUE_GET_TAG(array_arg) == JS_TAG_UNDEFINED ||\n         JS_VALUE_GET_TAG(array_arg) == JS_TAG_NULL) && magic != 2) {\n        return JS_Call(ctx, this_val, this_arg, 0, NULL);\n    }\n    tab = build_arg_list(ctx, &len, array_arg);\n    if (!tab)\n        return JS_EXCEPTION;\n    if (magic & 1) {\n        ret = JS_CallConstructor2(ctx, this_val, this_arg, len, (JSValueConst *)tab);\n    } else {\n        ret = JS_Call(ctx, this_val, this_arg, len, (JSValueConst *)tab);\n    }\n    free_arg_list(ctx, tab, len);\n    return ret;\n}\n\nstatic JSValue js_function_call(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    if (argc <= 0) {\n        return JS_Call(ctx, this_val, JS_UNDEFINED, 0, NULL);\n    } else {\n        return JS_Call(ctx, this_val, argv[0], argc - 1, argv + 1);\n    }\n}\n\nstatic JSValue js_function_bind(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    JSBoundFunction *bf;\n    JSValue func_obj, name1, len_val;\n    JSObject *p;\n    int arg_count, i, ret;\n\n    if (check_function(ctx, this_val))\n        return JS_EXCEPTION;\n\n    func_obj = JS_NewObjectProtoClass(ctx, ctx->function_proto,\n                                 JS_CLASS_BOUND_FUNCTION);\n    if (JS_IsException(func_obj))\n        return JS_EXCEPTION;\n    p = JS_VALUE_GET_OBJ(func_obj);\n    p->is_constructor = JS_IsConstructor(ctx, this_val);\n    arg_count = max_int(0, argc - 1);\n    bf = js_malloc(ctx, sizeof(*bf) + arg_count * sizeof(JSValue));\n    if (!bf)\n        goto exception;\n    bf->func_obj = JS_DupValue(ctx, this_val);\n    bf->this_val = JS_DupValue(ctx, argv[0]);\n    bf->argc = arg_count;\n    for(i = 0; i < arg_count; i++) {\n        bf->argv[i] = JS_DupValue(ctx, argv[i + 1]);\n    }\n    p->u.bound_function = bf;\n\n    /* XXX: the spec could be simpler by only using GetOwnProperty */\n    ret = JS_GetOwnProperty(ctx, NULL, this_val, JS_ATOM_length);\n    if (ret < 0)\n        goto exception;\n    if (!ret) {\n        len_val = JS_NewInt32(ctx, 0);\n    } else {\n        len_val = JS_GetProperty(ctx, this_val, JS_ATOM_length);\n        if (JS_IsException(len_val))\n            goto exception;\n        if (JS_VALUE_GET_TAG(len_val) == JS_TAG_INT) {\n            /* most common case */\n            int len1 = JS_VALUE_GET_INT(len_val);\n            if (len1 <= arg_count)\n                len1 = 0;\n            else\n                len1 -= arg_count;\n            len_val = JS_NewInt32(ctx, len1);\n        } else if (JS_VALUE_GET_NORM_TAG(len_val) == JS_TAG_FLOAT64) {\n            double d = JS_VALUE_GET_FLOAT64(len_val);\n            if (isnan(d)) {\n                d = 0.0;\n            } else {\n                d = trunc(d);\n                if (d <= (double)arg_count)\n                    d = 0.0;\n                else\n                    d -= (double)arg_count; /* also converts -0 to +0 */\n            }\n            len_val = JS_NewFloat64(ctx, d);\n        } else {\n            JS_FreeValue(ctx, len_val);\n            len_val = JS_NewInt32(ctx, 0);\n        }\n    }\n    JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_length,\n                           len_val, JS_PROP_CONFIGURABLE);\n\n    name1 = JS_GetProperty(ctx, this_val, JS_ATOM_name);\n    if (JS_IsException(name1))\n        goto exception;\n    if (!JS_IsString(name1)) {\n        JS_FreeValue(ctx, name1);\n        name1 = JS_AtomToString(ctx, JS_ATOM_empty_string);\n    }\n    name1 = JS_ConcatString3(ctx, \"bound \", name1, \"\");\n    if (JS_IsException(name1))\n        goto exception;\n    JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_name, name1,\n                           JS_PROP_CONFIGURABLE);\n    return func_obj;\n exception:\n    JS_FreeValue(ctx, func_obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_function_toString(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv)\n{\n    JSObject *p;\n    JSFunctionKindEnum func_kind = JS_FUNC_NORMAL;\n\n    if (check_function(ctx, this_val))\n        return JS_EXCEPTION;\n\n    p = JS_VALUE_GET_OBJ(this_val);\n    if (js_class_has_bytecode(p->class_id)) {\n        JSFunctionBytecode *b = p->u.func.function_bytecode;\n        if (b->has_debug && b->debug.source) {\n            return JS_NewStringLen(ctx, b->debug.source, b->debug.source_len);\n        }\n        func_kind = b->func_kind;\n    }\n    {\n        JSValue name;\n        const char *pref, *suff;\n\n        switch(func_kind) {\n        default:\n        case JS_FUNC_NORMAL:\n            pref = \"function \";\n            break;\n        case JS_FUNC_GENERATOR:\n            pref = \"function *\";\n            break;\n        case JS_FUNC_ASYNC:\n            pref = \"async function \";\n            break;\n        case JS_FUNC_ASYNC_GENERATOR:\n            pref = \"async function *\";\n            break;\n        }\n        suff = \"() {\\n    [native code]\\n}\";\n        name = JS_GetProperty(ctx, this_val, JS_ATOM_name);\n        if (JS_IsUndefined(name))\n            name = JS_AtomToString(ctx, JS_ATOM_empty_string);\n        return JS_ConcatString3(ctx, pref, name, suff);\n    }\n}\n\nstatic JSValue js_function_hasInstance(JSContext *ctx, JSValueConst this_val,\n                                       int argc, JSValueConst *argv)\n{\n    int ret;\n    ret = JS_OrdinaryIsInstanceOf(ctx, argv[0], this_val);\n    if (ret < 0)\n        return JS_EXCEPTION;\n    else\n        return JS_NewBool(ctx, ret);\n}\n\nstatic const JSCFunctionListEntry js_function_proto_funcs[] = {\n    JS_CFUNC_DEF(\"call\", 1, js_function_call ),\n    JS_CFUNC_MAGIC_DEF(\"apply\", 2, js_function_apply, 0 ),\n    JS_CFUNC_DEF(\"bind\", 1, js_function_bind ),\n    JS_CFUNC_DEF(\"toString\", 0, js_function_toString ),\n    JS_CFUNC_DEF(\"[Symbol.hasInstance]\", 1, js_function_hasInstance ),\n    JS_CGETSET_DEF(\"fileName\", js_function_proto_fileName, NULL ),\n    JS_CGETSET_DEF(\"lineNumber\", js_function_proto_lineNumber, NULL ),\n};\n\n/* Error class */\n\nstatic JSValue iterator_to_array(JSContext *ctx, JSValueConst items)\n{\n    JSValue iter, next_method = JS_UNDEFINED;\n    JSValue v, r = JS_UNDEFINED;\n    int64_t k;\n    BOOL done;\n    \n    iter = JS_GetIterator(ctx, items, FALSE);\n    if (JS_IsException(iter))\n        goto exception;\n    next_method = JS_GetProperty(ctx, iter, JS_ATOM_next);\n    if (JS_IsException(next_method))\n        goto exception;\n    r = JS_NewArray(ctx);\n    if (JS_IsException(r))\n        goto exception;\n    for (k = 0;; k++) {\n        v = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);\n        if (JS_IsException(v))\n            goto exception_close;\n        if (done)\n            break;\n        if (JS_DefinePropertyValueInt64(ctx, r, k, v,\n                                        JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n            goto exception_close;\n    }\n done:\n    JS_FreeValue(ctx, next_method);\n    JS_FreeValue(ctx, iter);\n    return r;\n exception_close:\n    JS_IteratorClose(ctx, iter, TRUE);\n exception:\n    JS_FreeValue(ctx, r);\n    r = JS_EXCEPTION;\n    goto done;\n}\n\nstatic JSValue js_error_constructor(JSContext *ctx, JSValueConst new_target,\n                                    int argc, JSValueConst *argv, int magic)\n{\n    JSValue obj, msg, proto;\n    JSValueConst message;\n\n    if (JS_IsUndefined(new_target))\n        new_target = JS_GetActiveFunction(ctx);\n    proto = JS_GetProperty(ctx, new_target, JS_ATOM_prototype);\n    if (JS_IsException(proto))\n        return proto;\n    if (!JS_IsObject(proto)) {\n        JSContext *realm;\n        JSValueConst proto1;\n        \n        JS_FreeValue(ctx, proto);\n        realm = JS_GetFunctionRealm(ctx, new_target);\n        if (!realm)\n            return JS_EXCEPTION;\n        if (magic < 0) {\n            proto1 = realm->class_proto[JS_CLASS_ERROR];\n        } else {\n            proto1 = realm->native_error_proto[magic];\n        }\n        proto = JS_DupValue(ctx, proto1);\n    }\n    obj = JS_NewObjectProtoClass(ctx, proto, JS_CLASS_ERROR);\n    JS_FreeValue(ctx, proto);\n    if (JS_IsException(obj))\n        return obj;\n    if (magic == JS_AGGREGATE_ERROR) {\n        message = argv[1];\n    } else {\n        message = argv[0];\n    }\n\n    if (!JS_IsUndefined(message)) {\n        msg = JS_ToString(ctx, message);\n        if (unlikely(JS_IsException(msg)))\n            goto exception;\n        JS_DefinePropertyValue(ctx, obj, JS_ATOM_message, msg,\n                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    }\n\n    if (magic == JS_AGGREGATE_ERROR) {\n        JSValue error_list = iterator_to_array(ctx, argv[0]);\n        if (JS_IsException(error_list))\n            goto exception;\n        JS_DefinePropertyValue(ctx, obj, JS_ATOM_errors, error_list,\n                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    }\n\n    /* skip the Error() function in the backtrace */\n    build_backtrace(ctx, obj, NULL, 0, JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL);\n    return obj;\n exception:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_error_toString(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    JSValue name, msg;\n\n    if (!JS_IsObject(this_val))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    name = JS_GetProperty(ctx, this_val, JS_ATOM_name);\n    if (JS_IsUndefined(name))\n        name = JS_AtomToString(ctx, JS_ATOM_Error);\n    else\n        name = JS_ToStringFree(ctx, name);\n    if (JS_IsException(name))\n        return JS_EXCEPTION;\n\n    msg = JS_GetProperty(ctx, this_val, JS_ATOM_message);\n    if (JS_IsUndefined(msg))\n        msg = JS_AtomToString(ctx, JS_ATOM_empty_string);\n    else\n        msg = JS_ToStringFree(ctx, msg);\n    if (JS_IsException(msg)) {\n        JS_FreeValue(ctx, name);\n        return JS_EXCEPTION;\n    }\n    if (!JS_IsEmptyString(name) && !JS_IsEmptyString(msg))\n        name = JS_ConcatString3(ctx, \"\", name, \": \");\n    return JS_ConcatString(ctx, name, msg);\n}\n\nstatic const JSCFunctionListEntry js_error_proto_funcs[] = {\n    JS_CFUNC_DEF(\"toString\", 0, js_error_toString ),\n    JS_PROP_STRING_DEF(\"name\", \"Error\", JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE ),\n    JS_PROP_STRING_DEF(\"message\", \"\", JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE ),\n};\n\n/* AggregateError */\n\n/* used by C code. */\nstatic JSValue js_aggregate_error_constructor(JSContext *ctx,\n                                              JSValueConst errors)\n{\n    JSValue obj;\n    \n    obj = JS_NewObjectProtoClass(ctx,\n                                 ctx->native_error_proto[JS_AGGREGATE_ERROR],\n                                 JS_CLASS_ERROR);\n    if (JS_IsException(obj))\n        return obj;\n    JS_DefinePropertyValue(ctx, obj, JS_ATOM_errors, JS_DupValue(ctx, errors),\n                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    return obj;\n}\n\n/* Array */\n\nstatic int JS_CopySubArray(JSContext *ctx,\n                           JSValueConst obj, int64_t to_pos,\n                           int64_t from_pos, int64_t count, int dir)\n{\n    int64_t i, from, to;\n    JSValue val;\n    int fromPresent;\n\n    /* XXX: should special case fast arrays */\n    for (i = 0; i < count; i++) {\n        if (dir < 0) {\n            from = from_pos + count - i - 1;\n            to = to_pos + count - i - 1;\n        } else {\n            from = from_pos + i;\n            to = to_pos + i;\n        }\n        fromPresent = JS_TryGetPropertyInt64(ctx, obj, from, &val);\n        if (fromPresent < 0)\n            goto exception;\n\n        if (fromPresent) {\n            if (JS_SetPropertyInt64(ctx, obj, to, val) < 0)\n                goto exception;\n        } else {\n            if (JS_DeletePropertyInt64(ctx, obj, to, JS_PROP_THROW) < 0)\n                goto exception;\n        }\n    }\n    return 0;\n\n exception:\n    return -1;\n}\n\nstatic JSValue js_array_constructor(JSContext *ctx, JSValueConst new_target,\n                                    int argc, JSValueConst *argv)\n{\n    JSValue obj;\n    int i;\n\n    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_ARRAY);\n    if (JS_IsException(obj))\n        return obj;\n    if (argc == 1 && JS_IsNumber(argv[0])) {\n        uint32_t len;\n        if (JS_ToArrayLengthFree(ctx, &len, JS_DupValue(ctx, argv[0]), TRUE))\n            goto fail;\n        if (JS_SetProperty(ctx, obj, JS_ATOM_length, JS_NewUint32(ctx, len)) < 0)\n            goto fail;\n    } else {\n        for(i = 0; i < argc; i++) {\n            if (JS_SetPropertyUint32(ctx, obj, i, JS_DupValue(ctx, argv[i])) < 0)\n                goto fail;\n        }\n    }\n    return obj;\nfail:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_array_from(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    // from(items, mapfn = void 0, this_arg = void 0)\n    JSValueConst items = argv[0], mapfn, this_arg;\n    JSValueConst args[2];\n    JSValue stack[2];\n    JSValue iter, r, v, v2, arrayLike;\n    int64_t k, len;\n    int done, mapping;\n\n    mapping = FALSE;\n    mapfn = JS_UNDEFINED;\n    this_arg = JS_UNDEFINED;\n    r = JS_UNDEFINED;\n    arrayLike = JS_UNDEFINED;\n    stack[0] = JS_UNDEFINED;\n    stack[1] = JS_UNDEFINED;\n\n    if (argc > 1) {\n        mapfn = argv[1];\n        if (!JS_IsUndefined(mapfn)) {\n            if (check_function(ctx, mapfn))\n                goto exception;\n            mapping = 1;\n            if (argc > 2)\n                this_arg = argv[2];\n        }\n    }\n    iter = JS_GetProperty(ctx, items, JS_ATOM_Symbol_iterator);\n    if (JS_IsException(iter))\n        goto exception;\n    if (!JS_IsUndefined(iter)) {\n        JS_FreeValue(ctx, iter);\n        if (JS_IsConstructor(ctx, this_val))\n            r = JS_CallConstructor(ctx, this_val, 0, NULL);\n        else\n            r = JS_NewArray(ctx);\n        if (JS_IsException(r))\n            goto exception;\n        stack[0] = JS_DupValue(ctx, items);\n        if (js_for_of_start(ctx, &stack[1], FALSE))\n            goto exception;\n        for (k = 0;; k++) {\n            v = JS_IteratorNext(ctx, stack[0], stack[1], 0, NULL, &done);\n            if (JS_IsException(v))\n                goto exception_close;\n            if (done)\n                break;\n            if (mapping) {\n                args[0] = v;\n                args[1] = JS_NewInt32(ctx, k);\n                v2 = JS_Call(ctx, mapfn, this_arg, 2, args);\n                JS_FreeValue(ctx, v);\n                v = v2;\n                if (JS_IsException(v))\n                    goto exception_close;\n            }\n            if (JS_DefinePropertyValueInt64(ctx, r, k, v,\n                                            JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n                goto exception_close;\n        }\n    } else {\n        arrayLike = JS_ToObject(ctx, items);\n        if (JS_IsException(arrayLike))\n            goto exception;\n        if (js_get_length64(ctx, &len, arrayLike) < 0)\n            goto exception;\n        v = JS_NewInt64(ctx, len);\n        args[0] = v;\n        if (JS_IsConstructor(ctx, this_val)) {\n            r = JS_CallConstructor(ctx, this_val, 1, args);\n        } else {\n            r = js_array_constructor(ctx, JS_UNDEFINED, 1, args);\n        }\n        JS_FreeValue(ctx, v);\n        if (JS_IsException(r))\n            goto exception;\n        for(k = 0; k < len; k++) {\n            v = JS_GetPropertyInt64(ctx, arrayLike, k);\n            if (JS_IsException(v))\n                goto exception;\n            if (mapping) {\n                args[0] = v;\n                args[1] = JS_NewInt32(ctx, k);\n                v2 = JS_Call(ctx, mapfn, this_arg, 2, args);\n                JS_FreeValue(ctx, v);\n                v = v2;\n                if (JS_IsException(v))\n                    goto exception;\n            }\n            if (JS_DefinePropertyValueInt64(ctx, r, k, v,\n                                            JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n                goto exception;\n        }\n    }\n    if (JS_SetProperty(ctx, r, JS_ATOM_length, JS_NewUint32(ctx, k)) < 0)\n        goto exception;\n    goto done;\n\n exception_close:\n    if (!JS_IsUndefined(stack[0]))\n        JS_IteratorClose(ctx, stack[0], TRUE);\n exception:\n    JS_FreeValue(ctx, r);\n    r = JS_EXCEPTION;\n done:\n    JS_FreeValue(ctx, arrayLike);\n    JS_FreeValue(ctx, stack[0]);\n    JS_FreeValue(ctx, stack[1]);\n    return r;\n}\n\nstatic JSValue js_array_of(JSContext *ctx, JSValueConst this_val,\n                           int argc, JSValueConst *argv)\n{\n    JSValue obj, args[1];\n    int i;\n\n    if (JS_IsConstructor(ctx, this_val)) {\n        args[0] = JS_NewInt32(ctx, argc);\n        obj = JS_CallConstructor(ctx, this_val, 1, (JSValueConst *)args);\n    } else {\n        obj = JS_NewArray(ctx);\n    }\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n    for(i = 0; i < argc; i++) {\n        if (JS_CreateDataPropertyUint32(ctx, obj, i, JS_DupValue(ctx, argv[i]),\n                                        JS_PROP_THROW) < 0) {\n            goto fail;\n        }\n    }\n    if (JS_SetProperty(ctx, obj, JS_ATOM_length, JS_NewUint32(ctx, argc)) < 0) {\n    fail:\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    return obj;\n}\n\nstatic JSValue js_array_isArray(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    int ret;\n    ret = JS_IsArray(ctx, argv[0]);\n    if (ret < 0)\n        return JS_EXCEPTION;\n    else\n        return JS_NewBool(ctx, ret);\n}\n\nstatic JSValue js_get_this(JSContext *ctx,\n                           JSValueConst this_val)\n{\n    return JS_DupValue(ctx, this_val);\n}\n\nstatic JSValue JS_ArraySpeciesCreate(JSContext *ctx, JSValueConst obj,\n                                     JSValueConst len_val)\n{\n    JSValue ctor, ret, species;\n    int res;\n    JSContext *realm;\n    \n    res = JS_IsArray(ctx, obj);\n    if (res < 0)\n        return JS_EXCEPTION;\n    if (!res)\n        return js_array_constructor(ctx, JS_UNDEFINED, 1, &len_val);\n    ctor = JS_GetProperty(ctx, obj, JS_ATOM_constructor);\n    if (JS_IsException(ctor))\n        return ctor;\n    if (JS_IsConstructor(ctx, ctor)) {\n        /* legacy web compatibility */\n        realm = JS_GetFunctionRealm(ctx, ctor);\n        if (!realm) {\n            JS_FreeValue(ctx, ctor);\n            return JS_EXCEPTION;\n        }\n        if (realm != ctx &&\n            js_same_value(ctx, ctor, realm->array_ctor)) {\n            JS_FreeValue(ctx, ctor);\n            ctor = JS_UNDEFINED;\n        }\n    }\n    if (JS_IsObject(ctor)) {\n        species = JS_GetProperty(ctx, ctor, JS_ATOM_Symbol_species);\n        JS_FreeValue(ctx, ctor);\n        if (JS_IsException(species))\n            return species;\n        ctor = species;\n        if (JS_IsNull(ctor))\n            ctor = JS_UNDEFINED;\n    }\n    if (JS_IsUndefined(ctor)) {\n        return js_array_constructor(ctx, JS_UNDEFINED, 1, &len_val);\n    } else {\n        ret = JS_CallConstructor(ctx, ctor, 1, &len_val);\n        JS_FreeValue(ctx, ctor);\n        return ret;\n    }\n}\n\nstatic const JSCFunctionListEntry js_array_funcs[] = {\n    JS_CFUNC_DEF(\"isArray\", 1, js_array_isArray ),\n    JS_CFUNC_DEF(\"from\", 1, js_array_from ),\n    JS_CFUNC_DEF(\"of\", 0, js_array_of ),\n    JS_CGETSET_DEF(\"[Symbol.species]\", js_get_this, NULL ),\n};\n\nstatic int JS_isConcatSpreadable(JSContext *ctx, JSValueConst obj)\n{\n    JSValue val;\n\n    if (!JS_IsObject(obj))\n        return FALSE;\n    val = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_isConcatSpreadable);\n    if (JS_IsException(val))\n        return -1;\n    if (!JS_IsUndefined(val))\n        return JS_ToBoolFree(ctx, val);\n    return JS_IsArray(ctx, obj);\n}\n\nstatic JSValue js_array_concat(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    JSValue obj, arr, val;\n    JSValueConst e;\n    int64_t len, k, n;\n    int i, res;\n\n    arr = JS_UNDEFINED;\n    obj = JS_ToObject(ctx, this_val);\n    if (JS_IsException(obj))\n        goto exception;\n\n    arr = JS_ArraySpeciesCreate(ctx, obj, JS_NewInt32(ctx, 0));\n    if (JS_IsException(arr))\n        goto exception;\n    n = 0;\n    for (i = -1; i < argc; i++) {\n        if (i < 0)\n            e = obj;\n        else\n            e = argv[i];\n\n        res = JS_isConcatSpreadable(ctx, e);\n        if (res < 0)\n            goto exception;\n        if (res) {\n            if (js_get_length64(ctx, &len, e))\n                goto exception;\n            if (n + len > MAX_SAFE_INTEGER) {\n                JS_ThrowTypeError(ctx, \"Array loo long\");\n                goto exception;\n            }\n            for (k = 0; k < len; k++, n++) {\n                res = JS_TryGetPropertyInt64(ctx, e, k, &val);\n                if (res < 0)\n                    goto exception;\n                if (res) {\n                    if (JS_DefinePropertyValueInt64(ctx, arr, n, val,\n                                                    JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n                        goto exception;\n                }\n            }\n        } else {\n            if (n >= MAX_SAFE_INTEGER) {\n                JS_ThrowTypeError(ctx, \"Array loo long\");\n                goto exception;\n            }\n            if (JS_DefinePropertyValueInt64(ctx, arr, n, JS_DupValue(ctx, e),\n                                            JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n                goto exception;\n            n++;\n        }\n    }\n    if (JS_SetProperty(ctx, arr, JS_ATOM_length, JS_NewInt64(ctx, n)) < 0)\n        goto exception;\n\n    JS_FreeValue(ctx, obj);\n    return arr;\n\nexception:\n    JS_FreeValue(ctx, arr);\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\n#define special_every    0\n#define special_some     1\n#define special_forEach  2\n#define special_map      3\n#define special_filter   4\n#define special_TA       8\n\nstatic int js_typed_array_get_length_internal(JSContext *ctx, JSValueConst obj);\n\nstatic JSValue js_typed_array___speciesCreate(JSContext *ctx,\n                                              JSValueConst this_val,\n                                              int argc, JSValueConst *argv);\n\nstatic JSValue js_array_every(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv, int special)\n{\n    JSValue obj, val, index_val, res, ret;\n    JSValueConst args[3];\n    JSValueConst func, this_arg;\n    int64_t len, k, n;\n    int present;\n\n    ret = JS_UNDEFINED;\n    val = JS_UNDEFINED;\n    if (special & special_TA) {\n        obj = JS_DupValue(ctx, this_val);\n        len = js_typed_array_get_length_internal(ctx, obj);\n        if (len < 0)\n            goto exception;\n    } else {\n        obj = JS_ToObject(ctx, this_val);\n        if (js_get_length64(ctx, &len, obj))\n            goto exception;\n    }\n    func = argv[0];\n    this_arg = JS_UNDEFINED;\n    if (argc > 1)\n        this_arg = argv[1];\n        \n    if (check_function(ctx, func))\n        goto exception;\n\n    switch (special) {\n    case special_every:\n    case special_every | special_TA:\n        ret = JS_TRUE;\n        break;\n    case special_some:\n    case special_some | special_TA:\n        ret = JS_FALSE;\n        break;\n    case special_map:\n        /* XXX: JS_ArraySpeciesCreate should take int64_t */\n        ret = JS_ArraySpeciesCreate(ctx, obj, JS_NewInt64(ctx, len));\n        if (JS_IsException(ret))\n            goto exception;\n        break;\n    case special_filter:\n        ret = JS_ArraySpeciesCreate(ctx, obj, JS_NewInt32(ctx, 0));\n        if (JS_IsException(ret))\n            goto exception;\n        break;\n    case special_map | special_TA:\n        args[0] = obj;\n        args[1] = JS_NewInt32(ctx, len);\n        ret = js_typed_array___speciesCreate(ctx, JS_UNDEFINED, 2, args);\n        if (JS_IsException(ret))\n            goto exception;\n        break;\n    case special_filter | special_TA:\n        ret = JS_NewArray(ctx);\n        if (JS_IsException(ret))\n            goto exception;\n        break;\n    }\n    n = 0;\n\n    for(k = 0; k < len; k++) {\n        if (special & special_TA) {\n            val = JS_GetPropertyInt64(ctx, obj, k);\n            if (JS_IsException(val))\n                goto exception;\n            present = TRUE;\n        } else {\n            present = JS_TryGetPropertyInt64(ctx, obj, k, &val);\n            if (present < 0)\n                goto exception;\n        }\n        if (present) {\n            index_val = JS_NewInt64(ctx, k);\n            if (JS_IsException(index_val))\n                goto exception;\n            args[0] = val;\n            args[1] = index_val;\n            args[2] = obj;\n            res = JS_Call(ctx, func, this_arg, 3, args);\n            JS_FreeValue(ctx, index_val);\n            if (JS_IsException(res))\n                goto exception;\n            switch (special) {\n            case special_every:\n            case special_every | special_TA:\n                if (!JS_ToBoolFree(ctx, res)) {\n                    ret = JS_FALSE;\n                    goto done;\n                }\n                break;\n            case special_some:\n            case special_some | special_TA:\n                if (JS_ToBoolFree(ctx, res)) {\n                    ret = JS_TRUE;\n                    goto done;\n                }\n                break;\n            case special_map:\n                if (JS_DefinePropertyValueInt64(ctx, ret, k, res,\n                                                JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n                    goto exception;\n                break;\n            case special_map | special_TA:\n                if (JS_SetPropertyValue(ctx, ret, JS_NewInt32(ctx, k), res, JS_PROP_THROW) < 0)\n                    goto exception;\n                break;\n            case special_filter:\n            case special_filter | special_TA:\n                if (JS_ToBoolFree(ctx, res)) {\n                    if (JS_DefinePropertyValueInt64(ctx, ret, n++, JS_DupValue(ctx, val),\n                                                    JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n                        goto exception;\n                }\n                break;\n            default:\n                JS_FreeValue(ctx, res);\n                break;\n            }\n            JS_FreeValue(ctx, val);\n            val = JS_UNDEFINED;\n        }\n    }\ndone:\n    if (special == (special_filter | special_TA)) {\n        JSValue arr;\n        args[0] = obj;\n        args[1] = JS_NewInt32(ctx, n);\n        arr = js_typed_array___speciesCreate(ctx, JS_UNDEFINED, 2, args);\n        if (JS_IsException(arr))\n            goto exception;\n        args[0] = ret;\n        res = JS_Invoke(ctx, arr, JS_ATOM_set, 1, args);\n        if (check_exception_free(ctx, res))\n            goto exception;\n        JS_FreeValue(ctx, ret);\n        ret = arr;\n    }\n    JS_FreeValue(ctx, val);\n    JS_FreeValue(ctx, obj);\n    return ret;\n\nexception:\n    JS_FreeValue(ctx, ret);\n    JS_FreeValue(ctx, val);\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\n#define special_reduce       0\n#define special_reduceRight  1\n\nstatic JSValue js_array_reduce(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv, int special)\n{\n    JSValue obj, val, index_val, acc, acc1;\n    JSValueConst args[4];\n    JSValueConst func;\n    int64_t len, k, k1;\n    int present;\n\n    acc = JS_UNDEFINED;\n    val = JS_UNDEFINED;\n    if (special & special_TA) {\n        obj = JS_DupValue(ctx, this_val);\n        len = js_typed_array_get_length_internal(ctx, obj);\n        if (len < 0)\n            goto exception;\n    } else {\n        obj = JS_ToObject(ctx, this_val);\n        if (js_get_length64(ctx, &len, obj))\n            goto exception;\n    }\n    func = argv[0];\n\n    if (check_function(ctx, func))\n        goto exception;\n\n    k = 0;\n    if (argc > 1) {\n        acc = JS_DupValue(ctx, argv[1]);\n    } else {\n        for(;;) {\n            if (k >= len) {\n                JS_ThrowTypeError(ctx, \"empty array\");\n                goto exception;\n            }\n            k1 = (special & special_reduceRight) ? len - k - 1 : k;\n            k++;\n            if (special & special_TA) {\n                acc = JS_GetPropertyInt64(ctx, obj, k1);\n                if (JS_IsException(acc))\n                    goto exception;\n                break;\n            } else {\n                present = JS_TryGetPropertyInt64(ctx, obj, k1, &acc);\n                if (present < 0)\n                    goto exception;\n                if (present)\n                    break;\n            }\n        }\n    }\n    for (; k < len; k++) {\n        k1 = (special & special_reduceRight) ? len - k - 1 : k;\n        if (special & special_TA) {\n            val = JS_GetPropertyInt64(ctx, obj, k1);\n            if (JS_IsException(val))\n                goto exception;\n            present = TRUE;\n        } else {\n            present = JS_TryGetPropertyInt64(ctx, obj, k1, &val);\n            if (present < 0)\n                goto exception;\n        }\n        if (present) {\n            index_val = JS_NewInt64(ctx, k1);\n            if (JS_IsException(index_val))\n                goto exception;\n            args[0] = acc;\n            args[1] = val;\n            args[2] = index_val;\n            args[3] = obj;\n            acc1 = JS_Call(ctx, func, JS_UNDEFINED, 4, args);\n            JS_FreeValue(ctx, index_val);\n            JS_FreeValue(ctx, val);\n            val = JS_UNDEFINED;\n            if (JS_IsException(acc1))\n                goto exception;\n            JS_FreeValue(ctx, acc);\n            acc = acc1;\n        }\n    }\n    JS_FreeValue(ctx, obj);\n    return acc;\n\nexception:\n    JS_FreeValue(ctx, acc);\n    JS_FreeValue(ctx, val);\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_array_fill(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    JSValue obj;\n    int64_t len, start, end;\n\n    obj = JS_ToObject(ctx, this_val);\n    if (js_get_length64(ctx, &len, obj))\n        goto exception;\n\n    start = 0;\n    if (argc > 1 && !JS_IsUndefined(argv[1])) {\n        if (JS_ToInt64Clamp(ctx, &start, argv[1], 0, len, len))\n            goto exception;\n    }\n\n    end = len;\n    if (argc > 2 && !JS_IsUndefined(argv[2])) {\n        if (JS_ToInt64Clamp(ctx, &end, argv[2], 0, len, len))\n            goto exception;\n    }\n\n    /* XXX: should special case fast arrays */\n    while (start < end) {\n        if (JS_SetPropertyInt64(ctx, obj, start,\n                                JS_DupValue(ctx, argv[0])) < 0)\n            goto exception;\n        start++;\n    }\n    return obj;\n\n exception:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_array_includes(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    JSValue obj, val;\n    int64_t len, n, res;\n    JSValue *arrp;\n    uint32_t count;\n\n    obj = JS_ToObject(ctx, this_val);\n    if (js_get_length64(ctx, &len, obj))\n        goto exception;\n\n    res = FALSE;\n    if (len > 0) {\n        n = 0;\n        if (argc > 1) {\n            if (JS_ToInt64Clamp(ctx, &n, argv[1], 0, len, len))\n                goto exception;\n        }\n        if (js_get_fast_array(ctx, obj, &arrp, &count)) {\n            for (; n < count; n++) {\n                if (js_strict_eq2(ctx, JS_DupValue(ctx, argv[0]),\n                                  JS_DupValue(ctx, arrp[n]),\n                                  JS_EQ_SAME_VALUE_ZERO)) {\n                    res = TRUE;\n                    goto done;\n                }\n            }\n        }\n        for (; n < len; n++) {\n            val = JS_GetPropertyInt64(ctx, obj, n);\n            if (JS_IsException(val))\n                goto exception;\n            if (js_strict_eq2(ctx, JS_DupValue(ctx, argv[0]), val,\n                              JS_EQ_SAME_VALUE_ZERO)) {\n                res = TRUE;\n                break;\n            }\n        }\n    }\n done:\n    JS_FreeValue(ctx, obj);\n    return JS_NewBool(ctx, res);\n\n exception:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_array_indexOf(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    JSValue obj, val;\n    int64_t len, n, res;\n    JSValue *arrp;\n    uint32_t count;\n\n    obj = JS_ToObject(ctx, this_val);\n    if (js_get_length64(ctx, &len, obj))\n        goto exception;\n\n    res = -1;\n    if (len > 0) {\n        n = 0;\n        if (argc > 1) {\n            if (JS_ToInt64Clamp(ctx, &n, argv[1], 0, len, len))\n                goto exception;\n        }\n        if (js_get_fast_array(ctx, obj, &arrp, &count)) {\n            for (; n < count; n++) {\n                if (js_strict_eq2(ctx, JS_DupValue(ctx, argv[0]),\n                                  JS_DupValue(ctx, arrp[n]), JS_EQ_STRICT)) {\n                    res = n;\n                    goto done;\n                }\n            }\n        }\n        for (; n < len; n++) {\n            int present = JS_TryGetPropertyInt64(ctx, obj, n, &val);\n            if (present < 0)\n                goto exception;\n            if (present) {\n                if (js_strict_eq2(ctx, JS_DupValue(ctx, argv[0]), val, JS_EQ_STRICT)) {\n                    res = n;\n                    break;\n                }\n            }\n        }\n    }\n done:\n    JS_FreeValue(ctx, obj);\n    return JS_NewInt64(ctx, res);\n\n exception:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_array_lastIndexOf(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv)\n{\n    JSValue obj, val;\n    int64_t len, n, res;\n    int present;\n\n    obj = JS_ToObject(ctx, this_val);\n    if (js_get_length64(ctx, &len, obj))\n        goto exception;\n\n    res = -1;\n    if (len > 0) {\n        n = len - 1;\n        if (argc > 1) {\n            if (JS_ToInt64Clamp(ctx, &n, argv[1], -1, len - 1, len))\n                goto exception;\n        }\n        /* XXX: should special case fast arrays */\n        for (; n >= 0; n--) {\n            present = JS_TryGetPropertyInt64(ctx, obj, n, &val);\n            if (present < 0)\n                goto exception;\n            if (present) {\n                if (js_strict_eq2(ctx, JS_DupValue(ctx, argv[0]), val, JS_EQ_STRICT)) {\n                    res = n;\n                    break;\n                }\n            }\n        }\n    }\n    JS_FreeValue(ctx, obj);\n    return JS_NewInt64(ctx, res);\n\n exception:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_array_find(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv, int findIndex)\n{\n    JSValueConst func, this_arg;\n    JSValueConst args[3];\n    JSValue obj, val, index_val, res;\n    int64_t len, k;\n\n    index_val = JS_UNDEFINED;\n    val = JS_UNDEFINED;\n    obj = JS_ToObject(ctx, this_val);\n    if (js_get_length64(ctx, &len, obj))\n        goto exception;\n\n    func = argv[0];\n    if (check_function(ctx, func))\n        goto exception;\n\n    this_arg = JS_UNDEFINED;\n    if (argc > 1)\n        this_arg = argv[1];\n\n    for(k = 0; k < len; k++) {\n        index_val = JS_NewInt64(ctx, k);\n        if (JS_IsException(index_val))\n            goto exception;\n        val = JS_GetPropertyValue(ctx, obj, index_val);\n        if (JS_IsException(val))\n            goto exception;\n        args[0] = val;\n        args[1] = index_val;\n        args[2] = this_val;\n        res = JS_Call(ctx, func, this_arg, 3, args);\n        if (JS_IsException(res))\n            goto exception;\n        if (JS_ToBoolFree(ctx, res)) {\n            if (findIndex) {\n                JS_FreeValue(ctx, val);\n                JS_FreeValue(ctx, obj);\n                return index_val;\n            } else {\n                JS_FreeValue(ctx, index_val);\n                JS_FreeValue(ctx, obj);\n                return val;\n            }\n        }\n        JS_FreeValue(ctx, val);\n        JS_FreeValue(ctx, index_val);\n    }\n    JS_FreeValue(ctx, obj);\n    if (findIndex)\n        return JS_NewInt32(ctx, -1);\n    else\n        return JS_UNDEFINED;\n\nexception:\n    JS_FreeValue(ctx, index_val);\n    JS_FreeValue(ctx, val);\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_array_toString(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    JSValue obj, method, ret;\n\n    obj = JS_ToObject(ctx, this_val);\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n    method = JS_GetProperty(ctx, obj, JS_ATOM_join);\n    if (JS_IsException(method)) {\n        ret = JS_EXCEPTION;\n    } else\n    if (!JS_IsFunction(ctx, method)) {\n        /* Use intrinsic Object.prototype.toString */\n        JS_FreeValue(ctx, method);\n        ret = js_object_toString(ctx, obj, 0, NULL);\n    } else {\n        ret = JS_CallFree(ctx, method, obj, 0, NULL);\n    }\n    JS_FreeValue(ctx, obj);\n    return ret;\n}\n\nstatic JSValue js_array_join(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv, int toLocaleString)\n{\n    JSValue obj, sep = JS_UNDEFINED, el;\n    StringBuffer b_s, *b = &b_s;\n    JSString *p = NULL;\n    int64_t i, n;\n    int c;\n\n    obj = JS_ToObject(ctx, this_val);\n    if (js_get_length64(ctx, &n, obj))\n        goto exception;\n\n    c = ',';    /* default separator */\n    if (!toLocaleString && argc > 0 && !JS_IsUndefined(argv[0])) {\n        sep = JS_ToString(ctx, argv[0]);\n        if (JS_IsException(sep))\n            goto exception;\n        p = JS_VALUE_GET_STRING(sep);\n        if (p->len == 1 && !p->is_wide_char)\n            c = p->u.str8[0];\n        else\n            c = -1;\n    }\n    string_buffer_init(ctx, b, 0);\n\n    for(i = 0; i < n; i++) {\n        if (i > 0) {\n            if (c >= 0) {\n                string_buffer_putc8(b, c);\n            } else {\n                string_buffer_concat(b, p, 0, p->len);\n            }\n        }\n        el = JS_GetPropertyUint32(ctx, obj, i);\n        if (JS_IsException(el))\n            goto fail;\n        if (!JS_IsNull(el) && !JS_IsUndefined(el)) {\n            if (toLocaleString) {\n                el = JS_ToLocaleStringFree(ctx, el);\n            }\n            if (string_buffer_concat_value_free(b, el))\n                goto fail;\n        }\n    }\n    JS_FreeValue(ctx, sep);\n    JS_FreeValue(ctx, obj);\n    return string_buffer_end(b);\n\nfail:\n    string_buffer_free(b);\n    JS_FreeValue(ctx, sep);\nexception:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_array_pop(JSContext *ctx, JSValueConst this_val,\n                            int argc, JSValueConst *argv, int shift)\n{\n    JSValue obj, res = JS_UNDEFINED;\n    int64_t len, newLen;\n    JSValue *arrp;\n    uint32_t count32;\n\n    obj = JS_ToObject(ctx, this_val);\n    if (js_get_length64(ctx, &len, obj))\n        goto exception;\n    newLen = 0;\n    if (len > 0) {\n        newLen = len - 1;\n        /* Special case fast arrays */\n        if (js_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {\n            JSObject *p = JS_VALUE_GET_OBJ(obj);\n            if (shift) {\n                res = arrp[0];\n                memmove(arrp, arrp + 1, (count32 - 1) * sizeof(*arrp));\n                p->u.array.count--;\n            } else {\n                res = arrp[count32 - 1];\n                p->u.array.count--;\n            }\n        } else {\n            if (shift) {\n                res = JS_GetPropertyInt64(ctx, obj, 0);\n                if (JS_IsException(res))\n                    goto exception;\n                if (JS_CopySubArray(ctx, obj, 0, 1, len - 1, +1))\n                    goto exception;\n            } else {\n                res = JS_GetPropertyInt64(ctx, obj, newLen);\n                if (JS_IsException(res))\n                    goto exception;\n            }\n            if (JS_DeletePropertyInt64(ctx, obj, newLen, JS_PROP_THROW) < 0)\n                goto exception;\n        }\n    }\n    if (JS_SetProperty(ctx, obj, JS_ATOM_length, JS_NewInt64(ctx, newLen)) < 0)\n        goto exception;\n\n    JS_FreeValue(ctx, obj);\n    return res;\n\n exception:\n    JS_FreeValue(ctx, res);\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_array_push(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv, int unshift)\n{\n    JSValue obj;\n    int i;\n    int64_t len, from, newLen;\n\n    obj = JS_ToObject(ctx, this_val);\n\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(obj);\n        if (p->class_id != JS_CLASS_ARRAY ||\n            !p->fast_array || !p->extensible)\n            goto generic_case;\n        /* length must be writable */\n        if (unlikely(!(get_shape_prop(p->shape)->flags & JS_PROP_WRITABLE)))\n            goto generic_case;\n        /* check the length */\n        if (unlikely(JS_VALUE_GET_TAG(p->prop[0].u.value) != JS_TAG_INT))\n            goto generic_case;\n        len = JS_VALUE_GET_INT(p->prop[0].u.value);\n        /* we don't support holes */\n        if (unlikely(len != p->u.array.count))\n            goto generic_case;\n        newLen = len + argc;\n        if (unlikely(newLen > INT32_MAX))\n            goto generic_case;\n        if (newLen > p->u.array.u1.size) {\n            if (expand_fast_array(ctx, p, newLen))\n                goto exception;\n        }\n        if (unshift && argc > 0) {\n            memmove(p->u.array.u.values + argc, p->u.array.u.values,\n                    len * sizeof(p->u.array.u.values[0]));\n            from = 0;\n        } else {\n            from = len;\n        }\n        for(i = 0; i < argc; i++) {\n            p->u.array.u.values[from + i] = JS_DupValue(ctx, argv[i]);\n        }\n        p->u.array.count = newLen;\n        p->prop[0].u.value = JS_NewInt32(ctx, newLen);\n    } else {\n    generic_case:\n        if (js_get_length64(ctx, &len, obj))\n            goto exception;\n        newLen = len + argc;\n        if (newLen > MAX_SAFE_INTEGER) {\n            JS_ThrowTypeError(ctx, \"Array loo long\");\n            goto exception;\n        }\n        from = len;\n        if (unshift && argc > 0) {\n            if (JS_CopySubArray(ctx, obj, argc, 0, len, -1))\n                goto exception;\n            from = 0;\n        }\n        for(i = 0; i < argc; i++) {\n            if (JS_SetPropertyInt64(ctx, obj, from + i,\n                                    JS_DupValue(ctx, argv[i])) < 0)\n                goto exception;\n        }\n        if (JS_SetProperty(ctx, obj, JS_ATOM_length, JS_NewInt64(ctx, newLen)) < 0)\n            goto exception;\n    }\n    JS_FreeValue(ctx, obj);\n    return JS_NewInt64(ctx, newLen);\n\n exception:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_array_reverse(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    JSValue obj, lval, hval;\n    JSValue *arrp;\n    int64_t len, l, h;\n    int l_present, h_present;\n    uint32_t count32;\n\n    lval = JS_UNDEFINED;\n    obj = JS_ToObject(ctx, this_val);\n    if (js_get_length64(ctx, &len, obj))\n        goto exception;\n\n    /* Special case fast arrays */\n    if (js_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {\n        uint32_t ll, hh;\n\n        if (count32 > 1) {\n            for (ll = 0, hh = count32 - 1; ll < hh; ll++, hh--) {\n                lval = arrp[ll];\n                arrp[ll] = arrp[hh];\n                arrp[hh] = lval;\n            }\n        }\n        return obj;\n    }\n\n    for (l = 0, h = len - 1; l < h; l++, h--) {\n        l_present = JS_TryGetPropertyInt64(ctx, obj, l, &lval);\n        if (l_present < 0)\n            goto exception;\n        h_present = JS_TryGetPropertyInt64(ctx, obj, h, &hval);\n        if (h_present < 0)\n            goto exception;\n        if (h_present) {\n            if (JS_SetPropertyInt64(ctx, obj, l, hval) < 0)\n                goto exception;\n\n            if (l_present) {\n                if (JS_SetPropertyInt64(ctx, obj, h, lval) < 0) {\n                    lval = JS_UNDEFINED;\n                    goto exception;\n                }\n                lval = JS_UNDEFINED;\n            } else {\n                if (JS_DeletePropertyInt64(ctx, obj, h, JS_PROP_THROW) < 0)\n                    goto exception;\n            }\n        } else {\n            if (l_present) {\n                if (JS_DeletePropertyInt64(ctx, obj, l, JS_PROP_THROW) < 0)\n                    goto exception;\n                if (JS_SetPropertyInt64(ctx, obj, h, lval) < 0) {\n                    lval = JS_UNDEFINED;\n                    goto exception;\n                }\n                lval = JS_UNDEFINED;\n            }\n        }\n    }\n    return obj;\n\n exception:\n    JS_FreeValue(ctx, lval);\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_array_slice(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv, int splice)\n{\n    JSValue obj, arr, val, len_val;\n    int64_t len, start, k, final, n, count, del_count, new_len;\n    int kPresent;\n    JSValue *arrp;\n    uint32_t count32, i, item_count;\n\n    arr = JS_UNDEFINED;\n    obj = JS_ToObject(ctx, this_val);\n    if (js_get_length64(ctx, &len, obj))\n        goto exception;\n\n    if (JS_ToInt64Clamp(ctx, &start, argv[0], 0, len, len))\n        goto exception;\n\n    if (splice) {\n        if (argc == 0) {\n            item_count = 0;\n            del_count = 0;\n        } else\n        if (argc == 1) {\n            item_count = 0;\n            del_count = len - start;\n        } else {\n            item_count = argc - 2;\n            if (JS_ToInt64Clamp(ctx, &del_count, argv[1], 0, len - start, 0))\n                goto exception;\n        }\n        if (len + item_count - del_count > MAX_SAFE_INTEGER) {\n            JS_ThrowTypeError(ctx, \"Array loo long\");\n            goto exception;\n        }\n        count = del_count;\n    } else {\n        item_count = 0; /* avoid warning */\n        final = len;\n        if (!JS_IsUndefined(argv[1])) {\n            if (JS_ToInt64Clamp(ctx, &final, argv[1], 0, len, len))\n                goto exception;\n        }\n        count = max_int64(final - start, 0);\n    }\n    len_val = JS_NewInt64(ctx, count);\n    arr = JS_ArraySpeciesCreate(ctx, obj, len_val);\n    JS_FreeValue(ctx, len_val);\n    if (JS_IsException(arr))\n        goto exception;\n\n    k = start;\n    final = start + count;\n    n = 0;\n    /* The fast array test on arr ensures that\n       JS_CreateDataPropertyUint32() won't modify obj in case arr is\n       an exotic object */\n    /* Special case fast arrays */\n    if (js_get_fast_array(ctx, obj, &arrp, &count32) &&\n        js_is_fast_array(ctx, arr)) {\n        /* XXX: should share code with fast array constructor */\n        for (; k < final && k < count32; k++, n++) {\n            if (JS_CreateDataPropertyUint32(ctx, arr, n, JS_DupValue(ctx, arrp[k]), JS_PROP_THROW) < 0)\n                goto exception;\n        }\n    }\n    /* Copy the remaining elements if any (handle case of inherited properties) */\n    for (; k < final; k++, n++) {\n        kPresent = JS_TryGetPropertyInt64(ctx, obj, k, &val);\n        if (kPresent < 0)\n            goto exception;\n        if (kPresent) {\n            if (JS_CreateDataPropertyUint32(ctx, arr, n, val, JS_PROP_THROW) < 0)\n                goto exception;\n        }\n    }\n    if (JS_SetProperty(ctx, arr, JS_ATOM_length, JS_NewInt64(ctx, n)) < 0)\n        goto exception;\n\n    if (splice) {\n        new_len = len + item_count - del_count;\n        if (item_count != del_count) {\n            if (JS_CopySubArray(ctx, obj, start + item_count,\n                                start + del_count, len - (start + del_count),\n                                item_count <= del_count ? +1 : -1) < 0)\n                goto exception;\n\n            for (k = len; k-- > new_len; ) {\n                if (JS_DeletePropertyInt64(ctx, obj, k, JS_PROP_THROW) < 0)\n                    goto exception;\n            }\n        }\n        for (i = 0; i < item_count; i++) {\n            if (JS_SetPropertyInt64(ctx, obj, start + i, JS_DupValue(ctx, argv[i + 2])) < 0)\n                goto exception;\n        }\n        if (JS_SetProperty(ctx, obj, JS_ATOM_length, JS_NewInt64(ctx, new_len)) < 0)\n            goto exception;\n    }\n    JS_FreeValue(ctx, obj);\n    return arr;\n\n exception:\n    JS_FreeValue(ctx, obj);\n    JS_FreeValue(ctx, arr);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_array_copyWithin(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    JSValue obj;\n    int64_t len, from, to, final, count;\n\n    obj = JS_ToObject(ctx, this_val);\n    if (js_get_length64(ctx, &len, obj))\n        goto exception;\n\n    if (JS_ToInt64Clamp(ctx, &to, argv[0], 0, len, len))\n        goto exception;\n\n    if (JS_ToInt64Clamp(ctx, &from, argv[1], 0, len, len))\n        goto exception;\n\n    final = len;\n    if (argc > 2 && !JS_IsUndefined(argv[2])) {\n        if (JS_ToInt64Clamp(ctx, &final, argv[2], 0, len, len))\n            goto exception;\n    }\n\n    count = min_int64(final - from, len - to);\n\n    if (JS_CopySubArray(ctx, obj, to, from, count,\n                        (from < to && to < from + count) ? -1 : +1))\n        goto exception;\n\n    return obj;\n\n exception:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic int64_t JS_FlattenIntoArray(JSContext *ctx, JSValueConst target,\n                                   JSValueConst source, int64_t sourceLen,\n                                   int64_t targetIndex, int depth,\n                                   JSValueConst mapperFunction,\n                                   JSValueConst thisArg)\n{\n    JSValue element;\n    int64_t sourceIndex, elementLen;\n    int present, is_array;\n\n    if (js_check_stack_overflow(ctx->rt, 0)) {\n        JS_ThrowStackOverflow(ctx);\n        return -1;\n    }\n\n    for (sourceIndex = 0; sourceIndex < sourceLen; sourceIndex++) {\n        present = JS_TryGetPropertyInt64(ctx, source, sourceIndex, &element);\n        if (present < 0)\n            return -1;\n        if (!present)\n            continue;\n        if (!JS_IsUndefined(mapperFunction)) {\n            JSValueConst args[3] = { element, JS_NewInt64(ctx, sourceIndex), source };\n            element = JS_Call(ctx, mapperFunction, thisArg, 3, args);\n            JS_FreeValue(ctx, (JSValue)args[0]);\n            JS_FreeValue(ctx, (JSValue)args[1]);\n            if (JS_IsException(element))\n                return -1;\n        }\n        if (depth > 0) {\n            is_array = JS_IsArray(ctx, element);\n            if (is_array < 0)\n                goto fail;\n            if (is_array) {\n                if (js_get_length64(ctx, &elementLen, element) < 0)\n                    goto fail;\n                targetIndex = JS_FlattenIntoArray(ctx, target, element,\n                                                  elementLen, targetIndex,\n                                                  depth - 1,\n                                                  JS_UNDEFINED, JS_UNDEFINED);\n                if (targetIndex < 0)\n                    goto fail;\n                JS_FreeValue(ctx, element);\n                continue;\n            }\n        }\n        if (targetIndex >= MAX_SAFE_INTEGER) {\n            JS_ThrowTypeError(ctx, \"Array too long\");\n            goto fail;\n        }\n        if (JS_DefinePropertyValueInt64(ctx, target, targetIndex, element,\n                                        JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n            return -1;\n        targetIndex++;\n    }\n    return targetIndex;\n\nfail:\n    JS_FreeValue(ctx, element);\n    return -1;\n}\n\nstatic JSValue js_array_flatten(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv, int map)\n{\n    JSValue obj, arr;\n    JSValueConst mapperFunction, thisArg;\n    int64_t sourceLen;\n    int depthNum;\n\n    arr = JS_UNDEFINED;\n    obj = JS_ToObject(ctx, this_val);\n    if (js_get_length64(ctx, &sourceLen, obj))\n        goto exception;\n\n    depthNum = 1;\n    mapperFunction = JS_UNDEFINED;\n    thisArg = JS_UNDEFINED;\n    if (map) {\n        mapperFunction = argv[0];\n        if (argc > 1) {\n            thisArg = argv[1];\n        }\n        if (check_function(ctx, mapperFunction))\n            goto exception;\n    } else {\n        if (argc > 0 && !JS_IsUndefined(argv[0])) {\n            if (JS_ToInt32Sat(ctx, &depthNum, argv[0]) < 0)\n                goto exception;\n        }\n    }\n    arr = JS_ArraySpeciesCreate(ctx, obj, JS_NewInt32(ctx, 0));\n    if (JS_IsException(arr))\n        goto exception;\n    if (JS_FlattenIntoArray(ctx, arr, obj, sourceLen, 0, depthNum,\n                            mapperFunction, thisArg) < 0)\n        goto exception;\n    JS_FreeValue(ctx, obj);\n    return arr;\n\nexception:\n    JS_FreeValue(ctx, obj);\n    JS_FreeValue(ctx, arr);\n    return JS_EXCEPTION;\n}\n\n/* Array sort */\n\ntypedef struct ValueSlot {\n    JSValue val;\n    JSString *str;\n    int64_t pos;\n} ValueSlot;\n\nstruct array_sort_context {\n    JSContext *ctx;\n    int exception;\n    int has_method;\n    JSValueConst method;\n};\n\nstatic int js_array_cmp_generic(const void *a, const void *b, void *opaque) {\n    struct array_sort_context *psc = opaque;\n    JSContext *ctx = psc->ctx;\n    JSValueConst argv[2];\n    JSValue res;\n    ValueSlot *ap = (ValueSlot *)(void *)a;\n    ValueSlot *bp = (ValueSlot *)(void *)b;\n    int cmp;\n\n    if (psc->exception)\n        return 0;\n\n    if (psc->has_method) {\n        /* custom sort function is specified as returning 0 for identical\n         * objects: avoid method call overhead.\n         */\n        if (!memcmp(&ap->val, &bp->val, sizeof(ap->val)))\n            goto cmp_same;\n        argv[0] = ap->val;\n        argv[1] = bp->val;\n        res = JS_Call(ctx, psc->method, JS_UNDEFINED, 2, argv);\n        if (JS_IsException(res))\n            goto exception;\n        if (JS_VALUE_GET_TAG(res) == JS_TAG_INT) {\n            int val = JS_VALUE_GET_INT(res);\n            cmp = (val > 0) - (val < 0);\n        } else {\n            double val;\n            if (JS_ToFloat64Free(ctx, &val, res) < 0)\n                goto exception;\n            cmp = (val > 0) - (val < 0);\n        }\n    } else {\n        /* Not supposed to bypass ToString even for identical objects as\n         * tested in test262/test/built-ins/Array/prototype/sort/bug_596_1.js\n         */\n        if (!ap->str) {\n            JSValue str = JS_ToString(ctx, ap->val);\n            if (JS_IsException(str))\n                goto exception;\n            ap->str = JS_VALUE_GET_STRING(str);\n        }\n        if (!bp->str) {\n            JSValue str = JS_ToString(ctx, bp->val);\n            if (JS_IsException(str))\n                goto exception;\n            bp->str = JS_VALUE_GET_STRING(str);\n        }\n        cmp = js_string_compare(ctx, ap->str, bp->str);\n    }\n    if (cmp != 0)\n        return cmp;\ncmp_same:\n    /* make sort stable: compare array offsets */\n    return (ap->pos > bp->pos) - (ap->pos < bp->pos);\n\nexception:\n    psc->exception = 1;\n    return 0;\n}\n\nstatic JSValue js_array_sort(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    struct array_sort_context asc = { ctx, 0, 0, argv[0] };\n    JSValue obj = JS_UNDEFINED;\n    ValueSlot *array = NULL;\n    size_t array_size = 0, pos = 0, n = 0;\n    int64_t i, len, undefined_count = 0;\n    int present;\n\n    if (!JS_IsUndefined(asc.method)) {\n        if (check_function(ctx, asc.method))\n            goto exception;\n        asc.has_method = 1;\n    }\n    obj = JS_ToObject(ctx, this_val);\n    if (js_get_length64(ctx, &len, obj))\n        goto exception;\n\n    /* XXX: should special case fast arrays */\n    for (i = 0; i < len; i++) {\n        if (pos >= array_size) {\n            size_t new_size, slack;\n            ValueSlot *new_array;\n            new_size = (array_size + (array_size >> 1) + 31) & ~15;\n            new_array = js_realloc2(ctx, array, new_size * sizeof(*array), &slack);\n            if (new_array == NULL)\n                goto exception;\n            new_size += slack / sizeof(*new_array);\n            array = new_array;\n            array_size = new_size;\n        }\n        present = JS_TryGetPropertyInt64(ctx, obj, i, &array[pos].val);\n        if (present < 0)\n            goto exception;\n        if (present == 0)\n            continue;\n        if (JS_IsUndefined(array[pos].val)) {\n            undefined_count++;\n            continue;\n        }\n        array[pos].str = NULL;\n        array[pos].pos = i;\n        pos++;\n    }\n    rqsort(array, pos, sizeof(*array), js_array_cmp_generic, &asc);\n    if (asc.exception)\n        goto exception;\n\n    /* XXX: should special case fast arrays */\n    while (n < pos) {\n        if (array[n].str)\n            JS_FreeValue(ctx, JS_MKPTR(JS_TAG_STRING, array[n].str));\n        if (array[n].pos == n) {\n            JS_FreeValue(ctx, array[n].val);\n        } else {\n            if (JS_SetPropertyInt64(ctx, obj, n, array[n].val) < 0) {\n                n++;\n                goto exception;\n            }\n        }\n        n++;\n    }\n    js_free(ctx, array);\n    for (i = n; undefined_count-- > 0; i++) {\n        if (JS_SetPropertyInt64(ctx, obj, i, JS_UNDEFINED) < 0)\n            goto fail;\n    }\n    for (; i < len; i++) {\n        if (JS_DeletePropertyInt64(ctx, obj, i, JS_PROP_THROW) < 0)\n            goto fail;\n    }\n    return obj;\n\nexception:\n    for (; n < pos; n++) {\n        JS_FreeValue(ctx, array[n].val);\n        if (array[n].str)\n            JS_FreeValue(ctx, JS_MKPTR(JS_TAG_STRING, array[n].str));\n    }\n    js_free(ctx, array);\nfail:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\ntypedef struct JSArrayIteratorData {\n    JSValue obj;\n    JSIteratorKindEnum kind;\n    uint32_t idx;\n} JSArrayIteratorData;\n\nstatic void js_array_iterator_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSArrayIteratorData *it = p->u.array_iterator_data;\n    if (it) {\n        JS_FreeValueRT(rt, it->obj);\n        js_free_rt(rt, it);\n    }\n}\n\nstatic void js_array_iterator_mark(JSRuntime *rt, JSValueConst val,\n                                   JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSArrayIteratorData *it = p->u.array_iterator_data;\n    if (it) {\n        JS_MarkValue(rt, it->obj, mark_func);\n    }\n}\n\nstatic JSValue js_create_array(JSContext *ctx, int len, JSValueConst *tab)\n{\n    JSValue obj;\n    int i;\n\n    obj = JS_NewArray(ctx);\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n    for(i = 0; i < len; i++) {\n        if (JS_CreateDataPropertyUint32(ctx, obj, i, JS_DupValue(ctx, tab[i]), 0) < 0) {\n            JS_FreeValue(ctx, obj);\n            return JS_EXCEPTION;\n        }\n    }\n    return obj;\n}\n\nstatic JSValue js_create_array_iterator(JSContext *ctx, JSValueConst this_val,\n                                        int argc, JSValueConst *argv, int magic)\n{\n    JSValue enum_obj, arr;\n    JSArrayIteratorData *it;\n    JSIteratorKindEnum kind;\n    int class_id;\n\n    kind = magic & 3;\n    if (magic & 4) {\n        /* string iterator case */\n        arr = JS_ToStringCheckObject(ctx, this_val);\n        class_id = JS_CLASS_STRING_ITERATOR;\n    } else {\n        arr = JS_ToObject(ctx, this_val);\n        class_id = JS_CLASS_ARRAY_ITERATOR;\n    }\n    if (JS_IsException(arr))\n        goto fail;\n    enum_obj = JS_NewObjectClass(ctx, class_id);\n    if (JS_IsException(enum_obj))\n        goto fail;\n    it = js_malloc(ctx, sizeof(*it));\n    if (!it)\n        goto fail1;\n    it->obj = arr;\n    it->kind = kind;\n    it->idx = 0;\n    JS_SetOpaque(enum_obj, it);\n    return enum_obj;\n fail1:\n    JS_FreeValue(ctx, enum_obj);\n fail:\n    JS_FreeValue(ctx, arr);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_array_iterator_next(JSContext *ctx, JSValueConst this_val,\n                                      int argc, JSValueConst *argv,\n                                      BOOL *pdone, int magic)\n{\n    JSArrayIteratorData *it;\n    uint32_t len, idx;\n    JSValue val, obj;\n    JSObject *p;\n\n    it = JS_GetOpaque2(ctx, this_val, JS_CLASS_ARRAY_ITERATOR);\n    if (!it)\n        goto fail1;\n    if (JS_IsUndefined(it->obj))\n        goto done;\n    p = JS_VALUE_GET_OBJ(it->obj);\n    if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n        p->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n        if (typed_array_is_detached(ctx, p)) {\n            JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n            goto fail1;\n        }\n        len = p->u.array.count;\n    } else {\n        if (js_get_length32(ctx, &len, it->obj)) {\n        fail1:\n            *pdone = FALSE;\n            return JS_EXCEPTION;\n        }\n    }\n    idx = it->idx;\n    if (idx >= len) {\n        JS_FreeValue(ctx, it->obj);\n        it->obj = JS_UNDEFINED;\n    done:\n        *pdone = TRUE;\n        return JS_UNDEFINED;\n    }\n    it->idx = idx + 1;\n    *pdone = FALSE;\n    if (it->kind == JS_ITERATOR_KIND_KEY) {\n        return JS_NewUint32(ctx, idx);\n    } else {\n        val = JS_GetPropertyUint32(ctx, it->obj, idx);\n        if (JS_IsException(val))\n            return JS_EXCEPTION;\n        if (it->kind == JS_ITERATOR_KIND_VALUE) {\n            return val;\n        } else {\n            JSValueConst args[2];\n            JSValue num;\n            num = JS_NewUint32(ctx, idx);\n            args[0] = num;\n            args[1] = val;\n            obj = js_create_array(ctx, 2, args);\n            JS_FreeValue(ctx, val);\n            JS_FreeValue(ctx, num);\n            return obj;\n        }\n    }\n}\n\nstatic JSValue js_iterator_proto_iterator(JSContext *ctx, JSValueConst this_val,\n                                          int argc, JSValueConst *argv)\n{\n    return JS_DupValue(ctx, this_val);\n}\n\nstatic const JSCFunctionListEntry js_iterator_proto_funcs[] = {\n    JS_CFUNC_DEF(\"[Symbol.iterator]\", 0, js_iterator_proto_iterator ),\n};\n\nstatic const JSCFunctionListEntry js_array_proto_funcs[] = {\n    JS_CFUNC_DEF(\"concat\", 1, js_array_concat ),\n    JS_CFUNC_MAGIC_DEF(\"every\", 1, js_array_every, special_every ),\n    JS_CFUNC_MAGIC_DEF(\"some\", 1, js_array_every, special_some ),\n    JS_CFUNC_MAGIC_DEF(\"forEach\", 1, js_array_every, special_forEach ),\n    JS_CFUNC_MAGIC_DEF(\"map\", 1, js_array_every, special_map ),\n    JS_CFUNC_MAGIC_DEF(\"filter\", 1, js_array_every, special_filter ),\n    JS_CFUNC_MAGIC_DEF(\"reduce\", 1, js_array_reduce, special_reduce ),\n    JS_CFUNC_MAGIC_DEF(\"reduceRight\", 1, js_array_reduce, special_reduceRight ),\n    JS_CFUNC_DEF(\"fill\", 1, js_array_fill ),\n    JS_CFUNC_MAGIC_DEF(\"find\", 1, js_array_find, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"findIndex\", 1, js_array_find, 1 ),\n    JS_CFUNC_DEF(\"indexOf\", 1, js_array_indexOf ),\n    JS_CFUNC_DEF(\"lastIndexOf\", 1, js_array_lastIndexOf ),\n    JS_CFUNC_DEF(\"includes\", 1, js_array_includes ),\n    JS_CFUNC_MAGIC_DEF(\"join\", 1, js_array_join, 0 ),\n    JS_CFUNC_DEF(\"toString\", 0, js_array_toString ),\n    JS_CFUNC_MAGIC_DEF(\"toLocaleString\", 0, js_array_join, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"pop\", 0, js_array_pop, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"push\", 1, js_array_push, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"shift\", 0, js_array_pop, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"unshift\", 1, js_array_push, 1 ),\n    JS_CFUNC_DEF(\"reverse\", 0, js_array_reverse ),\n    JS_CFUNC_DEF(\"sort\", 1, js_array_sort ),\n    JS_CFUNC_MAGIC_DEF(\"slice\", 2, js_array_slice, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"splice\", 2, js_array_slice, 1 ),\n    JS_CFUNC_DEF(\"copyWithin\", 2, js_array_copyWithin ),\n    JS_CFUNC_MAGIC_DEF(\"flatMap\", 1, js_array_flatten, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"flat\", 0, js_array_flatten, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"values\", 0, js_create_array_iterator, JS_ITERATOR_KIND_VALUE ),\n    JS_ALIAS_DEF(\"[Symbol.iterator]\", \"values\" ),\n    JS_CFUNC_MAGIC_DEF(\"keys\", 0, js_create_array_iterator, JS_ITERATOR_KIND_KEY ),\n    JS_CFUNC_MAGIC_DEF(\"entries\", 0, js_create_array_iterator, JS_ITERATOR_KIND_KEY_AND_VALUE ),\n};\n\nstatic const JSCFunctionListEntry js_array_iterator_proto_funcs[] = {\n    JS_ITERATOR_NEXT_DEF(\"next\", 0, js_array_iterator_next, 0 ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"Array Iterator\", JS_PROP_CONFIGURABLE ),\n};\n\n/* Number */\n\nstatic JSValue js_number_constructor(JSContext *ctx, JSValueConst new_target,\n                                     int argc, JSValueConst *argv)\n{\n    JSValue val, obj;\n    if (argc == 0) {\n        val = JS_NewInt32(ctx, 0);\n    } else {\n        val = JS_ToNumeric(ctx, argv[0]);\n        if (JS_IsException(val))\n            return val;\n        switch(JS_VALUE_GET_TAG(val)) {\n#ifdef CONFIG_BIGNUM\n        case JS_TAG_BIG_INT:\n        case JS_TAG_BIG_FLOAT:\n            {\n                JSBigFloat *p = JS_VALUE_GET_PTR(val);\n                double d;\n                bf_get_float64(&p->num, &d, BF_RNDN);\n                JS_FreeValue(ctx, val);\n                val = __JS_NewFloat64(ctx, d);\n            }\n            break;\n        case JS_TAG_BIG_DECIMAL:\n            val = JS_ToStringFree(ctx, val);\n            if (JS_IsException(val))\n                return val;\n            val = JS_ToNumberFree(ctx, val);\n            if (JS_IsException(val))\n                return val;\n            break;\n#endif\n        default:\n            break;\n        }\n    }\n    if (!JS_IsUndefined(new_target)) {\n        obj = js_create_from_ctor(ctx, new_target, JS_CLASS_NUMBER);\n        if (!JS_IsException(obj))\n            JS_SetObjectData(ctx, obj, val);\n        return obj;\n    } else {\n        return val;\n    }\n}\n\n#if 0\nstatic JSValue js_number___toInteger(JSContext *ctx, JSValueConst this_val,\n                                     int argc, JSValueConst *argv)\n{\n    return JS_ToIntegerFree(ctx, JS_DupValue(ctx, argv[0]));\n}\n\nstatic JSValue js_number___toLength(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv)\n{\n    int64_t v;\n    if (JS_ToLengthFree(ctx, &v, JS_DupValue(ctx, argv[0])))\n        return JS_EXCEPTION;\n    return JS_NewInt64(ctx, v);\n}\n#endif\n\nstatic JSValue js_number_isNaN(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    if (!JS_IsNumber(argv[0]))\n        return JS_FALSE;\n    return js_global_isNaN(ctx, this_val, argc, argv);\n}\n\nstatic JSValue js_number_isFinite(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    if (!JS_IsNumber(argv[0]))\n        return JS_FALSE;\n    return js_global_isFinite(ctx, this_val, argc, argv);\n}\n\nstatic JSValue js_number_isInteger(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    int ret;\n    ret = JS_NumberIsInteger(ctx, argv[0]);\n    if (ret < 0)\n        return JS_EXCEPTION;\n    else\n        return JS_NewBool(ctx, ret);\n}\n\nstatic JSValue js_number_isSafeInteger(JSContext *ctx, JSValueConst this_val,\n                                       int argc, JSValueConst *argv)\n{\n    double d;\n    if (!JS_IsNumber(argv[0]))\n        return JS_FALSE;\n    if (unlikely(JS_ToFloat64(ctx, &d, argv[0])))\n        return JS_EXCEPTION;\n    return JS_NewBool(ctx, is_safe_integer(d));\n}\n\nstatic const JSCFunctionListEntry js_number_funcs[] = {\n    /* global ParseInt and parseFloat should be defined already or delayed */\n    JS_ALIAS_BASE_DEF(\"parseInt\", \"parseInt\", 0 ),\n    JS_ALIAS_BASE_DEF(\"parseFloat\", \"parseFloat\", 0 ),\n    JS_CFUNC_DEF(\"isNaN\", 1, js_number_isNaN ),\n    JS_CFUNC_DEF(\"isFinite\", 1, js_number_isFinite ),\n    JS_CFUNC_DEF(\"isInteger\", 1, js_number_isInteger ),\n    JS_CFUNC_DEF(\"isSafeInteger\", 1, js_number_isSafeInteger ),\n    JS_PROP_DOUBLE_DEF(\"MAX_VALUE\", 1.7976931348623157e+308, 0 ),\n    JS_PROP_DOUBLE_DEF(\"MIN_VALUE\", 5e-324, 0 ),\n    JS_PROP_DOUBLE_DEF(\"NaN\", NAN, 0 ),\n    JS_PROP_DOUBLE_DEF(\"NEGATIVE_INFINITY\", -INFINITY, 0 ),\n    JS_PROP_DOUBLE_DEF(\"POSITIVE_INFINITY\", INFINITY, 0 ),\n    JS_PROP_DOUBLE_DEF(\"EPSILON\", 2.220446049250313e-16, 0 ), /* ES6 */\n    JS_PROP_DOUBLE_DEF(\"MAX_SAFE_INTEGER\", 9007199254740991.0, 0 ), /* ES6 */\n    JS_PROP_DOUBLE_DEF(\"MIN_SAFE_INTEGER\", -9007199254740991.0, 0 ), /* ES6 */\n    //JS_CFUNC_DEF(\"__toInteger\", 1, js_number___toInteger ),\n    //JS_CFUNC_DEF(\"__toLength\", 1, js_number___toLength ),\n};\n\nstatic JSValue js_thisNumberValue(JSContext *ctx, JSValueConst this_val)\n{\n    if (JS_IsNumber(this_val))\n        return JS_DupValue(ctx, this_val);\n\n    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(this_val);\n        if (p->class_id == JS_CLASS_NUMBER) {\n            if (JS_IsNumber(p->u.object_data))\n                return JS_DupValue(ctx, p->u.object_data);\n        }\n    }\n    return JS_ThrowTypeError(ctx, \"not a number\");\n}\n\nstatic JSValue js_number_valueOf(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    return js_thisNumberValue(ctx, this_val);\n}\n\nstatic int js_get_radix(JSContext *ctx, JSValueConst val)\n{\n    int radix;\n    if (JS_ToInt32Sat(ctx, &radix, val))\n        return -1;\n    if (radix < 2 || radix > 36) {\n        JS_ThrowRangeError(ctx, \"radix must be between 2 and 36\");\n        return -1;\n    }\n    return radix;\n}\n\nstatic JSValue js_number_toString(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv, int magic)\n{\n    JSValue val;\n    int base;\n    double d;\n\n    val = js_thisNumberValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    if (magic || JS_IsUndefined(argv[0])) {\n        base = 10;\n    } else {\n        base = js_get_radix(ctx, argv[0]);\n        if (base < 0)\n            goto fail;\n    }\n    if (JS_ToFloat64Free(ctx, &d, val))\n        return JS_EXCEPTION;\n    return js_dtoa(ctx, d, base, 0, JS_DTOA_VAR_FORMAT);\n fail:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_number_toFixed(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    JSValue val;\n    int f;\n    double d;\n\n    val = js_thisNumberValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    if (JS_ToFloat64Free(ctx, &d, val))\n        return JS_EXCEPTION;\n    if (JS_ToInt32Sat(ctx, &f, argv[0]))\n        return JS_EXCEPTION;\n    if (f < 0 || f > 100)\n        return JS_ThrowRangeError(ctx, \"invalid number of digits\");\n    if (fabs(d) >= 1e21) {\n        return JS_ToStringFree(ctx, __JS_NewFloat64(ctx, d));\n    } else {\n        return js_dtoa(ctx, d, 10, f, JS_DTOA_FRAC_FORMAT);\n    }\n}\n\nstatic JSValue js_number_toExponential(JSContext *ctx, JSValueConst this_val,\n                                       int argc, JSValueConst *argv)\n{\n    JSValue val;\n    int f, flags;\n    double d;\n\n    val = js_thisNumberValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    if (JS_ToFloat64Free(ctx, &d, val))\n        return JS_EXCEPTION;\n    if (JS_ToInt32Sat(ctx, &f, argv[0]))\n        return JS_EXCEPTION;\n    if (!isfinite(d)) {\n        return JS_ToStringFree(ctx,  __JS_NewFloat64(ctx, d));\n    }\n    if (JS_IsUndefined(argv[0])) {\n        flags = 0;\n        f = 0;\n    } else {\n        if (f < 0 || f > 100)\n            return JS_ThrowRangeError(ctx, \"invalid number of digits\");\n        f++;\n        flags = JS_DTOA_FIXED_FORMAT;\n    }\n    return js_dtoa(ctx, d, 10, f, flags | JS_DTOA_FORCE_EXP);\n}\n\nstatic JSValue js_number_toPrecision(JSContext *ctx, JSValueConst this_val,\n                                     int argc, JSValueConst *argv)\n{\n    JSValue val;\n    int p;\n    double d;\n\n    val = js_thisNumberValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    if (JS_ToFloat64Free(ctx, &d, val))\n        return JS_EXCEPTION;\n    if (JS_IsUndefined(argv[0]))\n        goto to_string;\n    if (JS_ToInt32Sat(ctx, &p, argv[0]))\n        return JS_EXCEPTION;\n    if (!isfinite(d)) {\n    to_string:\n        return JS_ToStringFree(ctx,  __JS_NewFloat64(ctx, d));\n    }\n    if (p < 1 || p > 100)\n        return JS_ThrowRangeError(ctx, \"invalid number of digits\");\n    return js_dtoa(ctx, d, 10, p, JS_DTOA_FIXED_FORMAT);\n}\n\nstatic const JSCFunctionListEntry js_number_proto_funcs[] = {\n    JS_CFUNC_DEF(\"toExponential\", 1, js_number_toExponential ),\n    JS_CFUNC_DEF(\"toFixed\", 1, js_number_toFixed ),\n    JS_CFUNC_DEF(\"toPrecision\", 1, js_number_toPrecision ),\n    JS_CFUNC_MAGIC_DEF(\"toString\", 1, js_number_toString, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"toLocaleString\", 0, js_number_toString, 1 ),\n    JS_CFUNC_DEF(\"valueOf\", 0, js_number_valueOf ),\n};\n\nstatic JSValue js_parseInt(JSContext *ctx, JSValueConst this_val,\n                           int argc, JSValueConst *argv)\n{\n    const char *str, *p;\n    int radix, flags;\n    JSValue ret;\n\n    str = JS_ToCString(ctx, argv[0]);\n    if (!str)\n        return JS_EXCEPTION;\n    if (JS_ToInt32(ctx, &radix, argv[1])) {\n        JS_FreeCString(ctx, str);\n        return JS_EXCEPTION;\n    }\n    if (radix != 0 && (radix < 2 || radix > 36)) {\n        ret = JS_NAN;\n    } else {\n        p = str;\n        p += skip_spaces(p);\n        flags = ATOD_INT_ONLY | ATOD_ACCEPT_PREFIX_AFTER_SIGN;\n        ret = js_atof(ctx, p, NULL, radix, flags);\n    }\n    JS_FreeCString(ctx, str);\n    return ret;\n}\n\nstatic JSValue js_parseFloat(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    const char *str, *p;\n    JSValue ret;\n\n    str = JS_ToCString(ctx, argv[0]);\n    if (!str)\n        return JS_EXCEPTION;\n    p = str;\n    p += skip_spaces(p);\n    ret = js_atof(ctx, p, NULL, 10, 0);\n    JS_FreeCString(ctx, str);\n    return ret;\n}\n\n/* Boolean */\nstatic JSValue js_boolean_constructor(JSContext *ctx, JSValueConst new_target,\n                                     int argc, JSValueConst *argv)\n{\n    JSValue val, obj;\n    val = JS_NewBool(ctx, JS_ToBool(ctx, argv[0]));\n    if (!JS_IsUndefined(new_target)) {\n        obj = js_create_from_ctor(ctx, new_target, JS_CLASS_BOOLEAN);\n        if (!JS_IsException(obj))\n            JS_SetObjectData(ctx, obj, val);\n        return obj;\n    } else {\n        return val;\n    }\n}\n\nstatic JSValue js_thisBooleanValue(JSContext *ctx, JSValueConst this_val)\n{\n    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_BOOL)\n        return JS_DupValue(ctx, this_val);\n\n    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(this_val);\n        if (p->class_id == JS_CLASS_BOOLEAN) {\n            if (JS_VALUE_GET_TAG(p->u.object_data) == JS_TAG_BOOL)\n                return p->u.object_data;\n        }\n    }\n    return JS_ThrowTypeError(ctx, \"not a boolean\");\n}\n\nstatic JSValue js_boolean_toString(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    JSValue val = js_thisBooleanValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    return JS_AtomToString(ctx, JS_VALUE_GET_BOOL(val) ?\n                       JS_ATOM_true : JS_ATOM_false);\n}\n\nstatic JSValue js_boolean_valueOf(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    return js_thisBooleanValue(ctx, this_val);\n}\n\nstatic const JSCFunctionListEntry js_boolean_proto_funcs[] = {\n    JS_CFUNC_DEF(\"toString\", 0, js_boolean_toString ),\n    JS_CFUNC_DEF(\"valueOf\", 0, js_boolean_valueOf ),\n};\n\n/* String */\n\nstatic int js_string_get_own_property(JSContext *ctx,\n                                      JSPropertyDescriptor *desc,\n                                      JSValueConst obj, JSAtom prop)\n{\n    JSObject *p;\n    JSString *p1;\n    uint32_t idx, ch;\n\n    /* This is a class exotic method: obj class_id is JS_CLASS_STRING */\n    if (__JS_AtomIsTaggedInt(prop)) {\n        p = JS_VALUE_GET_OBJ(obj);\n        if (JS_VALUE_GET_TAG(p->u.object_data) == JS_TAG_STRING) {\n            p1 = JS_VALUE_GET_STRING(p->u.object_data);\n            idx = __JS_AtomToUInt32(prop);\n            if (idx < p1->len) {\n                if (desc) {\n                    if (p1->is_wide_char)\n                        ch = p1->u.str16[idx];\n                    else\n                        ch = p1->u.str8[idx];\n                    desc->flags = JS_PROP_ENUMERABLE;\n                    desc->value = js_new_string_char(ctx, ch);\n                    desc->getter = JS_UNDEFINED;\n                    desc->setter = JS_UNDEFINED;\n                }\n                return TRUE;\n            }\n        }\n    }\n    return FALSE;\n}\n\nstatic int js_string_define_own_property(JSContext *ctx,\n                                         JSValueConst this_obj,\n                                         JSAtom prop, JSValueConst val,\n                                         JSValueConst getter,\n                                         JSValueConst setter, int flags)\n{\n    uint32_t idx;\n    JSObject *p;\n    JSString *p1, *p2;\n    \n    if (__JS_AtomIsTaggedInt(prop)) {\n        idx = __JS_AtomToUInt32(prop);\n        p = JS_VALUE_GET_OBJ(this_obj);\n        if (JS_VALUE_GET_TAG(p->u.object_data) != JS_TAG_STRING)\n            goto def;\n        p1 = JS_VALUE_GET_STRING(p->u.object_data);\n        if (idx >= p1->len)\n            goto def;\n        if (!check_define_prop_flags(JS_PROP_ENUMERABLE, flags))\n            goto fail;\n        /* check that the same value is configured */\n        if (flags & JS_PROP_HAS_VALUE) {\n            if (JS_VALUE_GET_TAG(val) != JS_TAG_STRING)\n                goto fail;\n            p2 = JS_VALUE_GET_STRING(val);\n            if (p2->len != 1)\n                goto fail;\n            if (string_get(p1, idx) != string_get(p2, 0)) {\n            fail:\n                return JS_ThrowTypeErrorOrFalse(ctx, flags, \"property is not configurable\");\n            }\n        }\n        return TRUE;\n    } else {\n    def:\n        return JS_DefineProperty(ctx, this_obj, prop, val, getter, setter,\n                                 flags | JS_PROP_NO_EXOTIC);\n    }\n}\n\nstatic int js_string_delete_property(JSContext *ctx,\n                                     JSValueConst obj, JSAtom prop)\n{\n    uint32_t idx;\n\n    if (__JS_AtomIsTaggedInt(prop)) {\n        idx = __JS_AtomToUInt32(prop);\n        if (idx < js_string_obj_get_length(ctx, obj)) {\n            return FALSE;\n        }\n    }\n    return TRUE;\n}\n\nstatic const JSClassExoticMethods js_string_exotic_methods = {\n    .get_own_property = js_string_get_own_property,\n    .define_own_property = js_string_define_own_property,\n    .delete_property = js_string_delete_property,\n};\n\nstatic JSValue js_string_constructor(JSContext *ctx, JSValueConst new_target,\n                                     int argc, JSValueConst *argv)\n{\n    JSValue val, obj;\n    if (argc == 0) {\n        val = JS_AtomToString(ctx, JS_ATOM_empty_string);\n    } else {\n        if (JS_IsUndefined(new_target) && JS_IsSymbol(argv[0])) {\n            JSAtomStruct *p = JS_VALUE_GET_PTR(argv[0]);\n            val = JS_ConcatString3(ctx, \"Symbol(\", JS_AtomToString(ctx, js_get_atom_index(ctx->rt, p)), \")\");\n        } else {\n            val = JS_ToString(ctx, argv[0]);\n        }\n        if (JS_IsException(val))\n            return val;\n    }\n    if (!JS_IsUndefined(new_target)) {\n        JSString *p1 = JS_VALUE_GET_STRING(val);\n\n        obj = js_create_from_ctor(ctx, new_target, JS_CLASS_STRING);\n        if (!JS_IsException(obj)) {\n            JS_SetObjectData(ctx, obj, val);\n            JS_DefinePropertyValue(ctx, obj, JS_ATOM_length, JS_NewInt32(ctx, p1->len), 0);\n        }\n        return obj;\n    } else {\n        return val;\n    }\n}\n\nstatic JSValue js_thisStringValue(JSContext *ctx, JSValueConst this_val)\n{\n    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_STRING)\n        return JS_DupValue(ctx, this_val);\n\n    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(this_val);\n        if (p->class_id == JS_CLASS_STRING) {\n            if (JS_VALUE_GET_TAG(p->u.object_data) == JS_TAG_STRING)\n                return JS_DupValue(ctx, p->u.object_data);\n        }\n    }\n    return JS_ThrowTypeError(ctx, \"not a string\");\n}\n\nstatic JSValue js_string_fromCharCode(JSContext *ctx, JSValueConst this_val,\n                                      int argc, JSValueConst *argv)\n{\n    int i;\n    StringBuffer b_s, *b = &b_s;\n\n    string_buffer_init(ctx, b, argc);\n\n    for(i = 0; i < argc; i++) {\n        int32_t c;\n        if (JS_ToInt32(ctx, &c, argv[i]) || string_buffer_putc16(b, c & 0xffff)) {\n            string_buffer_free(b);\n            return JS_EXCEPTION;\n        }\n    }\n    return string_buffer_end(b);\n}\n\nstatic JSValue js_string_fromCodePoint(JSContext *ctx, JSValueConst this_val,\n                                       int argc, JSValueConst *argv)\n{\n    double d;\n    int i, c;\n    StringBuffer b_s, *b = &b_s;\n\n    /* XXX: could pre-compute string length if all arguments are JS_TAG_INT */\n\n    if (string_buffer_init(ctx, b, argc))\n        goto fail;\n    for(i = 0; i < argc; i++) {\n        if (JS_VALUE_GET_TAG(argv[i]) == JS_TAG_INT) {\n            c = JS_VALUE_GET_INT(argv[i]);\n            if (c < 0 || c > 0x10ffff)\n                goto range_error;\n        } else {\n            if (JS_ToFloat64(ctx, &d, argv[i]))\n                goto fail;\n            if (d < 0 || d > 0x10ffff || (c = (int)d) != d)\n                goto range_error;\n        }\n        if (string_buffer_putc(b, c))\n            goto fail;\n    }\n    return string_buffer_end(b);\n\n range_error:\n    JS_ThrowRangeError(ctx, \"invalid code point\");\n fail:\n    string_buffer_free(b);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_string_raw(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    // raw(temp,...a)\n    JSValue cooked, val, raw;\n    StringBuffer b_s, *b = &b_s;\n    int64_t i, n;\n\n    string_buffer_init(ctx, b, 0);\n    raw = JS_UNDEFINED;\n    cooked = JS_ToObject(ctx, argv[0]);\n    if (JS_IsException(cooked))\n        goto exception;\n    raw = JS_ToObjectFree(ctx, JS_GetProperty(ctx, cooked, JS_ATOM_raw));\n    if (JS_IsException(raw))\n        goto exception;\n    if (js_get_length64(ctx, &n, raw) < 0)\n        goto exception;\n        \n    for (i = 0; i < n; i++) {\n        val = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, raw, i));\n        if (JS_IsException(val))\n            goto exception;\n        string_buffer_concat_value_free(b, val);\n        if (i < n - 1 && i + 1 < argc) {\n            if (string_buffer_concat_value(b, argv[i + 1]))\n                goto exception;\n        }\n    }\n    JS_FreeValue(ctx, cooked);\n    JS_FreeValue(ctx, raw);\n    return string_buffer_end(b);\n\nexception:\n    JS_FreeValue(ctx, cooked);\n    JS_FreeValue(ctx, raw);\n    string_buffer_free(b);\n    return JS_EXCEPTION;\n}\n\n/* only used in test262 */\nJSValue js_string_codePointRange(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    uint32_t start, end, i, n;\n    StringBuffer b_s, *b = &b_s;\n\n    if (JS_ToUint32(ctx, &start, argv[0]) ||\n        JS_ToUint32(ctx, &end, argv[1]))\n        return JS_EXCEPTION;\n    end = min_uint32(end, 0x10ffff + 1);\n\n    if (start > end) {\n        start = end;\n    }\n    n = end - start;\n    if (end > 0x10000) {\n        n += end - max_uint32(start, 0x10000);\n    }\n    if (string_buffer_init2(ctx, b, n, end >= 0x100))\n        return JS_EXCEPTION;\n    for(i = start; i < end; i++) {\n        string_buffer_putc(b, i);\n    }\n    return string_buffer_end(b);\n}\n\n#if 0\nstatic JSValue js_string___isSpace(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    int c;\n    if (JS_ToInt32(ctx, &c, argv[0]))\n        return JS_EXCEPTION;\n    return JS_NewBool(ctx, lre_is_space(c));\n}\n#endif\n\nstatic JSValue js_string_charCodeAt(JSContext *ctx, JSValueConst this_val,\n                                     int argc, JSValueConst *argv)\n{\n    JSValue val, ret;\n    JSString *p;\n    int idx, c;\n\n    val = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    p = JS_VALUE_GET_STRING(val);\n    if (JS_ToInt32Sat(ctx, &idx, argv[0])) {\n        JS_FreeValue(ctx, val);\n        return JS_EXCEPTION;\n    }\n    if (idx < 0 || idx >= p->len) {\n        ret = JS_NAN;\n    } else {\n        if (p->is_wide_char)\n            c = p->u.str16[idx];\n        else\n            c = p->u.str8[idx];\n        ret = JS_NewInt32(ctx, c);\n    }\n    JS_FreeValue(ctx, val);\n    return ret;\n}\n\nstatic JSValue js_string_charAt(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    JSValue val, ret;\n    JSString *p;\n    int idx, c;\n\n    val = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    p = JS_VALUE_GET_STRING(val);\n    if (JS_ToInt32Sat(ctx, &idx, argv[0])) {\n        JS_FreeValue(ctx, val);\n        return JS_EXCEPTION;\n    }\n    if (idx < 0 || idx >= p->len) {\n        ret = js_new_string8(ctx, NULL, 0);\n    } else {\n        if (p->is_wide_char)\n            c = p->u.str16[idx];\n        else\n            c = p->u.str8[idx];\n        ret = js_new_string_char(ctx, c);\n    }\n    JS_FreeValue(ctx, val);\n    return ret;\n}\n\nstatic JSValue js_string_codePointAt(JSContext *ctx, JSValueConst this_val,\n                                     int argc, JSValueConst *argv)\n{\n    JSValue val, ret;\n    JSString *p;\n    int idx, c;\n\n    val = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    p = JS_VALUE_GET_STRING(val);\n    if (JS_ToInt32Sat(ctx, &idx, argv[0])) {\n        JS_FreeValue(ctx, val);\n        return JS_EXCEPTION;\n    }\n    if (idx < 0 || idx >= p->len) {\n        ret = JS_UNDEFINED;\n    } else {\n        c = string_getc(p, &idx);\n        ret = JS_NewInt32(ctx, c);\n    }\n    JS_FreeValue(ctx, val);\n    return ret;\n}\n\nstatic JSValue js_string_concat(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    JSValue r;\n    int i;\n\n    /* XXX: Use more efficient method */\n    /* XXX: This method is OK if r has a single refcount */\n    /* XXX: should use string_buffer? */\n    r = JS_ToStringCheckObject(ctx, this_val);\n    for (i = 0; i < argc; i++) {\n        if (JS_IsException(r))\n            break;\n        r = JS_ConcatString(ctx, r, JS_DupValue(ctx, argv[i]));\n    }\n    return r;\n}\n\nstatic int string_cmp(JSString *p1, JSString *p2, int x1, int x2, int len)\n{\n    int i, c1, c2;\n    for (i = 0; i < len; i++) {\n        if ((c1 = string_get(p1, x1 + i)) != (c2 = string_get(p2, x2 + i)))\n            return c1 - c2;\n    }\n    return 0;\n}\n\nstatic int string_indexof_char(JSString *p, int c, int from)\n{\n    /* assuming 0 <= from <= p->len */\n    int i, len = p->len;\n    if (p->is_wide_char) {\n        for (i = from; i < len; i++) {\n            if (p->u.str16[i] == c)\n                return i;\n        }\n    } else {\n        if ((c & ~0xff) == 0) {\n            for (i = from; i < len; i++) {\n                if (p->u.str8[i] == (uint8_t)c)\n                    return i;\n            }\n        }\n    }\n    return -1;\n}\n\nstatic int string_indexof(JSString *p1, JSString *p2, int from)\n{\n    /* assuming 0 <= from <= p1->len */\n    int c, i, j, len1 = p1->len, len2 = p2->len;\n    if (len2 == 0)\n        return from;\n    for (i = from, c = string_get(p2, 0); i + len2 <= len1; i = j + 1) {\n        j = string_indexof_char(p1, c, i);\n        if (j < 0 || j + len2 > len1)\n            break;\n        if (!string_cmp(p1, p2, j + 1, 1, len2 - 1))\n            return j;\n    }\n    return -1;\n}\n\nstatic int64_t string_advance_index(JSString *p, int64_t index, BOOL unicode)\n{\n    if (!unicode || index >= p->len || !p->is_wide_char) {\n        index++;\n    } else {\n        int index32 = (int)index;\n        string_getc(p, &index32);\n        index = index32;\n    }\n    return index;\n}\n\nstatic JSValue js_string_indexOf(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv, int lastIndexOf)\n{\n    JSValue str, v;\n    int i, len, v_len, pos, start, stop, ret, inc;\n    JSString *p;\n    JSString *p1;\n\n    str = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(str))\n        return str;\n    v = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(v))\n        goto fail;\n    p = JS_VALUE_GET_STRING(str);\n    p1 = JS_VALUE_GET_STRING(v);\n    len = p->len;\n    v_len = p1->len;\n    if (lastIndexOf) {\n        pos = len - v_len;\n        if (argc > 1) {\n            double d;\n            if (JS_ToFloat64(ctx, &d, argv[1]))\n                goto fail;\n            if (!isnan(d)) {\n                if (d <= 0)\n                    pos = 0;\n                else if (d < pos)\n                    pos = d;\n            }\n        }\n        start = pos;\n        stop = 0;\n        inc = -1;\n    } else {\n        pos = 0;\n        if (argc > 1) {\n            if (JS_ToInt32Clamp(ctx, &pos, argv[1], 0, len, 0))\n                goto fail;\n        }\n        start = pos;\n        stop = len - v_len;\n        inc = 1;\n    }\n    ret = -1;\n    if (len >= v_len && inc * (stop - start) >= 0) {\n        for (i = start;; i += inc) {\n            if (!string_cmp(p, p1, i, 0, v_len)) {\n                ret = i;\n                break;\n            }\n            if (i == stop)\n                break;\n        }\n    }\n    JS_FreeValue(ctx, str);\n    JS_FreeValue(ctx, v);\n    return JS_NewInt32(ctx, ret);\n\nfail:\n    JS_FreeValue(ctx, str);\n    JS_FreeValue(ctx, v);\n    return JS_EXCEPTION;\n}\n\n/* return < 0 if exception or TRUE/FALSE */\nstatic int js_is_regexp(JSContext *ctx, JSValueConst obj);\n\nstatic JSValue js_string_includes(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv, int magic)\n{\n    JSValue str, v = JS_UNDEFINED;\n    int i, len, v_len, pos, start, stop, ret;\n    JSString *p;\n    JSString *p1;\n\n    str = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(str))\n        return str;\n    ret = js_is_regexp(ctx, argv[0]);\n    if (ret) {\n        if (ret > 0)\n            JS_ThrowTypeError(ctx, \"regex not supported\");\n        goto fail;\n    }\n    v = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(v))\n        goto fail;\n    p = JS_VALUE_GET_STRING(str);\n    p1 = JS_VALUE_GET_STRING(v);\n    len = p->len;\n    v_len = p1->len;\n    pos = (magic == 2) ? len : 0;\n    if (argc > 1 && !JS_IsUndefined(argv[1])) {\n        if (JS_ToInt32Clamp(ctx, &pos, argv[1], 0, len, 0))\n            goto fail;\n    }\n    len -= v_len;\n    ret = 0;\n    if (magic == 0) {\n        start = pos;\n        stop = len;\n    } else {\n        if (magic == 1) {\n            if (pos > len)\n                goto done;\n        } else {\n            pos -= v_len;\n        }\n        start = stop = pos;\n    }\n    if (start >= 0 && start <= stop) {\n        for (i = start;; i++) {\n            if (!string_cmp(p, p1, i, 0, v_len)) {\n                ret = 1;\n                break;\n            }\n            if (i == stop)\n                break;\n        }\n    }\n done:\n    JS_FreeValue(ctx, str);\n    JS_FreeValue(ctx, v);\n    return JS_NewBool(ctx, ret);\n\nfail:\n    JS_FreeValue(ctx, str);\n    JS_FreeValue(ctx, v);\n    return JS_EXCEPTION;\n}\n\nstatic int check_regexp_g_flag(JSContext *ctx, JSValueConst regexp)\n{\n    int ret;\n    JSValue flags;\n    \n    ret = js_is_regexp(ctx, regexp);\n    if (ret < 0)\n        return -1;\n    if (ret) {\n        flags = JS_GetProperty(ctx, regexp, JS_ATOM_flags);\n        if (JS_IsException(flags))\n            return -1;\n        if (JS_IsUndefined(flags) || JS_IsNull(flags)) {\n            JS_ThrowTypeError(ctx, \"cannot convert to object\");\n            return -1;\n        }\n        flags = JS_ToStringFree(ctx, flags);\n        if (JS_IsException(flags))\n            return -1;\n        ret = string_indexof_char(JS_VALUE_GET_STRING(flags), 'g', 0);\n        JS_FreeValue(ctx, flags);\n        if (ret < 0) {\n            JS_ThrowTypeError(ctx, \"regexp must have the 'g' flag\");\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic JSValue js_string_match(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv, int atom)\n{\n    // match(rx), search(rx), matchAll(rx)\n    // atom is JS_ATOM_Symbol_match, JS_ATOM_Symbol_search, or JS_ATOM_Symbol_matchAll\n    JSValueConst O = this_val, regexp = argv[0], args[2];\n    JSValue matcher, S, rx, result, str;\n    int args_len;\n\n    if (JS_IsUndefined(O) || JS_IsNull(O))\n        return JS_ThrowTypeError(ctx, \"cannot convert to object\");\n\n    if (!JS_IsUndefined(regexp) && !JS_IsNull(regexp)) {\n        matcher = JS_GetProperty(ctx, regexp, atom);\n        if (JS_IsException(matcher))\n            return JS_EXCEPTION;\n        if (atom == JS_ATOM_Symbol_matchAll) {\n            if (check_regexp_g_flag(ctx, regexp) < 0) {\n                JS_FreeValue(ctx, matcher);\n                return JS_EXCEPTION;\n            }\n        }\n        if (!JS_IsUndefined(matcher) && !JS_IsNull(matcher)) {\n            return JS_CallFree(ctx, matcher, regexp, 1, &O);\n        }\n    }\n    S = JS_ToString(ctx, O);\n    if (JS_IsException(S))\n        return JS_EXCEPTION;\n    args_len = 1;\n    args[0] = regexp;\n    str = JS_UNDEFINED;\n    if (atom == JS_ATOM_Symbol_matchAll) {\n        str = JS_NewString(ctx, \"g\");\n        if (JS_IsException(str))\n            goto fail;\n        args[args_len++] = (JSValueConst)str;\n    }\n    rx = JS_CallConstructor(ctx, ctx->regexp_ctor, args_len, args);\n    JS_FreeValue(ctx, str);\n    if (JS_IsException(rx)) {\n    fail:\n        JS_FreeValue(ctx, S);\n        return JS_EXCEPTION;\n    }\n    result = JS_InvokeFree(ctx, rx, atom, 1, (JSValueConst *)&S);\n    JS_FreeValue(ctx, S);\n    return result;\n}\n\nstatic JSValue js_string___GetSubstitution(JSContext *ctx, JSValueConst this_val,\n                                           int argc, JSValueConst *argv)\n{\n    // GetSubstitution(matched, str, position, captures, namedCaptures, rep)\n    JSValueConst matched, str, captures, namedCaptures, rep;\n    JSValue capture, name, s;\n    uint32_t position, len, matched_len, captures_len;\n    int i, j, j0, k, k1;\n    int c, c1;\n    StringBuffer b_s, *b = &b_s;\n    JSString *sp, *rp;\n\n    matched = argv[0];\n    str = argv[1];\n    captures = argv[3];\n    namedCaptures = argv[4];\n    rep = argv[5];\n\n    if (!JS_IsString(rep) || !JS_IsString(str))\n        return JS_ThrowTypeError(ctx, \"not a string\");\n\n    sp = JS_VALUE_GET_STRING(str);\n    rp = JS_VALUE_GET_STRING(rep);\n\n    string_buffer_init(ctx, b, 0);\n\n    captures_len = 0;\n    if (!JS_IsUndefined(captures)) {\n        if (js_get_length32(ctx, &captures_len, captures))\n            goto exception;\n    }\n    if (js_get_length32(ctx, &matched_len, matched))\n        goto exception;\n    if (JS_ToUint32(ctx, &position, argv[2]) < 0)\n        goto exception;\n\n    len = rp->len;\n    i = 0;\n    for(;;) {\n        j = string_indexof_char(rp, '$', i);\n        if (j < 0 || j + 1 >= len)\n            break;\n        string_buffer_concat(b, rp, i, j);\n        j0 = j++;\n        c = string_get(rp, j++);\n        if (c == '$') {\n            string_buffer_putc8(b, '$');\n        } else if (c == '&') {\n            if (string_buffer_concat_value(b, matched))\n                goto exception;\n        } else if (c == '`') {\n            string_buffer_concat(b, sp, 0, position);\n        } else if (c == '\\'') {\n            string_buffer_concat(b, sp, position + matched_len, sp->len);\n        } else if (c >= '0' && c <= '9') {\n            k = c - '0';\n            if (j < len) {\n                c1 = string_get(rp, j);\n                if (c1 >= '0' && c1 <= '9') {\n                    /* This behavior is specified in ES6 and refined in ECMA 2019 */\n                    /* ECMA 2019 does not have the extra test, but\n                       Test262 S15.5.4.11_A3_T1..3 require this behavior */\n                    k1 = k * 10 + c1 - '0';\n                    if (k1 >= 1 && k1 < captures_len) {\n                        k = k1;\n                        j++;\n                    }\n                }\n            }\n            if (k >= 1 && k < captures_len) {\n                s = JS_GetPropertyInt64(ctx, captures, k);\n                if (JS_IsException(s))\n                    goto exception;\n                if (!JS_IsUndefined(s)) {\n                    if (string_buffer_concat_value_free(b, s))\n                        goto exception;\n                }\n            } else {\n                goto norep;\n            }\n        } else if (c == '<' && !JS_IsUndefined(namedCaptures)) {\n            k = string_indexof_char(rp, '>', j);\n            if (k < 0)\n                goto norep;\n            name = js_sub_string(ctx, rp, j, k);\n            if (JS_IsException(name))\n                goto exception;\n            capture = JS_GetPropertyValue(ctx, namedCaptures, name);\n            if (JS_IsException(capture))\n                goto exception;\n            if (!JS_IsUndefined(capture)) {\n                if (string_buffer_concat_value_free(b, capture))\n                    goto exception;\n            }\n            j = k + 1;\n        } else {\n        norep:\n            string_buffer_concat(b, rp, j0, j);\n        }\n        i = j;\n    }\n    string_buffer_concat(b, rp, i, rp->len);\n    return string_buffer_end(b);\nexception:\n    string_buffer_free(b);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_string_replace(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv,\n                                 int is_replaceAll)\n{\n    // replace(rx, rep)\n    JSValueConst O = this_val, searchValue = argv[0], replaceValue = argv[1];\n    JSValueConst args[6];\n    JSValue str, search_str, replaceValue_str, repl_str;\n    JSString *sp, *searchp;\n    StringBuffer b_s, *b = &b_s;\n    int pos, functionalReplace, endOfLastMatch;\n    BOOL is_first;\n\n    if (JS_IsUndefined(O) || JS_IsNull(O))\n        return JS_ThrowTypeError(ctx, \"cannot convert to object\");\n\n    search_str = JS_UNDEFINED;\n    replaceValue_str = JS_UNDEFINED;\n    repl_str = JS_UNDEFINED;\n\n    if (!JS_IsUndefined(searchValue) && !JS_IsNull(searchValue)) {\n        JSValue replacer;\n        if (is_replaceAll) {\n            if (check_regexp_g_flag(ctx, searchValue) < 0)\n                return JS_EXCEPTION;\n        }\n        replacer = JS_GetProperty(ctx, searchValue, JS_ATOM_Symbol_replace);\n        if (JS_IsException(replacer))\n            return JS_EXCEPTION;\n        if (!JS_IsUndefined(replacer) && !JS_IsNull(replacer)) {\n            args[0] = O;\n            args[1] = replaceValue;\n            return JS_CallFree(ctx, replacer, searchValue, 2, args);\n        }\n    }\n    string_buffer_init(ctx, b, 0);\n\n    str = JS_ToString(ctx, O);\n    if (JS_IsException(str))\n        goto exception;\n    search_str = JS_ToString(ctx, searchValue);\n    if (JS_IsException(search_str))\n        goto exception;\n    functionalReplace = JS_IsFunction(ctx, replaceValue);\n    if (!functionalReplace) {\n        replaceValue_str = JS_ToString(ctx, replaceValue);\n        if (JS_IsException(replaceValue_str))\n            goto exception;\n    }\n\n    sp = JS_VALUE_GET_STRING(str);\n    searchp = JS_VALUE_GET_STRING(search_str);\n    endOfLastMatch = 0;\n    is_first = TRUE;\n    for(;;) {\n        if (unlikely(searchp->len == 0)) {\n            if (is_first)\n                pos = 0;\n            else if (endOfLastMatch >= sp->len)\n                pos = -1;\n            else\n                pos = endOfLastMatch + 1;\n        } else {\n            pos = string_indexof(sp, searchp, endOfLastMatch);\n        }\n        if (pos < 0) {\n            if (is_first) {\n                string_buffer_free(b);\n                JS_FreeValue(ctx, search_str);\n                JS_FreeValue(ctx, replaceValue_str);\n                return str;\n            } else {\n                break;\n            }\n        }\n        if (functionalReplace) {\n            args[0] = search_str;\n            args[1] = JS_NewInt32(ctx, pos);\n            args[2] = str;\n            repl_str = JS_ToStringFree(ctx, JS_Call(ctx, replaceValue, JS_UNDEFINED, 3, args));\n        } else {\n            args[0] = search_str;\n            args[1] = str;\n            args[2] = JS_NewInt32(ctx, pos);\n            args[3] = JS_UNDEFINED;\n            args[4] = JS_UNDEFINED;\n            args[5] = replaceValue_str;\n            repl_str = js_string___GetSubstitution(ctx, JS_UNDEFINED, 6, args);\n        }\n        if (JS_IsException(repl_str))\n            goto exception;\n        \n        string_buffer_concat(b, sp, endOfLastMatch, pos);\n        string_buffer_concat_value_free(b, repl_str);\n        endOfLastMatch = pos + searchp->len;\n        is_first = FALSE;\n        if (!is_replaceAll)\n            break;\n    }\n    string_buffer_concat(b, sp, endOfLastMatch, sp->len);\n    JS_FreeValue(ctx, search_str);\n    JS_FreeValue(ctx, replaceValue_str);\n    JS_FreeValue(ctx, str);\n    return string_buffer_end(b);\n\nexception:\n    string_buffer_free(b);\n    JS_FreeValue(ctx, search_str);\n    JS_FreeValue(ctx, replaceValue_str);\n    JS_FreeValue(ctx, str);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_string_split(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    // split(sep, limit)\n    JSValueConst O = this_val, separator = argv[0], limit = argv[1];\n    JSValueConst args[2];\n    JSValue S, A, R, T;\n    uint32_t lim, lengthA;\n    int64_t p, q, s, r, e;\n    JSString *sp, *rp;\n\n    if (JS_IsUndefined(O) || JS_IsNull(O))\n        return JS_ThrowTypeError(ctx, \"cannot convert to object\");\n\n    S = JS_UNDEFINED;\n    A = JS_UNDEFINED;\n    R = JS_UNDEFINED;\n\n    if (!JS_IsUndefined(separator) && !JS_IsNull(separator)) {\n        JSValue splitter;\n        splitter = JS_GetProperty(ctx, separator, JS_ATOM_Symbol_split);\n        if (JS_IsException(splitter))\n            return JS_EXCEPTION;\n        if (!JS_IsUndefined(splitter) && !JS_IsNull(splitter)) {\n            args[0] = O;\n            args[1] = limit;\n            return JS_CallFree(ctx, splitter, separator, 2, args);\n        }\n    }\n    S = JS_ToString(ctx, O);\n    if (JS_IsException(S))\n        goto exception;\n    A = JS_NewArray(ctx);\n    if (JS_IsException(A))\n        goto exception;\n    lengthA = 0;\n    if (JS_IsUndefined(limit)) {\n        lim = 0xffffffff;\n    } else {\n        if (JS_ToUint32(ctx, &lim, limit) < 0)\n            goto exception;\n    }\n    sp = JS_VALUE_GET_STRING(S);\n    s = sp->len;\n    R = JS_ToString(ctx, separator);\n    if (JS_IsException(R))\n        goto exception;\n    rp = JS_VALUE_GET_STRING(R);\n    r = rp->len;\n    p = 0;\n    if (lim == 0)\n        goto done;\n    if (JS_IsUndefined(separator))\n        goto add_tail;\n    if (s == 0) {\n        if (r != 0)\n            goto add_tail;\n        goto done;\n    }\n    q = p;\n    for (q = p; (q += !r) <= s - r - !r; q = p = e + r) {\n        e = string_indexof(sp, rp, q);\n        if (e < 0)\n            break;\n        T = js_sub_string(ctx, sp, p, e);\n        if (JS_IsException(T))\n            goto exception;\n        if (JS_CreateDataPropertyUint32(ctx, A, lengthA++, T, 0) < 0)\n            goto exception;\n        if (lengthA == lim)\n            goto done;\n    }\nadd_tail:\n    T = js_sub_string(ctx, sp, p, s);\n    if (JS_IsException(T))\n        goto exception;\n    if (JS_CreateDataPropertyUint32(ctx, A, lengthA++, T,0 ) < 0)\n        goto exception;\ndone:\n    JS_FreeValue(ctx, S);\n    JS_FreeValue(ctx, R);\n    return A;\n\nexception:\n    JS_FreeValue(ctx, A);\n    JS_FreeValue(ctx, S);\n    JS_FreeValue(ctx, R);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_string_substring(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    JSValue str, ret;\n    int a, b, start, end;\n    JSString *p;\n\n    str = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(str))\n        return str;\n    p = JS_VALUE_GET_STRING(str);\n    if (JS_ToInt32Clamp(ctx, &a, argv[0], 0, p->len, 0)) {\n        JS_FreeValue(ctx, str);\n        return JS_EXCEPTION;\n    }\n    b = p->len;\n    if (!JS_IsUndefined(argv[1])) {\n        if (JS_ToInt32Clamp(ctx, &b, argv[1], 0, p->len, 0)) {\n            JS_FreeValue(ctx, str);\n            return JS_EXCEPTION;\n        }\n    }\n    if (a < b) {\n        start = a;\n        end = b;\n    } else {\n        start = b;\n        end = a;\n    }\n    ret = js_sub_string(ctx, p, start, end);\n    JS_FreeValue(ctx, str);\n    return ret;\n}\n\nstatic JSValue js_string_substr(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    JSValue str, ret;\n    int a, len, n;\n    JSString *p;\n\n    str = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(str))\n        return str;\n    p = JS_VALUE_GET_STRING(str);\n    len = p->len;\n    if (JS_ToInt32Clamp(ctx, &a, argv[0], 0, len, len)) {\n        JS_FreeValue(ctx, str);\n        return JS_EXCEPTION;\n    }\n    n = len - a;\n    if (!JS_IsUndefined(argv[1])) {\n        if (JS_ToInt32Clamp(ctx, &n, argv[1], 0, len - a, 0)) {\n            JS_FreeValue(ctx, str);\n            return JS_EXCEPTION;\n        }\n    }\n    ret = js_sub_string(ctx, p, a, a + n);\n    JS_FreeValue(ctx, str);\n    return ret;\n}\n\nstatic JSValue js_string_slice(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    JSValue str, ret;\n    int len, start, end;\n    JSString *p;\n\n    str = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(str))\n        return str;\n    p = JS_VALUE_GET_STRING(str);\n    len = p->len;\n    if (JS_ToInt32Clamp(ctx, &start, argv[0], 0, len, len)) {\n        JS_FreeValue(ctx, str);\n        return JS_EXCEPTION;\n    }\n    end = len;\n    if (!JS_IsUndefined(argv[1])) {\n        if (JS_ToInt32Clamp(ctx, &end, argv[1], 0, len, len)) {\n            JS_FreeValue(ctx, str);\n            return JS_EXCEPTION;\n        }\n    }\n    ret = js_sub_string(ctx, p, start, max_int(end, start));\n    JS_FreeValue(ctx, str);\n    return ret;\n}\n\nstatic JSValue js_string_pad(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv, int padEnd)\n{\n    JSValue str, v = JS_UNDEFINED;\n    StringBuffer b_s, *b = &b_s;\n    JSString *p, *p1 = NULL;\n    int n, len, c = ' ';\n\n    str = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(str))\n        goto fail1;\n    if (JS_ToInt32Sat(ctx, &n, argv[0]))\n        goto fail2;\n    p = JS_VALUE_GET_STRING(str);\n    len = p->len;\n    if (len >= n)\n        return str;\n    if (argc > 1 && !JS_IsUndefined(argv[1])) {\n        v = JS_ToString(ctx, argv[1]);\n        if (JS_IsException(v))\n            goto fail2;\n        p1 = JS_VALUE_GET_STRING(v);\n        if (p1->len == 0) {\n            JS_FreeValue(ctx, v);\n            return str;\n        }\n        if (p1->len == 1) {\n            c = string_get(p1, 0);\n            p1 = NULL;\n        }\n    }\n    if (n > JS_STRING_LEN_MAX) {\n        JS_ThrowInternalError(ctx, \"string too long\");\n        goto fail2;\n    }\n    if (string_buffer_init(ctx, b, n))\n        goto fail3;\n    n -= len;\n    if (padEnd) {\n        if (string_buffer_concat(b, p, 0, len))\n            goto fail;\n    }\n    if (p1) {\n        while (n > 0) {\n            int chunk = min_int(n, p1->len);\n            if (string_buffer_concat(b, p1, 0, chunk))\n                goto fail;\n            n -= chunk;\n        }\n    } else {\n        if (string_buffer_fill(b, c, n))\n            goto fail;\n    }\n    if (!padEnd) {\n        if (string_buffer_concat(b, p, 0, len))\n            goto fail;\n    }\n    JS_FreeValue(ctx, v);\n    JS_FreeValue(ctx, str);\n    return string_buffer_end(b);\n\nfail:\n    string_buffer_free(b);\nfail3:\n    JS_FreeValue(ctx, v);\nfail2:\n    JS_FreeValue(ctx, str);\nfail1:\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_string_repeat(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    JSValue str;\n    StringBuffer b_s, *b = &b_s;\n    JSString *p;\n    int64_t val;\n    int n, len;\n\n    str = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(str))\n        goto fail;\n    if (JS_ToInt64Sat(ctx, &val, argv[0]))\n        goto fail;\n    if (val < 0 || val > 2147483647) {\n        JS_ThrowRangeError(ctx, \"invalid repeat count\");\n        goto fail;\n    }\n    n = val;\n    p = JS_VALUE_GET_STRING(str);\n    len = p->len;\n    if (len == 0 || n == 1)\n        return str;\n    if (val * len > JS_STRING_LEN_MAX) {\n        JS_ThrowInternalError(ctx, \"string too long\");\n        goto fail;\n    }\n    if (string_buffer_init2(ctx, b, n * len, p->is_wide_char))\n        goto fail;\n    if (len == 1) {\n        string_buffer_fill(b, string_get(p, 0), n);\n    } else {\n        while (n-- > 0) {\n            string_buffer_concat(b, p, 0, len);\n        }\n    }\n    JS_FreeValue(ctx, str);\n    return string_buffer_end(b);\n\nfail:\n    JS_FreeValue(ctx, str);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_string_trim(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv, int magic)\n{\n    JSValue str, ret;\n    int a, b, len;\n    JSString *p;\n\n    str = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(str))\n        return str;\n    p = JS_VALUE_GET_STRING(str);\n    a = 0;\n    b = len = p->len;\n    if (magic & 1) {\n        while (a < len && lre_is_space(string_get(p, a)))\n            a++;\n    }\n    if (magic & 2) {\n        while (b > a && lre_is_space(string_get(p, b - 1)))\n            b--;\n    }\n    ret = js_sub_string(ctx, p, a, b);\n    JS_FreeValue(ctx, str);\n    return ret;\n}\n\nstatic JSValue js_string___quote(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    return JS_ToQuotedString(ctx, this_val);\n}\n\n/* return 0 if before the first char */\nstatic int string_prevc(JSString *p, int *pidx)\n{\n    int idx, c, c1;\n\n    idx = *pidx;\n    if (idx <= 0)\n        return 0;\n    idx--;\n    if (p->is_wide_char) {\n        c = p->u.str16[idx];\n        if (c >= 0xdc00 && c < 0xe000 && idx > 0) {\n            c1 = p->u.str16[idx - 1];\n            if (c1 >= 0xd800 && c1 <= 0xdc00) {\n                c = (((c1 & 0x3ff) << 10) | (c & 0x3ff)) + 0x10000;\n                idx--;\n            }\n        }\n    } else {\n        c = p->u.str8[idx];\n    }\n    *pidx = idx;\n    return c;\n}\n\nstatic BOOL test_final_sigma(JSString *p, int sigma_pos)\n{\n    int k, c1;\n\n    /* before C: skip case ignorable chars and check there is\n       a cased letter */\n    k = sigma_pos;\n    for(;;) {\n        c1 = string_prevc(p, &k);\n        if (!lre_is_case_ignorable(c1))\n            break;\n    }\n    if (!lre_is_cased(c1))\n        return FALSE;\n\n    /* after C: skip case ignorable chars and check there is\n       no cased letter */\n    k = sigma_pos + 1;\n    for(;;) {\n        if (k >= p->len)\n            return TRUE;\n        c1 = string_getc(p, &k);\n        if (!lre_is_case_ignorable(c1))\n            break;\n    }\n    return !lre_is_cased(c1);\n}\n\nstatic JSValue js_string_localeCompare(JSContext *ctx, JSValueConst this_val,\n                                       int argc, JSValueConst *argv)\n{\n    JSValue a, b;\n    int cmp;\n\n    a = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(a))\n        return JS_EXCEPTION;\n    b = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(b)) {\n        JS_FreeValue(ctx, a);\n        return JS_EXCEPTION;\n    }\n    cmp = js_string_compare(ctx, JS_VALUE_GET_STRING(a), JS_VALUE_GET_STRING(b));\n    JS_FreeValue(ctx, a);\n    JS_FreeValue(ctx, b);\n    return JS_NewInt32(ctx, cmp);\n}\n\nstatic JSValue js_string_toLowerCase(JSContext *ctx, JSValueConst this_val,\n                                     int argc, JSValueConst *argv, int to_lower)\n{\n    JSValue val;\n    StringBuffer b_s, *b = &b_s;\n    JSString *p;\n    int i, c, j, l;\n    uint32_t res[LRE_CC_RES_LEN_MAX];\n\n    val = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    p = JS_VALUE_GET_STRING(val);\n    if (p->len == 0)\n        return val;\n    if (string_buffer_init(ctx, b, p->len))\n        goto fail;\n    for(i = 0; i < p->len;) {\n        c = string_getc(p, &i);\n        if (c == 0x3a3 && to_lower && test_final_sigma(p, i - 1)) {\n            res[0] = 0x3c2; /* final sigma */\n            l = 1;\n        } else {\n            l = lre_case_conv(res, c, to_lower);\n        }\n        for(j = 0; j < l; j++) {\n            if (string_buffer_putc(b, res[j]))\n                goto fail;\n        }\n    }\n    JS_FreeValue(ctx, val);\n    return string_buffer_end(b);\n fail:\n    JS_FreeValue(ctx, val);\n    string_buffer_free(b);\n    return JS_EXCEPTION;\n}\n\n#ifdef CONFIG_ALL_UNICODE\n\n/* return (-1, NULL) if exception, otherwise (len, buf) */\nstatic int JS_ToUTF32String(JSContext *ctx, uint32_t **pbuf, JSValueConst val1)\n{\n    JSValue val;\n    JSString *p;\n    uint32_t *buf;\n    int i, j, len;\n\n    val = JS_ToString(ctx, val1);\n    if (JS_IsException(val))\n        return -1;\n    p = JS_VALUE_GET_STRING(val);\n    len = p->len;\n    /* UTF32 buffer length is len minus the number of correct surrogates pairs */\n    buf = js_malloc(ctx, sizeof(buf[0]) * max_int(len, 1));\n    if (!buf) {\n        JS_FreeValue(ctx, val);\n        goto fail;\n    }\n    for(i = j = 0; i < len;)\n        buf[j++] = string_getc(p, &i);\n    JS_FreeValue(ctx, val);\n    *pbuf = buf;\n    return j;\n fail:\n    *pbuf = NULL;\n    return -1;\n}\n\nstatic JSValue JS_NewUTF32String(JSContext *ctx, const uint32_t *buf, int len)\n{\n    int i;\n    StringBuffer b_s, *b = &b_s;\n    if (string_buffer_init(ctx, b, len))\n        return JS_EXCEPTION;\n    for(i = 0; i < len; i++) {\n        if (string_buffer_putc(b, buf[i]))\n            goto fail;\n    }\n    return string_buffer_end(b);\n fail:\n    string_buffer_free(b);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_string_normalize(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    const char *form, *p;\n    size_t form_len;\n    int is_compat, buf_len, out_len;\n    UnicodeNormalizationEnum n_type;\n    JSValue val;\n    uint32_t *buf, *out_buf;\n\n    val = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    buf_len = JS_ToUTF32String(ctx, &buf, val);\n    JS_FreeValue(ctx, val);\n    if (buf_len < 0)\n        return JS_EXCEPTION;\n\n    if (argc == 0 || JS_IsUndefined(argv[0])) {\n        n_type = UNICODE_NFC;\n    } else {\n        form = JS_ToCStringLen(ctx, &form_len, argv[0]);\n        if (!form)\n            goto fail1;\n        p = form;\n        if (p[0] != 'N' || p[1] != 'F')\n            goto bad_form;\n        p += 2;\n        is_compat = FALSE;\n        if (*p == 'K') {\n            is_compat = TRUE;\n            p++;\n        }\n        if (*p == 'C' || *p == 'D') {\n            n_type = UNICODE_NFC + is_compat * 2 + (*p - 'C');\n            if ((p + 1 - form) != form_len)\n                goto bad_form;\n        } else {\n        bad_form:\n            JS_FreeCString(ctx, form);\n            JS_ThrowRangeError(ctx, \"bad normalization form\");\n        fail1:\n            js_free(ctx, buf);\n            return JS_EXCEPTION;\n        }\n        JS_FreeCString(ctx, form);\n    }\n\n    out_len = unicode_normalize(&out_buf, buf, buf_len, n_type,\n                                ctx->rt, (DynBufReallocFunc *)js_realloc_rt);\n    js_free(ctx, buf);\n    if (out_len < 0)\n        return JS_EXCEPTION;\n    val = JS_NewUTF32String(ctx, out_buf, out_len);\n    js_free(ctx, out_buf);\n    return val;\n}\n#endif /* CONFIG_ALL_UNICODE */\n\n/* also used for String.prototype.valueOf */\nstatic JSValue js_string_toString(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    return js_thisStringValue(ctx, this_val);\n}\n\n#if 0\nstatic JSValue js_string___toStringCheckObject(JSContext *ctx, JSValueConst this_val,\n                                               int argc, JSValueConst *argv)\n{\n    return JS_ToStringCheckObject(ctx, argv[0]);\n}\n\nstatic JSValue js_string___toString(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv)\n{\n    return JS_ToString(ctx, argv[0]);\n}\n\nstatic JSValue js_string___advanceStringIndex(JSContext *ctx, JSValueConst\n                                              this_val,\n                                              int argc, JSValueConst *argv)\n{\n    JSValue str;\n    int idx;\n    BOOL is_unicode;\n    JSString *p;\n\n    str = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(str))\n        return str;\n    if (JS_ToInt32Sat(ctx, &idx, argv[1])) {\n        JS_FreeValue(ctx, str);\n        return JS_EXCEPTION;\n    }\n    is_unicode = JS_ToBool(ctx, argv[2]);\n    p = JS_VALUE_GET_STRING(str);\n    if (!is_unicode || (unsigned)idx >= p->len || !p->is_wide_char) {\n        idx++;\n    } else {\n        string_getc(p, &idx);\n    }\n    JS_FreeValue(ctx, str);\n    return JS_NewInt32(ctx, idx);\n}\n#endif\n\n/* String Iterator */\n\nstatic JSValue js_string_iterator_next(JSContext *ctx, JSValueConst this_val,\n                                       int argc, JSValueConst *argv,\n                                       BOOL *pdone, int magic)\n{\n    JSArrayIteratorData *it;\n    uint32_t idx, c, start;\n    JSString *p;\n\n    it = JS_GetOpaque2(ctx, this_val, JS_CLASS_STRING_ITERATOR);\n    if (!it) {\n        *pdone = FALSE;\n        return JS_EXCEPTION;\n    }\n    if (JS_IsUndefined(it->obj))\n        goto done;\n    p = JS_VALUE_GET_STRING(it->obj);\n    idx = it->idx;\n    if (idx >= p->len) {\n        JS_FreeValue(ctx, it->obj);\n        it->obj = JS_UNDEFINED;\n    done:\n        *pdone = TRUE;\n        return JS_UNDEFINED;\n    }\n\n    start = idx;\n    c = string_getc(p, (int *)&idx);\n    it->idx = idx;\n    *pdone = FALSE;\n    if (c <= 0xffff) {\n        return js_new_string_char(ctx, c);\n    } else {\n        return js_new_string16(ctx, p->u.str16 + start, 2);\n    }\n}\n\n/* ES6 Annex B 2.3.2 etc. */\nenum {\n    magic_string_anchor,\n    magic_string_big,\n    magic_string_blink,\n    magic_string_bold,\n    magic_string_fixed,\n    magic_string_fontcolor,\n    magic_string_fontsize,\n    magic_string_italics,\n    magic_string_link,\n    magic_string_small,\n    magic_string_strike,\n    magic_string_sub,\n    magic_string_sup,\n};\n\nstatic JSValue js_string_CreateHTML(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv, int magic)\n{\n    JSValue str;\n    const JSString *p;\n    StringBuffer b_s, *b = &b_s;\n    static struct { const char *tag, *attr; } const defs[] = {\n        { \"a\", \"name\" }, { \"big\", NULL }, { \"blink\", NULL }, { \"b\", NULL },\n        { \"tt\", NULL }, { \"font\", \"color\" }, { \"font\", \"size\" }, { \"i\", NULL },\n        { \"a\", \"href\" }, { \"small\", NULL }, { \"strike\", NULL }, \n        { \"sub\", NULL }, { \"sup\", NULL },\n    };\n\n    str = JS_ToStringCheckObject(ctx, this_val);\n    if (JS_IsException(str))\n        return JS_EXCEPTION;\n    string_buffer_init(ctx, b, 7);\n    string_buffer_putc8(b, '<');\n    string_buffer_puts8(b, defs[magic].tag);\n    if (defs[magic].attr) {\n        // r += \" \" + attr + \"=\\\"\" + value + \"\\\"\";\n        JSValue value;\n        int i;\n\n        string_buffer_putc8(b, ' ');\n        string_buffer_puts8(b, defs[magic].attr);\n        string_buffer_puts8(b, \"=\\\"\");\n        value = JS_ToStringCheckObject(ctx, argv[0]);\n        if (JS_IsException(value)) {\n            JS_FreeValue(ctx, str);\n            string_buffer_free(b);\n            return JS_EXCEPTION;\n        }\n        p = JS_VALUE_GET_STRING(value);\n        for (i = 0; i < p->len; i++) {\n            int c = string_get(p, i);\n            if (c == '\"') {\n                string_buffer_puts8(b, \"&quot;\");\n            } else {\n                string_buffer_putc16(b, c);\n            }\n        }\n        JS_FreeValue(ctx, value);\n        string_buffer_putc8(b, '\\\"');\n    }\n    // return r + \">\" + str + \"</\" + tag + \">\";\n    string_buffer_putc8(b, '>');\n    string_buffer_concat_value_free(b, str);\n    string_buffer_puts8(b, \"</\");\n    string_buffer_puts8(b, defs[magic].tag);\n    string_buffer_putc8(b, '>');\n    return string_buffer_end(b);\n}\n\nstatic const JSCFunctionListEntry js_string_funcs[] = {\n    JS_CFUNC_DEF(\"fromCharCode\", 1, js_string_fromCharCode ),\n    JS_CFUNC_DEF(\"fromCodePoint\", 1, js_string_fromCodePoint ),\n    JS_CFUNC_DEF(\"raw\", 1, js_string_raw ),\n    //JS_CFUNC_DEF(\"__toString\", 1, js_string___toString ),\n    //JS_CFUNC_DEF(\"__isSpace\", 1, js_string___isSpace ),\n    //JS_CFUNC_DEF(\"__toStringCheckObject\", 1, js_string___toStringCheckObject ),\n    //JS_CFUNC_DEF(\"__advanceStringIndex\", 3, js_string___advanceStringIndex ),\n    //JS_CFUNC_DEF(\"__GetSubstitution\", 6, js_string___GetSubstitution ),\n};\n\nstatic const JSCFunctionListEntry js_string_proto_funcs[] = {\n    JS_PROP_INT32_DEF(\"length\", 0, JS_PROP_CONFIGURABLE ),\n    JS_CFUNC_DEF(\"charCodeAt\", 1, js_string_charCodeAt ),\n    JS_CFUNC_DEF(\"charAt\", 1, js_string_charAt ),\n    JS_CFUNC_DEF(\"concat\", 1, js_string_concat ),\n    JS_CFUNC_DEF(\"codePointAt\", 1, js_string_codePointAt ),\n    JS_CFUNC_MAGIC_DEF(\"indexOf\", 1, js_string_indexOf, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"lastIndexOf\", 1, js_string_indexOf, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"includes\", 1, js_string_includes, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"endsWith\", 1, js_string_includes, 2 ),\n    JS_CFUNC_MAGIC_DEF(\"startsWith\", 1, js_string_includes, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"match\", 1, js_string_match, JS_ATOM_Symbol_match ),\n    JS_CFUNC_MAGIC_DEF(\"matchAll\", 1, js_string_match, JS_ATOM_Symbol_matchAll ),\n    JS_CFUNC_MAGIC_DEF(\"search\", 1, js_string_match, JS_ATOM_Symbol_search ),\n    JS_CFUNC_DEF(\"split\", 2, js_string_split ),\n    JS_CFUNC_DEF(\"substring\", 2, js_string_substring ),\n    JS_CFUNC_DEF(\"substr\", 2, js_string_substr ),\n    JS_CFUNC_DEF(\"slice\", 2, js_string_slice ),\n    JS_CFUNC_DEF(\"repeat\", 1, js_string_repeat ),\n    JS_CFUNC_MAGIC_DEF(\"replace\", 2, js_string_replace, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"replaceAll\", 2, js_string_replace, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"padEnd\", 1, js_string_pad, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"padStart\", 1, js_string_pad, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"trim\", 0, js_string_trim, 3 ),\n    JS_CFUNC_MAGIC_DEF(\"trimEnd\", 0, js_string_trim, 2 ),\n    JS_ALIAS_DEF(\"trimRight\", \"trimEnd\" ),\n    JS_CFUNC_MAGIC_DEF(\"trimStart\", 0, js_string_trim, 1 ),\n    JS_ALIAS_DEF(\"trimLeft\", \"trimStart\" ),\n    JS_CFUNC_DEF(\"toString\", 0, js_string_toString ),\n    JS_CFUNC_DEF(\"valueOf\", 0, js_string_toString ),\n    JS_CFUNC_DEF(\"__quote\", 1, js_string___quote ),\n    JS_CFUNC_DEF(\"localeCompare\", 1, js_string_localeCompare ),\n    JS_CFUNC_MAGIC_DEF(\"toLowerCase\", 0, js_string_toLowerCase, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"toUpperCase\", 0, js_string_toLowerCase, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"toLocaleLowerCase\", 0, js_string_toLowerCase, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"toLocaleUpperCase\", 0, js_string_toLowerCase, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"[Symbol.iterator]\", 0, js_create_array_iterator, JS_ITERATOR_KIND_VALUE | 4 ),\n    /* ES6 Annex B 2.3.2 etc. */\n    JS_CFUNC_MAGIC_DEF(\"anchor\", 1, js_string_CreateHTML, magic_string_anchor ),\n    JS_CFUNC_MAGIC_DEF(\"big\", 0, js_string_CreateHTML, magic_string_big ),\n    JS_CFUNC_MAGIC_DEF(\"blink\", 0, js_string_CreateHTML, magic_string_blink ),\n    JS_CFUNC_MAGIC_DEF(\"bold\", 0, js_string_CreateHTML, magic_string_bold ),\n    JS_CFUNC_MAGIC_DEF(\"fixed\", 0, js_string_CreateHTML, magic_string_fixed ),\n    JS_CFUNC_MAGIC_DEF(\"fontcolor\", 1, js_string_CreateHTML, magic_string_fontcolor ),\n    JS_CFUNC_MAGIC_DEF(\"fontsize\", 1, js_string_CreateHTML, magic_string_fontsize ),\n    JS_CFUNC_MAGIC_DEF(\"italics\", 0, js_string_CreateHTML, magic_string_italics ),\n    JS_CFUNC_MAGIC_DEF(\"link\", 1, js_string_CreateHTML, magic_string_link ),\n    JS_CFUNC_MAGIC_DEF(\"small\", 0, js_string_CreateHTML, magic_string_small ),\n    JS_CFUNC_MAGIC_DEF(\"strike\", 0, js_string_CreateHTML, magic_string_strike ),\n    JS_CFUNC_MAGIC_DEF(\"sub\", 0, js_string_CreateHTML, magic_string_sub ),\n    JS_CFUNC_MAGIC_DEF(\"sup\", 0, js_string_CreateHTML, magic_string_sup ),\n};\n\nstatic const JSCFunctionListEntry js_string_iterator_proto_funcs[] = {\n    JS_ITERATOR_NEXT_DEF(\"next\", 0, js_string_iterator_next, 0 ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"String Iterator\", JS_PROP_CONFIGURABLE ),\n};\n\n#ifdef CONFIG_ALL_UNICODE\nstatic const JSCFunctionListEntry js_string_proto_normalize[] = {\n    JS_CFUNC_DEF(\"normalize\", 0, js_string_normalize ),\n};\n#endif\n\nvoid JS_AddIntrinsicStringNormalize(JSContext *ctx)\n{\n#ifdef CONFIG_ALL_UNICODE\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_STRING], js_string_proto_normalize,\n                               countof(js_string_proto_normalize));\n#endif\n}\n\n/* Math */\n\n/* precondition: a and b are not NaN */\nstatic double js_fmin(double a, double b)\n{\n    if (a == 0 && b == 0) {\n        JSFloat64Union a1, b1;\n        a1.d = a;\n        b1.d = b;\n        a1.u64 |= b1.u64;\n        return a1.d;\n    } else {\n        return fmin(a, b);\n    }\n}\n\n/* precondition: a and b are not NaN */\nstatic double js_fmax(double a, double b)\n{\n    if (a == 0 && b == 0) {\n        JSFloat64Union a1, b1;\n        a1.d = a;\n        b1.d = b;\n        a1.u64 &= b1.u64;\n        return a1.d;\n    } else {\n        return fmax(a, b);\n    }\n}\n\nstatic JSValue js_math_min_max(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv, int magic)\n{\n    BOOL is_max = magic;\n    double r, a;\n    int i;\n    uint32_t tag;\n\n    if (unlikely(argc == 0)) {\n        return __JS_NewFloat64(ctx, is_max ? -1.0 / 0.0 : 1.0 / 0.0);\n    }\n\n    tag = JS_VALUE_GET_TAG(argv[0]);\n    if (tag == JS_TAG_INT) {\n        int a1, r1 = JS_VALUE_GET_INT(argv[0]);\n        for(i = 1; i < argc; i++) {\n            tag = JS_VALUE_GET_TAG(argv[i]);\n            if (tag != JS_TAG_INT) {\n                r = r1;\n                goto generic_case;\n            }\n            a1 = JS_VALUE_GET_INT(argv[i]);\n            if (is_max)\n                r1 = max_int(r1, a1);\n            else\n                r1 = min_int(r1, a1);\n\n        }\n        return JS_NewInt32(ctx, r1);\n    } else {\n        if (JS_ToFloat64(ctx, &r, argv[0]))\n            return JS_EXCEPTION;\n        i = 1;\n    generic_case:\n        while (i < argc) {\n            if (JS_ToFloat64(ctx, &a, argv[i]))\n                return JS_EXCEPTION;\n            if (!isnan(r)) {\n                if (isnan(a)) {\n                    r = a;\n                } else {\n                    if (is_max)\n                        r = js_fmax(r, a);\n                    else\n                        r = js_fmin(r, a);\n                }\n            }\n            i++;\n        }\n        return JS_NewFloat64(ctx, r);\n    }\n}\n\nstatic double js_math_sign(double a)\n{\n    if (isnan(a) || a == 0.0)\n        return a;\n    if (a < 0)\n        return -1;\n    else\n        return 1;\n}\n\nstatic double js_math_round(double a)\n{\n    JSFloat64Union u;\n    uint64_t frac_mask, one;\n    unsigned int e, s;\n\n    u.d = a;\n    e = (u.u64 >> 52) & 0x7ff;\n    if (e < 1023) {\n        /* abs(a) < 1 */\n        if (e == (1023 - 1) && u.u64 != 0xbfe0000000000000) {\n            /* abs(a) > 0.5 or a = 0.5: return +/-1.0 */\n            u.u64 = (u.u64 & ((uint64_t)1 << 63)) | ((uint64_t)1023 << 52);\n        } else {\n            /* return +/-0.0 */\n            u.u64 &= (uint64_t)1 << 63;\n        }\n    } else if (e < (1023 + 52)) {\n        s = u.u64 >> 63;\n        one = (uint64_t)1 << (52 - (e - 1023));\n        frac_mask = one - 1;\n        u.u64 += (one >> 1) - s;\n        u.u64 &= ~frac_mask; /* truncate to an integer */\n    }\n    /* otherwise: abs(a) >= 2^52, or NaN, +/-Infinity: no change */\n    return u.d;\n}\n\nstatic JSValue js_math_hypot(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    double r, a;\n    int i;\n\n    r = 0;\n    if (argc > 0) {\n        if (JS_ToFloat64(ctx, &r, argv[0]))\n            return JS_EXCEPTION;\n        if (argc == 1) {\n            r = fabs(r);\n        } else {\n            /* use the built-in function to minimize precision loss */\n            for (i = 1; i < argc; i++) {\n                if (JS_ToFloat64(ctx, &a, argv[i]))\n                    return JS_EXCEPTION;\n                r = hypot(r, a);\n            }\n        }\n    }\n    return JS_NewFloat64(ctx, r);\n}\n\nstatic double js_math_fround(double a)\n{\n    return (float)a;\n}\n\nstatic JSValue js_math_imul(JSContext *ctx, JSValueConst this_val,\n                            int argc, JSValueConst *argv)\n{\n    int a, b;\n\n    if (JS_ToInt32(ctx, &a, argv[0]))\n        return JS_EXCEPTION;\n    if (JS_ToInt32(ctx, &b, argv[1]))\n        return JS_EXCEPTION;\n    /* purposely ignoring overflow */\n    return JS_NewInt32(ctx, a * b);\n}\n\nstatic JSValue js_math_clz32(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    uint32_t a, r;\n\n    if (JS_ToUint32(ctx, &a, argv[0]))\n        return JS_EXCEPTION;\n    if (a == 0)\n        r = 32;\n    else\n        r = clz32(a);\n    return JS_NewInt32(ctx, r);\n}\n\n/* xorshift* random number generator by Marsaglia */\nstatic uint64_t xorshift64star(uint64_t *pstate)\n{\n    uint64_t x;\n    x = *pstate;\n    x ^= x >> 12;\n    x ^= x << 25;\n    x ^= x >> 27;\n    *pstate = x;\n    return x * 0x2545F4914F6CDD1D;\n}\n\nstatic void js_random_init(JSContext *ctx)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    ctx->random_state = ((int64_t)tv.tv_sec * 1000000) + tv.tv_usec;\n    /* the state must be non zero */\n    if (ctx->random_state == 0)\n        ctx->random_state = 1;\n}\n\nstatic JSValue js_math_random(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv)\n{\n    JSFloat64Union u;\n    uint64_t v;\n\n    v = xorshift64star(&ctx->random_state);\n    /* 1.0 <= u.d < 2 */\n    u.u64 = ((uint64_t)0x3ff << 52) | (v >> 12);\n    return __JS_NewFloat64(ctx, u.d - 1.0);\n}\n\nstatic const JSCFunctionListEntry js_math_funcs[] = {\n    JS_CFUNC_MAGIC_DEF(\"min\", 2, js_math_min_max, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"max\", 2, js_math_min_max, 1 ),\n    JS_CFUNC_SPECIAL_DEF(\"abs\", 1, f_f, fabs ),\n    JS_CFUNC_SPECIAL_DEF(\"floor\", 1, f_f, floor ),\n    JS_CFUNC_SPECIAL_DEF(\"ceil\", 1, f_f, ceil ),\n    JS_CFUNC_SPECIAL_DEF(\"round\", 1, f_f, js_math_round ),\n    JS_CFUNC_SPECIAL_DEF(\"sqrt\", 1, f_f, sqrt ),\n\n    JS_CFUNC_SPECIAL_DEF(\"acos\", 1, f_f, acos ),\n    JS_CFUNC_SPECIAL_DEF(\"asin\", 1, f_f, asin ),\n    JS_CFUNC_SPECIAL_DEF(\"atan\", 1, f_f, atan ),\n    JS_CFUNC_SPECIAL_DEF(\"atan2\", 2, f_f_f, atan2 ),\n    JS_CFUNC_SPECIAL_DEF(\"cos\", 1, f_f, cos ),\n    JS_CFUNC_SPECIAL_DEF(\"exp\", 1, f_f, exp ),\n    JS_CFUNC_SPECIAL_DEF(\"log\", 1, f_f, log ),\n    JS_CFUNC_SPECIAL_DEF(\"pow\", 2, f_f_f, js_pow ),\n    JS_CFUNC_SPECIAL_DEF(\"sin\", 1, f_f, sin ),\n    JS_CFUNC_SPECIAL_DEF(\"tan\", 1, f_f, tan ),\n    /* ES6 */\n    JS_CFUNC_SPECIAL_DEF(\"trunc\", 1, f_f, trunc ),\n    JS_CFUNC_SPECIAL_DEF(\"sign\", 1, f_f, js_math_sign ),\n    JS_CFUNC_SPECIAL_DEF(\"cosh\", 1, f_f, cosh ),\n    JS_CFUNC_SPECIAL_DEF(\"sinh\", 1, f_f, sinh ),\n    JS_CFUNC_SPECIAL_DEF(\"tanh\", 1, f_f, tanh ),\n    JS_CFUNC_SPECIAL_DEF(\"acosh\", 1, f_f, acosh ),\n    JS_CFUNC_SPECIAL_DEF(\"asinh\", 1, f_f, asinh ),\n    JS_CFUNC_SPECIAL_DEF(\"atanh\", 1, f_f, atanh ),\n    JS_CFUNC_SPECIAL_DEF(\"expm1\", 1, f_f, expm1 ),\n    JS_CFUNC_SPECIAL_DEF(\"log1p\", 1, f_f, log1p ),\n    JS_CFUNC_SPECIAL_DEF(\"log2\", 1, f_f, log2 ),\n    JS_CFUNC_SPECIAL_DEF(\"log10\", 1, f_f, log10 ),\n    JS_CFUNC_SPECIAL_DEF(\"cbrt\", 1, f_f, cbrt ),\n    JS_CFUNC_DEF(\"hypot\", 2, js_math_hypot ),\n    JS_CFUNC_DEF(\"random\", 0, js_math_random ),\n    JS_CFUNC_SPECIAL_DEF(\"fround\", 1, f_f, js_math_fround ),\n    JS_CFUNC_DEF(\"imul\", 2, js_math_imul ),\n    JS_CFUNC_DEF(\"clz32\", 1, js_math_clz32 ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"Math\", JS_PROP_CONFIGURABLE ),\n    JS_PROP_DOUBLE_DEF(\"E\", 2.718281828459045, 0 ),\n    JS_PROP_DOUBLE_DEF(\"LN10\", 2.302585092994046, 0 ),\n    JS_PROP_DOUBLE_DEF(\"LN2\", 0.6931471805599453, 0 ),\n    JS_PROP_DOUBLE_DEF(\"LOG2E\", 1.4426950408889634, 0 ),\n    JS_PROP_DOUBLE_DEF(\"LOG10E\", 0.4342944819032518, 0 ),\n    JS_PROP_DOUBLE_DEF(\"PI\", 3.141592653589793, 0 ),\n    JS_PROP_DOUBLE_DEF(\"SQRT1_2\", 0.7071067811865476, 0 ),\n    JS_PROP_DOUBLE_DEF(\"SQRT2\", 1.4142135623730951, 0 ),\n};\n\nstatic const JSCFunctionListEntry js_math_obj[] = {\n    JS_OBJECT_DEF(\"Math\", js_math_funcs, countof(js_math_funcs), JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE ),\n};\n\n/* Date */\n\n#if 0\n/* OS dependent: return the UTC time in ms since 1970. */\nstatic JSValue js___date_now(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    int64_t d;\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    d = (int64_t)tv.tv_sec * 1000 + (tv.tv_usec / 1000);\n    return JS_NewInt64(ctx, d);\n}\n#endif\n\n/* OS dependent: return the UTC time in microseconds since 1970. */\nstatic JSValue js___date_clock(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    int64_t d;\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    d = (int64_t)tv.tv_sec * 1000000 + tv.tv_usec;\n    return JS_NewInt64(ctx, d);\n}\n\n/* OS dependent. d = argv[0] is in ms from 1970. Return the difference\n   between UTC time and local time 'd' in minutes */\nstatic int getTimezoneOffset(int64_t time) {\n#if defined(_WIN32)\n    /* XXX: TODO */\n    return 0;\n#else\n    time_t ti;\n    struct tm tm;\n\n    time /= 1000; /* convert to seconds */\n    if (sizeof(time_t) == 4) {\n        /* on 32-bit systems, we need to clamp the time value to the\n           range of `time_t`. This is better than truncating values to\n           32 bits and hopefully provides the same result as 64-bit\n           implementation of localtime_r.\n         */\n        if ((time_t)-1 < 0) {\n            if (time < INT32_MIN) {\n                time = INT32_MIN;\n            } else if (time > INT32_MAX) {\n                time = INT32_MAX;\n            }\n        } else {\n            if (time < 0) {\n                time = 0;\n            } else if (time > UINT32_MAX) {\n                time = UINT32_MAX;\n            }\n        }\n    }\n    ti = time;\n    localtime_r(&ti, &tm);\n    return -tm.tm_gmtoff / 60;\n#endif\n}\n\n#if 0\nstatic JSValue js___date_getTimezoneOffset(JSContext *ctx, JSValueConst this_val,\n                                           int argc, JSValueConst *argv)\n{\n    double dd;\n\n    if (JS_ToFloat64(ctx, &dd, argv[0]))\n        return JS_EXCEPTION;\n    if (isnan(dd))\n        return __JS_NewFloat64(ctx, dd);\n    else\n        return JS_NewInt32(ctx, getTimezoneOffset((int64_t)dd));\n}\n\nstatic JSValue js_get_prototype_from_ctor(JSContext *ctx, JSValueConst ctor,\n                                          JSValueConst def_proto)\n{\n    JSValue proto;\n    proto = JS_GetProperty(ctx, ctor, JS_ATOM_prototype);\n    if (JS_IsException(proto))\n        return proto;\n    if (!JS_IsObject(proto)) {\n        JS_FreeValue(ctx, proto);\n        proto = JS_DupValue(ctx, def_proto);\n    }\n    return proto;\n}\n\n/* create a new date object */\nstatic JSValue js___date_create(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    JSValue obj, proto;\n    proto = js_get_prototype_from_ctor(ctx, argv[0], argv[1]);\n    if (JS_IsException(proto))\n        return proto;\n    obj = JS_NewObjectProtoClass(ctx, proto, JS_CLASS_DATE);\n    JS_FreeValue(ctx, proto);\n    if (!JS_IsException(obj))\n        JS_SetObjectData(ctx, obj, JS_DupValue(ctx, argv[2]));\n    return obj;\n}\n#endif\n\n/* RegExp */\n\nstatic void js_regexp_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSRegExp *re = &p->u.regexp;\n    JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_STRING, re->bytecode));\n    JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_STRING, re->pattern));\n}\n\n/* create a string containing the RegExp bytecode */\nstatic JSValue js_compile_regexp(JSContext *ctx, JSValueConst pattern,\n                                 JSValueConst flags)\n{\n    const char *str;\n    int re_flags, mask;\n    uint8_t *re_bytecode_buf;\n    size_t i, len;\n    int re_bytecode_len;\n    JSValue ret;\n    char error_msg[64];\n\n    re_flags = 0;\n    if (!JS_IsUndefined(flags)) {\n        str = JS_ToCStringLen(ctx, &len, flags);\n        if (!str)\n            return JS_EXCEPTION;\n        /* XXX: re_flags = LRE_FLAG_OCTAL unless strict mode? */\n        for (i = 0; i < len; i++) {\n            switch(str[i]) {\n            case 'g':\n                mask = LRE_FLAG_GLOBAL;\n                break;\n            case 'i':\n                mask = LRE_FLAG_IGNORECASE;\n                break;\n            case 'm':\n                mask = LRE_FLAG_MULTILINE;\n                break;\n            case 's':\n                mask = LRE_FLAG_DOTALL;\n                break;\n            case 'u':\n                mask = LRE_FLAG_UTF16;\n                break;\n            case 'y':\n                mask = LRE_FLAG_STICKY;\n                break;\n            default:\n                goto bad_flags;\n            }\n            if ((re_flags & mask) != 0) {\n            bad_flags:\n                JS_FreeCString(ctx, str);\n                return JS_ThrowSyntaxError(ctx, \"invalid regular expression flags\");\n            }\n            re_flags |= mask;\n        }\n        JS_FreeCString(ctx, str);\n    }\n\n    str = JS_ToCStringLen2(ctx, &len, pattern, !(re_flags & LRE_FLAG_UTF16));\n    if (!str)\n        return JS_EXCEPTION;\n    re_bytecode_buf = lre_compile(&re_bytecode_len, error_msg,\n                                  sizeof(error_msg), str, len, re_flags, ctx);\n    JS_FreeCString(ctx, str);\n    if (!re_bytecode_buf) {\n        JS_ThrowSyntaxError(ctx, \"%s\", error_msg);\n        return JS_EXCEPTION;\n    }\n\n    ret = js_new_string8(ctx, re_bytecode_buf, re_bytecode_len);\n    js_free(ctx, re_bytecode_buf);\n    return ret;\n}\n\n/* create a RegExp object from a string containing the RegExp bytecode\n   and the source pattern */\nstatic JSValue js_regexp_constructor_internal(JSContext *ctx, JSValueConst ctor,\n                                              JSValue pattern, JSValue bc)\n{\n    JSValue obj;\n    JSObject *p;\n    JSRegExp *re;\n\n    /* sanity check */\n    if (JS_VALUE_GET_TAG(bc) != JS_TAG_STRING ||\n        JS_VALUE_GET_TAG(pattern) != JS_TAG_STRING) {\n        JS_ThrowTypeError(ctx, \"string expected\");\n    fail:\n        JS_FreeValue(ctx, bc);\n        JS_FreeValue(ctx, pattern);\n        return JS_EXCEPTION;\n    }\n\n    obj = js_create_from_ctor(ctx, ctor, JS_CLASS_REGEXP);\n    if (JS_IsException(obj))\n        goto fail;\n    p = JS_VALUE_GET_OBJ(obj);\n    re = &p->u.regexp;\n    re->pattern = JS_VALUE_GET_STRING(pattern);\n    re->bytecode = JS_VALUE_GET_STRING(bc);\n    JS_DefinePropertyValue(ctx, obj, JS_ATOM_lastIndex, JS_NewInt32(ctx, 0),\n                           JS_PROP_WRITABLE);\n    return obj;\n}\n\nstatic JSRegExp *js_get_regexp(JSContext *ctx, JSValueConst obj, BOOL throw_error)\n{\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(obj);\n        if (p->class_id == JS_CLASS_REGEXP)\n            return &p->u.regexp;\n    }\n    if (throw_error) {\n        JS_ThrowTypeErrorInvalidClass(ctx, JS_CLASS_REGEXP);\n    }\n    return NULL;\n}\n\n/* return < 0 if exception or TRUE/FALSE */\nstatic int js_is_regexp(JSContext *ctx, JSValueConst obj)\n{\n    JSValue m;\n\n    if (!JS_IsObject(obj))\n        return FALSE;\n    m = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_match);\n    if (JS_IsException(m))\n        return -1;\n    if (!JS_IsUndefined(m))\n        return JS_ToBoolFree(ctx, m);\n    return js_get_regexp(ctx, obj, FALSE) != NULL;\n}\n\nstatic JSValue js_regexp_constructor(JSContext *ctx, JSValueConst new_target,\n                                     int argc, JSValueConst *argv)\n{\n    JSValue pattern, flags, bc, val;\n    JSValueConst pat, flags1;\n    JSRegExp *re;\n    int pat_is_regexp;\n\n    pat = argv[0];\n    flags1 = argv[1];\n    pat_is_regexp = js_is_regexp(ctx, pat);\n    if (pat_is_regexp < 0)\n        return JS_EXCEPTION;\n    if (JS_IsUndefined(new_target)) {\n        /* called as a function */\n        new_target = JS_GetActiveFunction(ctx);\n        if (pat_is_regexp && JS_IsUndefined(flags1)) {\n            JSValue ctor;\n            BOOL res;\n            ctor = JS_GetProperty(ctx, pat, JS_ATOM_constructor);\n            if (JS_IsException(ctor))\n                return ctor;\n            res = js_same_value(ctx, ctor, new_target);\n            JS_FreeValue(ctx, ctor);\n            if (res)\n                return JS_DupValue(ctx, pat);\n        }\n    }\n    re = js_get_regexp(ctx, pat, FALSE);\n    if (re) {\n        pattern = JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, re->pattern));\n        if (JS_IsUndefined(flags1)) {\n            bc = JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, re->bytecode));\n            goto no_compilation;\n        } else {\n            flags = JS_ToString(ctx, flags1);\n            if (JS_IsException(flags))\n                goto fail;\n        }\n    } else {\n        flags = JS_UNDEFINED;\n        if (pat_is_regexp) {\n            pattern = JS_GetProperty(ctx, pat, JS_ATOM_source);\n            if (JS_IsException(pattern))\n                goto fail;\n            if (JS_IsUndefined(flags1)) {\n                flags = JS_GetProperty(ctx, pat, JS_ATOM_flags);\n                if (JS_IsException(flags))\n                    goto fail;\n            } else {\n                flags = JS_DupValue(ctx, flags1);\n            }\n        } else {\n            pattern = JS_DupValue(ctx, pat);\n            flags = JS_DupValue(ctx, flags1);\n        }\n        if (JS_IsUndefined(pattern)) {\n            pattern = JS_AtomToString(ctx, JS_ATOM_empty_string);\n        } else {\n            val = pattern;\n            pattern = JS_ToString(ctx, val);\n            JS_FreeValue(ctx, val);\n            if (JS_IsException(pattern))\n                goto fail;\n        }\n    }\n    bc = js_compile_regexp(ctx, pattern, flags);\n    if (JS_IsException(bc))\n        goto fail;\n    JS_FreeValue(ctx, flags);\n no_compilation:\n    return js_regexp_constructor_internal(ctx, new_target, pattern, bc);\n fail:\n    JS_FreeValue(ctx, pattern);\n    JS_FreeValue(ctx, flags);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_regexp_compile(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    JSRegExp *re1, *re;\n    JSValueConst pattern1, flags1;\n    JSValue bc, pattern;\n\n    re = js_get_regexp(ctx, this_val, TRUE);\n    if (!re)\n        return JS_EXCEPTION;\n    pattern1 = argv[0];\n    flags1 = argv[1];\n    re1 = js_get_regexp(ctx, pattern1, FALSE);\n    if (re1) {\n        if (!JS_IsUndefined(flags1))\n            return JS_ThrowTypeError(ctx, \"flags must be undefined\");\n        pattern = JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, re1->pattern));\n        bc = JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, re1->bytecode));\n    } else {\n        bc = JS_UNDEFINED;\n        if (JS_IsUndefined(pattern1))\n            pattern = JS_AtomToString(ctx, JS_ATOM_empty_string);\n        else\n            pattern = JS_ToString(ctx, pattern1);\n        if (JS_IsException(pattern))\n            goto fail;\n        bc = js_compile_regexp(ctx, pattern, flags1);\n        if (JS_IsException(bc))\n            goto fail;\n    }\n    JS_FreeValue(ctx, JS_MKPTR(JS_TAG_STRING, re->pattern));\n    JS_FreeValue(ctx, JS_MKPTR(JS_TAG_STRING, re->bytecode));\n    re->pattern = JS_VALUE_GET_STRING(pattern);\n    re->bytecode = JS_VALUE_GET_STRING(bc);\n    if (JS_SetProperty(ctx, this_val, JS_ATOM_lastIndex,\n                       JS_NewInt32(ctx, 0)) < 0)\n        return JS_EXCEPTION;\n    return JS_DupValue(ctx, this_val);\n fail:\n    JS_FreeValue(ctx, pattern);\n    JS_FreeValue(ctx, bc);\n    return JS_EXCEPTION;\n}\n\n#if 0\nstatic JSValue js_regexp_get___source(JSContext *ctx, JSValueConst this_val)\n{\n    JSRegExp *re = js_get_regexp(ctx, this_val, TRUE);\n    if (!re)\n        return JS_EXCEPTION;\n    return JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, re->pattern));\n}\n\nstatic JSValue js_regexp_get___flags(JSContext *ctx, JSValueConst this_val)\n{\n    JSRegExp *re = js_get_regexp(ctx, this_val, TRUE);\n    int flags;\n\n    if (!re)\n        return JS_EXCEPTION;\n    flags = lre_get_flags(re->bytecode->u.str8);\n    return JS_NewInt32(ctx, flags);\n}\n#endif\n\nstatic JSValue js_regexp_get_source(JSContext *ctx, JSValueConst this_val)\n{\n    JSRegExp *re;\n    JSString *p;\n    StringBuffer b_s, *b = &b_s;\n    int i, n, c, c2, bra;\n\n    if (JS_VALUE_GET_TAG(this_val) != JS_TAG_OBJECT)\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n\n    if (js_same_value(ctx, this_val, ctx->class_proto[JS_CLASS_REGEXP]))\n        goto empty_regex;\n\n    re = js_get_regexp(ctx, this_val, TRUE);\n    if (!re)\n        return JS_EXCEPTION;\n\n    p = re->pattern;\n\n    if (p->len == 0) {\n    empty_regex:\n        return JS_NewString(ctx, \"(?:)\");\n    }    \n    string_buffer_init2(ctx, b, p->len, p->is_wide_char);\n\n    /* Escape '/' and newline sequences as needed */\n    bra = 0;\n    for (i = 0, n = p->len; i < n;) {\n        c2 = -1;\n        switch (c = string_get(p, i++)) {\n        case '\\\\':\n            if (i < n)\n                c2 = string_get(p, i++);\n            break;\n        case ']':\n            bra = 0;\n            break;\n        case '[':\n            if (!bra) {\n                if (i < n && string_get(p, i) == ']')\n                    c2 = string_get(p, i++);\n                bra = 1;\n            }\n            break;\n        case '\\n':\n            c = '\\\\';\n            c2 = 'n';\n            break;\n        case '\\r':\n            c = '\\\\';\n            c2 = 'r';\n            break;\n        case '/':\n            if (!bra) {\n                c = '\\\\';\n                c2 = '/';\n            }\n            break;\n        }\n        string_buffer_putc16(b, c);\n        if (c2 >= 0)\n            string_buffer_putc16(b, c2);\n    }\n    return string_buffer_end(b);\n}\n\nstatic JSValue js_regexp_get_flag(JSContext *ctx, JSValueConst this_val, int mask)\n{\n    JSRegExp *re;\n    int flags;\n\n    if (JS_VALUE_GET_TAG(this_val) != JS_TAG_OBJECT)\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n\n    re = js_get_regexp(ctx, this_val, FALSE);\n    if (!re) {\n        if (js_same_value(ctx, this_val, ctx->class_proto[JS_CLASS_REGEXP]))\n            return JS_UNDEFINED;\n        else\n            return JS_ThrowTypeErrorInvalidClass(ctx, JS_CLASS_REGEXP);\n    }\n    \n    flags = lre_get_flags(re->bytecode->u.str8);\n    return JS_NewBool(ctx, (flags & mask) != 0);\n}\n\nstatic JSValue js_regexp_get_flags(JSContext *ctx, JSValueConst this_val)\n{\n    char str[8], *p = str;\n    int res;\n\n    if (JS_VALUE_GET_TAG(this_val) != JS_TAG_OBJECT)\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n\n    res = JS_ToBoolFree(ctx, JS_GetProperty(ctx, this_val, JS_ATOM_global));\n    if (res < 0)\n        goto exception;\n    if (res)\n        *p++ = 'g';\n    res = JS_ToBoolFree(ctx, JS_GetPropertyStr(ctx, this_val, \"ignoreCase\"));\n    if (res < 0)\n        goto exception;\n    if (res)\n        *p++ = 'i';\n    res = JS_ToBoolFree(ctx, JS_GetPropertyStr(ctx, this_val, \"multiline\"));\n    if (res < 0)\n        goto exception;\n    if (res)\n        *p++ = 'm';\n    res = JS_ToBoolFree(ctx, JS_GetPropertyStr(ctx, this_val, \"dotAll\"));\n    if (res < 0)\n        goto exception;\n    if (res)\n        *p++ = 's';\n    res = JS_ToBoolFree(ctx, JS_GetProperty(ctx, this_val, JS_ATOM_unicode));\n    if (res < 0)\n        goto exception;\n    if (res)\n        *p++ = 'u';\n    res = JS_ToBoolFree(ctx, JS_GetPropertyStr(ctx, this_val, \"sticky\"));\n    if (res < 0)\n        goto exception;\n    if (res)\n        *p++ = 'y';\n    return JS_NewStringLen(ctx, str, p - str);\n\nexception:\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_regexp_toString(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    JSValue pattern, flags;\n    StringBuffer b_s, *b = &b_s;\n\n    if (!JS_IsObject(this_val))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n\n    string_buffer_init(ctx, b, 0);\n    string_buffer_putc8(b, '/');\n    pattern = JS_GetProperty(ctx, this_val, JS_ATOM_source);\n    if (string_buffer_concat_value_free(b, pattern))\n        goto fail;\n    string_buffer_putc8(b, '/');\n    flags = JS_GetProperty(ctx, this_val, JS_ATOM_flags);\n    if (string_buffer_concat_value_free(b, flags))\n        goto fail;\n    return string_buffer_end(b);\n\nfail:\n    string_buffer_free(b);\n    return JS_EXCEPTION;\n}\n\nBOOL lre_check_stack_overflow(void *opaque, size_t alloca_size)\n{\n    JSContext *ctx = opaque;\n    return js_check_stack_overflow(ctx->rt, alloca_size);\n}\n\nvoid *lre_realloc(void *opaque, void *ptr, size_t size)\n{\n    JSContext *ctx = opaque;\n    /* No JS exception is raised here */\n    return js_realloc_rt(ctx->rt, ptr, size);\n}\n\nstatic JSValue js_regexp_exec(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv)\n{\n    JSRegExp *re = js_get_regexp(ctx, this_val, TRUE);\n    JSString *str;\n    JSValue str_val, obj, val, groups = JS_UNDEFINED;\n    uint8_t *re_bytecode;\n    int ret;\n    uint8_t **capture, *str_buf;\n    int capture_count, shift, i, re_flags;\n    int64_t last_index;\n    const char *group_name_ptr;\n\n    if (!re)\n        return JS_EXCEPTION;\n    str_val = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(str_val))\n        return str_val;\n    val = JS_GetProperty(ctx, this_val, JS_ATOM_lastIndex);\n    if (JS_IsException(val) ||\n        JS_ToLengthFree(ctx, &last_index, val)) {\n        JS_FreeValue(ctx, str_val);\n        return JS_EXCEPTION;\n    }\n    re_bytecode = re->bytecode->u.str8;\n    re_flags = lre_get_flags(re_bytecode);\n    if ((re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY)) == 0) {\n        last_index = 0;\n    }\n    str = JS_VALUE_GET_STRING(str_val);\n    capture_count = lre_get_capture_count(re_bytecode);\n    capture = NULL;\n    if (capture_count > 0) {\n        capture = js_malloc(ctx, sizeof(capture[0]) * capture_count * 2);\n        if (!capture) {\n            JS_FreeValue(ctx, str_val);\n            return JS_EXCEPTION;\n        }\n    }\n    shift = str->is_wide_char;\n    str_buf = str->u.str8;\n    if (last_index > str->len) {\n        ret = 2;\n    } else {\n        ret = lre_exec(capture, re_bytecode,\n                       str_buf, last_index, str->len,\n                       shift, ctx);\n    }\n    obj = JS_NULL;\n    if (ret != 1) {\n        if (ret >= 0) {\n            if (ret == 2 || (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY))) {\n                if (JS_SetProperty(ctx, this_val, JS_ATOM_lastIndex,\n                                   JS_NewInt32(ctx, 0)) < 0)\n                    goto fail;\n            }\n        } else {\n            JS_ThrowInternalError(ctx, \"out of memory in regexp execution\");\n            goto fail;\n        }\n        JS_FreeValue(ctx, str_val);\n    } else {\n        int prop_flags;\n        if (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY)) {\n            if (JS_SetProperty(ctx, this_val, JS_ATOM_lastIndex,\n                               JS_NewInt32(ctx, (capture[1] - str_buf) >> shift)) < 0)\n                goto fail;\n        }\n        obj = JS_NewArray(ctx);\n        if (JS_IsException(obj))\n            goto fail;\n        prop_flags = JS_PROP_C_W_E | JS_PROP_THROW;\n        group_name_ptr = lre_get_groupnames(re_bytecode);\n        if (group_name_ptr) {\n            groups = JS_NewObjectProto(ctx, JS_NULL);\n            if (JS_IsException(groups))\n                goto fail;\n        }\n\n        for(i = 0; i < capture_count; i++) {\n            int start, end;\n            JSValue val;\n            if (capture[2 * i] == NULL ||\n                capture[2 * i + 1] == NULL) {\n                val = JS_UNDEFINED;\n            } else {\n                start = (capture[2 * i] - str_buf) >> shift;\n                end = (capture[2 * i + 1] - str_buf) >> shift;\n                val = js_sub_string(ctx, str, start, end);\n                if (JS_IsException(val))\n                    goto fail;\n            }\n            if (group_name_ptr && i > 0) {\n                if (*group_name_ptr) {\n                    if (JS_DefinePropertyValueStr(ctx, groups, group_name_ptr,\n                                                  JS_DupValue(ctx, val),\n                                                  prop_flags) < 0) {\n                        JS_FreeValue(ctx, val);\n                        goto fail;\n                    }\n                }\n                group_name_ptr += strlen(group_name_ptr) + 1;\n            }\n            if (JS_DefinePropertyValueUint32(ctx, obj, i, val, prop_flags) < 0)\n                goto fail;\n        }\n        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_groups,\n                                   groups, prop_flags) < 0)\n            goto fail;\n        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_index,\n                                   JS_NewInt32(ctx, (capture[0] - str_buf) >> shift), prop_flags) < 0)\n            goto fail;\n        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_input, str_val, prop_flags) < 0)\n            goto fail1;\n    }\n    js_free(ctx, capture);\n    return obj;\nfail:\n    JS_FreeValue(ctx, groups);\n    JS_FreeValue(ctx, str_val);\nfail1:\n    JS_FreeValue(ctx, obj);\n    js_free(ctx, capture);\n    return JS_EXCEPTION;\n}\n\n/* delete portions of a string that match a given regex */\nstatic JSValue JS_RegExpDelete(JSContext *ctx, JSValueConst this_val, JSValueConst arg)\n{\n    JSRegExp *re = js_get_regexp(ctx, this_val, TRUE);\n    JSString *str;\n    JSValue str_val, val;\n    uint8_t *re_bytecode;\n    int ret;\n    uint8_t **capture, *str_buf;\n    int capture_count, shift, re_flags;\n    int next_src_pos, start, end;\n    int64_t last_index;\n    StringBuffer b_s, *b = &b_s;\n\n    if (!re)\n        return JS_EXCEPTION;\n\n    string_buffer_init(ctx, b, 0);\n\n    capture = NULL;\n    str_val = JS_ToString(ctx, arg);\n    if (JS_IsException(str_val))\n        goto fail;\n    str = JS_VALUE_GET_STRING(str_val);\n    re_bytecode = re->bytecode->u.str8;\n    re_flags = lre_get_flags(re_bytecode);\n    if ((re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY)) == 0) {\n        last_index = 0;\n    } else {\n        val = JS_GetProperty(ctx, this_val, JS_ATOM_lastIndex);\n        if (JS_IsException(val) || JS_ToLengthFree(ctx, &last_index, val))\n            goto fail;\n    }\n    capture_count = lre_get_capture_count(re_bytecode);\n    if (capture_count > 0) {\n        capture = js_malloc(ctx, sizeof(capture[0]) * capture_count * 2);\n        if (!capture)\n            goto fail;\n    }\n    shift = str->is_wide_char;\n    str_buf = str->u.str8;\n    next_src_pos = 0;\n    for (;;) {\n        if (last_index > str->len)\n            break;\n\n        ret = lre_exec(capture, re_bytecode,\n                       str_buf, last_index, str->len, shift, ctx);\n        if (ret != 1) {\n            if (ret >= 0) {\n                if (ret == 2 || (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY))) {\n                    if (JS_SetProperty(ctx, this_val, JS_ATOM_lastIndex,\n                                       JS_NewInt32(ctx, 0)) < 0)\n                        goto fail;\n                }\n            } else {\n                JS_ThrowInternalError(ctx, \"out of memory in regexp execution\");\n                goto fail;\n            }\n            break;\n        }\n        start = (capture[0] - str_buf) >> shift;\n        end = (capture[1] - str_buf) >> shift;\n        last_index = end;\n        if (next_src_pos < start) {\n            if (string_buffer_concat(b, str, next_src_pos, start))\n                goto fail;\n        }\n        next_src_pos = end;\n        if (!(re_flags & LRE_FLAG_GLOBAL)) {\n            if (JS_SetProperty(ctx, this_val, JS_ATOM_lastIndex,\n                               JS_NewInt32(ctx, end)) < 0)\n                goto fail;\n            break;\n        }\n        if (end == start) {\n            if (!(re_flags & LRE_FLAG_UTF16) || (unsigned)end >= str->len || !str->is_wide_char) {\n                end++;\n            } else {\n                string_getc(str, &end);\n            }\n        }\n        last_index = end;\n    }\n    if (string_buffer_concat(b, str, next_src_pos, str->len))\n        goto fail;\n    JS_FreeValue(ctx, str_val);\n    js_free(ctx, capture);\n    return string_buffer_end(b);\nfail:\n    JS_FreeValue(ctx, str_val);\n    js_free(ctx, capture);\n    string_buffer_free(b);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_RegExpExec(JSContext *ctx, JSValueConst r, JSValueConst s)\n{\n    JSValue method, ret;\n\n    method = JS_GetProperty(ctx, r, JS_ATOM_exec);\n    if (JS_IsException(method))\n        return method;\n    if (JS_IsFunction(ctx, method)) {\n        ret = JS_CallFree(ctx, method, r, 1, &s);\n        if (JS_IsException(ret))\n            return ret;\n        if (!JS_IsObject(ret) && !JS_IsNull(ret)) {\n            JS_FreeValue(ctx, ret);\n            return JS_ThrowTypeError(ctx, \"RegExp exec method must return an object or null\");\n        }\n        return ret;\n    }\n    JS_FreeValue(ctx, method);\n    return js_regexp_exec(ctx, r, 1, &s);\n}\n\n#if 0\nstatic JSValue js_regexp___RegExpExec(JSContext *ctx, JSValueConst this_val,\n                                      int argc, JSValueConst *argv)\n{\n    return JS_RegExpExec(ctx, argv[0], argv[1]);\n}\nstatic JSValue js_regexp___RegExpDelete(JSContext *ctx, JSValueConst this_val,\n                                        int argc, JSValueConst *argv)\n{\n    return JS_RegExpDelete(ctx, argv[0], argv[1]);\n}\n#endif\n\nstatic JSValue js_regexp_test(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv)\n{\n    JSValue val;\n    BOOL ret;\n\n    val = JS_RegExpExec(ctx, this_val, argv[0]);\n    if (JS_IsException(val))\n        return JS_EXCEPTION;\n    ret = !JS_IsNull(val);\n    JS_FreeValue(ctx, val);\n    return JS_NewBool(ctx, ret);\n}\n\nstatic JSValue js_regexp_Symbol_match(JSContext *ctx, JSValueConst this_val,\n                                      int argc, JSValueConst *argv)\n{\n    // [Symbol.match](str)\n    JSValueConst rx = this_val;\n    JSValue A, S, result, matchStr;\n    int global, n, fullUnicode, isEmpty;\n    JSString *p;\n\n    if (!JS_IsObject(rx))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n\n    A = JS_UNDEFINED;\n    result = JS_UNDEFINED;\n    matchStr = JS_UNDEFINED;\n    S = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(S))\n        goto exception;\n\n    global = JS_ToBoolFree(ctx, JS_GetProperty(ctx, rx, JS_ATOM_global));\n    if (global < 0)\n        goto exception;\n\n    if (!global) {\n        A = JS_RegExpExec(ctx, rx, S);\n    } else {\n        fullUnicode = JS_ToBoolFree(ctx, JS_GetProperty(ctx, rx, JS_ATOM_unicode));\n        if (fullUnicode < 0)\n            goto exception;\n\n        if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, JS_NewInt32(ctx, 0)) < 0)\n            goto exception;\n        A = JS_NewArray(ctx);\n        if (JS_IsException(A))\n            goto exception;\n        n = 0;\n        for(;;) {\n            JS_FreeValue(ctx, result);\n            result = JS_RegExpExec(ctx, rx, S);\n            if (JS_IsException(result))\n                goto exception;\n            if (JS_IsNull(result))\n                break;\n            matchStr = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, result, 0));\n            if (JS_IsException(matchStr))\n                goto exception;\n            isEmpty = JS_IsEmptyString(matchStr);\n            if (JS_SetPropertyInt64(ctx, A, n++, matchStr) < 0)\n                goto exception;\n            if (isEmpty) {\n                int64_t thisIndex, nextIndex;\n                if (JS_ToLengthFree(ctx, &thisIndex,\n                                    JS_GetProperty(ctx, rx, JS_ATOM_lastIndex)) < 0)\n                    goto exception;\n                p = JS_VALUE_GET_STRING(S);\n                nextIndex = string_advance_index(p, thisIndex, fullUnicode);\n                if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, JS_NewInt64(ctx, nextIndex)) < 0)\n                    goto exception;\n            }\n        }\n        if (n == 0) {\n            JS_FreeValue(ctx, A);\n            A = JS_NULL;\n        }\n    }\n    JS_FreeValue(ctx, result);\n    JS_FreeValue(ctx, S);\n    return A;\n\nexception:\n    JS_FreeValue(ctx, A);\n    JS_FreeValue(ctx, result);\n    JS_FreeValue(ctx, S);\n    return JS_EXCEPTION;\n}\n\ntypedef struct JSRegExpStringIteratorData {\n    JSValue iterating_regexp;\n    JSValue iterated_string;\n    BOOL global;\n    BOOL unicode;\n    BOOL done;\n} JSRegExpStringIteratorData;\n\nstatic void js_regexp_string_iterator_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSRegExpStringIteratorData *it = p->u.regexp_string_iterator_data;\n    if (it) {\n        JS_FreeValueRT(rt, it->iterating_regexp);\n        JS_FreeValueRT(rt, it->iterated_string);\n        js_free_rt(rt, it);\n    }\n}\n\nstatic void js_regexp_string_iterator_mark(JSRuntime *rt, JSValueConst val,\n                                           JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSRegExpStringIteratorData *it = p->u.regexp_string_iterator_data;\n    if (it) {\n        JS_MarkValue(rt, it->iterating_regexp, mark_func);\n        JS_MarkValue(rt, it->iterated_string, mark_func);\n    }\n}\n\nstatic JSValue js_regexp_string_iterator_next(JSContext *ctx,\n                                              JSValueConst this_val,\n                                              int argc, JSValueConst *argv,\n                                              BOOL *pdone, int magic)\n{\n    JSRegExpStringIteratorData *it;\n    JSValueConst R, S;\n    JSValue matchStr = JS_UNDEFINED, match = JS_UNDEFINED;\n    JSString *sp;\n\n    it = JS_GetOpaque2(ctx, this_val, JS_CLASS_REGEXP_STRING_ITERATOR);\n    if (!it)\n        goto exception;\n    if (it->done) {\n        *pdone = TRUE;\n        return JS_UNDEFINED;\n    }\n    R = it->iterating_regexp;\n    S = it->iterated_string;\n    match = JS_RegExpExec(ctx, R, S);\n    if (JS_IsException(match))\n        goto exception;\n    if (JS_IsNull(match)) {\n        it->done = TRUE;\n        *pdone = TRUE;\n        return JS_UNDEFINED;\n    } else if (it->global) {\n        matchStr = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, match, 0));\n        if (JS_IsException(matchStr))\n            goto exception;\n        if (JS_IsEmptyString(matchStr)) {\n            int64_t thisIndex, nextIndex;\n            if (JS_ToLengthFree(ctx, &thisIndex,\n                                JS_GetProperty(ctx, R, JS_ATOM_lastIndex)) < 0)\n                goto exception;\n            sp = JS_VALUE_GET_STRING(S);\n            nextIndex = string_advance_index(sp, thisIndex, it->unicode);\n            if (JS_SetProperty(ctx, R, JS_ATOM_lastIndex,\n                               JS_NewInt64(ctx, nextIndex)) < 0)\n                goto exception;\n        }\n        JS_FreeValue(ctx, matchStr);\n    } else {\n        it->done = TRUE;\n    }\n    *pdone = FALSE;\n    return match;\n exception:\n    JS_FreeValue(ctx, match);\n    JS_FreeValue(ctx, matchStr);\n    *pdone = FALSE;\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_regexp_Symbol_matchAll(JSContext *ctx, JSValueConst this_val,\n                                         int argc, JSValueConst *argv)\n{\n    // [Symbol.matchAll](str)\n    JSValueConst R = this_val;\n    JSValue S, C, flags, matcher, iter;\n    JSValueConst args[2];\n    JSString *strp;\n    int64_t lastIndex;\n    JSRegExpStringIteratorData *it;\n    \n    if (!JS_IsObject(R))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n\n    C = JS_UNDEFINED;\n    flags = JS_UNDEFINED;\n    matcher = JS_UNDEFINED;\n    iter = JS_UNDEFINED;\n    \n    S = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(S))\n        goto exception;\n    C = JS_SpeciesConstructor(ctx, R, ctx->regexp_ctor);\n    if (JS_IsException(C))\n        goto exception;\n    flags = JS_ToStringFree(ctx, JS_GetProperty(ctx, R, JS_ATOM_flags));\n    if (JS_IsException(flags))\n        goto exception;\n    args[0] = R;\n    args[1] = flags;\n    matcher = JS_CallConstructor(ctx, C, 2, args);\n    if (JS_IsException(matcher))\n        goto exception;\n    if (JS_ToLengthFree(ctx, &lastIndex,\n                        JS_GetProperty(ctx, R, JS_ATOM_lastIndex)))\n        goto exception;\n    if (JS_SetProperty(ctx, matcher, JS_ATOM_lastIndex,\n                       JS_NewInt64(ctx, lastIndex)) < 0)\n        goto exception;\n    \n    iter = JS_NewObjectClass(ctx, JS_CLASS_REGEXP_STRING_ITERATOR);\n    if (JS_IsException(iter))\n        goto exception;\n    it = js_malloc(ctx, sizeof(*it));\n    if (!it)\n        goto exception;\n    it->iterating_regexp = matcher;\n    it->iterated_string = S;\n    strp = JS_VALUE_GET_STRING(flags);\n    it->global = string_indexof_char(strp, 'g', 0) >= 0;\n    it->unicode = string_indexof_char(strp, 'u', 0) >= 0;\n    it->done = FALSE;\n    JS_SetOpaque(iter, it);\n\n    JS_FreeValue(ctx, C);\n    JS_FreeValue(ctx, flags);\n    return iter;\n exception:\n    JS_FreeValue(ctx, S);\n    JS_FreeValue(ctx, C);\n    JS_FreeValue(ctx, flags);\n    JS_FreeValue(ctx, matcher);\n    JS_FreeValue(ctx, iter);\n    return JS_EXCEPTION;\n}\n\ntypedef struct ValueBuffer {\n    JSContext *ctx;\n    JSValue *arr;\n    JSValue def[4];\n    int len;\n    int size;\n    int error_status;\n} ValueBuffer;\n\nstatic int value_buffer_init(JSContext *ctx, ValueBuffer *b)\n{\n    b->ctx = ctx;\n    b->len = 0;\n    b->size = 4;\n    b->error_status = 0;\n    b->arr = b->def;\n    return 0;\n}\n\nstatic void value_buffer_free(ValueBuffer *b)\n{\n    while (b->len > 0)\n        JS_FreeValue(b->ctx, b->arr[--b->len]);\n    if (b->arr != b->def)\n        js_free(b->ctx, b->arr);\n    b->arr = b->def;\n    b->size = 4;\n}\n\nstatic int value_buffer_append(ValueBuffer *b, JSValue val)\n{\n    if (b->error_status)\n        return -1;\n\n    if (b->len >= b->size) {\n        int new_size = (b->len + (b->len >> 1) + 31) & ~16;\n        size_t slack;\n        JSValue *new_arr;\n\n        if (b->arr == b->def) {\n            new_arr = js_realloc2(b->ctx, NULL, sizeof(*b->arr) * new_size, &slack);\n            if (new_arr)\n                memcpy(new_arr, b->def, sizeof b->def);\n        } else {\n            new_arr = js_realloc2(b->ctx, b->arr, sizeof(*b->arr) * new_size, &slack);\n        }\n        if (!new_arr) {\n            value_buffer_free(b);\n            JS_FreeValue(b->ctx, val);\n            b->error_status = -1;\n            return -1;\n        }\n        new_size += slack / sizeof(*new_arr);\n        b->arr = new_arr;\n        b->size = new_size;\n    }\n    b->arr[b->len++] = val;\n    return 0;\n}\n\nstatic int js_is_standard_regexp(JSContext *ctx, JSValueConst rx)\n{\n    JSValue val;\n    int res;\n\n    val = JS_GetProperty(ctx, rx, JS_ATOM_constructor);\n    if (JS_IsException(val))\n        return -1;\n    // rx.constructor === RegExp\n    res = js_same_value(ctx, val, ctx->regexp_ctor);\n    JS_FreeValue(ctx, val);\n    if (res) {\n        val = JS_GetProperty(ctx, rx, JS_ATOM_exec);\n        if (JS_IsException(val))\n            return -1;\n        // rx.exec === RE_exec\n        res = JS_IsCFunction(ctx, val, js_regexp_exec, 0);\n        JS_FreeValue(ctx, val);\n    }\n    return res;\n}\n\nstatic JSValue js_regexp_Symbol_replace(JSContext *ctx, JSValueConst this_val,\n                                        int argc, JSValueConst *argv)\n{\n    // [Symbol.replace](str, rep)\n    JSValueConst rx = this_val, rep = argv[1];\n    JSValueConst args[6];\n    JSValue str, rep_val, matched, tab, rep_str, namedCaptures, res;\n    JSString *sp, *rp;\n    StringBuffer b_s, *b = &b_s;\n    ValueBuffer v_b, *results = &v_b;\n    int nextSourcePosition, n, j, functionalReplace, is_global, fullUnicode;\n    uint32_t nCaptures;\n    int64_t position;\n\n    if (!JS_IsObject(rx))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n\n    string_buffer_init(ctx, b, 0);\n    value_buffer_init(ctx, results);\n\n    rep_val = JS_UNDEFINED;\n    matched = JS_UNDEFINED;\n    tab = JS_UNDEFINED;\n    rep_str = JS_UNDEFINED;\n    namedCaptures = JS_UNDEFINED;\n\n    str = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(str))\n        goto exception;\n        \n    sp = JS_VALUE_GET_STRING(str);\n    rp = NULL;\n    functionalReplace = JS_IsFunction(ctx, rep);\n    if (!functionalReplace) {\n        rep_val = JS_ToString(ctx, rep);\n        if (JS_IsException(rep_val))\n            goto exception;\n        rp = JS_VALUE_GET_STRING(rep_val);\n    }\n    fullUnicode = 0;\n    is_global = JS_ToBoolFree(ctx, JS_GetProperty(ctx, rx, JS_ATOM_global));\n    if (is_global < 0)\n        goto exception;\n    if (is_global) {\n        fullUnicode = JS_ToBoolFree(ctx, JS_GetProperty(ctx, rx, JS_ATOM_unicode));\n        if (fullUnicode < 0)\n            goto exception;\n        if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, JS_NewInt32(ctx, 0)) < 0)\n            goto exception;\n    }\n\n    if (rp && rp->len == 0 && is_global && js_is_standard_regexp(ctx, rx)) {\n        /* use faster version for simple cases */\n        res = JS_RegExpDelete(ctx, rx, str);\n        goto done;\n    }\n    for(;;) {\n        JSValue result;\n        result = JS_RegExpExec(ctx, rx, str);\n        if (JS_IsException(result))\n            goto exception;\n        if (JS_IsNull(result))\n            break;\n        if (value_buffer_append(results, result) < 0)\n            goto exception;\n        if (!is_global)\n            break;\n        JS_FreeValue(ctx, matched);\n        matched = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, result, 0));\n        if (JS_IsException(matched))\n            goto exception;\n        if (JS_IsEmptyString(matched)) {\n            /* always advance of at least one char */\n            int64_t thisIndex, nextIndex;\n            if (JS_ToLengthFree(ctx, &thisIndex, JS_GetProperty(ctx, rx, JS_ATOM_lastIndex)) < 0)\n                goto exception;\n            nextIndex = string_advance_index(sp, thisIndex, fullUnicode);\n            if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, JS_NewInt64(ctx, nextIndex)) < 0)\n                goto exception;\n        }\n    }\n    nextSourcePosition = 0;\n    for(j = 0; j < results->len; j++) {\n        JSValueConst result;\n        result = results->arr[j];\n        if (js_get_length32(ctx, &nCaptures, result) < 0)\n            goto exception;\n        JS_FreeValue(ctx, matched);\n        matched = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, result, 0));\n        if (JS_IsException(matched))\n            goto exception;\n        if (JS_ToLengthFree(ctx, &position, JS_GetProperty(ctx, result, JS_ATOM_index)))\n            goto exception;\n        if (position > sp->len)\n            position = sp->len;\n        else if (position < 0)\n            position = 0;\n        /* ignore substition if going backward (can happen\n           with custom regexp object) */\n        JS_FreeValue(ctx, tab);\n        tab = JS_NewArray(ctx);\n        if (JS_IsException(tab))\n            goto exception;\n        if (JS_DefinePropertyValueInt64(ctx, tab, 0, JS_DupValue(ctx, matched),\n                                        JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n            goto exception;\n        for(n = 1; n < nCaptures; n++) {\n            JSValue capN;\n            capN = JS_GetPropertyInt64(ctx, result, n);\n            if (JS_IsException(capN))\n                goto exception;\n            if (!JS_IsUndefined(capN)) {\n                capN = JS_ToStringFree(ctx, capN);\n                if (JS_IsException(capN))\n                    goto exception;\n            }\n            if (JS_DefinePropertyValueInt64(ctx, tab, n, capN,\n                                            JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n                goto exception;\n        }\n        JS_FreeValue(ctx, namedCaptures);\n        namedCaptures = JS_GetProperty(ctx, result, JS_ATOM_groups);\n        if (JS_IsException(namedCaptures))\n            goto exception;\n        if (functionalReplace) {\n            if (JS_DefinePropertyValueInt64(ctx, tab, n++, JS_NewInt32(ctx, position), JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n                goto exception;\n            if (JS_DefinePropertyValueInt64(ctx, tab, n++, JS_DupValue(ctx, str), JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n                goto exception;\n            if (!JS_IsUndefined(namedCaptures)) {\n                if (JS_DefinePropertyValueInt64(ctx, tab, n++, JS_DupValue(ctx, namedCaptures), JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n                    goto exception;\n            }\n            args[0] = JS_UNDEFINED;\n            args[1] = tab;\n            JS_FreeValue(ctx, rep_str);\n            rep_str = JS_ToStringFree(ctx, js_function_apply(ctx, rep, 2, args, 0));\n        } else {\n            JSValue namedCaptures1;\n            if (!JS_IsUndefined(namedCaptures)) {\n                namedCaptures1 = JS_ToObject(ctx, namedCaptures);\n                if (JS_IsException(namedCaptures1))\n                    goto exception;\n            } else {\n                namedCaptures1 = JS_UNDEFINED;\n            }\n            args[0] = matched;\n            args[1] = str;\n            args[2] = JS_NewInt32(ctx, position);\n            args[3] = tab;\n            args[4] = namedCaptures1;\n            args[5] = rep_val;\n            JS_FreeValue(ctx, rep_str);\n            rep_str = js_string___GetSubstitution(ctx, JS_UNDEFINED, 6, args);\n            JS_FreeValue(ctx, namedCaptures1);\n        }\n        if (JS_IsException(rep_str))\n            goto exception;\n        if (position >= nextSourcePosition) {\n            string_buffer_concat(b, sp, nextSourcePosition, position);\n            string_buffer_concat_value(b, rep_str);\n            nextSourcePosition = position + JS_VALUE_GET_STRING(matched)->len;\n        }\n    }\n    string_buffer_concat(b, sp, nextSourcePosition, sp->len);\n    res = string_buffer_end(b);\n    goto done1;\n\nexception:\n    res = JS_EXCEPTION;\ndone:\n    string_buffer_free(b);\ndone1:\n    value_buffer_free(results);\n    JS_FreeValue(ctx, rep_val);\n    JS_FreeValue(ctx, matched);\n    JS_FreeValue(ctx, tab);\n    JS_FreeValue(ctx, rep_str);\n    JS_FreeValue(ctx, namedCaptures);\n    JS_FreeValue(ctx, str);\n    return res;\n}\n\nstatic JSValue js_regexp_Symbol_search(JSContext *ctx, JSValueConst this_val,\n                                       int argc, JSValueConst *argv)\n{\n    JSValueConst rx = this_val;\n    JSValue str, previousLastIndex, currentLastIndex, result, index;\n\n    if (!JS_IsObject(rx))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n\n    result = JS_UNDEFINED;\n    currentLastIndex = JS_UNDEFINED;\n    previousLastIndex = JS_UNDEFINED;\n    str = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(str))\n        goto exception;\n\n    previousLastIndex = JS_GetProperty(ctx, rx, JS_ATOM_lastIndex);\n    if (JS_IsException(previousLastIndex))\n        goto exception;\n\n    if (!js_same_value(ctx, previousLastIndex, JS_NewInt32(ctx, 0))) {\n        if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, JS_NewInt32(ctx, 0)) < 0) {\n            goto exception;\n        }\n    }\n    result = JS_RegExpExec(ctx, rx, str);\n    if (JS_IsException(result))\n        goto exception;\n    currentLastIndex = JS_GetProperty(ctx, rx, JS_ATOM_lastIndex);\n    if (JS_IsException(currentLastIndex))\n        goto exception;\n    if (js_same_value(ctx, currentLastIndex, previousLastIndex)) {\n        JS_FreeValue(ctx, previousLastIndex);\n    } else {\n        if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, previousLastIndex) < 0) {\n            previousLastIndex = JS_UNDEFINED;\n            goto exception;\n        }\n    }\n    JS_FreeValue(ctx, str);\n    JS_FreeValue(ctx, currentLastIndex);\n\n    if (JS_IsNull(result)) {\n        return JS_NewInt32(ctx, -1);\n    } else {\n        index = JS_GetProperty(ctx, result, JS_ATOM_index);\n        JS_FreeValue(ctx, result);\n        return index;\n    }\n\nexception:\n    JS_FreeValue(ctx, result);\n    JS_FreeValue(ctx, str);\n    JS_FreeValue(ctx, currentLastIndex);\n    JS_FreeValue(ctx, previousLastIndex);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_regexp_Symbol_split(JSContext *ctx, JSValueConst this_val,\n                                       int argc, JSValueConst *argv)\n{\n    // [Symbol.split](str, limit)\n    JSValueConst rx = this_val;\n    JSValueConst args[2];\n    JSValue str, ctor, splitter, A, flags, z, sub;\n    JSString *strp;\n    uint32_t lim, size, p, q;\n    int unicodeMatching;\n    int64_t lengthA, e, numberOfCaptures, i;\n\n    if (!JS_IsObject(rx))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n\n    ctor = JS_UNDEFINED;\n    splitter = JS_UNDEFINED;\n    A = JS_UNDEFINED;\n    flags = JS_UNDEFINED;\n    z = JS_UNDEFINED;\n    str = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(str))\n        goto exception;\n    ctor = JS_SpeciesConstructor(ctx, rx, ctx->regexp_ctor);\n    if (JS_IsException(ctor))\n        goto exception;\n    flags = JS_ToStringFree(ctx, JS_GetProperty(ctx, rx, JS_ATOM_flags));\n    if (JS_IsException(flags))\n        goto exception;\n    strp = JS_VALUE_GET_STRING(flags);\n    unicodeMatching = string_indexof_char(strp, 'u', 0) >= 0;\n    if (string_indexof_char(strp, 'y', 0) < 0) {\n        flags = JS_ConcatString3(ctx, \"\", flags, \"y\");\n        if (JS_IsException(flags))\n            goto exception;\n    }\n    args[0] = rx;\n    args[1] = flags;\n    splitter = JS_CallConstructor(ctx, ctor, 2, args);\n    if (JS_IsException(splitter))\n        goto exception;\n    A = JS_NewArray(ctx);\n    if (JS_IsException(A))\n        goto exception;\n    lengthA = 0;\n    if (JS_IsUndefined(argv[1])) {\n        lim = 0xffffffff;\n    } else {\n        if (JS_ToUint32(ctx, &lim, argv[1]) < 0)\n            goto exception;\n        if (lim == 0)\n            goto done;\n    }\n    strp = JS_VALUE_GET_STRING(str);\n    p = q = 0;\n    size = strp->len;\n    if (size == 0) {\n        z = JS_RegExpExec(ctx, splitter, str);\n        if (JS_IsException(z))\n            goto exception;\n        if (JS_IsNull(z))\n            goto add_tail;\n        goto done;\n    }\n    while (q < size) {\n        if (JS_SetProperty(ctx, splitter, JS_ATOM_lastIndex, JS_NewInt32(ctx, q)) < 0)\n            goto exception;\n        JS_FreeValue(ctx, z);    \n        z = JS_RegExpExec(ctx, splitter, str);\n        if (JS_IsException(z))\n            goto exception;\n        if (JS_IsNull(z)) {\n            q = string_advance_index(strp, q, unicodeMatching);\n        } else {\n            if (JS_ToLengthFree(ctx, &e, JS_GetProperty(ctx, splitter, JS_ATOM_lastIndex)))\n                goto exception;\n            if (e > size)\n                e = size;\n            if (e == p) {\n                q = string_advance_index(strp, q, unicodeMatching);\n            } else {\n                sub = js_sub_string(ctx, strp, p, q);\n                if (JS_IsException(sub))\n                    goto exception;\n                if (JS_DefinePropertyValueInt64(ctx, A, lengthA++, sub,\n                                                JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n                    goto exception;\n                if (lengthA == lim)\n                    goto done;\n                p = e;\n                if (js_get_length64(ctx, &numberOfCaptures, z))\n                    goto exception;\n                for(i = 1; i < numberOfCaptures; i++) {\n                    sub = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, z, i));\n                    if (JS_IsException(sub))\n                        goto exception;\n                    if (JS_DefinePropertyValueInt64(ctx, A, lengthA++, sub, JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n                        goto exception;\n                    if (lengthA == lim)\n                        goto done;\n                }\n                q = p;\n            }\n        }\n    }\nadd_tail:\n    if (p > size)\n        p = size;\n    sub = js_sub_string(ctx, strp, p, size);\n    if (JS_IsException(sub))\n        goto exception;\n    if (JS_DefinePropertyValueInt64(ctx, A, lengthA++, sub, JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n        goto exception;\n    goto done;\nexception:\n    JS_FreeValue(ctx, A);\n    A = JS_EXCEPTION;\ndone:\n    JS_FreeValue(ctx, str);\n    JS_FreeValue(ctx, ctor);\n    JS_FreeValue(ctx, splitter);\n    JS_FreeValue(ctx, flags);\n    JS_FreeValue(ctx, z);    \n    return A;\n}\n\nstatic const JSCFunctionListEntry js_regexp_funcs[] = {\n    JS_CGETSET_DEF(\"[Symbol.species]\", js_get_this, NULL ),\n    //JS_CFUNC_DEF(\"__RegExpExec\", 2, js_regexp___RegExpExec ),\n    //JS_CFUNC_DEF(\"__RegExpDelete\", 2, js_regexp___RegExpDelete ),\n};\n\nstatic const JSCFunctionListEntry js_regexp_proto_funcs[] = {\n    JS_CGETSET_DEF(\"flags\", js_regexp_get_flags, NULL ),\n    JS_CGETSET_DEF(\"source\", js_regexp_get_source, NULL ),\n    JS_CGETSET_MAGIC_DEF(\"global\", js_regexp_get_flag, NULL, 1 ),\n    JS_CGETSET_MAGIC_DEF(\"ignoreCase\", js_regexp_get_flag, NULL, 2 ),\n    JS_CGETSET_MAGIC_DEF(\"multiline\", js_regexp_get_flag, NULL, 4 ),\n    JS_CGETSET_MAGIC_DEF(\"dotAll\", js_regexp_get_flag, NULL, 8 ),\n    JS_CGETSET_MAGIC_DEF(\"unicode\", js_regexp_get_flag, NULL, 16 ),\n    JS_CGETSET_MAGIC_DEF(\"sticky\", js_regexp_get_flag, NULL, 32 ),\n    JS_CFUNC_DEF(\"exec\", 1, js_regexp_exec ),\n    JS_CFUNC_DEF(\"compile\", 2, js_regexp_compile ),\n    JS_CFUNC_DEF(\"test\", 1, js_regexp_test ),\n    JS_CFUNC_DEF(\"toString\", 0, js_regexp_toString ),\n    JS_CFUNC_DEF(\"[Symbol.replace]\", 2, js_regexp_Symbol_replace ),\n    JS_CFUNC_DEF(\"[Symbol.match]\", 1, js_regexp_Symbol_match ),\n    JS_CFUNC_DEF(\"[Symbol.matchAll]\", 1, js_regexp_Symbol_matchAll ),\n    JS_CFUNC_DEF(\"[Symbol.search]\", 1, js_regexp_Symbol_search ),\n    JS_CFUNC_DEF(\"[Symbol.split]\", 2, js_regexp_Symbol_split ),\n    //JS_CGETSET_DEF(\"__source\", js_regexp_get___source, NULL ),\n    //JS_CGETSET_DEF(\"__flags\", js_regexp_get___flags, NULL ),\n};\n\nstatic const JSCFunctionListEntry js_regexp_string_iterator_proto_funcs[] = {\n    JS_ITERATOR_NEXT_DEF(\"next\", 0, js_regexp_string_iterator_next, 0 ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"RegExp String Iterator\", JS_PROP_CONFIGURABLE ),\n};\n\nvoid JS_AddIntrinsicRegExpCompiler(JSContext *ctx)\n{\n    ctx->compile_regexp = js_compile_regexp;\n}\n\nvoid JS_AddIntrinsicRegExp(JSContext *ctx)\n{\n    JSValueConst obj;\n\n    JS_AddIntrinsicRegExpCompiler(ctx);\n\n    ctx->class_proto[JS_CLASS_REGEXP] = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_REGEXP], js_regexp_proto_funcs,\n                               countof(js_regexp_proto_funcs));\n    obj = JS_NewGlobalCConstructor(ctx, \"RegExp\", js_regexp_constructor, 2,\n                                   ctx->class_proto[JS_CLASS_REGEXP]);\n    ctx->regexp_ctor = JS_DupValue(ctx, obj);\n    JS_SetPropertyFunctionList(ctx, obj, js_regexp_funcs, countof(js_regexp_funcs));\n\n    ctx->class_proto[JS_CLASS_REGEXP_STRING_ITERATOR] =\n        JS_NewObjectProto(ctx, ctx->iterator_proto);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_REGEXP_STRING_ITERATOR],\n                               js_regexp_string_iterator_proto_funcs,\n                               countof(js_regexp_string_iterator_proto_funcs));\n}\n\n/* JSON */\n\nstatic int json_parse_expect(JSParseState *s, int tok)\n{\n    if (s->token.val != tok) {\n        /* XXX: dump token correctly in all cases */\n        return js_parse_error(s, \"expecting '%c'\", tok);\n    }\n    return json_next_token(s);\n}\n\nstatic JSValue json_parse_value(JSParseState *s)\n{\n    JSContext *ctx = s->ctx;\n    JSValue val = JS_NULL;\n    int ret;\n\n    switch(s->token.val) {\n    case '{':\n        {\n            JSValue prop_val;\n            JSAtom prop_name;\n            \n            if (json_next_token(s))\n                goto fail;\n            val = JS_NewObject(ctx);\n            if (JS_IsException(val))\n                goto fail;\n            if (s->token.val != '}') {\n                for(;;) {\n                    if (s->token.val == TOK_STRING) {\n                        prop_name = JS_ValueToAtom(ctx, s->token.u.str.str);\n                        if (prop_name == JS_ATOM_NULL)\n                            goto fail;\n                    } else if (s->ext_json && s->token.val == TOK_IDENT) {\n                        prop_name = JS_DupAtom(ctx, s->token.u.ident.atom);\n                    } else {\n                        js_parse_error(s, \"expecting property name\");\n                        goto fail;\n                    }\n                    if (json_next_token(s))\n                        goto fail1;\n                    if (json_parse_expect(s, ':'))\n                        goto fail1;\n                    prop_val = json_parse_value(s);\n                    if (JS_IsException(prop_val)) {\n                    fail1:\n                        JS_FreeAtom(ctx, prop_name);\n                        goto fail;\n                    }\n                    ret = JS_DefinePropertyValue(ctx, val, prop_name,\n                                                 prop_val, JS_PROP_C_W_E);\n                    JS_FreeAtom(ctx, prop_name);\n                    if (ret < 0)\n                        goto fail;\n\n                    if (s->token.val != ',')\n                        break;\n                    if (json_next_token(s))\n                        goto fail;\n                    if (s->ext_json && s->token.val == '}')\n                        break;\n                }\n            }\n            if (json_parse_expect(s, '}'))\n                goto fail;\n        }\n        break;\n    case '[':\n        {\n            JSValue el;\n            uint32_t idx;\n\n            if (json_next_token(s))\n                goto fail;\n            val = JS_NewArray(ctx);\n            if (JS_IsException(val))\n                goto fail;\n            if (s->token.val != ']') {\n                idx = 0;\n                for(;;) {\n                    el = json_parse_value(s);\n                    if (JS_IsException(el))\n                        goto fail;\n                    ret = JS_DefinePropertyValueUint32(ctx, val, idx, el, JS_PROP_C_W_E);\n                    if (ret < 0)\n                        goto fail;\n                    if (s->token.val != ',')\n                        break;\n                    if (json_next_token(s))\n                        goto fail;\n                    idx++;\n                    if (s->ext_json && s->token.val == ']')\n                        break;\n                }\n            }\n            if (json_parse_expect(s, ']'))\n                goto fail;\n        }\n        break;\n    case TOK_STRING:\n        val = JS_DupValue(ctx, s->token.u.str.str);\n        if (json_next_token(s))\n            goto fail;\n        break;\n    case TOK_NUMBER:\n        val = s->token.u.num.val;\n        if (json_next_token(s))\n            goto fail;\n        break;\n    case TOK_IDENT:\n        if (s->token.u.ident.atom == JS_ATOM_false ||\n            s->token.u.ident.atom == JS_ATOM_true) {\n            val = JS_NewBool(ctx, (s->token.u.ident.atom == JS_ATOM_true));\n        } else if (s->token.u.ident.atom == JS_ATOM_null) {\n            val = JS_NULL;\n        } else {\n            goto def_token;\n        }\n        if (json_next_token(s))\n            goto fail;\n        break;\n    default:\n    def_token:\n        if (s->token.val == TOK_EOF) {\n            js_parse_error(s, \"unexpected end of input\");\n        } else {\n            js_parse_error(s, \"unexpected token: '%.*s'\",\n                           (int)(s->buf_ptr - s->token.ptr), s->token.ptr);\n        }\n        goto fail;\n    }\n    return val;\n fail:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nJSValue JS_ParseJSON2(JSContext *ctx, const char *buf, size_t buf_len,\n                      const char *filename, int flags)\n{\n    JSParseState s1, *s = &s1;\n    JSValue val = JS_UNDEFINED;\n\n    js_parse_init(ctx, s, buf, buf_len, filename);\n    s->ext_json = ((flags & JS_PARSE_JSON_EXT) != 0);\n    if (json_next_token(s))\n        goto fail;\n    val = json_parse_value(s);\n    if (JS_IsException(val))\n        goto fail;\n    if (s->token.val != TOK_EOF) {\n        if (js_parse_error(s, \"unexpected data at the end\"))\n            goto fail;\n    }\n    return val;\n fail:\n    JS_FreeValue(ctx, val);\n    free_token(s, &s->token);\n    return JS_EXCEPTION;\n}\n\nJSValue JS_ParseJSON(JSContext *ctx, const char *buf, size_t buf_len,\n                     const char *filename)\n{\n    return JS_ParseJSON2(ctx, buf, buf_len, filename, 0); \n}\n\nstatic JSValue internalize_json_property(JSContext *ctx, JSValueConst holder,\n                                         JSAtom name, JSValueConst reviver)\n{\n    JSValue val, new_el, name_val, res;\n    JSValueConst args[2];\n    int ret, is_array;\n    uint32_t i, len = 0;\n    JSAtom prop;\n    JSPropertyEnum *atoms = NULL;\n\n    if (js_check_stack_overflow(ctx->rt, 0)) {\n        return JS_ThrowStackOverflow(ctx);\n    }\n\n    val = JS_GetProperty(ctx, holder, name);\n    if (JS_IsException(val))\n        return val;\n    if (JS_IsObject(val)) {\n        is_array = JS_IsArray(ctx, val);\n        if (is_array < 0)\n            goto fail;\n        if (is_array) {\n            if (js_get_length32(ctx, &len, val))\n                goto fail;\n        } else {\n            ret = JS_GetOwnPropertyNamesInternal(ctx, &atoms, &len, JS_VALUE_GET_OBJ(val), JS_GPN_ENUM_ONLY | JS_GPN_STRING_MASK);\n            if (ret < 0)\n                goto fail;\n        }\n        for(i = 0; i < len; i++) {\n            if (is_array) {\n                prop = JS_NewAtomUInt32(ctx, i);\n                if (prop == JS_ATOM_NULL)\n                    goto fail;\n            } else {\n                prop = JS_DupAtom(ctx, atoms[i].atom);\n            }\n            new_el = internalize_json_property(ctx, val, prop, reviver);\n            if (JS_IsException(new_el)) {\n                JS_FreeAtom(ctx, prop);\n                goto fail;\n            }\n            if (JS_IsUndefined(new_el)) {\n                ret = JS_DeleteProperty(ctx, val, prop, 0);\n            } else {\n                ret = JS_DefinePropertyValue(ctx, val, prop, new_el, JS_PROP_C_W_E);\n            }\n            JS_FreeAtom(ctx, prop);\n            if (ret < 0)\n                goto fail;\n        }\n    }\n    js_free_prop_enum(ctx, atoms, len);\n    atoms = NULL;\n    name_val = JS_AtomToValue(ctx, name);\n    if (JS_IsException(name_val))\n        goto fail;\n    args[0] = name_val;\n    args[1] = val;\n    res = JS_Call(ctx, reviver, holder, 2, args);\n    JS_FreeValue(ctx, name_val);\n    JS_FreeValue(ctx, val);\n    return res;\n fail:\n    js_free_prop_enum(ctx, atoms, len);\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_json_parse(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    JSValue obj, root;\n    JSValueConst reviver;\n    const char *str;\n    size_t len;\n\n    str = JS_ToCStringLen(ctx, &len, argv[0]);\n    if (!str)\n        return JS_EXCEPTION;\n    obj = JS_ParseJSON(ctx, str, len, \"<input>\");\n    JS_FreeCString(ctx, str);\n    if (JS_IsException(obj))\n        return obj;\n    if (argc > 1 && JS_IsFunction(ctx, argv[1])) {\n        reviver = argv[1];\n        root = JS_NewObject(ctx);\n        if (JS_IsException(root)) {\n            JS_FreeValue(ctx, obj);\n            return JS_EXCEPTION;\n        }\n        if (JS_DefinePropertyValue(ctx, root, JS_ATOM_empty_string, obj,\n                                   JS_PROP_C_W_E) < 0) {\n            JS_FreeValue(ctx, root);\n            return JS_EXCEPTION;\n        }\n        obj = internalize_json_property(ctx, root, JS_ATOM_empty_string,\n                                        reviver);\n        JS_FreeValue(ctx, root);\n    }\n    return obj;\n}\n\ntypedef struct JSONStringifyContext {\n    JSValueConst replacer_func;\n    JSValue stack;\n    JSValue property_list;\n    JSValue gap;\n    JSValue empty;\n    StringBuffer *b;\n} JSONStringifyContext;\n\nstatic JSValue JS_ToQuotedStringFree(JSContext *ctx, JSValue val) {\n    JSValue r = JS_ToQuotedString(ctx, val);\n    JS_FreeValue(ctx, val);\n    return r;\n}\n\nstatic JSValue js_json_check(JSContext *ctx, JSONStringifyContext *jsc,\n                             JSValueConst holder, JSValue val, JSValueConst key)\n{\n    JSValue v;\n    JSValueConst args[2];\n\n    if (JS_IsObject(val)\n#ifdef CONFIG_BIGNUM\n    ||  JS_IsBigInt(ctx, val)   /* XXX: probably useless */\n#endif\n        ) {\n            JSValue f = JS_GetProperty(ctx, val, JS_ATOM_toJSON);\n            if (JS_IsException(f))\n                goto exception;\n            if (JS_IsFunction(ctx, f)) {\n                v = JS_CallFree(ctx, f, val, 1, &key);\n                JS_FreeValue(ctx, val);\n                val = v;\n                if (JS_IsException(val))\n                    goto exception;\n            } else {\n                JS_FreeValue(ctx, f);\n            }\n        }\n\n    if (!JS_IsUndefined(jsc->replacer_func)) {\n        args[0] = key;\n        args[1] = val;\n        v = JS_Call(ctx, jsc->replacer_func, holder, 2, args);\n        JS_FreeValue(ctx, val);\n        val = v;\n        if (JS_IsException(val))\n            goto exception;\n    }\n\n    switch (JS_VALUE_GET_NORM_TAG(val)) {\n    case JS_TAG_OBJECT:\n        if (JS_IsFunction(ctx, val))\n            break;\n    case JS_TAG_STRING:\n    case JS_TAG_INT:\n    case JS_TAG_FLOAT64:\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n#endif\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n#endif\n    case JS_TAG_EXCEPTION:\n        return val;\n    default:\n        break;\n    }\n    JS_FreeValue(ctx, val);\n    return JS_UNDEFINED;\n\nexception:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic int js_json_to_str(JSContext *ctx, JSONStringifyContext *jsc,\n                          JSValueConst holder, JSValue val,\n                          JSValueConst indent)\n{\n    JSValue indent1, sep, sep1, tab, v, prop;\n    JSObject *p;\n    int64_t i, len;\n    int cl, ret;\n    BOOL has_content;\n    \n    indent1 = JS_UNDEFINED;\n    sep = JS_UNDEFINED;\n    sep1 = JS_UNDEFINED;\n    tab = JS_UNDEFINED;\n    prop = JS_UNDEFINED;\n\n    switch (JS_VALUE_GET_NORM_TAG(val)) {\n    case JS_TAG_OBJECT:\n        p = JS_VALUE_GET_OBJ(val);\n        cl = p->class_id;\n        if (cl == JS_CLASS_STRING) {\n            val = JS_ToStringFree(ctx, val);\n            if (JS_IsException(val))\n                goto exception;\n            val = JS_ToQuotedStringFree(ctx, val);\n            if (JS_IsException(val))\n                goto exception;\n            return string_buffer_concat_value_free(jsc->b, val);\n        } else if (cl == JS_CLASS_NUMBER) {\n            val = JS_ToNumberFree(ctx, val);\n            if (JS_IsException(val))\n                goto exception;\n            return string_buffer_concat_value_free(jsc->b, val);\n        } else if (cl == JS_CLASS_BOOLEAN) {\n            ret = string_buffer_concat_value(jsc->b, p->u.object_data);\n            JS_FreeValue(ctx, val);\n            return ret;\n        }\n#ifdef CONFIG_BIGNUM\n        else if (cl == JS_CLASS_BIG_FLOAT) {\n            return string_buffer_concat_value_free(jsc->b, val);\n        } else if (cl == JS_CLASS_BIG_INT) {\n            JS_ThrowTypeError(ctx, \"bigint are forbidden in JSON.stringify\");\n            goto exception;\n        }\n#endif\n        v = js_array_includes(ctx, jsc->stack, 1, (JSValueConst *)&val);\n        if (JS_IsException(v))\n            goto exception;\n        if (JS_ToBoolFree(ctx, v)) {\n            JS_ThrowTypeError(ctx, \"circular reference\");\n            goto exception;\n        }\n        indent1 = JS_ConcatString(ctx, JS_DupValue(ctx, indent), JS_DupValue(ctx, jsc->gap));\n        if (JS_IsException(indent1))\n            goto exception;\n        if (!JS_IsEmptyString(jsc->gap)) {\n            sep = JS_ConcatString3(ctx, \"\\n\", JS_DupValue(ctx, indent1), \"\");\n            if (JS_IsException(sep))\n                goto exception;\n            sep1 = JS_NewString(ctx, \" \");\n            if (JS_IsException(sep1))\n                goto exception;\n        } else {\n            sep = JS_DupValue(ctx, jsc->empty);\n            sep1 = JS_DupValue(ctx, jsc->empty);\n        }\n        v = js_array_push(ctx, jsc->stack, 1, (JSValueConst *)&val, 0);\n        if (check_exception_free(ctx, v))\n            goto exception;\n        ret = JS_IsArray(ctx, val);\n        if (ret < 0)\n            goto exception;\n        if (ret) {\n            if (js_get_length64(ctx, &len, val))\n                goto exception;\n            string_buffer_putc8(jsc->b, '[');\n            for(i = 0; i < len; i++) {\n                if (i > 0)\n                    string_buffer_putc8(jsc->b, ',');\n                string_buffer_concat_value(jsc->b, sep);\n                v = JS_GetPropertyInt64(ctx, val, i);\n                if (JS_IsException(v))\n                    goto exception;\n                /* XXX: could do this string conversion only when needed */\n                prop = JS_ToStringFree(ctx, JS_NewInt64(ctx, i));\n                if (JS_IsException(prop))\n                    goto exception;\n                v = js_json_check(ctx, jsc, val, v, prop);\n                JS_FreeValue(ctx, prop);\n                prop = JS_UNDEFINED;\n                if (JS_IsException(v))\n                    goto exception;\n                if (JS_IsUndefined(v))\n                    v = JS_NULL;\n                if (js_json_to_str(ctx, jsc, val, v, indent1))\n                    goto exception;\n            }\n            if (len > 0 && !JS_IsEmptyString(jsc->gap)) {\n                string_buffer_putc8(jsc->b, '\\n');\n                string_buffer_concat_value(jsc->b, indent);\n            }\n            string_buffer_putc8(jsc->b, ']');\n        } else {\n            if (!JS_IsUndefined(jsc->property_list))\n                tab = JS_DupValue(ctx, jsc->property_list);\n            else\n                tab = js_object_keys(ctx, JS_UNDEFINED, 1, (JSValueConst *)&val, JS_ITERATOR_KIND_KEY);\n            if (JS_IsException(tab))\n                goto exception;\n            if (js_get_length64(ctx, &len, tab))\n                goto exception;\n            string_buffer_putc8(jsc->b, '{');\n            has_content = FALSE;\n            for(i = 0; i < len; i++) {\n                JS_FreeValue(ctx, prop);\n                prop = JS_GetPropertyInt64(ctx, tab, i);\n                if (JS_IsException(prop))\n                    goto exception;\n                v = JS_GetPropertyValue(ctx, val, JS_DupValue(ctx, prop));\n                if (JS_IsException(v))\n                    goto exception;\n                v = js_json_check(ctx, jsc, val, v, prop);\n                if (JS_IsException(v))\n                    goto exception;\n                if (!JS_IsUndefined(v)) {\n                    if (has_content)\n                        string_buffer_putc8(jsc->b, ',');\n                    prop = JS_ToQuotedStringFree(ctx, prop);\n                    if (JS_IsException(prop)) {\n                        JS_FreeValue(ctx, v);\n                        goto exception;\n                    }\n                    string_buffer_concat_value(jsc->b, sep);\n                    string_buffer_concat_value(jsc->b, prop);\n                    string_buffer_putc8(jsc->b, ':');\n                    string_buffer_concat_value(jsc->b, sep1);\n                    if (js_json_to_str(ctx, jsc, val, v, indent1))\n                        goto exception;\n                    has_content = TRUE;\n                }\n            }\n            if (has_content && JS_VALUE_GET_STRING(jsc->gap)->len != 0) {\n                string_buffer_putc8(jsc->b, '\\n');\n                string_buffer_concat_value(jsc->b, indent);\n            }\n            string_buffer_putc8(jsc->b, '}');\n        }\n        if (check_exception_free(ctx, js_array_pop(ctx, jsc->stack, 0, NULL, 0)))\n            goto exception;\n        JS_FreeValue(ctx, val);\n        JS_FreeValue(ctx, tab);\n        JS_FreeValue(ctx, sep);\n        JS_FreeValue(ctx, sep1);\n        JS_FreeValue(ctx, indent1);\n        JS_FreeValue(ctx, prop);\n        return 0;\n    case JS_TAG_STRING:\n        val = JS_ToQuotedStringFree(ctx, val);\n        if (JS_IsException(val))\n            goto exception;\n        goto concat_value;\n    case JS_TAG_FLOAT64:\n        if (!isfinite(JS_VALUE_GET_FLOAT64(val))) {\n            val = JS_NULL;\n        }\n        goto concat_value;\n    case JS_TAG_INT:\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n#endif\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    concat_value:\n        return string_buffer_concat_value_free(jsc->b, val);\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_INT:\n        JS_ThrowTypeError(ctx, \"bigint are forbidden in JSON.stringify\");\n        goto exception;\n#endif\n    default:\n        JS_FreeValue(ctx, val);\n        return 0;\n    }\n    \nexception:\n    JS_FreeValue(ctx, val);\n    JS_FreeValue(ctx, tab);\n    JS_FreeValue(ctx, sep);\n    JS_FreeValue(ctx, sep1);\n    JS_FreeValue(ctx, indent1);\n    JS_FreeValue(ctx, prop);\n    return -1;\n}\n\nJSValue JS_JSONStringify(JSContext *ctx, JSValueConst obj,\n                         JSValueConst replacer, JSValueConst space0)\n{\n    StringBuffer b_s;\n    JSONStringifyContext jsc_s, *jsc = &jsc_s;\n    JSValue val, v, space, ret, wrapper;\n    int res;\n    int64_t i, j, n;\n\n    jsc->replacer_func = JS_UNDEFINED;\n    jsc->stack = JS_UNDEFINED;\n    jsc->property_list = JS_UNDEFINED;\n    jsc->gap = JS_UNDEFINED;\n    jsc->b = &b_s;\n    jsc->empty = JS_AtomToString(ctx, JS_ATOM_empty_string);\n    ret = JS_UNDEFINED;\n    wrapper = JS_UNDEFINED;\n\n    string_buffer_init(ctx, jsc->b, 0);\n    jsc->stack = JS_NewArray(ctx);\n    if (JS_IsException(jsc->stack))\n        goto exception;\n    if (JS_IsFunction(ctx, replacer)) {\n        jsc->replacer_func = replacer;\n    } else {\n        res = JS_IsArray(ctx, replacer);\n        if (res < 0)\n            goto exception;\n        if (res) {\n            /* XXX: enumeration is not fully correct */\n            jsc->property_list = JS_NewArray(ctx);\n            if (JS_IsException(jsc->property_list))\n                goto exception;\n            if (js_get_length64(ctx, &n, replacer))\n                goto exception;\n            for (i = j = 0; i < n; i++) {\n                JSValue present;\n                v = JS_GetPropertyInt64(ctx, replacer, i);\n                if (JS_IsException(v))\n                    goto exception;\n                if (JS_IsObject(v)) {\n                    JSObject *p = JS_VALUE_GET_OBJ(v);\n                    if (p->class_id == JS_CLASS_STRING ||\n                        p->class_id == JS_CLASS_NUMBER) {\n                        v = JS_ToStringFree(ctx, v);\n                        if (JS_IsException(v))\n                            goto exception;\n                    } else {\n                        JS_FreeValue(ctx, v);\n                        continue;\n                    }\n                } else if (JS_IsNumber(v)) {\n                    v = JS_ToStringFree(ctx, v);\n                    if (JS_IsException(v))\n                        goto exception;\n                } else if (!JS_IsString(v)) {\n                    JS_FreeValue(ctx, v);\n                    continue;\n                }\n                present = js_array_includes(ctx, jsc->property_list,\n                                            1, (JSValueConst *)&v);\n                if (JS_IsException(present)) {\n                    JS_FreeValue(ctx, v);\n                    goto exception;\n                }\n                if (!JS_ToBoolFree(ctx, present)) {\n                    JS_SetPropertyInt64(ctx, jsc->property_list, j++, v);\n                } else {\n                    JS_FreeValue(ctx, v);\n                }\n            }\n        }\n    }\n    space = JS_DupValue(ctx, space0);\n    if (JS_IsObject(space)) {\n        JSObject *p = JS_VALUE_GET_OBJ(space);\n        if (p->class_id == JS_CLASS_NUMBER) {\n            space = JS_ToNumberFree(ctx, space);\n        } else if (p->class_id == JS_CLASS_STRING) {\n            space = JS_ToStringFree(ctx, space);\n        }\n        if (JS_IsException(space)) {\n            JS_FreeValue(ctx, space);\n            goto exception;\n        }\n    }\n    if (JS_IsNumber(space)) {\n        int n;\n        if (JS_ToInt32Clamp(ctx, &n, space, 0, 10, 0))\n            goto exception;\n        jsc->gap = JS_NewStringLen(ctx, \"          \", n);\n    } else if (JS_IsString(space)) {\n        JSString *p = JS_VALUE_GET_STRING(space);\n        jsc->gap = js_sub_string(ctx, p, 0, min_int(p->len, 10));\n    } else {\n        jsc->gap = JS_DupValue(ctx, jsc->empty);\n    }\n    JS_FreeValue(ctx, space);\n    if (JS_IsException(jsc->gap))\n        goto exception;\n    wrapper = JS_NewObject(ctx);\n    if (JS_IsException(wrapper))\n        goto exception;\n    if (JS_DefinePropertyValue(ctx, wrapper, JS_ATOM_empty_string,\n                               JS_DupValue(ctx, obj), JS_PROP_C_W_E) < 0)\n        goto exception;\n    val = JS_DupValue(ctx, obj);\n                           \n    val = js_json_check(ctx, jsc, wrapper, val, jsc->empty);\n    if (JS_IsException(val))\n        goto exception;\n    if (JS_IsUndefined(val)) {\n        ret = JS_UNDEFINED;\n        goto done1;\n    }\n    if (js_json_to_str(ctx, jsc, wrapper, val, jsc->empty))\n        goto exception;\n\n    ret = string_buffer_end(jsc->b);\n    goto done;\n\nexception:\n    ret = JS_EXCEPTION;\ndone1:\n    string_buffer_free(jsc->b);\ndone:\n    JS_FreeValue(ctx, wrapper);\n    JS_FreeValue(ctx, jsc->empty);\n    JS_FreeValue(ctx, jsc->gap);\n    JS_FreeValue(ctx, jsc->property_list);\n    JS_FreeValue(ctx, jsc->stack);\n    return ret;\n}\n\nstatic JSValue js_json_stringify(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    // stringify(val, replacer, space)\n    return JS_JSONStringify(ctx, argv[0], argv[1], argv[2]);\n}\n\nstatic const JSCFunctionListEntry js_json_funcs[] = {\n    JS_CFUNC_DEF(\"parse\", 2, js_json_parse ),\n    JS_CFUNC_DEF(\"stringify\", 3, js_json_stringify ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"JSON\", JS_PROP_CONFIGURABLE ),\n};\n\nstatic const JSCFunctionListEntry js_json_obj[] = {\n    JS_OBJECT_DEF(\"JSON\", js_json_funcs, countof(js_json_funcs), JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE ),\n};\n\nvoid JS_AddIntrinsicJSON(JSContext *ctx)\n{\n    /* add JSON as autoinit object */\n    JS_SetPropertyFunctionList(ctx, ctx->global_obj, js_json_obj, countof(js_json_obj));\n}\n\n/* Reflect */\n\nstatic JSValue js_reflect_apply(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    return js_function_apply(ctx, argv[0], max_int(0, argc - 1), argv + 1, 2);\n}\n\nstatic JSValue js_reflect_construct(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv)\n{\n    JSValueConst func, array_arg, new_target;\n    JSValue *tab, ret;\n    uint32_t len;\n\n    func = argv[0];\n    array_arg = argv[1];\n    if (argc > 2) {\n        new_target = argv[2];\n        if (!JS_IsConstructor(ctx, new_target))\n            return JS_ThrowTypeError(ctx, \"not a constructor\");\n    } else {\n        new_target = func;\n    }\n    tab = build_arg_list(ctx, &len, array_arg);\n    if (!tab)\n        return JS_EXCEPTION;\n    ret = JS_CallConstructor2(ctx, func, new_target, len, (JSValueConst *)tab);\n    free_arg_list(ctx, tab, len);\n    return ret;\n}\n\nstatic JSValue js_reflect_deleteProperty(JSContext *ctx, JSValueConst this_val,\n                                         int argc, JSValueConst *argv)\n{\n    JSValueConst obj;\n    JSAtom atom;\n    int ret;\n\n    obj = argv[0];\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    atom = JS_ValueToAtom(ctx, argv[1]);\n    if (unlikely(atom == JS_ATOM_NULL))\n        return JS_EXCEPTION;\n    ret = JS_DeleteProperty(ctx, obj, atom, 0);\n    JS_FreeAtom(ctx, atom);\n    if (ret < 0)\n        return JS_EXCEPTION;\n    else\n        return JS_NewBool(ctx, ret);\n}\n\nstatic JSValue js_reflect_get(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv)\n{\n    JSValueConst obj, prop, receiver;\n    JSAtom atom;\n    JSValue ret;\n\n    obj = argv[0];\n    prop = argv[1];\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    if (argc > 2)\n        receiver = argv[2];\n    else\n        receiver = obj;\n    atom = JS_ValueToAtom(ctx, prop);\n    if (unlikely(atom == JS_ATOM_NULL))\n        return JS_EXCEPTION;\n    ret = JS_GetPropertyInternal(ctx, obj, atom, receiver, FALSE);\n    JS_FreeAtom(ctx, atom);\n    return ret;\n}\n\nstatic JSValue js_reflect_has(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv)\n{\n    JSValueConst obj, prop;\n    JSAtom atom;\n    int ret;\n\n    obj = argv[0];\n    prop = argv[1];\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    atom = JS_ValueToAtom(ctx, prop);\n    if (unlikely(atom == JS_ATOM_NULL))\n        return JS_EXCEPTION;\n    ret = JS_HasProperty(ctx, obj, atom);\n    JS_FreeAtom(ctx, atom);\n    if (ret < 0)\n        return JS_EXCEPTION;\n    else\n        return JS_NewBool(ctx, ret);\n}\n\nstatic JSValue js_reflect_set(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv)\n{\n    JSValueConst obj, prop, val, receiver;\n    int ret;\n    JSAtom atom;\n\n    obj = argv[0];\n    prop = argv[1];\n    val = argv[2];\n    if (argc > 3)\n        receiver = argv[3];\n    else\n        receiver = obj;\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    atom = JS_ValueToAtom(ctx, prop);\n    if (unlikely(atom == JS_ATOM_NULL))\n        return JS_EXCEPTION;\n    ret = JS_SetPropertyGeneric(ctx, obj, atom,\n                                JS_DupValue(ctx, val), receiver, 0);\n    JS_FreeAtom(ctx, atom);\n    if (ret < 0)\n        return JS_EXCEPTION;\n    else\n        return JS_NewBool(ctx, ret);\n}\n\nstatic JSValue js_reflect_setPrototypeOf(JSContext *ctx, JSValueConst this_val,\n                                         int argc, JSValueConst *argv)\n{\n    int ret;\n    ret = JS_SetPrototypeInternal(ctx, argv[0], argv[1], FALSE);\n    if (ret < 0)\n        return JS_EXCEPTION;\n    else\n        return JS_NewBool(ctx, ret);\n}\n\nstatic JSValue js_reflect_ownKeys(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    if (JS_VALUE_GET_TAG(argv[0]) != JS_TAG_OBJECT)\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    return JS_GetOwnPropertyNames2(ctx, argv[0],\n                                   JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK,\n                                   JS_ITERATOR_KIND_KEY);\n}\n\nstatic const JSCFunctionListEntry js_reflect_funcs[] = {\n    JS_CFUNC_DEF(\"apply\", 3, js_reflect_apply ),\n    JS_CFUNC_DEF(\"construct\", 2, js_reflect_construct ),\n    JS_CFUNC_MAGIC_DEF(\"defineProperty\", 3, js_object_defineProperty, 1 ),\n    JS_CFUNC_DEF(\"deleteProperty\", 2, js_reflect_deleteProperty ),\n    JS_CFUNC_DEF(\"get\", 2, js_reflect_get ),\n    JS_CFUNC_MAGIC_DEF(\"getOwnPropertyDescriptor\", 2, js_object_getOwnPropertyDescriptor, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"getPrototypeOf\", 1, js_object_getPrototypeOf, 1 ),\n    JS_CFUNC_DEF(\"has\", 2, js_reflect_has ),\n    JS_CFUNC_MAGIC_DEF(\"isExtensible\", 1, js_object_isExtensible, 1 ),\n    JS_CFUNC_DEF(\"ownKeys\", 1, js_reflect_ownKeys ),\n    JS_CFUNC_MAGIC_DEF(\"preventExtensions\", 1, js_object_preventExtensions, 1 ),\n    JS_CFUNC_DEF(\"set\", 3, js_reflect_set ),\n    JS_CFUNC_DEF(\"setPrototypeOf\", 2, js_reflect_setPrototypeOf ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"Reflect\", JS_PROP_CONFIGURABLE ),\n};\n\nstatic const JSCFunctionListEntry js_reflect_obj[] = {\n    JS_OBJECT_DEF(\"Reflect\", js_reflect_funcs, countof(js_reflect_funcs), JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE ),\n};\n\n/* Proxy */\n\nstatic void js_proxy_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSProxyData *s = JS_GetOpaque(val, JS_CLASS_PROXY);\n    if (s) {\n        JS_FreeValueRT(rt, s->target);\n        JS_FreeValueRT(rt, s->handler);\n        js_free_rt(rt, s);\n    }\n}\n\nstatic void js_proxy_mark(JSRuntime *rt, JSValueConst val,\n                          JS_MarkFunc *mark_func)\n{\n    JSProxyData *s = JS_GetOpaque(val, JS_CLASS_PROXY);\n    if (s) {\n        JS_MarkValue(rt, s->target, mark_func);\n        JS_MarkValue(rt, s->handler, mark_func);\n    }\n}\n\nstatic JSValue JS_ThrowTypeErrorRevokedProxy(JSContext *ctx)\n{\n    return JS_ThrowTypeError(ctx, \"revoked proxy\");\n}\n\nstatic JSProxyData *get_proxy_method(JSContext *ctx, JSValue *pmethod,\n                                     JSValueConst obj, JSAtom name)\n{\n    JSProxyData *s = JS_GetOpaque(obj, JS_CLASS_PROXY);\n    JSValue method;\n\n    /* safer to test recursion in all proxy methods */\n    if (js_check_stack_overflow(ctx->rt, 0)) {\n        JS_ThrowStackOverflow(ctx);\n        return NULL;\n    }\n    \n    /* 's' should never be NULL */\n    if (s->is_revoked) {\n        JS_ThrowTypeErrorRevokedProxy(ctx);\n        return NULL;\n    }\n    method = JS_GetProperty(ctx, s->handler, name);\n    if (JS_IsException(method))\n        return NULL;\n    if (JS_IsNull(method))\n        method = JS_UNDEFINED;\n    *pmethod = method;\n    return s;\n}\n\nstatic JSValue js_proxy_getPrototypeOf(JSContext *ctx, JSValueConst obj)\n{\n    JSProxyData *s;\n    JSValue method, ret, proto1;\n    int res;\n\n    s = get_proxy_method(ctx, &method, obj, JS_ATOM_getPrototypeOf);\n    if (!s)\n        return JS_EXCEPTION;\n    if (JS_IsUndefined(method))\n        return JS_GetPrototype(ctx, s->target);\n    ret = JS_CallFree(ctx, method, s->handler, 1, (JSValueConst *)&s->target);\n    if (JS_IsException(ret))\n        return ret;\n    if (JS_VALUE_GET_TAG(ret) != JS_TAG_NULL &&\n        JS_VALUE_GET_TAG(ret) != JS_TAG_OBJECT) {\n        goto fail;\n    }\n    res = JS_IsExtensible(ctx, s->target);\n    if (res < 0) {\n        JS_FreeValue(ctx, ret);\n        return JS_EXCEPTION;\n    }\n    if (!res) {\n        /* check invariant */\n        proto1 = JS_GetPrototype(ctx, s->target);\n        if (JS_IsException(proto1)) {\n            JS_FreeValue(ctx, ret);\n            return JS_EXCEPTION;\n        }\n        if (JS_VALUE_GET_OBJ(proto1) != JS_VALUE_GET_OBJ(ret)) {\n            JS_FreeValue(ctx, proto1);\n        fail:\n            JS_FreeValue(ctx, ret);\n            return JS_ThrowTypeError(ctx, \"proxy: inconsistent prototype\");\n        }\n        JS_FreeValue(ctx, proto1);\n    }\n    return ret;\n}\n\nstatic int js_proxy_setPrototypeOf(JSContext *ctx, JSValueConst obj,\n                                   JSValueConst proto_val, BOOL throw_flag)\n{\n    JSProxyData *s;\n    JSValue method, ret, proto1;\n    JSValueConst args[2];\n    BOOL res;\n    int res2;\n\n    s = get_proxy_method(ctx, &method, obj, JS_ATOM_setPrototypeOf);\n    if (!s)\n        return -1;\n    if (JS_IsUndefined(method))\n        return JS_SetPrototypeInternal(ctx, s->target, proto_val, throw_flag);\n    args[0] = s->target;\n    args[1] = proto_val;\n    ret = JS_CallFree(ctx, method, s->handler, 2, args);\n    if (JS_IsException(ret))\n        return -1;\n    res = JS_ToBoolFree(ctx, ret);\n    if (!res) {\n        if (throw_flag) {\n            JS_ThrowTypeError(ctx, \"proxy: bad prototype\");\n            return -1;\n        } else {\n            return FALSE;\n        }\n    }\n    res2 = JS_IsExtensible(ctx, s->target);\n    if (res2 < 0)\n        return -1;\n    if (!res2) {\n        proto1 = JS_GetPrototype(ctx, s->target);\n        if (JS_IsException(proto1))\n            return -1;\n        if (JS_VALUE_GET_OBJ(proto_val) != JS_VALUE_GET_OBJ(proto1)) {\n            JS_FreeValue(ctx, proto1);\n            JS_ThrowTypeError(ctx, \"proxy: inconsistent prototype\");\n            return -1;\n        }\n        JS_FreeValue(ctx, proto1);\n    }\n    return TRUE;\n}\n\nstatic int js_proxy_isExtensible(JSContext *ctx, JSValueConst obj)\n{\n    JSProxyData *s;\n    JSValue method, ret;\n    BOOL res;\n    int res2;\n\n    s = get_proxy_method(ctx, &method, obj, JS_ATOM_isExtensible);\n    if (!s)\n        return -1;\n    if (JS_IsUndefined(method))\n        return JS_IsExtensible(ctx, s->target);\n    ret = JS_CallFree(ctx, method, s->handler, 1, (JSValueConst *)&s->target);\n    if (JS_IsException(ret))\n        return -1;\n    res = JS_ToBoolFree(ctx, ret);\n    res2 = JS_IsExtensible(ctx, s->target);\n    if (res2 < 0)\n        return res2;\n    if (res != res2) {\n        JS_ThrowTypeError(ctx, \"proxy: inconsistent isExtensible\");\n        return -1;\n    }\n    return res;\n}\n\nstatic int js_proxy_preventExtensions(JSContext *ctx, JSValueConst obj)\n{\n    JSProxyData *s;\n    JSValue method, ret;\n    BOOL res;\n    int res2;\n\n    s = get_proxy_method(ctx, &method, obj, JS_ATOM_preventExtensions);\n    if (!s)\n        return -1;\n    if (JS_IsUndefined(method))\n        return JS_PreventExtensions(ctx, s->target);\n    ret = JS_CallFree(ctx, method, s->handler, 1, (JSValueConst *)&s->target);\n    if (JS_IsException(ret))\n        return -1;\n    res = JS_ToBoolFree(ctx, ret);\n    if (res) {\n        res2 = JS_IsExtensible(ctx, s->target);\n        if (res2 < 0)\n            return res2;\n        if (res2) {\n            JS_ThrowTypeError(ctx, \"proxy: inconsistent preventExtensions\");\n            return -1;\n        }\n    }\n    return res;\n}\n\nstatic int js_proxy_has(JSContext *ctx, JSValueConst obj, JSAtom atom)\n{\n    JSProxyData *s;\n    JSValue method, ret1, atom_val;\n    int ret, res;\n    JSObject *p;\n    JSValueConst args[2];\n    BOOL res2;\n\n    s = get_proxy_method(ctx, &method, obj, JS_ATOM_has);\n    if (!s)\n        return -1;\n    if (JS_IsUndefined(method))\n        return JS_HasProperty(ctx, s->target, atom);\n    atom_val = JS_AtomToValue(ctx, atom);\n    if (JS_IsException(atom_val)) {\n        JS_FreeValue(ctx, method);\n        return -1;\n    }\n    args[0] = s->target;\n    args[1] = atom_val;\n    ret1 = JS_CallFree(ctx, method, s->handler, 2, args);\n    JS_FreeValue(ctx, atom_val);\n    if (JS_IsException(ret1))\n        return -1;\n    ret = JS_ToBoolFree(ctx, ret1);\n    if (!ret) {\n        JSPropertyDescriptor desc;\n        p = JS_VALUE_GET_OBJ(s->target);\n        res = JS_GetOwnPropertyInternal(ctx, &desc, p, atom);\n        if (res < 0)\n            return -1;\n        if (res) {\n            res2 = !(desc.flags & JS_PROP_CONFIGURABLE);\n            js_free_desc(ctx, &desc);\n            if (res2 || !p->extensible) {\n                JS_ThrowTypeError(ctx, \"proxy: inconsistent has\");\n                return -1;\n            }\n        }\n    }\n    return ret;\n}\n\nstatic JSValue js_proxy_get(JSContext *ctx, JSValueConst obj, JSAtom atom,\n                            JSValueConst receiver)\n{\n    JSProxyData *s;\n    JSValue method, ret, atom_val;\n    int res;\n    JSValueConst args[3];\n    JSPropertyDescriptor desc;\n\n    s = get_proxy_method(ctx, &method, obj, JS_ATOM_get);\n    if (!s)\n        return JS_EXCEPTION;\n    /* Note: recursion is possible thru the prototype of s->target */\n    if (JS_IsUndefined(method))\n        return JS_GetPropertyInternal(ctx, s->target, atom, receiver, FALSE);\n    atom_val = JS_AtomToValue(ctx, atom);\n    if (JS_IsException(atom_val)) {\n        JS_FreeValue(ctx, method);\n        return JS_EXCEPTION;\n    }\n    args[0] = s->target;\n    args[1] = atom_val;\n    args[2] = receiver;\n    ret = JS_CallFree(ctx, method, s->handler, 3, args);\n    JS_FreeValue(ctx, atom_val);\n    if (JS_IsException(ret))\n        return JS_EXCEPTION;\n    res = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(s->target), atom);\n    if (res < 0)\n        return JS_EXCEPTION;\n    if (res) {\n        if ((desc.flags & (JS_PROP_GETSET | JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE)) == 0) {\n            if (!js_same_value(ctx, desc.value, ret)) {\n                goto fail;\n            }\n        } else if ((desc.flags & (JS_PROP_GETSET | JS_PROP_CONFIGURABLE)) == JS_PROP_GETSET) {\n            if (JS_IsUndefined(desc.getter) && !JS_IsUndefined(ret)) {\n            fail:\n                js_free_desc(ctx, &desc);\n                JS_FreeValue(ctx, ret);\n                return JS_ThrowTypeError(ctx, \"proxy: inconsistent get\");\n            }\n        }\n        js_free_desc(ctx, &desc);\n    }\n    return ret;\n}\n\nstatic int js_proxy_set(JSContext *ctx, JSValueConst obj, JSAtom atom,\n                        JSValueConst value, JSValueConst receiver, int flags)\n{\n    JSProxyData *s;\n    JSValue method, ret1, atom_val;\n    int ret, res;\n    JSValueConst args[4];\n\n    s = get_proxy_method(ctx, &method, obj, JS_ATOM_set);\n    if (!s)\n        return -1;\n    if (JS_IsUndefined(method)) {\n        return JS_SetPropertyGeneric(ctx, s->target, atom,\n                                     JS_DupValue(ctx, value), receiver,\n                                     flags);\n    }\n    atom_val = JS_AtomToValue(ctx, atom);\n    if (JS_IsException(atom_val)) {\n        JS_FreeValue(ctx, method);\n        return -1;\n    }\n    args[0] = s->target;\n    args[1] = atom_val;\n    args[2] = value;\n    args[3] = receiver;\n    ret1 = JS_CallFree(ctx, method, s->handler, 4, args);\n    JS_FreeValue(ctx, atom_val);\n    if (JS_IsException(ret1))\n        return -1;\n    ret = JS_ToBoolFree(ctx, ret1);\n    if (ret) {\n        JSPropertyDescriptor desc;\n        res = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(s->target), atom);\n        if (res < 0)\n            return -1;\n        if (res) {\n            if ((desc.flags & (JS_PROP_GETSET | JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE)) == 0) {\n                if (!js_same_value(ctx, desc.value, value)) {\n                    goto fail;\n                }\n            } else if ((desc.flags & (JS_PROP_GETSET | JS_PROP_CONFIGURABLE)) == JS_PROP_GETSET && JS_IsUndefined(desc.setter)) {\n                fail:\n                    js_free_desc(ctx, &desc);\n                    JS_ThrowTypeError(ctx, \"proxy: inconsistent set\");\n                    return -1;\n            }\n            js_free_desc(ctx, &desc);\n        }\n    } else {\n        if ((flags & JS_PROP_THROW) ||\n            ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {\n            JS_ThrowTypeError(ctx, \"proxy: cannot set property\");\n            return -1;\n        }\n    }\n    return ret;\n}\n\nstatic JSValue js_create_desc(JSContext *ctx, JSValueConst val,\n                              JSValueConst getter, JSValueConst setter,\n                              int flags)\n{\n    JSValue ret;\n    ret = JS_NewObject(ctx);\n    if (JS_IsException(ret))\n        return ret;\n    if (flags & JS_PROP_HAS_GET) {\n        JS_DefinePropertyValue(ctx, ret, JS_ATOM_get, JS_DupValue(ctx, getter),\n                               JS_PROP_C_W_E);\n    }\n    if (flags & JS_PROP_HAS_SET) {\n        JS_DefinePropertyValue(ctx, ret, JS_ATOM_set, JS_DupValue(ctx, setter),\n                               JS_PROP_C_W_E);\n    }\n    if (flags & JS_PROP_HAS_VALUE) {\n        JS_DefinePropertyValue(ctx, ret, JS_ATOM_value, JS_DupValue(ctx, val),\n                               JS_PROP_C_W_E);\n    }\n    if (flags & JS_PROP_HAS_WRITABLE) {\n        JS_DefinePropertyValue(ctx, ret, JS_ATOM_writable,\n                               JS_NewBool(ctx, (flags & JS_PROP_WRITABLE) != 0),\n                               JS_PROP_C_W_E);\n    }\n    if (flags & JS_PROP_HAS_ENUMERABLE) {\n        JS_DefinePropertyValue(ctx, ret, JS_ATOM_enumerable,\n                               JS_NewBool(ctx, (flags & JS_PROP_ENUMERABLE) != 0),\n                               JS_PROP_C_W_E);\n    }\n    if (flags & JS_PROP_HAS_CONFIGURABLE) {\n        JS_DefinePropertyValue(ctx, ret, JS_ATOM_configurable,\n                               JS_NewBool(ctx, (flags & JS_PROP_CONFIGURABLE) != 0),\n                               JS_PROP_C_W_E);\n    }\n    return ret;\n}\n\nstatic int js_proxy_get_own_property(JSContext *ctx, JSPropertyDescriptor *pdesc,\n                                     JSValueConst obj, JSAtom prop)\n{\n    JSProxyData *s;\n    JSValue method, trap_result_obj, prop_val;\n    int res, target_desc_ret, ret;\n    JSObject *p;\n    JSValueConst args[2];\n    JSPropertyDescriptor result_desc, target_desc;\n\n    s = get_proxy_method(ctx, &method, obj, JS_ATOM_getOwnPropertyDescriptor);\n    if (!s)\n        return -1;\n    p = JS_VALUE_GET_OBJ(s->target);\n    if (JS_IsUndefined(method)) {\n        return JS_GetOwnPropertyInternal(ctx, pdesc, p, prop);\n    }\n    prop_val = JS_AtomToValue(ctx, prop);\n    if (JS_IsException(prop_val)) {\n        JS_FreeValue(ctx, method);\n        return -1;\n    }\n    args[0] = s->target;\n    args[1] = prop_val;\n    trap_result_obj = JS_CallFree(ctx, method, s->handler, 2, args);\n    JS_FreeValue(ctx, prop_val);\n    if (JS_IsException(trap_result_obj))\n        return -1;\n    if (!JS_IsObject(trap_result_obj) && !JS_IsUndefined(trap_result_obj)) {\n        JS_FreeValue(ctx, trap_result_obj);\n        goto fail;\n    }\n    target_desc_ret = JS_GetOwnPropertyInternal(ctx, &target_desc, p, prop);\n    if (target_desc_ret < 0) {\n        JS_FreeValue(ctx, trap_result_obj);\n        return -1;\n    }\n    if (target_desc_ret)\n        js_free_desc(ctx, &target_desc);\n    if (JS_IsUndefined(trap_result_obj)) {\n        if (target_desc_ret) {\n            if (!(target_desc.flags & JS_PROP_CONFIGURABLE) || !p->extensible)\n                goto fail;\n        }\n        ret = FALSE;\n    } else {\n        int flags1, extensible_target;\n        extensible_target = JS_IsExtensible(ctx, s->target);\n        if (extensible_target < 0) {\n            JS_FreeValue(ctx, trap_result_obj);\n            return -1;\n        }\n        res = js_obj_to_desc(ctx, &result_desc, trap_result_obj);\n        JS_FreeValue(ctx, trap_result_obj);\n        if (res < 0)\n            return -1;\n        \n        if (target_desc_ret) {\n            /* convert result_desc.flags to defineProperty flags */\n            flags1 = result_desc.flags | JS_PROP_HAS_CONFIGURABLE | JS_PROP_HAS_ENUMERABLE;\n            if (result_desc.flags & JS_PROP_GETSET)\n                flags1 |= JS_PROP_HAS_GET | JS_PROP_HAS_SET;\n            else\n                flags1 |= JS_PROP_HAS_VALUE | JS_PROP_HAS_WRITABLE;\n            /* XXX: not complete check: need to compare value &\n               getter/setter as in defineproperty */\n            if (!check_define_prop_flags(target_desc.flags, flags1))\n                goto fail1;\n        } else {\n            if (!extensible_target)\n                goto fail1;\n        }\n        if (!(result_desc.flags & JS_PROP_CONFIGURABLE)) {\n            if (!target_desc_ret || (target_desc.flags & JS_PROP_CONFIGURABLE))\n                goto fail1;\n            if ((result_desc.flags &\n                 (JS_PROP_GETSET | JS_PROP_WRITABLE)) == 0 &&\n                target_desc_ret &&\n                (target_desc.flags & JS_PROP_WRITABLE) != 0) {\n                /* proxy-missing-checks */\n            fail1:\n                js_free_desc(ctx, &result_desc);\n            fail:\n                JS_ThrowTypeError(ctx, \"proxy: inconsistent getOwnPropertyDescriptor\");\n                return -1;\n            }\n        }\n        ret = TRUE;\n        if (pdesc) {\n            *pdesc = result_desc;\n        } else {\n            js_free_desc(ctx, &result_desc);\n        }\n    }\n    return ret;\n}\n\nstatic int js_proxy_define_own_property(JSContext *ctx, JSValueConst obj,\n                                        JSAtom prop, JSValueConst val,\n                                        JSValueConst getter, JSValueConst setter,\n                                        int flags)\n{\n    JSProxyData *s;\n    JSValue method, ret1, prop_val, desc_val;\n    int res, ret;\n    JSObject *p;\n    JSValueConst args[3];\n    JSPropertyDescriptor desc;\n    BOOL setting_not_configurable;\n\n    s = get_proxy_method(ctx, &method, obj, JS_ATOM_defineProperty);\n    if (!s)\n        return -1;\n    if (JS_IsUndefined(method)) {\n        return JS_DefineProperty(ctx, s->target, prop, val, getter, setter, flags);\n    }\n    prop_val = JS_AtomToValue(ctx, prop);\n    if (JS_IsException(prop_val)) {\n        JS_FreeValue(ctx, method);\n        return -1;\n    }\n    desc_val = js_create_desc(ctx, val, getter, setter, flags);\n    if (JS_IsException(desc_val)) {\n        JS_FreeValue(ctx, prop_val);\n        JS_FreeValue(ctx, method);\n        return -1;\n    }\n    args[0] = s->target;\n    args[1] = prop_val;\n    args[2] = desc_val;\n    ret1 = JS_CallFree(ctx, method, s->handler, 3, args);\n    JS_FreeValue(ctx, prop_val);\n    JS_FreeValue(ctx, desc_val);\n    if (JS_IsException(ret1))\n        return -1;\n    ret = JS_ToBoolFree(ctx, ret1);\n    if (!ret) {\n        if (flags & JS_PROP_THROW) {\n            JS_ThrowTypeError(ctx, \"proxy: defineProperty exception\");\n            return -1;\n        } else {\n            return 0;\n        }\n    }\n    p = JS_VALUE_GET_OBJ(s->target);\n    res = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);\n    if (res < 0)\n        return -1;\n    setting_not_configurable = ((flags & (JS_PROP_HAS_CONFIGURABLE |\n                                          JS_PROP_CONFIGURABLE)) ==\n                                JS_PROP_HAS_CONFIGURABLE);\n    if (!res) {\n        if (!p->extensible || setting_not_configurable)\n            goto fail;\n    } else {\n        if (!check_define_prop_flags(desc.flags, flags) ||\n            ((desc.flags & JS_PROP_CONFIGURABLE) && setting_not_configurable)) {\n            goto fail1;\n        }\n        if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {\n            if ((desc.flags & (JS_PROP_GETSET | JS_PROP_CONFIGURABLE)) ==\n                JS_PROP_GETSET) {\n                if ((flags & JS_PROP_HAS_GET) &&\n                    !js_same_value(ctx, getter, desc.getter)) {\n                    goto fail1;\n                }\n                if ((flags & JS_PROP_HAS_SET) &&\n                    !js_same_value(ctx, setter, desc.setter)) {\n                    goto fail1;\n                }\n            }\n        } else if (flags & JS_PROP_HAS_VALUE) {\n            if ((desc.flags & (JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE)) ==\n                JS_PROP_WRITABLE && !(flags & JS_PROP_WRITABLE)) {\n                /* missing-proxy-check feature */\n                goto fail1;\n            } else if ((desc.flags & (JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE)) == 0 &&\n                !js_same_value(ctx, val, desc.value)) {\n                goto fail1;\n            }\n        }\n        if (flags & JS_PROP_HAS_WRITABLE) {\n            if ((desc.flags & (JS_PROP_GETSET | JS_PROP_CONFIGURABLE |\n                               JS_PROP_WRITABLE)) == JS_PROP_WRITABLE) {\n                /* proxy-missing-checks */\n            fail1:\n                js_free_desc(ctx, &desc);\n            fail:\n                JS_ThrowTypeError(ctx, \"proxy: inconsistent defineProperty\");\n                return -1;\n            }\n        }\n        js_free_desc(ctx, &desc);\n    }\n    return 1;\n}\n\nstatic int js_proxy_delete_property(JSContext *ctx, JSValueConst obj,\n                                    JSAtom atom)\n{\n    JSProxyData *s;\n    JSValue method, ret, atom_val;\n    int res, res2, is_extensible;\n    JSValueConst args[2];\n\n    s = get_proxy_method(ctx, &method, obj, JS_ATOM_deleteProperty);\n    if (!s)\n        return -1;\n    if (JS_IsUndefined(method)) {\n        return JS_DeleteProperty(ctx, s->target, atom, 0);\n    }\n    atom_val = JS_AtomToValue(ctx, atom);;\n    if (JS_IsException(atom_val)) {\n        JS_FreeValue(ctx, method);\n        return -1;\n    }\n    args[0] = s->target;\n    args[1] = atom_val;\n    ret = JS_CallFree(ctx, method, s->handler, 2, args);\n    JS_FreeValue(ctx, atom_val);\n    if (JS_IsException(ret))\n        return -1;\n    res = JS_ToBoolFree(ctx, ret);\n    if (res) {\n        JSPropertyDescriptor desc;\n        res2 = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(s->target), atom);\n        if (res2 < 0)\n            return -1;\n        if (res2) {\n            if (!(desc.flags & JS_PROP_CONFIGURABLE))\n                goto fail;\n            is_extensible = JS_IsExtensible(ctx, s->target);\n            if (is_extensible < 0)\n                goto fail1;\n            if (!is_extensible) {\n                /* proxy-missing-checks */\n            fail:\n                JS_ThrowTypeError(ctx, \"proxy: inconsistent deleteProperty\");\n            fail1:\n                js_free_desc(ctx, &desc);\n                return -1;\n            }\n            js_free_desc(ctx, &desc);\n        }\n    }\n    return res;\n}\n\n/* return the index of the property or -1 if not found */\nstatic int find_prop_key(const JSPropertyEnum *tab, int n, JSAtom atom)\n{\n    int i;\n    for(i = 0; i < n; i++) {\n        if (tab[i].atom == atom)\n            return i;\n    }\n    return -1;\n}\n\nstatic int js_proxy_get_own_property_names(JSContext *ctx,\n                                           JSPropertyEnum **ptab,\n                                           uint32_t *plen,\n                                           JSValueConst obj)\n{\n    JSProxyData *s;\n    JSValue method, prop_array, val;\n    uint32_t len, i, len2;\n    JSPropertyEnum *tab, *tab2;\n    JSAtom atom;\n    JSPropertyDescriptor desc;\n    int res, is_extensible, idx;\n\n    s = get_proxy_method(ctx, &method, obj, JS_ATOM_ownKeys);\n    if (!s)\n        return -1;\n    if (JS_IsUndefined(method)) {\n        return JS_GetOwnPropertyNamesInternal(ctx, ptab, plen,\n                                      JS_VALUE_GET_OBJ(s->target),\n                                      JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK);\n    }\n    prop_array = JS_CallFree(ctx, method, s->handler, 1, (JSValueConst *)&s->target);\n    if (JS_IsException(prop_array))\n        return -1;\n    tab = NULL;\n    len = 0;\n    tab2 = NULL;\n    len2 = 0;\n    if (js_get_length32(ctx, &len, prop_array))\n        goto fail;\n    if (len > 0) {\n        tab = js_mallocz(ctx, sizeof(tab[0]) * len);\n        if (!tab)\n            goto fail;\n    }\n    for(i = 0; i < len; i++) {\n        val = JS_GetPropertyUint32(ctx, prop_array, i);\n        if (JS_IsException(val))\n            goto fail;\n        if (!JS_IsString(val) && !JS_IsSymbol(val)) {\n            JS_FreeValue(ctx, val);\n            JS_ThrowTypeError(ctx, \"proxy: properties must be strings or symbols\");\n            goto fail;\n        }\n        atom = JS_ValueToAtom(ctx, val);\n        JS_FreeValue(ctx, val);\n        if (atom == JS_ATOM_NULL)\n            goto fail;\n        tab[i].atom = atom;\n        tab[i].is_enumerable = FALSE; /* XXX: redundant? */\n    }\n\n    /* check duplicate properties (XXX: inefficient, could store the\n     * properties an a temporary object to use the hash) */\n    for(i = 1; i < len; i++) {\n        if (find_prop_key(tab, i, tab[i].atom) >= 0) {\n            JS_ThrowTypeError(ctx, \"proxy: duplicate property\");\n            goto fail;\n        }\n    }\n\n    is_extensible = JS_IsExtensible(ctx, s->target);\n    if (is_extensible < 0)\n        goto fail;\n\n    /* check if there are non configurable properties */\n    if (s->is_revoked) {\n        JS_ThrowTypeErrorRevokedProxy(ctx);\n        goto fail;\n    }\n    if (JS_GetOwnPropertyNamesInternal(ctx, &tab2, &len2, JS_VALUE_GET_OBJ(s->target),\n                               JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK))\n        goto fail;\n    for(i = 0; i < len2; i++) {\n        if (s->is_revoked) {\n            JS_ThrowTypeErrorRevokedProxy(ctx);\n            goto fail;\n        }\n        res = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(s->target),\n                                tab2[i].atom);\n        if (res < 0)\n            goto fail;\n        if (res) {  /* safety, property should be found */\n            js_free_desc(ctx, &desc);\n            if (!(desc.flags & JS_PROP_CONFIGURABLE) || !is_extensible) {\n                idx = find_prop_key(tab, len, tab2[i].atom);\n                if (idx < 0) {\n                    JS_ThrowTypeError(ctx, \"proxy: target property must be present in proxy ownKeys\");\n                    goto fail;\n                }\n                /* mark the property as found */\n                if (!is_extensible)\n                    tab[idx].is_enumerable = TRUE;\n            }\n        }\n    }\n    if (!is_extensible) {\n        /* check that all property in 'tab' were checked */\n        for(i = 0; i < len; i++) {\n            if (!tab[i].is_enumerable) {\n                JS_ThrowTypeError(ctx, \"proxy: property not present in target were returned by non extensible proxy\");\n                goto fail;\n            }\n        }\n    }\n\n    js_free_prop_enum(ctx, tab2, len2);\n    JS_FreeValue(ctx, prop_array);\n    *ptab = tab;\n    *plen = len;\n    return 0;\n fail:\n    js_free_prop_enum(ctx, tab2, len2);\n    js_free_prop_enum(ctx, tab, len);\n    JS_FreeValue(ctx, prop_array);\n    return -1;\n}\n\nstatic JSValue js_proxy_call_constructor(JSContext *ctx, JSValueConst func_obj,\n                                         JSValueConst new_target,\n                                         int argc, JSValueConst *argv)\n{\n    JSProxyData *s;\n    JSValue method, arg_array, ret;\n    JSValueConst args[3];\n\n    s = get_proxy_method(ctx, &method, func_obj, JS_ATOM_construct);\n    if (!s)\n        return JS_EXCEPTION;\n    if (!JS_IsConstructor(ctx, s->target))\n        return JS_ThrowTypeError(ctx, \"not a constructor\");\n    if (JS_IsUndefined(method))\n        return JS_CallConstructor2(ctx, s->target, new_target, argc, argv);\n    arg_array = js_create_array(ctx, argc, argv);\n    if (JS_IsException(arg_array)) {\n        ret = JS_EXCEPTION;\n        goto fail;\n    }\n    args[0] = s->target;\n    args[1] = arg_array;\n    args[2] = new_target;\n    ret = JS_Call(ctx, method, s->handler, 3, args);\n    if (!JS_IsException(ret) && JS_VALUE_GET_TAG(ret) != JS_TAG_OBJECT) {\n        JS_FreeValue(ctx, ret);\n        ret = JS_ThrowTypeErrorNotAnObject(ctx);\n    }\n fail:\n    JS_FreeValue(ctx, method);\n    JS_FreeValue(ctx, arg_array);\n    return ret;\n}\n\nstatic JSValue js_proxy_call(JSContext *ctx, JSValueConst func_obj,\n                             JSValueConst this_obj,\n                             int argc, JSValueConst *argv, int flags)\n{\n    JSProxyData *s;\n    JSValue method, arg_array, ret;\n    JSValueConst args[3];\n\n    if (flags & JS_CALL_FLAG_CONSTRUCTOR)\n        return js_proxy_call_constructor(ctx, func_obj, this_obj, argc, argv);\n    \n    s = get_proxy_method(ctx, &method, func_obj, JS_ATOM_apply);\n    if (!s)\n        return JS_EXCEPTION;\n    if (!s->is_func) {\n        JS_FreeValue(ctx, method);\n        return JS_ThrowTypeError(ctx, \"not a function\");\n    }\n    if (JS_IsUndefined(method))\n        return JS_Call(ctx, s->target, this_obj, argc, argv);\n    arg_array = js_create_array(ctx, argc, argv);\n    if (JS_IsException(arg_array)) {\n        ret = JS_EXCEPTION;\n        goto fail;\n    }\n    args[0] = s->target;\n    args[1] = this_obj;\n    args[2] = arg_array;\n    ret = JS_Call(ctx, method, s->handler, 3, args);\n fail:\n    JS_FreeValue(ctx, method);\n    JS_FreeValue(ctx, arg_array);\n    return ret;\n}\n\nstatic int js_proxy_isArray(JSContext *ctx, JSValueConst obj)\n{\n    JSProxyData *s = JS_GetOpaque(obj, JS_CLASS_PROXY);\n    if (!s)\n        return FALSE;\n    if (s->is_revoked) {\n        JS_ThrowTypeErrorRevokedProxy(ctx);\n        return -1;\n    }\n    return JS_IsArray(ctx, s->target);\n}\n\nstatic const JSClassExoticMethods js_proxy_exotic_methods = {\n    .get_own_property = js_proxy_get_own_property,\n    .define_own_property = js_proxy_define_own_property,\n    .delete_property = js_proxy_delete_property,\n    .get_own_property_names = js_proxy_get_own_property_names,\n    .has_property = js_proxy_has,\n    .get_property = js_proxy_get,\n    .set_property = js_proxy_set,\n};\n\nstatic JSValue js_proxy_constructor(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv)\n{\n    JSValueConst target, handler;\n    JSValue obj;\n    JSProxyData *s;\n\n    target = argv[0];\n    handler = argv[1];\n    if (JS_VALUE_GET_TAG(target) != JS_TAG_OBJECT ||\n        JS_VALUE_GET_TAG(handler) != JS_TAG_OBJECT)\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n\n    obj = JS_NewObjectProtoClass(ctx, JS_NULL, JS_CLASS_PROXY);\n    if (JS_IsException(obj))\n        return obj;\n    s = js_malloc(ctx, sizeof(JSProxyData));\n    if (!s) {\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    s->target = JS_DupValue(ctx, target);\n    s->handler = JS_DupValue(ctx, handler);\n    s->is_func = JS_IsFunction(ctx, target);\n    s->is_revoked = FALSE;\n    JS_SetOpaque(obj, s);\n    JS_SetConstructorBit(ctx, obj, JS_IsConstructor(ctx, target));\n    return obj;\n}\n\nstatic JSValue js_proxy_revoke(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv, int magic,\n                               JSValue *func_data)\n{\n    JSProxyData *s = JS_GetOpaque(func_data[0], JS_CLASS_PROXY);\n    if (s) {\n        /* We do not free the handler and target in case they are\n           referenced as constants in the C call stack */\n        s->is_revoked = TRUE;\n        JS_FreeValue(ctx, func_data[0]);\n        func_data[0] = JS_NULL;\n    }\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_proxy_revoke_constructor(JSContext *ctx,\n                                           JSValueConst proxy_obj)\n{\n    return JS_NewCFunctionData(ctx, js_proxy_revoke, 0, 0, 1, &proxy_obj);\n}\n\nstatic JSValue js_proxy_revocable(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    JSValue proxy_obj, revoke_obj = JS_UNDEFINED, obj;\n\n    proxy_obj = js_proxy_constructor(ctx, JS_UNDEFINED, argc, argv);\n    if (JS_IsException(proxy_obj))\n        goto fail;\n    revoke_obj = js_proxy_revoke_constructor(ctx, proxy_obj);\n    if (JS_IsException(revoke_obj))\n        goto fail;\n    obj = JS_NewObject(ctx);\n    if (JS_IsException(obj))\n        goto fail;\n    // XXX: exceptions?\n    JS_DefinePropertyValue(ctx, obj, JS_ATOM_proxy, proxy_obj, JS_PROP_C_W_E);\n    JS_DefinePropertyValue(ctx, obj, JS_ATOM_revoke, revoke_obj, JS_PROP_C_W_E);\n    return obj;\n fail:\n    JS_FreeValue(ctx, proxy_obj);\n    JS_FreeValue(ctx, revoke_obj);\n    return JS_EXCEPTION;\n}\n\nstatic const JSCFunctionListEntry js_proxy_funcs[] = {\n    JS_CFUNC_DEF(\"revocable\", 2, js_proxy_revocable ),\n};\n\nstatic const JSClassShortDef js_proxy_class_def[] = {\n    { JS_ATOM_Object, js_proxy_finalizer, js_proxy_mark }, /* JS_CLASS_PROXY */\n};\n\nvoid JS_AddIntrinsicProxy(JSContext *ctx)\n{\n    JSRuntime *rt = ctx->rt;\n    JSValue obj1;\n\n    if (!JS_IsRegisteredClass(rt, JS_CLASS_PROXY)) {\n        init_class_range(rt, js_proxy_class_def, JS_CLASS_PROXY,\n                         countof(js_proxy_class_def));\n        rt->class_array[JS_CLASS_PROXY].exotic = &js_proxy_exotic_methods;\n        rt->class_array[JS_CLASS_PROXY].call = js_proxy_call;\n    }\n\n    obj1 = JS_NewCFunction2(ctx, js_proxy_constructor, \"Proxy\", 2,\n                            JS_CFUNC_constructor, 0);\n    JS_SetConstructorBit(ctx, obj1, TRUE);\n    JS_SetPropertyFunctionList(ctx, obj1, js_proxy_funcs,\n                               countof(js_proxy_funcs));\n    JS_DefinePropertyValueStr(ctx, ctx->global_obj, \"Proxy\",\n                              obj1, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n}\n\n/* Symbol */\n\nstatic JSValue js_symbol_constructor(JSContext *ctx, JSValueConst new_target,\n                                     int argc, JSValueConst *argv)\n{\n    JSValue str;\n    JSString *p;\n\n    if (!JS_IsUndefined(new_target))\n        return JS_ThrowTypeError(ctx, \"not a constructor\");\n    if (argc == 0 || JS_IsUndefined(argv[0])) {\n        p = NULL;\n    } else {\n        str = JS_ToString(ctx, argv[0]);\n        if (JS_IsException(str))\n            return JS_EXCEPTION;\n        p = JS_VALUE_GET_STRING(str);\n    }\n    return JS_NewSymbol(ctx, p, JS_ATOM_TYPE_SYMBOL);\n}\n\nstatic JSValue js_thisSymbolValue(JSContext *ctx, JSValueConst this_val)\n{\n    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_SYMBOL)\n        return JS_DupValue(ctx, this_val);\n\n    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(this_val);\n        if (p->class_id == JS_CLASS_SYMBOL) {\n            if (JS_VALUE_GET_TAG(p->u.object_data) == JS_TAG_SYMBOL)\n                return JS_DupValue(ctx, p->u.object_data);\n        }\n    }\n    return JS_ThrowTypeError(ctx, \"not a symbol\");\n}\n\nstatic JSValue js_symbol_toString(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    JSValue val, ret;\n    val = js_thisSymbolValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    /* XXX: use JS_ToStringInternal() with a flags */\n    ret = js_string_constructor(ctx, JS_UNDEFINED, 1, (JSValueConst *)&val);\n    JS_FreeValue(ctx, val);\n    return ret;\n}\n\nstatic JSValue js_symbol_valueOf(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    return js_thisSymbolValue(ctx, this_val);\n}\n\nstatic JSValue js_symbol_get_description(JSContext *ctx, JSValueConst this_val)\n{\n    JSValue val, ret;\n    JSAtomStruct *p;\n\n    val = js_thisSymbolValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    p = JS_VALUE_GET_PTR(val);\n    if (p->len == 0 && p->is_wide_char != 0) {\n        ret = JS_UNDEFINED;\n    } else {\n        ret = JS_AtomToString(ctx, js_get_atom_index(ctx->rt, p));\n    }\n    JS_FreeValue(ctx, val);\n    return ret;\n}\n\nstatic const JSCFunctionListEntry js_symbol_proto_funcs[] = {\n    JS_CFUNC_DEF(\"toString\", 0, js_symbol_toString ),\n    JS_CFUNC_DEF(\"valueOf\", 0, js_symbol_valueOf ),\n    // XXX: should have writable: false\n    JS_CFUNC_DEF(\"[Symbol.toPrimitive]\", 1, js_symbol_valueOf ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"Symbol\", JS_PROP_CONFIGURABLE ),\n    JS_CGETSET_DEF(\"description\", js_symbol_get_description, NULL ),\n};\n\nstatic JSValue js_symbol_for(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    JSValue str;\n\n    str = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(str))\n        return JS_EXCEPTION;\n    return JS_NewSymbol(ctx, JS_VALUE_GET_STRING(str), JS_ATOM_TYPE_GLOBAL_SYMBOL);\n}\n\nstatic JSValue js_symbol_keyFor(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    JSAtomStruct *p;\n\n    if (!JS_IsSymbol(argv[0]))\n        return JS_ThrowTypeError(ctx, \"not a symbol\");\n    p = JS_VALUE_GET_PTR(argv[0]);\n    if (p->atom_type != JS_ATOM_TYPE_GLOBAL_SYMBOL)\n        return JS_UNDEFINED;\n    return JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, p));\n}\n\nstatic const JSCFunctionListEntry js_symbol_funcs[] = {\n    JS_CFUNC_DEF(\"for\", 1, js_symbol_for ),\n    JS_CFUNC_DEF(\"keyFor\", 1, js_symbol_keyFor ),\n};\n\n/* Set/Map/WeakSet/WeakMap */\n\ntypedef struct JSMapRecord {\n    int ref_count; /* used during enumeration to avoid freeing the record */\n    BOOL empty; /* TRUE if the record is deleted */\n    struct JSMapState *map;\n    struct JSMapRecord *next_weak_ref;\n    struct list_head link;\n    struct list_head hash_link;\n    JSValue key;\n    JSValue value;\n} JSMapRecord;\n\ntypedef struct JSMapState {\n    BOOL is_weak; /* TRUE if WeakSet/WeakMap */\n    struct list_head records; /* list of JSMapRecord.link */\n    uint32_t record_count;\n    struct list_head *hash_table;\n    uint32_t hash_size; /* must be a power of two */\n    uint32_t record_count_threshold; /* count at which a hash table\n                                        resize is needed */\n} JSMapState;\n\n#define MAGIC_SET (1 << 0)\n#define MAGIC_WEAK (1 << 1)\n\nstatic JSValue js_map_constructor(JSContext *ctx, JSValueConst new_target,\n                                  int argc, JSValueConst *argv, int magic)\n{\n    JSMapState *s;\n    JSValue obj, adder = JS_UNDEFINED, iter = JS_UNDEFINED, next_method = JS_UNDEFINED;\n    JSValueConst arr;\n    BOOL is_set, is_weak;\n\n    is_set = magic & MAGIC_SET;\n    is_weak = ((magic & MAGIC_WEAK) != 0);\n    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_MAP + magic);\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n    s = js_mallocz(ctx, sizeof(*s));\n    if (!s)\n        goto fail;\n    init_list_head(&s->records);\n    s->is_weak = is_weak;\n    JS_SetOpaque(obj, s);\n    s->hash_size = 1;\n    s->hash_table = js_malloc(ctx, sizeof(s->hash_table[0]) * s->hash_size);\n    if (!s->hash_table)\n        goto fail;\n    init_list_head(&s->hash_table[0]);\n    s->record_count_threshold = 4;\n\n    arr = JS_UNDEFINED;\n    if (argc > 0)\n        arr = argv[0];\n    if (!JS_IsUndefined(arr) && !JS_IsNull(arr)) {\n        JSValue item, ret;\n        BOOL done;\n\n        adder = JS_GetProperty(ctx, obj, is_set ? JS_ATOM_add : JS_ATOM_set);\n        if (JS_IsException(adder))\n            goto fail;\n        if (!JS_IsFunction(ctx, adder)) {\n            JS_ThrowTypeError(ctx, \"set/add is not a function\");\n            goto fail;\n        }\n\n        iter = JS_GetIterator(ctx, arr, FALSE);\n        if (JS_IsException(iter))\n            goto fail;\n        next_method = JS_GetProperty(ctx, iter, JS_ATOM_next);\n        if (JS_IsException(next_method))\n            goto fail;\n\n        for(;;) {\n            item = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);\n            if (JS_IsException(item))\n                goto fail;\n            if (done) {\n                JS_FreeValue(ctx, item);\n                break;\n            }\n            if (is_set) {\n                ret = JS_Call(ctx, adder, obj, 1, (JSValueConst *)&item);\n                if (JS_IsException(ret)) {\n                    JS_FreeValue(ctx, item);\n                    goto fail;\n                }\n            } else {\n                JSValue key, value;\n                JSValueConst args[2];\n                key = JS_UNDEFINED;\n                value = JS_UNDEFINED;\n                if (!JS_IsObject(item)) {\n                    JS_ThrowTypeErrorNotAnObject(ctx);\n                    goto fail1;\n                }\n                key = JS_GetPropertyUint32(ctx, item, 0);\n                if (JS_IsException(key))\n                    goto fail1;\n                value = JS_GetPropertyUint32(ctx, item, 1);\n                if (JS_IsException(value))\n                    goto fail1;\n                args[0] = key;\n                args[1] = value;\n                ret = JS_Call(ctx, adder, obj, 2, args);\n                if (JS_IsException(ret)) {\n                fail1:\n                    JS_FreeValue(ctx, item);\n                    JS_FreeValue(ctx, key);\n                    JS_FreeValue(ctx, value);\n                    goto fail;\n                }\n                JS_FreeValue(ctx, key);\n                JS_FreeValue(ctx, value);\n            }\n            JS_FreeValue(ctx, ret);\n            JS_FreeValue(ctx, item);\n        }\n        JS_FreeValue(ctx, next_method);\n        JS_FreeValue(ctx, iter);\n        JS_FreeValue(ctx, adder);\n    }\n    return obj;\n fail:\n    if (JS_IsObject(iter)) {\n        /* close the iterator object, preserving pending exception */\n        JS_IteratorClose(ctx, iter, TRUE);\n    }\n    JS_FreeValue(ctx, next_method);\n    JS_FreeValue(ctx, iter);\n    JS_FreeValue(ctx, adder);\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\n/* XXX: could normalize strings to speed up comparison */\nstatic JSValueConst map_normalize_key(JSContext *ctx, JSValueConst key)\n{\n    uint32_t tag = JS_VALUE_GET_TAG(key);\n    /* convert -0.0 to +0.0 */\n    if (JS_TAG_IS_FLOAT64(tag) && JS_VALUE_GET_FLOAT64(key) == 0.0) {\n        key = JS_NewInt32(ctx, 0);\n    }\n    return key;\n}\n\n/* XXX: better hash ? */\nstatic uint32_t map_hash_key(JSContext *ctx, JSValueConst key)\n{\n    uint32_t tag = JS_VALUE_GET_NORM_TAG(key);\n    uint32_t h;\n    double d;\n    JSFloat64Union u;\n\n    switch(tag) {\n    case JS_TAG_BOOL:\n        h = JS_VALUE_GET_INT(key);\n        break;\n    case JS_TAG_STRING:\n        h = hash_string(JS_VALUE_GET_STRING(key), 0);\n        break;\n    case JS_TAG_OBJECT:\n    case JS_TAG_SYMBOL:\n        h = (uintptr_t)JS_VALUE_GET_PTR(key) * 3163;\n        break;\n    case JS_TAG_INT:\n        d = JS_VALUE_GET_INT(key) * 3163;\n        goto hash_float64;\n    case JS_TAG_FLOAT64:\n        d = JS_VALUE_GET_FLOAT64(key);\n        /* normalize the NaN */\n        if (isnan(d))\n            d = JS_FLOAT64_NAN;\n    hash_float64:\n        u.d = d;\n        h = (u.u32[0] ^ u.u32[1]) * 3163;\n        break;\n    default:\n        h = 0; /* XXX: bignum support */\n        break;\n    }\n    h ^= tag;\n    return h;\n}\n\nstatic JSMapRecord *map_find_record(JSContext *ctx, JSMapState *s,\n                                    JSValueConst key)\n{\n    struct list_head *el;\n    JSMapRecord *mr;\n    uint32_t h;\n    h = map_hash_key(ctx, key) & (s->hash_size - 1);\n    list_for_each(el, &s->hash_table[h]) {\n        mr = list_entry(el, JSMapRecord, hash_link);\n        if (js_same_value_zero(ctx, mr->key, key))\n            return mr;\n    }\n    return NULL;\n}\n\nstatic void map_hash_resize(JSContext *ctx, JSMapState *s)\n{\n    uint32_t new_hash_size, i, h;\n    size_t slack;\n    struct list_head *new_hash_table, *el;\n    JSMapRecord *mr;\n\n    /* XXX: no reporting of memory allocation failure */\n    if (s->hash_size == 1)\n        new_hash_size = 4;\n    else\n        new_hash_size = s->hash_size * 2;\n    new_hash_table = js_realloc2(ctx, s->hash_table,\n                                 sizeof(new_hash_table[0]) * new_hash_size, &slack);\n    if (!new_hash_table)\n        return;\n    new_hash_size += slack / sizeof(*new_hash_table);\n\n    for(i = 0; i < new_hash_size; i++)\n        init_list_head(&new_hash_table[i]);\n\n    list_for_each(el, &s->records) {\n        mr = list_entry(el, JSMapRecord, link);\n        if (!mr->empty) {\n            h = map_hash_key(ctx, mr->key) & (new_hash_size - 1);\n            list_add_tail(&mr->hash_link, &new_hash_table[h]);\n        }\n    }\n    s->hash_table = new_hash_table;\n    s->hash_size = new_hash_size;\n    s->record_count_threshold = new_hash_size * 2;\n}\n\nstatic JSMapRecord *map_add_record(JSContext *ctx, JSMapState *s,\n                                   JSValueConst key)\n{\n    uint32_t h;\n    JSMapRecord *mr;\n\n    mr = js_malloc(ctx, sizeof(*mr));\n    if (!mr)\n        return NULL;\n    mr->ref_count = 1;\n    mr->map = s;\n    mr->empty = FALSE;\n    if (s->is_weak) {\n        JSObject *p = JS_VALUE_GET_OBJ(key);\n        /* Add the weak reference */\n        mr->next_weak_ref = p->first_weak_ref;\n        p->first_weak_ref = mr;\n    } else {\n        JS_DupValue(ctx, key);\n    }\n    mr->key = (JSValue)key;\n    h = map_hash_key(ctx, key) & (s->hash_size - 1);\n    list_add_tail(&mr->hash_link, &s->hash_table[h]);\n    list_add_tail(&mr->link, &s->records);\n    s->record_count++;\n    if (s->record_count >= s->record_count_threshold) {\n        map_hash_resize(ctx, s);\n    }\n    return mr;\n}\n\n/* Remove the weak reference from the object weak\n   reference list. we don't use a doubly linked list to\n   save space, assuming a given object has few weak\n       references to it */\nstatic void delete_weak_ref(JSRuntime *rt, JSMapRecord *mr)\n{\n    JSMapRecord **pmr, *mr1;\n    JSObject *p;\n\n    p = JS_VALUE_GET_OBJ(mr->key);\n    pmr = &p->first_weak_ref;\n    for(;;) {\n        mr1 = *pmr;\n        assert(mr1 != NULL);\n        if (mr1 == mr)\n            break;\n        pmr = &mr1->next_weak_ref;\n    }\n    *pmr = mr1->next_weak_ref;\n}\n\nstatic void map_delete_record(JSRuntime *rt, JSMapState *s, JSMapRecord *mr)\n{\n    if (mr->empty)\n        return;\n    list_del(&mr->hash_link);\n    if (s->is_weak) {\n        delete_weak_ref(rt, mr);\n    } else {\n        JS_FreeValueRT(rt, mr->key);\n    }\n    JS_FreeValueRT(rt, mr->value);\n    if (--mr->ref_count == 0) {\n        list_del(&mr->link);\n        js_free_rt(rt, mr);\n    } else {\n        /* keep a zombie record for iterators */\n        mr->empty = TRUE;\n        mr->key = JS_UNDEFINED;\n        mr->value = JS_UNDEFINED;\n    }\n    s->record_count--;\n}\n\nstatic void map_decref_record(JSRuntime *rt, JSMapRecord *mr)\n{\n    if (--mr->ref_count == 0) {\n        /* the record can be safely removed */\n        assert(mr->empty);\n        list_del(&mr->link);\n        js_free_rt(rt, mr);\n    }\n}\n\nstatic void reset_weak_ref(JSRuntime *rt, JSObject *p)\n{\n    JSMapRecord *mr, *mr_next;\n    JSMapState *s;\n    \n    /* first pass to remove the records from the WeakMap/WeakSet\n       lists */\n    for(mr = p->first_weak_ref; mr != NULL; mr = mr->next_weak_ref) {\n        s = mr->map;\n        assert(s->is_weak);\n        assert(!mr->empty); /* no iterator on WeakMap/WeakSet */\n        list_del(&mr->hash_link);\n        list_del(&mr->link);\n    }\n    \n    /* second pass to free the values to avoid modifying the weak\n       reference list while traversing it. */\n    for(mr = p->first_weak_ref; mr != NULL; mr = mr_next) {\n        mr_next = mr->next_weak_ref;\n        JS_FreeValueRT(rt, mr->value);\n        js_free_rt(rt, mr);\n    }\n\n    p->first_weak_ref = NULL; /* fail safe */\n}\n\nstatic JSValue js_map_set(JSContext *ctx, JSValueConst this_val,\n                          int argc, JSValueConst *argv, int magic)\n{\n    JSMapState *s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);\n    JSMapRecord *mr;\n    JSValueConst key, value;\n\n    if (!s)\n        return JS_EXCEPTION;\n    key = map_normalize_key(ctx, argv[0]);\n    if (s->is_weak && !JS_IsObject(key))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    if (magic & MAGIC_SET)\n        value = JS_UNDEFINED;\n    else\n        value = argv[1];\n    mr = map_find_record(ctx, s, key);\n    if (mr) {\n        JS_FreeValue(ctx, mr->value);\n    } else {\n        mr = map_add_record(ctx, s, key);\n        if (!mr)\n            return JS_EXCEPTION;\n    }\n    mr->value = JS_DupValue(ctx, value);\n    return JS_DupValue(ctx, this_val);\n}\n\nstatic JSValue js_map_get(JSContext *ctx, JSValueConst this_val,\n                          int argc, JSValueConst *argv, int magic)\n{\n    JSMapState *s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);\n    JSMapRecord *mr;\n    JSValueConst key;\n\n    if (!s)\n        return JS_EXCEPTION;\n    key = map_normalize_key(ctx, argv[0]);\n    mr = map_find_record(ctx, s, key);\n    if (!mr)\n        return JS_UNDEFINED;\n    else\n        return JS_DupValue(ctx, mr->value);\n}\n\nstatic JSValue js_map_has(JSContext *ctx, JSValueConst this_val,\n                          int argc, JSValueConst *argv, int magic)\n{\n    JSMapState *s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);\n    JSMapRecord *mr;\n    JSValueConst key;\n\n    if (!s)\n        return JS_EXCEPTION;\n    key = map_normalize_key(ctx, argv[0]);\n    mr = map_find_record(ctx, s, key);\n    return JS_NewBool(ctx, (mr != NULL));\n}\n\nstatic JSValue js_map_delete(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv, int magic)\n{\n    JSMapState *s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);\n    JSMapRecord *mr;\n    JSValueConst key;\n\n    if (!s)\n        return JS_EXCEPTION;\n    key = map_normalize_key(ctx, argv[0]);\n    mr = map_find_record(ctx, s, key);\n    if (!mr)\n        return JS_FALSE;\n    map_delete_record(ctx->rt, s, mr);\n    return JS_TRUE;\n}\n\nstatic JSValue js_map_clear(JSContext *ctx, JSValueConst this_val,\n                            int argc, JSValueConst *argv, int magic)\n{\n    JSMapState *s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);\n    struct list_head *el, *el1;\n    JSMapRecord *mr;\n\n    if (!s)\n        return JS_EXCEPTION;\n    list_for_each_safe(el, el1, &s->records) {\n        mr = list_entry(el, JSMapRecord, link);\n        map_delete_record(ctx->rt, s, mr);\n    }\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_map_get_size(JSContext *ctx, JSValueConst this_val, int magic)\n{\n    JSMapState *s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);\n    if (!s)\n        return JS_EXCEPTION;\n    return JS_NewUint32(ctx, s->record_count);\n}\n\nstatic JSValue js_map_forEach(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv, int magic)\n{\n    JSMapState *s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);\n    JSValueConst func, this_arg;\n    JSValue ret, args[3];\n    struct list_head *el;\n    JSMapRecord *mr;\n\n    if (!s)\n        return JS_EXCEPTION;\n    func = argv[0];\n    if (argc > 1)\n        this_arg = argv[1];\n    else\n        this_arg = JS_UNDEFINED;\n    if (check_function(ctx, func))\n        return JS_EXCEPTION;\n    /* Note: the list can be modified while traversing it, but the\n       current element is locked */\n    el = s->records.next;\n    while (el != &s->records) {\n        mr = list_entry(el, JSMapRecord, link);\n        if (!mr->empty) {\n            mr->ref_count++;\n            /* must duplicate in case the record is deleted */\n            args[1] = JS_DupValue(ctx, mr->key);\n            if (magic)\n                args[0] = args[1];\n            else\n                args[0] = JS_DupValue(ctx, mr->value);\n            args[2] = (JSValue)this_val;\n            ret = JS_Call(ctx, func, this_arg, 3, (JSValueConst *)args);\n            JS_FreeValue(ctx, args[0]);\n            if (!magic)\n                JS_FreeValue(ctx, args[1]);\n            el = el->next;\n            map_decref_record(ctx->rt, mr);\n            if (JS_IsException(ret))\n                return ret;\n            JS_FreeValue(ctx, ret);\n        } else {\n            el = el->next;\n        }\n    }\n    return JS_UNDEFINED;\n}\n\nstatic void js_map_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p;\n    JSMapState *s;\n    struct list_head *el, *el1;\n    JSMapRecord *mr;\n\n    p = JS_VALUE_GET_OBJ(val);\n    s = p->u.map_state;\n    if (s) {\n        /* if the object is deleted we are sure that no iterator is\n           using it */\n        list_for_each_safe(el, el1, &s->records) {\n            mr = list_entry(el, JSMapRecord, link);\n            if (!mr->empty) {\n                if (s->is_weak)\n                    delete_weak_ref(rt, mr);\n                else\n                    JS_FreeValueRT(rt, mr->key);\n                JS_FreeValueRT(rt, mr->value);\n            }\n            js_free_rt(rt, mr);\n        }\n        js_free_rt(rt, s->hash_table);\n        js_free_rt(rt, s);\n    }\n}\n\nstatic void js_map_mark(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSMapState *s;\n    struct list_head *el;\n    JSMapRecord *mr;\n\n    s = p->u.map_state;\n    if (s) {\n        list_for_each(el, &s->records) {\n            mr = list_entry(el, JSMapRecord, link);\n            if (!s->is_weak)\n                JS_MarkValue(rt, mr->key, mark_func);\n            JS_MarkValue(rt, mr->value, mark_func);\n        }\n    }\n}\n\n/* Map Iterator */\n\ntypedef struct JSMapIteratorData {\n    JSValue obj;\n    JSIteratorKindEnum kind;\n    JSMapRecord *cur_record;\n} JSMapIteratorData;\n\nstatic void js_map_iterator_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p;\n    JSMapIteratorData *it;\n\n    p = JS_VALUE_GET_OBJ(val);\n    it = p->u.map_iterator_data;\n    if (it) {\n        /* During the GC sweep phase the Map finalizer may be\n           called before the Map iterator finalizer */\n        if (JS_IsLiveObject(rt, it->obj) && it->cur_record) {\n            map_decref_record(rt, it->cur_record);\n        }\n        JS_FreeValueRT(rt, it->obj);\n        js_free_rt(rt, it);\n    }\n}\n\nstatic void js_map_iterator_mark(JSRuntime *rt, JSValueConst val,\n                                 JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSMapIteratorData *it;\n    it = p->u.map_iterator_data;\n    if (it) {\n        /* the record is already marked by the object */\n        JS_MarkValue(rt, it->obj, mark_func);\n    }\n}\n\nstatic JSValue js_create_map_iterator(JSContext *ctx, JSValueConst this_val,\n                                      int argc, JSValueConst *argv, int magic)\n{\n    JSIteratorKindEnum kind;\n    JSMapState *s;\n    JSMapIteratorData *it;\n    JSValue enum_obj;\n\n    kind = magic >> 2;\n    magic &= 3;\n    s = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic);\n    if (!s)\n        return JS_EXCEPTION;\n    enum_obj = JS_NewObjectClass(ctx, JS_CLASS_MAP_ITERATOR + magic);\n    if (JS_IsException(enum_obj))\n        goto fail;\n    it = js_malloc(ctx, sizeof(*it));\n    if (!it) {\n        JS_FreeValue(ctx, enum_obj);\n        goto fail;\n    }\n    it->obj = JS_DupValue(ctx, this_val);\n    it->kind = kind;\n    it->cur_record = NULL;\n    JS_SetOpaque(enum_obj, it);\n    return enum_obj;\n fail:\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_map_iterator_next(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv,\n                                    BOOL *pdone, int magic)\n{\n    JSMapIteratorData *it;\n    JSMapState *s;\n    JSMapRecord *mr;\n    struct list_head *el;\n\n    it = JS_GetOpaque2(ctx, this_val, JS_CLASS_MAP_ITERATOR + magic);\n    if (!it) {\n        *pdone = FALSE;\n        return JS_EXCEPTION;\n    }\n    if (JS_IsUndefined(it->obj))\n        goto done;\n    s = JS_GetOpaque(it->obj, JS_CLASS_MAP + magic);\n    assert(s != NULL);\n    if (!it->cur_record) {\n        el = s->records.next;\n    } else {\n        mr = it->cur_record;\n        el = mr->link.next;\n        map_decref_record(ctx->rt, mr); /* the record can be freed here */\n    }\n    for(;;) {\n        if (el == &s->records) {\n            /* no more record  */\n            it->cur_record = NULL;\n            JS_FreeValue(ctx, it->obj);\n            it->obj = JS_UNDEFINED;\n        done:\n            /* end of enumeration */\n            *pdone = TRUE;\n            return JS_UNDEFINED;\n        }\n        mr = list_entry(el, JSMapRecord, link);\n        if (!mr->empty)\n            break;\n        /* get the next record */\n        el = mr->link.next;\n    }\n\n    /* lock the record so that it won't be freed */\n    mr->ref_count++;\n    it->cur_record = mr;\n    *pdone = FALSE;\n\n    if (it->kind == JS_ITERATOR_KIND_KEY) {\n        return JS_DupValue(ctx, mr->key);\n    } else {\n        JSValueConst args[2];\n        args[0] = mr->key;\n        if (magic)\n            args[1] = mr->key;\n        else\n            args[1] = mr->value;\n        if (it->kind == JS_ITERATOR_KIND_VALUE) {\n            return JS_DupValue(ctx, args[1]);\n        } else {\n            return js_create_array(ctx, 2, args);\n        }\n    }\n}\n\nstatic const JSCFunctionListEntry js_map_funcs[] = {\n    JS_CGETSET_DEF(\"[Symbol.species]\", js_get_this, NULL ),\n};\n\nstatic const JSCFunctionListEntry js_map_proto_funcs[] = {\n    JS_CFUNC_MAGIC_DEF(\"set\", 2, js_map_set, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"get\", 1, js_map_get, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"has\", 1, js_map_has, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"delete\", 1, js_map_delete, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"clear\", 0, js_map_clear, 0 ),\n    JS_CGETSET_MAGIC_DEF(\"size\", js_map_get_size, NULL, 0),\n    JS_CFUNC_MAGIC_DEF(\"forEach\", 1, js_map_forEach, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"values\", 0, js_create_map_iterator, (JS_ITERATOR_KIND_VALUE << 2) | 0 ),\n    JS_CFUNC_MAGIC_DEF(\"keys\", 0, js_create_map_iterator, (JS_ITERATOR_KIND_KEY << 2) | 0 ),\n    JS_CFUNC_MAGIC_DEF(\"entries\", 0, js_create_map_iterator, (JS_ITERATOR_KIND_KEY_AND_VALUE << 2) | 0 ),\n    JS_ALIAS_DEF(\"[Symbol.iterator]\", \"entries\" ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"Map\", JS_PROP_CONFIGURABLE ),\n};\n\nstatic const JSCFunctionListEntry js_map_iterator_proto_funcs[] = {\n    JS_ITERATOR_NEXT_DEF(\"next\", 0, js_map_iterator_next, 0 ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"Map Iterator\", JS_PROP_CONFIGURABLE ),\n};\n\nstatic const JSCFunctionListEntry js_set_proto_funcs[] = {\n    JS_CFUNC_MAGIC_DEF(\"add\", 1, js_map_set, MAGIC_SET ),\n    JS_CFUNC_MAGIC_DEF(\"has\", 1, js_map_has, MAGIC_SET ),\n    JS_CFUNC_MAGIC_DEF(\"delete\", 1, js_map_delete, MAGIC_SET ),\n    JS_CFUNC_MAGIC_DEF(\"clear\", 0, js_map_clear, MAGIC_SET ),\n    JS_CGETSET_MAGIC_DEF(\"size\", js_map_get_size, NULL, MAGIC_SET ),\n    JS_CFUNC_MAGIC_DEF(\"forEach\", 1, js_map_forEach, MAGIC_SET ),\n    JS_CFUNC_MAGIC_DEF(\"values\", 0, js_create_map_iterator, (JS_ITERATOR_KIND_KEY << 2) | MAGIC_SET ),\n    JS_ALIAS_DEF(\"keys\", \"values\" ),\n    JS_ALIAS_DEF(\"[Symbol.iterator]\", \"values\" ),\n    JS_CFUNC_MAGIC_DEF(\"entries\", 0, js_create_map_iterator, (JS_ITERATOR_KIND_KEY_AND_VALUE << 2) | MAGIC_SET ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"Set\", JS_PROP_CONFIGURABLE ),\n};\n\nstatic const JSCFunctionListEntry js_set_iterator_proto_funcs[] = {\n    JS_ITERATOR_NEXT_DEF(\"next\", 0, js_map_iterator_next, MAGIC_SET ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"Set Iterator\", JS_PROP_CONFIGURABLE ),\n};\n\nstatic const JSCFunctionListEntry js_weak_map_proto_funcs[] = {\n    JS_CFUNC_MAGIC_DEF(\"set\", 2, js_map_set, MAGIC_WEAK ),\n    JS_CFUNC_MAGIC_DEF(\"get\", 1, js_map_get, MAGIC_WEAK ),\n    JS_CFUNC_MAGIC_DEF(\"has\", 1, js_map_has, MAGIC_WEAK ),\n    JS_CFUNC_MAGIC_DEF(\"delete\", 1, js_map_delete, MAGIC_WEAK ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"WeakMap\", JS_PROP_CONFIGURABLE ),\n};\n\nstatic const JSCFunctionListEntry js_weak_set_proto_funcs[] = {\n    JS_CFUNC_MAGIC_DEF(\"add\", 1, js_map_set, MAGIC_SET | MAGIC_WEAK ),\n    JS_CFUNC_MAGIC_DEF(\"has\", 1, js_map_has, MAGIC_SET | MAGIC_WEAK ),\n    JS_CFUNC_MAGIC_DEF(\"delete\", 1, js_map_delete, MAGIC_SET | MAGIC_WEAK ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"WeakSet\", JS_PROP_CONFIGURABLE ),\n};\n\nstatic const JSCFunctionListEntry * const js_map_proto_funcs_ptr[6] = {\n    js_map_proto_funcs,\n    js_set_proto_funcs,\n    js_weak_map_proto_funcs,\n    js_weak_set_proto_funcs,\n    js_map_iterator_proto_funcs,\n    js_set_iterator_proto_funcs,\n};\n\nstatic const uint8_t js_map_proto_funcs_count[6] = {\n    countof(js_map_proto_funcs),\n    countof(js_set_proto_funcs),\n    countof(js_weak_map_proto_funcs),\n    countof(js_weak_set_proto_funcs),\n    countof(js_map_iterator_proto_funcs),\n    countof(js_set_iterator_proto_funcs),\n};\n\nvoid JS_AddIntrinsicMapSet(JSContext *ctx)\n{\n    int i;\n    JSValue obj1;\n    char buf[ATOM_GET_STR_BUF_SIZE];\n\n    for(i = 0; i < 4; i++) {\n        const char *name = JS_AtomGetStr(ctx, buf, sizeof(buf),\n                                         JS_ATOM_Map + i);\n        ctx->class_proto[JS_CLASS_MAP + i] = JS_NewObject(ctx);\n        JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_MAP + i],\n                                   js_map_proto_funcs_ptr[i],\n                                   js_map_proto_funcs_count[i]);\n        obj1 = JS_NewCFunctionMagic(ctx, js_map_constructor, name, 0,\n                                    JS_CFUNC_constructor_magic, i);\n        if (i < 2) {\n            JS_SetPropertyFunctionList(ctx, obj1, js_map_funcs,\n                                       countof(js_map_funcs));\n        }\n        JS_NewGlobalCConstructor2(ctx, obj1, name, ctx->class_proto[JS_CLASS_MAP + i]);\n    }\n\n    for(i = 0; i < 2; i++) {\n        ctx->class_proto[JS_CLASS_MAP_ITERATOR + i] =\n            JS_NewObjectProto(ctx, ctx->iterator_proto);\n        JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_MAP_ITERATOR + i],\n                                   js_map_proto_funcs_ptr[i + 4],\n                                   js_map_proto_funcs_count[i + 4]);\n    }\n}\n\n/* Generator */\nstatic const JSCFunctionListEntry js_generator_function_proto_funcs[] = {\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"GeneratorFunction\", JS_PROP_CONFIGURABLE),\n};\n\nstatic const JSCFunctionListEntry js_generator_proto_funcs[] = {\n    JS_ITERATOR_NEXT_DEF(\"next\", 1, js_generator_next, GEN_MAGIC_NEXT ),\n    JS_ITERATOR_NEXT_DEF(\"return\", 1, js_generator_next, GEN_MAGIC_RETURN ),\n    JS_ITERATOR_NEXT_DEF(\"throw\", 1, js_generator_next, GEN_MAGIC_THROW ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"Generator\", JS_PROP_CONFIGURABLE),\n};\n\n/* Promise */\n\ntypedef enum JSPromiseStateEnum {\n    JS_PROMISE_PENDING,\n    JS_PROMISE_FULFILLED,\n    JS_PROMISE_REJECTED,\n} JSPromiseStateEnum;\n\ntypedef struct JSPromiseData {\n    JSPromiseStateEnum promise_state;\n    /* 0=fulfill, 1=reject, list of JSPromiseReactionData.link */\n    struct list_head promise_reactions[2];\n    BOOL is_handled; /* Note: only useful to debug */\n    JSValue promise_result;\n} JSPromiseData;\n\ntypedef struct JSPromiseFunctionDataResolved {\n    int ref_count;\n    BOOL already_resolved;\n} JSPromiseFunctionDataResolved;\n\ntypedef struct JSPromiseFunctionData {\n    JSValue promise;\n    JSPromiseFunctionDataResolved *presolved;\n} JSPromiseFunctionData;\n\ntypedef struct JSPromiseReactionData {\n    struct list_head link; /* not used in promise_reaction_job */\n    JSValue resolving_funcs[2];\n    JSValue handler;\n} JSPromiseReactionData;\n\nstatic int js_create_resolving_functions(JSContext *ctx, JSValue *args,\n                                         JSValueConst promise);\n\nstatic void promise_reaction_data_free(JSRuntime *rt,\n                                       JSPromiseReactionData *rd)\n{\n    JS_FreeValueRT(rt, rd->resolving_funcs[0]);\n    JS_FreeValueRT(rt, rd->resolving_funcs[1]);\n    JS_FreeValueRT(rt, rd->handler);\n    js_free_rt(rt, rd);\n}\n\nstatic JSValue promise_reaction_job(JSContext *ctx, int argc,\n                                    JSValueConst *argv)\n{\n    JSValueConst handler, arg, func;\n    JSValue res, res2;\n    BOOL is_reject;\n\n    assert(argc == 5);\n    handler = argv[2];\n    is_reject = JS_ToBool(ctx, argv[3]);\n    arg = argv[4];\n#ifdef DUMP_PROMISE\n    printf(\"promise_reaction_job: is_reject=%d\\n\", is_reject);\n#endif\n\n    if (JS_IsUndefined(handler)) {\n        if (is_reject) {\n            res = JS_Throw(ctx, JS_DupValue(ctx, arg));\n        } else {\n            res = JS_DupValue(ctx, arg);\n        }\n    } else {\n        res = JS_Call(ctx, handler, JS_UNDEFINED, 1, &arg);\n    }\n    is_reject = JS_IsException(res);\n    if (is_reject)\n        res = JS_GetException(ctx);\n    func = argv[is_reject];\n    /* as an extension, we support undefined as value to avoid\n       creating a dummy promise in the 'await' implementation of async\n       functions */\n    if (!JS_IsUndefined(func)) {\n        res2 = JS_Call(ctx, func, JS_UNDEFINED,\n                       1, (JSValueConst *)&res);\n    } else {\n        res2 = JS_UNDEFINED;\n    }\n    JS_FreeValue(ctx, res);\n\n    return res2;\n}\n\nvoid JS_SetHostPromiseRejectionTracker(JSRuntime *rt,\n                                       JSHostPromiseRejectionTracker *cb,\n                                       void *opaque)\n{\n    rt->host_promise_rejection_tracker = cb;\n    rt->host_promise_rejection_tracker_opaque = opaque;\n}\n\nstatic void fulfill_or_reject_promise(JSContext *ctx, JSValueConst promise,\n                                      JSValueConst value, BOOL is_reject)\n{\n    JSPromiseData *s = JS_GetOpaque(promise, JS_CLASS_PROMISE);\n    struct list_head *el, *el1;\n    JSPromiseReactionData *rd;\n    JSValueConst args[5];\n\n    if (!s || s->promise_state != JS_PROMISE_PENDING)\n        return; /* should never happen */\n    set_value(ctx, &s->promise_result, JS_DupValue(ctx, value));\n    s->promise_state = JS_PROMISE_FULFILLED + is_reject;\n#ifdef DUMP_PROMISE\n    printf(\"fulfill_or_reject_promise: is_reject=%d\\n\", is_reject);\n#endif\n    if (s->promise_state == JS_PROMISE_REJECTED && !s->is_handled) {\n        JSRuntime *rt = ctx->rt;\n        if (rt->host_promise_rejection_tracker) {\n            rt->host_promise_rejection_tracker(ctx, promise, value, FALSE,\n                                               rt->host_promise_rejection_tracker_opaque);\n        }\n    }\n\n    list_for_each_safe(el, el1, &s->promise_reactions[is_reject]) {\n        rd = list_entry(el, JSPromiseReactionData, link);\n        args[0] = rd->resolving_funcs[0];\n        args[1] = rd->resolving_funcs[1];\n        args[2] = rd->handler;\n        args[3] = JS_NewBool(ctx, is_reject);\n        args[4] = value;\n        JS_EnqueueJob(ctx, promise_reaction_job, 5, args);\n        list_del(&rd->link);\n        promise_reaction_data_free(ctx->rt, rd);\n    }\n\n    list_for_each_safe(el, el1, &s->promise_reactions[1 - is_reject]) {\n        rd = list_entry(el, JSPromiseReactionData, link);\n        list_del(&rd->link);\n        promise_reaction_data_free(ctx->rt, rd);\n    }\n}\n\nstatic void reject_promise(JSContext *ctx, JSValueConst promise,\n                           JSValueConst value)\n{\n    fulfill_or_reject_promise(ctx, promise, value, TRUE);\n}\n\nstatic JSValue js_promise_resolve_thenable_job(JSContext *ctx,\n                                               int argc, JSValueConst *argv)\n{\n    JSValueConst promise, thenable, then;\n    JSValue args[2], res;\n\n#ifdef DUMP_PROMISE\n    printf(\"js_promise_resolve_thenable_job\\n\");\n#endif\n    assert(argc == 3);\n    promise = argv[0];\n    thenable = argv[1];\n    then = argv[2];\n    if (js_create_resolving_functions(ctx, args, promise) < 0)\n        return JS_EXCEPTION;\n    res = JS_Call(ctx, then, thenable, 2, (JSValueConst *)args);\n    if (JS_IsException(res)) {\n        JSValue error = JS_GetException(ctx);\n        res = JS_Call(ctx, args[1], JS_UNDEFINED, 1, (JSValueConst *)&error);\n        JS_FreeValue(ctx, error);\n    }\n    JS_FreeValue(ctx, args[0]);\n    JS_FreeValue(ctx, args[1]);\n    return res;\n}\n\nstatic void js_promise_resolve_function_free_resolved(JSRuntime *rt,\n                                                      JSPromiseFunctionDataResolved *sr)\n{\n    if (--sr->ref_count == 0) {\n        js_free_rt(rt, sr);\n    }\n}\n\nstatic int js_create_resolving_functions(JSContext *ctx,\n                                         JSValue *resolving_funcs,\n                                         JSValueConst promise)\n\n{\n    JSValue obj;\n    JSPromiseFunctionData *s;\n    JSPromiseFunctionDataResolved *sr;\n    int i, ret;\n\n    sr = js_malloc(ctx, sizeof(*sr));\n    if (!sr)\n        return -1;\n    sr->ref_count = 1;\n    sr->already_resolved = FALSE; /* must be shared between the two functions */\n    ret = 0;\n    for(i = 0; i < 2; i++) {\n        obj = JS_NewObjectProtoClass(ctx, ctx->function_proto,\n                                     JS_CLASS_PROMISE_RESOLVE_FUNCTION + i);\n        if (JS_IsException(obj))\n            goto fail;\n        s = js_malloc(ctx, sizeof(*s));\n        if (!s) {\n            JS_FreeValue(ctx, obj);\n        fail:\n\n            if (i != 0)\n                JS_FreeValue(ctx, resolving_funcs[0]);\n            ret = -1;\n            break;\n        }\n        sr->ref_count++;\n        s->presolved = sr;\n        s->promise = JS_DupValue(ctx, promise);\n        JS_SetOpaque(obj, s);\n        js_function_set_properties(ctx, obj, JS_ATOM_empty_string, 1);\n        resolving_funcs[i] = obj;\n    }\n    js_promise_resolve_function_free_resolved(ctx->rt, sr);\n    return ret;\n}\n\nstatic void js_promise_resolve_function_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSPromiseFunctionData *s = JS_VALUE_GET_OBJ(val)->u.promise_function_data;\n    if (s) {\n        js_promise_resolve_function_free_resolved(rt, s->presolved);\n        JS_FreeValueRT(rt, s->promise);\n        js_free_rt(rt, s);\n    }\n}\n\nstatic void js_promise_resolve_function_mark(JSRuntime *rt, JSValueConst val,\n                                             JS_MarkFunc *mark_func)\n{\n    JSPromiseFunctionData *s = JS_VALUE_GET_OBJ(val)->u.promise_function_data;\n    if (s) {\n        JS_MarkValue(rt, s->promise, mark_func);\n    }\n}\n\nstatic JSValue js_promise_resolve_function_call(JSContext *ctx,\n                                                JSValueConst func_obj,\n                                                JSValueConst this_val,\n                                                int argc, JSValueConst *argv,\n                                                int flags)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(func_obj);\n    JSPromiseFunctionData *s;\n    JSValueConst resolution, args[3];\n    JSValue then;\n    BOOL is_reject;\n\n    s = p->u.promise_function_data;\n    if (!s || s->presolved->already_resolved)\n        return JS_UNDEFINED;\n    s->presolved->already_resolved = TRUE;\n    is_reject = p->class_id - JS_CLASS_PROMISE_RESOLVE_FUNCTION;\n    if (argc > 0)\n        resolution = argv[0];\n    else\n        resolution = JS_UNDEFINED;\n#ifdef DUMP_PROMISE\n    printf(\"js_promise_resolving_function_call: is_reject=%d resolution=\", is_reject);\n    JS_DumpValue(ctx, resolution);\n    printf(\"\\n\");\n#endif\n    if (is_reject || !JS_IsObject(resolution)) {\n        goto done;\n    } else if (js_same_value(ctx, resolution, s->promise)) {\n        JS_ThrowTypeError(ctx, \"promise self resolution\");\n        goto fail_reject;\n    }\n    then = JS_GetProperty(ctx, resolution, JS_ATOM_then);\n    if (JS_IsException(then)) {\n        JSValue error;\n    fail_reject:\n        error = JS_GetException(ctx);\n        reject_promise(ctx, s->promise, error);\n        JS_FreeValue(ctx, error);\n    } else if (!JS_IsFunction(ctx, then)) {\n        JS_FreeValue(ctx, then);\n    done:\n        fulfill_or_reject_promise(ctx, s->promise, resolution, is_reject);\n    } else {\n        args[0] = s->promise;\n        args[1] = resolution;\n        args[2] = then;\n        JS_EnqueueJob(ctx, js_promise_resolve_thenable_job, 3, args);\n        JS_FreeValue(ctx, then);\n    }\n    return JS_UNDEFINED;\n}\n\nstatic void js_promise_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSPromiseData *s = JS_GetOpaque(val, JS_CLASS_PROMISE);\n    struct list_head *el, *el1;\n    int i;\n\n    if (!s)\n        return;\n    for(i = 0; i < 2; i++) {\n        list_for_each_safe(el, el1, &s->promise_reactions[i]) {\n            JSPromiseReactionData *rd =\n                list_entry(el, JSPromiseReactionData, link);\n            promise_reaction_data_free(rt, rd);\n        }\n    }\n    JS_FreeValueRT(rt, s->promise_result);\n    js_free_rt(rt, s);\n}\n\nstatic void js_promise_mark(JSRuntime *rt, JSValueConst val,\n                            JS_MarkFunc *mark_func)\n{\n    JSPromiseData *s = JS_GetOpaque(val, JS_CLASS_PROMISE);\n    struct list_head *el;\n    int i;\n\n    if (!s)\n        return;\n    for(i = 0; i < 2; i++) {\n        list_for_each(el, &s->promise_reactions[i]) {\n            JSPromiseReactionData *rd =\n                list_entry(el, JSPromiseReactionData, link);\n            JS_MarkValue(rt, rd->resolving_funcs[0], mark_func);\n            JS_MarkValue(rt, rd->resolving_funcs[1], mark_func);\n            JS_MarkValue(rt, rd->handler, mark_func);\n        }\n    }\n    JS_MarkValue(rt, s->promise_result, mark_func);\n}\n\nstatic JSValue js_promise_constructor(JSContext *ctx, JSValueConst new_target,\n                                      int argc, JSValueConst *argv)\n{\n    JSValueConst executor;\n    JSValue obj;\n    JSPromiseData *s;\n    JSValue args[2], ret;\n    int i;\n\n    executor = argv[0];\n    if (check_function(ctx, executor))\n        return JS_EXCEPTION;\n    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_PROMISE);\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n    s = js_mallocz(ctx, sizeof(*s));\n    if (!s)\n        goto fail;\n    s->promise_state = JS_PROMISE_PENDING;\n    s->is_handled = FALSE;\n    for(i = 0; i < 2; i++)\n        init_list_head(&s->promise_reactions[i]);\n    s->promise_result = JS_UNDEFINED;\n    JS_SetOpaque(obj, s);\n    if (js_create_resolving_functions(ctx, args, obj))\n        goto fail;\n    ret = JS_Call(ctx, executor, JS_UNDEFINED, 2, (JSValueConst *)args);\n    if (JS_IsException(ret)) {\n        JSValue ret2, error;\n        error = JS_GetException(ctx);\n        ret2 = JS_Call(ctx, args[1], JS_UNDEFINED, 1, (JSValueConst *)&error);\n        JS_FreeValue(ctx, error);\n        if (JS_IsException(ret2))\n            goto fail1;\n        JS_FreeValue(ctx, ret2);\n    }\n    JS_FreeValue(ctx, ret);\n    JS_FreeValue(ctx, args[0]);\n    JS_FreeValue(ctx, args[1]);\n    return obj;\n fail1:\n    JS_FreeValue(ctx, args[0]);\n    JS_FreeValue(ctx, args[1]);\n fail:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_promise_executor(JSContext *ctx,\n                                   JSValueConst this_val,\n                                   int argc, JSValueConst *argv,\n                                   int magic, JSValue *func_data)\n{\n    int i;\n\n    for(i = 0; i < 2; i++) {\n        if (!JS_IsUndefined(func_data[i]))\n            return JS_ThrowTypeError(ctx, \"resolving function already set\");\n        func_data[i] = JS_DupValue(ctx, argv[i]);\n    }\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_promise_executor_new(JSContext *ctx)\n{\n    JSValueConst func_data[2];\n\n    func_data[0] = JS_UNDEFINED;\n    func_data[1] = JS_UNDEFINED;\n    return JS_NewCFunctionData(ctx, js_promise_executor, 2,\n                               0, 2, func_data);\n}\n\nstatic JSValue js_new_promise_capability(JSContext *ctx,\n                                         JSValue *resolving_funcs,\n                                         JSValueConst ctor)\n{\n    JSValue executor, result_promise;\n    JSCFunctionDataRecord *s;\n    int i;\n\n    executor = js_promise_executor_new(ctx);\n    if (JS_IsException(executor))\n        return executor;\n\n    if (JS_IsUndefined(ctor)) {\n        result_promise = js_promise_constructor(ctx, ctor, 1,\n                                                (JSValueConst *)&executor);\n    } else {\n        result_promise = JS_CallConstructor(ctx, ctor, 1,\n                                            (JSValueConst *)&executor);\n    }\n    if (JS_IsException(result_promise))\n        goto fail;\n    s = JS_GetOpaque(executor, JS_CLASS_C_FUNCTION_DATA);\n    for(i = 0; i < 2; i++) {\n        if (check_function(ctx, s->data[i]))\n            goto fail;\n    }\n    for(i = 0; i < 2; i++)\n        resolving_funcs[i] = JS_DupValue(ctx, s->data[i]);\n    JS_FreeValue(ctx, executor);\n    return result_promise;\n fail:\n    JS_FreeValue(ctx, executor);\n    JS_FreeValue(ctx, result_promise);\n    return JS_EXCEPTION;\n}\n\nJSValue JS_NewPromiseCapability(JSContext *ctx, JSValue *resolving_funcs)\n{\n    return js_new_promise_capability(ctx, resolving_funcs, JS_UNDEFINED);\n}\n\nstatic JSValue js_promise_resolve(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv, int magic)\n{\n    JSValue result_promise, resolving_funcs[2], ret;\n    BOOL is_reject = magic;\n\n    if (!JS_IsObject(this_val))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    if (!is_reject && JS_GetOpaque(argv[0], JS_CLASS_PROMISE)) {\n        JSValue ctor;\n        BOOL is_same;\n        ctor = JS_GetProperty(ctx, argv[0], JS_ATOM_constructor);\n        if (JS_IsException(ctor))\n            return ctor;\n        is_same = js_same_value(ctx, ctor, this_val);\n        JS_FreeValue(ctx, ctor);\n        if (is_same)\n            return JS_DupValue(ctx, argv[0]);\n    }\n    result_promise = js_new_promise_capability(ctx, resolving_funcs, this_val);\n    if (JS_IsException(result_promise))\n        return result_promise;\n    ret = JS_Call(ctx, resolving_funcs[is_reject], JS_UNDEFINED, 1, argv);\n    JS_FreeValue(ctx, resolving_funcs[0]);\n    JS_FreeValue(ctx, resolving_funcs[1]);\n    if (JS_IsException(ret)) {\n        JS_FreeValue(ctx, result_promise);\n        return ret;\n    }\n    JS_FreeValue(ctx, ret);\n    return result_promise;\n}\n\n#if 0\nstatic JSValue js_promise___newPromiseCapability(JSContext *ctx,\n                                                 JSValueConst this_val,\n                                                 int argc, JSValueConst *argv)\n{\n    JSValue result_promise, resolving_funcs[2], obj;\n    JSValueConst ctor;\n    ctor = argv[0];\n    if (!JS_IsObject(ctor))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    result_promise = js_new_promise_capability(ctx, resolving_funcs, ctor);\n    if (JS_IsException(result_promise))\n        return result_promise;\n    obj = JS_NewObject(ctx);\n    if (JS_IsException(obj)) {\n        JS_FreeValue(ctx, resolving_funcs[0]);\n        JS_FreeValue(ctx, resolving_funcs[1]);\n        JS_FreeValue(ctx, result_promise);\n        return JS_EXCEPTION;\n    }\n    JS_DefinePropertyValue(ctx, obj, JS_ATOM_promise, result_promise, JS_PROP_C_W_E);\n    JS_DefinePropertyValue(ctx, obj, JS_ATOM_resolve, resolving_funcs[0], JS_PROP_C_W_E);\n    JS_DefinePropertyValue(ctx, obj, JS_ATOM_reject, resolving_funcs[1], JS_PROP_C_W_E);\n    return obj;\n}\n#endif\n\nstatic __exception int remainingElementsCount_add(JSContext *ctx,\n                                                  JSValueConst resolve_element_env,\n                                                  int addend)\n{\n    JSValue val;\n    int remainingElementsCount;\n\n    val = JS_GetPropertyUint32(ctx, resolve_element_env, 0);\n    if (JS_IsException(val))\n        return -1;\n    if (JS_ToInt32Free(ctx, &remainingElementsCount, val))\n        return -1;\n    remainingElementsCount += addend;\n    if (JS_SetPropertyUint32(ctx, resolve_element_env, 0,\n                             JS_NewInt32(ctx, remainingElementsCount)) < 0)\n        return -1;\n    return (remainingElementsCount == 0);\n}\n\n#define PROMISE_MAGIC_all        0\n#define PROMISE_MAGIC_allSettled 1\n#define PROMISE_MAGIC_any        2\n\nstatic JSValue js_promise_all_resolve_element(JSContext *ctx,\n                                              JSValueConst this_val,\n                                              int argc, JSValueConst *argv,\n                                              int magic,\n                                              JSValue *func_data)\n{\n    int resolve_type = magic & 3;\n    int is_reject = magic & 4;\n    BOOL alreadyCalled = JS_ToBool(ctx, func_data[0]);\n    JSValueConst values = func_data[2];\n    JSValueConst resolve = func_data[3];\n    JSValueConst resolve_element_env = func_data[4];\n    JSValue ret, obj;\n    int is_zero, index;\n    \n    if (JS_ToInt32(ctx, &index, func_data[1]))\n        return JS_EXCEPTION;\n    if (alreadyCalled)\n        return JS_UNDEFINED;\n    func_data[0] = JS_NewBool(ctx, TRUE);\n\n    if (resolve_type == PROMISE_MAGIC_allSettled) {\n        JSValue str;\n        \n        obj = JS_NewObject(ctx);\n        if (JS_IsException(obj))\n            return JS_EXCEPTION;\n        str = JS_NewString(ctx, is_reject ? \"rejected\" : \"fulfilled\");\n        if (JS_IsException(str))\n            goto fail1;\n        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_status,\n                                   str,\n                                   JS_PROP_C_W_E) < 0)\n            goto fail1;\n        if (JS_DefinePropertyValue(ctx, obj,\n                                   is_reject ? JS_ATOM_reason : JS_ATOM_value,\n                                   JS_DupValue(ctx, argv[0]),\n                                   JS_PROP_C_W_E) < 0) {\n        fail1:\n            JS_FreeValue(ctx, obj);\n            return JS_EXCEPTION;\n        }\n    } else {\n        obj = JS_DupValue(ctx, argv[0]);\n    }\n    if (JS_DefinePropertyValueUint32(ctx, values, index,\n                                     obj, JS_PROP_C_W_E) < 0)\n        return JS_EXCEPTION;\n    \n    is_zero = remainingElementsCount_add(ctx, resolve_element_env, -1);\n    if (is_zero < 0)\n        return JS_EXCEPTION;\n    if (is_zero) {\n        if (resolve_type == PROMISE_MAGIC_any) {\n            JSValue error;\n            error = js_aggregate_error_constructor(ctx, values);\n            if (JS_IsException(error))\n                return JS_EXCEPTION;\n            ret = JS_Call(ctx, resolve, JS_UNDEFINED, 1, (JSValueConst *)&error);\n            JS_FreeValue(ctx, error);\n        } else {\n            ret = JS_Call(ctx, resolve, JS_UNDEFINED, 1, (JSValueConst *)&values);\n        }\n        if (JS_IsException(ret))\n            return ret;\n        JS_FreeValue(ctx, ret);\n    }\n    return JS_UNDEFINED;\n}\n\n/* magic = 0: Promise.all 1: Promise.allSettled */\nstatic JSValue js_promise_all(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv, int magic)\n{\n    JSValue result_promise, resolving_funcs[2], item, next_promise, ret;\n    JSValue next_method = JS_UNDEFINED, values = JS_UNDEFINED;\n    JSValue resolve_element_env = JS_UNDEFINED, resolve_element, reject_element;\n    JSValue promise_resolve = JS_UNDEFINED, iter = JS_UNDEFINED;\n    JSValueConst then_args[2], resolve_element_data[5];\n    BOOL done;\n    int index, is_zero, is_promise_any = (magic == PROMISE_MAGIC_any);\n    \n    if (!JS_IsObject(this_val))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    result_promise = js_new_promise_capability(ctx, resolving_funcs, this_val);\n    if (JS_IsException(result_promise))\n        return result_promise;\n    promise_resolve = JS_GetProperty(ctx, this_val, JS_ATOM_resolve);\n    if (JS_IsException(promise_resolve) ||\n        check_function(ctx, promise_resolve))\n        goto fail_reject;\n    iter = JS_GetIterator(ctx, argv[0], FALSE);\n    if (JS_IsException(iter)) {\n        JSValue error;\n    fail_reject:\n        error = JS_GetException(ctx);\n        ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED, 1,\n                       (JSValueConst *)&error);\n        JS_FreeValue(ctx, error);\n        if (JS_IsException(ret))\n            goto fail;\n        JS_FreeValue(ctx, ret);\n    } else {\n        next_method = JS_GetProperty(ctx, iter, JS_ATOM_next);\n        if (JS_IsException(next_method))\n            goto fail_reject;\n        values = JS_NewArray(ctx);\n        if (JS_IsException(values))\n            goto fail_reject;\n        resolve_element_env = JS_NewArray(ctx);\n        if (JS_IsException(resolve_element_env))\n            goto fail_reject;\n        /* remainingElementsCount field */\n        if (JS_DefinePropertyValueUint32(ctx, resolve_element_env, 0,\n                                         JS_NewInt32(ctx, 1),\n                                         JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE | JS_PROP_WRITABLE) < 0)\n            goto fail_reject;\n        \n        index = 0;\n        for(;;) {\n            /* XXX: conformance: should close the iterator if error on 'done'\n               access, but not on 'value' access */\n            item = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);\n            if (JS_IsException(item))\n                goto fail_reject;\n            if (done)\n                break;\n            next_promise = JS_Call(ctx, promise_resolve, \n                                   this_val, 1, (JSValueConst *)&item);\n            JS_FreeValue(ctx, item);\n            if (JS_IsException(next_promise)) {\n            fail_reject1:\n                JS_IteratorClose(ctx, iter, TRUE);\n                goto fail_reject;\n            }\n            resolve_element_data[0] = JS_NewBool(ctx, FALSE);\n            resolve_element_data[1] = (JSValueConst)JS_NewInt32(ctx, index);\n            resolve_element_data[2] = values;\n            resolve_element_data[3] = resolving_funcs[is_promise_any];\n            resolve_element_data[4] = resolve_element_env;\n            resolve_element =\n                JS_NewCFunctionData(ctx, js_promise_all_resolve_element, 1,\n                                    magic, 5, resolve_element_data);\n            if (JS_IsException(resolve_element)) {\n                JS_FreeValue(ctx, next_promise);\n                goto fail_reject1;\n            }\n            \n            if (magic == PROMISE_MAGIC_allSettled) {\n                reject_element =\n                    JS_NewCFunctionData(ctx, js_promise_all_resolve_element, 1,\n                                        magic | 4, 5, resolve_element_data);\n                if (JS_IsException(reject_element)) {\n                    JS_FreeValue(ctx, next_promise);\n                    goto fail_reject1;\n                }\n            } else if (magic == PROMISE_MAGIC_any) {\n                if (JS_DefinePropertyValueUint32(ctx, values, index,\n                                                 JS_UNDEFINED, JS_PROP_C_W_E) < 0)\n                    goto fail_reject1;\n                reject_element = resolve_element;\n                resolve_element = JS_DupValue(ctx, resolving_funcs[0]);\n            } else {\n                reject_element = JS_DupValue(ctx, resolving_funcs[1]);\n            }\n\n            if (remainingElementsCount_add(ctx, resolve_element_env, 1) < 0) {\n                JS_FreeValue(ctx, next_promise);\n                JS_FreeValue(ctx, resolve_element);\n                JS_FreeValue(ctx, reject_element);\n                goto fail_reject1;\n            }\n\n            then_args[0] = resolve_element;\n            then_args[1] = reject_element;\n            ret = JS_InvokeFree(ctx, next_promise, JS_ATOM_then, 2, then_args);\n            JS_FreeValue(ctx, resolve_element);\n            JS_FreeValue(ctx, reject_element);\n            if (check_exception_free(ctx, ret))\n                goto fail_reject1;\n            index++;\n        }\n\n        is_zero = remainingElementsCount_add(ctx, resolve_element_env, -1);\n        if (is_zero < 0)\n            goto fail_reject;\n        if (is_zero) {\n            if (magic == PROMISE_MAGIC_any) {\n                JSValue error;\n                error = js_aggregate_error_constructor(ctx, values);\n                if (JS_IsException(error))\n                    goto fail_reject;\n                JS_FreeValue(ctx, values);\n                values = error;\n            }\n            ret = JS_Call(ctx, resolving_funcs[is_promise_any], JS_UNDEFINED,\n                          1, (JSValueConst *)&values);\n            if (check_exception_free(ctx, ret))\n                goto fail_reject;\n        }\n    }\n done:\n    JS_FreeValue(ctx, promise_resolve);\n    JS_FreeValue(ctx, resolve_element_env);\n    JS_FreeValue(ctx, values);\n    JS_FreeValue(ctx, next_method);\n    JS_FreeValue(ctx, iter);\n    JS_FreeValue(ctx, resolving_funcs[0]);\n    JS_FreeValue(ctx, resolving_funcs[1]);\n    return result_promise;\n fail:\n    JS_FreeValue(ctx, result_promise);\n    result_promise = JS_EXCEPTION;\n    goto done;\n}\n\nstatic JSValue js_promise_race(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    JSValue result_promise, resolving_funcs[2], item, next_promise, ret;\n    JSValue next_method = JS_UNDEFINED, iter = JS_UNDEFINED;\n    JSValue promise_resolve = JS_UNDEFINED;\n    BOOL done;\n\n    if (!JS_IsObject(this_val))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    result_promise = js_new_promise_capability(ctx, resolving_funcs, this_val);\n    if (JS_IsException(result_promise))\n        return result_promise;\n    promise_resolve = JS_GetProperty(ctx, this_val, JS_ATOM_resolve);\n    if (JS_IsException(promise_resolve) ||\n        check_function(ctx, promise_resolve))\n        goto fail_reject;\n    iter = JS_GetIterator(ctx, argv[0], FALSE);\n    if (JS_IsException(iter)) {\n        JSValue error;\n    fail_reject:\n        error = JS_GetException(ctx);\n        ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED, 1,\n                       (JSValueConst *)&error);\n        JS_FreeValue(ctx, error);\n        if (JS_IsException(ret))\n            goto fail;\n        JS_FreeValue(ctx, ret);\n    } else {\n        next_method = JS_GetProperty(ctx, iter, JS_ATOM_next);\n        if (JS_IsException(next_method))\n            goto fail_reject;\n\n        for(;;) {\n            /* XXX: conformance: should close the iterator if error on 'done'\n               access, but not on 'value' access */\n            item = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);\n            if (JS_IsException(item))\n                goto fail_reject;\n            if (done)\n                break;\n            next_promise = JS_Call(ctx, promise_resolve,\n                                   this_val, 1, (JSValueConst *)&item);\n            JS_FreeValue(ctx, item);\n            if (JS_IsException(next_promise)) {\n            fail_reject1:\n                JS_IteratorClose(ctx, iter, TRUE);\n                goto fail_reject;\n            }\n            ret = JS_InvokeFree(ctx, next_promise, JS_ATOM_then, 2,\n                                (JSValueConst *)resolving_funcs);\n            if (check_exception_free(ctx, ret))\n                goto fail_reject1;\n        }\n    }\n done:\n    JS_FreeValue(ctx, promise_resolve);\n    JS_FreeValue(ctx, next_method);\n    JS_FreeValue(ctx, iter);\n    JS_FreeValue(ctx, resolving_funcs[0]);\n    JS_FreeValue(ctx, resolving_funcs[1]);\n    return result_promise;\n fail:\n    //JS_FreeValue(ctx, next_method); // why not???\n    JS_FreeValue(ctx, result_promise);\n    result_promise = JS_EXCEPTION;\n    goto done;\n}\n\nstatic __exception int perform_promise_then(JSContext *ctx,\n                                            JSValueConst promise,\n                                            JSValueConst *resolve_reject,\n                                            JSValueConst *cap_resolving_funcs)\n{\n    JSPromiseData *s = JS_GetOpaque(promise, JS_CLASS_PROMISE);\n    JSPromiseReactionData *rd_array[2], *rd;\n    int i, j;\n\n    rd_array[0] = NULL;\n    rd_array[1] = NULL;\n    for(i = 0; i < 2; i++) {\n        JSValueConst handler;\n        rd = js_mallocz(ctx, sizeof(*rd));\n        if (!rd) {\n            if (i == 1)\n                promise_reaction_data_free(ctx->rt, rd_array[0]);\n            return -1;\n        }\n        for(j = 0; j < 2; j++)\n            rd->resolving_funcs[j] = JS_DupValue(ctx, cap_resolving_funcs[j]);\n        handler = resolve_reject[i];\n        if (!JS_IsFunction(ctx, handler))\n            handler = JS_UNDEFINED;\n        rd->handler = JS_DupValue(ctx, handler);\n        rd_array[i] = rd;\n    }\n\n    if (s->promise_state == JS_PROMISE_PENDING) {\n        for(i = 0; i < 2; i++)\n            list_add_tail(&rd_array[i]->link, &s->promise_reactions[i]);\n    } else {\n        JSValueConst args[5];\n        if (s->promise_state == JS_PROMISE_REJECTED && !s->is_handled) {\n            JSRuntime *rt = ctx->rt;\n            if (rt->host_promise_rejection_tracker) {\n                rt->host_promise_rejection_tracker(ctx, promise, s->promise_result,\n                                                   TRUE, rt->host_promise_rejection_tracker_opaque);\n            }\n        }\n        i = s->promise_state - JS_PROMISE_FULFILLED;\n        rd = rd_array[i];\n        args[0] = rd->resolving_funcs[0];\n        args[1] = rd->resolving_funcs[1];\n        args[2] = rd->handler;\n        args[3] = JS_NewBool(ctx, i);\n        args[4] = s->promise_result;\n        JS_EnqueueJob(ctx, promise_reaction_job, 5, args);\n        for(i = 0; i < 2; i++)\n            promise_reaction_data_free(ctx->rt, rd_array[i]);\n    }\n    s->is_handled = TRUE;\n    return 0;\n}\n\nstatic JSValue js_promise_then(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    JSValue ctor, result_promise, resolving_funcs[2];\n    JSPromiseData *s;\n    int i, ret;\n\n    s = JS_GetOpaque2(ctx, this_val, JS_CLASS_PROMISE);\n    if (!s)\n        return JS_EXCEPTION;\n\n    ctor = JS_SpeciesConstructor(ctx, this_val, JS_UNDEFINED);\n    if (JS_IsException(ctor))\n        return ctor;\n    result_promise = js_new_promise_capability(ctx, resolving_funcs, ctor);\n    JS_FreeValue(ctx, ctor);\n    if (JS_IsException(result_promise))\n        return result_promise;\n    ret = perform_promise_then(ctx, this_val, argv,\n                               (JSValueConst *)resolving_funcs);\n    for(i = 0; i < 2; i++)\n        JS_FreeValue(ctx, resolving_funcs[i]);\n    if (ret) {\n        JS_FreeValue(ctx, result_promise);\n        return JS_EXCEPTION;\n    }\n    return result_promise;\n}\n\nstatic JSValue js_promise_catch(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    JSValueConst args[2];\n    args[0] = JS_UNDEFINED;\n    args[1] = argv[0];\n    return JS_Invoke(ctx, this_val, JS_ATOM_then, 2, args);\n}\n\nstatic JSValue js_promise_finally_value_thunk(JSContext *ctx, JSValueConst this_val,\n                                              int argc, JSValueConst *argv,\n                                              int magic, JSValue *func_data)\n{\n    return JS_DupValue(ctx, func_data[0]);\n}\n\nstatic JSValue js_promise_finally_thrower(JSContext *ctx, JSValueConst this_val,\n                                          int argc, JSValueConst *argv,\n                                          int magic, JSValue *func_data)\n{\n    return JS_Throw(ctx, JS_DupValue(ctx, func_data[0]));\n}\n\nstatic JSValue js_promise_then_finally_func(JSContext *ctx, JSValueConst this_val,\n                                            int argc, JSValueConst *argv,\n                                            int magic, JSValue *func_data)\n{\n    JSValueConst ctor = func_data[0];\n    JSValueConst onFinally = func_data[1];\n    JSValue res, promise, ret, then_func;\n\n    res = JS_Call(ctx, onFinally, JS_UNDEFINED, 0, NULL);\n    if (JS_IsException(res))\n        return res;\n    promise = js_promise_resolve(ctx, ctor, 1, (JSValueConst *)&res, 0);\n    JS_FreeValue(ctx, res);\n    if (JS_IsException(promise))\n        return promise;\n    if (magic == 0) {\n        then_func = JS_NewCFunctionData(ctx, js_promise_finally_value_thunk, 0,\n                                        0, 1, argv);\n    } else {\n        then_func = JS_NewCFunctionData(ctx, js_promise_finally_thrower, 0,\n                                        0, 1, argv);\n    }\n    if (JS_IsException(then_func)) {\n        JS_FreeValue(ctx, promise);\n        return then_func;\n    }\n    ret = JS_InvokeFree(ctx, promise, JS_ATOM_then, 1, (JSValueConst *)&then_func);\n    JS_FreeValue(ctx, then_func);\n    return ret;\n}\n\nstatic JSValue js_promise_finally(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    JSValueConst onFinally = argv[0];\n    JSValue ctor, ret;\n    JSValue then_funcs[2];\n    JSValueConst func_data[2];\n    int i;\n\n    ctor = JS_SpeciesConstructor(ctx, this_val, JS_UNDEFINED);\n    if (JS_IsException(ctor))\n        return ctor;\n    if (!JS_IsFunction(ctx, onFinally)) {\n        then_funcs[0] = JS_DupValue(ctx, onFinally);\n        then_funcs[1] = JS_DupValue(ctx, onFinally);\n    } else {\n        func_data[0] = ctor;\n        func_data[1] = onFinally;\n        for(i = 0; i < 2; i++) {\n            then_funcs[i] = JS_NewCFunctionData(ctx, js_promise_then_finally_func, 1, i, 2, func_data);\n            if (JS_IsException(then_funcs[i])) {\n                if (i == 1)\n                    JS_FreeValue(ctx, then_funcs[0]);\n                JS_FreeValue(ctx, ctor);\n                return JS_EXCEPTION;\n            }\n        }\n    }\n    JS_FreeValue(ctx, ctor);\n    ret = JS_Invoke(ctx, this_val, JS_ATOM_then, 2, (JSValueConst *)then_funcs);\n    JS_FreeValue(ctx, then_funcs[0]);\n    JS_FreeValue(ctx, then_funcs[1]);\n    return ret;\n}\n\nstatic const JSCFunctionListEntry js_promise_funcs[] = {\n    JS_CFUNC_MAGIC_DEF(\"resolve\", 1, js_promise_resolve, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"reject\", 1, js_promise_resolve, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"all\", 1, js_promise_all, PROMISE_MAGIC_all ),\n    JS_CFUNC_MAGIC_DEF(\"allSettled\", 1, js_promise_all, PROMISE_MAGIC_allSettled ),\n    JS_CFUNC_MAGIC_DEF(\"any\", 1, js_promise_all, PROMISE_MAGIC_any ),\n    JS_CFUNC_DEF(\"race\", 1, js_promise_race ),\n    //JS_CFUNC_DEF(\"__newPromiseCapability\", 1, js_promise___newPromiseCapability ),\n    JS_CGETSET_DEF(\"[Symbol.species]\", js_get_this, NULL),\n};\n\nstatic const JSCFunctionListEntry js_promise_proto_funcs[] = {\n    JS_CFUNC_DEF(\"then\", 2, js_promise_then ),\n    JS_CFUNC_DEF(\"catch\", 1, js_promise_catch ),\n    JS_CFUNC_DEF(\"finally\", 1, js_promise_finally ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"Promise\", JS_PROP_CONFIGURABLE ),\n};\n\n/* AsyncFunction */\nstatic const JSCFunctionListEntry js_async_function_proto_funcs[] = {\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"AsyncFunction\", JS_PROP_CONFIGURABLE ),\n};\n\nstatic JSValue js_async_from_sync_iterator_unwrap(JSContext *ctx,\n                                                  JSValueConst this_val,\n                                                  int argc, JSValueConst *argv,\n                                                  int magic, JSValue *func_data)\n{\n    return js_create_iterator_result(ctx, JS_DupValue(ctx, argv[0]),\n                                     JS_ToBool(ctx, func_data[0]));\n}\n\nstatic JSValue js_async_from_sync_iterator_unwrap_func_create(JSContext *ctx,\n                                                              BOOL done)\n{\n    JSValueConst func_data[1];\n\n    func_data[0] = (JSValueConst)JS_NewBool(ctx, done);\n    return JS_NewCFunctionData(ctx, js_async_from_sync_iterator_unwrap,\n                               1, 0, 1, func_data);\n}\n\n/* AsyncIteratorPrototype */\n\nstatic const JSCFunctionListEntry js_async_iterator_proto_funcs[] = {\n    JS_CFUNC_DEF(\"[Symbol.asyncIterator]\", 0, js_iterator_proto_iterator ),\n};\n\n/* AsyncFromSyncIteratorPrototype */\n\ntypedef struct JSAsyncFromSyncIteratorData {\n    JSValue sync_iter;\n    JSValue next_method;\n} JSAsyncFromSyncIteratorData;\n\nstatic void js_async_from_sync_iterator_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSAsyncFromSyncIteratorData *s =\n        JS_GetOpaque(val, JS_CLASS_ASYNC_FROM_SYNC_ITERATOR);\n    if (s) {\n        JS_FreeValueRT(rt, s->sync_iter);\n        JS_FreeValueRT(rt, s->next_method);\n        js_free_rt(rt, s);\n    }\n}\n\nstatic void js_async_from_sync_iterator_mark(JSRuntime *rt, JSValueConst val,\n                                             JS_MarkFunc *mark_func)\n{\n    JSAsyncFromSyncIteratorData *s =\n        JS_GetOpaque(val, JS_CLASS_ASYNC_FROM_SYNC_ITERATOR);\n    if (s) {\n        JS_MarkValue(rt, s->sync_iter, mark_func);\n        JS_MarkValue(rt, s->next_method, mark_func);\n    }\n}\n\nstatic JSValue JS_CreateAsyncFromSyncIterator(JSContext *ctx,\n                                              JSValueConst sync_iter)\n{\n    JSValue async_iter, next_method;\n    JSAsyncFromSyncIteratorData *s;\n\n    next_method = JS_GetProperty(ctx, sync_iter, JS_ATOM_next);\n    if (JS_IsException(next_method))\n        return JS_EXCEPTION;\n    async_iter = JS_NewObjectClass(ctx, JS_CLASS_ASYNC_FROM_SYNC_ITERATOR);\n    if (JS_IsException(async_iter)) {\n        JS_FreeValue(ctx, next_method);\n        return async_iter;\n    }\n    s = js_mallocz(ctx, sizeof(*s));\n    if (!s) {\n        JS_FreeValue(ctx, async_iter);\n        JS_FreeValue(ctx, next_method);\n        return JS_EXCEPTION;\n    }\n    s->sync_iter = JS_DupValue(ctx, sync_iter);\n    s->next_method = next_method;\n    JS_SetOpaque(async_iter, s);\n    return async_iter;\n}\n\nstatic JSValue js_async_from_sync_iterator_next(JSContext *ctx, JSValueConst this_val,\n                                                int argc, JSValueConst *argv,\n                                                int magic)\n{\n    JSValue promise, resolving_funcs[2], value, err, method;\n    JSAsyncFromSyncIteratorData *s;\n    int done;\n    int is_reject;\n\n    promise = JS_NewPromiseCapability(ctx, resolving_funcs);\n    if (JS_IsException(promise))\n        return JS_EXCEPTION;\n    s = JS_GetOpaque(this_val, JS_CLASS_ASYNC_FROM_SYNC_ITERATOR);\n    if (!s) {\n        JS_ThrowTypeError(ctx, \"not an Async-from-Sync Iterator\");\n        goto reject;\n    }\n\n    if (magic == GEN_MAGIC_NEXT) {\n        method = JS_DupValue(ctx, s->next_method);\n    } else {\n        method = JS_GetProperty(ctx, s->sync_iter,\n                                magic == GEN_MAGIC_RETURN ? JS_ATOM_return :\n                                JS_ATOM_throw);\n        if (JS_IsException(method))\n            goto reject;\n        if (JS_IsUndefined(method) || JS_IsNull(method)) {\n            if (magic == GEN_MAGIC_RETURN) {\n                err = js_create_iterator_result(ctx, JS_DupValue(ctx, argv[0]), TRUE);\n                is_reject = 0;\n            } else {\n                err = JS_DupValue(ctx, argv[0]);\n                is_reject = 1;\n            }\n            goto done_resolve;\n        }\n    }\n    value = JS_IteratorNext2(ctx, s->sync_iter, method,\n                             argc >= 1 ? 1 : 0, argv, &done);\n    JS_FreeValue(ctx, method);\n    if (JS_IsException(value))\n        goto reject;\n    if (done == 2) {\n        JSValue obj = value;\n        value = JS_IteratorGetCompleteValue(ctx, obj, &done);\n        JS_FreeValue(ctx, obj);\n        if (JS_IsException(value))\n            goto reject;\n    }\n\n    if (JS_IsException(value)) {\n        JSValue res2;\n    reject:\n        err = JS_GetException(ctx);\n        is_reject = 1;\n    done_resolve:\n        res2 = JS_Call(ctx, resolving_funcs[is_reject], JS_UNDEFINED,\n                       1, (JSValueConst *)&err);\n        JS_FreeValue(ctx, err);\n        JS_FreeValue(ctx, res2);\n        JS_FreeValue(ctx, resolving_funcs[0]);\n        JS_FreeValue(ctx, resolving_funcs[1]);\n        return promise;\n    }\n    {\n        JSValue value_wrapper_promise, resolve_reject[2];\n        int res;\n\n        value_wrapper_promise = js_promise_resolve(ctx, ctx->promise_ctor,\n                                                   1, (JSValueConst *)&value, 0);\n        if (JS_IsException(value_wrapper_promise)) {\n            JS_FreeValue(ctx, value);\n            goto reject;\n        }\n\n        resolve_reject[0] =\n            js_async_from_sync_iterator_unwrap_func_create(ctx, done);\n        if (JS_IsException(resolve_reject[0])) {\n            JS_FreeValue(ctx, value_wrapper_promise);\n            goto fail;\n        }\n        JS_FreeValue(ctx, value);\n        resolve_reject[1] = JS_UNDEFINED;\n\n        res = perform_promise_then(ctx, value_wrapper_promise,\n                                   (JSValueConst *)resolve_reject,\n                                   (JSValueConst *)resolving_funcs);\n        JS_FreeValue(ctx, resolve_reject[0]);\n        JS_FreeValue(ctx, value_wrapper_promise);\n        JS_FreeValue(ctx, resolving_funcs[0]);\n        JS_FreeValue(ctx, resolving_funcs[1]);\n        if (res) {\n            JS_FreeValue(ctx, promise);\n            return JS_EXCEPTION;\n        }\n    }\n    return promise;\n fail:\n    JS_FreeValue(ctx, value);\n    JS_FreeValue(ctx, resolving_funcs[0]);\n    JS_FreeValue(ctx, resolving_funcs[1]);\n    JS_FreeValue(ctx, promise);\n    return JS_EXCEPTION;\n}\n\nstatic const JSCFunctionListEntry js_async_from_sync_iterator_proto_funcs[] = {\n    JS_CFUNC_MAGIC_DEF(\"next\", 1, js_async_from_sync_iterator_next, GEN_MAGIC_NEXT ),\n    JS_CFUNC_MAGIC_DEF(\"return\", 1, js_async_from_sync_iterator_next, GEN_MAGIC_RETURN ),\n    JS_CFUNC_MAGIC_DEF(\"throw\", 1, js_async_from_sync_iterator_next, GEN_MAGIC_THROW ),\n};\n\n/* AsyncGeneratorFunction */\n\nstatic const JSCFunctionListEntry js_async_generator_function_proto_funcs[] = {\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"AsyncGeneratorFunction\", JS_PROP_CONFIGURABLE ),\n};\n\n/* AsyncGenerator prototype */\n\nstatic const JSCFunctionListEntry js_async_generator_proto_funcs[] = {\n    JS_CFUNC_MAGIC_DEF(\"next\", 1, js_async_generator_next, GEN_MAGIC_NEXT ),\n    JS_CFUNC_MAGIC_DEF(\"return\", 1, js_async_generator_next, GEN_MAGIC_RETURN ),\n    JS_CFUNC_MAGIC_DEF(\"throw\", 1, js_async_generator_next, GEN_MAGIC_THROW ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"AsyncGenerator\", JS_PROP_CONFIGURABLE ),\n};\n\nstatic JSClassShortDef const js_async_class_def[] = {\n    { JS_ATOM_Promise, js_promise_finalizer, js_promise_mark },                      /* JS_CLASS_PROMISE */\n    { JS_ATOM_PromiseResolveFunction, js_promise_resolve_function_finalizer, js_promise_resolve_function_mark }, /* JS_CLASS_PROMISE_RESOLVE_FUNCTION */\n    { JS_ATOM_PromiseRejectFunction, js_promise_resolve_function_finalizer, js_promise_resolve_function_mark }, /* JS_CLASS_PROMISE_REJECT_FUNCTION */\n    { JS_ATOM_AsyncFunction, js_bytecode_function_finalizer, js_bytecode_function_mark },  /* JS_CLASS_ASYNC_FUNCTION */\n    { JS_ATOM_AsyncFunctionResolve, js_async_function_resolve_finalizer, js_async_function_resolve_mark }, /* JS_CLASS_ASYNC_FUNCTION_RESOLVE */\n    { JS_ATOM_AsyncFunctionReject, js_async_function_resolve_finalizer, js_async_function_resolve_mark }, /* JS_CLASS_ASYNC_FUNCTION_REJECT */\n    { JS_ATOM_empty_string, js_async_from_sync_iterator_finalizer, js_async_from_sync_iterator_mark }, /* JS_CLASS_ASYNC_FROM_SYNC_ITERATOR */\n    { JS_ATOM_AsyncGeneratorFunction, js_bytecode_function_finalizer, js_bytecode_function_mark },  /* JS_CLASS_ASYNC_GENERATOR_FUNCTION */\n    { JS_ATOM_AsyncGenerator, js_async_generator_finalizer, js_async_generator_mark },  /* JS_CLASS_ASYNC_GENERATOR */\n};\n\nvoid JS_AddIntrinsicPromise(JSContext *ctx)\n{\n    JSRuntime *rt = ctx->rt;\n    JSValue obj1;\n\n    if (!JS_IsRegisteredClass(rt, JS_CLASS_PROMISE)) {\n        init_class_range(rt, js_async_class_def, JS_CLASS_PROMISE,\n                         countof(js_async_class_def));\n        rt->class_array[JS_CLASS_PROMISE_RESOLVE_FUNCTION].call = js_promise_resolve_function_call;\n        rt->class_array[JS_CLASS_PROMISE_REJECT_FUNCTION].call = js_promise_resolve_function_call;\n        rt->class_array[JS_CLASS_ASYNC_FUNCTION].call = js_async_function_call;\n        rt->class_array[JS_CLASS_ASYNC_FUNCTION_RESOLVE].call = js_async_function_resolve_call;\n        rt->class_array[JS_CLASS_ASYNC_FUNCTION_REJECT].call = js_async_function_resolve_call;\n        rt->class_array[JS_CLASS_ASYNC_GENERATOR_FUNCTION].call = js_async_generator_function_call;\n    }\n\n    /* Promise */\n    ctx->class_proto[JS_CLASS_PROMISE] = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_PROMISE],\n                               js_promise_proto_funcs,\n                               countof(js_promise_proto_funcs));\n    obj1 = JS_NewCFunction2(ctx, js_promise_constructor, \"Promise\", 1,\n                            JS_CFUNC_constructor, 0);\n    ctx->promise_ctor = JS_DupValue(ctx, obj1);\n    JS_SetPropertyFunctionList(ctx, obj1,\n                               js_promise_funcs,\n                               countof(js_promise_funcs));\n    JS_NewGlobalCConstructor2(ctx, obj1, \"Promise\",\n                              ctx->class_proto[JS_CLASS_PROMISE]);\n\n    /* AsyncFunction */\n    ctx->class_proto[JS_CLASS_ASYNC_FUNCTION] = JS_NewObjectProto(ctx, ctx->function_proto);\n    obj1 = JS_NewCFunction3(ctx, (JSCFunction *)js_function_constructor,\n                            \"AsyncFunction\", 1,\n                            JS_CFUNC_constructor_or_func_magic, JS_FUNC_ASYNC,\n                            ctx->function_ctor);\n    JS_SetPropertyFunctionList(ctx,\n                               ctx->class_proto[JS_CLASS_ASYNC_FUNCTION],\n                               js_async_function_proto_funcs,\n                               countof(js_async_function_proto_funcs));\n    JS_SetConstructor2(ctx, obj1, ctx->class_proto[JS_CLASS_ASYNC_FUNCTION],\n                       0, JS_PROP_CONFIGURABLE);\n    JS_FreeValue(ctx, obj1);\n\n    /* AsyncIteratorPrototype */\n    ctx->async_iterator_proto = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, ctx->async_iterator_proto,\n                               js_async_iterator_proto_funcs,\n                               countof(js_async_iterator_proto_funcs));\n\n    /* AsyncFromSyncIteratorPrototype */\n    ctx->class_proto[JS_CLASS_ASYNC_FROM_SYNC_ITERATOR] =\n        JS_NewObjectProto(ctx, ctx->async_iterator_proto);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ASYNC_FROM_SYNC_ITERATOR],\n                               js_async_from_sync_iterator_proto_funcs,\n                               countof(js_async_from_sync_iterator_proto_funcs));\n\n    /* AsyncGeneratorPrototype */\n    ctx->class_proto[JS_CLASS_ASYNC_GENERATOR] =\n        JS_NewObjectProto(ctx, ctx->async_iterator_proto);\n    JS_SetPropertyFunctionList(ctx,\n                               ctx->class_proto[JS_CLASS_ASYNC_GENERATOR],\n                               js_async_generator_proto_funcs,\n                               countof(js_async_generator_proto_funcs));\n\n    /* AsyncGeneratorFunction */\n    ctx->class_proto[JS_CLASS_ASYNC_GENERATOR_FUNCTION] =\n        JS_NewObjectProto(ctx, ctx->function_proto);\n    obj1 = JS_NewCFunction3(ctx, (JSCFunction *)js_function_constructor,\n                            \"AsyncGeneratorFunction\", 1,\n                            JS_CFUNC_constructor_or_func_magic,\n                            JS_FUNC_ASYNC_GENERATOR,\n                            ctx->function_ctor);\n    JS_SetPropertyFunctionList(ctx,\n                               ctx->class_proto[JS_CLASS_ASYNC_GENERATOR_FUNCTION],\n                               js_async_generator_function_proto_funcs,\n                               countof(js_async_generator_function_proto_funcs));\n    JS_SetConstructor2(ctx, ctx->class_proto[JS_CLASS_ASYNC_GENERATOR_FUNCTION],\n                       ctx->class_proto[JS_CLASS_ASYNC_GENERATOR],\n                       JS_PROP_CONFIGURABLE, JS_PROP_CONFIGURABLE);\n    JS_SetConstructor2(ctx, obj1, ctx->class_proto[JS_CLASS_ASYNC_GENERATOR_FUNCTION],\n                       0, JS_PROP_CONFIGURABLE);\n    JS_FreeValue(ctx, obj1);\n}\n\n/* URI handling */\n\nstatic int string_get_hex(JSString *p, int k, int n) {\n    int c = 0, h;\n    while (n-- > 0) {\n        if ((h = from_hex(string_get(p, k++))) < 0)\n            return -1;\n        c = (c << 4) | h;\n    }\n    return c;\n}\n\nstatic int isURIReserved(int c) {\n    return c < 0x100 && memchr(\";/?:@&=+$,#\", c, sizeof(\";/?:@&=+$,#\") - 1) != NULL;\n}\n\nstatic int __attribute__((format(printf, 2, 3))) js_throw_URIError(JSContext *ctx, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    JS_ThrowError(ctx, JS_URI_ERROR, fmt, ap);\n    va_end(ap);\n    return -1;\n}\n\nstatic int hex_decode(JSContext *ctx, JSString *p, int k) {\n    int c;\n\n    if (k >= p->len || string_get(p, k) != '%')\n        return js_throw_URIError(ctx, \"expecting %%\");\n    if (k + 2 >= p->len || (c = string_get_hex(p, k + 1, 2)) < 0)\n        return js_throw_URIError(ctx, \"expecting hex digit\");\n\n    return c;\n}\n\nstatic JSValue js_global_decodeURI(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv, int isComponent)\n{\n    JSValue str;\n    StringBuffer b_s, *b = &b_s;\n    JSString *p;\n    int k, c, c1, n, c_min;\n\n    str = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(str))\n        return str;\n\n    string_buffer_init(ctx, b, 0);\n\n    p = JS_VALUE_GET_STRING(str);\n    for (k = 0; k < p->len;) {\n        c = string_get(p, k);\n        if (c == '%') {\n            c = hex_decode(ctx, p, k);\n            if (c < 0)\n                goto fail;\n            k += 3;\n            if (c < 0x80) {\n                if (!isComponent && isURIReserved(c)) {\n                    c = '%';\n                    k -= 2;\n                }\n            } else {\n                /* Decode URI-encoded UTF-8 sequence */\n                if (c >= 0xc0 && c <= 0xdf) {\n                    n = 1;\n                    c_min = 0x80;\n                    c &= 0x1f;\n                } else if (c >= 0xe0 && c <= 0xef) {\n                    n = 2;\n                    c_min = 0x800;\n                    c &= 0xf;\n                } else if (c >= 0xf0 && c <= 0xf7) {\n                    n = 3;\n                    c_min = 0x10000;\n                    c &= 0x7;\n                } else {\n                    n = 0;\n                    c_min = 1;\n                    c = 0;\n                }\n                while (n-- > 0) {\n                    c1 = hex_decode(ctx, p, k);\n                    if (c1 < 0)\n                        goto fail;\n                    k += 3;\n                    if ((c1 & 0xc0) != 0x80) {\n                        c = 0;\n                        break;\n                    }\n                    c = (c << 6) | (c1 & 0x3f);\n                }\n                if (c < c_min || c > 0x10FFFF ||\n                    (c >= 0xd800 && c < 0xe000)) {\n                    js_throw_URIError(ctx, \"malformed UTF-8\");\n                    goto fail;\n                }\n            }\n        } else {\n            k++;\n        }\n        string_buffer_putc(b, c);\n    }\n    JS_FreeValue(ctx, str);\n    return string_buffer_end(b);\n\nfail:\n    JS_FreeValue(ctx, str);\n    string_buffer_free(b);\n    return JS_EXCEPTION;\n}\n\nstatic int isUnescaped(int c) {\n    static char const unescaped_chars[] =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        \"abcdefghijklmnopqrstuvwxyz\"\n        \"0123456789\"\n        \"@*_+-./\";\n    return c < 0x100 &&\n        memchr(unescaped_chars, c, sizeof(unescaped_chars) - 1);\n}\n\nstatic int isURIUnescaped(int c, int isComponent) {\n    return c < 0x100 &&\n        ((c >= 0x61 && c <= 0x7a) ||\n         (c >= 0x41 && c <= 0x5a) ||\n         (c >= 0x30 && c <= 0x39) ||\n         memchr(\"-_.!~*'()\", c, sizeof(\"-_.!~*'()\") - 1) != NULL ||\n         (!isComponent && isURIReserved(c)));\n}\n\nstatic int encodeURI_hex(StringBuffer *b, int c) {\n    uint8_t buf[6];\n    int n = 0;\n    const char *hex = \"0123456789ABCDEF\";\n\n    buf[n++] = '%';\n    if (c >= 256) {\n        buf[n++] = 'u';\n        buf[n++] = hex[(c >> 12) & 15];\n        buf[n++] = hex[(c >>  8) & 15];\n    }\n    buf[n++] = hex[(c >> 4) & 15];\n    buf[n++] = hex[(c >> 0) & 15];\n    return string_buffer_write8(b, buf, n);\n}\n\nstatic JSValue js_global_encodeURI(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv,\n                                   int isComponent)\n{\n    JSValue str;\n    StringBuffer b_s, *b = &b_s;\n    JSString *p;\n    int k, c, c1;\n\n    str = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(str))\n        return str;\n\n    p = JS_VALUE_GET_STRING(str);\n    string_buffer_init(ctx, b, p->len);\n    for (k = 0; k < p->len;) {\n        c = string_get(p, k);\n        k++;\n        if (isURIUnescaped(c, isComponent)) {\n            string_buffer_putc16(b, c);\n        } else {\n            if (c >= 0xdc00 && c <= 0xdfff) {\n                js_throw_URIError(ctx, \"invalid character\");\n                goto fail;\n            } else if (c >= 0xd800 && c <= 0xdbff) {\n                if (k >= p->len) {\n                    js_throw_URIError(ctx, \"expecting surrogate pair\");\n                    goto fail;\n                }\n                c1 = string_get(p, k);\n                k++;\n                if (c1 < 0xdc00 || c1 > 0xdfff) {\n                    js_throw_URIError(ctx, \"expecting surrogate pair\");\n                    goto fail;\n                }\n                c = (((c & 0x3ff) << 10) | (c1 & 0x3ff)) + 0x10000;\n            }\n            if (c < 0x80) {\n                encodeURI_hex(b, c);\n            } else {\n                /* XXX: use C UTF-8 conversion ? */\n                if (c < 0x800) {\n                    encodeURI_hex(b, (c >> 6) | 0xc0);\n                } else {\n                    if (c < 0x10000) {\n                        encodeURI_hex(b, (c >> 12) | 0xe0);\n                    } else {\n                        encodeURI_hex(b, (c >> 18) | 0xf0);\n                        encodeURI_hex(b, ((c >> 12) & 0x3f) | 0x80);\n                    }\n                    encodeURI_hex(b, ((c >> 6) & 0x3f) | 0x80);\n                }\n                encodeURI_hex(b, (c & 0x3f) | 0x80);\n            }\n        }\n    }\n    JS_FreeValue(ctx, str);\n    return string_buffer_end(b);\n\nfail:\n    JS_FreeValue(ctx, str);\n    string_buffer_free(b);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_global_escape(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    JSValue str;\n    StringBuffer b_s, *b = &b_s;\n    JSString *p;\n    int i, len, c;\n\n    str = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(str))\n        return str;\n\n    p = JS_VALUE_GET_STRING(str);\n    string_buffer_init(ctx, b, p->len);\n    for (i = 0, len = p->len; i < len; i++) {\n        c = string_get(p, i);\n        if (isUnescaped(c)) {\n            string_buffer_putc16(b, c);\n        } else {\n            encodeURI_hex(b, c);\n        }\n    }\n    JS_FreeValue(ctx, str);\n    return string_buffer_end(b);\n}\n\nstatic JSValue js_global_unescape(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    JSValue str;\n    StringBuffer b_s, *b = &b_s;\n    JSString *p;\n    int i, len, c, n;\n\n    str = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(str))\n        return str;\n\n    string_buffer_init(ctx, b, 0);\n    p = JS_VALUE_GET_STRING(str);\n    for (i = 0, len = p->len; i < len; i++) {\n        c = string_get(p, i);\n        if (c == '%') {\n            if (i + 6 <= len\n            &&  string_get(p, i + 1) == 'u'\n            &&  (n = string_get_hex(p, i + 2, 4)) >= 0) {\n                c = n;\n                i += 6 - 1;\n            } else\n            if (i + 3 <= len\n            &&  (n = string_get_hex(p, i + 1, 2)) >= 0) {\n                c = n;\n                i += 3 - 1;\n            }\n        }\n        string_buffer_putc16(b, c);\n    }\n    JS_FreeValue(ctx, str);\n    return string_buffer_end(b);\n}\n\n/* global object */\n\nstatic const JSCFunctionListEntry js_global_funcs[] = {\n    JS_CFUNC_DEF(\"parseInt\", 2, js_parseInt ),\n    JS_CFUNC_DEF(\"parseFloat\", 1, js_parseFloat ),\n    JS_CFUNC_DEF(\"isNaN\", 1, js_global_isNaN ),\n    JS_CFUNC_DEF(\"isFinite\", 1, js_global_isFinite ),\n\n    JS_CFUNC_MAGIC_DEF(\"decodeURI\", 1, js_global_decodeURI, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"decodeURIComponent\", 1, js_global_decodeURI, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"encodeURI\", 1, js_global_encodeURI, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"encodeURIComponent\", 1, js_global_encodeURI, 1 ),\n    JS_CFUNC_DEF(\"escape\", 1, js_global_escape ),\n    JS_CFUNC_DEF(\"unescape\", 1, js_global_unescape ),\n    JS_PROP_DOUBLE_DEF(\"Infinity\", 1.0 / 0.0, 0 ),\n    JS_PROP_DOUBLE_DEF(\"NaN\", NAN, 0 ),\n    JS_PROP_UNDEFINED_DEF(\"undefined\", 0 ),\n\n    /* for the 'Date' implementation */\n    JS_CFUNC_DEF(\"__date_clock\", 0, js___date_clock ),\n    //JS_CFUNC_DEF(\"__date_now\", 0, js___date_now ),\n    //JS_CFUNC_DEF(\"__date_getTimezoneOffset\", 1, js___date_getTimezoneOffset ),\n    //JS_CFUNC_DEF(\"__date_create\", 3, js___date_create ),\n};\n\n/* Date */\n\nstatic int64_t math_mod(int64_t a, int64_t b) {\n    /* return positive modulo */\n    int64_t m = a % b;\n    return m + (m < 0) * b;\n}\n\nstatic int64_t floor_div(int64_t a, int64_t b) {\n    /* integer division rounding toward -Infinity */\n    int64_t m = a % b;\n    return (a - (m + (m < 0) * b)) / b;\n}\n\nstatic JSValue js_Date_parse(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv);\n\nstatic __exception int JS_ThisTimeValue(JSContext *ctx, double *valp, JSValueConst this_val)\n{\n    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(this_val);\n        if (p->class_id == JS_CLASS_DATE && JS_IsNumber(p->u.object_data))\n            return JS_ToFloat64(ctx, valp, p->u.object_data);\n    }\n    JS_ThrowTypeError(ctx, \"not a Date object\");\n    return -1;\n}\n\nstatic JSValue JS_SetThisTimeValue(JSContext *ctx, JSValueConst this_val, double v)\n{\n    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(this_val);\n        if (p->class_id == JS_CLASS_DATE) {\n            JS_FreeValue(ctx, p->u.object_data);\n            p->u.object_data = JS_NewFloat64(ctx, v);\n            return JS_DupValue(ctx, p->u.object_data);\n        }\n    }\n    return JS_ThrowTypeError(ctx, \"not a Date object\");\n}\n\nstatic int64_t days_from_year(int64_t y) {\n    return 365 * (y - 1970) + floor_div(y - 1969, 4) -\n        floor_div(y - 1901, 100) + floor_div(y - 1601, 400);\n}\n\nstatic int64_t days_in_year(int64_t y) {\n    return 365 + !(y % 4) - !(y % 100) + !(y % 400);\n}\n\n/* return the year, update days */\nstatic int64_t year_from_days(int64_t *days) {\n    int64_t y, d1, nd, d = *days;\n    y = floor_div(d * 10000, 3652425) + 1970;\n    /* the initial approximation is very good, so only a few\n       iterations are necessary */\n    for(;;) {\n        d1 = d - days_from_year(y);\n        if (d1 < 0) {\n            y--;\n            d1 += days_in_year(y);\n        } else {\n            nd = days_in_year(y);\n            if (d1 < nd)\n                break;\n            d1 -= nd;\n            y++;\n        }\n    }\n    *days = d1;\n    return y;\n}\n\nstatic int const month_days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\nstatic char const month_names[] = \"JanFebMarAprMayJunJulAugSepOctNovDec\";\nstatic char const day_names[] = \"SunMonTueWedThuFriSat\";\n\nstatic __exception int get_date_fields(JSContext *ctx, JSValueConst obj,\n                                       double fields[9], int is_local, int force)\n{\n    double dval;\n    int64_t d, days, wd, y, i, md, h, m, s, ms, tz = 0;\n\n    if (JS_ThisTimeValue(ctx, &dval, obj))\n        return -1;\n\n    if (isnan(dval)) {\n        if (!force)\n            return FALSE; /* NaN */\n        d = 0;        /* initialize all fields to 0 */\n    } else {\n        d = dval;\n        if (is_local) {\n            tz = -getTimezoneOffset(d);\n            d += tz * 60000;\n        }\n    }\n\n    /* result is >= 0, we can use % */\n    h = math_mod(d, 86400000);\n    days = (d - h) / 86400000;\n    ms = h % 1000;\n    h = (h - ms) / 1000;\n    s = h % 60;\n    h = (h - s) / 60;\n    m = h % 60;\n    h = (h - m) / 60;\n    wd = math_mod(days + 4, 7); /* week day */\n    y = year_from_days(&days);\n\n    for(i = 0; i < 11; i++) {\n        md = month_days[i];\n        if (i == 1)\n            md += days_in_year(y) - 365;\n        if (days < md)\n            break;\n        days -= md;\n    }\n    fields[0] = y;\n    fields[1] = i;\n    fields[2] = days + 1;\n    fields[3] = h;\n    fields[4] = m;\n    fields[5] = s;\n    fields[6] = ms;\n    fields[7] = wd;\n    fields[8] = tz;\n    return TRUE;\n}\n\nstatic double time_clip(double t) {\n    if (t >= -8.64e15 && t <= 8.64e15)\n        return trunc(t) + 0.0;  /* convert -0 to +0 */\n    else\n        return NAN;\n}\n\n/* The spec mandates the use of 'double' and it fixes the order\n   of the operations */\nstatic double set_date_fields(double fields[], int is_local) {\n    int64_t y;\n    double days, d, h, m1;\n    int i, m, md;\n    \n    m1 = fields[1];\n    m = fmod(m1, 12);\n    if (m < 0)\n        m += 12;\n    y = (int64_t)(fields[0] + floor(m1 / 12));\n    days = days_from_year(y);\n\n    for(i = 0; i < m; i++) {\n        md = month_days[i];\n        if (i == 1)\n            md += days_in_year(y) - 365;\n        days += md;\n    }\n    days += fields[2] - 1;\n    h = fields[3] * 3600000 + fields[4] * 60000 + \n        fields[5] * 1000 + fields[6];\n    d = days * 86400000 + h;\n    if (is_local)\n        d += getTimezoneOffset(d) * 60000;\n    return time_clip(d);\n}\n\nstatic JSValue get_date_field(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv, int magic)\n{\n    // get_date_field(obj, n, is_local)\n    double fields[9];\n    int res, n, is_local;\n\n    is_local = magic & 0x0F;\n    n = (magic >> 4) & 0x0F;\n    res = get_date_fields(ctx, this_val, fields, is_local, 0);\n    if (res < 0)\n        return JS_EXCEPTION;\n    if (!res)\n        return JS_NAN;\n\n    if (magic & 0x100) {    // getYear\n        fields[0] -= 1900;\n    }\n    return JS_NewFloat64(ctx, fields[n]);\n}\n\nstatic JSValue set_date_field(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv, int magic)\n{\n    // _field(obj, first_field, end_field, args, is_local)\n    double fields[9];\n    int res, first_field, end_field, is_local, i, n;\n    double d, a;\n\n    d = NAN;\n    first_field = (magic >> 8) & 0x0F;\n    end_field = (magic >> 4) & 0x0F;\n    is_local = magic & 0x0F;\n\n    res = get_date_fields(ctx, this_val, fields, is_local, first_field == 0);\n    if (res < 0)\n        return JS_EXCEPTION;\n    if (res && argc > 0) {\n        n = end_field - first_field;\n        if (argc < n)\n            n = argc;\n        for(i = 0; i < n; i++) {\n            if (JS_ToFloat64(ctx, &a, argv[i]))\n                return JS_EXCEPTION;\n            if (!isfinite(a))\n                goto done;\n            fields[first_field + i] = trunc(a);\n        }\n        d = set_date_fields(fields, is_local);\n    }\ndone:\n    return JS_SetThisTimeValue(ctx, this_val, d);\n}\n\n/* fmt:\n   0: toUTCString: \"Tue, 02 Jan 2018 23:04:46 GMT\"\n   1: toString: \"Wed Jan 03 2018 00:05:22 GMT+0100 (CET)\"\n   2: toISOString: \"2018-01-02T23:02:56.927Z\"\n   3: toLocaleString: \"1/2/2018, 11:40:40 PM\"\n   part: 1=date, 2=time 3=all\n   XXX: should use a variant of strftime().\n */\nstatic JSValue get_date_string(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv, int magic)\n{\n    // _string(obj, fmt, part)\n    char buf[64];\n    double fields[9];\n    int res, fmt, part, pos;\n    int y, mon, d, h, m, s, ms, wd, tz;\n\n    fmt = (magic >> 4) & 0x0F;\n    part = magic & 0x0F;\n\n    res = get_date_fields(ctx, this_val, fields, fmt & 1, 0);\n    if (res < 0)\n        return JS_EXCEPTION;\n    if (!res) {\n        if (fmt == 2)\n            return JS_ThrowRangeError(ctx, \"Date value is NaN\");\n        else\n            return JS_NewString(ctx, \"Invalid Date\");\n    }\n\n    y = fields[0];\n    mon = fields[1];\n    d = fields[2];\n    h = fields[3];\n    m = fields[4];\n    s = fields[5];\n    ms = fields[6];\n    wd = fields[7];\n    tz = fields[8];\n\n    pos = 0;\n\n    if (part & 1) { /* date part */\n        switch(fmt) {\n        case 0:\n            pos += snprintf(buf + pos, sizeof(buf) - pos,\n                            \"%.3s, %02d %.3s %0*d \",\n                            day_names + wd * 3, d,\n                            month_names + mon * 3, 4 + (y < 0), y);\n            break;\n        case 1:\n            pos += snprintf(buf + pos, sizeof(buf) - pos,\n                            \"%.3s %.3s %02d %0*d\",\n                            day_names + wd * 3,\n                            month_names + mon * 3, d, 4 + (y < 0), y);\n            if (part == 3) {\n                buf[pos++] = ' ';\n            }\n            break;\n        case 2:\n            if (y >= 0 && y <= 9999) {\n                pos += snprintf(buf + pos, sizeof(buf) - pos,\n                                \"%04d\", y);\n            } else {\n                pos += snprintf(buf + pos, sizeof(buf) - pos,\n                                \"%+07d\", y);\n            }\n            pos += snprintf(buf + pos, sizeof(buf) - pos,\n                            \"-%02d-%02dT\", mon + 1, d);\n            break;\n        case 3:\n            pos += snprintf(buf + pos, sizeof(buf) - pos,\n                            \"%02d/%02d/%0*d\", mon + 1, d, 4 + (y < 0), y);\n            if (part == 3) {\n                buf[pos++] = ',';\n                buf[pos++] = ' ';\n            }\n            break;\n        }\n    }\n    if (part & 2) { /* time part */\n        switch(fmt) {\n        case 0:\n            pos += snprintf(buf + pos, sizeof(buf) - pos,\n                            \"%02d:%02d:%02d GMT\", h, m, s);\n            break;\n        case 1:\n            pos += snprintf(buf + pos, sizeof(buf) - pos,\n                            \"%02d:%02d:%02d GMT\", h, m, s);\n            if (tz < 0) {\n                buf[pos++] = '-';\n                tz = -tz;\n            } else {\n                buf[pos++] = '+';\n            }\n            /* tz is >= 0, can use % */\n            pos += snprintf(buf + pos, sizeof(buf) - pos,\n                            \"%02d%02d\", tz / 60, tz % 60);\n            /* XXX: tack the time zone code? */\n            break;\n        case 2:\n            pos += snprintf(buf + pos, sizeof(buf) - pos,\n                            \"%02d:%02d:%02d.%03dZ\", h, m, s, ms);\n            break;\n        case 3:\n            pos += snprintf(buf + pos, sizeof(buf) - pos,\n                            \"%02d:%02d:%02d %cM\", (h + 1) % 12 - 1, m, s,\n                            (h < 12) ? 'A' : 'P');\n            break;\n        }\n    }\n    return JS_NewStringLen(ctx, buf, pos);\n}\n\n/* OS dependent: return the UTC time in ms since 1970. */\nstatic int64_t date_now(void) {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return (int64_t)tv.tv_sec * 1000 + (tv.tv_usec / 1000);\n}\n\nstatic JSValue js_date_constructor(JSContext *ctx, JSValueConst new_target,\n                                   int argc, JSValueConst *argv)\n{\n    // Date(y, mon, d, h, m, s, ms)\n    JSValue rv;\n    int i, n;\n    double a, val;\n\n    if (JS_IsUndefined(new_target)) {\n        /* invoked as function */\n        argc = 0;\n    }\n    n = argc;\n    if (n == 0) {\n        val = date_now();\n    } else if (n == 1) {\n        JSValue v, dv;\n        if (JS_VALUE_GET_TAG(argv[0]) == JS_TAG_OBJECT) {\n            JSObject *p = JS_VALUE_GET_OBJ(argv[0]);\n            if (p->class_id == JS_CLASS_DATE && JS_IsNumber(p->u.object_data)) {\n                if (JS_ToFloat64(ctx, &val, p->u.object_data))\n                    return JS_EXCEPTION;\n                val = time_clip(val);\n                goto has_val;\n            }\n        }\n        v = JS_ToPrimitive(ctx, argv[0], HINT_NONE);\n        if (JS_IsString(v)) {\n            dv = js_Date_parse(ctx, JS_UNDEFINED, 1, (JSValueConst *)&v);\n            JS_FreeValue(ctx, v);\n            if (JS_IsException(dv))\n                return JS_EXCEPTION;\n            if (JS_ToFloat64Free(ctx, &val, dv))\n                return JS_EXCEPTION;\n        } else {\n            if (JS_ToFloat64Free(ctx, &val, v))\n                return JS_EXCEPTION;\n        }\n        val = time_clip(val);\n    } else {\n        double fields[] = { 0, 0, 1, 0, 0, 0, 0 };\n        if (n > 7)\n            n = 7;\n        for(i = 0; i < n; i++) {\n            if (JS_ToFloat64(ctx, &a, argv[i]))\n                return JS_EXCEPTION;\n            if (!isfinite(a))\n                break;\n            fields[i] = trunc(a);\n            if (i == 0 && fields[0] >= 0 && fields[0] < 100)\n                fields[0] += 1900;\n        }\n        val = (i == n) ? set_date_fields(fields, 1) : NAN;\n    }\nhas_val:\n#if 0\n    JSValueConst args[3];\n    args[0] = new_target;\n    args[1] = ctx->class_proto[JS_CLASS_DATE];\n    args[2] = JS_NewFloat64(ctx, val);\n    rv = js___date_create(ctx, JS_UNDEFINED, 3, args);\n#else\n    rv = js_create_from_ctor(ctx, new_target, JS_CLASS_DATE);\n    if (!JS_IsException(rv))\n        JS_SetObjectData(ctx, rv, JS_NewFloat64(ctx, val));\n#endif\n    if (!JS_IsException(rv) && JS_IsUndefined(new_target)) {\n        /* invoked as a function, return (new Date()).toString(); */\n        JSValue s;\n        s = get_date_string(ctx, rv, 0, NULL, 0x13);\n        JS_FreeValue(ctx, rv);\n        rv = s;\n    }\n    return rv;\n}\n\nstatic JSValue js_Date_UTC(JSContext *ctx, JSValueConst this_val,\n                           int argc, JSValueConst *argv)\n{\n    // UTC(y, mon, d, h, m, s, ms)\n    double fields[] = { 0, 0, 1, 0, 0, 0, 0 };\n    int i, n;\n    double a;\n\n    n = argc;\n    if (n == 0)\n        return JS_NAN;\n    if (n > 7)\n        n = 7;\n    for(i = 0; i < n; i++) {\n        if (JS_ToFloat64(ctx, &a, argv[i]))\n            return JS_EXCEPTION;\n        if (!isfinite(a))\n            return JS_NAN;\n        fields[i] = trunc(a);\n        if (i == 0 && fields[0] >= 0 && fields[0] < 100)\n            fields[0] += 1900;\n    }\n    return JS_NewFloat64(ctx, set_date_fields(fields, 0));\n}\n\nstatic void string_skip_spaces(JSString *sp, int *pp) {\n    while (*pp < sp->len && string_get(sp, *pp) == ' ')\n        *pp += 1;\n}\n\nstatic void string_skip_non_spaces(JSString *sp, int *pp) {\n    while (*pp < sp->len && string_get(sp, *pp) != ' ')\n        *pp += 1;\n}\n\n/* parse a numeric field with an optional sign if accept_sign is TRUE */\nstatic int string_get_digits(JSString *sp, int *pp, int64_t *pval) {\n    int64_t v = 0;\n    int c, p = *pp, p_start;\n    \n    if (p >= sp->len)\n        return -1;\n    p_start = p;\n    while (p < sp->len) {\n        c = string_get(sp, p);\n        if (!(c >= '0' && c <= '9')) {\n            if (p == p_start)\n                return -1;\n            else\n                break;\n        }\n        v = v * 10 + c - '0';\n        p++;\n    }\n    *pval = v;\n    *pp = p;\n    return 0;\n}\n\nstatic int string_get_signed_digits(JSString *sp, int *pp, int64_t *pval) {\n    int res, sgn, p = *pp;\n    \n    if (p >= sp->len)\n        return -1;\n\n    sgn = string_get(sp, p);\n    if (sgn == '-' || sgn == '+')\n        p++;\n \n    res = string_get_digits(sp, &p, pval);\n    if (res == 0 && sgn == '-')\n        *pval = -*pval;\n    *pp = p;\n    return res;\n}\n\n/* parse a fixed width numeric field */\nstatic int string_get_fixed_width_digits(JSString *sp, int *pp, int n, int64_t *pval) {\n    int64_t v = 0;\n    int i, c, p = *pp;\n\n    for(i = 0; i < n; i++) {\n        if (p >= sp->len)\n            return -1;\n        c = string_get(sp, p);\n        if (!(c >= '0' && c <= '9'))\n            return -1;\n        v = v * 10 + c - '0';\n        p++;\n    }\n    *pval = v;\n    *pp = p;\n    return 0;\n}\n\nstatic int string_get_milliseconds(JSString *sp, int *pp, int64_t *pval) {\n    /* parse milliseconds as a fractional part, round to nearest */\n    /* XXX: the spec does not indicate which rounding should be used */\n    int mul = 1000, ms = 0, p = *pp, c, p_start;\n    if (p >= sp->len)\n        return -1;\n    p_start = p;\n    while (p < sp->len) {\n        c = string_get(sp, p);\n        if (!(c >= '0' && c <= '9')) {\n            if (p == p_start)\n                return -1;\n            else\n                break;\n        }\n        if (mul == 1 && c >= '5')\n            ms += 1;\n        ms += (c - '0') * (mul /= 10);\n        p++;\n    }\n    *pval = ms;\n    *pp = p;\n    return 0;\n}\n\n\nstatic int find_abbrev(JSString *sp, int p, const char *list, int count) {\n    int n, i;\n\n    if (p + 3 <= sp->len) {\n        for (n = 0; n < count; n++) {\n            for (i = 0; i < 3; i++) {\n                if (string_get(sp, p + i) != month_names[n * 3 + i])\n                    goto next;\n            }\n            return n;\n        next:;\n        }\n    }\n    return -1;\n}\n\nstatic int string_get_month(JSString *sp, int *pp, int64_t *pval) {\n    int n;\n\n    string_skip_spaces(sp, pp);\n    n = find_abbrev(sp, *pp, month_names, 12);\n    if (n < 0)\n        return -1;\n\n    *pval = n;\n    *pp += 3;\n    return 0;\n}\n\nstatic JSValue js_Date_parse(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    // parse(s)\n    JSValue s, rv;\n    int64_t fields[] = { 0, 1, 1, 0, 0, 0, 0 };\n    double fields1[7];\n    int64_t tz, hh, mm;\n    double d;\n    int p, i, c, sgn, l;\n    JSString *sp;\n    BOOL is_local;\n    \n    rv = JS_NAN;\n\n    s = JS_ToString(ctx, argv[0]);\n    if (JS_IsException(s))\n        return JS_EXCEPTION;\n    \n    sp = JS_VALUE_GET_STRING(s);\n    p = 0;\n    if (p < sp->len && (((c = string_get(sp, p)) >= '0' && c <= '9') || c == '+' || c == '-')) {\n        /* ISO format */\n        /* year field can be negative */\n        if (string_get_signed_digits(sp, &p, &fields[0]))\n            goto done;\n\n        for (i = 1; i < 7; i++) {\n            if (p >= sp->len)\n                break;\n            switch(i) {\n            case 1:\n            case 2:\n                c = '-';\n                break;\n            case 3:\n                c = 'T';\n                break;\n            case 4:\n            case 5:\n                c = ':';\n                break;\n            case 6:\n                c = '.';\n                break;\n            }\n            if (string_get(sp, p) != c)\n                break;\n            p++;\n            if (i == 6) {\n                if (string_get_milliseconds(sp, &p, &fields[i]))\n                    goto done;\n            } else {\n                if (string_get_digits(sp, &p, &fields[i]))\n                    goto done;\n            }\n        }\n        /* no time: UTC by default */\n        is_local = (i > 3);\n        fields[1] -= 1;\n\n        /* parse the time zone offset if present: [+-]HH:mm or [+-]HHmm */\n        tz = 0;\n        if (p < sp->len) {\n            sgn = string_get(sp, p);\n            if (sgn == '+' || sgn == '-') {\n                p++;\n                l = sp->len - p;\n                if (l != 4 && l != 5)\n                    goto done;\n                if (string_get_fixed_width_digits(sp, &p, 2, &hh))\n                    goto done;\n                if (l == 5) {\n                    if (string_get(sp, p) != ':')\n                        goto done;\n                    p++;\n                }\n                if (string_get_fixed_width_digits(sp, &p, 2, &mm))\n                    goto done;\n                tz = hh * 60 + mm;\n                if (sgn == '-')\n                    tz = -tz;\n                is_local = FALSE;\n            } else if (sgn == 'Z') {\n                p++;\n                is_local = FALSE;\n            } else {\n                goto done;\n            }\n            /* error if extraneous characters */\n            if (p != sp->len)\n                goto done;\n        }\n    } else {\n        /* toString or toUTCString format */\n        /* skip the day of the week */\n        string_skip_non_spaces(sp, &p);\n        string_skip_spaces(sp, &p);\n        if (p >= sp->len)\n            goto done;\n        c = string_get(sp, p);\n        if (c >= '0' && c <= '9') {\n            /* day of month first */\n            if (string_get_digits(sp, &p, &fields[2]))\n                goto done;\n            if (string_get_month(sp, &p, &fields[1]))\n                goto done;\n        } else {\n            /* month first */\n            if (string_get_month(sp, &p, &fields[1]))\n                goto done;\n            string_skip_spaces(sp, &p);\n            if (string_get_digits(sp, &p, &fields[2]))\n                goto done;\n        }\n        /* year */\n        string_skip_spaces(sp, &p);\n        if (string_get_signed_digits(sp, &p, &fields[0]))\n            goto done;\n\n        /* hour, min, seconds */\n        string_skip_spaces(sp, &p);\n        for(i = 0; i < 3; i++) {\n            if (i == 1 || i == 2) {\n                if (p >= sp->len)\n                    goto done;\n                if (string_get(sp, p) != ':')\n                    goto done;\n                p++;\n            }\n            if (string_get_digits(sp, &p, &fields[3 + i]))\n                goto done;\n        }\n        // XXX: parse optional milliseconds?\n\n        /* parse the time zone offset if present: [+-]HHmm */\n        is_local = FALSE;\n        tz = 0;\n        for (tz = 0; p < sp->len; p++) {\n            sgn = string_get(sp, p);\n            if (sgn == '+' || sgn == '-') {\n                p++;\n                if (string_get_fixed_width_digits(sp, &p, 2, &hh))\n                    goto done;\n                if (string_get_fixed_width_digits(sp, &p, 2, &mm))\n                    goto done;\n                tz = hh * 60 + mm;\n                if (sgn == '-')\n                    tz = -tz;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < 7; i++)\n        fields1[i] = fields[i];\n    d = set_date_fields(fields1, is_local) - tz * 60000;\n    rv = JS_NewFloat64(ctx, d);\n\ndone:\n    JS_FreeValue(ctx, s);\n    return rv;\n}\n\nstatic JSValue js_Date_now(JSContext *ctx, JSValueConst this_val,\n                           int argc, JSValueConst *argv)\n{\n    // now()\n    return JS_NewInt64(ctx, date_now());\n}\n\nstatic JSValue js_date_Symbol_toPrimitive(JSContext *ctx, JSValueConst this_val,\n                                          int argc, JSValueConst *argv)\n{\n    // Symbol_toPrimitive(hint)\n    JSValueConst obj = this_val;\n    JSAtom hint = JS_ATOM_NULL;\n    int hint_num;\n\n    if (!JS_IsObject(obj))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n\n    if (JS_IsString(argv[0])) {\n        hint = JS_ValueToAtom(ctx, argv[0]);\n        if (hint == JS_ATOM_NULL)\n            return JS_EXCEPTION;\n        JS_FreeAtom(ctx, hint);\n    }\n    switch (hint) {\n    case JS_ATOM_number:\n#ifdef CONFIG_BIGNUM\n    case JS_ATOM_integer:\n#endif\n        hint_num = HINT_NUMBER;\n        break;\n    case JS_ATOM_string:\n    case JS_ATOM_default:\n        hint_num = HINT_STRING;\n        break;\n    default:\n        return JS_ThrowTypeError(ctx, \"invalid hint\");\n    }\n    return JS_ToPrimitive(ctx, obj, hint_num | HINT_FORCE_ORDINARY);\n}\n\nstatic JSValue js_date_getTimezoneOffset(JSContext *ctx, JSValueConst this_val,\n                                         int argc, JSValueConst *argv)\n{\n    // getTimezoneOffset()\n    double v;\n\n    if (JS_ThisTimeValue(ctx, &v, this_val))\n        return JS_EXCEPTION;\n    if (isnan(v))\n        return JS_NAN;\n    else\n        return JS_NewInt64(ctx, getTimezoneOffset((int64_t)trunc(v)));\n}\n\nstatic JSValue js_date_getTime(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    // getTime()\n    double v;\n\n    if (JS_ThisTimeValue(ctx, &v, this_val))\n        return JS_EXCEPTION;\n    return JS_NewFloat64(ctx, v);\n}\n\nstatic JSValue js_date_setTime(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    // setTime(v)\n    double v;\n\n    if (JS_ThisTimeValue(ctx, &v, this_val) || JS_ToFloat64(ctx, &v, argv[0]))\n        return JS_EXCEPTION;\n    return JS_SetThisTimeValue(ctx, this_val, time_clip(v));\n}\n\nstatic JSValue js_date_setYear(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    // setYear(y)\n    double y;\n    JSValueConst args[1];\n\n    if (JS_ThisTimeValue(ctx, &y, this_val) || JS_ToFloat64(ctx, &y, argv[0]))\n        return JS_EXCEPTION;\n    y = +y;\n    if (isfinite(y)) {\n        y = trunc(y);\n        if (y >= 0 && y < 100)\n            y += 1900;\n    }\n    args[0] = JS_NewFloat64(ctx, y);\n    return set_date_field(ctx, this_val, 1, args, 0x011);\n}\n\nstatic JSValue js_date_toJSON(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv)\n{\n    // toJSON(key)\n    JSValue obj, tv, method, rv;\n    double d;\n\n    rv = JS_EXCEPTION;\n    tv = JS_UNDEFINED;\n\n    obj = JS_ToObject(ctx, this_val);\n    tv = JS_ToPrimitive(ctx, obj, HINT_NUMBER);\n    if (JS_IsException(tv))\n        goto exception;\n    if (JS_IsNumber(tv)) {\n        if (JS_ToFloat64(ctx, &d, tv) < 0)\n            goto exception;\n        if (!isfinite(d)) {\n            rv = JS_NULL;\n            goto done;\n        }\n    }\n    method = JS_GetPropertyStr(ctx, obj, \"toISOString\");\n    if (JS_IsException(method))\n        goto exception;\n    if (!JS_IsFunction(ctx, method)) {\n        JS_ThrowTypeError(ctx, \"object needs toISOString method\");\n        JS_FreeValue(ctx, method);\n        goto exception;\n    }\n    rv = JS_CallFree(ctx, method, obj, 0, NULL);\nexception:\ndone:\n    JS_FreeValue(ctx, obj);\n    JS_FreeValue(ctx, tv);\n    return rv;\n}\n\nstatic const JSCFunctionListEntry js_date_funcs[] = {\n    JS_CFUNC_DEF(\"now\", 0, js_Date_now ),\n    JS_CFUNC_DEF(\"parse\", 1, js_Date_parse ),\n    JS_CFUNC_DEF(\"UTC\", 7, js_Date_UTC ),\n};\n\nstatic const JSCFunctionListEntry js_date_proto_funcs[] = {\n    JS_CFUNC_DEF(\"valueOf\", 0, js_date_getTime ),\n    JS_CFUNC_MAGIC_DEF(\"toString\", 0, get_date_string, 0x13 ),\n    JS_CFUNC_DEF(\"[Symbol.toPrimitive]\", 1, js_date_Symbol_toPrimitive ),\n    JS_CFUNC_MAGIC_DEF(\"toUTCString\", 0, get_date_string, 0x03 ),\n    JS_ALIAS_DEF(\"toGMTString\", \"toUTCString\" ),\n    JS_CFUNC_MAGIC_DEF(\"toISOString\", 0, get_date_string, 0x23 ),\n    JS_CFUNC_MAGIC_DEF(\"toDateString\", 0, get_date_string, 0x11 ),\n    JS_CFUNC_MAGIC_DEF(\"toTimeString\", 0, get_date_string, 0x12 ),\n    JS_CFUNC_MAGIC_DEF(\"toLocaleString\", 0, get_date_string, 0x33 ),\n    JS_CFUNC_MAGIC_DEF(\"toLocaleDateString\", 0, get_date_string, 0x31 ),\n    JS_CFUNC_MAGIC_DEF(\"toLocaleTimeString\", 0, get_date_string, 0x32 ),\n    JS_CFUNC_DEF(\"getTimezoneOffset\", 0, js_date_getTimezoneOffset ),\n    JS_CFUNC_DEF(\"getTime\", 0, js_date_getTime ),\n    JS_CFUNC_MAGIC_DEF(\"getYear\", 0, get_date_field, 0x101 ),\n    JS_CFUNC_MAGIC_DEF(\"getFullYear\", 0, get_date_field, 0x01 ),\n    JS_CFUNC_MAGIC_DEF(\"getUTCFullYear\", 0, get_date_field, 0x00 ),\n    JS_CFUNC_MAGIC_DEF(\"getMonth\", 0, get_date_field, 0x11 ),\n    JS_CFUNC_MAGIC_DEF(\"getUTCMonth\", 0, get_date_field, 0x10 ),\n    JS_CFUNC_MAGIC_DEF(\"getDate\", 0, get_date_field, 0x21 ),\n    JS_CFUNC_MAGIC_DEF(\"getUTCDate\", 0, get_date_field, 0x20 ),\n    JS_CFUNC_MAGIC_DEF(\"getHours\", 0, get_date_field, 0x31 ),\n    JS_CFUNC_MAGIC_DEF(\"getUTCHours\", 0, get_date_field, 0x30 ),\n    JS_CFUNC_MAGIC_DEF(\"getMinutes\", 0, get_date_field, 0x41 ),\n    JS_CFUNC_MAGIC_DEF(\"getUTCMinutes\", 0, get_date_field, 0x40 ),\n    JS_CFUNC_MAGIC_DEF(\"getSeconds\", 0, get_date_field, 0x51 ),\n    JS_CFUNC_MAGIC_DEF(\"getUTCSeconds\", 0, get_date_field, 0x50 ),\n    JS_CFUNC_MAGIC_DEF(\"getMilliseconds\", 0, get_date_field, 0x61 ),\n    JS_CFUNC_MAGIC_DEF(\"getUTCMilliseconds\", 0, get_date_field, 0x60 ),\n    JS_CFUNC_MAGIC_DEF(\"getDay\", 0, get_date_field, 0x71 ),\n    JS_CFUNC_MAGIC_DEF(\"getUTCDay\", 0, get_date_field, 0x70 ),\n    JS_CFUNC_DEF(\"setTime\", 1, js_date_setTime ),\n    JS_CFUNC_MAGIC_DEF(\"setMilliseconds\", 1, set_date_field, 0x671 ),\n    JS_CFUNC_MAGIC_DEF(\"setUTCMilliseconds\", 1, set_date_field, 0x670 ),\n    JS_CFUNC_MAGIC_DEF(\"setSeconds\", 2, set_date_field, 0x571 ),\n    JS_CFUNC_MAGIC_DEF(\"setUTCSeconds\", 2, set_date_field, 0x570 ),\n    JS_CFUNC_MAGIC_DEF(\"setMinutes\", 3, set_date_field, 0x471 ),\n    JS_CFUNC_MAGIC_DEF(\"setUTCMinutes\", 3, set_date_field, 0x470 ),\n    JS_CFUNC_MAGIC_DEF(\"setHours\", 4, set_date_field, 0x371 ),\n    JS_CFUNC_MAGIC_DEF(\"setUTCHours\", 4, set_date_field, 0x370 ),\n    JS_CFUNC_MAGIC_DEF(\"setDate\", 1, set_date_field, 0x231 ),\n    JS_CFUNC_MAGIC_DEF(\"setUTCDate\", 1, set_date_field, 0x230 ),\n    JS_CFUNC_MAGIC_DEF(\"setMonth\", 2, set_date_field, 0x131 ),\n    JS_CFUNC_MAGIC_DEF(\"setUTCMonth\", 2, set_date_field, 0x130 ),\n    JS_CFUNC_DEF(\"setYear\", 1, js_date_setYear ),\n    JS_CFUNC_MAGIC_DEF(\"setFullYear\", 3, set_date_field, 0x031 ),\n    JS_CFUNC_MAGIC_DEF(\"setUTCFullYear\", 3, set_date_field, 0x030 ),\n    JS_CFUNC_DEF(\"toJSON\", 1, js_date_toJSON ),\n};\n\nvoid JS_AddIntrinsicDate(JSContext *ctx)\n{\n    JSValueConst obj;\n\n    /* Date */\n    ctx->class_proto[JS_CLASS_DATE] = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_DATE], js_date_proto_funcs,\n                               countof(js_date_proto_funcs));\n    obj = JS_NewGlobalCConstructor(ctx, \"Date\", js_date_constructor, 7,\n                                   ctx->class_proto[JS_CLASS_DATE]);\n    JS_SetPropertyFunctionList(ctx, obj, js_date_funcs, countof(js_date_funcs));\n}\n\n/* eval */\n\nvoid JS_AddIntrinsicEval(JSContext *ctx)\n{\n    ctx->eval_internal = __JS_EvalInternal;\n}\n\n#ifdef CONFIG_BIGNUM\n\n/* Operators */\n\nstatic void js_operator_set_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSOperatorSetData *opset = JS_GetOpaque(val, JS_CLASS_OPERATOR_SET);\n    int i, j;\n    JSBinaryOperatorDefEntry *ent;\n    \n    if (opset) {\n        for(i = 0; i < JS_OVOP_COUNT; i++) {\n            if (opset->self_ops[i])\n                JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, opset->self_ops[i]));\n        }\n        for(j = 0; j < opset->left.count; j++) {\n            ent = &opset->left.tab[j];\n            for(i = 0; i < JS_OVOP_BINARY_COUNT; i++) {\n                if (ent->ops[i])\n                    JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, ent->ops[i]));\n            }\n        }\n        js_free_rt(rt, opset->left.tab);\n        for(j = 0; j < opset->right.count; j++) {\n            ent = &opset->right.tab[j];\n            for(i = 0; i < JS_OVOP_BINARY_COUNT; i++) {\n                if (ent->ops[i])\n                    JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, ent->ops[i]));\n            }\n        }\n        js_free_rt(rt, opset->right.tab);\n        js_free_rt(rt, opset);\n    }\n}\n\nstatic void js_operator_set_mark(JSRuntime *rt, JSValueConst val,\n                                 JS_MarkFunc *mark_func)\n{\n    JSOperatorSetData *opset = JS_GetOpaque(val, JS_CLASS_OPERATOR_SET);\n    int i, j;\n    JSBinaryOperatorDefEntry *ent;\n    \n    if (opset) {\n        for(i = 0; i < JS_OVOP_COUNT; i++) {\n            if (opset->self_ops[i])\n                JS_MarkValue(rt, JS_MKPTR(JS_TAG_OBJECT, opset->self_ops[i]),\n                             mark_func);\n        }\n        for(j = 0; j < opset->left.count; j++) {\n            ent = &opset->left.tab[j];\n            for(i = 0; i < JS_OVOP_BINARY_COUNT; i++) {\n                if (ent->ops[i])\n                    JS_MarkValue(rt, JS_MKPTR(JS_TAG_OBJECT, ent->ops[i]),\n                                 mark_func);\n            }\n        }\n        for(j = 0; j < opset->right.count; j++) {\n            ent = &opset->right.tab[j];\n            for(i = 0; i < JS_OVOP_BINARY_COUNT; i++) {\n                if (ent->ops[i])\n                    JS_MarkValue(rt, JS_MKPTR(JS_TAG_OBJECT, ent->ops[i]),\n                                 mark_func);\n            }\n        }\n    }\n}\n\n\n/* create an OperatorSet object */\nstatic JSValue js_operators_create_internal(JSContext *ctx,\n                                            int argc, JSValueConst *argv,\n                                            BOOL is_primitive)\n{\n    JSValue opset_obj, prop, obj;\n    JSOperatorSetData *opset, *opset1;\n    JSBinaryOperatorDef *def;\n    JSValueConst arg;\n    int i, j;\n    JSBinaryOperatorDefEntry *new_tab;\n    JSBinaryOperatorDefEntry *ent;\n    uint32_t op_count;\n\n    if (ctx->rt->operator_count == UINT32_MAX) {\n        return JS_ThrowTypeError(ctx, \"too many operators\");\n    }\n    opset_obj = JS_NewObjectProtoClass(ctx, JS_NULL, JS_CLASS_OPERATOR_SET);\n    if (JS_IsException(opset_obj))\n        goto fail;\n    opset = js_mallocz(ctx, sizeof(*opset));\n    if (!opset)\n        goto fail;\n    JS_SetOpaque(opset_obj, opset);\n    if (argc >= 1) {\n        arg = argv[0];\n        /* self operators */\n        for(i = 0; i < JS_OVOP_COUNT; i++) {\n            prop = JS_GetPropertyStr(ctx, arg, js_overloadable_operator_names[i]);\n            if (JS_IsException(prop))\n                goto fail;\n            if (!JS_IsUndefined(prop)) {\n                if (check_function(ctx, prop)) {\n                    JS_FreeValue(ctx, prop);\n                    goto fail;\n                }\n                opset->self_ops[i] = JS_VALUE_GET_OBJ(prop);\n            }\n        }\n    }\n    /* left & right operators */\n    for(j = 1; j < argc; j++) {\n        arg = argv[j];\n        prop = JS_GetPropertyStr(ctx, arg, \"left\");\n        if (JS_IsException(prop))\n            goto fail;\n        def = &opset->right;\n        if (JS_IsUndefined(prop)) {\n            prop = JS_GetPropertyStr(ctx, arg, \"right\");\n            if (JS_IsException(prop))\n                goto fail;\n            if (JS_IsUndefined(prop)) {\n                JS_ThrowTypeError(ctx, \"left or right property must be present\");\n                goto fail;\n            }\n            def = &opset->left;\n        }\n        /* get the operator set */\n        obj = JS_GetProperty(ctx, prop, JS_ATOM_prototype);\n        JS_FreeValue(ctx, prop);\n        if (JS_IsException(obj))\n            goto fail;\n        prop = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_operatorSet);\n        JS_FreeValue(ctx, obj);\n        if (JS_IsException(prop))\n            goto fail;\n        opset1 = JS_GetOpaque2(ctx, prop, JS_CLASS_OPERATOR_SET);\n        if (!opset1) {\n            JS_FreeValue(ctx, prop);\n            goto fail;\n        }\n        op_count = opset1->operator_counter;\n        JS_FreeValue(ctx, prop);\n        \n        /* we assume there are few entries */\n        new_tab = js_realloc(ctx, def->tab,\n                             (def->count + 1) * sizeof(def->tab[0]));\n        if (!new_tab)\n            goto fail;\n        def->tab = new_tab;\n        def->count++;\n        ent = def->tab + def->count - 1;\n        memset(ent, 0, sizeof(def->tab[0]));\n        ent->operator_index = op_count;\n        \n        for(i = 0; i < JS_OVOP_BINARY_COUNT; i++) {\n            prop = JS_GetPropertyStr(ctx, arg,\n                                     js_overloadable_operator_names[i]);\n            if (JS_IsException(prop))\n                goto fail;\n            if (!JS_IsUndefined(prop)) {\n                if (check_function(ctx, prop)) {\n                    JS_FreeValue(ctx, prop);\n                    goto fail;\n                }\n                ent->ops[i] = JS_VALUE_GET_OBJ(prop);\n            }\n        }\n    }\n    opset->is_primitive = is_primitive;\n    opset->operator_counter = ctx->rt->operator_count++;\n    return opset_obj;\n fail:\n    JS_FreeValue(ctx, opset_obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_operators_create(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    return js_operators_create_internal(ctx, argc, argv, FALSE);\n}\n\nstatic JSValue js_operators_updateBigIntOperators(JSContext *ctx, JSValueConst this_val,\n                                                  int argc, JSValueConst *argv)\n{\n    JSValue opset_obj, prop;\n    JSOperatorSetData *opset;\n    const JSOverloadableOperatorEnum ops[2] = { JS_OVOP_DIV, JS_OVOP_POW };\n    JSOverloadableOperatorEnum op;\n    int i;\n    \n    opset_obj = JS_GetProperty(ctx, ctx->class_proto[JS_CLASS_BIG_INT],\n                               JS_ATOM_Symbol_operatorSet);\n    if (JS_IsException(opset_obj))\n        goto fail;\n    opset = JS_GetOpaque2(ctx, opset_obj, JS_CLASS_OPERATOR_SET);\n    if (!opset)\n        goto fail;\n    for(i = 0; i < countof(ops); i++) {\n        op = ops[i];\n        prop = JS_GetPropertyStr(ctx, argv[0],\n                                 js_overloadable_operator_names[op]);\n        if (JS_IsException(prop))\n            goto fail;\n        if (!JS_IsUndefined(prop)) {\n            if (!JS_IsNull(prop) && check_function(ctx, prop)) {\n                JS_FreeValue(ctx, prop);\n                goto fail;\n            }\n            if (opset->self_ops[op])\n                JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, opset->self_ops[op]));\n            if (JS_IsNull(prop)) {\n                opset->self_ops[op] = NULL;\n            } else {\n                opset->self_ops[op] = JS_VALUE_GET_PTR(prop);\n            }\n        }\n    }\n    JS_FreeValue(ctx, opset_obj);\n    return JS_UNDEFINED;\n fail:\n    JS_FreeValue(ctx, opset_obj);\n    return JS_EXCEPTION;\n}\n\nstatic int js_operators_set_default(JSContext *ctx, JSValueConst obj)\n{\n    JSValue opset_obj;\n\n    if (!JS_IsObject(obj)) /* in case the prototype is not defined */\n        return 0;\n    opset_obj = js_operators_create_internal(ctx, 0, NULL, TRUE);\n    if (JS_IsException(opset_obj))\n        return -1;\n    /* cannot be modified by the user */\n    JS_DefinePropertyValue(ctx, obj, JS_ATOM_Symbol_operatorSet,\n                           opset_obj, 0);\n    return 0;\n}\n\nstatic JSValue js_dummy_operators_ctor(JSContext *ctx, JSValueConst new_target,\n                                       int argc, JSValueConst *argv)\n{\n    return js_create_from_ctor(ctx, new_target, JS_CLASS_OBJECT);\n}\n\nstatic JSValue js_global_operators(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    JSValue func_obj, proto, opset_obj;\n\n    func_obj = JS_UNDEFINED;\n    proto = JS_NewObject(ctx);\n    if (JS_IsException(proto))\n        return JS_EXCEPTION;\n    opset_obj = js_operators_create_internal(ctx, argc, argv, FALSE);\n    if (JS_IsException(opset_obj))\n        goto fail;\n    JS_DefinePropertyValue(ctx, proto, JS_ATOM_Symbol_operatorSet,\n                           opset_obj, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    func_obj = JS_NewCFunction2(ctx, js_dummy_operators_ctor, \"Operators\",\n                                0, JS_CFUNC_constructor, 0);\n    if (JS_IsException(func_obj))\n        goto fail;\n    JS_SetConstructor2(ctx, func_obj, proto,\n                       0, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    JS_FreeValue(ctx, proto);\n    return func_obj;\n fail:\n    JS_FreeValue(ctx, proto);\n    JS_FreeValue(ctx, func_obj);\n    return JS_EXCEPTION;\n}\n\nstatic const JSCFunctionListEntry js_operators_funcs[] = {\n    JS_CFUNC_DEF(\"create\", 1, js_operators_create ),\n    JS_CFUNC_DEF(\"updateBigIntOperators\", 2, js_operators_updateBigIntOperators ),\n};\n\n/* must be called after all overloadable base types are initialized */\nvoid JS_AddIntrinsicOperators(JSContext *ctx)\n{\n    JSValue obj;\n\n    ctx->allow_operator_overloading = TRUE;\n    obj = JS_NewCFunction(ctx, js_global_operators, \"Operators\", 1);\n    JS_SetPropertyFunctionList(ctx, obj,\n                               js_operators_funcs,\n                               countof(js_operators_funcs));\n    JS_DefinePropertyValue(ctx, ctx->global_obj, JS_ATOM_Operators,\n                           obj,\n                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    /* add default operatorSets */\n    js_operators_set_default(ctx, ctx->class_proto[JS_CLASS_BOOLEAN]);\n    js_operators_set_default(ctx, ctx->class_proto[JS_CLASS_NUMBER]);\n    js_operators_set_default(ctx, ctx->class_proto[JS_CLASS_STRING]);\n    js_operators_set_default(ctx, ctx->class_proto[JS_CLASS_BIG_INT]);\n    js_operators_set_default(ctx, ctx->class_proto[JS_CLASS_BIG_FLOAT]);\n    js_operators_set_default(ctx, ctx->class_proto[JS_CLASS_BIG_DECIMAL]);\n}\n\n/* BigInt */\n\nstatic JSValue JS_ToBigIntCtorFree(JSContext *ctx, JSValue val)\n{\n    uint32_t tag;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n        val = JS_NewBigInt64(ctx, JS_VALUE_GET_INT(val));\n        break;\n    case JS_TAG_BIG_INT:\n        break;\n    case JS_TAG_FLOAT64:\n    case JS_TAG_BIG_FLOAT:\n        {\n            bf_t *a, a_s;\n            \n            a = JS_ToBigFloat(ctx, &a_s, val);\n            if (!bf_is_finite(a)) {\n                JS_FreeValue(ctx, val);\n                val = JS_ThrowRangeError(ctx, \"cannot convert NaN or Infinity to bigint\");\n            } else {\n                JSValue val1 = JS_NewBigInt(ctx);\n                bf_t *r;\n                int ret;\n                if (JS_IsException(val1)) {\n                    JS_FreeValue(ctx, val);\n                    return JS_EXCEPTION;\n                }\n                r = JS_GetBigInt(val1);\n                ret = bf_set(r, a);\n                ret |= bf_rint(r, BF_RNDZ);\n                JS_FreeValue(ctx, val);\n                if (ret & BF_ST_MEM_ERROR) {\n                    JS_FreeValue(ctx, val1);\n                    val = JS_ThrowOutOfMemory(ctx);\n                } else if (ret & BF_ST_INEXACT) {\n                    JS_FreeValue(ctx, val1);\n                    val = JS_ThrowRangeError(ctx, \"cannot convert to bigint: not an integer\");\n                } else {\n                    val = JS_CompactBigInt(ctx, val1);\n                }\n            }\n            if (a == &a_s)\n                bf_delete(a);\n        }\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        val = JS_ToStringFree(ctx, val);\n         if (JS_IsException(val))\n            break;\n        goto redo;\n    case JS_TAG_STRING:\n        val = JS_StringToBigIntErr(ctx, val);\n        break;\n    case JS_TAG_OBJECT:\n        val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);\n        if (JS_IsException(val))\n            break;\n        goto redo;\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n    default:\n        JS_FreeValue(ctx, val);\n        return JS_ThrowTypeError(ctx, \"cannot convert to bigint\");\n    }\n    return val;\n}\n\nstatic JSValue js_bigint_constructor(JSContext *ctx,\n                                     JSValueConst new_target,\n                                     int argc, JSValueConst *argv)\n{\n    if (!JS_IsUndefined(new_target))\n        return JS_ThrowTypeError(ctx, \"not a constructor\");\n    return JS_ToBigIntCtorFree(ctx, JS_DupValue(ctx, argv[0]));\n}\n\nstatic JSValue js_thisBigIntValue(JSContext *ctx, JSValueConst this_val)\n{\n    if (JS_IsBigInt(ctx, this_val))\n        return JS_DupValue(ctx, this_val);\n\n    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(this_val);\n        if (p->class_id == JS_CLASS_BIG_INT) {\n            if (JS_IsBigInt(ctx, p->u.object_data))\n                return JS_DupValue(ctx, p->u.object_data);\n        }\n    }\n    return JS_ThrowTypeError(ctx, \"not a bigint\");\n}\n\nstatic JSValue js_bigint_toString(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    JSValue val;\n    int base;\n    JSValue ret;\n\n    val = js_thisBigIntValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    if (argc == 0 || JS_IsUndefined(argv[0])) {\n        base = 10;\n    } else {\n        base = js_get_radix(ctx, argv[0]);\n        if (base < 0)\n            goto fail;\n    }\n    ret = js_bigint_to_string1(ctx, val, base);\n    JS_FreeValue(ctx, val);\n    return ret;\n fail:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_bigint_valueOf(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    return js_thisBigIntValue(ctx, this_val);\n}\n\nstatic JSValue js_bigint_div(JSContext *ctx,\n                              JSValueConst this_val,\n                              int argc, JSValueConst *argv, int magic)\n{\n    bf_t a_s, b_s, *a, *b, *r, *q;\n    int status;\n    JSValue q_val, r_val;\n    \n    q_val = JS_NewBigInt(ctx);\n    if (JS_IsException(q_val))\n        return JS_EXCEPTION;\n    r_val = JS_NewBigInt(ctx);\n    if (JS_IsException(r_val))\n        goto fail;\n    b = NULL;\n    a = JS_ToBigInt(ctx, &a_s, argv[0]);\n    if (!a)\n        goto fail;\n    b = JS_ToBigInt(ctx, &b_s, argv[1]);\n    if (!b) {\n        JS_FreeBigInt(ctx, a, &a_s);\n        goto fail;\n    }\n    q = JS_GetBigInt(q_val);\n    r = JS_GetBigInt(r_val);\n    status = bf_divrem(q, r, a, b, BF_PREC_INF, BF_RNDZ, magic & 0xf);\n    JS_FreeBigInt(ctx, a, &a_s);\n    JS_FreeBigInt(ctx, b, &b_s);\n    if (unlikely(status)) {\n        throw_bf_exception(ctx, status);\n        goto fail;\n    }\n    q_val = JS_CompactBigInt(ctx, q_val);\n    if (magic & 0x10) {\n        JSValue ret;\n        ret = JS_NewArray(ctx);\n        if (JS_IsException(ret))\n            goto fail;\n        JS_SetPropertyUint32(ctx, ret, 0, q_val);\n        JS_SetPropertyUint32(ctx, ret, 1, JS_CompactBigInt(ctx, r_val));\n        return ret;\n    } else {\n        JS_FreeValue(ctx, r_val);\n        return q_val;\n    }\n fail:\n    JS_FreeValue(ctx, q_val);\n    JS_FreeValue(ctx, r_val);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_bigint_sqrt(JSContext *ctx,\n                               JSValueConst this_val,\n                               int argc, JSValueConst *argv, int magic)\n{\n    bf_t a_s, *a, *r, *rem;\n    int status;\n    JSValue r_val, rem_val;\n    \n    r_val = JS_NewBigInt(ctx);\n    if (JS_IsException(r_val))\n        return JS_EXCEPTION;\n    rem_val = JS_NewBigInt(ctx);\n    if (JS_IsException(rem_val))\n        return JS_EXCEPTION;\n    r = JS_GetBigInt(r_val);\n    rem = JS_GetBigInt(rem_val);\n\n    a = JS_ToBigInt(ctx, &a_s, argv[0]);\n    if (!a)\n        goto fail;\n    status = bf_sqrtrem(r, rem, a);\n    JS_FreeBigInt(ctx, a, &a_s);\n    if (unlikely(status & ~BF_ST_INEXACT)) {\n        throw_bf_exception(ctx, status);\n        goto fail;\n    }\n    r_val = JS_CompactBigInt(ctx, r_val);\n    if (magic) {\n        JSValue ret;\n        ret = JS_NewArray(ctx);\n        if (JS_IsException(ret))\n            goto fail;\n        JS_SetPropertyUint32(ctx, ret, 0, r_val);\n        JS_SetPropertyUint32(ctx, ret, 1, JS_CompactBigInt(ctx, rem_val));\n        return ret;\n    } else {\n        JS_FreeValue(ctx, rem_val);\n        return r_val;\n    }\n fail:\n    JS_FreeValue(ctx, r_val);\n    JS_FreeValue(ctx, rem_val);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_bigint_op1(JSContext *ctx,\n                              JSValueConst this_val,\n                              int argc, JSValueConst *argv,\n                              int magic)\n{\n    bf_t a_s, *a;\n    int64_t res;\n\n    a = JS_ToBigInt(ctx, &a_s, argv[0]);\n    if (!a)\n        return JS_EXCEPTION;\n    switch(magic) {\n    case 0: /* floorLog2 */\n        if (a->sign || a->expn <= 0) {\n            res = -1;\n        } else {\n            res = a->expn - 1;\n        }\n        break;\n    case 1: /* ctz */\n        if (bf_is_zero(a)) {\n            res = -1;\n        } else {\n            res = bf_get_exp_min(a);\n        }\n        break;\n    default:\n        abort();\n    }\n    JS_FreeBigInt(ctx, a, &a_s);\n    return JS_NewBigInt64(ctx, res);\n}\n\nstatic JSValue js_bigint_asUintN(JSContext *ctx,\n                                  JSValueConst this_val,\n                                  int argc, JSValueConst *argv, int asIntN)\n{\n    uint64_t bits;\n    bf_t a_s, *a = &a_s, *r, mask_s, *mask = &mask_s;\n    JSValue res;\n    \n    if (JS_ToIndex(ctx, &bits, argv[0]))\n        return JS_EXCEPTION;\n    res = JS_NewBigInt(ctx);\n    if (JS_IsException(res))\n        return JS_EXCEPTION;\n    r = JS_GetBigInt(res);\n    a = JS_ToBigInt(ctx, &a_s, argv[1]);\n    if (!a) {\n        JS_FreeValue(ctx, res);\n        return JS_EXCEPTION;\n    }\n    /* XXX: optimize */\n    r = JS_GetBigInt(res);\n    bf_init(ctx->bf_ctx, mask);\n    bf_set_ui(mask, 1);\n    bf_mul_2exp(mask, bits, BF_PREC_INF, BF_RNDZ);\n    bf_add_si(mask, mask, -1, BF_PREC_INF, BF_RNDZ);\n    bf_logic_and(r, a, mask);\n    if (asIntN && bits != 0) {\n        bf_set_ui(mask, 1);\n        bf_mul_2exp(mask, bits - 1, BF_PREC_INF, BF_RNDZ);\n        if (bf_cmpu(r, mask) >= 0) {\n            bf_set_ui(mask, 1);\n            bf_mul_2exp(mask, bits, BF_PREC_INF, BF_RNDZ);\n            bf_sub(r, r, mask, BF_PREC_INF, BF_RNDZ);\n        }\n    }\n    bf_delete(mask);\n    JS_FreeBigInt(ctx, a, &a_s);\n    return JS_CompactBigInt(ctx, res);\n}\n\nstatic const JSCFunctionListEntry js_bigint_funcs[] = {\n    JS_CFUNC_MAGIC_DEF(\"asUintN\", 2, js_bigint_asUintN, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"asIntN\", 2, js_bigint_asUintN, 1 ),\n    /* QuickJS extensions */\n    JS_CFUNC_MAGIC_DEF(\"tdiv\", 2, js_bigint_div, BF_RNDZ ),\n    JS_CFUNC_MAGIC_DEF(\"fdiv\", 2, js_bigint_div, BF_RNDD ),\n    JS_CFUNC_MAGIC_DEF(\"cdiv\", 2, js_bigint_div, BF_RNDU ),\n    JS_CFUNC_MAGIC_DEF(\"ediv\", 2, js_bigint_div, BF_DIVREM_EUCLIDIAN ),\n    JS_CFUNC_MAGIC_DEF(\"tdivrem\", 2, js_bigint_div, BF_RNDZ | 0x10 ),\n    JS_CFUNC_MAGIC_DEF(\"fdivrem\", 2, js_bigint_div, BF_RNDD | 0x10 ),\n    JS_CFUNC_MAGIC_DEF(\"cdivrem\", 2, js_bigint_div, BF_RNDU | 0x10 ),\n    JS_CFUNC_MAGIC_DEF(\"edivrem\", 2, js_bigint_div, BF_DIVREM_EUCLIDIAN | 0x10 ),\n    JS_CFUNC_MAGIC_DEF(\"sqrt\", 1, js_bigint_sqrt, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"sqrtrem\", 1, js_bigint_sqrt, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"floorLog2\", 1, js_bigint_op1, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"ctz\", 1, js_bigint_op1, 1 ),\n};\n\nstatic const JSCFunctionListEntry js_bigint_proto_funcs[] = {\n    JS_CFUNC_DEF(\"toString\", 0, js_bigint_toString ),\n    JS_CFUNC_DEF(\"valueOf\", 0, js_bigint_valueOf ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"BigInt\", JS_PROP_CONFIGURABLE ),\n};\n\nvoid JS_AddIntrinsicBigInt(JSContext *ctx)\n{\n    JSRuntime *rt = ctx->rt;\n    JSValueConst obj1;\n\n    rt->bigint_ops.to_string = js_bigint_to_string;\n    rt->bigint_ops.from_string = js_string_to_bigint;\n    rt->bigint_ops.unary_arith = js_unary_arith_bigint;\n    rt->bigint_ops.binary_arith = js_binary_arith_bigint;\n    rt->bigint_ops.compare = js_compare_bigfloat;\n    \n    ctx->class_proto[JS_CLASS_BIG_INT] = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BIG_INT],\n                               js_bigint_proto_funcs,\n                               countof(js_bigint_proto_funcs));\n    obj1 = JS_NewGlobalCConstructor(ctx, \"BigInt\", js_bigint_constructor, 1,\n                                    ctx->class_proto[JS_CLASS_BIG_INT]);\n    JS_SetPropertyFunctionList(ctx, obj1, js_bigint_funcs,\n                               countof(js_bigint_funcs));\n}\n\n/* BigFloat */\n\nstatic JSValue js_thisBigFloatValue(JSContext *ctx, JSValueConst this_val)\n{\n    if (JS_IsBigFloat(this_val))\n        return JS_DupValue(ctx, this_val);\n\n    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(this_val);\n        if (p->class_id == JS_CLASS_BIG_FLOAT) {\n            if (JS_IsBigFloat(p->u.object_data))\n                return JS_DupValue(ctx, p->u.object_data);\n        }\n    }\n    return JS_ThrowTypeError(ctx, \"not a bigfloat\");\n}\n\nstatic JSValue js_bigfloat_toString(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv)\n{\n    JSValue val;\n    int base;\n    JSValue ret;\n\n    val = js_thisBigFloatValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    if (argc == 0 || JS_IsUndefined(argv[0])) {\n        base = 10;\n    } else {\n        base = js_get_radix(ctx, argv[0]);\n        if (base < 0)\n            goto fail;\n    }\n    ret = js_ftoa(ctx, val, base, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);\n    JS_FreeValue(ctx, val);\n    return ret;\n fail:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_bigfloat_valueOf(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    return js_thisBigFloatValue(ctx, this_val);\n}\n\nstatic int bigfloat_get_rnd_mode(JSContext *ctx, JSValueConst val)\n{\n    int rnd_mode;\n    if (JS_ToInt32Sat(ctx, &rnd_mode, val))\n        return -1;\n    if (rnd_mode < BF_RNDN || rnd_mode > BF_RNDF) {\n        JS_ThrowRangeError(ctx, \"invalid rounding mode\");\n        return -1;\n    }\n    return rnd_mode;\n}\n\nstatic JSValue js_bigfloat_toFixed(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    JSValue val, ret;\n    int64_t f;\n    int rnd_mode, radix;\n\n    val = js_thisBigFloatValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    if (JS_ToInt64Sat(ctx, &f, argv[0]))\n        goto fail;\n    if (f < 0 || f > BF_PREC_MAX) {\n        JS_ThrowRangeError(ctx, \"invalid number of digits\");\n        goto fail;\n    }\n    rnd_mode = BF_RNDNA;\n    radix = 10;\n    /* XXX: swap parameter order for rounding mode and radix */\n    if (argc > 1) {\n        rnd_mode = bigfloat_get_rnd_mode(ctx, argv[1]);\n        if (rnd_mode < 0)\n            goto fail;\n    }\n    if (argc > 2) {\n        radix = js_get_radix(ctx, argv[2]);\n        if (radix < 0)\n            goto fail;\n    }\n    ret = js_ftoa(ctx, val, radix, f, rnd_mode | BF_FTOA_FORMAT_FRAC);\n    JS_FreeValue(ctx, val);\n    return ret;\n fail:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic BOOL js_bigfloat_is_finite(JSContext *ctx, JSValueConst val)\n{\n    BOOL res;\n    uint32_t tag;\n\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            res = bf_is_finite(&p->num);\n        }\n        break;\n    default:\n        res = FALSE;\n        break;\n    }\n    return res;\n}\n\nstatic JSValue js_bigfloat_toExponential(JSContext *ctx, JSValueConst this_val,\n                                       int argc, JSValueConst *argv)\n{\n    JSValue val, ret;\n    int64_t f;\n    int rnd_mode, radix;\n\n    val = js_thisBigFloatValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    if (JS_ToInt64Sat(ctx, &f, argv[0]))\n        goto fail;\n    if (!js_bigfloat_is_finite(ctx, val)) {\n        ret = JS_ToString(ctx, val);\n    } else if (JS_IsUndefined(argv[0])) {\n        ret = js_ftoa(ctx, val, 10, 0,\n                      BF_RNDN | BF_FTOA_FORMAT_FREE_MIN | BF_FTOA_FORCE_EXP);\n    } else {\n        if (f < 0 || f > BF_PREC_MAX) {\n            JS_ThrowRangeError(ctx, \"invalid number of digits\");\n            goto fail;\n        }\n        rnd_mode = BF_RNDNA;\n        radix = 10;\n        if (argc > 1) {\n            rnd_mode = bigfloat_get_rnd_mode(ctx, argv[1]);\n            if (rnd_mode < 0)\n                goto fail;\n        }\n        if (argc > 2) {\n            radix = js_get_radix(ctx, argv[2]);\n            if (radix < 0)\n                goto fail;\n        }\n        ret = js_ftoa(ctx, val, radix, f + 1,\n                      rnd_mode | BF_FTOA_FORMAT_FIXED | BF_FTOA_FORCE_EXP);\n    }\n    JS_FreeValue(ctx, val);\n    return ret;\n fail:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_bigfloat_toPrecision(JSContext *ctx, JSValueConst this_val,\n                                     int argc, JSValueConst *argv)\n{\n    JSValue val, ret;\n    int64_t p;\n    int rnd_mode, radix;\n\n    val = js_thisBigFloatValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    if (JS_IsUndefined(argv[0]))\n        goto to_string;\n    if (JS_ToInt64Sat(ctx, &p, argv[0]))\n        goto fail;\n    if (!js_bigfloat_is_finite(ctx, val)) {\n    to_string:\n        ret = JS_ToString(ctx, this_val);\n    } else {\n        if (p < 1 || p > BF_PREC_MAX) {\n            JS_ThrowRangeError(ctx, \"invalid number of digits\");\n            goto fail;\n        }\n        rnd_mode = BF_RNDNA;\n        radix = 10;\n        if (argc > 1) {\n            rnd_mode = bigfloat_get_rnd_mode(ctx, argv[1]);\n            if (rnd_mode < 0)\n                goto fail;\n        }\n        if (argc > 2) {\n            radix = js_get_radix(ctx, argv[2]);\n            if (radix < 0)\n                goto fail;\n        }\n        ret = js_ftoa(ctx, val, radix, p, rnd_mode | BF_FTOA_FORMAT_FIXED);\n    }\n    JS_FreeValue(ctx, val);\n    return ret;\n fail:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic const JSCFunctionListEntry js_bigfloat_proto_funcs[] = {\n    JS_CFUNC_DEF(\"toString\", 0, js_bigfloat_toString ),\n    JS_CFUNC_DEF(\"valueOf\", 0, js_bigfloat_valueOf ),\n    JS_CFUNC_DEF(\"toPrecision\", 1, js_bigfloat_toPrecision ),\n    JS_CFUNC_DEF(\"toFixed\", 1, js_bigfloat_toFixed ),\n    JS_CFUNC_DEF(\"toExponential\", 1, js_bigfloat_toExponential ),\n};\n\nstatic JSValue js_bigfloat_constructor(JSContext *ctx,\n                                       JSValueConst new_target,\n                                       int argc, JSValueConst *argv)\n{\n    JSValue val;\n    if (!JS_IsUndefined(new_target))\n        return JS_ThrowTypeError(ctx, \"not a constructor\");\n    if (argc == 0) {\n        bf_t *r;\n        val = JS_NewBigFloat(ctx);\n        if (JS_IsException(val))\n            return val;\n        r = JS_GetBigFloat(val);\n        bf_set_zero(r, 0);\n    } else {\n        val = JS_DupValue(ctx, argv[0]);\n    redo:\n        switch(JS_VALUE_GET_NORM_TAG(val)) {\n        case JS_TAG_BIG_FLOAT:\n            break;\n        case JS_TAG_FLOAT64:\n            {\n                bf_t *r;\n                double d = JS_VALUE_GET_FLOAT64(val);\n                val = JS_NewBigFloat(ctx);\n                if (JS_IsException(val))\n                    break;\n                r = JS_GetBigFloat(val);\n                if (bf_set_float64(r, d))\n                    goto fail;\n            }\n            break;\n        case JS_TAG_INT:\n            {\n                bf_t *r;\n                int32_t v = JS_VALUE_GET_INT(val);\n                val = JS_NewBigFloat(ctx);\n                if (JS_IsException(val))\n                    break;\n                r = JS_GetBigFloat(val);\n                if (bf_set_si(r, v))\n                    goto fail;\n            }\n            break;\n        case JS_TAG_BIG_INT:\n            /* We keep the full precision of the integer */\n            {\n                JSBigFloat *p = JS_VALUE_GET_PTR(val);\n                val = JS_MKPTR(JS_TAG_BIG_FLOAT, p);\n            }\n            break;\n        case JS_TAG_BIG_DECIMAL:\n            val = JS_ToStringFree(ctx, val);\n            if (JS_IsException(val))\n                break;\n            goto redo;\n        case JS_TAG_STRING:\n            {\n                const char *str, *p;\n                size_t len;\n                int err;\n\n                str = JS_ToCStringLen(ctx, &len, val);\n                JS_FreeValue(ctx, val);\n                if (!str)\n                    return JS_EXCEPTION;\n                p = str;\n                p += skip_spaces(p);\n                if ((p - str) == len) {\n                    bf_t *r;\n                    val = JS_NewBigFloat(ctx);\n                    if (JS_IsException(val))\n                        break;\n                    r = JS_GetBigFloat(val);\n                    bf_set_zero(r, 0);\n                    err = 0;\n                } else {\n                    val = js_atof(ctx, p, &p, 0, ATOD_ACCEPT_BIN_OCT |\n                                  ATOD_TYPE_BIG_FLOAT |\n                                  ATOD_ACCEPT_PREFIX_AFTER_SIGN);\n                    if (JS_IsException(val)) {\n                        JS_FreeCString(ctx, str);\n                        return JS_EXCEPTION;\n                    }\n                    p += skip_spaces(p);\n                    err = ((p - str) != len);\n                }\n                JS_FreeCString(ctx, str);\n                if (err) {\n                    JS_FreeValue(ctx, val);\n                    return JS_ThrowSyntaxError(ctx, \"invalid bigfloat literal\");\n                }\n            }\n            break;\n        case JS_TAG_OBJECT:\n            val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);\n            if (JS_IsException(val))\n                break;\n            goto redo;\n        case JS_TAG_NULL:\n        case JS_TAG_UNDEFINED:\n        default:\n            JS_FreeValue(ctx, val);\n            return JS_ThrowTypeError(ctx, \"cannot convert to bigfloat\");\n        }\n    }\n    return val;\n fail:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_bigfloat_get_const(JSContext *ctx,\n                                     JSValueConst this_val, int magic)\n{\n    bf_t *r;\n    JSValue val;\n    val = JS_NewBigFloat(ctx);\n    if (JS_IsException(val))\n        return val;\n    r = JS_GetBigFloat(val);\n    switch(magic) {\n    case 0: /* PI */\n        bf_const_pi(r, ctx->fp_env.prec, ctx->fp_env.flags);\n        break;\n    case 1: /* LN2 */\n        bf_const_log2(r, ctx->fp_env.prec, ctx->fp_env.flags);\n        break;\n    case 2: /* MIN_VALUE */\n    case 3: /* MAX_VALUE */\n        {\n            slimb_t e_range, e;\n            e_range = (limb_t)1 << (bf_get_exp_bits(ctx->fp_env.flags) - 1);\n            bf_set_ui(r, 1);\n            if (magic == 2) {\n                e = -e_range + 2;\n                if (ctx->fp_env.flags & BF_FLAG_SUBNORMAL)\n                    e -= ctx->fp_env.prec - 1;\n                bf_mul_2exp(r, e, ctx->fp_env.prec, ctx->fp_env.flags);\n            } else {\n                bf_mul_2exp(r, ctx->fp_env.prec, ctx->fp_env.prec,\n                            ctx->fp_env.flags);\n                bf_add_si(r, r, -1, ctx->fp_env.prec, ctx->fp_env.flags);\n                bf_mul_2exp(r, e_range - ctx->fp_env.prec, ctx->fp_env.prec,\n                            ctx->fp_env.flags);\n            }\n        }\n        break;\n    case 4: /* EPSILON */\n        bf_set_ui(r, 1);\n        bf_mul_2exp(r, 1 - ctx->fp_env.prec,\n                    ctx->fp_env.prec, ctx->fp_env.flags);\n        break;\n    default:\n        abort();\n    }\n    return val;\n}\n\nstatic JSValue js_bigfloat_parseFloat(JSContext *ctx, JSValueConst this_val,\n                                      int argc, JSValueConst *argv)\n{\n    bf_t *a;\n    const char *str;\n    JSValue ret;\n    int radix;\n    JSFloatEnv *fe;\n\n    str = JS_ToCString(ctx, argv[0]);\n    if (!str)\n        return JS_EXCEPTION;\n    if (JS_ToInt32(ctx, &radix, argv[1])) {\n    fail:\n        JS_FreeCString(ctx, str);\n        return JS_EXCEPTION;\n    }\n    if (radix != 0 && (radix < 2 || radix > 36)) {\n        JS_ThrowRangeError(ctx, \"radix must be between 2 and 36\");\n        goto fail;\n    }\n    fe = &ctx->fp_env;\n    if (argc > 2) {\n        fe = JS_GetOpaque2(ctx, argv[2], JS_CLASS_FLOAT_ENV);\n        if (!fe)\n            goto fail;\n    }\n    ret = JS_NewBigFloat(ctx);\n    if (JS_IsException(ret))\n        goto done;\n    a = JS_GetBigFloat(ret);\n    /* XXX: use js_atof() */\n    bf_atof(a, str, NULL, radix, fe->prec, fe->flags);\n done:\n    JS_FreeCString(ctx, str);\n    return ret;\n}\n\nstatic JSValue js_bigfloat_isFinite(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv)\n{\n    JSValueConst val = argv[0];\n    JSBigFloat *p;\n    \n    if (JS_VALUE_GET_NORM_TAG(val) != JS_TAG_BIG_FLOAT)\n        return JS_FALSE;\n    p = JS_VALUE_GET_PTR(val);\n    return JS_NewBool(ctx, bf_is_finite(&p->num));\n}\n\nstatic JSValue js_bigfloat_isNaN(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    JSValueConst val = argv[0];\n    JSBigFloat *p;\n    \n    if (JS_VALUE_GET_NORM_TAG(val) != JS_TAG_BIG_FLOAT)\n        return JS_FALSE;\n    p = JS_VALUE_GET_PTR(val);\n    return JS_NewBool(ctx, bf_is_nan(&p->num));\n}\n\nenum {\n    MATH_OP_ABS,\n    MATH_OP_FLOOR,\n    MATH_OP_CEIL,\n    MATH_OP_ROUND,\n    MATH_OP_TRUNC,\n    MATH_OP_SQRT,\n    MATH_OP_FPROUND,\n    MATH_OP_ACOS,\n    MATH_OP_ASIN,\n    MATH_OP_ATAN,\n    MATH_OP_ATAN2,\n    MATH_OP_COS,\n    MATH_OP_EXP,\n    MATH_OP_LOG,\n    MATH_OP_POW,\n    MATH_OP_SIN,\n    MATH_OP_TAN,\n    MATH_OP_FMOD,\n    MATH_OP_REM,\n    MATH_OP_SIGN,\n\n    MATH_OP_ADD,\n    MATH_OP_SUB,\n    MATH_OP_MUL,\n    MATH_OP_DIV,\n};\n\nstatic JSValue js_bigfloat_fop(JSContext *ctx, JSValueConst this_val,\n                           int argc, JSValueConst *argv, int magic)\n{\n    bf_t a_s, *a, *r;\n    JSFloatEnv *fe;\n    int rnd_mode;\n    JSValue op1, res;\n\n    op1 = JS_ToNumeric(ctx, argv[0]);\n    if (JS_IsException(op1))\n        return op1;\n    a = JS_ToBigFloat(ctx, &a_s, op1);\n    fe = &ctx->fp_env;\n    if (argc > 1) {\n        fe = JS_GetOpaque2(ctx, argv[1], JS_CLASS_FLOAT_ENV);\n        if (!fe)\n            goto fail;\n    }\n    res = JS_NewBigFloat(ctx);\n    if (JS_IsException(res)) {\n    fail:\n        if (a == &a_s)\n            bf_delete(a);\n        JS_FreeValue(ctx, op1);\n        return JS_EXCEPTION;\n    }\n    r = JS_GetBigFloat(res);\n    switch (magic) {\n    case MATH_OP_ABS:\n        bf_set(r, a);\n        r->sign = 0;\n        break;\n    case MATH_OP_FLOOR:\n        rnd_mode = BF_RNDD;\n        goto rint;\n    case MATH_OP_CEIL:\n        rnd_mode = BF_RNDU;\n        goto rint;\n    case MATH_OP_ROUND:\n        rnd_mode = BF_RNDNA;\n        goto rint;\n    case MATH_OP_TRUNC:\n        rnd_mode = BF_RNDZ;\n    rint:\n        bf_set(r, a);\n        fe->status |= bf_rint(r, rnd_mode);\n        break;\n    case MATH_OP_SQRT:\n        fe->status |= bf_sqrt(r, a, fe->prec, fe->flags);\n        break;\n    case MATH_OP_FPROUND:\n        bf_set(r, a);\n        fe->status |= bf_round(r, fe->prec, fe->flags);\n        break;\n    case MATH_OP_ACOS:\n        fe->status |= bf_acos(r, a, fe->prec, fe->flags);\n        break;\n    case MATH_OP_ASIN:\n        fe->status |= bf_asin(r, a, fe->prec, fe->flags);\n        break;\n    case MATH_OP_ATAN:\n        fe->status |= bf_atan(r, a, fe->prec, fe->flags);\n        break;\n    case MATH_OP_COS:\n        fe->status |= bf_cos(r, a, fe->prec, fe->flags);\n        break;\n    case MATH_OP_EXP:\n        fe->status |= bf_exp(r, a, fe->prec, fe->flags);\n        break;\n    case MATH_OP_LOG:\n        fe->status |= bf_log(r, a, fe->prec, fe->flags);\n        break;\n    case MATH_OP_SIN:\n        fe->status |= bf_sin(r, a, fe->prec, fe->flags);\n        break;\n    case MATH_OP_TAN:\n        fe->status |= bf_tan(r, a, fe->prec, fe->flags);\n        break;\n    case MATH_OP_SIGN:\n        if (bf_is_nan(a) || bf_is_zero(a)) {\n            bf_set(r, a);\n        } else {\n            bf_set_si(r, 1 - 2 * a->sign);\n        }\n        break;\n    default:\n        abort();\n    }\n    if (a == &a_s)\n        bf_delete(a);\n    JS_FreeValue(ctx, op1);\n    return res;\n}\n\nstatic JSValue js_bigfloat_fop2(JSContext *ctx, JSValueConst this_val,\n                            int argc, JSValueConst *argv, int magic)\n{\n    bf_t a_s, *a, b_s, *b, r_s, *r = &r_s;\n    JSFloatEnv *fe;\n    JSValue op1, op2, res;\n\n    op1 = JS_ToNumeric(ctx, argv[0]);\n    if (JS_IsException(op1))\n        return op1;\n    op2 = JS_ToNumeric(ctx, argv[1]);\n    if (JS_IsException(op2)) {\n        JS_FreeValue(ctx, op1);\n        return op2;\n    }\n    a = JS_ToBigFloat(ctx, &a_s, op1);\n    b = JS_ToBigFloat(ctx, &b_s, op2);\n    fe = &ctx->fp_env;\n    if (argc > 2) {\n        fe = JS_GetOpaque2(ctx, argv[2], JS_CLASS_FLOAT_ENV);\n        if (!fe)\n            goto fail;\n    }\n    res = JS_NewBigFloat(ctx);\n    if (JS_IsException(res)) {\n    fail:\n        if (a == &a_s)\n            bf_delete(a);\n        if (b == &b_s)\n            bf_delete(b);\n        JS_FreeValue(ctx, op1);\n        JS_FreeValue(ctx, op2);\n        return JS_EXCEPTION;\n    }\n    r = JS_GetBigFloat(res);\n    switch (magic) {\n    case MATH_OP_ATAN2:\n        fe->status |= bf_atan2(r, a, b, fe->prec, fe->flags);\n        break;\n    case MATH_OP_POW:\n        fe->status |= bf_pow(r, a, b, fe->prec, fe->flags | BF_POW_JS_QUIRKS);\n        break;\n    case MATH_OP_FMOD:\n        fe->status |= bf_rem(r, a, b, fe->prec, fe->flags, BF_RNDZ);\n        break;\n    case MATH_OP_REM:\n        fe->status |= bf_rem(r, a, b, fe->prec, fe->flags, BF_RNDN);\n        break;\n    case MATH_OP_ADD:\n        fe->status |= bf_add(r, a, b, fe->prec, fe->flags);\n        break;\n    case MATH_OP_SUB:\n        fe->status |= bf_sub(r, a, b, fe->prec, fe->flags);\n        break;\n    case MATH_OP_MUL:\n        fe->status |= bf_mul(r, a, b, fe->prec, fe->flags);\n        break;\n    case MATH_OP_DIV:\n        fe->status |= bf_div(r, a, b, fe->prec, fe->flags);\n        break;\n    default:\n        abort();\n    }\n    if (a == &a_s)\n        bf_delete(a);\n    if (b == &b_s)\n        bf_delete(b);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    return res;\n}\n\nstatic const JSCFunctionListEntry js_bigfloat_funcs[] = {\n    JS_CGETSET_MAGIC_DEF(\"PI\", js_bigfloat_get_const, NULL, 0 ),\n    JS_CGETSET_MAGIC_DEF(\"LN2\", js_bigfloat_get_const, NULL, 1 ),\n    JS_CGETSET_MAGIC_DEF(\"MIN_VALUE\", js_bigfloat_get_const, NULL, 2 ),\n    JS_CGETSET_MAGIC_DEF(\"MAX_VALUE\", js_bigfloat_get_const, NULL, 3 ),\n    JS_CGETSET_MAGIC_DEF(\"EPSILON\", js_bigfloat_get_const, NULL, 4 ),\n    JS_CFUNC_DEF(\"parseFloat\", 1, js_bigfloat_parseFloat ),\n    JS_CFUNC_DEF(\"isFinite\", 1, js_bigfloat_isFinite ),\n    JS_CFUNC_DEF(\"isNaN\", 1, js_bigfloat_isNaN ),\n    JS_CFUNC_MAGIC_DEF(\"abs\", 1, js_bigfloat_fop, MATH_OP_ABS ),\n    JS_CFUNC_MAGIC_DEF(\"fpRound\", 1, js_bigfloat_fop, MATH_OP_FPROUND ),\n    JS_CFUNC_MAGIC_DEF(\"floor\", 1, js_bigfloat_fop, MATH_OP_FLOOR ),\n    JS_CFUNC_MAGIC_DEF(\"ceil\", 1, js_bigfloat_fop, MATH_OP_CEIL ),\n    JS_CFUNC_MAGIC_DEF(\"round\", 1, js_bigfloat_fop, MATH_OP_ROUND ),\n    JS_CFUNC_MAGIC_DEF(\"trunc\", 1, js_bigfloat_fop, MATH_OP_TRUNC ),\n    JS_CFUNC_MAGIC_DEF(\"sqrt\", 1, js_bigfloat_fop, MATH_OP_SQRT ),\n    JS_CFUNC_MAGIC_DEF(\"acos\", 1, js_bigfloat_fop, MATH_OP_ACOS ),\n    JS_CFUNC_MAGIC_DEF(\"asin\", 1, js_bigfloat_fop, MATH_OP_ASIN ),\n    JS_CFUNC_MAGIC_DEF(\"atan\", 1, js_bigfloat_fop, MATH_OP_ATAN ),\n    JS_CFUNC_MAGIC_DEF(\"atan2\", 2, js_bigfloat_fop2, MATH_OP_ATAN2 ),\n    JS_CFUNC_MAGIC_DEF(\"cos\", 1, js_bigfloat_fop, MATH_OP_COS ),\n    JS_CFUNC_MAGIC_DEF(\"exp\", 1, js_bigfloat_fop, MATH_OP_EXP ),\n    JS_CFUNC_MAGIC_DEF(\"log\", 1, js_bigfloat_fop, MATH_OP_LOG ),\n    JS_CFUNC_MAGIC_DEF(\"pow\", 2, js_bigfloat_fop2, MATH_OP_POW ),\n    JS_CFUNC_MAGIC_DEF(\"sin\", 1, js_bigfloat_fop, MATH_OP_SIN ),\n    JS_CFUNC_MAGIC_DEF(\"tan\", 1, js_bigfloat_fop, MATH_OP_TAN ),\n    JS_CFUNC_MAGIC_DEF(\"sign\", 1, js_bigfloat_fop, MATH_OP_SIGN ),\n    JS_CFUNC_MAGIC_DEF(\"add\", 2, js_bigfloat_fop2, MATH_OP_ADD ),\n    JS_CFUNC_MAGIC_DEF(\"sub\", 2, js_bigfloat_fop2, MATH_OP_SUB ),\n    JS_CFUNC_MAGIC_DEF(\"mul\", 2, js_bigfloat_fop2, MATH_OP_MUL ),\n    JS_CFUNC_MAGIC_DEF(\"div\", 2, js_bigfloat_fop2, MATH_OP_DIV ),\n    JS_CFUNC_MAGIC_DEF(\"fmod\", 2, js_bigfloat_fop2, MATH_OP_FMOD ),\n    JS_CFUNC_MAGIC_DEF(\"remainder\", 2, js_bigfloat_fop2, MATH_OP_REM ),\n};\n\n/* FloatEnv */\n\nstatic JSValue js_float_env_constructor(JSContext *ctx,\n                                        JSValueConst new_target,\n                                        int argc, JSValueConst *argv)\n{\n    JSValue obj;\n    JSFloatEnv *fe;\n    int64_t prec;\n    int flags, rndmode;\n\n    prec = ctx->fp_env.prec;\n    flags = ctx->fp_env.flags;\n    if (!JS_IsUndefined(argv[0])) {\n        if (JS_ToInt64Sat(ctx, &prec, argv[0]))\n            return JS_EXCEPTION;\n        if (prec < BF_PREC_MIN || prec > BF_PREC_MAX)\n            return JS_ThrowRangeError(ctx, \"invalid precision\");\n        flags = BF_RNDN; /* RNDN, max exponent size, no subnormal */\n        if (argc > 1 && !JS_IsUndefined(argv[1])) {\n            if (JS_ToInt32Sat(ctx, &rndmode, argv[1]))\n                return JS_EXCEPTION;\n            if (rndmode < BF_RNDN || rndmode > BF_RNDF)\n                return JS_ThrowRangeError(ctx, \"invalid rounding mode\");\n            flags = rndmode;\n        }\n    }\n\n    obj = JS_NewObjectClass(ctx, JS_CLASS_FLOAT_ENV);\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n    fe = js_malloc(ctx, sizeof(*fe));\n    if (!fe)\n        return JS_EXCEPTION;\n    fe->prec = prec;\n    fe->flags = flags;\n    fe->status = 0;\n    JS_SetOpaque(obj, fe);\n    return obj;\n}\n\nstatic void js_float_env_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSFloatEnv *fe = JS_GetOpaque(val, JS_CLASS_FLOAT_ENV);\n    js_free_rt(rt, fe);\n}\n\nstatic JSValue js_float_env_get_prec(JSContext *ctx, JSValueConst this_val)\n{\n    return JS_NewInt64(ctx, ctx->fp_env.prec);\n}\n\nstatic JSValue js_float_env_get_expBits(JSContext *ctx, JSValueConst this_val)\n{\n    return JS_NewInt32(ctx, bf_get_exp_bits(ctx->fp_env.flags));\n}\n\nstatic JSValue js_float_env_setPrec(JSContext *ctx,\n                                    JSValueConst this_val,\n                                    int argc, JSValueConst *argv)\n{\n    JSValueConst func;\n    int exp_bits, flags, saved_flags;\n    JSValue ret;\n    limb_t saved_prec;\n    int64_t prec;\n\n    func = argv[0];\n    if (JS_ToInt64Sat(ctx, &prec, argv[1]))\n        return JS_EXCEPTION;\n    if (prec < BF_PREC_MIN || prec > BF_PREC_MAX)\n        return JS_ThrowRangeError(ctx, \"invalid precision\");\n    exp_bits = BF_EXP_BITS_MAX;\n\n    if (argc > 2 && !JS_IsUndefined(argv[2])) {\n        if (JS_ToInt32Sat(ctx, &exp_bits, argv[2]))\n            return JS_EXCEPTION;\n        if (exp_bits < BF_EXP_BITS_MIN || exp_bits > BF_EXP_BITS_MAX)\n            return JS_ThrowRangeError(ctx, \"invalid number of exponent bits\");\n    }\n\n    flags = BF_RNDN | BF_FLAG_SUBNORMAL | bf_set_exp_bits(exp_bits);\n\n    saved_prec = ctx->fp_env.prec;\n    saved_flags = ctx->fp_env.flags;\n\n    ctx->fp_env.prec = prec;\n    ctx->fp_env.flags = flags;\n\n    ret = JS_Call(ctx, func, JS_UNDEFINED, 0, NULL);\n    /* always restore the floating point precision */\n    ctx->fp_env.prec = saved_prec;\n    ctx->fp_env.flags = saved_flags;\n    return ret;\n}\n\n#define FE_PREC      (-1)\n#define FE_EXP       (-2)\n#define FE_RNDMODE   (-3)\n#define FE_SUBNORMAL (-4)\n\nstatic JSValue js_float_env_proto_get_status(JSContext *ctx, JSValueConst this_val, int magic)\n{\n    JSFloatEnv *fe;\n    fe = JS_GetOpaque2(ctx, this_val, JS_CLASS_FLOAT_ENV);\n    if (!fe)\n        return JS_EXCEPTION;\n    switch(magic) {\n    case FE_PREC:\n        return JS_NewInt64(ctx, fe->prec);\n    case FE_EXP:\n        return JS_NewInt32(ctx, bf_get_exp_bits(fe->flags));\n    case FE_RNDMODE:\n        return JS_NewInt32(ctx, fe->flags & BF_RND_MASK);\n    case FE_SUBNORMAL:\n        return JS_NewBool(ctx, (fe->flags & BF_FLAG_SUBNORMAL) != 0);\n    default:\n        return JS_NewBool(ctx, (fe->status & magic) != 0);\n    }\n}\n\nstatic JSValue js_float_env_proto_set_status(JSContext *ctx, JSValueConst this_val, JSValueConst val, int magic)\n{\n    JSFloatEnv *fe;\n    int b;\n    int64_t prec;\n\n    fe = JS_GetOpaque2(ctx, this_val, JS_CLASS_FLOAT_ENV);\n    if (!fe)\n        return JS_EXCEPTION;\n    switch(magic) {\n    case FE_PREC:\n        if (JS_ToInt64Sat(ctx, &prec, val))\n            return JS_EXCEPTION;\n        if (prec < BF_PREC_MIN || prec > BF_PREC_MAX)\n            return JS_ThrowRangeError(ctx, \"invalid precision\");\n        fe->prec = prec;\n        break;\n    case FE_EXP:\n        if (JS_ToInt32Sat(ctx, &b, val))\n            return JS_EXCEPTION;\n        if (b < BF_EXP_BITS_MIN || b > BF_EXP_BITS_MAX)\n            return JS_ThrowRangeError(ctx, \"invalid number of exponent bits\");\n        fe->flags = (fe->flags & ~(BF_EXP_BITS_MASK << BF_EXP_BITS_SHIFT)) |\n            bf_set_exp_bits(b);\n        break;\n    case FE_RNDMODE:\n        b = bigfloat_get_rnd_mode(ctx, val);\n        if (b < 0)\n            return JS_EXCEPTION;\n        fe->flags = (fe->flags & ~BF_RND_MASK) | b;\n        break;\n    case FE_SUBNORMAL:\n        b = JS_ToBool(ctx, val);\n        fe->flags = (fe->flags & ~BF_FLAG_SUBNORMAL) | (b ? BF_FLAG_SUBNORMAL: 0);\n        break;\n    default:\n        b = JS_ToBool(ctx, val);\n        fe->status = (fe->status & ~magic) & ((-b) & magic);\n        break;\n    }\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_float_env_clearStatus(JSContext *ctx,\n                                        JSValueConst this_val,\n                                        int argc, JSValueConst *argv)\n{\n    JSFloatEnv *fe = JS_GetOpaque2(ctx, this_val, JS_CLASS_FLOAT_ENV);\n    if (!fe)\n        return JS_EXCEPTION;\n    fe->status = 0;\n    return JS_UNDEFINED;\n}\n\nstatic const JSCFunctionListEntry js_float_env_funcs[] = {\n    JS_CGETSET_DEF(\"prec\", js_float_env_get_prec, NULL ),\n    JS_CGETSET_DEF(\"expBits\", js_float_env_get_expBits, NULL ),\n    JS_CFUNC_DEF(\"setPrec\", 2, js_float_env_setPrec ),\n    JS_PROP_INT32_DEF(\"RNDN\", BF_RNDN, 0 ),\n    JS_PROP_INT32_DEF(\"RNDZ\", BF_RNDZ, 0 ),\n    JS_PROP_INT32_DEF(\"RNDU\", BF_RNDU, 0 ),\n    JS_PROP_INT32_DEF(\"RNDD\", BF_RNDD, 0 ),\n    JS_PROP_INT32_DEF(\"RNDNA\", BF_RNDNA, 0 ),\n    JS_PROP_INT32_DEF(\"RNDA\", BF_RNDA, 0 ),\n    JS_PROP_INT32_DEF(\"RNDF\", BF_RNDF, 0 ),\n    JS_PROP_INT32_DEF(\"precMin\", BF_PREC_MIN, 0 ),\n    JS_PROP_INT64_DEF(\"precMax\", BF_PREC_MAX, 0 ),\n    JS_PROP_INT32_DEF(\"expBitsMin\", BF_EXP_BITS_MIN, 0 ),\n    JS_PROP_INT32_DEF(\"expBitsMax\", BF_EXP_BITS_MAX, 0 ),\n};\n\nstatic const JSCFunctionListEntry js_float_env_proto_funcs[] = {\n    JS_CGETSET_MAGIC_DEF(\"prec\", js_float_env_proto_get_status,\n                         js_float_env_proto_set_status, FE_PREC ),\n    JS_CGETSET_MAGIC_DEF(\"expBits\", js_float_env_proto_get_status,\n                         js_float_env_proto_set_status, FE_EXP ),\n    JS_CGETSET_MAGIC_DEF(\"rndMode\", js_float_env_proto_get_status,\n                         js_float_env_proto_set_status, FE_RNDMODE ),\n    JS_CGETSET_MAGIC_DEF(\"subnormal\", js_float_env_proto_get_status,\n                         js_float_env_proto_set_status, FE_SUBNORMAL ),\n    JS_CGETSET_MAGIC_DEF(\"invalidOperation\", js_float_env_proto_get_status,\n                         js_float_env_proto_set_status, BF_ST_INVALID_OP ),\n    JS_CGETSET_MAGIC_DEF(\"divideByZero\", js_float_env_proto_get_status,\n                         js_float_env_proto_set_status, BF_ST_DIVIDE_ZERO ),\n    JS_CGETSET_MAGIC_DEF(\"overflow\", js_float_env_proto_get_status,\n                         js_float_env_proto_set_status, BF_ST_OVERFLOW ),\n    JS_CGETSET_MAGIC_DEF(\"underflow\", js_float_env_proto_get_status,\n                         js_float_env_proto_set_status, BF_ST_UNDERFLOW ),\n    JS_CGETSET_MAGIC_DEF(\"inexact\", js_float_env_proto_get_status,\n                         js_float_env_proto_set_status, BF_ST_INEXACT ),\n    JS_CFUNC_DEF(\"clearStatus\", 0, js_float_env_clearStatus ),\n};\n\nvoid JS_AddIntrinsicBigFloat(JSContext *ctx)\n{\n    JSRuntime *rt = ctx->rt;\n    JSValueConst obj1;\n    \n    rt->bigfloat_ops.to_string = js_bigfloat_to_string;\n    rt->bigfloat_ops.from_string = js_string_to_bigfloat;\n    rt->bigfloat_ops.unary_arith = js_unary_arith_bigfloat;\n    rt->bigfloat_ops.binary_arith = js_binary_arith_bigfloat;\n    rt->bigfloat_ops.compare = js_compare_bigfloat;\n    rt->bigfloat_ops.mul_pow10_to_float64 = js_mul_pow10_to_float64;\n    rt->bigfloat_ops.mul_pow10 = js_mul_pow10;\n    \n    ctx->class_proto[JS_CLASS_BIG_FLOAT] = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BIG_FLOAT],\n                               js_bigfloat_proto_funcs,\n                               countof(js_bigfloat_proto_funcs));\n    obj1 = JS_NewGlobalCConstructor(ctx, \"BigFloat\", js_bigfloat_constructor, 1,\n                                    ctx->class_proto[JS_CLASS_BIG_FLOAT]);\n    JS_SetPropertyFunctionList(ctx, obj1, js_bigfloat_funcs,\n                               countof(js_bigfloat_funcs));\n\n    ctx->class_proto[JS_CLASS_FLOAT_ENV] = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_FLOAT_ENV],\n                               js_float_env_proto_funcs,\n                               countof(js_float_env_proto_funcs));\n    obj1 = JS_NewGlobalCConstructorOnly(ctx, \"BigFloatEnv\",\n                                        js_float_env_constructor, 1,\n                                        ctx->class_proto[JS_CLASS_FLOAT_ENV]);\n    JS_SetPropertyFunctionList(ctx, obj1, js_float_env_funcs,\n                               countof(js_float_env_funcs));\n}\n\n/* BigDecimal */\n\nstatic JSValue JS_ToBigDecimalFree(JSContext *ctx, JSValue val,\n                                   BOOL allow_null_or_undefined)\n{\n redo:\n    switch(JS_VALUE_GET_NORM_TAG(val)) {\n    case JS_TAG_BIG_DECIMAL:\n        break;\n    case JS_TAG_NULL:\n        if (!allow_null_or_undefined)\n            goto fail;\n        /* fall thru */\n    case JS_TAG_BOOL:\n    case JS_TAG_INT:\n        {\n            bfdec_t *r;\n            int32_t v = JS_VALUE_GET_INT(val);\n\n            val = JS_NewBigDecimal(ctx);\n            if (JS_IsException(val))\n                break;\n            r = JS_GetBigDecimal(val);\n            if (bfdec_set_si(r, v)) {\n                JS_FreeValue(ctx, val);\n                val = JS_EXCEPTION;\n                break;\n            }\n        }\n        break;\n    case JS_TAG_FLOAT64:\n    case JS_TAG_BIG_INT:\n    case JS_TAG_BIG_FLOAT:\n        val = JS_ToStringFree(ctx, val);\n        if (JS_IsException(val))\n            break;\n        goto redo;\n    case JS_TAG_STRING:\n        {\n            const char *str, *p;\n            size_t len;\n            int err;\n\n            str = JS_ToCStringLen(ctx, &len, val);\n            JS_FreeValue(ctx, val);\n            if (!str)\n                return JS_EXCEPTION;\n            p = str;\n            p += skip_spaces(p);\n            if ((p - str) == len) {\n                bfdec_t *r;\n                val = JS_NewBigDecimal(ctx);\n                if (JS_IsException(val))\n                    break;\n                r = JS_GetBigDecimal(val);\n                bfdec_set_zero(r, 0);\n                err = 0;\n            } else {\n                val = js_atof(ctx, p, &p, 0, ATOD_TYPE_BIG_DECIMAL);\n                if (JS_IsException(val)) {\n                    JS_FreeCString(ctx, str);\n                    return JS_EXCEPTION;\n                }\n                p += skip_spaces(p);\n                err = ((p - str) != len);\n            }\n            JS_FreeCString(ctx, str);\n            if (err) {\n                JS_FreeValue(ctx, val);\n                return JS_ThrowSyntaxError(ctx, \"invalid bigdecimal literal\");\n            }\n        }\n        break;\n    case JS_TAG_OBJECT:\n        val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);\n        if (JS_IsException(val))\n            break;\n        goto redo;\n    case JS_TAG_UNDEFINED:\n        {\n            bfdec_t *r;\n            if (!allow_null_or_undefined)\n                goto fail;\n            val = JS_NewBigDecimal(ctx);\n            if (JS_IsException(val))\n                break;\n            r = JS_GetBigDecimal(val);\n            bfdec_set_nan(r);\n        }\n        break;\n    default:\n    fail:\n        JS_FreeValue(ctx, val);\n        return JS_ThrowTypeError(ctx, \"cannot convert to bigdecimal\");\n    }\n    return val;\n}\n\nstatic JSValue js_bigdecimal_constructor(JSContext *ctx,\n                                         JSValueConst new_target,\n                                         int argc, JSValueConst *argv)\n{\n    JSValue val;\n    if (!JS_IsUndefined(new_target))\n        return JS_ThrowTypeError(ctx, \"not a constructor\");\n    if (argc == 0) {\n        bfdec_t *r;\n        val = JS_NewBigDecimal(ctx);\n        if (JS_IsException(val))\n            return val;\n        r = JS_GetBigDecimal(val);\n        bfdec_set_zero(r, 0);\n    } else {\n        val = JS_ToBigDecimalFree(ctx, JS_DupValue(ctx, argv[0]), FALSE);\n    }\n    return val;\n}\n\nstatic JSValue js_thisBigDecimalValue(JSContext *ctx, JSValueConst this_val)\n{\n    if (JS_IsBigDecimal(this_val))\n        return JS_DupValue(ctx, this_val);\n\n    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(this_val);\n        if (p->class_id == JS_CLASS_BIG_DECIMAL) {\n            if (JS_IsBigDecimal(p->u.object_data))\n                return JS_DupValue(ctx, p->u.object_data);\n        }\n    }\n    return JS_ThrowTypeError(ctx, \"not a bigdecimal\");\n}\n\nstatic JSValue js_bigdecimal_toString(JSContext *ctx, JSValueConst this_val,\n                                      int argc, JSValueConst *argv)\n{\n    JSValue val;\n\n    val = js_thisBigDecimalValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    return JS_ToStringFree(ctx, val);\n}\n\nstatic JSValue js_bigdecimal_valueOf(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    return js_thisBigDecimalValue(ctx, this_val);\n}\n\nstatic int js_bigdecimal_get_rnd_mode(JSContext *ctx, JSValueConst obj)\n{\n    const char *str;\n    size_t size;\n    int rnd_mode;\n    \n    str = JS_ToCStringLen(ctx, &size, obj);\n    if (!str)\n        return -1;\n    if (strlen(str) != size)\n        goto invalid_rounding_mode;\n    if (!strcmp(str, \"floor\")) {\n        rnd_mode = BF_RNDD;\n    } else if (!strcmp(str, \"ceiling\")) {\n        rnd_mode = BF_RNDU;\n    } else if (!strcmp(str, \"down\")) {\n        rnd_mode = BF_RNDZ;\n    } else if (!strcmp(str, \"up\")) {\n        rnd_mode = BF_RNDA;\n    } else if (!strcmp(str, \"half-even\")) {\n        rnd_mode = BF_RNDN;\n    } else if (!strcmp(str, \"half-up\")) {\n        rnd_mode = BF_RNDNA;\n    } else {\n    invalid_rounding_mode:\n        JS_FreeCString(ctx, str);\n        JS_ThrowTypeError(ctx, \"invalid rounding mode\");\n        return -1;\n    }\n    JS_FreeCString(ctx, str);\n    return rnd_mode;\n}\n\ntypedef struct {\n    int64_t prec;\n    bf_flags_t flags;\n} BigDecimalEnv;\n\nstatic int js_bigdecimal_get_env(JSContext *ctx, BigDecimalEnv *fe,\n                                 JSValueConst obj)\n{\n    JSValue prop;\n    int64_t val;\n    BOOL has_prec;\n    int rnd_mode;\n    \n    if (!JS_IsObject(obj)) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        return -1;\n    }\n    prop = JS_GetProperty(ctx, obj, JS_ATOM_roundingMode);\n    if (JS_IsException(prop))\n        return -1;\n    rnd_mode = js_bigdecimal_get_rnd_mode(ctx, prop);\n    JS_FreeValue(ctx, prop);\n    if (rnd_mode < 0)\n        return -1;\n    fe->flags = rnd_mode;\n    \n    prop = JS_GetProperty(ctx, obj, JS_ATOM_maximumSignificantDigits);\n    if (JS_IsException(prop))\n        return -1;\n    has_prec = FALSE;\n    if (!JS_IsUndefined(prop)) {\n        if (JS_ToInt64SatFree(ctx, &val, prop))\n            return -1;\n        if (val < 1 || val > BF_PREC_MAX)\n            goto invalid_precision;\n        fe->prec = val;\n        has_prec = TRUE;\n    }\n\n    prop = JS_GetProperty(ctx, obj, JS_ATOM_maximumFractionDigits);\n    if (JS_IsException(prop))\n        return -1;\n    if (!JS_IsUndefined(prop)) {\n        if (has_prec) {\n            JS_FreeValue(ctx, prop);\n            JS_ThrowTypeError(ctx, \"cannot provide both maximumSignificantDigits and maximumFractionDigits\");\n            return -1;\n        }\n        if (JS_ToInt64SatFree(ctx, &val, prop))\n            return -1;\n        if (val < 0 || val > BF_PREC_MAX) {\n        invalid_precision:\n            JS_ThrowTypeError(ctx, \"invalid precision\");\n            return -1;\n        }\n        fe->prec = val;\n        fe->flags |= BF_FLAG_RADPNT_PREC;\n        has_prec = TRUE;\n    }\n    if (!has_prec) {\n        JS_ThrowTypeError(ctx, \"precision must be present\");\n        return -1;\n    }\n    return 0;\n}\n\n\nstatic JSValue js_bigdecimal_fop(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv, int magic)\n{\n    bfdec_t *a, *b, r_s, *r = &r_s;\n    JSValue op1, op2, res;\n    BigDecimalEnv fe_s, *fe = &fe_s;\n    int op_count, ret;\n\n    if (magic == MATH_OP_SQRT ||\n        magic == MATH_OP_ROUND)\n        op_count = 1;\n    else\n        op_count = 2;\n    \n    op1 = JS_ToNumeric(ctx, argv[0]);\n    if (JS_IsException(op1))\n        return op1;\n    a = JS_ToBigDecimal(ctx, op1);\n    if (!a) {\n        JS_FreeValue(ctx, op1);\n        return JS_EXCEPTION;\n    }\n    if (op_count >= 2) {\n        op2 = JS_ToNumeric(ctx, argv[1]);\n        if (JS_IsException(op2)) {\n            JS_FreeValue(ctx, op1);\n            return op2;\n        }\n        b = JS_ToBigDecimal(ctx, op2);\n        if (!b)\n            goto fail;\n    } else {\n        op2 = JS_UNDEFINED;\n        b = NULL;\n    }\n    fe->flags = BF_RNDZ;\n    fe->prec = BF_PREC_INF;\n    if (op_count < argc) {\n        if (js_bigdecimal_get_env(ctx, fe, argv[op_count]))\n            goto fail;\n    }\n\n    res = JS_NewBigDecimal(ctx);\n    if (JS_IsException(res)) {\n    fail:\n        JS_FreeValue(ctx, op1);\n        JS_FreeValue(ctx, op2);\n        return JS_EXCEPTION;\n    }\n    r = JS_GetBigDecimal(res);\n    switch (magic) {\n    case MATH_OP_ADD:\n        ret = bfdec_add(r, a, b, fe->prec, fe->flags);\n        break;\n    case MATH_OP_SUB:\n        ret = bfdec_sub(r, a, b, fe->prec, fe->flags);\n        break;\n    case MATH_OP_MUL:\n        ret = bfdec_mul(r, a, b, fe->prec, fe->flags);\n        break;\n    case MATH_OP_DIV:\n        ret = bfdec_div(r, a, b, fe->prec, fe->flags);\n        break;\n    case MATH_OP_FMOD:\n        ret = bfdec_rem(r, a, b, fe->prec, fe->flags, BF_RNDZ);\n        break;\n    case MATH_OP_SQRT:\n        ret = bfdec_sqrt(r, a, fe->prec, fe->flags);\n        break;\n    case MATH_OP_ROUND:\n        ret = bfdec_set(r, a);\n        if (!(ret & BF_ST_MEM_ERROR))\n            ret = bfdec_round(r, fe->prec, fe->flags);\n        break;\n    default:\n        abort();\n    }\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    ret &= BF_ST_MEM_ERROR | BF_ST_DIVIDE_ZERO | BF_ST_INVALID_OP |\n        BF_ST_OVERFLOW;\n    if (ret != 0) {\n        JS_FreeValue(ctx, res);\n        return throw_bf_exception(ctx, ret);\n    } else {\n        return res;\n    }\n}\n\nstatic JSValue js_bigdecimal_toFixed(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    JSValue val, ret;\n    int64_t f;\n    int rnd_mode;\n\n    val = js_thisBigDecimalValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    if (JS_ToInt64Sat(ctx, &f, argv[0]))\n        goto fail;\n    if (f < 0 || f > BF_PREC_MAX) {\n        JS_ThrowRangeError(ctx, \"invalid number of digits\");\n        goto fail;\n    }\n    rnd_mode = BF_RNDNA;\n    if (argc > 1) {\n        rnd_mode = js_bigdecimal_get_rnd_mode(ctx, argv[1]);\n        if (rnd_mode < 0)\n            goto fail;\n    }\n    ret = js_bigdecimal_to_string1(ctx, val, f, rnd_mode | BF_FTOA_FORMAT_FRAC);\n    JS_FreeValue(ctx, val);\n    return ret;\n fail:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_bigdecimal_toExponential(JSContext *ctx, JSValueConst this_val,\n                                       int argc, JSValueConst *argv)\n{\n    JSValue val, ret;\n    int64_t f;\n    int rnd_mode;\n\n    val = js_thisBigDecimalValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    if (JS_ToInt64Sat(ctx, &f, argv[0]))\n        goto fail;\n    if (JS_IsUndefined(argv[0])) {\n        ret = js_bigdecimal_to_string1(ctx, val, 0,\n                  BF_RNDN | BF_FTOA_FORMAT_FREE_MIN | BF_FTOA_FORCE_EXP);\n    } else {\n        if (f < 0 || f > BF_PREC_MAX) {\n            JS_ThrowRangeError(ctx, \"invalid number of digits\");\n            goto fail;\n        }\n        rnd_mode = BF_RNDNA;\n        if (argc > 1) {\n            rnd_mode = js_bigdecimal_get_rnd_mode(ctx, argv[1]);\n            if (rnd_mode < 0)\n                goto fail;\n        }\n        ret = js_bigdecimal_to_string1(ctx, val, f + 1,\n                      rnd_mode | BF_FTOA_FORMAT_FIXED | BF_FTOA_FORCE_EXP);\n    }\n    JS_FreeValue(ctx, val);\n    return ret;\n fail:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_bigdecimal_toPrecision(JSContext *ctx, JSValueConst this_val,\n                                     int argc, JSValueConst *argv)\n{\n    JSValue val, ret;\n    int64_t p;\n    int rnd_mode;\n\n    val = js_thisBigDecimalValue(ctx, this_val);\n    if (JS_IsException(val))\n        return val;\n    if (JS_IsUndefined(argv[0])) {\n        return JS_ToStringFree(ctx, val);\n    }\n    if (JS_ToInt64Sat(ctx, &p, argv[0]))\n        goto fail;\n    if (p < 1 || p > BF_PREC_MAX) {\n        JS_ThrowRangeError(ctx, \"invalid number of digits\");\n        goto fail;\n    }\n    rnd_mode = BF_RNDNA;\n    if (argc > 1) {\n        rnd_mode = js_bigdecimal_get_rnd_mode(ctx, argv[1]);\n        if (rnd_mode < 0)\n            goto fail;\n    }\n    ret = js_bigdecimal_to_string1(ctx, val, p,\n                                   rnd_mode | BF_FTOA_FORMAT_FIXED);\n    JS_FreeValue(ctx, val);\n    return ret;\n fail:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic const JSCFunctionListEntry js_bigdecimal_proto_funcs[] = {\n    JS_CFUNC_DEF(\"toString\", 0, js_bigdecimal_toString ),\n    JS_CFUNC_DEF(\"valueOf\", 0, js_bigdecimal_valueOf ),\n    JS_CFUNC_DEF(\"toPrecision\", 1, js_bigdecimal_toPrecision ),\n    JS_CFUNC_DEF(\"toFixed\", 1, js_bigdecimal_toFixed ),\n    JS_CFUNC_DEF(\"toExponential\", 1, js_bigdecimal_toExponential ),\n};\n\nstatic const JSCFunctionListEntry js_bigdecimal_funcs[] = {\n    JS_CFUNC_MAGIC_DEF(\"add\", 2, js_bigdecimal_fop, MATH_OP_ADD ),\n    JS_CFUNC_MAGIC_DEF(\"sub\", 2, js_bigdecimal_fop, MATH_OP_SUB ),\n    JS_CFUNC_MAGIC_DEF(\"mul\", 2, js_bigdecimal_fop, MATH_OP_MUL ),\n    JS_CFUNC_MAGIC_DEF(\"div\", 2, js_bigdecimal_fop, MATH_OP_DIV ),\n    JS_CFUNC_MAGIC_DEF(\"mod\", 2, js_bigdecimal_fop, MATH_OP_FMOD ),\n    JS_CFUNC_MAGIC_DEF(\"round\", 1, js_bigdecimal_fop, MATH_OP_ROUND ),\n    JS_CFUNC_MAGIC_DEF(\"sqrt\", 1, js_bigdecimal_fop, MATH_OP_SQRT ),\n};\n\nvoid JS_AddIntrinsicBigDecimal(JSContext *ctx)\n{\n    JSRuntime *rt = ctx->rt;\n    JSValueConst obj1;\n\n    rt->bigdecimal_ops.to_string = js_bigdecimal_to_string;\n    rt->bigdecimal_ops.from_string = js_string_to_bigdecimal;\n    rt->bigdecimal_ops.unary_arith = js_unary_arith_bigdecimal;\n    rt->bigdecimal_ops.binary_arith = js_binary_arith_bigdecimal;\n    rt->bigdecimal_ops.compare = js_compare_bigdecimal;\n\n    ctx->class_proto[JS_CLASS_BIG_DECIMAL] = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BIG_DECIMAL],\n                               js_bigdecimal_proto_funcs,\n                               countof(js_bigdecimal_proto_funcs));\n    obj1 = JS_NewGlobalCConstructor(ctx, \"BigDecimal\",\n                                    js_bigdecimal_constructor, 1,\n                                    ctx->class_proto[JS_CLASS_BIG_DECIMAL]);\n    JS_SetPropertyFunctionList(ctx, obj1, js_bigdecimal_funcs,\n                               countof(js_bigdecimal_funcs));\n}\n\nvoid JS_EnableBignumExt(JSContext *ctx, BOOL enable)\n{\n    ctx->bignum_ext = enable;\n}\n\n#endif /* CONFIG_BIGNUM */\n\nstatic const char * const native_error_name[JS_NATIVE_ERROR_COUNT] = {\n    \"EvalError\", \"RangeError\", \"ReferenceError\",\n    \"SyntaxError\", \"TypeError\", \"URIError\",\n    \"InternalError\", \"AggregateError\",\n};\n\n/* Minimum amount of objects to be able to compile code and display\n   error messages. No JSAtom should be allocated by this function. */\nstatic void JS_AddIntrinsicBasicObjects(JSContext *ctx)\n{\n    JSValue proto;\n    int i;\n\n    ctx->class_proto[JS_CLASS_OBJECT] = JS_NewObjectProto(ctx, JS_NULL);\n    ctx->function_proto = JS_NewCFunction3(ctx, js_function_proto, \"\", 0,\n                                           JS_CFUNC_generic, 0,\n                                           ctx->class_proto[JS_CLASS_OBJECT]);\n    ctx->class_proto[JS_CLASS_BYTECODE_FUNCTION] = JS_DupValue(ctx, ctx->function_proto);\n    ctx->class_proto[JS_CLASS_ERROR] = JS_NewObject(ctx);\n#if 0\n    /* these are auto-initialized from js_error_proto_funcs,\n       but delaying might be a problem */\n    JS_DefinePropertyValue(ctx, ctx->class_proto[JS_CLASS_ERROR], JS_ATOM_name,\n                           JS_AtomToString(ctx, JS_ATOM_Error),\n                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    JS_DefinePropertyValue(ctx, ctx->class_proto[JS_CLASS_ERROR], JS_ATOM_message,\n                           JS_AtomToString(ctx, JS_ATOM_empty_string),\n                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n#endif\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ERROR],\n                               js_error_proto_funcs,\n                               countof(js_error_proto_funcs));\n\n    for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {\n        proto = JS_NewObjectProto(ctx, ctx->class_proto[JS_CLASS_ERROR]);\n        JS_DefinePropertyValue(ctx, proto, JS_ATOM_name,\n                               JS_NewAtomString(ctx, native_error_name[i]),\n                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n        JS_DefinePropertyValue(ctx, proto, JS_ATOM_message,\n                               JS_AtomToString(ctx, JS_ATOM_empty_string),\n                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n        ctx->native_error_proto[i] = proto;\n    }\n\n    /* the array prototype is an array */\n    ctx->class_proto[JS_CLASS_ARRAY] =\n        JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],\n                               JS_CLASS_ARRAY);\n\n    ctx->array_shape = js_new_shape2(ctx, get_proto_obj(ctx->class_proto[JS_CLASS_ARRAY]),\n                                     JS_PROP_INITIAL_HASH_SIZE, 1);\n    add_shape_property(ctx, &ctx->array_shape, NULL,\n                       JS_ATOM_length, JS_PROP_WRITABLE | JS_PROP_LENGTH);\n\n    /* XXX: could test it on first context creation to ensure that no\n       new atoms are created in JS_AddIntrinsicBasicObjects(). It is\n       necessary to avoid useless renumbering of atoms after\n       JS_EvalBinary() if it is done just after\n       JS_AddIntrinsicBasicObjects(). */\n    //    assert(ctx->rt->atom_count == JS_ATOM_END);\n}\n\nvoid JS_AddIntrinsicBaseObjects(JSContext *ctx)\n{\n    int i;\n    JSValueConst obj, number_obj;\n    JSValue obj1;\n\n    ctx->throw_type_error = JS_NewCFunction(ctx, js_throw_type_error, NULL, 0);\n\n    /* add caller and arguments properties to throw a TypeError */\n    obj1 = JS_NewCFunction(ctx, js_function_proto_caller, NULL, 0);\n    JS_DefineProperty(ctx, ctx->function_proto, JS_ATOM_caller, JS_UNDEFINED,\n                      obj1, ctx->throw_type_error,\n                      JS_PROP_HAS_GET | JS_PROP_HAS_SET |\n                      JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE);\n    JS_DefineProperty(ctx, ctx->function_proto, JS_ATOM_arguments, JS_UNDEFINED,\n                      obj1, ctx->throw_type_error,\n                      JS_PROP_HAS_GET | JS_PROP_HAS_SET |\n                      JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE);\n    JS_FreeValue(ctx, obj1);\n    JS_FreeValue(ctx, js_object_seal(ctx, JS_UNDEFINED, 1, (JSValueConst *)&ctx->throw_type_error, 1));\n\n    ctx->global_obj = JS_NewObject(ctx);\n    ctx->global_var_obj = JS_NewObjectProto(ctx, JS_NULL);\n\n    /* Object */\n    obj = JS_NewGlobalCConstructor(ctx, \"Object\", js_object_constructor, 1,\n                                   ctx->class_proto[JS_CLASS_OBJECT]);\n    JS_SetPropertyFunctionList(ctx, obj, js_object_funcs, countof(js_object_funcs));\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_OBJECT],\n                               js_object_proto_funcs, countof(js_object_proto_funcs));\n\n    /* Function */\n    JS_SetPropertyFunctionList(ctx, ctx->function_proto, js_function_proto_funcs, countof(js_function_proto_funcs));\n    ctx->function_ctor = JS_NewCFunctionMagic(ctx, js_function_constructor,\n                                              \"Function\", 1, JS_CFUNC_constructor_or_func_magic,\n                                              JS_FUNC_NORMAL);\n    JS_NewGlobalCConstructor2(ctx, JS_DupValue(ctx, ctx->function_ctor), \"Function\",\n                              ctx->function_proto);\n\n    /* Error */\n    obj1 = JS_NewCFunctionMagic(ctx, js_error_constructor,\n                                \"Error\", 1, JS_CFUNC_constructor_or_func_magic, -1);\n    JS_NewGlobalCConstructor2(ctx, obj1,\n                              \"Error\", ctx->class_proto[JS_CLASS_ERROR]);\n\n    for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {\n        JSValue func_obj;\n        int n_args;\n        n_args = 1 + (i == JS_AGGREGATE_ERROR);\n        func_obj = JS_NewCFunction3(ctx, (JSCFunction *)js_error_constructor,\n                                    native_error_name[i], n_args,\n                                    JS_CFUNC_constructor_or_func_magic, i, obj1);\n        JS_NewGlobalCConstructor2(ctx, func_obj, native_error_name[i],\n                                  ctx->native_error_proto[i]);\n    }\n\n    /* Iterator prototype */\n    ctx->iterator_proto = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, ctx->iterator_proto,\n                               js_iterator_proto_funcs,\n                               countof(js_iterator_proto_funcs));\n\n    /* Array */\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ARRAY],\n                               js_array_proto_funcs,\n                               countof(js_array_proto_funcs));\n\n    obj = JS_NewGlobalCConstructor(ctx, \"Array\", js_array_constructor, 1,\n                                   ctx->class_proto[JS_CLASS_ARRAY]);\n    ctx->array_ctor = JS_DupValue(ctx, obj);\n    JS_SetPropertyFunctionList(ctx, obj, js_array_funcs,\n                               countof(js_array_funcs));\n\n    /* XXX: create auto_initializer */\n    {\n        /* initialize Array.prototype[Symbol.unscopables] */\n        char const unscopables[] = \"copyWithin\" \"\\0\" \"entries\" \"\\0\" \"fill\" \"\\0\" \"find\" \"\\0\"\n            \"findIndex\" \"\\0\" \"flat\" \"\\0\" \"flatMap\" \"\\0\" \"includes\" \"\\0\" \"keys\" \"\\0\" \"values\" \"\\0\";\n        const char *p = unscopables;\n        obj1 = JS_NewObjectProto(ctx, JS_NULL);\n        for(p = unscopables; *p; p += strlen(p) + 1) {\n            JS_DefinePropertyValueStr(ctx, obj1, p, JS_TRUE, JS_PROP_C_W_E);\n        }\n        JS_DefinePropertyValue(ctx, ctx->class_proto[JS_CLASS_ARRAY],\n                               JS_ATOM_Symbol_unscopables, obj1,\n                               JS_PROP_CONFIGURABLE);\n    }\n\n    /* needed to initialize arguments[Symbol.iterator] */\n    ctx->array_proto_values =\n        JS_GetProperty(ctx, ctx->class_proto[JS_CLASS_ARRAY], JS_ATOM_values);\n\n    ctx->class_proto[JS_CLASS_ARRAY_ITERATOR] = JS_NewObjectProto(ctx, ctx->iterator_proto);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ARRAY_ITERATOR],\n                               js_array_iterator_proto_funcs,\n                               countof(js_array_iterator_proto_funcs));\n\n    /* parseFloat and parseInteger must be defined before Number\n       because of the Number.parseFloat and Number.parseInteger\n       aliases */\n    JS_SetPropertyFunctionList(ctx, ctx->global_obj, js_global_funcs,\n                               countof(js_global_funcs));\n\n    /* Number */\n    ctx->class_proto[JS_CLASS_NUMBER] = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],\n                                                               JS_CLASS_NUMBER);\n    JS_SetObjectData(ctx, ctx->class_proto[JS_CLASS_NUMBER], JS_NewInt32(ctx, 0));\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_NUMBER],\n                               js_number_proto_funcs,\n                               countof(js_number_proto_funcs));\n    number_obj = JS_NewGlobalCConstructor(ctx, \"Number\", js_number_constructor, 1,\n                                          ctx->class_proto[JS_CLASS_NUMBER]);\n    JS_SetPropertyFunctionList(ctx, number_obj, js_number_funcs, countof(js_number_funcs));\n\n    /* Boolean */\n    ctx->class_proto[JS_CLASS_BOOLEAN] = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],\n                                                                JS_CLASS_BOOLEAN);\n    JS_SetObjectData(ctx, ctx->class_proto[JS_CLASS_BOOLEAN], JS_NewBool(ctx, FALSE));\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BOOLEAN], js_boolean_proto_funcs,\n                               countof(js_boolean_proto_funcs));\n    JS_NewGlobalCConstructor(ctx, \"Boolean\", js_boolean_constructor, 1,\n                             ctx->class_proto[JS_CLASS_BOOLEAN]);\n\n    /* String */\n    ctx->class_proto[JS_CLASS_STRING] = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],\n                                                               JS_CLASS_STRING);\n    JS_SetObjectData(ctx, ctx->class_proto[JS_CLASS_STRING], JS_AtomToString(ctx, JS_ATOM_empty_string));\n    obj = JS_NewGlobalCConstructor(ctx, \"String\", js_string_constructor, 1,\n                                   ctx->class_proto[JS_CLASS_STRING]);\n    JS_SetPropertyFunctionList(ctx, obj, js_string_funcs,\n                               countof(js_string_funcs));\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_STRING], js_string_proto_funcs,\n                               countof(js_string_proto_funcs));\n\n    ctx->class_proto[JS_CLASS_STRING_ITERATOR] = JS_NewObjectProto(ctx, ctx->iterator_proto);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_STRING_ITERATOR],\n                               js_string_iterator_proto_funcs,\n                               countof(js_string_iterator_proto_funcs));\n\n    /* Math: create as autoinit object */\n    js_random_init(ctx);\n    JS_SetPropertyFunctionList(ctx, ctx->global_obj, js_math_obj, countof(js_math_obj));\n\n    /* ES6 Reflect: create as autoinit object */\n    JS_SetPropertyFunctionList(ctx, ctx->global_obj, js_reflect_obj, countof(js_reflect_obj));\n\n    /* ES6 Symbol */\n    ctx->class_proto[JS_CLASS_SYMBOL] = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_SYMBOL], js_symbol_proto_funcs,\n                               countof(js_symbol_proto_funcs));\n    obj = JS_NewGlobalCConstructor(ctx, \"Symbol\", js_symbol_constructor, 0,\n                                   ctx->class_proto[JS_CLASS_SYMBOL]);\n    JS_SetPropertyFunctionList(ctx, obj, js_symbol_funcs,\n                               countof(js_symbol_funcs));\n    for(i = JS_ATOM_Symbol_toPrimitive; i < JS_ATOM_END; i++) {\n        char buf[ATOM_GET_STR_BUF_SIZE];\n        const char *str, *p;\n        str = JS_AtomGetStr(ctx, buf, sizeof(buf), i);\n        /* skip \"Symbol.\" */\n        p = strchr(str, '.');\n        if (p)\n            str = p + 1;\n        JS_DefinePropertyValueStr(ctx, obj, str, JS_AtomToValue(ctx, i), 0);\n    }\n\n    /* ES6 Generator */\n    ctx->class_proto[JS_CLASS_GENERATOR] = JS_NewObjectProto(ctx, ctx->iterator_proto);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_GENERATOR],\n                               js_generator_proto_funcs,\n                               countof(js_generator_proto_funcs));\n\n    ctx->class_proto[JS_CLASS_GENERATOR_FUNCTION] = JS_NewObjectProto(ctx, ctx->function_proto);\n    obj1 = JS_NewCFunctionMagic(ctx, js_function_constructor,\n                                \"GeneratorFunction\", 1,\n                                JS_CFUNC_constructor_or_func_magic, JS_FUNC_GENERATOR);\n    JS_SetPropertyFunctionList(ctx,\n                               ctx->class_proto[JS_CLASS_GENERATOR_FUNCTION],\n                               js_generator_function_proto_funcs,\n                               countof(js_generator_function_proto_funcs));\n    JS_SetConstructor2(ctx, ctx->class_proto[JS_CLASS_GENERATOR_FUNCTION],\n                       ctx->class_proto[JS_CLASS_GENERATOR],\n                       JS_PROP_CONFIGURABLE, JS_PROP_CONFIGURABLE);\n    JS_SetConstructor2(ctx, obj1, ctx->class_proto[JS_CLASS_GENERATOR_FUNCTION],\n                       0, JS_PROP_CONFIGURABLE);\n    JS_FreeValue(ctx, obj1);\n\n    /* global properties */\n    ctx->eval_obj = JS_NewCFunction(ctx, js_global_eval, \"eval\", 1);\n    JS_DefinePropertyValue(ctx, ctx->global_obj, JS_ATOM_eval,\n                           JS_DupValue(ctx, ctx->eval_obj),\n                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n\n    JS_DefinePropertyValue(ctx, ctx->global_obj, JS_ATOM_globalThis,\n                           JS_DupValue(ctx, ctx->global_obj),\n                           JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);\n}\n\n/* Typed Arrays */\n\nstatic uint8_t const typed_array_size_log2[JS_TYPED_ARRAY_COUNT] = {\n    0, 0, 0, 1, 1, 2, 2,\n#ifdef CONFIG_BIGNUM\n    3, 3, /* BigInt64Array, BigUint64Array */\n#endif\n    2, 3\n};\n\nstatic JSValue js_array_buffer_constructor3(JSContext *ctx,\n                                            JSValueConst new_target,\n                                            uint64_t len, JSClassID class_id,\n                                            uint8_t *buf,\n                                            JSFreeArrayBufferDataFunc *free_func,\n                                            void *opaque, BOOL alloc_flag)\n{\n    JSRuntime *rt = ctx->rt;\n    JSValue obj;\n    JSArrayBuffer *abuf = NULL;\n\n    obj = js_create_from_ctor(ctx, new_target, class_id);\n    if (JS_IsException(obj))\n        return obj;\n    /* XXX: we are currently limited to 2 GB */\n    if (len > INT32_MAX) {\n        JS_ThrowRangeError(ctx, \"invalid array buffer length\");\n        goto fail;\n    }\n    abuf = js_malloc(ctx, sizeof(*abuf));\n    if (!abuf)\n        goto fail;\n    abuf->byte_length = len;\n    if (alloc_flag) {\n        if (class_id == JS_CLASS_SHARED_ARRAY_BUFFER &&\n            rt->sab_funcs.sab_alloc) {\n            abuf->data = rt->sab_funcs.sab_alloc(rt->sab_funcs.sab_opaque,\n                                                 max_int(len, 1));\n            if (!abuf->data)\n                goto fail;\n            memset(abuf->data, 0, len);\n        } else {\n            /* the allocation must be done after the object creation */\n            abuf->data = js_mallocz(ctx, max_int(len, 1));\n            if (!abuf->data)\n                goto fail;\n        }\n    } else {\n        if (class_id == JS_CLASS_SHARED_ARRAY_BUFFER &&\n            rt->sab_funcs.sab_dup) {\n            rt->sab_funcs.sab_dup(rt->sab_funcs.sab_opaque, buf);\n        }\n        abuf->data = buf;\n    }\n    init_list_head(&abuf->array_list);\n    abuf->detached = FALSE;\n    abuf->shared = (class_id == JS_CLASS_SHARED_ARRAY_BUFFER);\n    abuf->opaque = opaque;\n    abuf->free_func = free_func;\n    if (alloc_flag && buf)\n        memcpy(abuf->data, buf, len);\n    JS_SetOpaque(obj, abuf);\n    return obj;\n fail:\n    JS_FreeValue(ctx, obj);\n    js_free(ctx, abuf);\n    return JS_EXCEPTION;\n}\n\nstatic void js_array_buffer_free(JSRuntime *rt, void *opaque, void *ptr)\n{\n    js_free_rt(rt, ptr);\n}\n\nstatic JSValue js_array_buffer_constructor2(JSContext *ctx,\n                                            JSValueConst new_target,\n                                            uint64_t len, JSClassID class_id)\n{\n    return js_array_buffer_constructor3(ctx, new_target, len, class_id,\n                                        NULL, js_array_buffer_free, NULL,\n                                        TRUE);\n}\n\nstatic JSValue js_array_buffer_constructor1(JSContext *ctx,\n                                            JSValueConst new_target,\n                                            uint64_t len)\n{\n    return js_array_buffer_constructor2(ctx, new_target, len,\n                                        JS_CLASS_ARRAY_BUFFER);\n}\n\nJSValue JS_NewArrayBuffer(JSContext *ctx, uint8_t *buf, size_t len,\n                          JSFreeArrayBufferDataFunc *free_func, void *opaque,\n                          BOOL is_shared)\n{\n    return js_array_buffer_constructor3(ctx, JS_UNDEFINED, len,\n                                        is_shared ? JS_CLASS_SHARED_ARRAY_BUFFER : JS_CLASS_ARRAY_BUFFER,\n                                        buf, free_func, opaque, FALSE);\n}\n\n/* create a new ArrayBuffer of length 'len' and copy 'buf' to it */\nJSValue JS_NewArrayBufferCopy(JSContext *ctx, const uint8_t *buf, size_t len)\n{\n    return js_array_buffer_constructor3(ctx, JS_UNDEFINED, len,\n                                        JS_CLASS_ARRAY_BUFFER,\n                                        (uint8_t *)buf,\n                                        js_array_buffer_free, NULL,\n                                        TRUE);\n}\n\nstatic JSValue js_array_buffer_constructor(JSContext *ctx,\n                                           JSValueConst new_target,\n                                           int argc, JSValueConst *argv)\n{\n    uint64_t len;\n    if (JS_ToIndex(ctx, &len, argv[0]))\n        return JS_EXCEPTION;\n    return js_array_buffer_constructor1(ctx, new_target, len);\n}\n\nstatic JSValue js_shared_array_buffer_constructor(JSContext *ctx,\n                                                  JSValueConst new_target,\n                                                  int argc, JSValueConst *argv)\n{\n    uint64_t len;\n    if (JS_ToIndex(ctx, &len, argv[0]))\n        return JS_EXCEPTION;\n    return js_array_buffer_constructor2(ctx, new_target, len,\n                                        JS_CLASS_SHARED_ARRAY_BUFFER);\n}\n\n/* also used for SharedArrayBuffer */\nstatic void js_array_buffer_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSArrayBuffer *abuf = p->u.array_buffer;\n    if (abuf) {\n        /* The ArrayBuffer finalizer may be called before the typed\n           array finalizers using it, so abuf->array_list is not\n           necessarily empty. */\n        // assert(list_empty(&abuf->array_list));\n        if (abuf->shared && rt->sab_funcs.sab_free) {\n            rt->sab_funcs.sab_free(rt->sab_funcs.sab_opaque, abuf->data);\n        } else {\n            if (abuf->free_func)\n                abuf->free_func(rt, abuf->opaque, abuf->data);\n        }\n        js_free_rt(rt, abuf);\n    }\n}\n\nstatic JSValue js_array_buffer_isView(JSContext *ctx,\n                                      JSValueConst this_val,\n                                      int argc, JSValueConst *argv)\n{\n    JSObject *p;\n    BOOL res;\n    res = FALSE;\n    if (JS_VALUE_GET_TAG(argv[0]) == JS_TAG_OBJECT) {\n        p = JS_VALUE_GET_OBJ(argv[0]);\n        if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n            p->class_id <= JS_CLASS_DATAVIEW) {\n            res = TRUE;\n        }\n    }\n    return JS_NewBool(ctx, res);\n}\n\nstatic const JSCFunctionListEntry js_array_buffer_funcs[] = {\n    JS_CFUNC_DEF(\"isView\", 1, js_array_buffer_isView ),\n    JS_CGETSET_DEF(\"[Symbol.species]\", js_get_this, NULL ),\n};\n\nstatic JSValue JS_ThrowTypeErrorDetachedArrayBuffer(JSContext *ctx)\n{\n    return JS_ThrowTypeError(ctx, \"ArrayBuffer is detached\");\n}\n\nstatic JSValue js_array_buffer_get_byteLength(JSContext *ctx,\n                                              JSValueConst this_val,\n                                              int class_id)\n{\n    JSArrayBuffer *abuf = JS_GetOpaque2(ctx, this_val, class_id);\n    if (!abuf)\n        return JS_EXCEPTION;\n    /* return 0 if detached */\n    return JS_NewUint32(ctx, abuf->byte_length);\n}\n\nvoid JS_DetachArrayBuffer(JSContext *ctx, JSValueConst obj)\n{\n    JSArrayBuffer *abuf = JS_GetOpaque(obj, JS_CLASS_ARRAY_BUFFER);\n    struct list_head *el;\n\n    if (!abuf || abuf->detached)\n        return;\n    if (abuf->free_func)\n        abuf->free_func(ctx->rt, abuf->opaque, abuf->data);\n    abuf->data = NULL;\n    abuf->byte_length = 0;\n    abuf->detached = TRUE;\n\n    list_for_each(el, &abuf->array_list) {\n        JSTypedArray *ta;\n        JSObject *p;\n\n        ta = list_entry(el, JSTypedArray, link);\n        p = ta->obj;\n        /* Note: the typed array length and offset fields are not modified */\n        if (p->class_id != JS_CLASS_DATAVIEW) {\n            p->u.array.count = 0;\n            p->u.array.u.ptr = NULL;\n        }\n    }\n}\n\n/* get an ArrayBuffer or SharedArrayBuffer */\nstatic JSArrayBuffer *js_get_array_buffer(JSContext *ctx, JSValueConst obj)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        goto fail;\n    p = JS_VALUE_GET_OBJ(obj);\n    if (p->class_id != JS_CLASS_ARRAY_BUFFER &&\n        p->class_id != JS_CLASS_SHARED_ARRAY_BUFFER) {\n    fail:\n        JS_ThrowTypeErrorInvalidClass(ctx, JS_CLASS_ARRAY_BUFFER);\n        return NULL;\n    }\n    return p->u.array_buffer;\n}\n\n/* return NULL if exception. WARNING: any JS call can detach the\n   buffer and render the returned pointer invalid */\nuint8_t *JS_GetArrayBuffer(JSContext *ctx, size_t *psize, JSValueConst obj)\n{\n    JSArrayBuffer *abuf = js_get_array_buffer(ctx, obj);\n    if (!abuf)\n        goto fail;\n    if (abuf->detached) {\n        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n        goto fail;\n    }\n    *psize = abuf->byte_length;\n    return abuf->data;\n fail:\n    *psize = 0;\n    return NULL;\n}\n\nstatic JSValue js_array_buffer_slice(JSContext *ctx,\n                                     JSValueConst this_val,\n                                     int argc, JSValueConst *argv, int class_id)\n{\n    JSArrayBuffer *abuf, *new_abuf;\n    int64_t len, start, end, new_len;\n    JSValue ctor, new_obj;\n\n    abuf = JS_GetOpaque2(ctx, this_val, class_id);\n    if (!abuf)\n        return JS_EXCEPTION;\n    if (abuf->detached)\n        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n    len = abuf->byte_length;\n\n    if (JS_ToInt64Clamp(ctx, &start, argv[0], 0, len, len))\n        return JS_EXCEPTION;\n\n    end = len;\n    if (!JS_IsUndefined(argv[1])) {\n        if (JS_ToInt64Clamp(ctx, &end, argv[1], 0, len, len))\n            return JS_EXCEPTION;\n    }\n    new_len = max_int64(end - start, 0);\n    ctor = JS_SpeciesConstructor(ctx, this_val, JS_UNDEFINED);\n    if (JS_IsException(ctor))\n        return ctor;\n    if (JS_IsUndefined(ctor)) {\n        new_obj = js_array_buffer_constructor2(ctx, JS_UNDEFINED, new_len,\n                                               class_id);\n    } else {\n        JSValue args[1];\n        args[0] = JS_NewInt64(ctx, new_len);\n        new_obj = JS_CallConstructor(ctx, ctor, 1, (JSValueConst *)args);\n        JS_FreeValue(ctx, ctor);\n        JS_FreeValue(ctx, args[0]);\n    }\n    if (JS_IsException(new_obj))\n        return new_obj;\n    new_abuf = JS_GetOpaque2(ctx, new_obj, class_id);\n    if (!new_abuf)\n        goto fail;\n    if (js_same_value(ctx, new_obj, this_val)) {\n        JS_ThrowTypeError(ctx, \"cannot use identical ArrayBuffer\");\n        goto fail;\n    }\n    if (new_abuf->detached) {\n        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n        goto fail;\n    }\n    if (new_abuf->byte_length < new_len) {\n        JS_ThrowTypeError(ctx, \"new ArrayBuffer is too small\");\n        goto fail;\n    }\n    /* must test again because of side effects */\n    if (abuf->detached) {\n        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n        goto fail;\n    }\n    memcpy(new_abuf->data, abuf->data + start, new_len);\n    return new_obj;\n fail:\n    JS_FreeValue(ctx, new_obj);\n    return JS_EXCEPTION;\n}\n\nstatic const JSCFunctionListEntry js_array_buffer_proto_funcs[] = {\n    JS_CGETSET_MAGIC_DEF(\"byteLength\", js_array_buffer_get_byteLength, NULL, JS_CLASS_ARRAY_BUFFER ),\n    JS_CFUNC_MAGIC_DEF(\"slice\", 2, js_array_buffer_slice, JS_CLASS_ARRAY_BUFFER ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"ArrayBuffer\", JS_PROP_CONFIGURABLE ),\n};\n\n/* SharedArrayBuffer */\n\nstatic const JSCFunctionListEntry js_shared_array_buffer_funcs[] = {\n    JS_CGETSET_DEF(\"[Symbol.species]\", js_get_this, NULL ),\n};\n\nstatic const JSCFunctionListEntry js_shared_array_buffer_proto_funcs[] = {\n    JS_CGETSET_MAGIC_DEF(\"byteLength\", js_array_buffer_get_byteLength, NULL, JS_CLASS_SHARED_ARRAY_BUFFER ),\n    JS_CFUNC_MAGIC_DEF(\"slice\", 2, js_array_buffer_slice, JS_CLASS_SHARED_ARRAY_BUFFER ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"SharedArrayBuffer\", JS_PROP_CONFIGURABLE ),\n};\n\nstatic JSObject *get_typed_array(JSContext *ctx,\n                                 JSValueConst this_val,\n                                 int is_dataview)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(this_val) != JS_TAG_OBJECT)\n        goto fail;\n    p = JS_VALUE_GET_OBJ(this_val);\n    if (is_dataview) {\n        if (p->class_id != JS_CLASS_DATAVIEW)\n            goto fail;\n    } else {\n        if (!(p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n              p->class_id <= JS_CLASS_FLOAT64_ARRAY)) {\n        fail:\n            JS_ThrowTypeError(ctx, \"not a %s\", is_dataview ? \"DataView\" : \"TypedArray\");\n            return NULL;\n        }\n    }\n    return p;\n}\n\n/* WARNING: 'p' must be a typed array */\nstatic BOOL typed_array_is_detached(JSContext *ctx, JSObject *p)\n{\n    JSTypedArray *ta = p->u.typed_array;\n    JSArrayBuffer *abuf = ta->buffer->u.array_buffer;\n    /* XXX: could simplify test by ensuring that\n       p->u.array.u.ptr is NULL iff it is detached */\n    return abuf->detached;\n}\n\n/* WARNING: 'p' must be a typed array. Works even if the array buffer\n   is detached */\nstatic uint32_t typed_array_get_length(JSContext *ctx, JSObject *p)\n{\n    JSTypedArray *ta = p->u.typed_array;\n    int size_log2 = typed_array_size_log2(p->class_id);\n    return ta->length >> size_log2;\n}\n\nstatic int validate_typed_array(JSContext *ctx, JSValueConst this_val)\n{\n    JSObject *p;\n    p = get_typed_array(ctx, this_val, 0);\n    if (!p)\n        return -1;\n    if (typed_array_is_detached(ctx, p)) {\n        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n        return -1;\n    }\n    return 0;\n}\n\nstatic JSValue js_typed_array_get_length(JSContext *ctx,\n                                         JSValueConst this_val)\n{\n    JSObject *p;\n    p = get_typed_array(ctx, this_val, 0);\n    if (!p)\n        return JS_EXCEPTION;\n    return JS_NewInt32(ctx, p->u.array.count);\n}\n\nstatic JSValue js_typed_array_get_buffer(JSContext *ctx,\n                                         JSValueConst this_val, int is_dataview)\n{\n    JSObject *p;\n    JSTypedArray *ta;\n    p = get_typed_array(ctx, this_val, is_dataview);\n    if (!p)\n        return JS_EXCEPTION;\n    ta = p->u.typed_array;\n    return JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, ta->buffer));\n}\n\nstatic JSValue js_typed_array_get_byteLength(JSContext *ctx,\n                                             JSValueConst this_val,\n                                             int is_dataview)\n{\n    JSObject *p;\n    JSTypedArray *ta;\n    p = get_typed_array(ctx, this_val, is_dataview);\n    if (!p)\n        return JS_EXCEPTION;\n    if (typed_array_is_detached(ctx, p)) {\n        if (is_dataview) {\n            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n        } else {\n            return JS_NewInt32(ctx, 0);\n        }\n    }\n    ta = p->u.typed_array;\n    return JS_NewInt32(ctx, ta->length);\n}\n\nstatic JSValue js_typed_array_get_byteOffset(JSContext *ctx,\n                                             JSValueConst this_val,\n                                             int is_dataview)\n{\n    JSObject *p;\n    JSTypedArray *ta;\n    p = get_typed_array(ctx, this_val, is_dataview);\n    if (!p)\n        return JS_EXCEPTION;\n    if (typed_array_is_detached(ctx, p)) {\n        if (is_dataview) {\n            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n        } else {\n            return JS_NewInt32(ctx, 0);\n        }\n    }\n    ta = p->u.typed_array;\n    return JS_NewInt32(ctx, ta->offset);\n}\n\n/* Return the buffer associated to the typed array or an exception if\n   it is not a typed array or if the buffer is detached. pbyte_offset,\n   pbyte_length or pbytes_per_element can be NULL. */\nJSValue JS_GetTypedArrayBuffer(JSContext *ctx, JSValueConst obj,\n                               size_t *pbyte_offset,\n                               size_t *pbyte_length,\n                               size_t *pbytes_per_element)\n{\n    JSObject *p;\n    JSTypedArray *ta;\n    p = get_typed_array(ctx, obj, FALSE);\n    if (!p)\n        return JS_EXCEPTION;\n    if (typed_array_is_detached(ctx, p))\n        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n    ta = p->u.typed_array;\n    if (pbyte_offset)\n        *pbyte_offset = ta->offset;\n    if (pbyte_length)\n        *pbyte_length = ta->length;\n    if (pbytes_per_element) {\n        *pbytes_per_element = 1 << typed_array_size_log2(p->class_id);\n    }\n    return JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, ta->buffer));\n}\n                               \nstatic JSValue js_typed_array_get_toStringTag(JSContext *ctx,\n                                              JSValueConst this_val)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(this_val) != JS_TAG_OBJECT)\n        return JS_UNDEFINED;\n    p = JS_VALUE_GET_OBJ(this_val);\n    if (!(p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n          p->class_id <= JS_CLASS_FLOAT64_ARRAY))\n        return JS_UNDEFINED;\n    return JS_AtomToString(ctx, ctx->rt->class_array[p->class_id].class_name);\n}\n\nstatic JSValue js_typed_array_set_internal(JSContext *ctx,\n                                           JSValueConst dst,\n                                           JSValueConst src,\n                                           JSValueConst off)\n{\n    JSObject *p;\n    JSObject *src_p;\n    uint32_t i;\n    int64_t src_len, offset;\n    JSValue val, src_obj = JS_UNDEFINED;\n\n    p = get_typed_array(ctx, dst, 0);\n    if (!p)\n        goto fail;\n    if (JS_ToInt64Sat(ctx, &offset, off))\n        goto fail;\n    if (offset < 0)\n        goto range_error;\n    if (typed_array_is_detached(ctx, p)) {\n    detached:\n        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n        goto fail;\n    }\n    src_obj = JS_ToObject(ctx, src);\n    if (JS_IsException(src_obj))\n        goto fail;\n    src_p = JS_VALUE_GET_OBJ(src_obj);\n    if (src_p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n        src_p->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n        JSTypedArray *dest_ta = p->u.typed_array;\n        JSArrayBuffer *dest_abuf = dest_ta->buffer->u.array_buffer;\n        JSTypedArray *src_ta = src_p->u.typed_array;\n        JSArrayBuffer *src_abuf = src_ta->buffer->u.array_buffer;\n        int shift = typed_array_size_log2(p->class_id);\n\n        if (src_abuf->detached)\n            goto detached;\n\n        src_len = src_p->u.array.count;\n        if (offset > (int64_t)(p->u.array.count - src_len))\n            goto range_error;\n\n        /* copying between typed objects */\n        if (src_p->class_id == p->class_id) {\n            /* same type, use memmove */\n            memmove(dest_abuf->data + dest_ta->offset + (offset << shift),\n                    src_abuf->data + src_ta->offset, src_len << shift);\n            goto done;\n        }\n        if (dest_abuf->data == src_abuf->data) {\n            /* copying between the same buffer using different types of mappings\n               would require a temporary buffer */\n        }\n        /* otherwise, default behavior is slow but correct */\n    } else {\n        if (js_get_length64(ctx, &src_len, src_obj))\n            goto fail;\n        if (offset > (int64_t)(p->u.array.count - src_len)) {\n        range_error:\n            JS_ThrowRangeError(ctx, \"invalid array length\");\n            goto fail;\n        }\n    }\n    for(i = 0; i < src_len; i++) {\n        val = JS_GetPropertyUint32(ctx, src_obj, i);\n        if (JS_IsException(val))\n            goto fail;\n        if (JS_SetPropertyUint32(ctx, dst, offset + i, val) < 0)\n            goto fail;\n    }\ndone:\n    JS_FreeValue(ctx, src_obj);\n    return JS_UNDEFINED;\nfail:\n    JS_FreeValue(ctx, src_obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_typed_array_set(JSContext *ctx,\n                                  JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    JSValueConst offset = JS_UNDEFINED;\n    if (argc > 1) {\n        offset = argv[1];\n    }\n    return js_typed_array_set_internal(ctx, this_val, argv[0], offset);\n}\n\nstatic JSValue js_create_typed_array_iterator(JSContext *ctx, JSValueConst this_val,\n                                              int argc, JSValueConst *argv, int magic)\n{\n    if (validate_typed_array(ctx, this_val))\n        return JS_EXCEPTION;\n    return js_create_array_iterator(ctx, this_val, argc, argv, magic);\n}\n\n/* return < 0 if exception */\nstatic int js_typed_array_get_length_internal(JSContext *ctx,\n                                              JSValueConst obj)\n{\n    JSObject *p;\n    p = get_typed_array(ctx, obj, 0);\n    if (!p)\n        return -1;\n    if (typed_array_is_detached(ctx, p)) {\n        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n        return -1;\n    }\n    return p->u.array.count;\n}\n\n#if 0\n/* validate a typed array and return its length */\nstatic JSValue js_typed_array___getLength(JSContext *ctx,\n                                          JSValueConst this_val,\n                                          int argc, JSValueConst *argv)\n{\n    BOOL ignore_detached = JS_ToBool(ctx, argv[1]);\n\n    if (ignore_detached) {\n        return js_typed_array_get_length(ctx, argv[0]);\n    } else {\n        int len;\n        len = js_typed_array_get_length_internal(ctx, argv[0]);\n        if (len < 0)\n            return JS_EXCEPTION;\n        return JS_NewInt32(ctx, len);\n    }\n}\n#endif\n\nstatic JSValue js_typed_array_create(JSContext *ctx, JSValueConst ctor,\n                                     int argc, JSValueConst *argv)\n{\n    JSValue ret;\n    int new_len;\n    int64_t len;\n\n    ret = JS_CallConstructor(ctx, ctor, argc, argv);\n    if (JS_IsException(ret))\n        return ret;\n    /* validate the typed array */\n    new_len = js_typed_array_get_length_internal(ctx, ret);\n    if (new_len < 0)\n        goto fail;\n    if (argc == 1) {\n        /* ensure that it is large enough */\n        if (JS_ToLengthFree(ctx, &len, JS_DupValue(ctx, argv[0])))\n            goto fail;\n        if (new_len < len) {\n            JS_ThrowTypeError(ctx, \"TypedArray length is too small\");\n        fail:\n            JS_FreeValue(ctx, ret);\n            return JS_EXCEPTION;\n        }\n    }\n    return ret;\n}\n\n#if 0\nstatic JSValue js_typed_array___create(JSContext *ctx,\n                                       JSValueConst this_val,\n                                       int argc, JSValueConst *argv)\n{\n    return js_typed_array_create(ctx, argv[0], max_int(argc - 1, 0), argv + 1);\n}\n#endif\n\nstatic JSValue js_typed_array___speciesCreate(JSContext *ctx,\n                                              JSValueConst this_val,\n                                              int argc, JSValueConst *argv)\n{\n    JSValueConst obj;\n    JSObject *p;\n    JSValue ctor, ret;\n    int argc1;\n\n    obj = argv[0];\n    p = get_typed_array(ctx, obj, 0);\n    if (!p)\n        return JS_EXCEPTION;\n    ctor = JS_SpeciesConstructor(ctx, obj, JS_UNDEFINED);\n    if (JS_IsException(ctor))\n        return ctor;\n    argc1 = max_int(argc - 1, 0);\n    if (JS_IsUndefined(ctor)) {\n        ret = js_typed_array_constructor(ctx, JS_UNDEFINED, argc1, argv + 1,\n                                         p->class_id);\n    } else {\n        ret = js_typed_array_create(ctx, ctor, argc1, argv + 1);\n        JS_FreeValue(ctx, ctor);\n    }\n    return ret;\n}\n\nstatic JSValue js_typed_array_from(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    // from(items, mapfn = void 0, this_arg = void 0)\n    JSValueConst items = argv[0], mapfn, this_arg;\n    JSValueConst args[2];\n    JSValue stack[2];\n    JSValue iter, arr, r, v, v2;\n    int64_t k, len;\n    int done, mapping;\n\n    mapping = FALSE;\n    mapfn = JS_UNDEFINED;\n    this_arg = JS_UNDEFINED;\n    r = JS_UNDEFINED;\n    arr = JS_UNDEFINED;\n    stack[0] = JS_UNDEFINED;\n    stack[1] = JS_UNDEFINED;\n\n    if (argc > 1) {\n        mapfn = argv[1];\n        if (!JS_IsUndefined(mapfn)) {\n            if (check_function(ctx, mapfn))\n                goto exception;\n            mapping = 1;\n            if (argc > 2)\n                this_arg = argv[2];\n        }\n    }\n    iter = JS_GetProperty(ctx, items, JS_ATOM_Symbol_iterator);\n    if (JS_IsException(iter))\n        goto exception;\n    if (!JS_IsUndefined(iter)) {\n        JS_FreeValue(ctx, iter);\n        arr = JS_NewArray(ctx);\n        if (JS_IsException(arr))\n            goto exception;\n        stack[0] = JS_DupValue(ctx, items);\n        if (js_for_of_start(ctx, &stack[1], FALSE))\n            goto exception;\n        for (k = 0;; k++) {\n            v = JS_IteratorNext(ctx, stack[0], stack[1], 0, NULL, &done);\n            if (JS_IsException(v))\n                goto exception_close;\n            if (done)\n                break;\n            if (JS_DefinePropertyValueInt64(ctx, arr, k, v, JS_PROP_C_W_E | JS_PROP_THROW) < 0)\n                goto exception_close;\n        }\n    } else {\n        arr = JS_ToObject(ctx, items);\n        if (JS_IsException(arr))\n            goto exception;\n    }\n    if (js_get_length64(ctx, &len, arr) < 0)\n        goto exception;\n    v = JS_NewInt64(ctx, len);\n    args[0] = v;\n    r = js_typed_array_create(ctx, this_val, 1, args);\n    JS_FreeValue(ctx, v);\n    if (JS_IsException(r))\n        goto exception;\n    for(k = 0; k < len; k++) {\n        v = JS_GetPropertyInt64(ctx, arr, k);\n        if (JS_IsException(v))\n            goto exception;\n        if (mapping) {\n            args[0] = v;\n            args[1] = JS_NewInt32(ctx, k);\n            v2 = JS_Call(ctx, mapfn, this_arg, 2, args);\n            JS_FreeValue(ctx, v);\n            v = v2;\n            if (JS_IsException(v))\n                goto exception;\n        }\n        if (JS_SetPropertyInt64(ctx, r, k, v) < 0)\n            goto exception;\n    }\n    goto done;\n\n exception_close:\n    if (!JS_IsUndefined(stack[0]))\n        JS_IteratorClose(ctx, stack[0], TRUE);\n exception:\n    JS_FreeValue(ctx, r);\n    r = JS_EXCEPTION;\n done:\n    JS_FreeValue(ctx, arr);\n    JS_FreeValue(ctx, stack[0]);\n    JS_FreeValue(ctx, stack[1]);\n    return r;\n}\n\nstatic JSValue js_typed_array_of(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    JSValue obj;\n    JSValueConst args[1];\n    int i;\n\n    args[0] = JS_NewInt32(ctx, argc);\n    obj = js_typed_array_create(ctx, this_val, 1, args);\n    if (JS_IsException(obj))\n        return obj;\n\n    for(i = 0; i < argc; i++) {\n        if (JS_SetPropertyUint32(ctx, obj, i, JS_DupValue(ctx, argv[i])) < 0) {\n            JS_FreeValue(ctx, obj);\n            return JS_EXCEPTION;\n        }\n    }\n    return obj;\n}\n\nstatic JSValue js_typed_array_copyWithin(JSContext *ctx, JSValueConst this_val,\n                                         int argc, JSValueConst *argv)\n{\n    JSObject *p;\n    int len, to, from, final, count, shift;\n\n    len = js_typed_array_get_length_internal(ctx, this_val);\n    if (len < 0)\n        return JS_EXCEPTION;\n\n    if (JS_ToInt32Clamp(ctx, &to, argv[0], 0, len, len))\n        return JS_EXCEPTION;\n\n    if (JS_ToInt32Clamp(ctx, &from, argv[1], 0, len, len))\n        return JS_EXCEPTION;\n\n    final = len;\n    if (argc > 2 && !JS_IsUndefined(argv[2])) {\n        if (JS_ToInt32Clamp(ctx, &final, argv[2], 0, len, len))\n            return JS_EXCEPTION;\n    }\n\n    count = min_int(final - from, len - to);\n    if (count > 0) {\n        p = JS_VALUE_GET_OBJ(this_val);\n        if (typed_array_is_detached(ctx, p))\n            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n        shift = typed_array_size_log2(p->class_id);\n        memmove(p->u.array.u.uint8_ptr + (to << shift),\n                p->u.array.u.uint8_ptr + (from << shift),\n                count << shift);\n    }\n    return JS_DupValue(ctx, this_val);\n}\n\nstatic JSValue js_typed_array_fill(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    JSObject *p;\n    int len, k, final, shift;\n    uint64_t v64;\n\n    len = js_typed_array_get_length_internal(ctx, this_val);\n    if (len < 0)\n        return JS_EXCEPTION;\n    p = JS_VALUE_GET_OBJ(this_val);\n\n    if (p->class_id == JS_CLASS_UINT8C_ARRAY) {\n        int32_t v;\n        if (JS_ToUint8ClampFree(ctx, &v, JS_DupValue(ctx, argv[0])))\n            return JS_EXCEPTION;\n        v64 = v;\n    } else if (p->class_id <= JS_CLASS_UINT32_ARRAY) {\n        uint32_t v;\n        if (JS_ToUint32(ctx, &v, argv[0]))\n            return JS_EXCEPTION;\n        v64 = v;\n    } else\n#ifdef CONFIG_BIGNUM\n    if (p->class_id <= JS_CLASS_BIG_UINT64_ARRAY) {\n        if (JS_ToBigInt64(ctx, (int64_t *)&v64, argv[0]))\n            return JS_EXCEPTION;\n    } else\n#endif\n    {\n        double d;\n        if (JS_ToFloat64(ctx, &d, argv[0]))\n            return JS_EXCEPTION;\n        if (p->class_id == JS_CLASS_FLOAT32_ARRAY) {\n            union {\n                float f;\n                uint32_t u32;\n            } u;\n            u.f = d;\n            v64 = u.u32;\n        } else {\n            JSFloat64Union u;\n            u.d = d;\n            v64 = u.u64;\n        }\n    }\n\n    k = 0;\n    if (argc > 1) {\n        if (JS_ToInt32Clamp(ctx, &k, argv[1], 0, len, len))\n            return JS_EXCEPTION;\n    }\n\n    final = len;\n    if (argc > 2 && !JS_IsUndefined(argv[2])) {\n        if (JS_ToInt32Clamp(ctx, &final, argv[2], 0, len, len))\n            return JS_EXCEPTION;\n    }\n\n    if (typed_array_is_detached(ctx, p))\n        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n    \n    shift = typed_array_size_log2(p->class_id);\n    switch(shift) {\n    case 0:\n        if (k < final) {\n            memset(p->u.array.u.uint8_ptr + k, v64, final - k);\n        }\n        break;\n    case 1:\n        for(; k < final; k++) {\n            p->u.array.u.uint16_ptr[k] = v64;\n        }\n        break;\n    case 2:\n        for(; k < final; k++) {\n            p->u.array.u.uint32_ptr[k] = v64;\n        }\n        break;\n    case 3:\n        for(; k < final; k++) {\n            p->u.array.u.uint64_ptr[k] = v64;\n        }\n        break;\n    default:\n        abort();\n    }\n    return JS_DupValue(ctx, this_val);\n}\n\nstatic JSValue js_typed_array_find(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv, int findIndex)\n{\n    JSValueConst func, this_arg;\n    JSValueConst args[3];\n    JSValue val, index_val, res;\n    int len, k;\n\n    val = JS_UNDEFINED;\n    len = js_typed_array_get_length_internal(ctx, this_val);\n    if (len < 0)\n        goto exception;\n\n    func = argv[0];\n    if (check_function(ctx, func))\n        goto exception;\n\n    this_arg = JS_UNDEFINED;\n    if (argc > 1)\n        this_arg = argv[1];\n\n    for(k = 0; k < len; k++) {\n        index_val = JS_NewInt32(ctx, k);\n        val = JS_GetPropertyValue(ctx, this_val, index_val);\n        if (JS_IsException(val))\n            goto exception;\n        args[0] = val;\n        args[1] = index_val;\n        args[2] = this_val;\n        res = JS_Call(ctx, func, this_arg, 3, args);\n        if (JS_IsException(res))\n            goto exception;\n        if (JS_ToBoolFree(ctx, res)) {\n            if (findIndex) {\n                JS_FreeValue(ctx, val);\n                return index_val;\n            } else {\n                return val;\n            }\n        }\n        JS_FreeValue(ctx, val);\n    }\n    if (findIndex)\n        return JS_NewInt32(ctx, -1);\n    else\n        return JS_UNDEFINED;\n\nexception:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\n#define special_indexOf 0\n#define special_lastIndexOf 1\n#define special_includes -1\n\nstatic JSValue js_typed_array_indexOf(JSContext *ctx, JSValueConst this_val,\n                                      int argc, JSValueConst *argv, int special)\n{\n    JSObject *p;\n    int len, tag, is_int, is_bigint, k, stop, inc, res = -1;\n    int64_t v64;\n    double d;\n    float f;\n\n    len = js_typed_array_get_length_internal(ctx, this_val);\n    if (len < 0)\n        goto exception;\n    if (len == 0)\n        goto done;\n\n    if (special == special_lastIndexOf) {\n        k = len - 1;\n        if (argc > 1) {\n            if (JS_ToFloat64(ctx, &d, argv[1]))\n                goto exception;\n            if (isnan(d)) {\n                k = 0;\n            } else {\n                if (d >= 0) {\n                    if (d < k) {\n                        k = d;\n                    }\n                } else {\n                    d += len;\n                    if (d < 0)\n                        goto done;\n                    k = d;\n                }\n            }\n        }\n        stop = -1;\n        inc = -1;\n    } else {\n        k = 0;\n        if (argc > 1) {\n            if (JS_ToInt32Clamp(ctx, &k, argv[1], 0, len, len))\n                goto exception;\n        }\n        stop = len;\n        inc = 1;\n    }\n\n    p = JS_VALUE_GET_OBJ(this_val);\n    /* if the array was detached, no need to go further (but no\n       exception is raised) */\n    if (typed_array_is_detached(ctx, p)) {\n        /* \"includes\" scans all the properties, so \"undefined\" can match */\n        if (special == special_includes && JS_IsUndefined(argv[0]) && len > 0)\n            res = 0;\n        goto done;\n    }\n    \n    is_bigint = 0;\n    is_int = 0; /* avoid warning */\n    v64 = 0; /* avoid warning */\n    tag = JS_VALUE_GET_NORM_TAG(argv[0]);\n    if (tag == JS_TAG_INT) {\n        is_int = 1;\n        v64 = JS_VALUE_GET_INT(argv[0]);\n        d = v64;\n    } else\n    if (tag == JS_TAG_FLOAT64) {\n        d = JS_VALUE_GET_FLOAT64(argv[0]);\n        v64 = d;\n        is_int = (v64 == d);\n    } else\n#ifdef CONFIG_BIGNUM\n    if (tag == JS_TAG_BIG_INT) {\n        JSBigFloat *p1 = JS_VALUE_GET_PTR(argv[0]);\n        \n        if (p->class_id == JS_CLASS_BIG_INT64_ARRAY) {\n            if (bf_get_int64(&v64, &p1->num, 0) != 0)\n                goto done;\n        } else if (p->class_id == JS_CLASS_BIG_UINT64_ARRAY) {\n            if (bf_get_uint64((uint64_t *)&v64, &p1->num) != 0)\n                goto done;\n        } else {\n            goto done;\n        }\n        d = 0;\n        is_bigint = 1;\n    } else\n#endif\n    {\n        goto done;\n    }\n\n    switch (p->class_id) {\n    case JS_CLASS_INT8_ARRAY:\n        if (is_int && (int8_t)v64 == v64)\n            goto scan8;\n        break;\n    case JS_CLASS_UINT8C_ARRAY:\n    case JS_CLASS_UINT8_ARRAY:\n        if (is_int && (uint8_t)v64 == v64) {\n            const uint8_t *pv, *pp;\n            uint16_t v;\n        scan8:\n            pv = p->u.array.u.uint8_ptr;\n            v = v64;\n            if (inc > 0) {\n                pp = memchr(pv + k, v, len - k);\n                if (pp)\n                    res = pp - pv;\n            } else {\n                for (; k != stop; k += inc) {\n                    if (pv[k] == v) {\n                        res = k;\n                        break;\n                    }\n                }\n            }\n        }\n        break;\n    case JS_CLASS_INT16_ARRAY:\n        if (is_int && (int16_t)v64 == v64)\n            goto scan16;\n        break;\n    case JS_CLASS_UINT16_ARRAY:\n        if (is_int && (uint16_t)v64 == v64) {\n            const uint16_t *pv;\n            uint16_t v;\n        scan16:\n            pv = p->u.array.u.uint16_ptr;\n            v = v64;\n            for (; k != stop; k += inc) {\n                if (pv[k] == v) {\n                    res = k;\n                    break;\n                }\n            }\n        }\n        break;\n    case JS_CLASS_INT32_ARRAY:\n        if (is_int && (int32_t)v64 == v64)\n            goto scan32;\n        break;\n    case JS_CLASS_UINT32_ARRAY:\n        if (is_int && (uint32_t)v64 == v64) {\n            const uint32_t *pv;\n            uint32_t v;\n        scan32:\n            pv = p->u.array.u.uint32_ptr;\n            v = v64;\n            for (; k != stop; k += inc) {\n                if (pv[k] == v) {\n                    res = k;\n                    break;\n                }\n            }\n        }\n        break;\n    case JS_CLASS_FLOAT32_ARRAY:\n        if (is_bigint)\n            break;\n        if (isnan(d)) {\n            const float *pv = p->u.array.u.float_ptr;\n            /* special case: indexOf returns -1, includes finds NaN */\n            if (special != special_includes)\n                goto done;\n            for (; k != stop; k += inc) {\n                if (isnan(pv[k])) {\n                    res = k;\n                    break;\n                }\n            }\n        } else if ((f = (float)d) == d) {\n            const float *pv = p->u.array.u.float_ptr;\n            for (; k != stop; k += inc) {\n                if (pv[k] == f) {\n                    res = k;\n                    break;\n                }\n            }\n        }\n        break;\n    case JS_CLASS_FLOAT64_ARRAY:\n        if (is_bigint)\n            break;\n        if (isnan(d)) {\n            const double *pv = p->u.array.u.double_ptr;\n            /* special case: indexOf returns -1, includes finds NaN */\n            if (special != special_includes)\n                goto done;\n            for (; k != stop; k += inc) {\n                if (isnan(pv[k])) {\n                    res = k;\n                    break;\n                }\n            }\n        } else {\n            const double *pv = p->u.array.u.double_ptr;\n            for (; k != stop; k += inc) {\n                if (pv[k] == d) {\n                    res = k;\n                    break;\n                }\n            }\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_CLASS_BIG_INT64_ARRAY:\n        if (is_bigint || (is_math_mode(ctx) && is_int &&\n                          v64 >= -MAX_SAFE_INTEGER &&\n                          v64 <= MAX_SAFE_INTEGER)) {\n            goto scan64;\n        }\n        break;\n    case JS_CLASS_BIG_UINT64_ARRAY:\n        if (is_bigint || (is_math_mode(ctx) && is_int &&\n                          v64 >= 0 && v64 <= MAX_SAFE_INTEGER)) {\n            const uint64_t *pv;\n            uint64_t v;\n        scan64:\n            pv = p->u.array.u.uint64_ptr;\n            v = v64;\n            for (; k != stop; k += inc) {\n                if (pv[k] == v) {\n                    res = k;\n                    break;\n                }\n            }\n        }\n        break;\n#endif\n    }\n\ndone:\n    if (special == special_includes)\n        return JS_NewBool(ctx, res >= 0);\n    else\n        return JS_NewInt32(ctx, res);\n\nexception:\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_typed_array_join(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv, int toLocaleString)\n{\n    JSValue sep = JS_UNDEFINED, el;\n    StringBuffer b_s, *b = &b_s;\n    JSString *p = NULL;\n    int i, n;\n    int c;\n\n    n = js_typed_array_get_length_internal(ctx, this_val);\n    if (n < 0)\n        goto exception;\n\n    c = ',';    /* default separator */\n    if (!toLocaleString && argc > 0 && !JS_IsUndefined(argv[0])) {\n        sep = JS_ToString(ctx, argv[0]);\n        if (JS_IsException(sep))\n            goto exception;\n        p = JS_VALUE_GET_STRING(sep);\n        if (p->len == 1 && !p->is_wide_char)\n            c = p->u.str8[0];\n        else\n            c = -1;\n    }\n    string_buffer_init(ctx, b, 0);\n\n    /* XXX: optimize with direct access */\n    for(i = 0; i < n; i++) {\n        if (i > 0) {\n            if (c >= 0) {\n                if (string_buffer_putc8(b, c))\n                    goto fail;\n            } else {\n                if (string_buffer_concat(b, p, 0, p->len))\n                    goto fail;\n            }\n        }\n        el = JS_GetPropertyUint32(ctx, this_val, i);\n        /* Can return undefined for example if the typed array is detached */\n        if (!JS_IsNull(el) && !JS_IsUndefined(el)) {\n            if (JS_IsException(el))\n                goto fail;\n            if (toLocaleString) {\n                el = JS_ToLocaleStringFree(ctx, el);\n            }\n            if (string_buffer_concat_value_free(b, el))\n                goto fail;\n        }\n    }\n    JS_FreeValue(ctx, sep);\n    return string_buffer_end(b);\n\nfail:\n    string_buffer_free(b);\n    JS_FreeValue(ctx, sep);\nexception:\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_typed_array_reverse(JSContext *ctx, JSValueConst this_val,\n                                      int argc, JSValueConst *argv)\n{\n    JSObject *p;\n    int len;\n\n    len = js_typed_array_get_length_internal(ctx, this_val);\n    if (len < 0)\n        return JS_EXCEPTION;\n    if (len > 0) {\n        p = JS_VALUE_GET_OBJ(this_val);\n        switch (typed_array_size_log2(p->class_id)) {\n        case 0:\n            {\n                uint8_t *p1 = p->u.array.u.uint8_ptr;\n                uint8_t *p2 = p1 + len - 1;\n                while (p1 < p2) {\n                    uint8_t v = *p1;\n                    *p1++ = *p2;\n                    *p2-- = v;\n                }\n            }\n            break;\n        case 1:\n            {\n                uint16_t *p1 = p->u.array.u.uint16_ptr;\n                uint16_t *p2 = p1 + len - 1;\n                while (p1 < p2) {\n                    uint16_t v = *p1;\n                    *p1++ = *p2;\n                    *p2-- = v;\n                }\n            }\n            break;\n        case 2:\n            {\n                uint32_t *p1 = p->u.array.u.uint32_ptr;\n                uint32_t *p2 = p1 + len - 1;\n                while (p1 < p2) {\n                    uint32_t v = *p1;\n                    *p1++ = *p2;\n                    *p2-- = v;\n                }\n            }\n            break;\n        case 3:\n            {\n                uint64_t *p1 = p->u.array.u.uint64_ptr;\n                uint64_t *p2 = p1 + len - 1;\n                while (p1 < p2) {\n                    uint64_t v = *p1;\n                    *p1++ = *p2;\n                    *p2-- = v;\n                }\n            }\n            break;\n        default:\n            abort();\n        }\n    }\n    return JS_DupValue(ctx, this_val);\n}\n\nstatic JSValue js_typed_array_slice(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv)\n{\n    JSValueConst args[2];\n    JSValue arr, val;\n    JSObject *p, *p1;\n    int n, len, start, final, count, shift;\n\n    arr = JS_UNDEFINED;\n    len = js_typed_array_get_length_internal(ctx, this_val);\n    if (len < 0)\n        goto exception;\n\n    if (JS_ToInt32Clamp(ctx, &start, argv[0], 0, len, len))\n        goto exception;\n    final = len;\n    if (!JS_IsUndefined(argv[1])) {\n        if (JS_ToInt32Clamp(ctx, &final, argv[1], 0, len, len))\n            goto exception;\n    }\n    count = max_int(final - start, 0);\n\n    p = get_typed_array(ctx, this_val, 0);\n    if (p == NULL)\n        goto exception;\n    shift = typed_array_size_log2(p->class_id);\n\n    args[0] = this_val;\n    args[1] = JS_NewInt32(ctx, count);\n    arr = js_typed_array___speciesCreate(ctx, JS_UNDEFINED, 2, args);\n    if (JS_IsException(arr))\n        goto exception;\n\n    if (count > 0) {\n        if (validate_typed_array(ctx, this_val)\n        ||  validate_typed_array(ctx, arr))\n            goto exception;\n\n        p1 = get_typed_array(ctx, arr, 0);\n        if (p1 != NULL && p->class_id == p1->class_id &&\n            typed_array_get_length(ctx, p1) >= count &&\n            typed_array_get_length(ctx, p) >= start + count) {\n            memcpy(p1->u.array.u.uint8_ptr,\n                   p->u.array.u.uint8_ptr + (start << shift),\n                   count << shift);\n        } else {\n            for (n = 0; n < count; n++) {\n                val = JS_GetPropertyValue(ctx, this_val, JS_NewInt32(ctx, start + n));\n                if (JS_IsException(val))\n                    goto exception;\n                if (JS_SetPropertyValue(ctx, arr, JS_NewInt32(ctx, n), val,\n                                        JS_PROP_THROW) < 0)\n                    goto exception;\n            }\n        }\n    }\n    return arr;\n\n exception:\n    JS_FreeValue(ctx, arr);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_typed_array_subarray(JSContext *ctx, JSValueConst this_val,\n                                       int argc, JSValueConst *argv)\n{\n    JSValueConst args[4];\n    JSValue arr, byteOffset, ta_buffer;\n    JSObject *p;\n    int len, start, final, count, shift, offset;\n\n    p = get_typed_array(ctx, this_val, 0);\n    if (!p)\n        goto exception;\n    len = p->u.array.count;\n    if (JS_ToInt32Clamp(ctx, &start, argv[0], 0, len, len))\n        goto exception;\n\n    final = len;\n    if (!JS_IsUndefined(argv[1])) {\n        if (JS_ToInt32Clamp(ctx, &final, argv[1], 0, len, len))\n            goto exception;\n    }\n    count = max_int(final - start, 0);\n    byteOffset = js_typed_array_get_byteOffset(ctx, this_val, 0);\n    if (JS_IsException(byteOffset))\n        goto exception;\n    shift = typed_array_size_log2(p->class_id);\n    offset = JS_VALUE_GET_INT(byteOffset) + (start << shift);\n    JS_FreeValue(ctx, byteOffset);\n    ta_buffer = js_typed_array_get_buffer(ctx, this_val, 0);\n    if (JS_IsException(ta_buffer))\n        goto exception;\n    args[0] = this_val;\n    args[1] = ta_buffer;\n    args[2] = JS_NewInt32(ctx, offset);\n    args[3] = JS_NewInt32(ctx, count);\n    arr = js_typed_array___speciesCreate(ctx, JS_UNDEFINED, 4, args);\n    JS_FreeValue(ctx, ta_buffer);\n    return arr;\n\n exception:\n    return JS_EXCEPTION;\n}\n\n/* TypedArray.prototype.sort */\n\nstatic int js_cmp_doubles(double x, double y)\n{\n    if (isnan(x))    return isnan(y) ? 0 : +1;\n    if (isnan(y))    return -1;\n    if (x < y)       return -1;\n    if (x > y)       return 1;\n    if (x != 0)      return 0;\n    if (signbit(x))  return signbit(y) ? 0 : -1;\n    else             return signbit(y) ? 1 : 0;\n}\n\nstatic int js_TA_cmp_int8(const void *a, const void *b, void *opaque) {\n    return *(const int8_t *)a - *(const int8_t *)b;\n}\n\nstatic int js_TA_cmp_uint8(const void *a, const void *b, void *opaque) {\n    return *(const uint8_t *)a - *(const uint8_t *)b;\n}\n\nstatic int js_TA_cmp_int16(const void *a, const void *b, void *opaque) {\n    return *(const int16_t *)a - *(const int16_t *)b;\n}\n\nstatic int js_TA_cmp_uint16(const void *a, const void *b, void *opaque) {\n    return *(const uint16_t *)a - *(const uint16_t *)b;\n}\n\nstatic int js_TA_cmp_int32(const void *a, const void *b, void *opaque) {\n    int32_t x = *(const int32_t *)a;\n    int32_t y = *(const int32_t *)b;\n    return (y < x) - (y > x);\n}\n\nstatic int js_TA_cmp_uint32(const void *a, const void *b, void *opaque) {\n    uint32_t x = *(const uint32_t *)a;\n    uint32_t y = *(const uint32_t *)b;\n    return (y < x) - (y > x);\n}\n\n#ifdef CONFIG_BIGNUM\nstatic int js_TA_cmp_int64(const void *a, const void *b, void *opaque) {\n    int64_t x = *(const int64_t *)a;\n    int64_t y = *(const int64_t *)b;\n    return (y < x) - (y > x);\n}\n\nstatic int js_TA_cmp_uint64(const void *a, const void *b, void *opaque) {\n    uint64_t x = *(const uint64_t *)a;\n    uint64_t y = *(const uint64_t *)b;\n    return (y < x) - (y > x);\n}\n#endif\n\nstatic int js_TA_cmp_float32(const void *a, const void *b, void *opaque) {\n    return js_cmp_doubles(*(const float *)a, *(const float *)b);\n}\n\nstatic int js_TA_cmp_float64(const void *a, const void *b, void *opaque) {\n    return js_cmp_doubles(*(const double *)a, *(const double *)b);\n}\n\nstatic JSValue js_TA_get_int8(JSContext *ctx, const void *a) {\n    return JS_NewInt32(ctx, *(const int8_t *)a);\n}\n\nstatic JSValue js_TA_get_uint8(JSContext *ctx, const void *a) {\n    return JS_NewInt32(ctx, *(const uint8_t *)a);\n}\n\nstatic JSValue js_TA_get_int16(JSContext *ctx, const void *a) {\n    return JS_NewInt32(ctx, *(const int16_t *)a);\n}\n\nstatic JSValue js_TA_get_uint16(JSContext *ctx, const void *a) {\n    return JS_NewInt32(ctx, *(const uint16_t *)a);\n}\n\nstatic JSValue js_TA_get_int32(JSContext *ctx, const void *a) {\n    return JS_NewInt32(ctx, *(const int32_t *)a);\n}\n\nstatic JSValue js_TA_get_uint32(JSContext *ctx, const void *a) {\n    return JS_NewUint32(ctx, *(const uint32_t *)a);\n}\n\n#ifdef CONFIG_BIGNUM\nstatic JSValue js_TA_get_int64(JSContext *ctx, const void *a) {\n    return JS_NewBigInt64(ctx, *(int64_t *)a);\n}\n\nstatic JSValue js_TA_get_uint64(JSContext *ctx, const void *a) {\n    return JS_NewBigUint64(ctx, *(uint64_t *)a);\n}\n#endif\n\nstatic JSValue js_TA_get_float32(JSContext *ctx, const void *a) {\n    return __JS_NewFloat64(ctx, *(const float *)a);\n}\n\nstatic JSValue js_TA_get_float64(JSContext *ctx, const void *a) {\n    return __JS_NewFloat64(ctx, *(const double *)a);\n}\n\nstruct TA_sort_context {\n    JSContext *ctx;\n    int exception;\n    JSValueConst arr;\n    JSValueConst cmp;\n    JSValue (*getfun)(JSContext *ctx, const void *a);\n    uint8_t *array_ptr; /* cannot change unless the array is detached */\n    int elt_size;\n};\n\nstatic int js_TA_cmp_generic(const void *a, const void *b, void *opaque) {\n    struct TA_sort_context *psc = opaque;\n    JSContext *ctx = psc->ctx;\n    uint32_t a_idx, b_idx;\n    JSValueConst argv[2];\n    JSValue res;\n    int cmp;\n\n    cmp = 0;\n    if (!psc->exception) {\n        a_idx = *(uint32_t *)a;\n        b_idx = *(uint32_t *)b;\n        argv[0] = psc->getfun(ctx, psc->array_ptr +\n                              a_idx * (size_t)psc->elt_size);\n        argv[1] = psc->getfun(ctx, psc->array_ptr +\n                              b_idx * (size_t)(psc->elt_size));\n        res = JS_Call(ctx, psc->cmp, JS_UNDEFINED, 2, argv);\n        if (JS_IsException(res)) {\n            psc->exception = 1;\n            goto done;\n        }\n        if (JS_VALUE_GET_TAG(res) == JS_TAG_INT) {\n            int val = JS_VALUE_GET_INT(res);\n            cmp = (val > 0) - (val < 0);\n        } else {\n            double val;\n            if (JS_ToFloat64Free(ctx, &val, res) < 0) {\n                psc->exception = 1;\n                goto done;\n            } else {\n                cmp = (val > 0) - (val < 0);\n            }\n        }\n        if (cmp == 0) {\n            /* make sort stable: compare array offsets */\n            cmp = (a_idx > b_idx) - (a_idx < b_idx);\n        }\n        if (validate_typed_array(ctx, psc->arr) < 0) {\n            psc->exception = 1;\n        }\n    done:\n        JS_FreeValue(ctx, (JSValue)argv[0]);\n        JS_FreeValue(ctx, (JSValue)argv[1]);\n    }\n    return cmp;\n}\n\nstatic JSValue js_typed_array_sort(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    JSObject *p;\n    int len;\n    size_t elt_size;\n    struct TA_sort_context tsc;\n    void *array_ptr;\n    int (*cmpfun)(const void *a, const void *b, void *opaque);\n\n    tsc.ctx = ctx;\n    tsc.exception = 0;\n    tsc.arr = this_val;\n    tsc.cmp = argv[0];\n\n    len = js_typed_array_get_length_internal(ctx, this_val);\n    if (len < 0)\n        return JS_EXCEPTION;\n    if (!JS_IsUndefined(tsc.cmp) && check_function(ctx, tsc.cmp))\n        return JS_EXCEPTION;\n\n    if (len > 1) {\n        p = JS_VALUE_GET_OBJ(this_val);\n        switch (p->class_id) {\n        case JS_CLASS_INT8_ARRAY:\n            tsc.getfun = js_TA_get_int8;\n            cmpfun = js_TA_cmp_int8;\n            break;\n        case JS_CLASS_UINT8C_ARRAY:\n        case JS_CLASS_UINT8_ARRAY:\n            tsc.getfun = js_TA_get_uint8;\n            cmpfun = js_TA_cmp_uint8;\n            break;\n        case JS_CLASS_INT16_ARRAY:\n            tsc.getfun = js_TA_get_int16;\n            cmpfun = js_TA_cmp_int16;\n            break;\n        case JS_CLASS_UINT16_ARRAY:\n            tsc.getfun = js_TA_get_uint16;\n            cmpfun = js_TA_cmp_uint16;\n            break;\n        case JS_CLASS_INT32_ARRAY:\n            tsc.getfun = js_TA_get_int32;\n            cmpfun = js_TA_cmp_int32;\n            break;\n        case JS_CLASS_UINT32_ARRAY:\n            tsc.getfun = js_TA_get_uint32;\n            cmpfun = js_TA_cmp_uint32;\n            break;\n#ifdef CONFIG_BIGNUM\n        case JS_CLASS_BIG_INT64_ARRAY:\n            tsc.getfun = js_TA_get_int64;\n            cmpfun = js_TA_cmp_int64;\n            break;\n        case JS_CLASS_BIG_UINT64_ARRAY:\n            tsc.getfun = js_TA_get_uint64;\n            cmpfun = js_TA_cmp_uint64;\n            break;\n#endif\n        case JS_CLASS_FLOAT32_ARRAY:\n            tsc.getfun = js_TA_get_float32;\n            cmpfun = js_TA_cmp_float32;\n            break;\n        case JS_CLASS_FLOAT64_ARRAY:\n            tsc.getfun = js_TA_get_float64;\n            cmpfun = js_TA_cmp_float64;\n            break;\n        default:\n            abort();\n        }\n        array_ptr = p->u.array.u.ptr;\n        elt_size = 1 << typed_array_size_log2(p->class_id);\n        if (!JS_IsUndefined(tsc.cmp)) {\n            uint32_t *array_idx;\n            void *array_tmp;\n            size_t i, j;\n            \n            /* XXX: a stable sort would use less memory */\n            array_idx = js_malloc(ctx, len * sizeof(array_idx[0]));\n            if (!array_idx)\n                return JS_EXCEPTION;\n            for(i = 0; i < len; i++)\n                array_idx[i] = i;\n            tsc.array_ptr = array_ptr;\n            tsc.elt_size = elt_size;\n            rqsort(array_idx, len, sizeof(array_idx[0]),\n                   js_TA_cmp_generic, &tsc);\n            if (tsc.exception)\n                goto fail;\n            array_tmp = js_malloc(ctx, len * elt_size);\n            if (!array_tmp) {\n            fail:\n                js_free(ctx, array_idx);\n                return JS_EXCEPTION;\n            }\n            memcpy(array_tmp, array_ptr, len * elt_size);\n            switch(elt_size) {\n            case 1:\n                for(i = 0; i < len; i++) {\n                    j = array_idx[i];\n                    ((uint8_t *)array_ptr)[i] = ((uint8_t *)array_tmp)[j];\n                }\n                break;\n            case 2:\n                for(i = 0; i < len; i++) {\n                    j = array_idx[i];\n                    ((uint16_t *)array_ptr)[i] = ((uint16_t *)array_tmp)[j];\n                }\n                break;\n            case 4:\n                for(i = 0; i < len; i++) {\n                    j = array_idx[i];\n                    ((uint32_t *)array_ptr)[i] = ((uint32_t *)array_tmp)[j];\n                }\n                break;\n            case 8:\n                for(i = 0; i < len; i++) {\n                    j = array_idx[i];\n                    ((uint64_t *)array_ptr)[i] = ((uint64_t *)array_tmp)[j];\n                }\n                break;\n            default:\n                abort();\n            }\n            js_free(ctx, array_tmp);\n            js_free(ctx, array_idx);\n        } else {\n            rqsort(array_ptr, len, elt_size, cmpfun, &tsc);\n            if (tsc.exception)\n                return JS_EXCEPTION;\n        }\n    }\n    return JS_DupValue(ctx, this_val);\n}\n\nstatic const JSCFunctionListEntry js_typed_array_base_funcs[] = {\n    JS_CFUNC_DEF(\"from\", 1, js_typed_array_from ),\n    JS_CFUNC_DEF(\"of\", 0, js_typed_array_of ),\n    JS_CGETSET_DEF(\"[Symbol.species]\", js_get_this, NULL ),\n    //JS_CFUNC_DEF(\"__getLength\", 2, js_typed_array___getLength ),\n    //JS_CFUNC_DEF(\"__create\", 2, js_typed_array___create ),\n    //JS_CFUNC_DEF(\"__speciesCreate\", 2, js_typed_array___speciesCreate ),\n};\n\nstatic const JSCFunctionListEntry js_typed_array_base_proto_funcs[] = {\n    JS_CGETSET_DEF(\"length\", js_typed_array_get_length, NULL ),\n    JS_CGETSET_MAGIC_DEF(\"buffer\", js_typed_array_get_buffer, NULL, 0 ),\n    JS_CGETSET_MAGIC_DEF(\"byteLength\", js_typed_array_get_byteLength, NULL, 0 ),\n    JS_CGETSET_MAGIC_DEF(\"byteOffset\", js_typed_array_get_byteOffset, NULL, 0 ),\n    JS_CFUNC_DEF(\"set\", 1, js_typed_array_set ),\n    JS_CFUNC_MAGIC_DEF(\"values\", 0, js_create_typed_array_iterator, JS_ITERATOR_KIND_VALUE ),\n    JS_ALIAS_DEF(\"[Symbol.iterator]\", \"values\" ),\n    JS_CFUNC_MAGIC_DEF(\"keys\", 0, js_create_typed_array_iterator, JS_ITERATOR_KIND_KEY ),\n    JS_CFUNC_MAGIC_DEF(\"entries\", 0, js_create_typed_array_iterator, JS_ITERATOR_KIND_KEY_AND_VALUE ),\n    JS_CGETSET_DEF(\"[Symbol.toStringTag]\", js_typed_array_get_toStringTag, NULL ),\n    JS_CFUNC_DEF(\"copyWithin\", 2, js_typed_array_copyWithin ),\n    JS_CFUNC_MAGIC_DEF(\"every\", 1, js_array_every, special_every | special_TA ),\n    JS_CFUNC_MAGIC_DEF(\"some\", 1, js_array_every, special_some | special_TA ),\n    JS_CFUNC_MAGIC_DEF(\"forEach\", 1, js_array_every, special_forEach | special_TA ),\n    JS_CFUNC_MAGIC_DEF(\"map\", 1, js_array_every, special_map | special_TA ),\n    JS_CFUNC_MAGIC_DEF(\"filter\", 1, js_array_every, special_filter | special_TA ),\n    JS_CFUNC_MAGIC_DEF(\"reduce\", 1, js_array_reduce, special_reduce | special_TA ),\n    JS_CFUNC_MAGIC_DEF(\"reduceRight\", 1, js_array_reduce, special_reduceRight | special_TA ),\n    JS_CFUNC_DEF(\"fill\", 1, js_typed_array_fill ),\n    JS_CFUNC_MAGIC_DEF(\"find\", 1, js_typed_array_find, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"findIndex\", 1, js_typed_array_find, 1 ),\n    JS_CFUNC_DEF(\"reverse\", 0, js_typed_array_reverse ),\n    JS_CFUNC_DEF(\"slice\", 2, js_typed_array_slice ),\n    JS_CFUNC_DEF(\"subarray\", 2, js_typed_array_subarray ),\n    JS_CFUNC_DEF(\"sort\", 1, js_typed_array_sort ),\n    JS_CFUNC_MAGIC_DEF(\"join\", 1, js_typed_array_join, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"toLocaleString\", 0, js_typed_array_join, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"indexOf\", 1, js_typed_array_indexOf, special_indexOf ),\n    JS_CFUNC_MAGIC_DEF(\"lastIndexOf\", 1, js_typed_array_indexOf, special_lastIndexOf ),\n    JS_CFUNC_MAGIC_DEF(\"includes\", 1, js_typed_array_indexOf, special_includes ),\n    //JS_ALIAS_BASE_DEF(\"toString\", \"toString\", 2 /* Array.prototype. */), @@@\n};\n\nstatic JSValue js_typed_array_base_constructor(JSContext *ctx,\n                                               JSValueConst this_val,\n                                               int argc, JSValueConst *argv)\n{\n    return JS_ThrowTypeError(ctx, \"cannot be called\");\n}\n\n/* 'obj' must be an allocated typed array object */\nstatic int typed_array_init(JSContext *ctx, JSValueConst obj,\n                            JSValue buffer, uint64_t offset, uint64_t len)\n{\n    JSTypedArray *ta;\n    JSObject *p, *pbuffer;\n    JSArrayBuffer *abuf;\n    int size_log2;\n\n    p = JS_VALUE_GET_OBJ(obj);\n    size_log2 = typed_array_size_log2(p->class_id);\n    ta = js_malloc(ctx, sizeof(*ta));\n    if (!ta) {\n        JS_FreeValue(ctx, buffer);\n        return -1;\n    }\n    pbuffer = JS_VALUE_GET_OBJ(buffer);\n    abuf = pbuffer->u.array_buffer;\n    ta->obj = p;\n    ta->buffer = pbuffer;\n    ta->offset = offset;\n    ta->length = len << size_log2;\n    list_add_tail(&ta->link, &abuf->array_list);\n    p->u.typed_array = ta;\n    p->u.array.count = len;\n    p->u.array.u.ptr = abuf->data + offset;\n    return 0;\n}\n\n\nstatic JSValue js_array_from_iterator(JSContext *ctx, uint32_t *plen,\n                                      JSValueConst obj, JSValueConst method)\n{\n    JSValue arr, iter, next_method = JS_UNDEFINED, val;\n    BOOL done;\n    uint32_t k;\n\n    *plen = 0;\n    arr = JS_NewArray(ctx);\n    if (JS_IsException(arr))\n        return arr;\n    iter = JS_GetIterator2(ctx, obj, method);\n    if (JS_IsException(iter))\n        goto fail;\n    next_method = JS_GetProperty(ctx, iter, JS_ATOM_next);\n    if (JS_IsException(next_method))\n        goto fail;\n    k = 0;\n    for(;;) {\n        val = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);\n        if (JS_IsException(val))\n            goto fail;\n        if (done) {\n            JS_FreeValue(ctx, val);\n            break;\n        }\n        if (JS_CreateDataPropertyUint32(ctx, arr, k, val, JS_PROP_THROW) < 0)\n            goto fail;\n        k++;\n    }\n    JS_FreeValue(ctx, next_method);\n    JS_FreeValue(ctx, iter);\n    *plen = k;\n    return arr;\n fail:\n    JS_FreeValue(ctx, next_method);\n    JS_FreeValue(ctx, iter);\n    JS_FreeValue(ctx, arr);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_typed_array_constructor_obj(JSContext *ctx,\n                                              JSValueConst new_target,\n                                              JSValueConst obj,\n                                              int classid)\n{\n    JSValue iter, ret, arr = JS_UNDEFINED, val, buffer;\n    uint32_t i;\n    int size_log2;\n    int64_t len;\n\n    size_log2 = typed_array_size_log2(classid);\n    ret = js_create_from_ctor(ctx, new_target, classid);\n    if (JS_IsException(ret))\n        return JS_EXCEPTION;\n\n    iter = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_iterator);\n    if (JS_IsException(iter))\n        goto fail;\n    if (!JS_IsUndefined(iter) && !JS_IsNull(iter)) {\n        uint32_t len1;\n        arr = js_array_from_iterator(ctx, &len1, obj, iter);\n        JS_FreeValue(ctx, iter);\n        if (JS_IsException(arr))\n            goto fail;\n        len = len1;\n    } else {\n        if (js_get_length64(ctx, &len, obj))\n            goto fail;\n        arr = JS_DupValue(ctx, obj);\n    }\n\n    buffer = js_array_buffer_constructor1(ctx, JS_UNDEFINED,\n                                          len << size_log2);\n    if (JS_IsException(buffer))\n        goto fail;\n    if (typed_array_init(ctx, ret, buffer, 0, len))\n        goto fail;\n\n    for(i = 0; i < len; i++) {\n        val = JS_GetPropertyUint32(ctx, arr, i);\n        if (JS_IsException(val))\n            goto fail;\n        if (JS_SetPropertyUint32(ctx, ret, i, val) < 0)\n            goto fail;\n    }\n    JS_FreeValue(ctx, arr);\n    return ret;\n fail:\n    JS_FreeValue(ctx, arr);\n    JS_FreeValue(ctx, ret);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_typed_array_constructor_ta(JSContext *ctx,\n                                             JSValueConst new_target,\n                                             JSValueConst src_obj,\n                                             int classid)\n{\n    JSObject *p, *src_buffer;\n    JSTypedArray *ta;\n    JSValue ctor, obj, buffer;\n    uint32_t len, i;\n    int size_log2;\n    JSArrayBuffer *src_abuf, *abuf;\n\n    obj = js_create_from_ctor(ctx, new_target, classid);\n    if (JS_IsException(obj))\n        return obj;\n    p = JS_VALUE_GET_OBJ(src_obj);\n    if (typed_array_is_detached(ctx, p)) {\n        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n        goto fail;\n    }\n    ta = p->u.typed_array;\n    len = p->u.array.count;\n    src_buffer = ta->buffer;\n    src_abuf = src_buffer->u.array_buffer;\n    if (!src_abuf->shared) {\n        ctor = JS_SpeciesConstructor(ctx, JS_MKPTR(JS_TAG_OBJECT, src_buffer),\n                                     JS_UNDEFINED);\n        if (JS_IsException(ctor))\n            goto fail;\n    } else {\n        /* force ArrayBuffer default constructor */\n        ctor = JS_UNDEFINED;\n    }\n    size_log2 = typed_array_size_log2(classid);\n    buffer = js_array_buffer_constructor1(ctx, ctor,\n                                          (uint64_t)len << size_log2);\n    JS_FreeValue(ctx, ctor);\n    if (JS_IsException(buffer))\n        goto fail;\n    /* necessary because it could have been detached */\n    if (typed_array_is_detached(ctx, p)) {\n        JS_FreeValue(ctx, buffer);\n        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n        goto fail;\n    }\n    abuf = JS_GetOpaque(buffer, JS_CLASS_ARRAY_BUFFER);\n    if (typed_array_init(ctx, obj, buffer, 0, len))\n        goto fail;\n    if (p->class_id == classid) {\n        /* same type: copy the content */\n        memcpy(abuf->data, src_abuf->data + ta->offset, abuf->byte_length);\n    } else {\n        for(i = 0; i < len; i++) {\n            JSValue val;\n            val = JS_GetPropertyUint32(ctx, src_obj, i);\n            if (JS_IsException(val))\n                goto fail;\n            if (JS_SetPropertyUint32(ctx, obj, i, val) < 0)\n                goto fail;\n        }\n    }\n    return obj;\n fail:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_typed_array_constructor(JSContext *ctx,\n                                          JSValueConst new_target,\n                                          int argc, JSValueConst *argv,\n                                          int classid)\n{\n    JSValue buffer, obj;\n    JSArrayBuffer *abuf;\n    int size_log2;\n    uint64_t len, offset;\n\n    size_log2 = typed_array_size_log2(classid);\n    if (JS_VALUE_GET_TAG(argv[0]) != JS_TAG_OBJECT) {\n        if (JS_ToIndex(ctx, &len, argv[0]))\n            return JS_EXCEPTION;\n        buffer = js_array_buffer_constructor1(ctx, JS_UNDEFINED,\n                                              len << size_log2);\n        if (JS_IsException(buffer))\n            return JS_EXCEPTION;\n        offset = 0;\n    } else {\n        JSObject *p = JS_VALUE_GET_OBJ(argv[0]);\n        if (p->class_id == JS_CLASS_ARRAY_BUFFER ||\n            p->class_id == JS_CLASS_SHARED_ARRAY_BUFFER) {\n            abuf = p->u.array_buffer;\n            if (JS_ToIndex(ctx, &offset, argv[1]))\n                return JS_EXCEPTION;\n            if (abuf->detached)\n                return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n            if ((offset & ((1 << size_log2) - 1)) != 0 ||\n                offset > abuf->byte_length)\n                return JS_ThrowRangeError(ctx, \"invalid offset\");\n            if (JS_IsUndefined(argv[2])) {\n                if ((abuf->byte_length & ((1 << size_log2) - 1)) != 0)\n                    goto invalid_length;\n                len = (abuf->byte_length - offset) >> size_log2;\n            } else {\n                if (JS_ToIndex(ctx, &len, argv[2]))\n                    return JS_EXCEPTION;\n                if (abuf->detached)\n                    return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n                if ((offset + (len << size_log2)) > abuf->byte_length) {\n                invalid_length:\n                    return JS_ThrowRangeError(ctx, \"invalid length\");\n                }\n            }\n            buffer = JS_DupValue(ctx, argv[0]);\n        } else {\n            if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n                p->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n                return js_typed_array_constructor_ta(ctx, new_target, argv[0], classid);\n            } else {\n                return js_typed_array_constructor_obj(ctx, new_target, argv[0], classid);\n            }\n        }\n    }\n\n    obj = js_create_from_ctor(ctx, new_target, classid);\n    if (JS_IsException(obj)) {\n        JS_FreeValue(ctx, buffer);\n        return JS_EXCEPTION;\n    }\n    if (typed_array_init(ctx, obj, buffer, offset, len)) {\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    return obj;\n}\n\nstatic void js_typed_array_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSTypedArray *ta = p->u.typed_array;\n    if (ta) {\n        /* during the GC the finalizers are called in an arbitrary\n           order so the ArrayBuffer finalizer may have been called */\n        if (JS_IsLiveObject(rt, JS_MKPTR(JS_TAG_OBJECT, ta->buffer))) {\n            list_del(&ta->link);\n        }\n        JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, ta->buffer));\n        js_free_rt(rt, ta);\n    }\n}\n\nstatic void js_typed_array_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSTypedArray *ta = p->u.typed_array;\n    if (ta) {\n        JS_MarkValue(rt, JS_MKPTR(JS_TAG_OBJECT, ta->buffer), mark_func);\n    }\n}\n\nstatic JSValue js_dataview_constructor(JSContext *ctx,\n                                       JSValueConst new_target,\n                                       int argc, JSValueConst *argv)\n{\n    JSArrayBuffer *abuf;\n    uint64_t offset;\n    uint32_t len;\n    JSValueConst buffer;\n    JSValue obj;\n    JSTypedArray *ta;\n    JSObject *p;\n\n    buffer = argv[0];\n    abuf = js_get_array_buffer(ctx, buffer);\n    if (!abuf)\n        return JS_EXCEPTION;\n    offset = 0;\n    if (argc > 1) {\n        if (JS_ToIndex(ctx, &offset, argv[1]))\n            return JS_EXCEPTION;\n    }\n    if (abuf->detached)\n        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n    if (offset > abuf->byte_length)\n        return JS_ThrowRangeError(ctx, \"invalid byteOffset\");\n    len = abuf->byte_length - offset;\n    if (argc > 2 && !JS_IsUndefined(argv[2])) {\n        uint64_t l;\n        if (JS_ToIndex(ctx, &l, argv[2]))\n            return JS_EXCEPTION;\n        if (l > len)\n            return JS_ThrowRangeError(ctx, \"invalid byteLength\");\n        len = l;\n    }\n\n    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_DATAVIEW);\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n    if (abuf->detached) {\n        /* could have been detached in js_create_from_ctor() */\n        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n        goto fail;\n    }\n    ta = js_malloc(ctx, sizeof(*ta));\n    if (!ta) {\n    fail:\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    p = JS_VALUE_GET_OBJ(obj);\n    ta->obj = p;\n    ta->buffer = JS_VALUE_GET_OBJ(JS_DupValue(ctx, buffer));\n    ta->offset = offset;\n    ta->length = len;\n    list_add_tail(&ta->link, &abuf->array_list);\n    p->u.typed_array = ta;\n    return obj;\n}\n\nstatic JSValue js_dataview_getValue(JSContext *ctx,\n                                    JSValueConst this_obj,\n                                    int argc, JSValueConst *argv, int class_id)\n{\n    JSTypedArray *ta;\n    JSArrayBuffer *abuf;\n    int is_swap, size;\n    uint8_t *ptr;\n    uint32_t v;\n    uint64_t pos;\n\n    ta = JS_GetOpaque2(ctx, this_obj, JS_CLASS_DATAVIEW);\n    if (!ta)\n        return JS_EXCEPTION;\n    size = 1 << typed_array_size_log2(class_id);\n    if (JS_ToIndex(ctx, &pos, argv[0]))\n        return JS_EXCEPTION;\n    is_swap = FALSE;\n    if (argc > 1)\n        is_swap = JS_ToBool(ctx, argv[1]);\n#ifndef WORDS_BIGENDIAN\n    is_swap ^= 1;\n#endif\n    abuf = ta->buffer->u.array_buffer;\n    if (abuf->detached)\n        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n    if ((pos + size) > ta->length)\n        return JS_ThrowRangeError(ctx, \"out of bound\");\n    ptr = abuf->data + ta->offset + pos;\n\n    switch(class_id) {\n    case JS_CLASS_INT8_ARRAY:\n        return JS_NewInt32(ctx, *(int8_t *)ptr);\n    case JS_CLASS_UINT8_ARRAY:\n        return JS_NewInt32(ctx, *(uint8_t *)ptr);\n    case JS_CLASS_INT16_ARRAY:\n        v = get_u16(ptr);\n        if (is_swap)\n            v = bswap16(v);\n        return JS_NewInt32(ctx, (int16_t)v);\n    case JS_CLASS_UINT16_ARRAY:\n        v = get_u16(ptr);\n        if (is_swap)\n            v = bswap16(v);\n        return JS_NewInt32(ctx, v);\n    case JS_CLASS_INT32_ARRAY:\n        v = get_u32(ptr);\n        if (is_swap)\n            v = bswap32(v);\n        return JS_NewInt32(ctx, v);\n    case JS_CLASS_UINT32_ARRAY:\n        v = get_u32(ptr);\n        if (is_swap)\n            v = bswap32(v);\n        return JS_NewUint32(ctx, v);\n#ifdef CONFIG_BIGNUM\n    case JS_CLASS_BIG_INT64_ARRAY:\n        {\n            uint64_t v;\n            v = get_u64(ptr);\n            if (is_swap)\n                v = bswap64(v);\n            return JS_NewBigInt64(ctx, v);\n        }\n        break;\n    case JS_CLASS_BIG_UINT64_ARRAY:\n        {\n            uint64_t v;\n            v = get_u64(ptr);\n            if (is_swap)\n                v = bswap64(v);\n            return JS_NewBigUint64(ctx, v);\n        }\n        break;\n#endif\n    case JS_CLASS_FLOAT32_ARRAY:\n        {\n            union {\n                float f;\n                uint32_t i;\n            } u;\n            v = get_u32(ptr);\n            if (is_swap)\n                v = bswap32(v);\n            u.i = v;\n            return __JS_NewFloat64(ctx, u.f);\n        }\n    case JS_CLASS_FLOAT64_ARRAY:\n        {\n            union {\n                double f;\n                uint64_t i;\n            } u;\n            u.i = get_u64(ptr);\n            if (is_swap)\n                u.i = bswap64(u.i);\n            return __JS_NewFloat64(ctx, u.f);\n        }\n    default:\n        abort();\n    }\n}\n\nstatic JSValue js_dataview_setValue(JSContext *ctx,\n                                    JSValueConst this_obj,\n                                    int argc, JSValueConst *argv, int class_id)\n{\n    JSTypedArray *ta;\n    JSArrayBuffer *abuf;\n    int is_swap, size;\n    uint8_t *ptr;\n    uint64_t v64;\n    uint32_t v;\n    uint64_t pos;\n    JSValueConst val;\n\n    ta = JS_GetOpaque2(ctx, this_obj, JS_CLASS_DATAVIEW);\n    if (!ta)\n        return JS_EXCEPTION;\n    size = 1 << typed_array_size_log2(class_id);\n    if (JS_ToIndex(ctx, &pos, argv[0]))\n        return JS_EXCEPTION;\n    val = argv[1];\n    v = 0; /* avoid warning */\n    v64 = 0; /* avoid warning */\n    if (class_id <= JS_CLASS_UINT32_ARRAY) {\n        if (JS_ToUint32(ctx, &v, val))\n            return JS_EXCEPTION;\n    } else\n#ifdef CONFIG_BIGNUM\n    if (class_id <= JS_CLASS_BIG_UINT64_ARRAY) {\n        if (JS_ToBigInt64(ctx, (int64_t *)&v64, val))\n            return JS_EXCEPTION;\n    } else\n#endif\n    {\n        double d;\n        if (JS_ToFloat64(ctx, &d, val))\n            return JS_EXCEPTION;\n        if (class_id == JS_CLASS_FLOAT32_ARRAY) {\n            union {\n                float f;\n                uint32_t i;\n            } u;\n            u.f = d;\n            v = u.i;\n        } else {\n            JSFloat64Union u;\n            u.d = d;\n            v64 = u.u64;\n        }\n    }\n    is_swap = FALSE;\n    if (argc > 2)\n        is_swap = JS_ToBool(ctx, argv[2]);\n#ifndef WORDS_BIGENDIAN\n    is_swap ^= 1;\n#endif\n    abuf = ta->buffer->u.array_buffer;\n    if (abuf->detached)\n        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n    if ((pos + size) > ta->length)\n        return JS_ThrowRangeError(ctx, \"out of bound\");\n    ptr = abuf->data + ta->offset + pos;\n\n    switch(class_id) {\n    case JS_CLASS_INT8_ARRAY:\n    case JS_CLASS_UINT8_ARRAY:\n        *ptr = v;\n        break;\n    case JS_CLASS_INT16_ARRAY:\n    case JS_CLASS_UINT16_ARRAY:\n        if (is_swap)\n            v = bswap16(v);\n        put_u16(ptr, v);\n        break;\n    case JS_CLASS_INT32_ARRAY:\n    case JS_CLASS_UINT32_ARRAY:\n    case JS_CLASS_FLOAT32_ARRAY:\n        if (is_swap)\n            v = bswap32(v);\n        put_u32(ptr, v);\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_CLASS_BIG_INT64_ARRAY:\n    case JS_CLASS_BIG_UINT64_ARRAY:\n#endif\n    case JS_CLASS_FLOAT64_ARRAY:\n        if (is_swap)\n            v64 = bswap64(v64);\n        put_u64(ptr, v64);\n        break;\n    default:\n        abort();\n    }\n    return JS_UNDEFINED;\n}\n\nstatic const JSCFunctionListEntry js_dataview_proto_funcs[] = {\n    JS_CGETSET_MAGIC_DEF(\"buffer\", js_typed_array_get_buffer, NULL, 1 ),\n    JS_CGETSET_MAGIC_DEF(\"byteLength\", js_typed_array_get_byteLength, NULL, 1 ),\n    JS_CGETSET_MAGIC_DEF(\"byteOffset\", js_typed_array_get_byteOffset, NULL, 1 ),\n    JS_CFUNC_MAGIC_DEF(\"getInt8\", 1, js_dataview_getValue, JS_CLASS_INT8_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"getUint8\", 1, js_dataview_getValue, JS_CLASS_UINT8_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"getInt16\", 1, js_dataview_getValue, JS_CLASS_INT16_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"getUint16\", 1, js_dataview_getValue, JS_CLASS_UINT16_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"getInt32\", 1, js_dataview_getValue, JS_CLASS_INT32_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"getUint32\", 1, js_dataview_getValue, JS_CLASS_UINT32_ARRAY ),\n#ifdef CONFIG_BIGNUM\n    JS_CFUNC_MAGIC_DEF(\"getBigInt64\", 1, js_dataview_getValue, JS_CLASS_BIG_INT64_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"getBigUint64\", 1, js_dataview_getValue, JS_CLASS_BIG_UINT64_ARRAY ),\n#endif\n    JS_CFUNC_MAGIC_DEF(\"getFloat32\", 1, js_dataview_getValue, JS_CLASS_FLOAT32_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"getFloat64\", 1, js_dataview_getValue, JS_CLASS_FLOAT64_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"setInt8\", 2, js_dataview_setValue, JS_CLASS_INT8_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"setUint8\", 2, js_dataview_setValue, JS_CLASS_UINT8_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"setInt16\", 2, js_dataview_setValue, JS_CLASS_INT16_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"setUint16\", 2, js_dataview_setValue, JS_CLASS_UINT16_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"setInt32\", 2, js_dataview_setValue, JS_CLASS_INT32_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"setUint32\", 2, js_dataview_setValue, JS_CLASS_UINT32_ARRAY ),\n#ifdef CONFIG_BIGNUM\n    JS_CFUNC_MAGIC_DEF(\"setBigInt64\", 2, js_dataview_setValue, JS_CLASS_BIG_INT64_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"setBigUint64\", 2, js_dataview_setValue, JS_CLASS_BIG_UINT64_ARRAY ),\n#endif\n    JS_CFUNC_MAGIC_DEF(\"setFloat32\", 2, js_dataview_setValue, JS_CLASS_FLOAT32_ARRAY ),\n    JS_CFUNC_MAGIC_DEF(\"setFloat64\", 2, js_dataview_setValue, JS_CLASS_FLOAT64_ARRAY ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"DataView\", JS_PROP_CONFIGURABLE ),\n};\n\n/* Atomics */\n#ifdef CONFIG_ATOMICS\n\ntypedef enum AtomicsOpEnum {\n    ATOMICS_OP_ADD,\n    ATOMICS_OP_AND,\n    ATOMICS_OP_OR,\n    ATOMICS_OP_SUB,\n    ATOMICS_OP_XOR,\n    ATOMICS_OP_EXCHANGE,\n    ATOMICS_OP_COMPARE_EXCHANGE,\n    ATOMICS_OP_LOAD,\n} AtomicsOpEnum;\n\nstatic void *js_atomics_get_ptr(JSContext *ctx,\n                                JSArrayBuffer **pabuf,\n                                int *psize_log2, JSClassID *pclass_id,\n                                JSValueConst obj, JSValueConst idx_val,\n                                int is_waitable)\n{\n    JSObject *p;\n    JSTypedArray *ta;\n    JSArrayBuffer *abuf;\n    void *ptr;\n    uint64_t idx;\n    BOOL err;\n    int size_log2;\n\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        goto fail;\n    p = JS_VALUE_GET_OBJ(obj);\n#ifdef CONFIG_BIGNUM\n    if (is_waitable)\n        err = (p->class_id != JS_CLASS_INT32_ARRAY &&\n               p->class_id != JS_CLASS_BIG_INT64_ARRAY);\n    else\n        err = !(p->class_id >= JS_CLASS_INT8_ARRAY &&\n                p->class_id <= JS_CLASS_BIG_UINT64_ARRAY);\n#else\n    if (is_waitable)\n        err = (p->class_id != JS_CLASS_INT32_ARRAY);\n    else\n        err = !(p->class_id >= JS_CLASS_INT8_ARRAY &&\n                p->class_id <= JS_CLASS_UINT32_ARRAY);\n#endif\n    if (err) {\n    fail:\n        JS_ThrowTypeError(ctx, \"integer TypedArray expected\");\n        return NULL;\n    }\n    ta = p->u.typed_array;\n    abuf = ta->buffer->u.array_buffer;\n    if (!abuf->shared) {\n        if (is_waitable == 2) {\n            JS_ThrowTypeError(ctx, \"not a SharedArrayBuffer TypedArray\");\n            return NULL;\n        }\n        if (abuf->detached) {\n            JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n            return NULL;\n        }\n    }\n    if (JS_ToIndex(ctx, &idx, idx_val)) {\n        return NULL;\n    }\n    /* if the array buffer is detached, p->u.array.count = 0 */\n    if (idx >= p->u.array.count) {\n        JS_ThrowRangeError(ctx, \"out-of-bound access\");\n        return NULL;\n    }\n    size_log2 = typed_array_size_log2(p->class_id);\n    ptr = p->u.array.u.uint8_ptr + ((uintptr_t)idx << size_log2);\n    if (pabuf)\n        *pabuf = abuf;\n    if (psize_log2)\n        *psize_log2 = size_log2;\n    if (pclass_id)\n        *pclass_id = p->class_id;\n    return ptr;\n}\n\nstatic JSValue js_atomics_op(JSContext *ctx,\n                             JSValueConst this_obj,\n                             int argc, JSValueConst *argv, int op)\n{\n    int size_log2;\n#ifdef CONFIG_BIGNUM\n    uint64_t v, a, rep_val;\n#else\n    uint32_t v, a, rep_val;\n#endif\n    void *ptr;\n    JSValue ret;\n    JSClassID class_id;\n    JSArrayBuffer *abuf;\n\n    ptr = js_atomics_get_ptr(ctx, &abuf, &size_log2, &class_id,\n                             argv[0], argv[1], 0);\n    if (!ptr)\n        return JS_EXCEPTION;\n    rep_val = 0;\n    if (op == ATOMICS_OP_LOAD) {\n        v = 0;\n    } else {\n#ifdef CONFIG_BIGNUM\n        if (size_log2 == 3) {\n            int64_t v64;\n            if (JS_ToBigInt64(ctx, &v64, argv[2]))\n                return JS_EXCEPTION;\n            v = v64;\n            if (op == ATOMICS_OP_COMPARE_EXCHANGE) {\n                if (JS_ToBigInt64(ctx, &v64, argv[3]))\n                    return JS_EXCEPTION;\n                rep_val = v64;\n            }\n        } else\n#endif\n        {\n                uint32_t v32;\n                if (JS_ToUint32(ctx, &v32, argv[2]))\n                    return JS_EXCEPTION;\n                v = v32;\n                if (op == ATOMICS_OP_COMPARE_EXCHANGE) {\n                    if (JS_ToUint32(ctx, &v32, argv[3]))\n                        return JS_EXCEPTION;\n                    rep_val = v32;\n                }\n        }\n        if (abuf->detached)\n            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n   }\n\n   switch(op | (size_log2 << 3)) {\n            \n#ifdef CONFIG_BIGNUM\n#define OP(op_name, func_name)                          \\\n    case ATOMICS_OP_ ## op_name | (0 << 3):             \\\n       a = func_name((_Atomic(uint8_t) *)ptr, v);       \\\n       break;                                           \\\n    case ATOMICS_OP_ ## op_name | (1 << 3):             \\\n        a = func_name((_Atomic(uint16_t) *)ptr, v);     \\\n        break;                                          \\\n    case ATOMICS_OP_ ## op_name | (2 << 3):             \\\n        a = func_name((_Atomic(uint32_t) *)ptr, v);     \\\n        break;                                          \\\n    case ATOMICS_OP_ ## op_name | (3 << 3):             \\\n        a = func_name((_Atomic(uint64_t) *)ptr, v);     \\\n        break;\n#else\n#define OP(op_name, func_name)                          \\\n    case ATOMICS_OP_ ## op_name | (0 << 3):             \\\n       a = func_name((_Atomic(uint8_t) *)ptr, v);       \\\n       break;                                           \\\n    case ATOMICS_OP_ ## op_name | (1 << 3):             \\\n        a = func_name((_Atomic(uint16_t) *)ptr, v);     \\\n        break;                                          \\\n    case ATOMICS_OP_ ## op_name | (2 << 3):             \\\n        a = func_name((_Atomic(uint32_t) *)ptr, v);     \\\n        break;\n#endif\n        OP(ADD, atomic_fetch_add)\n        OP(AND, atomic_fetch_and)\n        OP(OR, atomic_fetch_or)\n        OP(SUB, atomic_fetch_sub)\n        OP(XOR, atomic_fetch_xor)\n        OP(EXCHANGE, atomic_exchange)\n#undef OP\n\n    case ATOMICS_OP_LOAD | (0 << 3):\n        a = atomic_load((_Atomic(uint8_t) *)ptr);\n        break;\n    case ATOMICS_OP_LOAD | (1 << 3):\n        a = atomic_load((_Atomic(uint16_t) *)ptr);\n        break;\n    case ATOMICS_OP_LOAD | (2 << 3):\n        a = atomic_load((_Atomic(uint32_t) *)ptr);\n        break;\n#ifdef CONFIG_BIGNUM\n    case ATOMICS_OP_LOAD | (3 << 3):\n        a = atomic_load((_Atomic(uint64_t) *)ptr);\n        break;\n#endif\n        \n    case ATOMICS_OP_COMPARE_EXCHANGE | (0 << 3):\n        {\n            uint8_t v1 = v;\n            atomic_compare_exchange_strong((_Atomic(uint8_t) *)ptr, &v1, rep_val);\n            a = v1;\n        }\n        break;\n    case ATOMICS_OP_COMPARE_EXCHANGE | (1 << 3):\n        {\n            uint16_t v1 = v;\n            atomic_compare_exchange_strong((_Atomic(uint16_t) *)ptr, &v1, rep_val);\n            a = v1;\n        }\n        break;\n    case ATOMICS_OP_COMPARE_EXCHANGE | (2 << 3):\n        {\n            uint32_t v1 = v;\n            atomic_compare_exchange_strong((_Atomic(uint32_t) *)ptr, &v1, rep_val);\n            a = v1;\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case ATOMICS_OP_COMPARE_EXCHANGE | (3 << 3):\n        {\n            uint64_t v1 = v;\n            atomic_compare_exchange_strong((_Atomic(uint64_t) *)ptr, &v1, rep_val);\n            a = v1;\n        }\n        break;\n#endif\n    default:\n        abort();\n    }\n\n    switch(class_id) {\n    case JS_CLASS_INT8_ARRAY:\n        a = (int8_t)a;\n        goto done;\n    case JS_CLASS_UINT8_ARRAY:\n        a = (uint8_t)a;\n        goto done;\n    case JS_CLASS_INT16_ARRAY:\n        a = (int16_t)a;\n        goto done;\n    case JS_CLASS_UINT16_ARRAY:\n        a = (uint16_t)a;\n        goto done;\n    case JS_CLASS_INT32_ARRAY:\n    done:\n        ret = JS_NewInt32(ctx, a);\n        break;\n    case JS_CLASS_UINT32_ARRAY:\n        ret = JS_NewUint32(ctx, a);\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_CLASS_BIG_INT64_ARRAY:\n        ret = JS_NewBigInt64(ctx, a);\n        break;\n    case JS_CLASS_BIG_UINT64_ARRAY:\n        ret = JS_NewBigUint64(ctx, a);\n        break;\n#endif\n    default:\n        abort();\n    }\n    return ret;\n}\n\nstatic JSValue js_atomics_store(JSContext *ctx,\n                                JSValueConst this_obj,\n                                int argc, JSValueConst *argv)\n{\n    int size_log2;\n    void *ptr;\n    JSValue ret;\n    JSArrayBuffer *abuf;\n\n    ptr = js_atomics_get_ptr(ctx, &abuf, &size_log2, NULL,\n                             argv[0], argv[1], 0);\n    if (!ptr)\n        return JS_EXCEPTION;\n#ifdef CONFIG_BIGNUM\n    if (size_log2 == 3) {\n        int64_t v64;\n        ret = JS_ToBigIntValueFree(ctx, JS_DupValue(ctx, argv[2]));\n        if (JS_IsException(ret))\n            return ret;\n        if (JS_ToBigInt64(ctx, &v64, ret)) {\n            JS_FreeValue(ctx, ret);\n            return JS_EXCEPTION;\n        }\n        if (abuf->detached)\n            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n        atomic_store((_Atomic(uint64_t) *)ptr, v64);\n    } else\n#endif\n    {\n        uint32_t v;\n        /* XXX: spec, would be simpler to return the written value */\n        ret = JS_ToIntegerFree(ctx, JS_DupValue(ctx, argv[2]));\n        if (JS_IsException(ret))\n            return ret;\n        if (JS_ToUint32(ctx, &v, ret)) {\n            JS_FreeValue(ctx, ret);\n            return JS_EXCEPTION;\n        }\n        if (abuf->detached)\n            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n        switch(size_log2) {\n        case 0:\n            atomic_store((_Atomic(uint8_t) *)ptr, v);\n            break;\n        case 1:\n            atomic_store((_Atomic(uint16_t) *)ptr, v);\n            break;\n        case 2:\n            atomic_store((_Atomic(uint32_t) *)ptr, v);\n            break;\n        default:\n            abort();\n        }\n    }\n    return ret;\n}\n\nstatic JSValue js_atomics_isLockFree(JSContext *ctx,\n                                     JSValueConst this_obj,\n                                     int argc, JSValueConst *argv)\n{\n    int v, ret;\n    if (JS_ToInt32Sat(ctx, &v, argv[0]))\n        return JS_EXCEPTION;\n    ret = (v == 1 || v == 2 || v == 4\n#ifdef CONFIG_BIGNUM\n           || v == 8\n#endif\n           );\n    return JS_NewBool(ctx, ret);\n}\n\ntypedef struct JSAtomicsWaiter {\n    struct list_head link;\n    BOOL linked;\n    pthread_cond_t cond;\n    int32_t *ptr;\n} JSAtomicsWaiter;\n\nstatic pthread_mutex_t js_atomics_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic struct list_head js_atomics_waiter_list =\n    LIST_HEAD_INIT(js_atomics_waiter_list);\n\nstatic JSValue js_atomics_wait(JSContext *ctx,\n                               JSValueConst this_obj,\n                               int argc, JSValueConst *argv)\n{\n    int64_t v;\n    int32_t v32;\n    void *ptr;\n    int64_t timeout;\n    struct timespec ts;\n    JSAtomicsWaiter waiter_s, *waiter;\n    int ret, size_log2, res;\n    double d;\n\n    ptr = js_atomics_get_ptr(ctx, NULL, &size_log2, NULL,\n                             argv[0], argv[1], 2);\n    if (!ptr)\n        return JS_EXCEPTION;\n#ifdef CONFIG_BIGNUM\n    if (size_log2 == 3) {\n        if (JS_ToBigInt64(ctx, &v, argv[2]))\n            return JS_EXCEPTION;\n    } else\n#endif\n    {        \n        if (JS_ToInt32(ctx, &v32, argv[2]))\n            return JS_EXCEPTION;\n        v = v32;\n    }\n    if (JS_ToFloat64(ctx, &d, argv[3]))\n        return JS_EXCEPTION;\n    if (isnan(d) || d > INT64_MAX)\n        timeout = INT64_MAX;\n    else if (d < 0)\n        timeout = 0;\n    else\n        timeout = (int64_t)d;\n    if (!ctx->rt->can_block)\n        return JS_ThrowTypeError(ctx, \"cannot block in this thread\");\n\n    /* XXX: inefficient if large number of waiters, should hash on\n       'ptr' value */\n    /* XXX: use Linux futexes when available ? */\n    pthread_mutex_lock(&js_atomics_mutex);\n    if (size_log2 == 3) {\n        res = *(int64_t *)ptr != v;\n    } else {\n        res = *(int32_t *)ptr != v;\n    }\n    if (res) {\n        pthread_mutex_unlock(&js_atomics_mutex);\n        return JS_AtomToString(ctx, JS_ATOM_not_equal);\n    }\n\n    waiter = &waiter_s;\n    waiter->ptr = ptr;\n    pthread_cond_init(&waiter->cond, NULL);\n    waiter->linked = TRUE;\n    list_add_tail(&waiter->link, &js_atomics_waiter_list);\n\n    if (timeout == INT64_MAX) {\n        pthread_cond_wait(&waiter->cond, &js_atomics_mutex);\n        ret = 0;\n    } else {\n        /* XXX: use clock monotonic */\n        clock_gettime(CLOCK_REALTIME, &ts);\n        ts.tv_sec += timeout / 1000;\n        ts.tv_nsec += (timeout % 1000) * 1000000;\n        if (ts.tv_nsec >= 1000000000) {\n            ts.tv_nsec -= 1000000000;\n            ts.tv_sec++;\n        }\n        ret = pthread_cond_timedwait(&waiter->cond, &js_atomics_mutex,\n                                     &ts);\n    }\n    if (waiter->linked)\n        list_del(&waiter->link);\n    pthread_mutex_unlock(&js_atomics_mutex);\n    pthread_cond_destroy(&waiter->cond);\n    if (ret == ETIMEDOUT) {\n        return JS_AtomToString(ctx, JS_ATOM_timed_out);\n    } else {\n        return JS_AtomToString(ctx, JS_ATOM_ok);\n    }\n}\n\nstatic JSValue js_atomics_notify(JSContext *ctx,\n                                 JSValueConst this_obj,\n                                 int argc, JSValueConst *argv)\n{\n    struct list_head *el, *el1, waiter_list;\n    int32_t count, n;\n    void *ptr;\n    JSAtomicsWaiter *waiter;\n    JSArrayBuffer *abuf;\n\n    ptr = js_atomics_get_ptr(ctx, &abuf, NULL, NULL, argv[0], argv[1], 1);\n    if (!ptr)\n        return JS_EXCEPTION;\n\n    if (JS_IsUndefined(argv[2])) {\n        count = INT32_MAX;\n    } else {\n        if (JS_ToInt32Clamp(ctx, &count, argv[2], 0, INT32_MAX, 0))\n            return JS_EXCEPTION;\n    }\n    if (abuf->detached)\n        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);\n\n    n = 0;\n    if (abuf->shared && count > 0) {\n        pthread_mutex_lock(&js_atomics_mutex);\n        init_list_head(&waiter_list);\n        list_for_each_safe(el, el1, &js_atomics_waiter_list) {\n            waiter = list_entry(el, JSAtomicsWaiter, link);\n            if (waiter->ptr == ptr) {\n                list_del(&waiter->link);\n                waiter->linked = FALSE;\n                list_add_tail(&waiter->link, &waiter_list);\n                n++;\n                if (n >= count)\n                    break;\n            }\n        }\n        list_for_each(el, &waiter_list) {\n            waiter = list_entry(el, JSAtomicsWaiter, link);\n            pthread_cond_signal(&waiter->cond);\n        }\n        pthread_mutex_unlock(&js_atomics_mutex);\n    }\n    return JS_NewInt32(ctx, n);\n}\n\nstatic const JSCFunctionListEntry js_atomics_funcs[] = {\n    JS_CFUNC_MAGIC_DEF(\"add\", 3, js_atomics_op, ATOMICS_OP_ADD ),\n    JS_CFUNC_MAGIC_DEF(\"and\", 3, js_atomics_op, ATOMICS_OP_AND ),\n    JS_CFUNC_MAGIC_DEF(\"or\", 3, js_atomics_op, ATOMICS_OP_OR ),\n    JS_CFUNC_MAGIC_DEF(\"sub\", 3, js_atomics_op, ATOMICS_OP_SUB ),\n    JS_CFUNC_MAGIC_DEF(\"xor\", 3, js_atomics_op, ATOMICS_OP_XOR ),\n    JS_CFUNC_MAGIC_DEF(\"exchange\", 3, js_atomics_op, ATOMICS_OP_EXCHANGE ),\n    JS_CFUNC_MAGIC_DEF(\"compareExchange\", 4, js_atomics_op, ATOMICS_OP_COMPARE_EXCHANGE ),\n    JS_CFUNC_MAGIC_DEF(\"load\", 2, js_atomics_op, ATOMICS_OP_LOAD ),\n    JS_CFUNC_DEF(\"store\", 3, js_atomics_store ),\n    JS_CFUNC_DEF(\"isLockFree\", 1, js_atomics_isLockFree ),\n    JS_CFUNC_DEF(\"wait\", 4, js_atomics_wait ),\n    JS_CFUNC_DEF(\"notify\", 3, js_atomics_notify ),\n    JS_PROP_STRING_DEF(\"[Symbol.toStringTag]\", \"Atomics\", JS_PROP_CONFIGURABLE ),\n};\n\nstatic const JSCFunctionListEntry js_atomics_obj[] = {\n    JS_OBJECT_DEF(\"Atomics\", js_atomics_funcs, countof(js_atomics_funcs), JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE ),\n};\n\nvoid JS_AddIntrinsicAtomics(JSContext *ctx)\n{\n    /* add Atomics as autoinit object */\n    JS_SetPropertyFunctionList(ctx, ctx->global_obj, js_atomics_obj, countof(js_atomics_obj));\n}\n\n#endif /* CONFIG_ATOMICS */\n\nvoid JS_AddIntrinsicTypedArrays(JSContext *ctx)\n{\n    JSValue typed_array_base_proto, typed_array_base_func;\n    JSValueConst array_buffer_func, shared_array_buffer_func;\n    int i;\n\n    ctx->class_proto[JS_CLASS_ARRAY_BUFFER] = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ARRAY_BUFFER],\n                               js_array_buffer_proto_funcs,\n                               countof(js_array_buffer_proto_funcs));\n\n    array_buffer_func = JS_NewGlobalCConstructorOnly(ctx, \"ArrayBuffer\",\n                                                 js_array_buffer_constructor, 1,\n                                                 ctx->class_proto[JS_CLASS_ARRAY_BUFFER]);\n    JS_SetPropertyFunctionList(ctx, array_buffer_func,\n                               js_array_buffer_funcs,\n                               countof(js_array_buffer_funcs));\n\n    ctx->class_proto[JS_CLASS_SHARED_ARRAY_BUFFER] = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_SHARED_ARRAY_BUFFER],\n                               js_shared_array_buffer_proto_funcs,\n                               countof(js_shared_array_buffer_proto_funcs));\n\n    shared_array_buffer_func = JS_NewGlobalCConstructorOnly(ctx, \"SharedArrayBuffer\",\n                                                 js_shared_array_buffer_constructor, 1,\n                                                 ctx->class_proto[JS_CLASS_SHARED_ARRAY_BUFFER]);\n    JS_SetPropertyFunctionList(ctx, shared_array_buffer_func,\n                               js_shared_array_buffer_funcs,\n                               countof(js_shared_array_buffer_funcs));\n\n    typed_array_base_proto = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, typed_array_base_proto,\n                               js_typed_array_base_proto_funcs,\n                               countof(js_typed_array_base_proto_funcs));\n\n    /* TypedArray.prototype.toString must be the same object as Array.prototype.toString */\n    JSValue obj = JS_GetProperty(ctx, ctx->class_proto[JS_CLASS_ARRAY], JS_ATOM_toString);\n    /* XXX: should use alias method in JSCFunctionListEntry */ //@@@\n    JS_DefinePropertyValue(ctx, typed_array_base_proto, JS_ATOM_toString, obj,\n                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n\n    typed_array_base_func = JS_NewCFunction(ctx, js_typed_array_base_constructor,\n                                            \"TypedArray\", 0);\n    JS_SetPropertyFunctionList(ctx, typed_array_base_func,\n                               js_typed_array_base_funcs,\n                               countof(js_typed_array_base_funcs));\n    JS_SetConstructor(ctx, typed_array_base_func, typed_array_base_proto);\n\n    for(i = JS_CLASS_UINT8C_ARRAY; i < JS_CLASS_UINT8C_ARRAY + JS_TYPED_ARRAY_COUNT; i++) {\n        JSValue func_obj;\n        char buf[ATOM_GET_STR_BUF_SIZE];\n        const char *name;\n\n        ctx->class_proto[i] = JS_NewObjectProto(ctx, typed_array_base_proto);\n        JS_DefinePropertyValueStr(ctx, ctx->class_proto[i],\n                                  \"BYTES_PER_ELEMENT\",\n                                  JS_NewInt32(ctx, 1 << typed_array_size_log2(i)),\n                                  0);\n        name = JS_AtomGetStr(ctx, buf, sizeof(buf),\n                             JS_ATOM_Uint8ClampedArray + i - JS_CLASS_UINT8C_ARRAY);\n        func_obj = JS_NewCFunction3(ctx, (JSCFunction *)js_typed_array_constructor,\n                                    name, 3, JS_CFUNC_constructor_magic, i,\n                                    typed_array_base_func);\n        JS_NewGlobalCConstructor2(ctx, func_obj, name, ctx->class_proto[i]);\n        JS_DefinePropertyValueStr(ctx, func_obj,\n                                  \"BYTES_PER_ELEMENT\",\n                                  JS_NewInt32(ctx, 1 << typed_array_size_log2(i)),\n                                  0);\n    }\n    JS_FreeValue(ctx, typed_array_base_proto);\n    JS_FreeValue(ctx, typed_array_base_func);\n\n    /* DataView */\n    ctx->class_proto[JS_CLASS_DATAVIEW] = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_DATAVIEW],\n                               js_dataview_proto_funcs,\n                               countof(js_dataview_proto_funcs));\n    JS_NewGlobalCConstructorOnly(ctx, \"DataView\",\n                                 js_dataview_constructor, 1,\n                                 ctx->class_proto[JS_CLASS_DATAVIEW]);\n    /* Atomics */\n#ifdef CONFIG_ATOMICS\n    JS_AddIntrinsicAtomics(ctx);\n#endif\n}\n\nJSClassID JS_GetClassID(JSValue v) {\n    JSObject *p;\n\n    if (JS_VALUE_GET_TAG(v) != JS_TAG_OBJECT)\n        return 0;\n    p = JS_VALUE_GET_OBJ(v);\n    assert(p != 0);\n    return p->class_id;\n}\n\n#ifdef CONFIG_DEBUGGER\nJSDebuggerLocation js_debugger_current_location(JSContext *ctx, const uint8_t *cur_pc) {\n    JSDebuggerLocation location;\n    location.filename = 0;\n    JSStackFrame *sf = ctx->rt->current_stack_frame;\n    if (!sf)\n        return location;\n\n    JSObject *p = JS_VALUE_GET_OBJ(sf->cur_func);\n    if (!p)\n        return location;\n\n    JSFunctionBytecode *b = p->u.func.function_bytecode;\n    if (!b || !b->has_debug)\n        return location;\n\n    location.line = find_line_num(ctx, b, (cur_pc ? cur_pc : sf->cur_pc) - b->byte_code_buf - 1);\n    location.filename = b->debug.filename;\n    // quickjs has no column info.\n    location.column = 0;\n    return location;\n}\n\nJSDebuggerInfo *js_debugger_info(JSRuntime *rt) {\n    return &rt->debugger_info;\n}\n\nuint32_t js_debugger_stack_depth(JSContext *ctx) {\n    uint32_t stack_index = 0;\n    JSStackFrame *sf = ctx->rt->current_stack_frame;\n    while (sf != NULL) {\n        sf = sf->prev_frame;\n        stack_index++;\n    }\n    return stack_index;\n}\n\nJSValue js_debugger_build_backtrace(JSContext *ctx, const uint8_t *cur_pc)\n{\n    JSStackFrame *sf;\n    const char *func_name_str;\n    JSObject *p;\n    JSValue ret = JS_NewArray(ctx);\n    uint32_t stack_index = 0;\n\n    for(sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {\n        JSValue current_frame = JS_NewObject(ctx);\n\n        uint32_t id = stack_index++;\n        JS_SetPropertyStr(ctx, current_frame, \"id\", JS_NewUint32(ctx, id));\n\n        func_name_str = get_func_name(ctx, sf->cur_func);\n        if (!func_name_str || func_name_str[0] == '\\0')\n            JS_SetPropertyStr(ctx, current_frame, \"name\", JS_NewString(ctx, \"<anonymous>\"));\n        else\n            JS_SetPropertyStr(ctx, current_frame, \"name\", JS_NewString(ctx, func_name_str));\n        JS_FreeCString(ctx, func_name_str);\n\n        p = JS_VALUE_GET_OBJ(sf->cur_func);\n        if (p && js_class_has_bytecode(p->class_id)) {\n            JSFunctionBytecode *b;\n            int line_num1;\n\n            b = p->u.func.function_bytecode;\n            if (b->has_debug) {\n                const uint8_t *pc = sf != ctx->rt->current_stack_frame || !cur_pc ? sf->cur_pc : cur_pc;\n                line_num1 = find_line_num(ctx, b, pc - b->byte_code_buf - 1);\n                JS_SetPropertyStr(ctx, current_frame, \"filename\", JS_AtomToString(ctx, b->debug.filename));\n                if (line_num1 != -1)\n                    JS_SetPropertyStr(ctx, current_frame, \"line\", JS_NewUint32(ctx, line_num1));\n            }\n        } else {\n            JS_SetPropertyStr(ctx, current_frame, \"name\", JS_NewString(ctx, \"(native)\"));\n        }\n        JS_SetPropertyUint32(ctx, ret, id, current_frame);\n    }\n    return ret;\n}\n\nint js_debugger_check_breakpoint(JSContext *ctx, uint32_t current_dirty, const uint8_t *cur_pc) {\n    JSValue path_data = JS_UNDEFINED;\n    if (!ctx->rt->current_stack_frame)\n        return 0;\n    JSObject *f = JS_VALUE_GET_OBJ(ctx->rt->current_stack_frame->cur_func);\n    if (!f || !js_class_has_bytecode(f->class_id))\n        return 0;\n    JSFunctionBytecode *b = f->u.func.function_bytecode;\n    if (!b->has_debug || !b->debug.filename)\n        return 0;\n\n    // check if up to date\n    if (b->debugger.dirty == current_dirty)\n        goto done;\n\n    // note the dirty value and mark as up to date\n    uint32_t dirty = b->debugger.dirty;\n    b->debugger.dirty = current_dirty;\n\n    const char *filename = JS_AtomToCString(ctx, b->debug.filename);\n    path_data = js_debugger_file_breakpoints(ctx, filename);\n    JS_FreeCString(ctx, filename);\n    if (JS_IsUndefined(path_data))\n        goto done;\n\n    JSValue path_dirty_value = JS_GetPropertyStr(ctx, path_data, \"dirty\");\n    uint32_t path_dirty;\n    JS_ToUint32(ctx, &path_dirty, path_dirty_value);\n    JS_FreeValue(ctx, path_dirty_value);\n    // check the dirty value on this source file specifically\n    if (path_dirty == dirty)\n        goto done;\n\n    // todo: bit field?\n    // clear/alloc breakpoints\n    if (!b->debugger.breakpoints)\n        b->debugger.breakpoints = js_malloc_rt(ctx->rt, b->byte_code_len);\n    memset(b->debugger.breakpoints, 0, b->byte_code_len);\n\n    JSValue breakpoints = JS_GetPropertyStr(ctx, path_data, \"breakpoints\");\n\n    JSValue breakpoints_length_property = JS_GetPropertyStr(ctx, breakpoints, \"length\");\n    uint32_t breakpoints_length;\n    JS_ToUint32(ctx, &breakpoints_length, breakpoints_length_property);\n    JS_FreeValue(ctx, breakpoints_length_property);\n\n    const uint8_t *p_end, *p;\n    int new_line_num, line_num, pc, v, ret;\n    unsigned int op;\n\n    p = b->debug.pc2line_buf;\n    p_end = p + b->debug.pc2line_len;\n    pc = 0;\n    line_num = b->debug.line_num;\n\n    for (uint32_t i = 0; i < breakpoints_length; i++) {\n        JSValue breakpoint = JS_GetPropertyUint32(ctx, breakpoints, i);\n        JSValue breakpoint_line_prop = JS_GetPropertyStr(ctx, breakpoint, \"line\");\n        uint32_t breakpoint_line;\n        JS_ToUint32(ctx, &breakpoint_line, breakpoint_line_prop);\n        JS_FreeValue(ctx, breakpoint_line_prop);\n        JS_FreeValue(ctx, breakpoint);\n\n        // breakpoint is before the current line.\n        // todo: this may be an invalid breakpoint if it's inside the function, but got\n        // skipped over.\n        if (breakpoint_line < line_num)\n            continue;\n        // breakpoint is after function end. can stop, as breakpoints are in sorted order.\n        if (b->debugger.last_line_num && breakpoint_line > b->debugger.last_line_num)\n            break;\n\n        int last_line_num = line_num;\n        int line_pc = pc;\n\n        // scan until we find the start pc for the breakpoint\n        while (p < p_end && line_num <= breakpoint_line) {\n\n            // scan line by line\n            while (p < p_end && line_num == last_line_num) {\n                op = *p++;\n                if (op == 0) {\n                    uint32_t val;\n                    ret = get_leb128(&val, p, p_end);\n                    if (ret < 0)\n                        goto fail;\n                    pc += val;\n                    p += ret;\n                    ret = get_sleb128(&v, p, p_end);\n                    if (ret < 0)\n                        goto fail;\n                    p += ret;\n                    new_line_num = line_num + v;\n                } else {\n                    op -= PC2LINE_OP_FIRST;\n                    pc += (op / PC2LINE_RANGE);\n                    new_line_num = line_num + (op % PC2LINE_RANGE) + PC2LINE_BASE;\n                }\n                line_num = new_line_num;\n            }\n\n            if (line_num != last_line_num) {\n                // new line found, check if it is the one with breakpoint.\n                if (last_line_num == breakpoint_line && line_num > last_line_num)\n                    memset(b->debugger.breakpoints + line_pc, 1, pc - line_pc);\n\n                // update the line trackers\n                line_pc = pc;\n                last_line_num = line_num;\n            }\n        }\n\n        if (p >= p_end)\n            b->debugger.last_line_num = line_num;\n    }\n\nfail:\n    JS_FreeValue(ctx, breakpoints);\n\ndone:\n    JS_FreeValue(ctx, path_data);\n\n    if (!b->debugger.breakpoints)\n        return 0;\n\n    pc = (cur_pc ? cur_pc : ctx->rt->current_stack_frame->cur_pc) - b->byte_code_buf - 1;\n    if (pc < 0 || pc > b->byte_code_len)\n        return 0;\n    return b->debugger.breakpoints[pc];\n}\n\nJSValue js_debugger_local_variables(JSContext *ctx, int stack_index) {\n    JSValue ret = JS_NewObject(ctx);\n\n    // put exceptions on the top stack frame\n    if (stack_index == 0 && !JS_IsNull(ctx->rt->current_exception) && !JS_IsUndefined(ctx->rt->current_exception))\n        JS_SetPropertyStr(ctx, ret, \"<exception>\", JS_DupValue(ctx, ctx->rt->current_exception));\n\n    JSStackFrame *sf;\n    int cur_index = 0;\n\n    for(sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {\n        // this val is one frame up\n        if (cur_index == stack_index - 1) {\n            JSObject *f = JS_VALUE_GET_OBJ(sf->cur_func);\n            if (f && js_class_has_bytecode(f->class_id)) {\n                JSFunctionBytecode *b = f->u.func.function_bytecode;\n\n                JSValue this_obj = sf->var_buf[b->var_count];\n                // only provide a this if it is not the global object.\n                if (JS_VALUE_GET_OBJ(this_obj) != JS_VALUE_GET_OBJ(ctx->global_obj))\n                    JS_SetPropertyStr(ctx, ret, \"this\", JS_DupValue(ctx, this_obj));\n            }\n        }\n\n        if (cur_index < stack_index) {\n            cur_index++;\n            continue;\n        }\n\n        JSObject *f = JS_VALUE_GET_OBJ(sf->cur_func);\n        if (!f || !js_class_has_bytecode(f->class_id))\n            goto done;\n        JSFunctionBytecode *b = f->u.func.function_bytecode;\n\n        for (uint32_t i = 0; i < b->arg_count + b->var_count; i++) {\n            JSValue var_val;\n            if (i < b->arg_count)\n                var_val = sf->arg_buf[i];\n            else\n                var_val = sf->var_buf[i - b->arg_count];\n\n            if (JS_IsUninitialized(var_val))\n                continue;\n\n            JSVarDef *vd = b->vardefs + i;\n            JS_SetProperty(ctx, ret, vd->var_name, JS_DupValue(ctx, var_val));\n        }\n\n        break;\n    }\n\ndone:\n    return ret;\n}\n\nJSValue js_debugger_closure_variables(JSContext *ctx, int stack_index) {\n    JSValue ret = JS_NewObject(ctx);\n\n    JSStackFrame *sf;\n    int cur_index = 0;\n    for(sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {\n        if (cur_index < stack_index) {\n            cur_index++;\n            continue;\n        }\n\n        JSObject *f = JS_VALUE_GET_OBJ(sf->cur_func);\n        if (!f || !js_class_has_bytecode(f->class_id))\n            goto done;\n\n        JSFunctionBytecode *b = f->u.func.function_bytecode;\n\n        for (uint32_t i = 0; i < b->closure_var_count; i++) {\n            JSClosureVar *cvar = b->closure_var + i;\n            JSValue var_val;\n            JSVarRef *var_ref = NULL;\n            if (f->u.func.var_refs)\n                var_ref = f->u.func.var_refs[i];\n            if (!var_ref || !var_ref->pvalue)\n                continue;\n            var_val = *var_ref->pvalue;\n\n            if (JS_IsUninitialized(var_val))\n                continue;\n\n            JS_SetProperty(ctx, ret, cvar->var_name, JS_DupValue(ctx, var_val));\n        }\n\n        break;\n    }\n\ndone:\n    return ret;\n}\n\n/* debugger needs ability to eval at any stack frame */\nstatic JSValue js_debugger_eval(JSContext *ctx, JSValueConst this_obj, JSStackFrame *sf,\n                                 const char *input, size_t input_len,\n                                 const char *filename, int flags, int scope_idx)\n{\n    JSParseState s1, *s = &s1;\n    int err, js_mode;\n    JSValue fun_obj, ret_val;\n    JSVarRef **var_refs;\n    JSFunctionBytecode *b;\n    JSFunctionDef *fd;\n\n    js_parse_init(ctx, s, input, input_len, filename);\n    skip_shebang(s);\n\n    JSObject *p;\n    assert(sf != NULL);\n    assert(JS_VALUE_GET_TAG(sf->cur_func) == JS_TAG_OBJECT);\n    p = JS_VALUE_GET_OBJ(sf->cur_func);\n    assert(js_class_has_bytecode(p->class_id));\n    b = p->u.func.function_bytecode;\n    var_refs = p->u.func.var_refs;\n    js_mode = b->js_mode;\n\n    fd = js_new_function_def(ctx, NULL, TRUE, FALSE, filename, 1);\n    if (!fd)\n        goto fail1;\n    s->cur_func = fd;\n    fd->eval_type = JS_EVAL_TYPE_DIRECT;\n    fd->has_this_binding = 0;\n    fd->new_target_allowed = b->new_target_allowed;\n    fd->super_call_allowed = b->super_call_allowed;\n    fd->super_allowed = b->super_allowed;\n    fd->arguments_allowed = b->arguments_allowed;\n    fd->js_mode = js_mode;\n    fd->func_name = JS_DupAtom(ctx, JS_ATOM__eval_);\n    if (b) {\n        int idx;\n        if (!b->var_count)\n            idx = -1;\n        else\n            idx = (b->vardefs && b->vardefs[b->arg_count + scope_idx].scope_next != scope_idx) ? 0 : -1;\n        if (add_closure_variables(ctx, fd, b, idx))\n            goto fail;\n    }\n    fd->module = NULL;\n    s->is_module = 0;\n    s->allow_html_comments = !s->is_module;\n\n    push_scope(s); /* body scope */\n\n    err = js_parse_program(s);\n    if (err) {\nfail:\n        free_token(s, &s->token);\n        js_free_function_def(ctx, fd);\n        goto fail1;\n    }\n\n    /* create the function object and all the enclosed functions */\n    fun_obj = js_create_function(ctx, fd);\n    if (JS_IsException(fun_obj))\n        goto fail1;\n    if (flags & JS_EVAL_FLAG_COMPILE_ONLY) {\n        ret_val = fun_obj;\n    } else {\n        ret_val = JS_EvalFunctionInternal(ctx, fun_obj, this_obj, var_refs, sf);\n    }\n    return ret_val;\nfail1:\n    return JS_EXCEPTION;\n}\n\nJSValue js_debugger_evaluate(JSContext *ctx, int stack_index, JSValue expression) {\n    JSStackFrame *sf;\n    int cur_index = 0;\n\n    for(sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {\n        if (cur_index < stack_index) {\n            cur_index++;\n            continue;\n        }\n\n        JSObject *f = JS_VALUE_GET_OBJ(sf->cur_func);\n        if (!f || !js_class_has_bytecode(f->class_id))\n            return JS_UNDEFINED;\n        JSFunctionBytecode *b = f->u.func.function_bytecode;\n\n        int scope_idx = b->vardefs ? 0 : -1;\n        size_t len;\n        const char* str = JS_ToCStringLen(ctx, &len, expression);\n        JSValue ret = js_debugger_eval(ctx, sf->var_buf[b->var_count], sf, str, len, \"<debugger>\", JS_EVAL_TYPE_DIRECT, scope_idx);\n        JS_FreeCString(ctx, str);\n        return ret;\n    }\n    return JS_UNDEFINED;\n}\n#endif\n",
			"file": "/home/roman/Projects/plot-cv/quickjs/quickjs.c",
			"file_size": 1773395,
			"file_write_time": 132725311052797953,
			"settings":
			{
				"buffer_size": 1773399,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					4,
					1,
					"insert",
					{
						"characters": " \t"
					},
					"AgAAAF2FAQAAAAAAXoUBAAAAAAAAAAAAXoUBAAAAAABhhQEAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAXYUBAAAAAABdhQEAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "quickjs-inspect.c",
			"settings":
			{
				"buffer_size": 33486,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					62,
					1,
					"wrap_block",
					{
						"begin": "{",
						"end": "}"
					},
					"AgAAAMMOAAAAAAAAxA4AAAAAAAAAAAAA8A4AAAAAAAD0DgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAww4AAAAAAADDDgAAAAAAAAAAAAAAAPC/"
				],
				[
					65,
					1,
					"cut",
					null,
					"AQAAAPIOAAAAAAAA8g4AAAAAAAABAAAAfQ",
					"AQAAAAAAAAABAAAA8w4AAAAAAADyDgAAAAAAAAAAAAAAAPC/"
				],
				[
					66,
					2,
					"left_delete",
					null,
					"AgAAAPAOAAAAAAAA8A4AAAAAAAACAAAAICDvDgAAAAAAAO8OAAAAAAAAAQAAAAo",
					"AQAAAAAAAAABAAAA8g4AAAAAAADyDgAAAAAAAAAAAAAAAPC/"
				],
				[
					68,
					1,
					"insert",
					{
						"characters": "\nv"
					},
					"AwAAAAsPAAAAAAAADA8AAAAAAAAAAAAADA8AAAAAAAAODwAAAAAAAAAAAAAODwAAAAAAAA8PAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAACw8AAAAAAAALDwAAAAAAAAAAAAAAQHpA"
				],
				[
					69,
					1,
					"left_delete",
					null,
					"AQAAAA4PAAAAAAAADg8AAAAAAAABAAAAdg",
					"AQAAAAAAAAABAAAADw8AAAAAAAAPDwAAAAAAAAAAAAAAAPC/"
				],
				[
					70,
					1,
					"paste",
					null,
					"AQAAAA4PAAAAAAAADw8AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAADg8AAAAAAAAODwAAAAAAAAAAAAAAAPC/"
				],
				[
					73,
					1,
					"wrap_block",
					{
						"begin": "{",
						"end": "}"
					},
					"AgAAAAwOAAAAAAAADQ4AAAAAAAAAAAAAPA4AAAAAAABADgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAADA4AAAAAAAAMDgAAAAAAAP///////+9/"
				],
				[
					75,
					1,
					"left_delete",
					null,
					"AQAAADoOAAAAAAAAOg4AAAAAAAABAAAAOw",
					"AQAAAAAAAAABAAAAOw4AAAAAAAA7DgAAAAAAAAAAAAAAMIFA"
				],
				[
					76,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAADoOAAAAAAAAOw4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAOg4AAAAAAAA6DgAAAAAAAAAAAAAAAPC/"
				],
				[
					78,
					3,
					"left_delete",
					null,
					"AwAAAD4OAAAAAAAAPg4AAAAAAAABAAAAfTwOAAAAAAAAPA4AAAAAAAACAAAAICA7DgAAAAAAADsOAAAAAAAAAQAAAAo",
					"AQAAAAAAAAABAAAAPw4AAAAAAAA/DgAAAAAAAAAAAAAAIHxA"
				],
				[
					80,
					1,
					"insert",
					{
						"characters": "}"
					},
					"AQAAAFcOAAAAAAAAWA4AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAVw4AAAAAAABXDgAAAAAAAAAAAAAAIHxA"
				],
				[
					83,
					1,
					"wrap_block",
					{
						"begin": "{",
						"end": "}"
					},
					"AgAAAE8NAAAAAAAAUA0AAAAAAAAAAAAAgw0AAAAAAACHDQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAATw0AAAAAAABPDQAAAAAAAP///////+9/"
				],
				[
					84,
					1,
					"right_delete",
					null,
					"AQAAAFANAAAAAAAAUA0AAAAAAAABAAAACg",
					"AQAAAAAAAAABAAAAUA0AAAAAAABQDQAAAAAAAAAAAAAAAPC/"
				],
				[
					85,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAAFANAAAAAAAAUQ0AAAAAAAAAAAAAUQ0AAAAAAABTDQAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAUA0AAAAAAABQDQAAAAAAAAAAAAAAAPC/"
				],
				[
					87,
					3,
					"right_delete",
					null,
					"AwAAAIcNAAAAAAAAhw0AAAAAAAABAAAAfYcNAAAAAAAAhw0AAAAAAAABAAAACocNAAAAAAAAhw0AAAAAAAABAAAAIA",
					"AQAAAAAAAAABAAAAhw0AAAAAAACHDQAAAAAAAAAAAAAAADRA"
				],
				[
					89,
					1,
					"insert",
					{
						"characters": "}"
					},
					"AQAAAKENAAAAAAAAog0AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAoQ0AAAAAAAChDQAAAAAAAP///////+9/"
				],
				[
					91,
					1,
					"insert",
					{
						"characters": "}"
					},
					"AQAAAN0MAAAAAAAA3gwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA3QwAAAAAAADdDAAAAAAAAAAAAAAAIHJA"
				],
				[
					94,
					1,
					"wrap_block",
					{
						"begin": "{",
						"end": "}"
					},
					"AgAAAJEMAAAAAAAAkgwAAAAAAAAAAAAAwgwAAAAAAADGDAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAkQwAAAAAAACRDAAAAAAAAP///////+9/"
				],
				[
					96,
					3,
					"left_delete",
					null,
					"AwAAAMQMAAAAAAAAxAwAAAAAAAABAAAAfcIMAAAAAAAAwgwAAAAAAAACAAAAICDBDAAAAAAAAMEMAAAAAAAAAQAAAAo",
					"AQAAAAAAAAABAAAAxQwAAAAAAADFDAAAAAAAAAAAAAAAMIFA"
				],
				[
					99,
					1,
					"wrap_block",
					{
						"begin": "{",
						"end": "}"
					},
					"AgAAANsLAAAAAAAA3AsAAAAAAAAAAAAABwwAAAAAAAALDAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA2wsAAAAAAADbCwAAAAAAAP///////+9/"
				],
				[
					101,
					3,
					"left_delete",
					null,
					"AwAAAAkMAAAAAAAACQwAAAAAAAABAAAAfQcMAAAAAAAABwwAAAAAAAACAAAAICAGDAAAAAAAAAYMAAAAAAAAAQAAAAo",
					"AQAAAAAAAAABAAAACgwAAAAAAAAKDAAAAAAAAAAAAAAAMIFA"
				],
				[
					103,
					1,
					"insert",
					{
						"characters": "}"
					},
					"AQAAACMMAAAAAAAAJAwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAIwwAAAAAAAAjDAAAAAAAAAAAAAAAoHlA"
				],
				[
					104,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AQAAACQMAAAAAAAAJQwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAJAwAAAAAAAAkDAAAAAAAAAAAAAAAAPC/"
				],
				[
					108,
					1,
					"wrap_block",
					{
						"begin": "{",
						"end": "}"
					},
					"AgAAAJMPAAAAAAAAlA8AAAAAAAAAAAAAzQ8AAAAAAADRDwAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAkw8AAAAAAACTDwAAAAAAAAAAAAAAsINA"
				],
				[
					110,
					3,
					"left_delete",
					null,
					"AwAAAM8PAAAAAAAAzw8AAAAAAAABAAAAfc0PAAAAAAAAzQ8AAAAAAAACAAAAICDMDwAAAAAAAMwPAAAAAAAAAQAAAAo",
					"AQAAAAAAAAABAAAA0A8AAAAAAADQDwAAAAAAAAAAAAAAMIFA"
				],
				[
					112,
					1,
					"insert",
					{
						"characters": "\n}"
					},
					"BQAAAOgPAAAAAAAA6Q8AAAAAAAAAAAAA6Q8AAAAAAADrDwAAAAAAAAAAAADrDwAAAAAAAOwPAAAAAAAAAAAAAOkPAAAAAAAA6Q8AAAAAAAACAAAAICDpDwAAAAAAAOkPAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA6A8AAAAAAADoDwAAAAAAAAAAAAAAMIFA"
				],
				[
					122,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAACzggAAI2lmbmRlZiBfR05VX1NPVVJDRQojZGVmaW5lIF9HTlVfU09VUkNFCiNlbmRpZgoKI2luY2x1ZGUgImN1dGlscy5oIgojaW5jbHVkZSAiaXRlcmF0aW9uLmgiCiNpbmNsdWRlICJsaXN0LmgiCiNpbmNsdWRlICJwcm9wZXJ0eS1lbnVtZXJhdGlvbi5oIgojaW5jbHVkZSAicXVpY2tqcy1pbnRlcm5hbC5oIgojaW5jbHVkZSAicXVpY2tqcy5oIgojaW5jbHVkZSAidXRpbHMuaCIKI2luY2x1ZGUgInZlY3Rvci5oIgojaW5jbHVkZSAiYnVmZmVyLXV0aWxzLmgiCgojaW5jbHVkZSA8Y3R5cGUuaD4KI2luY2x1ZGUgPG1hdGguaD4KI2luY2x1ZGUgPHN0cmluZy5oPgojaW5jbHVkZSA8c3lzL2lvY3RsLmg+CiNpbmNsdWRlIDx0ZXJtaW9zLmg+Cgp0aHJlYWRfbG9jYWwgSlNBdG9tIGluc3BlY3RfY3VzdG9tX2F0b20gPSAwLCBpbnNwZWN0X2N1c3RvbV9hdG9tX25vZGUgPSAwOwoKI2RlZmluZSBJTlNQRUNUX0lOVDMyVF9JTlJBTkdFKGkpICgoaSkgPiBJTlQzMl9NSU4gJiYgKGkpIDwgSU5UMzJfTUFYKQojZGVmaW5lIElOU1BFQ1RfTEVWRUwob3B0cykgKChvcHRzKS0+ZGVwdGggLSAoZGVwdGgpKQojZGVmaW5lIElOU1BFQ1RfSVNfQ09NUEFDVChvcHRzKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKICAoKG9wdHMpLT5jb21wYWN0ID09IElOVDMyX01BWCA/IFRSVUUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCiAgIDogSU5TUEVDVF9JTlQzMlRfSU5SQU5HRSgob3B0cyktPmNvbXBhY3QpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAogICAgICAgPyAoKG9wdHMpLT5jb21wYWN0IDwgMCA/IElOU1BFQ1RfTEVWRUwob3B0cykgPj0gLShvcHRzLT5jb21wYWN0KSA6IElOU1BFQ1RfTEVWRUwob3B0cykgPj0gKG9wdHMpLT5jb21wYWN0KSAgICAgIFwKICAgICAgIDogMCkKCnR5cGVkZWYgc3RydWN0IHsKICBpbnQgY29sb3JzIDogMTsKICBpbnQgc2hvd19oaWRkZW4gOiAxOwogIGludCBjdXN0b21faW5zcGVjdCA6IDE7CiAgaW50IHNob3dfcHJveHkgOiAxOwogIGludCBnZXR0ZXJzIDogMTsKICBpbnQgc3RyaW5nX2JyZWFrX25ld2xpbmUgOiAxOwogIGludDMyX3QgZGVwdGg7CiAgaW50MzJfdCBtYXhfYXJyYXlfbGVuZ3RoOwogIGludDMyX3QgbWF4X3N0cmluZ19sZW5ndGg7CiAgaW50MzJfdCBicmVha19sZW5ndGg7CiAgaW50MzJfdCBjb21wYWN0OwogIGludDMyX3QgcHJvdG9fY2hhaW47CiAgaW50MzJfdCBudW1iZXJfYmFzZTsKICBWZWN0b3IgaGlkZV9rZXlzOwp9IGluc3BlY3Rfb3B0aW9uc190OwoKc3RydWN0IHByb3Bfa2V5OwoKdHlwZWRlZiBzdHJ1Y3QgcHJvcF9rZXkgewogIHN0cnVjdCBsaXN0X2hlYWQgbGluazsKICBjb25zdCBjaGFyKiBuYW1lOwogIEpTQXRvbSBhdG9tOwp9IHByb3Bfa2V5X3Q7CgpzdGF0aWMgaW50IGpzX2luc3BlY3RfcHJpbnQoSlNDb250ZXh0KiBjdHgsIER5bkJ1ZiogYnVmLCBKU1ZhbHVlQ29uc3QgdmFsdWUsIGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBpbnQzMl90IGRlcHRoKTsKCnN0YXRpYyBpbnQKcmVnZXhwX3ByZWRpY2F0ZShpbnQgYykgewogIHN3aXRjaChjKSB7CiAgICBjYXNlIDg6IHJldHVybiAndSc7CiAgICBjYXNlIDEyOiByZXR1cm4gJ2YnOwogICAgY2FzZSAxMDogcmV0dXJuICduJzsKICAgIGNhc2UgMTM6IHJldHVybiAncic7CiAgICBjYXNlIDk6IHJldHVybiAndCc7CiAgICBjYXNlIDExOiByZXR1cm4gJ3YnOwogIH0KICBpZihjIDwgMHgyMCkKICAgIHJldHVybiAndSc7CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbmxpbmUgaW50Cmluc3BlY3Rfc2NyZWVuX3dpZHRoKHZvaWQpIHsKICBzdHJ1Y3Qgd2luc2l6ZSB3ID0gey53c19jb2wgPSAtMSwgLndzX3JvdyA9IC0xfTsKICBpb2N0bCgxLCBUSU9DR1dJTlNaLCAmdyk7CiAgcmV0dXJuIHcud3NfY29sOwp9CgpzdGF0aWMgdm9pZAppbnNwZWN0X29wdGlvbnNfaW5pdChpbnNwZWN0X29wdGlvbnNfdCogb3B0cywgSlNDb250ZXh0KiBjdHgpIHsKICBvcHRzLT5jb2xvcnMgPSBUUlVFOwogIG9wdHMtPnNob3dfaGlkZGVuID0gRkFMU0U7CiAgb3B0cy0+Y3VzdG9tX2luc3BlY3QgPSBUUlVFOwogIG9wdHMtPnNob3dfcHJveHkgPSBGQUxTRTsKICBvcHRzLT5nZXR0ZXJzID0gRkFMU0U7CiAgb3B0cy0+c3RyaW5nX2JyZWFrX25ld2xpbmUgPSBGQUxTRTsKICBvcHRzLT5kZXB0aCA9IElOVDMyX01BWDsKICBvcHRzLT5tYXhfYXJyYXlfbGVuZ3RoID0gMzAwOwogIG9wdHMtPm1heF9zdHJpbmdfbGVuZ3RoID0gSU5UMzJfTUFYOwogIG9wdHMtPmJyZWFrX2xlbmd0aCA9IGluc3BlY3Rfc2NyZWVuX3dpZHRoKCk7CiAgb3B0cy0+Y29tcGFjdCA9IDU7CiAgb3B0cy0+cHJvdG9fY2hhaW4gPSAwOwogIG9wdHMtPm51bWJlcl9iYXNlID0gMTA7CiAgdmVjdG9yX2luaXQoJm9wdHMtPmhpZGVfa2V5cywgY3R4KTsKfQoKc3RhdGljIHZvaWQKaW5zcGVjdF9vcHRpb25zX2ZyZWUoaW5zcGVjdF9vcHRpb25zX3QqIG9wdHMsIEpTQ29udGV4dCogY3R4KSB7CgogIHByb3Bfa2V5X3QqIGtleTsKCiAgdmVjdG9yX2ZvcmVhY2hfdCgmb3B0cy0+aGlkZV9rZXlzLCBrZXkpIHsKICAgIEpTX0ZyZWVBdG9tKGN0eCwga2V5LT5hdG9tKTsKICAgIGpzX2NzdHJpbmdfZnJlZShjdHgsIGtleS0+bmFtZSk7CiAgfQogIHZlY3Rvcl9mcmVlKCZvcHRzLT5oaWRlX2tleXMpOwp9CgpzdGF0aWMgdm9pZAppbnNwZWN0X29wdGlvbnNfZ2V0KGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iamVjdCkgewogIEpTVmFsdWUgdmFsdWU7CiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iamVjdCwgImNvbG9ycyIpOwogIGlmKCFKU19Jc0V4Y2VwdGlvbih2YWx1ZSkgJiYgIUpTX0lzVW5kZWZpbmVkKHZhbHVlKSl7CiAgICBvcHRzLT5jb2xvcnMgPSBKU19Ub0Jvb2woY3R4LCB2YWx1ZSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwp9CgogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJzaG93SGlkZGVuIik7CiAgaWYoIUpTX0lzRXhjZXB0aW9uKHZhbHVlKSAmJiAhSlNfSXNVbmRlZmluZWQodmFsdWUpKXsKICAgIG9wdHMtPnNob3dfaGlkZGVuID0gSlNfVG9Cb29sKGN0eCwgdmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKfQogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJjdXN0b21JbnNwZWN0Iik7CiAgaWYoIUpTX0lzRXhjZXB0aW9uKHZhbHVlKSAmJiAhSlNfSXNVbmRlZmluZWQodmFsdWUpKXsKICAgICAgb3B0cy0+Y3VzdG9tX2luc3BlY3QgPSBKU19Ub0Jvb2woY3R4LCB2YWx1ZSk7CiAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTt9CgogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJzaG93UHJveHkiKTsKICBpZighSlNfSXNFeGNlcHRpb24odmFsdWUpICYmICFKU19Jc1VuZGVmaW5lZCh2YWx1ZSkpewogICAgb3B0cy0+c2hvd19wcm94eSA9IEpTX1RvQm9vbChjdHgsIHZhbHVlKTsKICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7fQoKICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqZWN0LCAiZ2V0dGVycyIpOwogIGlmKCFKU19Jc0V4Y2VwdGlvbih2YWx1ZSkgJiYgIUpTX0lzVW5kZWZpbmVkKHZhbHVlKSl7CiAgICBvcHRzLT5nZXR0ZXJzID0gSlNfVG9Cb29sKGN0eCwgdmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICB9CgogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJzdHJpbmdCcmVha05ld2xpbmUiKTsKICBpZighSlNfSXNFeGNlcHRpb24odmFsdWUpICYmICFKU19Jc1VuZGVmaW5lZCh2YWx1ZSkpewogICAgb3B0cy0+c3RyaW5nX2JyZWFrX25ld2xpbmUgPSBKU19Ub0Jvb2woY3R4LCB2YWx1ZSk7CiAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwp9CgogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJkZXB0aCIpOwogIGlmKCFKU19Jc1VuZGVmaW5lZCh2YWx1ZSkgJiYgIUpTX0lzRXhjZXB0aW9uKHZhbHVlKSkgewogICAgaWYoSlNfVkFMVUVfR0VUX1RBRyh2YWx1ZSkgPT0gSlNfVEFHX0ZMT0FUNjQgJiYgaXNpbmYoSlNfVkFMVUVfR0VUX0ZMT0FUNjQodmFsdWUpKSkKICAgICAgb3B0cy0+ZGVwdGggPSBJTlQzMl9NQVg7CiAgICBlbHNlCiAgICAgIEpTX1RvSW50MzIoY3R4LCAmb3B0cy0+ZGVwdGgsIHZhbHVlKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICB9CiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iamVjdCwgIm1heEFycmF5TGVuZ3RoIik7CiAgaWYoIUpTX0lzVW5kZWZpbmVkKHZhbHVlKSAmJiAhSlNfSXNFeGNlcHRpb24odmFsdWUpKSB7CiAgICBpZihKU19WQUxVRV9HRVRfVEFHKHZhbHVlKSA9PSBKU19UQUdfRkxPQVQ2NCAmJiBpc2luZihKU19WQUxVRV9HRVRfRkxPQVQ2NCh2YWx1ZSkpKQogICAgICBvcHRzLT5tYXhfYXJyYXlfbGVuZ3RoID0gSU5UMzJfTUFYOwogICAgZWxzZQogICAgICBKU19Ub0ludDMyKGN0eCwgJm9wdHMtPm1heF9hcnJheV9sZW5ndGgsIHZhbHVlKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICB9CiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iamVjdCwgIm1heFN0cmluZ0xlbmd0aCIpOwogIGlmKCFKU19Jc1VuZGVmaW5lZCh2YWx1ZSkgJiYgIUpTX0lzRXhjZXB0aW9uKHZhbHVlKSkgewogICAgaWYoSlNfVkFMVUVfR0VUX1RBRyh2YWx1ZSkgPT0gSlNfVEFHX0ZMT0FUNjQgJiYgaXNpbmYoSlNfVkFMVUVfR0VUX0ZMT0FUNjQodmFsdWUpKSkKICAgICAgb3B0cy0+bWF4X3N0cmluZ19sZW5ndGggPSBJTlQzMl9NQVg7CiAgICBlbHNlCiAgICAgIEpTX1RvSW50MzIoY3R4LCAmb3B0cy0+bWF4X3N0cmluZ19sZW5ndGgsIHZhbHVlKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICB9CiAgdmFsdWUgPSBKU19HZXRQcm9wZXJ0eVN0cihjdHgsIG9iamVjdCwgImJyZWFrTGVuZ3RoIik7CiAgaWYoIUpTX0lzVW5kZWZpbmVkKHZhbHVlKSAmJiAhSlNfSXNFeGNlcHRpb24odmFsdWUpKSB7CiAgICBpZihKU19WQUxVRV9HRVRfVEFHKHZhbHVlKSA9PSBKU19UQUdfRkxPQVQ2NCAmJiBpc2luZihKU19WQUxVRV9HRVRfRkxPQVQ2NCh2YWx1ZSkpKQogICAgICBvcHRzLT5icmVha19sZW5ndGggPSBJTlQzMl9NQVg7CiAgICBlbHNlCiAgICAgIEpTX1RvSW50MzIoY3R4LCAmb3B0cy0+YnJlYWtfbGVuZ3RoLCB2YWx1ZSk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgfQogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJjb21wYWN0Iik7CiAgaWYoIUpTX0lzVW5kZWZpbmVkKHZhbHVlKSAmJiAhSlNfSXNFeGNlcHRpb24odmFsdWUpKSB7CiAgICBpZihKU19WQUxVRV9HRVRfVEFHKHZhbHVlKSA9PSBKU19UQUdfQk9PTCAmJiBKU19WQUxVRV9HRVRfQk9PTCh2YWx1ZSkgPT0gMCkKICAgICAgb3B0cy0+Y29tcGFjdCA9IElOVDMyX01JTjsKICAgIGVsc2UgaWYoSlNfVkFMVUVfR0VUX1RBRyh2YWx1ZSkgPT0gSlNfVEFHX0ZMT0FUNjQgJiYgaXNpbmYoSlNfVkFMVUVfR0VUX0ZMT0FUNjQodmFsdWUpKSkKICAgICAgb3B0cy0+Y29tcGFjdCA9IElOVDMyX01BWDsKICAgIGVsc2UKICAgICAgSlNfVG9JbnQzMihjdHgsICZvcHRzLT5jb21wYWN0LCB2YWx1ZSk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgfQogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJoaWRlS2V5cyIpOwogIGlmKEpTX0lzQXJyYXkoY3R4LCB2YWx1ZSkpIHsKICAgIGludDY0X3QgbGVuLCBwb3M7CiAgICBsZW4gPSBqc19hcnJheV9sZW5ndGgoY3R4LCB2YWx1ZSk7CgogICAgZm9yKHBvcyA9IDA7IHBvcyA8IGxlbjsgcG9zKyspIHsKICAgICAgSlNWYWx1ZSBpdGVtID0gSlNfR2V0UHJvcGVydHlVaW50MzIoY3R4LCB2YWx1ZSwgcG9zKTsKICAgICAgcHJvcF9rZXlfdCBrZXk7CiAgICAgIGtleS5uYW1lID0gSlNfVkFMVUVfR0VUX1RBRyhpdGVtKSA9PSBKU19UQUdfU1lNQk9MID8gMCA6IEpTX1RvQ1N0cmluZyhjdHgsIGl0ZW0pOwogICAgICBrZXkuYXRvbSA9IEpTX1ZhbHVlVG9BdG9tKGN0eCwgaXRlbSk7CiAgICAgIHZlY3Rvcl9wdXNoKCZvcHRzLT5oaWRlX2tleXMsIGtleSk7CiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGl0ZW0pOwogICAgfQogICAgSlNfRnJlZVZhbHVlKGN0eCwgdmFsdWUpOwogIH0KICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgb2JqZWN0LCAicHJvdG9DaGFpbiIpOwogIGlmKEpTX0lzTnVtYmVyKHZhbHVlKSkKICAgIEpTX1RvSW50MzIoY3R4LCAmb3B0cy0+cHJvdG9fY2hhaW4sIHZhbHVlKTsKICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CgogIHZhbHVlID0gSlNfR2V0UHJvcGVydHlTdHIoY3R4LCBvYmplY3QsICJudW1iZXJCYXNlIik7CiAgaWYoSlNfSXNOdW1iZXIodmFsdWUpKQogICAgSlNfVG9JbnQzMihjdHgsICZvcHRzLT5udW1iZXJfYmFzZSwgdmFsdWUpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKfQoKc3RhdGljIEpTVmFsdWUKaW5zcGVjdF9vcHRpb25zX29iamVjdChpbnNwZWN0X29wdGlvbnNfdCogb3B0cywgSlNDb250ZXh0KiBjdHgpIHsKICBKU1ZhbHVlIGFyciwgcmV0ID0gSlNfTmV3T2JqZWN0KGN0eCk7CiAgdWludDMyX3QgbjsKICBwcm9wX2tleV90KiBrZXk7CgogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAiY29sb3JzIiwgSlNfTmV3Qm9vbChjdHgsIG9wdHMtPmNvbG9ycykpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAic2hvd0hpZGRlbiIsIEpTX05ld0Jvb2woY3R4LCBvcHRzLT5zaG93X2hpZGRlbikpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAiY3VzdG9tSW5zcGVjdCIsIEpTX05ld0Jvb2woY3R4LCBvcHRzLT5jdXN0b21faW5zcGVjdCkpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAic2hvd1Byb3h5IiwgSlNfTmV3Qm9vbChjdHgsIG9wdHMtPnNob3dfcHJveHkpKTsKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgImdldHRlcnMiLCBKU19OZXdCb29sKGN0eCwgb3B0cy0+Z2V0dGVycykpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAic3RyaW5nQnJlYWtOZXdsaW5lIiwgSlNfTmV3Qm9vbChjdHgsIG9wdHMtPnN0cmluZ19icmVha19uZXdsaW5lKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJkZXB0aCIsIGpzX251bWJlcl9uZXcoY3R4LCBvcHRzLT5kZXB0aCkpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAibWF4QXJyYXlMZW5ndGgiLCBqc19udW1iZXJfbmV3KGN0eCwgb3B0cy0+bWF4X2FycmF5X2xlbmd0aCkpOwogIEpTX1NldFByb3BlcnR5U3RyKGN0eCwgcmV0LCAibWF4U3RyaW5nTGVuZ3RoIiwganNfbnVtYmVyX25ldyhjdHgsIG9wdHMtPm1heF9zdHJpbmdfbGVuZ3RoKSk7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJicmVha0xlbmd0aCIsIGpzX251bWJlcl9uZXcoY3R4LCBvcHRzLT5icmVha19sZW5ndGgpKTsKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgImNvbXBhY3QiLCBqc19uZXdfYm9vbF9vcl9udW1iZXIoY3R4LCBvcHRzLT5jb21wYWN0KSk7CiAgaWYob3B0cy0+cHJvdG9fY2hhaW4pCiAgICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHJldCwgInByb3RvQ2hhaW4iLCBqc19udW1iZXJfbmV3KGN0eCwgb3B0cy0+cHJvdG9fY2hhaW4pKTsKICBhcnIgPSBKU19OZXdBcnJheShjdHgpOwogIG4gPSAwOwogIHZlY3Rvcl9mb3JlYWNoX3QoJm9wdHMtPmhpZGVfa2V5cywga2V5KSB7IEpTX1NldFByb3BlcnR5VWludDMyKGN0eCwgYXJyLCBuKyssIGpzX2F0b21fdG92YWx1ZShjdHgsIGtleS0+YXRvbSkpOyB9CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJoaWRlS2V5cyIsIGFycik7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCByZXQsICJudW1iZXJCYXNlIiwganNfbnVtYmVyX25ldyhjdHgsIG9wdHMtPm51bWJlcl9iYXNlKSk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGludAppbnNwZWN0X29wdGlvbnNfaGlkZGVuKGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBKU0F0b20gYXRvbSkgewogIHByb3Bfa2V5X3QqIGtleTsKICB2ZWN0b3JfZm9yZWFjaF90KCZvcHRzLT5oaWRlX2tleXMsIGtleSkgewogICAgaWYoa2V5LT5hdG9tID09IGF0b20pIC8vISBzdHJjbXAoa2V5LT5uYW1lLCBzdHIpKQogICAgICByZXR1cm4gMTsKICB9CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkCmluc3BlY3RfbmV3bGluZShEeW5CdWYqIGJ1ZiwgaW50MzJfdCBkZXB0aCkgewogIGRidWZfcHV0YyhidWYsICdcbicpOwogIHdoaWxlKGRlcHRoLS0gPiAwKSBkYnVmX3B1dHN0cihidWYsICIgICIpOwp9CgpzdGF0aWMgaW50CmpzX29iamVjdF9nZXRwcm9wZXJ0eW5hbWVzKEpTQ29udGV4dCogY3R4LCB1bmlvbiBWZWN0b3IqIHByb3BlbnVtX3RhYiwgSlNWYWx1ZUNvbnN0IG9iaiwgaW50IGZsYWdzKSB7CiAgaW50IHJldDsKICBKU1Byb3BlcnR5RW51bSogdG1wX3RhYjsKICB1aW50MzJfdCBpLCB0bXBfbGVuOwogIHJldCA9IEpTX0dldE93blByb3BlcnR5TmFtZXMoY3R4LCAmdG1wX3RhYiwgJnRtcF9sZW4sIG9iaiwgZmxhZ3MpOwoKICBmb3IoaSA9IDA7IGkgPCB0bXBfbGVuOyBpKyspIHsKICAgIGlmKHZlY3Rvcl9maW5kKHByb3BlbnVtX3RhYiwgc2l6ZW9mKEpTUHJvcGVydHlFbnVtKSwgJnRtcF90YWJbaV0pID09IC0xKQogICAgICB2ZWN0b3JfcHV0KHByb3BlbnVtX3RhYiwgJnRtcF90YWJbaV0sIHNpemVvZihKU1Byb3BlcnR5RW51bSkpOwogIH0KCiAganNfZnJlZShjdHgsIHRtcF90YWIpOwogIHJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQKanNfb2JqZWN0X2dldHByb3BlcnR5bmFtZXNfcmVjdXJzaXZlKEpTQ29udGV4dCogY3R4LCB1bmlvbiBWZWN0b3IqIHByb3BlbnVtX3RhYiwgSlNWYWx1ZUNvbnN0IG9iaiwgaW50IGZsYWdzKSB7CiAgaW50IHJldDsKCiAgaWYoKHJldCA9IGpzX29iamVjdF9nZXRwcm9wZXJ0eW5hbWVzKGN0eCwgcHJvcGVudW1fdGFiLCBvYmosIGZsYWdzKSkgPj0gMCkgewogICAgSlNWYWx1ZSBwcm90byA9IEpTX0dldFByb3RvdHlwZShjdHgsIG9iaik7CgogICAgaWYoSlNfSXNPYmplY3QocHJvdG8pKQogICAgICByZXQgPSBqc19vYmplY3RfZ2V0cHJvcGVydHluYW1lc19yZWN1cnNpdmUoY3R4LCBwcm9wZW51bV90YWIsIHByb3RvLCBmbGFncyk7CiAgfQoKICByZXR1cm4gcmV0Owp9CgpzdGF0aWMgSlNBdG9tCmpzX2luc3BlY3RfY3VzdG9tX2F0b20oSlNDb250ZXh0KiBjdHgsIGNvbnN0IGNoYXIqIHN5bV9mb3IpIHsKICBKU1ZhbHVlIGtleSwgc3ltOwogIEpTQXRvbSBhdG9tOwogIGtleSA9IEpTX05ld1N0cmluZyhjdHgsIHN5bV9mb3IgPyBzeW1fZm9yIDogInF1aWNranMuaW5zcGVjdC5jdXN0b20iKTsKICBzeW0gPSBqc19zeW1ib2xfaW52b2tlX3N0YXRpYyhjdHgsICJmb3IiLCBrZXkpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGtleSk7CiAgYXRvbSA9IEpTX1ZhbHVlVG9BdG9tKGN0eCwgc3ltKTsKICBKU19GcmVlVmFsdWUoY3R4LCBzeW0pOwoKICByZXR1cm4gYXRvbTsKfQoKc3RhdGljIEpTVmFsdWUKanNfaW5zcGVjdF9jdXN0b21fY2FsbChKU0NvbnRleHQqIGN0eCwgSlNWYWx1ZUNvbnN0IG9iaiwgaW5zcGVjdF9vcHRpb25zX3QqIG9wdHMsIGludDMyX3QgZGVwdGgpIHsKICBKU1ZhbHVlIHJldCA9IEpTX1VOREVGSU5FRDsKICBKU1ZhbHVlIGluc3BlY3QgPSBKU19VTkRFRklORUQ7CiAgSlNBdG9tIHByb3A7CgogIGlmKEpTX1ZBTFVFX0dFVF9PQkoob2JqKS0+Y2xhc3NfaWQpIHsKICAgIGlmKEpTX0hhc1Byb3BlcnR5KGN0eCwgb2JqLCBpbnNwZWN0X2N1c3RvbV9hdG9tKSkKICAgICAgaW5zcGVjdCA9IEpTX0dldFByb3BlcnR5KGN0eCwgb2JqLCBpbnNwZWN0X2N1c3RvbV9hdG9tKTsKICAgIGVsc2UgaWYoSlNfSGFzUHJvcGVydHkoY3R4LCBvYmosIGluc3BlY3RfY3VzdG9tX2F0b21fbm9kZSkpCiAgICAgIGluc3BlY3QgPSBKU19HZXRQcm9wZXJ0eShjdHgsIG9iaiwgaW5zcGVjdF9jdXN0b21fYXRvbV9ub2RlKTsKICB9CiAgaWYoSlNfSXNGdW5jdGlvbihjdHgsIGluc3BlY3QpKSB7CiAgICBKU1ZhbHVlQ29uc3QgYXJnc1syXTsKICAgIGluc3BlY3Rfb3B0aW9uc190IG9wdHNfbm9jdXN0b207CiAgICBtZW1jcHkoJm9wdHNfbm9jdXN0b20sIG9wdHMsIHNpemVvZihpbnNwZWN0X29wdGlvbnNfdCkpOwogICAgb3B0c19ub2N1c3RvbS5jdXN0b21faW5zcGVjdCA9IEZBTFNFOwogICAgYXJnc1swXSA9IGpzX251bWJlcl9uZXcoY3R4LCBJTlNQRUNUX0xFVkVMKG9wdHMpKTsKICAgIGFyZ3NbMV0gPSBpbnNwZWN0X29wdGlvbnNfb2JqZWN0KCZvcHRzX25vY3VzdG9tLCBjdHgpOwogICAgcmV0ID0gSlNfQ2FsbChjdHgsIGluc3BlY3QsIG9iaiwgMiwgYXJncyk7CiAgICBKU19GcmVlVmFsdWUoY3R4LCBhcmdzWzBdKTsKICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGFyZ3NbMV0pOwogICAgLyogICBzdHIgPSBKU19Ub0NTdHJpbmcoY3R4LCByZXQpOwogICAgICAgSlNfRnJlZVZhbHVlKGN0eCwgcmV0KTsqLwogIH0KCiAgSlNfRnJlZVZhbHVlKGN0eCwgaW5zcGVjdCk7CiAgcmV0dXJuIHJldDsKfQoKc3RhdGljIGludApqc19pbnNwZWN0X21hcChKU0NvbnRleHQqIGN0eCwgRHluQnVmKiBidWYsIEpTVmFsdWVDb25zdCBvYmosIGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBpbnQzMl90IGRlcHRoKSB7CiAgQk9PTCByZXQsIGZpbmlzaCA9IEZBTFNFOwogIHNpemVfdCBpID0gMDsKICBpbnQgY29tcGFjdCA9IElOU1BFQ1RfSVNfQ09NUEFDVChvcHRzKTsKICAvLyBwcmludGYoImpzX2luc3BlY3RfbWFwIGxldmVsPSV1IG9wdHMtPmRlcHRoPSUiIFBSSWQzMiAiIGRlcHRoPSUiIFBSSWQzMiAiIGNvbXBhY3Q9JWlcbiIsCiAgLy8gSU5TUEVDVF9MRVZFTChvcHRzKSwgb3B0cy0+ZGVwdGgsIGRlcHRoLCBjb21wYWN0KTsKICBKU1ZhbHVlIGRhdGEsIGtleSwgdmFsdWU7CiAgSXRlcmF0aW9uIGl0OwogIGlmKCEocmV0ID0gaXRlcmF0aW9uX21ldGhvZF9zeW1ib2woJml0LCBjdHgsIG9iaiwgIml0ZXJhdG9yIikpKSB7CiAgICBKU19UaHJvd1R5cGVFcnJvcihjdHgsICJqc19pbnNwZWN0X21hcCB0YWc9JWRcbiIsIEpTX1ZBTFVFX0dFVF9UQUcob2JqKSk7CiAgICByZXR1cm4gMDsKICB9CiAgZGJ1Zl9wdXRzdHIoYnVmLCAiTWFwIHsiKTsKICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgSU5TUEVDVF9MRVZFTChvcHRzKSk7CiAgZm9yKGkgPSAwOyAhKGZpbmlzaCA9IGl0ZXJhdGlvbl9uZXh0KCZpdCwgY3R4KSk7IGkrKykgewogICAgaWYoIWZpbmlzaCkgewogICAgICBkYXRhID0gaXRlcmF0aW9uX3ZhbHVlKCZpdCwgY3R4KTsKICAgICAgaWYoaSkgewogICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgIiwiKTsKICAgICAgICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgICAgICAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgSU5TUEVDVF9MRVZFTChvcHRzKSk7CiAgICAgIH0KICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBjb21wYWN0ID8gIiAiIDogIiAgIik7CiAgICAgIGtleSA9IEpTX0dldFByb3BlcnR5VWludDMyKGN0eCwgZGF0YSwgMCk7CiAgICAgIGpzX2luc3BlY3RfcHJpbnQoY3R4LCBidWYsIGtleSwgb3B0cywgZGVwdGggLSAxKTsKICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCAiID0+ICIpOwogICAgICB2YWx1ZSA9IEpTX0dldFByb3BlcnR5VWludDMyKGN0eCwgZGF0YSwgMSk7CiAgICAgIGpzX2luc3BlY3RfcHJpbnQoY3R4LCBidWYsIHZhbHVlLCBvcHRzLCBkZXB0aCAtIDEpOwogICAgICBKU19GcmVlVmFsdWUoY3R4LCBrZXkpOwogICAgICBKU19GcmVlVmFsdWUoY3R4LCB2YWx1ZSk7CiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGRhdGEpOwogICAgfQogIH0KICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgSU5TUEVDVF9MRVZFTChvcHRzKSk7CiAgZGJ1Zl9wdXRzdHIoYnVmLCBjb21wYWN0ID8gIiB9IiA6ICJ9Iik7CiAgaXRlcmF0aW9uX3Jlc2V0KCZpdCwgSlNfR2V0UnVudGltZShjdHgpKTsKICByZXR1cm4gMDsKfQoKc3RhdGljIGludApqc19pbnNwZWN0X3NldChKU0NvbnRleHQqIGN0eCwgRHluQnVmKiBidWYsIEpTVmFsdWVDb25zdCBvYmosIGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBpbnQzMl90IGRlcHRoKSB7CiAgQk9PTCByZXQsIGZpbmlzaCA9IEZBTFNFOwogIHNpemVfdCBpID0gMDsKICBpbnQgY29tcGFjdCA9IElOU1BFQ1RfSVNfQ09NUEFDVChvcHRzKTsKICBKU1ZhbHVlIHZhbHVlOwogIEl0ZXJhdGlvbiBpdDsKCiAgaWYoIShyZXQgPSBpdGVyYXRpb25fbWV0aG9kX3N5bWJvbCgmaXQsIGN0eCwgb2JqLCAiaXRlcmF0b3IiKSkpIHsKICAgIEpTX1Rocm93VHlwZUVycm9yKGN0eCwgImpzX2luc3BlY3RfbWFwIHRhZz0lZFxuIiwgSlNfVkFMVUVfR0VUX1RBRyhvYmopKTsKICAgIHJldHVybiAwOwogIH0KICBkYnVmX3B1dHN0cihidWYsICJTZXQgWyIpOwogIGlmKCFjb21wYWN0ICYmIG9wdHMtPmJyZWFrX2xlbmd0aCAhPSBJTlQzMl9NQVgpCiAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpKTsKICBmb3IoaSA9IDA7ICEoZmluaXNoID0gaXRlcmF0aW9uX25leHQoJml0LCBjdHgpKTsgaSsrKSB7CiAgICBpZighZmluaXNoKSB7CiAgICAgIHZhbHVlID0gaXRlcmF0aW9uX3ZhbHVlKCZpdCwgY3R4KTsKICAgICAgaWYoaSkgewogICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgIiwiKTsKICAgICAgICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgICAgICAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgSU5TUEVDVF9MRVZFTChvcHRzKSk7CiAgICAgIH0KICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBjb21wYWN0ID8gIiAiIDogIiAgIik7CiAgICAgIGpzX2luc3BlY3RfcHJpbnQoY3R4LCBidWYsIHZhbHVlLCBvcHRzLCBkZXB0aCk7CiAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHZhbHVlKTsKICAgIH0KICB9CiAgaWYoIWNvbXBhY3QgJiYgb3B0cy0+YnJlYWtfbGVuZ3RoICE9IElOVDMyX01BWCkKICAgIGluc3BlY3RfbmV3bGluZShidWYsIElOU1BFQ1RfTEVWRUwob3B0cykpOwogIGRidWZfcHV0c3RyKGJ1ZiwgY29tcGFjdCA/ICIgXSIgOiAiXSIpOwogIGl0ZXJhdGlvbl9yZXNldCgmaXQsIEpTX0dldFJ1bnRpbWUoY3R4KSk7CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQKanNfaW5zcGVjdF9hcnJheWJ1ZmZlcihKU0NvbnRleHQqIGN0eCwgRHluQnVmKiBidWYsIEpTVmFsdWVDb25zdCB2YWx1ZSwgaW5zcGVjdF9vcHRpb25zX3QqIG9wdHMsIGludDMyX3QgZGVwdGgpIHsKICBjb25zdCBjaGFyICpzdHIsICpzdHIyOwogIHVpbnQ4X3QqIHB0cjsKICBzaXplX3QgaSwgc2xlbiwgc2l6ZTsKICBpbnQgYnJlYWtfbGVuID0gb3B0cy0+YnJlYWtfbGVuZ3RoOyAvLyBpbnNwZWN0X3NjcmVlbl93aWR0aCgpOwogIGludCBjb2x1bW4gPSBkYnVmX2dldF9jb2x1bW4oYnVmKTsKICBKU1ZhbHVlIHByb3RvOwogIGJyZWFrX2xlbiA9IChicmVha19sZW4gKyAxKSAvIDM7CiAgYnJlYWtfbGVuICo9IDM7CgogIGlmKGJyZWFrX2xlbiA+IG9wdHMtPmJyZWFrX2xlbmd0aCkKICAgIGJyZWFrX2xlbiA9IG9wdHMtPmJyZWFrX2xlbmd0aDsKICBwdHIgPSBKU19HZXRBcnJheUJ1ZmZlcihjdHgsICZzaXplLCB2YWx1ZSk7CiAgLy8gcHJpbnRmKCJtYXhBcnJheUxlbmd0aDogJWlcbiIsIG9wdHMtPm1heF9hcnJheV9sZW5ndGgpOwogIHByb3RvID0gSlNfR2V0UHJvdG90eXBlKGN0eCwgdmFsdWUpOwogIHN0ciA9IGpzX29iamVjdF90b3N0cmluZyhjdHgsIHByb3RvKTsKICBKU19GcmVlVmFsdWUoY3R4LCBwcm90byk7CgogIGlmKGpzX2lzX2FycmF5YnVmZmVyKGN0eCwgdmFsdWUpKQogICAgZGJ1Zl9wdXRzdHIoYnVmLCAiQXJyYXlCdWZmZXIiKTsKICBlbHNlIGlmKGpzX2lzX3NoYXJlZGFycmF5YnVmZmVyKGN0eCwgdmFsdWUpKQogICAgZGJ1Zl9wdXRzdHIoYnVmLCAiU2hhcmVkQXJyYXlCdWZmZXIiKTsKICBlbHNlIGlmKHN0ciAmJiAoc3RyMiA9IHN0cmNocihzdHIsICcgJykpKSB7CiAgICBzdHIyKys7CiAgICBzbGVuID0gYnl0ZV9jaHIoc3RyMiwgc3RybGVuKHN0cjIpLCAnXScpOwogICAgZGJ1Zl9hcHBlbmQoYnVmLCAoY29uc3QgdWludDhfdCopc3RyMiwgc2xlbik7CiAgfQoKICBpZihzdHIpCiAgICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBzdHIpOwoKICBkYnVmX3B1dHN0cihidWYsICIgeyIpOwogIGluc3BlY3RfbmV3bGluZShidWYsIChvcHRzLT5kZXB0aCAtIGRlcHRoKSArIDIpOwogIGRidWZfcHJpbnRmKGJ1ZiwgImJ5dGVMZW5ndGg6ICV6dSBbIiwgc2l6ZSk7CiAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgKG9wdHMtPmRlcHRoIC0gZGVwdGgpICsgMyk7CiAgYnJlYWtfbGVuIC09ICgob3B0cy0+ZGVwdGggLSBkZXB0aCkgKyAzKSAqIDI7CiAgY29sdW1uID0gMDsKCiAgZm9yKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7CiAgICBpZihpID09IChzaXplX3Qpb3B0cy0+bWF4X2FycmF5X2xlbmd0aCkKICAgICAgYnJlYWs7CiAgICBpZihjb2x1bW4gKyAzID49IGJyZWFrX2xlbiAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKSB7CiAgICAgIGluc3BlY3RfbmV3bGluZShidWYsIChvcHRzLT5kZXB0aCAtIGRlcHRoKSArIDMpOwogICAgICBjb2x1bW4gPSAwOwogICAgfQogICAgZGJ1Zl9wcmludGYoYnVmLCBjb2x1bW4gPyAiICUwMngiIDogIiUwMngiLCBwdHJbaV0pOwogICAgY29sdW1uICs9IGNvbHVtbiA/IDMgOiAyOwogIH0KICBpZihpIDwgc2l6ZSkgewogICAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgKG9wdHMtPmRlcHRoIC0gZGVwdGgpICsgMyk7CgogICAgZGJ1Zl9wcmludGYoYnVmLCAiLi4uICV6dSBtb3JlIGJ5dGVzIiwgc2l6ZSAtIGkpOwogIH0KICBpbnNwZWN0X25ld2xpbmUoYnVmLCAob3B0cy0+ZGVwdGggLSBkZXB0aCkgKyAyKTsKICBkYnVmX3B1dHN0cihidWYsICJdIik7CiAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgKG9wdHMtPmRlcHRoIC0gZGVwdGgpICsgMSk7CiAgZGJ1Zl9wdXRzdHIoYnVmLCAifSIpOwogIHJldHVybiAwOwp9CgpzdGF0aWMgaW50CmpzX2luc3BlY3RfcmVnZXhwKEpTQ29udGV4dCogY3R4LCBEeW5CdWYqIGJ1ZiwgSlNWYWx1ZUNvbnN0IHZhbHVlLCBpbnNwZWN0X29wdGlvbnNfdCogb3B0cywgaW50MzJfdCBkZXB0aCkgewogIGNvbnN0IGNoYXIqIHN0cjsKICBzaXplX3QgbGVuOwogIHN0ciA9IEpTX1RvQ1N0cmluZ0xlbihjdHgsICZsZW4sIHZhbHVlKTsKICBpZihvcHRzLT5jb2xvcnMpCiAgICBkYnVmX3B1dHN0cihidWYsICJceDFiWzA7MzFtIik7CiAgZGJ1Zl9wdXRfZXNjYXBlZF9wcmVkKGJ1Ziwgc3RyLCBsZW4sIHJlZ2V4cF9wcmVkaWNhdGUpOwogIGlmKG9wdHMtPmNvbG9ycykKICAgIGRidWZfcHV0c3RyKGJ1ZiwgIlx4MWJbbSIpOwogIGpzX2NzdHJpbmdfZnJlZShjdHgsIHN0cik7CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQKanNfaW5zcGVjdF9udW1iZXIoSlNDb250ZXh0KiBjdHgsIER5bkJ1ZiogYnVmLCBKU1ZhbHVlQ29uc3QgdmFsdWUsIGluc3BlY3Rfb3B0aW9uc190KiBvcHRzLCBpbnQzMl90IGRlcHRoKSB7CiAgaW50IHRhZyA9IEpTX1ZBTFVFX0dFVF9UQUcodmFsdWUpOwogIGNvbnN0IGNoYXIqIHN0cjsKICBzaXplX3QgbGVuOwogIEpTVmFsdWUgbnVtYmVyLCBiYXNlOwogIGlmKHRhZyAhPSBKU19UQUdfU1lNQk9MICYmIG9wdHMtPmNvbG9ycykKICAgIGRidWZfcHV0c3RyKGJ1ZiwgQ09MT1JfTElHSFRZRUxMT1cpOwogIGlmKG9wdHMtPm51bWJlcl9iYXNlICYmIG9wdHMtPm51bWJlcl9iYXNlICE9IDEwKSB7CiAgICBiYXNlID0gSlNfTmV3SW50MzIoY3R4LCAxNik7CiAgICBudW1iZXIgPSBqc19pbnZva2UoY3R4LCB2YWx1ZSwgInRvU3RyaW5nIiwgMSwgJmJhc2UpOwogICAgSlNfRnJlZVZhbHVlKGN0eCwgYmFzZSk7CgogIH0gZWxzZSB7CiAgICBudW1iZXIgPSBKU19EdXBWYWx1ZShjdHgsIHZhbHVlKTsKICB9CiAgc3RyID0gSlNfVG9DU3RyaW5nTGVuKGN0eCwgJmxlbiwgbnVtYmVyKTsKICBKU19GcmVlVmFsdWUoY3R4LCBudW1iZXIpOwoKICBzd2l0Y2gob3B0cy0+bnVtYmVyX2Jhc2UpIHsKICAgIGNhc2UgMTY6IGRidWZfcHV0c3RyKGJ1ZiwgIjB4Iik7IGJyZWFrOwogICAgY2FzZSAyOiBkYnVmX3B1dHN0cihidWYsICIwYiIpOyBicmVhazsKICAgIGNhc2UgODogZGJ1Zl9wdXRzdHIoYnVmLCAiMCIpOyBicmVhazsKICB9CgogIGRidWZfYXBwZW5kKGJ1ZiwgKGNvbnN0IHVpbnQ4X3QqKXN0ciwgbGVuKTsKICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBzdHIpOwogIGlmKHRhZyA8PSBKU19UQUdfQklHX0ZMT0FUKQogICAgZGJ1Zl9wdXRjKGJ1ZiwgdGFnID09IEpTX1RBR19CSUdfREVDSU1BTCA/ICdtJyA6IHRhZyA9PSBKU19UQUdfQklHX0ZMT0FUID8gJ2wnIDogJ24nKTsKICBpZihvcHRzLT5jb2xvcnMpCiAgICBkYnVmX3B1dHN0cihidWYsIENPTE9SX05PTkUpOwogIHJldHVybiAwOwp9CgpzdGF0aWMgaW50CmpzX2luc3BlY3Rfc3RyaW5nKEpTQ29udGV4dCogY3R4LCBEeW5CdWYqIGJ1ZiwgSlNWYWx1ZUNvbnN0IHZhbHVlLCBpbnNwZWN0X29wdGlvbnNfdCogb3B0cywgaW50MzJfdCBkZXB0aCkgewogIGludCB0YWcgPSBKU19WQUxVRV9HRVRfVEFHKHZhbHVlKTsKICBpbnQgY29tcGFjdCA9IElOU1BFQ1RfSVNfQ09NUEFDVChvcHRzKTsKCiAgY29uc3QgY2hhciogc3RyOwogIHNpemVfdCBwb3MsIGxlbiwgbWF4X2xlbiwgbGltaXQsIGNvbHVtbl9zdGFydCA9IChJTlNQRUNUX0xFVkVMKG9wdHMpICogMik7CiAgc3RyID0gSlNfVG9DU3RyaW5nTGVuKGN0eCwgJmxlbiwgdmFsdWUpOwogIG1heF9sZW4gPSBtaW5fc2l6ZShvcHRzLT5icmVha19sZW5ndGggLSBkYnVmX2dldF9jb2x1bW4oYnVmKSAtIDEwLCBsZW4pOwoKICBpZih0YWcgIT0gSlNfVEFHX1NZTUJPTCAmJiBvcHRzLT5jb2xvcnMpCiAgICBkYnVmX3B1dHN0cihidWYsIENPTE9SX0dSRUVOKTsKICBkYnVmX3B1dGMoYnVmLCB0YWcgPT0gSlNfVEFHX1NZTUJPTCA/ICcoJyA6ICdcJycpOwogIGxpbWl0ID0gbWluX3NpemUob3B0cy0+bWF4X3N0cmluZ19sZW5ndGgsIGxlbik7CgogIGZvcihwb3MgPSAwOyBwb3MgPCBsaW1pdDspIHsKICAgIHNpemVfdCBpLCBuLCBlb2w7CiAgICBuID0gbGltaXQgLSBwb3M7CiAgICBpZihwb3MgPiAwKSB7CiAgICAgIGRidWZfcHV0c3RyKGJ1Ziwgb3B0cy0+Y29sb3JzID8gIiciIENPTE9SX05PTkUgIiArIiA6ICInICsiKTsKICAgICAgbWF4X2xlbiA9IG9wdHMtPmJyZWFrX2xlbmd0aCAtIGNvbHVtbl9zdGFydCAtIDg7CiAgICAgIGluc3BlY3RfbmV3bGluZShidWYsIElOU1BFQ1RfTEVWRUwob3B0cykgKyAxKTsKICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBvcHRzLT5jb2xvcnMgPyBDT0xPUl9HUkVFTiAiJyIgOiAiJyIpOwogICAgfQogICAgaWYoY29tcGFjdCkgewogICAgICBuID0gYW5zaV90cnVuY2F0ZSgmc3RyW3Bvc10sIG4sIG1heF9sZW4pOwogICAgfSBlbHNlIGlmKG9wdHMtPnN0cmluZ19icmVha19uZXdsaW5lKSB7CiAgICAgIGZvcihpID0gcG9zOyBpIDwgbGltaXQ7IGkgKz0gZW9sKSB7CiAgICAgICAgZW9sID0gYnl0ZV9jaHIoJnN0cltpXSwgbGltaXQgLSBpLCAnXG4nKTsKICAgICAgICBpZihzdHJbaSArIGVvbF0gPT0gJ1xuJykKICAgICAgICAgIGVvbCsrOwoKICAgICAgICBpZihpID4gcG9zICYmIGFuc2lfdHJ1bmNhdGUoJnN0cltwb3NdLCBpICsgZW9sIC0gcG9zLCBtYXhfbGVuKSA8IGkgKyBlb2wgLSBwb3MpIHsKICAgICAgICAgIG4gPSBpIC0gcG9zOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBkYnVmX3B1dF9lc2NhcGVkKGJ1ZiwgJnN0cltwb3NdLCBuKTsKICAgIHBvcyArPSBuOwogIH0KICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBzdHIpOwogIGRidWZfcHV0YyhidWYsIHRhZyA9PSBKU19UQUdfU1lNQk9MID8gJyknIDogJ1wnJyk7CgogIGlmKG9wdHMtPmNvbG9ycykKICAgIGRidWZfcHV0c3RyKGJ1ZiwgQ09MT1JfTk9ORSk7CgogIGlmKGxpbWl0IDwgbGVuKSB7CiAgICBpZihvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYICYmIGRidWZfZ2V0X2NvbHVtbihidWYpICsgMjYgPiBvcHRzLT5icmVha19sZW5ndGgpCiAgICAgIGluc3BlY3RfbmV3bGluZShidWYsIElOU1BFQ1RfTEVWRUwob3B0cykgKyAxKTsKICAgIGRidWZfcHJpbnRmKGJ1ZiwgIi4uLiAlenUgbW9yZSBjaGFyYWN0ZXJzIiwgbGVuIC0gcG9zKTsKICB9CiAgcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQKanNfaW5zcGVjdF9wcmludChKU0NvbnRleHQqIGN0eCwgRHluQnVmKiBidWYsIEpTVmFsdWVDb25zdCB2YWx1ZSwgaW5zcGVjdF9vcHRpb25zX3QqIG9wdHMsIGludDMyX3QgZGVwdGgpIHsKICBpbnQgdGFnID0gSlNfVkFMVUVfR0VUX1RBRyh2YWx1ZSk7CiAgLy8gaW50IGNvbXBhY3QgPSBJTlNQRUNUX0lTX0NPTVBBQ1Qob3B0cyk7CiAgLy8gcHJpbnRmKCJqc19pbnNwZWN0X3ByaW50IGxldmVsOiAlZFxuIiwgSU5TUEVDVF9MRVZFTChvcHRzKSk7CiAgc3dpdGNoKHRhZykgewogICAgY2FzZSBKU19UQUdfRkxPQVQ2NDoKICAgIGNhc2UgSlNfVEFHX0JJR19ERUNJTUFMOgogICAgY2FzZSBKU19UQUdfQklHX0lOVDoKICAgIGNhc2UgSlNfVEFHX0lOVDoKICAgIGNhc2UgSlNfVEFHX0JJR19GTE9BVDogewogICAgICByZXR1cm4ganNfaW5zcGVjdF9udW1iZXIoY3R4LCBidWYsIHZhbHVlLCBvcHRzLCBkZXB0aCk7CiAgICB9CgogICAgICAvKiBjYXNlIEpTX1RBR19JTlQ6IHsKICAgICAgICAgaW50IGkgPSBKU19WQUxVRV9HRVRfSU5UKHZhbHVlKTsKICAgICAgICAgaWYob3B0cy0+Y29sb3JzKQogICAgICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgQ09MT1JfWUVMTE9XKTsKICAgICAgICAgZGJ1Zl9wcmludGYoYnVmLCAiJWkiLCBpKTsKICAgICAgICAgaWYob3B0cy0+Y29sb3JzKQogICAgICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgQ09MT1JfTk9ORSk7CiAgICAgICAgIGJyZWFrOwogICAgICAgfSovCgogICAgY2FzZSBKU19UQUdfQk9PTDogewogICAgICBpZihvcHRzLT5jb2xvcnMpCiAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBDT0xPUl9ZRUxMT1cpOwogICAgICBkYnVmX3B1dHN0cihidWYsIEpTX1ZBTFVFX0dFVF9CT09MKHZhbHVlKSA/ICJ0cnVlIiA6ICJmYWxzZSIpOwogICAgICBpZihvcHRzLT5jb2xvcnMpCiAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBDT0xPUl9OT05FKTsKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBKU19UQUdfTlVMTDogewogICAgICBkYnVmX3B1dHN0cihidWYsIG9wdHMtPmNvbG9ycyA/ICJceDFiWzM4OzU7MTI5bW51bGxceDFiW20iIDogIm51bGwiKTsKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBKU19UQUdfVU5ERUZJTkVEOiB7CiAgICAgIGRidWZfcHV0X2NvbG9yc3RyKGJ1ZiwgInVuZGVmaW5lZCIsIENPTE9SX0dSQVksIG9wdHMtPmNvbG9ycyk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgSlNfVEFHX0VYQ0VQVElPTjogewogICAgICBkYnVmX3B1dF9jb2xvcnN0cihidWYsICJbZXhjZXB0aW9uXSIsIENPTE9SX1JFRCwgb3B0cy0+Y29sb3JzKTsKICAgICAgYnJlYWs7CiAgICB9CgogICAgY2FzZSBKU19UQUdfU1lNQk9MOiB7CiAgICAgIHZhbHVlID0ganNfc3ltYm9sX3RvX3N0cmluZyhjdHgsIHZhbHVlKTsKICAgICAgaWYob3B0cy0+Y29sb3JzKQogICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgQ09MT1JfR1JFRU4pOwogICAgICBkYnVmX3B1dHN0cihidWYsICJTeW1ib2wiKTsKICAgICAgX19hdHRyaWJ1dGVfXygoZmFsbHRocm91Z2gpKTsKICAgIH0KCiAgICBjYXNlIEpTX1RBR19TVFJJTkc6IHsKICAgICAgcmV0dXJuIGpzX2luc3BlY3Rfc3RyaW5nKGN0eCwgYnVmLCB2YWx1ZSwgb3B0cywgZGVwdGgpOwogICAgfQoKICAgIGNhc2UgSlNfVEFHX09CSkVDVDogewogICAgICBCT09MIGlzX2FycmF5ID0gMCwgaXNfdHlwZWRhcnJheSA9IDAsIGlzX2Z1bmN0aW9uID0gMDsKICAgICAgdWludDMyX3QgcG9zLCBsZW4sIGxpbWl0OwogICAgICBWZWN0b3IgcHJvcGVudW1fdGFiOwogICAgICBjb25zdCBjaGFyKiBzID0gMDsKICAgICAgaW50IGNvbXBhY3QgPSBvcHRzLT5jb21wYWN0OwogICAgICBKU09iamVjdCogb2JqID0gSlNfVkFMVUVfR0VUX09CSih2YWx1ZSk7CgogICAgICBpZighb2JqLT5wcm9wIHx8ICFvYmotPnNoYXBlKSB7CiAgICAgICAgZGJ1Zl9wcmludGYoYnVmLCAianNfaW5zcGVjdF9wcmludCBPYmplY3QgcHJvcCA9ICVwLCBzaGFwZSA9ICVwICIsIG9iai0+cHJvcCwgb2JqLT5zaGFwZSk7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CgogICAgICBpZihvcHRzLT5jdXN0b21faW5zcGVjdCkgewogICAgICAgIEpTVmFsdWUgdG1wID0ganNfaW5zcGVjdF9jdXN0b21fY2FsbChjdHgsIHZhbHVlLCBvcHRzLCBkZXB0aCk7CiAgICAgICAgaWYoSlNfSXNTdHJpbmcodG1wKSkgewogICAgICAgICAgY29uc3QgY2hhciogcyA9IEpTX1RvQ1N0cmluZyhjdHgsIHRtcCk7CiAgICAgICAgICBkYnVmX3B1dHN0cihidWYsIHMpOwogICAgICAgICAganNfY3N0cmluZ19mcmVlKGN0eCwgcyk7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CgogICAgICAgIGlmKEpTX0lzRXhjZXB0aW9uKHRtcCkpIHsKICAgICAgICAgIEpTVmFsdWUgZXhjZXB0aW9uID0gSlNfR2V0RXhjZXB0aW9uKGN0eCk7CgogICAgICAgICAgLy8gZGJ1Zl9wcmludGYoYnVmLCAiZXhjZXB0aW9uOiAlc1xuIiwgSlNfVG9DU3RyaW5nKGN0eCwgZXhjZXB0aW9uKSk7CiAgICAgICAgICAvLyByZXR1cm4gMDsKCiAgICAgICAgfSBlbHNlIGlmKCFKU19Jc1VuZGVmaW5lZCh0bXApKSB7CiAgICAgICAgICBpZighSlNfSXNPYmplY3QodG1wKSkKICAgICAgICAgICAgcmV0dXJuIGpzX2luc3BlY3RfcHJpbnQoY3R4LCBidWYsIHRtcCwgb3B0cywgZGVwdGggKyAxKTsKCiAgICAgICAgICB2YWx1ZSA9IHRtcDsKICAgICAgICAgIGNvbXBhY3QrKzsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmKG9wdHMtPmNvbXBhY3QgPCAwKSB7CiAgICAgICAgY29tcGFjdCA9IGRlcHRoID49IC1vcHRzLT5jb21wYWN0OwogICAgICB9IGVsc2UgaWYoSU5TUEVDVF9JTlQzMlRfSU5SQU5HRShvcHRzLT5jb21wYWN0KSAmJiBvcHRzLT5jb21wYWN0ID4gMCkgewogICAgICAgIGludDMyX3QgZGVlcGVzdCA9IDE7CgogICAgICAgIGlmKCFqc19pc19hcnJheWJ1ZmZlcihjdHgsIHZhbHVlKSkKICAgICAgICAgIGRlZXBlc3QgPSBwcm9wZXJ0eV9lbnVtZXJhdGlvbl9kZWVwZXN0KGN0eCwgdmFsdWUpOwogICAgICAgIGNvbnN0IGNoYXIqIHR5cGVzdHIgPSBqc192YWx1ZV90eXBlc3RyKGN0eCwgdmFsdWUpOwogICAgICAgIC8vIHByaW50ZigiJXMgb3B0cy0+Y29tcGFjdCA9ICVkLCBkZWVwZXN0ID0gJWQsIGRlcHRoID0gJWRcbiIsIHR5cGVzdHIgPyB0eXBlc3RyIDogIihudWxsKSIsIG9wdHMtPmNvbXBhY3QsCiAgICAgICAgLy8gZGVlcGVzdCwgZGVwdGgpOwoKICAgICAgICBjb21wYWN0ID0gY29tcGFjdCA+IGRlZXBlc3Q7CiAgICAgIH0KCiAgICAgIGlmKCEoaXNfZnVuY3Rpb24gPSBKU19Jc0Z1bmN0aW9uKGN0eCwgdmFsdWUpKSkgewogICAgICAgIGlzX2FycmF5ID0ganNfaXNfYXJyYXkoY3R4LCB2YWx1ZSk7CiAgICAgICAgaXNfdHlwZWRhcnJheSA9IGpzX2lzX3R5cGVkYXJyYXkodmFsdWUpOwoKICAgICAgICBpZighaXNfYXJyYXkgJiYgIWlzX3R5cGVkYXJyYXkpIHsKICAgICAgICAgIGlmKGpzX2lzX2FycmF5YnVmZmVyKGN0eCwgdmFsdWUpIHx8IGpzX2lzX3NoYXJlZGFycmF5YnVmZmVyKGN0eCwgdmFsdWUpKQogICAgICAgICAgICByZXR1cm4ganNfaW5zcGVjdF9hcnJheWJ1ZmZlcihjdHgsIGJ1ZiwgdmFsdWUsIG9wdHMsIGRlcHRoICsgMSk7CgogICAgICAgICAgaWYoanNfaXNfbWFwKGN0eCwgdmFsdWUpKQogICAgICAgICAgICByZXR1cm4ganNfaW5zcGVjdF9tYXAoY3R4LCBidWYsIHZhbHVlLCBvcHRzLCBkZXB0aCAvKisgMSovKTsKICAgICAgICAgIGlmKGpzX2lzX3NldChjdHgsIHZhbHVlKSkKICAgICAgICAgICAgcmV0dXJuIGpzX2luc3BlY3Rfc2V0KGN0eCwgYnVmLCB2YWx1ZSwgb3B0cywgZGVwdGggKyAxKTsKICAgICAgICAgIGlmKGpzX2lzX3JlZ2V4cChjdHgsIHZhbHVlKSkKICAgICAgICAgICAgcmV0dXJuIGpzX2luc3BlY3RfcmVnZXhwKGN0eCwgYnVmLCB2YWx1ZSwgb3B0cywgZGVwdGggKyAxKTsKICAgICAgICAgIC8qaWYoSlNfSXNJbnN0YW5jZU9mKGN0eCwgdmFsdWUsIHByb3h5X2N0b3IpKSB7CiAgICAgICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgIltQcm94eV0iKTsKICAgICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgICB9Ki8KICAgICAgICB9CgogICAgICAgIGlmKGpzX29iamVjdF90bXBtYXJrX2lzc2V0KHZhbHVlKSkgewogICAgICAgICAgSlNfVGhyb3dUeXBlRXJyb3IoY3R4LCAiY2lyY3VsYXIgcmVmZXJlbmNlIik7CiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgfQoKICAgICAgICBpZihqc19pc19nZW5lcmF0b3IoY3R4LCB2YWx1ZSkpIHsKICAgICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgIk9iamVjdCBbR2VuZXJhdG9yXSB7fSIpOwogICAgICAgICAganNfY3N0cmluZ19mcmVlKGN0eCwgcyk7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmKCFKU19Jc0FycmF5KGN0eCwgdmFsdWUpICYmICFpc19mdW5jdGlvbikgewogICAgICAgIGlmKHMgPT0gMCkKICAgICAgICAgIHMgPSBqc19vYmplY3RfdG9zdHJpbmcoY3R4LCB2YWx1ZSk7CgogICAgICAgIGlmKCFzdHJuY21wKHMsICJbb2JqZWN0ICIsIDgpKSB7CiAgICAgICAgICBjb25zdCBjaGFyKiBlID0gc3RyY2hyKHMsICddJyk7CiAgICAgICAgICBzaXplX3Qgc2xlbiA9IGUgLSAocyArIDgpOwoKICAgICAgICAgIGlmKHNsZW4gIT0gNiB8fCBtZW1jbXAocyArIDgsICJPYmplY3QiLCA2KSkgewogICAgICAgICAgICBkYnVmX3B1dHN0cihidWYsIG9wdHMtPmNvbG9ycyA/IENPTE9SX0xJR0hUUkVEIDogIlsiKTsKICAgICAgICAgICAgLy8gZGJ1Zl9wdXRzdHIoYnVmLCBvcHRzLT5jb2xvcnMgPyBDT0xPUl9NQVJJTkUgIlsiIDogIlsiKTsKICAgICAgICAgICAgZGJ1Zl9hcHBlbmQoYnVmLCAoY29uc3QgdWludDhfdCopcyArIDgsIGUgLSAocyArIDgpKTsKICAgICAgICAgICAgLy8gZGJ1Zl9wdXRzdHIoYnVmLCBvcHRzLT5jb2xvcnMgPyAiXSIgQ09MT1JfTk9ORSAiICIgOiAiXSAiKTsKICAgICAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBvcHRzLT5jb2xvcnMgPyBDT0xPUl9OT05FICIgIiA6ICJdICIpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBzKTsKCiAgICAgIHZlY3Rvcl9pbml0KCZwcm9wZW51bV90YWIsIGN0eCk7CgogICAgICBpZihqc19vYmplY3RfZ2V0cHJvcGVydHluYW1lc19yZWN1cnNpdmUoY3R4LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJnByb3BlbnVtX3RhYiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMtPnByb3RvX2NoYWluID8gSlNfR2V0UHJvdG90eXBlKGN0eCwgdmFsdWUpIDogdmFsdWUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU19HUE5fU1RSSU5HX01BU0sgfCBKU19HUE5fU1lNQk9MX01BU0sgfAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvcHRzLT5zaG93X2hpZGRlbiA/IDAgOiBKU19HUE5fRU5VTV9PTkxZKSkpCiAgICAgICAgcmV0dXJuIC0xOwoKICAgICAgaWYoaXNfZnVuY3Rpb24pIHsKICAgICAgICBKU1ZhbHVlIG5hbWU7CiAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBvcHRzLT5jb2xvcnMgPyBDT0xPUl9NQVJJTkUgIltGdW5jdGlvbiIgOiAiW0Z1bmN0aW9uIik7CiAgICAgICAgbmFtZSA9IEpTX0dldFByb3BlcnR5U3RyKGN0eCwgdmFsdWUsICJuYW1lIik7CiAgICAgICAgaWYoIUpTX0lzVW5kZWZpbmVkKG5hbWUpKSB7CiAgICAgICAgICBzID0gSlNfVG9DU3RyaW5nKGN0eCwgbmFtZSk7CiAgICAgICAgICBpZigqcykgewogICAgICAgICAgICBkYnVmX3B1dHN0cihidWYsICI6ICIpOwogICAgICAgICAgICBkYnVmX3B1dHN0cihidWYsIHMpOwogICAgICAgICAgfQogICAgICAgICAganNfY3N0cmluZ19mcmVlKGN0eCwgcyk7CiAgICAgICAgfQogICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIG5hbWUpOwogICAgICAgIGRidWZfcHV0c3RyKGJ1Ziwgb3B0cy0+Y29sb3JzID8gIl0iIENPTE9SX05PTkUgOiAiXSIpOwogICAgICAgIGlmKHZlY3Rvcl9zaXplKCZwcm9wZW51bV90YWIsIHNpemVvZihKU1Byb3BlcnR5RGVzY3JpcHRvcikpICYmIGRlcHRoID49IDApCiAgICAgICAgICBkYnVmX3B1dGMoYnVmLCAnICcpOwogICAgICAgIGVsc2UKICAgICAgICAgIGdvdG8gZW5kX29iajsKICAgICAgfQogICAgICBpZihkZXB0aCA8IDApIHsKICAgICAgICBkYnVmX3B1dF9jb2xvcnN0cihidWYsIGlzX2FycmF5ID8gIltBcnJheV0iIDogIltPYmplY3RdIiwgQ09MT1JfTUFSSU5FLCBvcHRzLT5jb2xvcnMpOwogICAgICAgIGdvdG8gZW5kX29iajsKICAgICAgfQoKICAgICAganNfb2JqZWN0X3RtcG1hcmtfc2V0KHZhbHVlKTsKCiAgICAgIGlmKGlzX2FycmF5IHx8IGlzX3R5cGVkYXJyYXkpIHsKICAgICAgICBsZW4gPSBqc19hcnJheV9sZW5ndGgoY3R4LCB2YWx1ZSk7CiAgICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBjb21wYWN0ICYmIG9wdHMtPmJyZWFrX2xlbmd0aCAhPSBJTlQzMl9NQVggPyAiWyAiIDogIlsiKTsKICAgICAgICBsaW1pdCA9IG1pbl9zaXplKG9wdHMtPm1heF9hcnJheV9sZW5ndGgsIGxlbik7CiAgICAgICAgaWYobGVuICYmICFjb21wYWN0ICYmIG9wdHMtPmJyZWFrX2xlbmd0aCAhPSBJTlQzMl9NQVgpCiAgICAgICAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpICsgMSk7CiAgICAgICAgZm9yKHBvcyA9IDA7IHBvcyA8IGxlbjsgcG9zKyspIHsKICAgICAgICAgIEpTUHJvcGVydHlEZXNjcmlwdG9yIGRlc2M7CiAgICAgICAgICBKU0F0b20gcHJvcDsKICAgICAgICAgIGlmKHBvcyA9PSBsaW1pdCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBpZihwb3MgPiAwKSB7CiAgICAgICAgICAgIGRidWZfcHV0c3RyKGJ1ZiwgIiwgIik7CiAgICAgICAgICAgIC8vIGRidWZfcHV0c3RyKGJ1ZiwgY29tcGFjdCA/ICIsICIgOiAiLCIpOwogICAgICAgICAgICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgICAgICAgICAgIGluc3BlY3RfbmV3bGluZShidWYsIElOU1BFQ1RfTEVWRUwob3B0cykgKyAxKTsKICAgICAgICAgIH0KICAgICAgICAgIHByb3AgPSBKU19OZXdBdG9tVUludDMyKGN0eCwgcG9zKTsKICAgICAgICAgIG1lbXNldCgmZGVzYywgMCwgc2l6ZW9mKGRlc2MpKTsKICAgICAgICAgIGRlc2MudmFsdWUgPSBKU19VTkRFRklORUQ7CiAgICAgICAgICBKU19HZXRPd25Qcm9wZXJ0eShjdHgsICZkZXNjLCB2YWx1ZSwgcHJvcCk7CiAgICAgICAgICBKU19GcmVlQXRvbShjdHgsIHByb3ApOwoKICAgICAgICAgIGlmKChkZXNjLmZsYWdzICYgSlNfUFJPUF9HRVRTRVQpICYmIG9wdHMtPmdldHRlcnMpIHsKICAgICAgICAgICAgaW50IGlkeCA9IChKU19Jc1VuZGVmaW5lZChkZXNjLmdldHRlcikgPyAwIDogMSkgfCAoSlNfSXNVbmRlZmluZWQoZGVzYy5zZXR0ZXIpID8gMCA6IDIpOwogICAgICAgICAgICBzdGF0aWMgY29uc3QgY2hhciogY29uc3Qgc3Ryc1s0XSA9IHswLCAiW0dldHRlcl0iLCAiW1NldHRlcl0iLCAiW0dldHRlci9TZXR0ZXJdIn07CiAgICAgICAgICAgIGlmKGlkeCkKICAgICAgICAgICAgICBkYnVmX3B1dF9jb2xvcnN0cihidWYsIHN0cnNbaWR4XSwgQ09MT1JfTUFSSU5FLCBvcHRzLT5jb2xvcnMpOwoKICAgICAgICAgIH0gZWxzZSBpZihKU19IYXNQcm9wZXJ0eShjdHgsIHZhbHVlLCBKU19BVE9NX1RBR19JTlQgfCBwb3MpKSB7CiAgICAgICAgICAgIC8qICBpZihjb21wYWN0IHx8IG9wdHMtPmJyZWFrX2xlbmd0aCA9PSBJTlQzMl9NQVgpCiAgICAgICAgICAgICAgICBkYnVmX3B1dGMoYnVmLCAnICcpOyovCiAgICAgICAgICAgIGpzX2luc3BlY3RfcHJpbnQoY3R4LCBidWYsIGRlc2MudmFsdWUsIG9wdHMsIGRlcHRoIC0gMSk7CiAgICAgICAgICB9CiAgICAgICAgICBqc19wcm9wZXJ0eWRlc2NyaXB0b3JfZnJlZShjdHgsICZkZXNjKTsKICAgICAgICB9CiAgICAgICAgaWYobGVuICYmIGxpbWl0IDwgbGVuKSB7CiAgICAgICAgICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgICAgICAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpICsgMSk7CiAgICAgICAgICBkYnVmX3ByaW50ZihidWYsICIuLi4gJXUgbW9yZSBpdGVtIiwgbGVuIC0gcG9zKTsKICAgICAgICAgIGlmKHBvcyArIDEgPCBsZW4pCiAgICAgICAgICAgIGRidWZfcHV0YyhidWYsICdzJyk7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZighaXNfYXJyYXkgJiYgIWlzX3R5cGVkYXJyYXkpIHsKICAgICAgICBkYnVmX3B1dHN0cihidWYsIChjb21wYWN0ICYmIHZlY3Rvcl9zaXplKCZwcm9wZW51bV90YWIsIHNpemVvZihKU1Byb3BlcnR5RW51bSkpKSA/ICJ7ICIgOiAieyIpOwogICAgICAgIGxlbiA9IDA7CiAgICAgIH0KCiAgICAgIGZvcihwb3MgPSAwOyBwb3MgPCB2ZWN0b3Jfc2l6ZSgmcHJvcGVudW1fdGFiLCBzaXplb2YoSlNQcm9wZXJ0eUVudW0pKTsgcG9zKyspIHsKICAgICAgICBKU1Byb3BlcnR5RGVzY3JpcHRvciBkZXNjOwogICAgICAgIGNvbnN0IGNoYXIqIG5hbWU7CiAgICAgICAgSlNQcm9wZXJ0eUVudW0qIHByb3BlbnVtID0gKEpTUHJvcGVydHlFbnVtKil2ZWN0b3JfYXQoJnByb3BlbnVtX3RhYiwgc2l6ZW9mKEpTUHJvcGVydHlFbnVtKSwgcG9zKTsKICAgICAgICBKU1ZhbHVlIGtleSA9IGpzX2F0b21fdG92YWx1ZShjdHgsIHByb3BlbnVtLT5hdG9tKTsKICAgICAgICBuYW1lID0gSlNfQXRvbVRvQ1N0cmluZyhjdHgsIHByb3BlbnVtLT5hdG9tKTsKICAgICAgICBpZighSlNfSXNTeW1ib2woa2V5KSkgewogICAgICAgICAgaWYoKChpc19hcnJheSB8fCBpc190eXBlZGFycmF5KSAmJiBpc19pbnRlZ2VyKG5hbWUpKSB8fCBpbnNwZWN0X29wdGlvbnNfaGlkZGVuKG9wdHMsIHByb3BlbnVtLT5hdG9tKSkgewogICAgICAgICAgICBKU19GcmVlVmFsdWUoY3R4LCBrZXkpOwogICAgICAgICAgICBqc19jc3RyaW5nX2ZyZWUoY3R4LCBuYW1lKTsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmKHBvcyA+IDApCiAgICAgICAgICBkYnVmX3B1dHN0cihidWYsIGNvbXBhY3QgPyAiLCAiIDogIiwiKTsKICAgICAgICBpZighY29tcGFjdCAmJiBvcHRzLT5icmVha19sZW5ndGggIT0gSU5UMzJfTUFYKQogICAgICAgICAgaW5zcGVjdF9uZXdsaW5lKGJ1ZiwgSU5TUEVDVF9MRVZFTChvcHRzKSArIDEpOwogICAgICAgIGlmKCFKU19Jc1N5bWJvbChrZXkpICYmIChpc19pZGVudGlmaWVyKG5hbWUpIHx8IGlzX2ludGVnZXIobmFtZSkpKSB7CiAgICAgICAgICBkYnVmX3B1dHN0cihidWYsIG5hbWUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZighSlNfSXNTdHJpbmcoa2V5KSkKICAgICAgICAgICAgZGJ1Zl9wdXRjKGJ1ZiwgJ1snKTsKICAgICAgICAgIGpzX2luc3BlY3RfcHJpbnQoY3R4LCBidWYsIGtleSwgb3B0cywgZGVwdGggLSAxKTsKICAgICAgICAgIGlmKCFKU19Jc1N0cmluZyhrZXkpKQogICAgICAgICAgICBkYnVmX3B1dGMoYnVmLCAnXScpOwogICAgICAgIH0KICAgICAgICBkYnVmX3B1dHN0cihidWYsICI6ICIpOwogICAgICAgIGpzX2NzdHJpbmdfZnJlZShjdHgsIG5hbWUpOwogICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIGtleSk7CgogICAgICAgIGlmKGpzX2dldF9wcm9wZXJ0eWRlc2NyaXB0b3IoY3R4LCAmZGVzYywgdmFsdWUsIHByb3BlbnVtLT5hdG9tKSA9PSBUUlVFKSB7CiAgICAgICAgICBpZigoZGVzYy5mbGFncyAmIEpTX1BST1BfR0VUU0VUKSkgewogICAgICAgICAgICBpZighb3B0cy0+Z2V0dGVycykgewogICAgICAgICAgICAgIEpTVmFsdWUgdiA9IEpTX0dldFByb3BlcnR5KGN0eCwgdmFsdWUsIHByb3BlbnVtLT5hdG9tKTsKICAgICAgICAgICAgICBqc19pbnNwZWN0X3ByaW50KGN0eCwgYnVmLCB2LCBvcHRzLCBkZXB0aCAtIDEpOwogICAgICAgICAgICAgIEpTX0ZyZWVWYWx1ZShjdHgsIHYpOwogICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICBkYnVmX3B1dF9jb2xvcnN0cihidWYsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNfSXNVbmRlZmluZWQoZGVzYy5nZXR0ZXIpICAgPyAiW1NldHRlcl0iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBKU19Jc1VuZGVmaW5lZChkZXNjLnNldHRlcikgPyAiW0dldHRlcl0iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAiW0dldHRlci9TZXR0ZXJdIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT0xPUl9NQVJJTkUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy0+Y29sb3JzKTsKICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICBqc19pbnNwZWN0X3ByaW50KGN0eCwgYnVmLCBkZXNjLnZhbHVlLCBvcHRzLCBkZXB0aCAtIDEpOwogICAgICAgIH0KICAgICAgICBqc19wcm9wZXJ0eWRlc2NyaXB0b3JfZnJlZShjdHgsICZkZXNjKTsKICAgICAgICBsZW4rKzsKICAgICAgfQogICAgICBqc19vYmplY3RfdG1wbWFya19jbGVhcih2YWx1ZSk7CgogICAgICBpZighY29tcGFjdCAmJiBsZW4gJiYgb3B0cy0+YnJlYWtfbGVuZ3RoICE9IElOVDMyX01BWCkKICAgICAgICBpbnNwZWN0X25ld2xpbmUoYnVmLCBJTlNQRUNUX0xFVkVMKG9wdHMpKTsKICAgICAgZGJ1Zl9wdXRzdHIoYnVmLAogICAgICAgICAgICAgICAgICAoaXNfYXJyYXkgfHwgaXNfdHlwZWRhcnJheSkgPyAoKGNvbXBhY3QgfHwgb3B0cy0+YnJlYWtfbGVuZ3RoID09IElOVDMyX01BWCkgJiYgbGVuID8gIiBdIiA6ICJdIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGNvbXBhY3QgJiYgbGVuID8gIiB9IiA6ICJ9IikpOwoKICAgIGVuZF9vYmo6CiAgICAgIGlmKCF2ZWN0b3JfZW1wdHkoJnByb3BlbnVtX3RhYikpCiAgICAgICAganNfcHJvcGVydHllbnVtc19mcmVlKGN0eCwgdmVjdG9yX2JlZ2luKCZwcm9wZW51bV90YWIpLCB2ZWN0b3Jfc2l6ZSgmcHJvcGVudW1fdGFiLCBzaXplb2YoSlNQcm9wZXJ0eUVudW0pKSk7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIGNhc2UgSlNfVEFHX0ZVTkNUSU9OX0JZVEVDT0RFOiB7CiAgICAgIGRidWZfcHV0c3RyKGJ1Ziwgb3B0cy0+Y29sb3JzID8gQ09MT1JfTElHSFRSRUQgIltieXRlY29kZV0iIENPTE9SX05PTkUgOiAiW2J5dGVjb2RlXSIpOwogICAgICBicmVhazsKICAgIH0KCiAgICBjYXNlIEpTX1RBR19NT0RVTEU6IHsKICAgICAgZGJ1Zl9wdXRzdHIoYnVmLCBvcHRzLT5jb2xvcnMgPyBDT0xPUl9MSUdIVE1BUklORSAiW21vZHVsZV0iIENPTE9SX05PTkUgOiAiW21vZHVsZV0iKTsKICAgICAgYnJlYWs7CiAgICB9CgogICAgZGVmYXVsdDogewogICAgICBKU19UaHJvd1R5cGVFcnJvcihjdHgsICJVbmhhbmRsZWQgdmFsdWUgdGFnIGluIGpzX2luc3BlY3RfcHJpbnQ6ICVkXG4iLCB0YWcpOwogICAgICByZXR1cm4gLTE7CiAgICB9CiAgfQogIHJldHVybiAwOwp9CgpzdGF0aWMgSlNWYWx1ZQpqc19pbnNwZWN0KEpTQ29udGV4dCogY3R4LCBKU1ZhbHVlQ29uc3QgdGhpc192YWwsIGludCBhcmdjLCBKU1ZhbHVlQ29uc3QgYXJndltdKSB7CiAgRHluQnVmIGRidWY7CiAgaW5zcGVjdF9vcHRpb25zX3Qgb3B0aW9uczsKICBpbnQzMl90IGxldmVsOwogIGludCBvcHRpbmQgPSAxOwogIEpTVmFsdWUgcmV0OwoKICBqc19kYnVmX2luaXQoY3R4LCAmZGJ1Zik7CiAgaW5zcGVjdF9vcHRpb25zX2luaXQoJm9wdGlvbnMsIGN0eCk7CgogIGlmKGFyZ2MgPiAxICYmIEpTX0lzTnVtYmVyKGFyZ3ZbMV0pKQogICAgb3B0aW5kKys7CgogIGlmKG9wdGluZCA8IGFyZ2MpCiAgICBpbnNwZWN0X29wdGlvbnNfZ2V0KCZvcHRpb25zLCBjdHgsIGFyZ3Zbb3B0aW5kXSk7CgogIGlmKG9wdGluZCA+IDEpIHsKICAgIGRvdWJsZSBkOwogICAgSlNfVG9GbG9hdDY0KGN0eCwgJmQsIGFyZ3ZbMV0pOwogICAgbGV2ZWwgPSBpc2luZihkKSA/IElOVDMyX01BWCA6IGQ7CiAgfSBlbHNlIHsKICAgIGxldmVsID0gMDsKICB9CgogIC8qcHJpbnRmKCJqc19pbnNwZWN0IGJyZWFrX2xlbmd0aDogJWQsIG1heF9hcnJheV9sZW5ndGg6ICVkLCBtYXhfc3RyaW5nX2xlbmd0aDogJWRcbiIsCiAgICAgICAgIG9wdGlvbnMuYnJlYWtfbGVuZ3RoLCBvcHRpb25zLm1heF9hcnJheV9sZW5ndGgsIG9wdGlvbnMubWF4X3N0cmluZ19sZW5ndGgpOyovCgogIGpzX2luc3BlY3RfcHJpbnQoY3R4LCAmZGJ1ZiwgYXJndlswXSwgJm9wdGlvbnMsIG9wdGlvbnMuZGVwdGggLSBsZXZlbCk7CgogIHJldCA9IEpTX05ld1N0cmluZ0xlbihjdHgsIChjb25zdCBjaGFyKilkYnVmLmJ1ZiwgZGJ1Zi5zaXplKTsKCiAgZGJ1Zl9mcmVlKCZkYnVmKTsKCiAgaW5zcGVjdF9vcHRpb25zX2ZyZWUoJm9wdGlvbnMsIGN0eCk7CgogIHJldHVybiByZXQ7Cn0KCmNvbnN0IGNoYXIqCmpzX2luc3BlY3RfdG9zdHJpbmcoSlNDb250ZXh0KiBjdHgsIEpTVmFsdWVDb25zdCB2YWx1ZSkgewogIEpTVmFsdWUgb3V0cHV0OwogIGluc3BlY3Rfb3B0aW9uc190IG9wdHM7CiAgSlNWYWx1ZUNvbnN0IGFyZ3NbXSA9IHt2YWx1ZSwgSlNfVU5ERUZJTkVEfTsKICBpbnNwZWN0X29wdGlvbnNfaW5pdCgmb3B0cywgY3R4KTsKICBvcHRzLmNvbG9ycyA9IEZBTFNFOwogIGFyZ3NbMV0gPSBpbnNwZWN0X29wdGlvbnNfb2JqZWN0KCZvcHRzLCBjdHgpOwogIGluc3BlY3Rfb3B0aW9uc19mcmVlKCZvcHRzLCBjdHgpOwoKICBvdXRwdXQgPSBqc19pbnNwZWN0KGN0eCwgSlNfVU5ERUZJTkVELCAyLCBhcmdzKTsKICBKU19GcmVlVmFsdWUoY3R4LCBhcmdzWzFdKTsKICByZXR1cm4gSlNfVG9DU3RyaW5nKGN0eCwgb3V0cHV0KTsKfQoKSlNWYWx1ZSBqc19kZWJ1Z2dlcl9idWlsZF9iYWNrdHJhY2UoSlNDb250ZXh0KiBjdHgsIGNvbnN0IHVpbnQ4X3QqIGN1cl9wYyk7CgpKU1ZhbHVlCmpzX2luc3BlY3Rfc3RhY2t0cmFjZV92YWx1ZShKU0NvbnRleHQqIGN0eCkgewogIEpTUnVudGltZSogcnQgPSBKU19HZXRSdW50aW1lKGN0eCk7CiAgc3RydWN0IEpTU3RhY2tGcmFtZSogZnJhbWU7CiAgSlNWYWx1ZSByZXQgPSBKU19VTkRFRklORUQ7CiAgaWYoKGZyYW1lID0gcnQtPmN1cnJlbnRfc3RhY2tfZnJhbWUpKSB7CiNpZmRlZiBDT05GSUdfREVCVUdHRVIKICAgIHJldCA9IGpzX2RlYnVnZ2VyX2J1aWxkX2JhY2t0cmFjZShjdHgsIGZyYW1lLT5jdXJfcGMpOwojZW5kaWYKICB9CiAgcmV0dXJuIHJldDsKfQoKY29uc3QgY2hhcioKanNfaW5zcGVjdF9zdGFja3RyYWNlKEpTQ29udGV4dCogY3R4KSB7CiAgSlNWYWx1ZSBzdGFjayA9IGpzX2luc3BlY3Rfc3RhY2t0cmFjZV92YWx1ZShjdHgpOwogIHJldHVybiBqc19pbnNwZWN0X3Rvc3RyaW5nKGN0eCwgc3RhY2spOwp9CgpzdGF0aWMgY29uc3QgSlNDRnVuY3Rpb25MaXN0RW50cnkganNfaW5zcGVjdF9mdW5jc1tdID0gewogICAgSlNfQ0ZVTkNfREVGKCJpbnNwZWN0IiwgMSwganNfaW5zcGVjdCksCn07CgpzdGF0aWMgaW50CmpzX2luc3BlY3RfaW5pdChKU0NvbnRleHQqIGN0eCwgSlNNb2R1bGVEZWYqIG0pIHsKICBKU1ZhbHVlIGluc3BlY3QsIGluc3BlY3Rfc3ltYm9sLCBzeW1ib2xfY3RvcjsKCiAgaW5zcGVjdCA9IEpTX05ld0NGdW5jdGlvbihjdHgsIGpzX2luc3BlY3QsICJpbnNwZWN0IiwgMik7CgogIGluc3BlY3Rfc3ltYm9sID0ganNfc3ltYm9sX2ZvcihjdHgsICJxdWlja2pzLmluc3BlY3QuY3VzdG9tIik7CiAgSlNfU2V0UHJvcGVydHlTdHIoY3R4LCBpbnNwZWN0LCAic3ltYm9sIiwgSlNfRHVwVmFsdWUoY3R4LCBpbnNwZWN0X3N5bWJvbCkpOwogIHN5bWJvbF9jdG9yID0ganNfc3ltYm9sX2N0b3IoY3R4KTsKICBKU19TZXRQcm9wZXJ0eVN0cihjdHgsIHN5bWJvbF9jdG9yLCAiaW5zcGVjdCIsIEpTX0R1cFZhbHVlKGN0eCwgaW5zcGVjdF9zeW1ib2wpKTsKCiAgSlNfRnJlZVZhbHVlKGN0eCwgc3ltYm9sX2N0b3IpOwogIEpTX0ZyZWVWYWx1ZShjdHgsIGluc3BlY3Rfc3ltYm9sKTsKCiAgaW5zcGVjdF9jdXN0b21fYXRvbSA9IGpzX2luc3BlY3RfY3VzdG9tX2F0b20oY3R4LCAicXVpY2tqcy5pbnNwZWN0LmN1c3RvbSIpOwogIGluc3BlY3RfY3VzdG9tX2F0b21fbm9kZSA9IGpzX2luc3BlY3RfY3VzdG9tX2F0b20oY3R4LCAibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20iKTsKCiAgaWYobSkgewogICAgSlNfU2V0TW9kdWxlRXhwb3J0TGlzdChjdHgsIG0sIGpzX2luc3BlY3RfZnVuY3MsIGNvdW50b2YoanNfaW5zcGVjdF9mdW5jcykpOwogICAgSlNfU2V0TW9kdWxlRXhwb3J0KGN0eCwgbSwgImRlZmF1bHQiLCBpbnNwZWN0KTsKICB9CgogIHJldHVybiAwOwp9CgojaWYgZGVmaW5lZChKU19TSEFSRURfTElCUkFSWSkgJiYgZGVmaW5lZChKU19JTlNQRUNUX01PRFVMRSkKI2RlZmluZSBKU19JTklUX01PRFVMRSBqc19pbml0X21vZHVsZQojZWxzZQojZGVmaW5lIEpTX0lOSVRfTU9EVUxFIGpzX2luaXRfbW9kdWxlX2luc3BlY3QKI2VuZGlmCgpWSVNJQkxFIEpTTW9kdWxlRGVmKgpKU19JTklUX01PRFVMRShKU0NvbnRleHQqIGN0eCwgY29uc3QgY2hhciogbW9kdWxlX25hbWUpIHsKICBKU01vZHVsZURlZiogbTsKICBtID0gSlNfTmV3Q01vZHVsZShjdHgsIG1vZHVsZV9uYW1lLCBqc19pbnNwZWN0X2luaXQpOwogIGlmKCFtKQogICAgcmV0dXJuIE5VTEw7CiAgSlNfQWRkTW9kdWxlRXhwb3J0TGlzdChjdHgsIG0sIGpzX2luc3BlY3RfZnVuY3MsIGNvdW50b2YoanNfaW5zcGVjdF9mdW5jcykpOwogIEpTX0FkZE1vZHVsZUV4cG9ydChjdHgsIG0sICJkZWZhdWx0Iik7CiAgcmV0dXJuIG07Cn0KAAAAAAAAAADOggAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAmBgAAAAAAACYGAAAAAAAAAAAAAAAACRA"
				]
			]
		}
	],
	"build_system": "Packages/Makefile/Make.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Build all",
					""
				],
				[
					"Build tests",
					""
				],
				[
					"List",
					""
				],
				[
					"Rebuild CTags",
					""
				],
				[
					"clang-format",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				]
			],
			[
				"Packages/Makefile/Make.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"outline",
				"Browse Mode: Outline (Right)"
			],
			[
				"scheme",
				"Color Scheme Editor: Edit current color scheme"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"INSTALL",
				"Package Control: Install Package"
			],
			[
				"out",
				"Browse Mode: Outline (Right)"
			],
			[
				"edit",
				"SchemeEditor: Edit Current Scheme"
			],
			[
				"outlin",
				"Browse Mode: Outline (Right)"
			],
			[
				"",
				"Arithmetic"
			],
			[
				"disable",
				"Package Control: Disable Package"
			],
			[
				"Package Control: disable",
				"Package Control: Disable Package"
			],
			[
				"Package Control: ",
				"Package Control: Disable Package"
			],
			[
				"adap",
				"Debugger: Install Adapters"
			],
			[
				"install ada",
				"Debugger: Install Adapters"
			],
			[
				"adapter",
				"Debugger: Install Adapters"
			],
			[
				"debug",
				"Debugger: Install Adapters"
			],
			[
				"Package Control: remove",
				"Package Control: Remove Package"
			],
			[
				"debu",
				"Debugger: Install Adapters"
			],
			[
				"add re",
				"Package Control: Add Repository"
			],
			[
				"instal",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 393.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/cmake",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests"
	],
	"file_history":
	[
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/cmake/Findpigpio.cmake",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/cmake/FindQuickJS.cmake",
		"/home/roman/Projects/plot-cv/quickjs/quickjs.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-inspect.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/qjsm.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/pigpio/pigpio.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/pigpio/CMakeLists.txt",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/pigpio/README",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/CMakeLists.txt",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/buffer-utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/buffer-utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/char-utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/char-utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-path.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_blob.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_stringdecoder.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_misc.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/pointer.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-predicate.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/child-process.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/path.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/property-enumeration.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-gpio.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/location.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-pointer.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lexer.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lexer.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/predicate.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-location.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-blob.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-blob.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-xml.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-lexer.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-stringdecoder.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-bjson.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/vector.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/vector.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-stringdecoder.h",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-internal.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-pointer.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/ringbuffer.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-archive.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-lexer.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/README.md",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/ringbuffer.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/extendGenerator.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_location.js",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-deep.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-location.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/cmake/QuickJSModule.cmake",
		"/home/roman/Projects/plot-cv/quickjs/cutils.h",
		"/home/roman/Projects/plot-cv/quickjs/cutils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/repl.js",
		"/home/roman/Projects/plot-cv/quickjs/quickjs.c",
		"/home/roman/Sources/plot-cv/quickjs/quickjs-libc.h",
		"/home/roman/Sources/plot-cv/quickjs/quickjs-libc.c",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/lib/util.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/extendArray.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/util.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/console.js",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-libc.h",
		"/home/roman/Sources/plot-cv/quickjs/qjs-modules/quickjs-libc.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/fs.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/tty.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_xml.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/gpio.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-gpio.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/stack.js",
		"/home/roman/Projects/plot-cv/quickjs/modules/utils.h",
		"/home/roman/Projects/plot-cv/quickjs/modules/qjsm.c",
		"/home/roman/Projects/plot-cv/quickjs/modules/lib/fs.js",
		"/home/roman/Projects/plot-cv/quickjs/modules/pigpio/pigpiod_if2.h",
		"/home/roman/Projects/plot-cv/quickjs/modules/pigpio/pigpio.h",
		"/home/roman/Projects/plot-cv/quickjs/modules/CMakeLists.txt",
		"/home/roman/Projects/plot-cv/test-gpio.js",
		"/home/roman/Projects/plot-cv/quickjs/modules/gpio.c",
		"/home/roman/Projects/plot-cv/quickjs/modules/gpio.h",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-gpio.h",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-predicate.c",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-path.c",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-repeater.c",
		"/home/roman/Projects/plot-cv/quickjs/modules/cmake/functions.cmake",
		"/home/roman/Projects/plot-cv/quickjs/modules/cmake/Findpigpio.cmake",
		"/home/roman/Sources/plot-cv/quickjs/modules/CMakeLists.txt",
		"/home/roman/Projects/plot-cv/quickjs/modules/cmake/FindQuickJS.cmake",
		"/home/roman/Projects/plot-cv/quickjs/modules/cmake/QuickJSModule.cmake",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-gpio.c",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-misc.c",
		"/home/roman/Projects/plot-cv/test-archive.js",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-archive.h",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-location.c",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-lexer.c",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-archive.c",
		"/home/roman/Projects/plot-cv/quickjs/modules/vector.c",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-inspect.c",
		"/home/roman/Sources/plot-cv/quickjs/modules/utils.h",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-internal.h",
		"/home/roman/Projects/plot-cv/quickjs/modules/utils.c",
		"/usr/include/archive_entry.h",
		"/usr/include/archive.h",
		"/home/roman/Sources/plot-cv/quickjs/modules/utils.c",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry.h",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry.c",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry.3",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_acl.3",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_copy_bhfi.c",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_copy_stat.c",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_link_resolver.c",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_linkify.3",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_locale.h",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_misc.3",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_paths.3",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_perms.3",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_private.h",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_sparse.c",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_stat.3",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_stat.c",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_strmode.c",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_time.3",
		"/home/roman/Projects/zip-lib/libarchive/libarchive/archive_entry_xattr.c",
		"/home/roman/Projects/plot-cv/quickjs/modules/lib/repl.js",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-sockets.c",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-bjson.c",
		"/home/roman/Projects/plot-cv/quickjs/modules/quickjs-child-process.c"
	],
	"find":
	{
		"height": 40.0
	},
	"find_in_files":
	{
		"height": 130.0,
		"where_history":
		[
			"/home/roman/Sources/plot-cv/quickjs/qjs-modules,*.c,*.h,*.js,-*/build/*,*.cmake,CMakeLists.txt",
			"/home/roman/Sources/plot-cv/quickjs/modules,*.c,*.h,*.js,-*/build/*,*.cmake,CMakeLists.txt",
			"/home/roman/Sources/plot-cv/quickjs/modules,*.c,*.h,*.js,*.cmake,CMakeLists.txt",
			"/home/roman/Sources/plot-cv/quickjs/modules,*.c,*.h,*.js",
			"/home/roman/Sources/plot-cv/quickjs,*.c,*.h,*.js",
			"/home/roman/Sources/plot-cv/quickjs/modules,*.c,*.h,*.js"
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"jsm_load_script",
			"jsm_eval_file",
			"jsm_eval_str",
			"^\\s+jsm_eval",
			"jsm_eval",
			"jsm_eval_str",
			"jsm_eval_buf",
			"inspect_options_obj",
			"getters",
			"dbuf_free",
			"blob_write",
			"js_is_array",
			"finalize",
			"jsm_module_find",
			"jsm_std_dump_error",
			"add_lib",
			"SHARED_LIBS",
			"libwebsockets",
			"Findpig",
			"token_length",
			"STRING_UTILS",
			"utils.c utils.h",
			"utils.c utils.h buffer-utils.c buffer-utils.h",
			"dbuf_",
			"(InputBuffer|MemoryBlock|PointerRange|OffsetLength|Buffer)",
			"(InputBuffer|MemoryBlock|PointerRange|OffsetLength)",
			"(InputBuffer|MemoryBlock)",
			"input_skip",
			"ol->",
			"get_offset",
			"get_offset_length",
			"get_off",
			"get_offset_length",
			"struct off",
			"MIN_NUM",
			"block_range",
			"offset_offset",
			"JS_DupValue",
			"JS_NewArrayBuffer",
			"input_buffer_free_default",
			"\\.length",
			"\\.offset",
			"printf",
			"put_escaped",
			"vector_free",
			"input_buffer_free",
			"InputBuffer",
			"js_input_buffer",
			"peekc",
			"max\\(",
			"in->size",
			"in->data",
			"->data",
			"in->data",
			"InputBuf",
			"js_is_map",
			"is_",
			"js_is_typedarray",
			"js_input_buf",
			"is_typedarray",
			"is_typed",
			"JS_ThrowOutOfMemory",
			"pointer",
			"fromvalue",
			"js_arraybuffer_length",
			"arrayb",
			"js_bytecode_free_func",
			"JS_NewArrayBuffer\\(",
			"js_tostring",
			"location",
			"->buffer",
			"vector_alloc",
			"AtomTo",
			"decoder",
			"js_misc",
			"JS_AddModuleExport",
			"ModuleExport",
			"js_location_init",
			"StringDecoder",
			"utf8",
			"InputBuffer",
			"r->r([^a-z])",
			"r->r",
			"realloc",
			"once",
			"memoize",
			"once",
			" fs\\.",
			"fs\\.",
			"fs =",
			"waitRead",
			"fs",
			"location",
			"loc",
			"stringdecoder_write",
			"misc",
			"location_SOU",
			"location",
			"misc",
			"js_stringdecoder_setter",
			"js_stringdecoder_getter",
			"location",
			"js_std_error_props",
			"\"Error\"",
			"InputBuffer",
			"extendArray",
			"extendArra",
			"'<'",
			"flushSync",
			"openSync",
			"fopen",
			"readF",
			"\\.so",
			"str_end",
			"debug_mod",
			"flushSync",
			"flush",
			"CONFIG_PREFIX",
			"^(\\s*)fprintf",
			"QUICKJS_PREFIX",
			"struct GPIO",
			"GPIO",
			"GPIO\\*",
			"entry",
			"JS_GetRuntime\\(ctx\\)",
			"JS_GetRuntime",
			"js_class_id",
			"^js_cstring_free"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"pigpio",
			"CHAR_UTILS",
			"${util_SOURCES}",
			"ol.",
			"range_from",
			".range.length",
			".range.offset",
			"input_buffer_length(in)",
			"input_buffer_data(in)",
			"blob",
			"location->vec",
			"location",
			"Location",
			"r->data\\1",
			" this.fs.",
			"stringdecoder",
			"js_stringdecoder_set",
			"js_stringdecoder_get",
			"stringdecoder",
			"\\1if(gpio->debug) fprintf",
			"struct gpio",
			"struct GPIO",
			"struct GPIO*",
			"ctx->rt",
			"",
			": ",
			"\"",
			"ret = \\1;",
			"->errnum",
			"(",
			"error",
			"JS_NewInt32",
			"",
			",",
			"left, right",
			"predicate_nextarg(ctx, &args)",
			"predicate_nextarg(ctx, &args),predicate_nextarg(ctx, &args))",
			"predicate_argument_shift(ctx, &args)",
			"js_arguments_shift(&args)",
			"",
			"ret = PRECEDENCE_",
			"args",
			"",
			"dbuf",
			": left",
			"pred",
			"args->",
			"r",
			"predicate_value",
			"",
			"'x'",
			"0",
			"\\1this.last_cmd",
			"\\1this.cmd",
			"level",
			"cmd",
			"  ",
			"",
			"\\1this.prompt",
			"",
			" globalThis.",
			"evalAnd",
			"commands",
			"",
			"handlers",
			"events",
			"this.",
			"\\1",
			"listeners",
			"events",
			"\\1",
			"jsm_pending_signals",
			"jsm_module_native",
			"js_pointer_data(ctx, obj)",
			"ShiftPredicate",
			".buf",
			"\\1",
			"file.close",
			"std.open",
			"js_misc_free_arraybuffer",
			"JS_SetPropertyStr",
			"jsm_load_module",
			"",
			"_?",
			"sockets",
			"qjsc_perf_hooks",
			"output->",
			"output",
			"\\1//printf",
			"",
			"sizeSync",
			"CreateOperatorSet",
			"",
			"loc",
			"location",
			"loc->",
			"jsm_load_package_json",
			"tmp",
			"    ",
			"  ",
			"BOOL\\njs_is_",
			"GeneratorPrototype",
			"SetIteratorPrototype",
			"MapIteratorPrototype",
			"hasBuiltIn",
			"hbiTs",
			"sSl",
			"ccAt",
			"formatNumber(",
			"isObject(value) && ",
			"pointer_toarray( ptr, ctx)",
			"moduleStack.size",
			"require('${m}')",
			"globalThis.code ?? 'C'",
			"code",
			"fs.",
			"jsm_load_script",
			"jsm_load_file",
			"require.",
			"dirname",
			"dir",
			"script",
			"this.id",
			"jsm_std_dump_error",
			"if(",
			"",
			")",
			""
		],
		"reverse": false,
		"scrollbar_highlights": true,
		"show_context": true,
		"use_buffer2": true,
		"use_gitignore": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"sheets":
			[
				{
					"buffer": 0,
					"selected": true,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 714,
						"regions":
						{
						},
						"selection":
						[
						],
						"settings":
						{
							"current_file": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-blob.c",
							"outline_rename_mode": false,
							"symkeys":
							[
								[
									28,
									39
								],
								[
									128,
									131
								],
								[
									403,
									412
								],
								[
									623,
									631
								],
								[
									836,
									846
								],
								[
									1002,
									1011
								],
								[
									1129,
									1141
								],
								[
									1260,
									1270
								],
								[
									1435,
									1452
								],
								[
									1532,
									1544
								],
								[
									1709,
									1720
								],
								[
									1933,
									1944
								],
								[
									2324,
									2343
								],
								[
									4567,
									4581
								],
								[
									5755,
									5770
								],
								[
									6205,
									6222
								],
								[
									7012,
									7024
								],
								[
									7883,
									7897
								],
								[
									7927,
									7941
								]
							],
							"symlist":
							[
								"\tⓂ  _GNU_SOURCE … — macro object",
								"—Ⓜ– max ( ) … — macro function",
								"—Ⓕ– blob_init ( ) { … } — function",
								"—Ⓕ– blob_new ( ) { … } — function",
								"—Ⓕ– blob_write ( ) { … } — function",
								"—Ⓕ– blob_free ( ) { … } — function",
								"—Ⓕ– blob_free_rt ( ) { … } — function",
								"—Ⓕ– blob_input ( ) { … } — function",
								"—Ⓕ– js_blob_free_func ( ) { … } — function",
								"—Ⓕ– js_blob_wrap ( ) { … } — function",
								"—Ⓕ– js_blob_new ( ) { … } — function",
								"—Ⓕ– js_blob_get ( ) { … } — function",
								"—Ⓕ– js_blob_constructor ( ) { … } — function",
								"—Ⓕ– js_blob_method ( ) { … } — function",
								"—Ⓕ– js_blob_inspect ( ) { … } — function",
								"—Ⓕ– js_blob_finalizer ( ) { … } — function",
								"—Ⓕ– js_blob_init ( ) { … } — function",
								"\tⓂ  JS_INIT_MODULE … — macro object",
								"\tⓂ  JS_INIT_MODULE … — macro object"
							],
							"syntax": "Packages/Outline/outline.hidden-tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1630256923.44,
							"tabs_extra_last_activated_sheet_index": 0,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"stack_multiselect": false,
					"type": "text"
				}
			]
		},
		{
			"sheets":
			[
				{
					"buffer": 1,
					"file": "quickjs-blob.c",
					"selected": true,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8279,
						"regions":
						{
						},
						"selection":
						[
							[
								8151,
								8227
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1630270176.31,
							"tabs_extra_last_activated_sheet_index": 0,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5529.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "qjsm.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 40565,
						"regions":
						{
						},
						"selection":
						[
							[
								18256,
								18271
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1630257560.48,
							"tabs_extra_last_activated_sheet_index": 1,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 12345.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "vector.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6717,
						"regions":
						{
						},
						"selection":
						[
							[
								488,
								500
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1630257560.96,
							"tabs_extra_last_activated_sheet_index": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "vector.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3762,
						"regions":
						{
						},
						"selection":
						[
							[
								904,
								904
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1630257561.54,
							"tabs_extra_last_activated_sheet_index": 3,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 394.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/home/roman/Projects/plot-cv/quickjs/cutils.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7403,
						"regions":
						{
						},
						"selection":
						[
							[
								5811,
								5811
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 4,
							"tabs_extra_last_activated": 1630255533.08,
							"tabs_extra_last_activated_sheet_index": 3,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4213.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/home/roman/Projects/plot-cv/quickjs/cutils.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17551,
						"regions":
						{
						},
						"selection":
						[
							[
								5003,
								5003
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 4,
							"tabs_extra_last_activated": 1630255506.6,
							"tabs_extra_last_activated_sheet_index": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3529.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "utils.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 26821,
						"regions":
						{
						},
						"selection":
						[
							[
								24520,
								24531
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1630255430.57,
							"tabs_extra_last_activated_sheet_index": 5,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 14530.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "tests/test_blob.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1715,
						"regions":
						{
						},
						"selection":
						[
							[
								430,
								430
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1630257122.05,
							"tabs_extra_last_activated_sheet_index": 7,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10207,
						"regions":
						{
						},
						"selection":
						[
							[
								2759,
								2759
							]
						],
						"settings":
						{
							"syntax": "Packages/User/Themes/CMake.sublime-syntax",
							"tab_size": 2,
							"tabs_extra_last_activated": 1630257558.96,
							"tabs_extra_last_activated_sheet_index": 8,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 684.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "/home/roman/Projects/plot-cv/quickjs/quickjs.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1773399,
						"regions":
						{
						},
						"selection":
						[
							[
								99681,
								99681
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 4,
							"tabs_extra_last_activated": 1630256791.94,
							"tabs_extra_last_activated_sheet_index": 8,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 56064.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "quickjs-inspect.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 33486,
						"regions":
						{
						},
						"selection":
						[
							[
								7050,
								7063
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1630256789.9,
							"tabs_extra_last_activated_sheet_index": 9,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4232.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"stack_multiselect": false,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 40.0
	},
	"input":
	{
		"height": 42.0
	},
	"layout":
	{
		"cells":
		[
			[
				2,
				0,
				3,
				2
			],
			[
				0,
				0,
				2,
				2
			]
		],
		"cols":
		[
			0.0,
			0.2,
			0.8,
			1.0
		],
		"rows":
		[
			0.0,
			0.5,
			1.0
		]
	},
	"menu_visible": true,
	"output.Debugger":
	{
		"height": 139.0
	},
	"output.exec":
	{
		"height": 120.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.unsaved_changes":
	{
		"height": 108.0
	},
	"pinned_build_system": "",
	"project": "modules.sublime-project",
	"replace":
	{
		"height": 72.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"qjsm.c",
				"qjsm.c"
			],
			[
				"quickjs-ins",
				"quickjs-inspect.c"
			],
			[
				"utils.h",
				"utils.h"
			],
			[
				"quickjs-in",
				"quickjs-inspect.c"
			],
			[
				"utils.c",
				"utils.c"
			],
			[
				"qjsm",
				"qjsm.c"
			],
			[
				"quickjs-blo",
				"quickjs-blob.c"
			],
			[
				"cmake",
				"CMakeLists.txt"
			],
			[
				"test_mis",
				"tests/test_misc.js"
			],
			[
				"test_blob",
				"tests/test_blob.js"
			],
			[
				"test_string",
				"tests/test_stringdecoder.js"
			],
			[
				"test_str",
				"tests/test_stringdecoder.js"
			],
			[
				"quickjs-blb",
				"quickjs-blob.h"
			],
			[
				"vector.h",
				"vector.h"
			],
			[
				"ringbuffer.h",
				"ringbuffer.h"
			],
			[
				"quickjs.h",
				"~/Projects/plot-cv/quickjs/quickjs.h"
			],
			[
				"util.js",
				"lib/util.js"
			],
			[
				"repl.js",
				"lib/repl.js"
			],
			[
				"quickjsmo",
				"cmake/QuickJSModule.cmake"
			],
			[
				"inspe",
				"quickjs-inspect.c"
			],
			[
				"misc",
				"quickjs-misc.c"
			],
			[
				"deep",
				"quickjs-deep.c"
			],
			[
				"terminal.",
				"lib/terminal.js"
			],
			[
				"tty.js",
				"lib/tty.js"
			],
			[
				"quickjs-lex",
				"quickjs-lexer.c"
			],
			[
				"intern",
				"quickjs-internal.h"
			],
			[
				"test_chil",
				"tests/test_childprocess.js"
			],
			[
				"pointer.h",
				"pointer.h"
			],
			[
				"stack",
				"lib/stack.js"
			],
			[
				"",
				"tests/test_qjsm.js"
			],
			[
				"test_misc",
				"tests/test_misc.js"
			],
			[
				"quickjs-misc",
				"quickjs-misc.c"
			],
			[
				"test_lex",
				"tests/test_lexer.js"
			],
			[
				"fs.js",
				"lib/fs.js"
			],
			[
				"quickjs.c",
				"~/Projects/plot-cv/quickjs/quickjs.c"
			],
			[
				"pointer.c",
				"pointer.c"
			],
			[
				"-insp",
				"quickjs-inspect.c"
			],
			[
				"test_op",
				"tests/test_op_overloading.js"
			],
			[
				"lexer.c",
				"lexer.c"
			],
			[
				"quickjs-lexer",
				"quickjs-lexer.c"
			],
			[
				"test_qjs",
				"tests/test_qjsm.js"
			],
			[
				"quickjs-pre",
				"quickjs-predicate.c"
			],
			[
				"pred",
				"predicate.c"
			],
			[
				"dee",
				"quickjs-deep.c"
			],
			[
				"qjsm.",
				"qjsm.c"
			],
			[
				"test_qj",
				"tests/test_qjsm.js"
			],
			[
				"quicksj-in",
				"quickjs-internal.h"
			],
			[
				"property",
				"property-enumeration.c"
			],
			[
				"pointer.",
				"pointer.c"
			],
			[
				"quickjs",
				"quickjs-inspect.c"
			],
			[
				"util.j",
				"lib/util.js"
			],
			[
				"jsm.c",
				"qjsm.c"
			],
			[
				"test_point",
				"tests/test_pointer.js"
			],
			[
				"bnflex",
				"lib/bnflexer.js"
			],
			[
				"bnf.y",
				"~/Projects/plot-cv/lib/grammars/bnf.y"
			],
			[
				"test_par",
				"tests/test_parser.js"
			],
			[
				"grammar.ki",
				"grammar.kison"
			],
			[
				"test_pat",
				"tests/test_path.js"
			],
			[
				"exten",
				"lib/extendArray.js"
			],
			[
				"test_parse",
				"tests/test_parser.js"
			],
			[
				"test_path",
				"tests/test_path.js"
			],
			[
				"test_lexer",
				"tests/test_lexer.js"
			],
			[
				"lexer.h",
				"lexer.h"
			],
			[
				"test_tree",
				"tests/test_treewalker.js"
			],
			[
				"tree.h",
				"src/tree.h"
			],
			[
				"scan_ulongn",
				"lib/scan/scan_ulongn.c"
			],
			[
				"term_rest",
				"src/term/term_restore.c"
			],
			[
				"parse.h",
				"src/parse.h"
			],
			[
				"cmakeli",
				"CMakeLists.txt"
			],
			[
				"byte.h",
				"lib/byte.h"
			],
			[
				"buffer.h",
				"lib/buffer.h"
			],
			[
				"shell.h",
				"lib/shell.h"
			],
			[
				"mmap_file",
				"lib/stralloc/mmap_filename.c"
			],
			[
				"uffer.h",
				"lib/buffer.h"
			],
			[
				"scan.h",
				"lib/scan.h"
			],
			[
				"stralloc.h",
				"lib/stralloc.h"
			],
			[
				"path.h",
				"lib/path.h"
			],
			[
				"str.h",
				"lib/str.h"
			],
			[
				"scan.",
				"lib/scan.h"
			],
			[
				"debug_char",
				"src/debug/debug_char.c"
			],
			[
				"source_pop",
				"src/source/source_pop.c"
			],
			[
				"builtin.h",
				"src/builtin.h"
			],
			[
				"debug_node",
				"src/debug/debug_node.c"
			],
			[
				"sig_in",
				"lib/sig_internal.h"
			],
			[
				"term_",
				"src/term/term_attr.c"
			],
			[
				"glob.h",
				"lib/glob.h"
			],
			[
				"source.h",
				"src/source.h"
			],
			[
				"fdtable",
				"src/fdtable.h"
			],
			[
				"fd.h",
				"src/fd.h"
			],
			[
				"eval",
				"src/eval.h"
			],
			[
				"ieee",
				"doc/posix/ieee-p1003.2-d11.2-s3.txt"
			],
			[
				"expand.h",
				"src/expand.h"
			],
			[
				"builtin_dum",
				"src/builtin/builtin_dump.c"
			],
			[
				"h_main",
				"src/sh/sh_main.c"
			],
			[
				"parse_cha",
				"src/parse/parse_chartable.c"
			],
			[
				"debug.h",
				"src/debug.h"
			],
			[
				"exec_c",
				"src/exec/exec_command.c"
			],
			[
				"eval.h",
				"src/eval.h"
			],
			[
				"test-op",
				"test-operators.js"
			],
			[
				"filesys",
				"lib/filesystem.js"
			],
			[
				"repl.",
				"repl.js"
			],
			[
				"test-str",
				"plot-cv/quickjs/modules/test-str0.c"
			],
			[
				"property-en",
				"plot-cv/quickjs/modules/property-enumeration.h"
			],
			[
				"cutil",
				"plot-cv/quickjs/cutils.c"
			],
			[
				"test-libre",
				"plot-cv/quickjs/modules/test-libregexp.c"
			],
			[
				"clang-as",
				"plot-cv/clang-ast.js"
			],
			[
				"repl",
				"plot-cv/repl.js"
			],
			[
				"consoleS",
				"plot-cv/lib/consoleSetup.js"
			],
			[
				"test-ed",
				"plot-cv/test-editline.js"
			],
			[
				"gl.js",
				"plot-cv/gl.js"
			],
			[
				"editline",
				"plot-cv/editline.js"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"~/Projects/plot-cv/plot-cv.sublime-project"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 370.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"WS"
			]
		],
		"width": 970.0
	},
	"selected_group": 1,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 251.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
